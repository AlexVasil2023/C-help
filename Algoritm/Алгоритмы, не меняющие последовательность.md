# Алгоритмы, не меняющие последовательность C++11


| Название     | синтаксис                                                                                                                                                                                                                                                                                                                                                                                                                     | Пояснение                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **for_each** | template <class InputIterator,<br>class Function> Function<br>for_each(InputIterator ?rst,<br>InputIterator last, Function f);                                                                                                                                                                                                                                                                                                | for_each применяет f к результату<br>разыменования каждого итератора в<br>диапазоне [first, last] и возвращает f.<br>Принято, что f не применяет какую-то<br>непостоянную функцию к разыменованному<br>итератору. f применяется точно last-first раз.<br>Если f возвращает результат, результат<br>игнорируется.                                                                                                                                                                                                                                                                             |
| **find**     | template <class InputIterator, class<br>T> InputIterator find(InputIterator<br>first, InputIterator last, const T& value); template <class InputIterator,<br>class Predicate> InputIterator<br>find_if(InputIterator first, InputIterator<br>last, Predicate pred);                                                                                                                                                           | find возвращает первый итератор i в<br>диапазоне [first, last], для которого<br>соблюдаются следующие соответствующие<br>условия: * i == value, pred (*i) == true. Если<br>такой итератор не найден, возвращается last. Соответствующий предикат применяется<br>точно find(first, last, value) - first раз.                                                                                                                                                                                                                                                                                  |
| **count**    | template <class InputIterator, class<br>T> typename iterator_traits<InputIterator>::difference_type count (InputIterator first, InputIterator last, const T& val);<br>template <class InputIterator, class Predicate> typename iterator_traits<InputIterator>::differen<br>ce_type count_if (InputIterator first, InputIterator last, UnaryPredicate pred);                                                                   | count подсчитывает число итераторов i в диапазоне [first, last], для которых соблюдаются следующие соответствующие условия: \*i == value, pred (\*i) == true. Соответствующий<br>предикат применяется точно last-first раз.                                                                                                                                                                                                                                                                                                                                                                  |
| **equal**    | template <class InputIterator1, class InputIterator2> bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2); template <class InputIterator1, class InputIterator2, class BinaryPredicate> bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred);                                                                                               | equal возвращает true, если для каждого итератора i в диапазоне [first1, last1] выполнены следующие соответствующие условия: \*i == \*(first2 + (i - first1)), binary_pred(\*i, \*(first2 + (i - first1))) == true. Иначе equal возвращает false. Соответствующий предикат применяется, самое большее, last1 - first1 раз.                                                                                                                                                                                                                                                                   |
| **search**   | template <class ForwardIterator1, class ForwardIterator2> ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2); template <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate> ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate binary_pred); | search находит подпоследовательность равных значений в последовательности. search возвращает первый итератор i в диапазоне [first1, last1 - (last2 - first2)] такой, что для любого неотрицательного целого числа n, меньшего чем last2 - first2, выполнены следующие соответствующие условия: \*(i + n) == \*(first2 + n), binary_pred(\*(i + n), \*(first2 + n)) == true. Если такой итератор не найден, возвращается last1. Соответствующий предикат применяется, самое большее, (last1 - first1) \* (last2 - first2) раз. Квадратичное поведение, однако, является крайне маловероятным. |


