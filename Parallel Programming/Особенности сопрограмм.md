
[[#Особенности сопрограмм|Особенности сопрограмм]]
1. [[#Типичные сценарии использования|Типичные сценарии использования]] 5.2.1
2. [[#Разновидности сопрограмм|Разновидности сопрограмм]] 5.2.2
3. [[#Требования к сопрограммам|Требования к сопрограммам]] 5.2.3
4. [[#Преобразование функции в сопрограмму|Преобразование функции в сопрограмму]] 5.2.4
5. [[#Ограничения|Ограничения]] 5.2.5

# Особенности сопрограмм

Сопрограммы обладают рядом уникальных особенностей.

## Типичные сценарии использования

Сопрограммы часто применяются для создания приложений, управляемых событиями, к которым относятся системы имитационного моделирования, игры, серверы, интерфейсы пользователя или даже некоторые алгоритмы обработки больших потоков данных. Сопрограммы также часто используют для реализации кооперативной многозадачности. Суть её состоит в том, что множество задач могут выполняться на одном процессоре или ядре, но их выполнение чередуется таким образом, чтобы создавать иллюзию параллельной работы; при этом каждая из множества совместно выполняемых задач берёт себе столько процессорного времени, сколько сама сочтёт нужным, однако обязуется за конечное время отдать управление, тем самым позволив другим задачам продолжить свою работу. Этим кооперативная многозадачность отличается от вытесняющей, при которой планировщик решает, на какой промежуток времени предоставить процессор той или иной задаче, и принудительно забирает у неё доступ к процессору по истечении этого
времени.

Существует несколько разновидностей сопрограмм, которые следует разобрать отдельно.

## Разновидности сопрограмм

Среди сопрограмм, как они определены в стандарте C++20, можно выделить частные случаи: по способу передачи управления – симметричные и асимметричные, по способу представления в языке – «первого класса» и некоторые ограниченные языковые конструкции, по способу локализации внутреннего состояния – обладающие и не обладающие стеком.

Обращение к асимметричной сопрограмме возвращает управление вызывающему коду, тогда как симметричная сопрограмма может делегировать выполнение другой сопрограмме.

Сопрограммы первого класса выглядят подобно функциям и ведут себя подобно данным. Последнее означает, что их можно использовать в качестве аргументов или возвращаемых значений функций, а также сохранять в переменных.

Если сопрограмма не пользуется стеком, её выполнение можно приостанавливать и возобновлять. При этом управление и выработанное значение передаются вызвавшему коду. Такие сопрограммы должны хранить своё состояние для последующего возобновления за пределами стека. Сопрограммы без стека часто называют возобновляемыми.

## Требования к сопрограммам

Гор Нишанов в документе N44021 так описывает требования, которыми руководствовались при разработке механизма сопрограмм:

>* высокая масштабируемость (возможность одновременной работы миллиардов сопрограмм);
>* высокая эффективность приостановок и возобновлений по сравнению с накладными расходами на вызов функции;
>* удобное взаимодействие с прочими элементами языка без дополнительных усилий;
>* открытость программного интерфейса, позволяющая разрабатывать библиотеки сопрограмм, предоставляющие разнообразные высокоуровневые средства, такие как генераторы, «горутины» (англ. goroutines), задания и многое другое;
>* возможность использования в средах, где механизм исключений запрещён или недоступен.

Требованиям масштабируемости и лёгкой интеграции с существующими средствами языка лучше всего удовлетворяют сопрограммы без стека. Для сопрограммы со стеком выделяется по умолчанию 1 МБ памяти на ОС Windows и 2 МБ на ОС Linux.

Обычную функцию можно преобразовать в сопрограмму четырьмя способами.

## Преобразование функции в сопрограмму

Функция становится сопрограммой, если в ней используется хотя бы одна из следующих конструкций:

> - ключевое слово `co_return`;
> - ключевое слово `co_await`;
> - ключевое слово `co_yield`;
> - выражение `co_await` в цикле по диапазону.

> **Различие между фабрикой сопрограмм и объектом-сопрограммой:**
> 
> Термин «сопрограмма» часто используется в двух различных смыслах: с одной стороны, его применяют к функциям, в которых используются ключевые слова `co_return`, `co_await` и `co_yield`, а с другой – к объекту-сопрограмме. Использование одного и того же слова для обозначения двух различных явлений может сбить читателя с толку (как в своё время сбило автора этой книги). Следует прояснить оба термина. Рассмотрим код.

**Простая сопрограмма, возвращающая значение 2001:**
```c++
MyFuture<int> createFuture() {
	co_return 2021;
}

int main() {
	auto fut = createFuture();
	std::cout << “fut.get(): “ << fut.get() << ‘\n’;
}
```

В этом примере фигурируют функция `createFuture` и возвращаемый ею объект типа `MyFuture<int>`. Оба называют сопрограммами. Говоря более точно, функция `createFuture` – это фабрика сопрограмм, которая возвращает объект-сопрограмму. Объект-сопрограмма инкапсулирует приостанавливаемое и возобновляемое вычисление, реализует определённую концептуальную модель и обладает определённым в этой модели поведением. Ниже, в разделе, посвящённом оператору `co_return`, будет подробно рассказано о внутреннем устройстве и использовании этой элементарной сопрограммы.

## Ограничения

Сопрограммы не могут содержать оператор `return`. Тип возвращаемого значения сопрограммы не может быть оставлен на волю компилятора. Это касается как неограниченного вывода типа (ключевое слово `auto`), так и ограниченного посредством концептов (англ. concept).

Кроме того, в сопрограммы не могут быть преобразованы функции с произвольным числом аргументов, объявленные со спецификаторами [[constexpr|constexpr]] и [[consteval|consteval]], конструкторы, деструкторы, а также главная функция программы.



