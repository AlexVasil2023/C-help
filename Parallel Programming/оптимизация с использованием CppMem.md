
[[#Поэтапная оптимизация с использованием инструмента CppMem|Поэтапная оптимизация с использованием инструмента CppMem]] 6.3
1. [[#Неатомарные переменные|Неатомарные переменные]] 6.3.1
	1. [[#Анализ программы|Анализ программы]] 6.3.1.1
		1. [[#Первый вариант выполнения|Первый вариант выполнения]] 6.3.1.1.1
		2. [[#Второй вариант выполнения|Второй вариант выполнения]] 6.3.1.1.2
		3. [[#Третий вариант выполнения|Третий вариант выполнения]] 6.3.1.1.3
		4. [[#Четвёртый вариант выполнения|Четвёртый вариант выполнения]] 6.3.1.1.4
		5. [[#Выводы|Выводы]] 6.3.1.1.5
2. [[#Анализ программы с блокировкой|Анализ программы с блокировкой]] 6.3.2
3. [[#Атомарные переменные с последовательной согласованностью|Атомарные переменные с последовательной согласованностью]] 6.3.3
	1. [[#Анализ программы инструментом CppMem|Анализ программы инструментом CppMem]] 6.3.3.1
		1. [[#Вариант выполнения для y = 0, x = 0|Вариант выполнения для y = 0, x = 0]] 6.3.3.1.1
		2. [[#Варианты выполнения для y = 0, x = 2000|Варианты выполнения для y = 0, x = 2000]] 6.3.3.1.2
		3. [[#Вариант выполнения для y = 11, x = 2000|Вариант выполнения для y = 11, x = 2000]] 6.3.3.1.3
	2. [[#Последовательность операций|Последовательность операций]] 6.3.3.2
4. [[#Атомарные переменные с семантикой захвата и освобождения|Атомарные переменные с семантикой захвата и освобождения]] 6.3.4
	1. [[#Анализ программы инструментом CppMem 2|Анализ программы инструментом CppMem]] 6.3.4.1
		1. [[#Возможные варианты выполнения|Возможные варианты выполнения]] 6.3.4.1.1
		2. [[#Вариант выполнения для случая y = 0, x = 0|Вариант выполнения для случая y = 0, x = 0]] 6.3.4.1.2
		3. [[#Вариант выполнения для случая y = 0, x = 2000|Вариант выполнения для случая y = 0, x = 2000]] 6.3.4.1.3
		4. [[#Вариант выполнения для случая y = 11, x = 2000|Вариант выполнения для случая y = 11, x = 2000]] 6.3.4.1.4
5. [[#Смесь атомарных и неатомарных переменных|Смесь атомарных и неатомарных переменных]] 6.3.5
	1. [[#Анализ программы инструментом CppMem 3|Анализ программы инструментом CppMem]] 6.3.5.1
6. [[оптимизация с использованием CppMem#Атомарные переменные с ослабленной семантикой|Атомарные переменные с ослабленной семантикой]] 6.3.6
	1. [[#Анализ инструментом CppMem 4|Анализ инструментом CppMem]] 6.3.6.1

# Поэтапная оптимизация с использованием инструмента CppMem

В этом разделе начнём с небольшой программы и будем последовательно улучшать её. Каждый этап её совершенствования будем проверять на анализаторе `CppMem`. `CppMem` представляет собой интерактивный инструмент для исследования того, как небольшие участки кода работают в модели памяти C++.

**Ниже представлен начальный вариант программы:**
```c++
// ongoingOptimisation.cpp

#include <iostream>
#include <thread>

int x = 0;
int y = 0;

void writing() {
	x = 2000;
	y = 11;
}

void reading() {
	std::cout << “y: “ << y << “ “;
	std::cout << “x: “ << x << std::endl;
}

int main() {
	std::thread thread1(writing);
	std::thread thread2(reading);

	thread1.join();
	thread2.join();
}
```

Эта программа устроена весьма просто. Она состоит из двух потоков, `thread1` и `thread2`. Поток `thread1` присваивает значения переменным `x` и `y`, а поток `thread2` вычитывает эти значения в обратном порядке. Принцип работы программы кажется очевидным, но даже столь простая программа может давать три различных результата, как свидетельствует следующий рисунок.

![[ParallelProg_154.png]]

Приступая к поэтапной оптимизации этой программы, нужно иметь в виду два вопроса:
1.	Обладает ли эта программа хорошо определённым поведением? В частности, присутствует ли в ней гонка данных?
2. Какие значения могут принимать переменные `x` и `y`?

На первый из этих вопросов обычно бывает сложно ответить. В первую очередь подумаем над этим вопросом, а затем проверим свои рассуждения с помощью инструмента `CppMem`. Когда ответ на первый вопрос будет найден, из него сам собой получится ответ и на второй вопрос. Возможные значения переменных `x` и `y` можно будет представить в виде таблицы.

Между прочим, следует ещё пояснить, что здесь имеется в виду под пошаговой оптимизацией. Это довольно просто: нам предстоит оптимизировать программу, с каждым разом всё более ослабляя порядок доступа к памяти.

Полный список шагов по оптимизации программы будет таким:
1) неатомарные переменные;
2) синхронизация на основе блокировщика;
3) атомарные переменные с последовательной согласованностью;
4) атомарные переменные с семантикой захвата и освобождения;
5) атомарные переменные с ослабленной семантикой;
6) переменные с квалификатором [[volatile|volatile]].

Прежде чем начать поэтапную оптимизацию программы, нужно получить хотя бы начальное представление об инструменте `CppMem`. 

## Неатомарные переменные

Одного нажатия на кнопку `Run` в окне `CppMem` достаточно, чтобы убедиться в наличии гонки данных. Если точнее, в программе есть даже две гонки данных. Не защищен доступ ни к переменной `x`, ни к переменной `y`. Как следствие программа в целом обладает неопределённым поведением. О такой программе можно сказать, что она обладает семантикой русской рулетки: в результате её работы может произойти что угодно, даже самоуничтожение компьютера. Поэтому мы не можем строить никаких предположений о значениях переменных `x` и `y`.

> **Гарантии для целочисленных переменных**
> 
> В большинстве распространённых архитектур гарантируется атомарность доступа к переменным типа `int`, при условии что эти переменные выровнены в памяти естественным образом. Естественным в 32-битных или 64-битных архитектурах называется выравнивание, при котором адрес переменной типа `int` кратен четырём. Причина, по которой есть смысл так подробно останавливаться на этом правиле, состоит в том, что стандарт C++11 позволяет программисту в явном виде управлять выравниванием данных.
> 
> Конечно, это вовсе не означает совета использовать обычный тип `int` вместо атомарного. Это означает лишь, что компилятор предоставляет более сильные гарантии, чем стандарт языка C++. Если программист строит свою программу с опорой на гарантии компилятора, программа не будет отвечать стандарту языка C++11. Следовательно, такая программа может работать некорректно на иных архитектурах или на той же архитектуре с будущей версией компилятора.

Посмотрим теперь, как инструмент `CppMem` сообщает о неопределённом поведении программы. Инструмент `CppMem` позволяет сократить текст программы до полного минимума.

**Несинхронизировнный доступ в анализаторе `CppMem`:**
```c++
int main() {
	int x = 0;
	int y = 0;

	{{{ {
			x = 2000;
			y = 11;
		}
	||| {
			y;
			x;
		}
	}}}
}
```

Потоки на встроенном языке `CppMem` можно обозначить посредством фигурных скобок (строки `{{{` и `}}}`) и символа трубопровода (строка `|||`). Дополнительные пары фигурных скобок, как в строках `{` и `}` служат для обозначения действий, которые должны выполняться потоком. Поскольку вывод значений переменных `x` и `y` нам на самом деле не нужен, в строках `y;` и `x;` стоит лишь вычитание их значений.

Это было отступление от теории работы с инструментом `CppMem`. Пора переходить к практике.

### Анализ программы

Если запустить программу в среде `CppMem`, среда покажет сообщение, помеченное на рисунке цифрой `1`, о том, что из четырёх возможных последовательностей выполнения программы лишь одно оказалось согласованным, но и оно содержит гонку данных. Теперь пользователь может переключаться между вариантами выполнения программы с помощью кнопок, помеченных цифрой `2`, и анализировать графическую схему процесса выполнения, снабжённую текстовыми метками, на рисунке она обозначена цифрой `3`.

![[ParallelProg_155.png]]

Больше всего информации о программе можно получить именно из анализа этих графов.

#### Первый вариант выполнения

На какие выводы может натолкнуть граф выполнения программы, показанный на следующем рисунке?

![[ParallelProg_156.png]]

Вершины графа соответствуют выражениям в тексте программы, а рёбра - отношениям между выражениями. Выражения помечены на графе буквами от `a` до `f`, они и будут использоваться в следующем далее пояснении. Что же должен говорить пользователю этот граф?
* `a:Wna x = 0`: выполнение программы начинается с неатомарной записи значения в переменную `x`;
* `sb` (sequenced-before – находится перед): операция записи (`a`) выполняется перед операцией записи (`b`). Подобное же отношение имеет место между операциями (`c`) и (`d`), а также между операциями (`e`) и (`f`);
* `rf` (read from – чтение из): выражение (`e`) читает значение переменной `y`, присвоенное выражением (`b`); подобным же образом выражение (`f`) читает значение, присвоенное выражением (`a`);
* `sw` (synchronizes-with – синхронизируется `с`): выражение (`a`) синхронизируется с выражением (`f`). Это утверждение справедливо потому, что выражение (`f`) выполняется в отдельном потоке, а момент создания потока представляет собой точку синхронизации: результаты всех операций, которые произошли до этой точки, должны быть видимы из потока. Из соображений симметрии такое же отношение имеет место и между выражениями (`b`) и (`e`);
* `dr` (data race – гонка данных): здесь имеют место гонки данных между попытками чтения и записи как для переменной `x`, так и для переменной `y`. Следовательно, программа обладает неопределённым поведением.

> **Почему это выполнение считается согласованным:**
> 
> Разобранный здесь вариант выполнения программы считается согласованным потому, что значения переменных `x` и `y` получили свои начальные значения в главном потоке, в выражениях (`a`) и (`b`). Присваивание этим переменным новых значений в выражениях (`c`) и (`d`) не является согласованным с точки зрения модели памяти.

Следующие три варианта выполнения программы не являются согласованными.

#### Второй вариант выполнения

Последовательность выполнения операций показана на рисунке на следующей странице.

![[ParallelProg_157.png]]

Теперь выражение (`e`) читает значение, которое пишет выражение (`d`). Операция записи (`d`) происходит параллельно с операцией чтения (`e`).

#### Третий вариант выполнения

Ещё один возможный сценарий выполнения параллельной программы представлен на рисунке.

![[ParallelProg_158.png]]

Он симметричен предыдущему варианту: операция чтения в выражении (`f`) выполняется одновременно с записью в выражении (`c`).

#### Четвёртый вариант выполнения

В последнем из логически возможных сценариев неправильно всё. Обе операции чтения, (`e`) и (`f`), выполняются одновременно с операциями записи в те же переменные: (`d`) и (`c`).

![[ParallelProg_159.png]]

#### Выводы

Даже с конфигурацией по умолчанию инструмент `CppMem` позволил получить много ценной информации и глубоко заглянуть в процесс выполнения программы. Построенные системой графики помогли выявить следующее:
* в результате работы программы могут возникнуть четыре комбинации значений переменных: (0, 0), (11, 0), (0, 2000) и (11, 2000);
* в программе имеется по меньшей мере одна гонка данных – следовательно, её поведение не определено;
* лишь один из четырёх возможных вариантов выполнения согласован.

> **Использование квалификатора [[volatile|volatile]]**
> 
> С точки зрения модели памяти доступ к переменным, объявленным с квалификатором [[volatile|volatile]], ничем не отличается от несинхронизированного доступа к обычным переменным `x` и `y`.

**Несинхронизированный доступ к [[volatile|volatile]] -переменным:**
```c++
int main() {
	volatile int x = 0;
	volatile int y = 0;
	{{{ {
			x = 2000;
			y = 11;
		}
	||| {
			y;
			x;
		}
	}}}
}
```

Для этой программы инструмент `CppMem` генерирует точно такие же граф-схемы, как для предыдущего примера. Причина этого проста и состоит в том, что семантика квалификатора [[volatile|volatile]] никак не связана с параллельным режимом работы программы.

В рассмотренном выше примере доступ к переменным `x` и `y` никак не был синхронизирован, отсюда и гонка данных, а с нею и неопределённое поведение. Наиболее очевидный способ синхронизации – использование [[lock|блокировщиков]].

## Анализ программы с блокировкой

Пусть теперь оба потока, `thread1` и `thread2`, используют один и тот же [[mutex|мьютекс]], заворачивая его в блокировщик [[lock#Тип std lock_guard|std::lock_guard]].

**Поэтапная оптимизация: использование блокировщика:**
```c++
// ongoingOptimisationLock.cpp

#include <iostream>
#include <mutex>
#include <thread>

int x = 0;
int y = 0;

std::mutex mut;

void writing(){
	std::lock_guard<std::mutex> guard(mut);
	x = 2000;
	y = 11;
}

void reading(){
	std::lock_guard<std::mutex> guard(mut);
	
	std::cout << “y: “ << y << “ “;
	std::cout << “x: “ << x << std::endl;
}

int main(){
	std::thread thread1(writing);
	std::thread thread2(reading);

	thread1.join();
	thread2.join();
};
```

Поведение этой программы вполне определено. В зависимости от порядка выполнения потоков (сначала поток `thread1`, затем `thread2`, или наоборот) либо сначала из обеих переменных вычитаются их первоначальные значения, затем обеим присваиваются новые, либо сначала обеим присваиваются новые значения, после чего они вычитаются. Из четырёх мыслимых комбинаций значений переменных лишь две возможны, как показано в таблице.

**Возможные значения переменных при использовании блокировщика:**

| **y** | **x** | **Возможность** |
| ----- | ----- | --------------- |
| 0     | 0     | +               |
| 11    | 0     | -               |
| 0     | 2000  | -               |
| 11    | 2000  | +               |

Блокировщики просты в использовании, однако такая синхронизация выходит слишком тяжеловесной. Рассмотрим более проворные механизмы синхронизации, основанные на атомарных переменных.

## Атомарные переменные с последовательной согласованностью

Если программист не указывает явно порядок доступа к памяти, по умолчанию применяется семантика последовательной согласованности. Последовательная согласованность влечёт за собой две гарантии. Во-первых, в каждом потоке операции над атомарными переменными выполняются в том порядке, в котором они записаны в исходном коде. Во-вторых, операции всех потоков образуют глобально упорядоченную последовательность. Ниже представлена оптимизированная версия предыдущей программы.

**Поэтапная оптимизация: последовательная согласованность:**
```c++
// OptimisationSequentialConsistency.cpp

#include <atomic>
#include <iostream>
#include <thread>

std::atomic<int> x{0};
std::atomic<int> y{0};

void writing(){
	x.store(2000);
	y.store(11);
}

void reading(){
	std::cout << y.load() << “ “;
	std::cout << x.load() << std::endl;
}

int main(){
	std::thread thread1(writing);
	std::thread thread2(reading);

	thread1.join();
	thread2.join();
};
```

Рассмотрим эту программу подробнее. Она не содержит гонки данных, так как переменные `x` и `y` атомарны. Поэтому остаётся ответить лишь на один вопрос: какие значения переменных возможны. Благодаря последовательной согласованности все потоки должны образовывать единый глобальный порядок выполнения операций. Очевидны следующие соотношения.

* Операция `store`, записывающая в переменную `x` значение 2000, выполняется ранее операции `store`, которая записывает значение 11 в переменную `y`.
* Операция `load` над переменной `y` выполняется ранее операции `load` над переменной `x`.

Следовательно, вычитание значения переменной `x` не может дать значение 0, если из переменной `y` уже прочитано значение 11.

Все остальные комбинации значений возможны. Ниже перечислены три возможных сценария перемежающегося выполнения потоков, приводящих к трём различным комбинациям значений переменных.
1. Поток `thread1` целиком выполняется до потока `thread2`.
2. Поток `thread2` целиком выполняется до потока `thread1`.
3. В потоке `thread1` выполняется первая операция `store`, записывающая в переменную `x` значение 2000, затем начинается выполнение потока `thread2`.

**Возможные комбинации значений переменных показаны в таблице:**

| **y** | **x** | **Возможность** |
| ----- | ----- | --------------- |
| 0     | 0     | +               |
| 11    | 0     | -               |
| 0     | 2000  | +               |
| 11    | 2000  | +               |

Сравним наши рассуждения с тем, что даст анализатор `CppMem`.

### Анализ программы инструментом CppMem

Ниже представлен перевод последней программы на язык системы `CppMem`.

**Атомарные переменные в системе `CppMem`:**
```c++
int main() {
	atomic_int x = 0;
	atomic_int y = 0;

	{{{ {
			x.store(2000);
			y.store(11);
		}
	||| {
			y.load();
			x.load();
		}
	}}}
}
```

Прежде всего нужно сказать несколько слов о синтаксисе. В строках `atomic_int x = 0;` и `atomic_int y = 0;` используется тип `atomic_int` – это предопределённый в системе `CppMem` псевдоним для типа `std::atomic<int>`.

Если теперь запустить программу под управлением анализатора, число получившихся вариантов-кандидатов оказывается удивительно большим.

![[ParallelProg_160.png]]

Система обнаруживает 384 возможных кандидата (цифра 1 на рисунке), только 6 из которых согласованы. Ни один вариант-кандидат не содержит гонки данных. Нас будут интересовать только шесть согласованных вариантов выполнения программы, на остальные 378 вариантов можно не обращать внимания. Несогласованность означает, что они, например, не отвечают ограничениям на порядок модификации переменных, накладываемым моделью памяти.

Воспользуемся панелью визуального интерфейса, помеченной на рисунке цифрой 2, чтобы исследовать шесть размеченных схем.

Как мы уже знаем, возможны все комбинации значений переменных, кроме одной: когда с `y=11` и `x=0`. Три оставшихся результата возможны в силу семантики последовательной согласованности. Теперь хочется выяснить, какие последовательности перемежающихся операций ведут к тем или иным возможным комбинациям значений переменных.

#### Вариант выполнения для y = 0, x = 0

Эта комбинация значений реализуется при единственном варианте выполнения программы, показанном на следующем рисунке.

![[ParallelProg_161.png]]

#### Варианты выполнения для y = 0, x = 2000

Четыре различных варианта выполнения программы, показанных на рисунках, ведут к одному результату.

![[ParallelProg_162.png]]
![[ParallelProg_163.png]]
![[ParallelProg_164.png]]
![[ParallelProg_165.png]]

#### Вариант выполнения для y = 11, x = 2000

Последняя возможная комбинация значений переменных реализуется лишь в одном варианте выполнения программы.

![[ParallelProg_166.png]]

Анализ программы этим не исчерпывается. Нужно ответить ещё на один вопрос: какая последовательность выполнения операций соответствует каждому из шести графов?

### Последовательность операций

На следующем рисунке каждой возможной последовательности операций поставлен в соответствие один из показанных выше графов.

![[ParallelProg_167.png]]

Начнём с наиболее очевидных случаев.
* Вариант (1) довольно просто сопоставить с графом под тем же номером. При такой последовательности операций из обеих переменных читаются начальные значения 0, поскольку обе операции чтения происходят раньше, чем в переменные попадают новые значения 2000 и 11.
* Вариант (6) можно связать с соответствующим графом с помощью похожего рассуждения. Из переменной `y` читается значение 11, а из переменной `x` – значение 2000, поскольку обе операции чтения выполняются после операций записи.
* Варианты (2), (3), (4), (5) более интересны, в результате их из переменной `y` читается значение 0, а из переменной `x` – значение 2000. Желтые стрелки с меткой (`sc`) на графах дают ключ к пониманию происходящего, так как обозначают последовательность выполнения операций. Рассмотрим, например, вариант (2):
	* путь по жёлтым стрелкам (`sc`) на графе (2) означает такую последовательность операций: записать значение 2000 в переменную `x`, прочитать значение 0 из переменной `y`, затем записать значение 11 в переменную `y` и, наконец, прочитать из переменной `x` значение 2000. Этот путь на графе соответствует перемежающейся последовательности операций под номером (2) на последнем рисунке.

Посмотрим, что будет, если нарушить последовательную согласованность семантикой захвата и освобождения.

## Атомарные переменные с семантикой захвата и освобождения

В семантике захвата и освобождения синхронизируются между собой только атомарные операции над одной и той же переменной. В этом состоит её отличие от семантики последовательной согласованности, при которой синхронизируются все атомарные операции между всеми потоками. Это отличие делает семантику захвата и освобождения более лёгкой для компьютера и, следовательно, быстрой. Текст модифицированной программы с семантикой захвата и освобождения приведён ниже.

**Поэтапная оптимизация: семантика захвата и освобождения:**
```c++
// ongoingOptimizationAcquireRelease.cpp

#include <atomic>
#include <iostream>
#include <thread>

std::atomic<int> x{0};
std::atomic<int> y{0};

void writing(){
	x.store(2000, std::memory_order_relaxed);
	y.store(11, std::memory_order_release);
}

void reading(){
	std::cout << y.load(std::memory_order_acquire) << “ “;
	std::cout << x.load(std::memory_order_relaxed) << std::endl;
}

int main(){
	std::thread thread1(writing);
	std::thread thread2(reading);

	thread1.join();
	thread2.join();
};
```

Одного взгляда на эту программу довольно, чтобы убедиться: все операции в ней атомарны – следовательно, поведение программы вполне определено. Однако второй взгляд обнаруживает интересную деталь: если операции над переменной `y` выполняются с флагами `std::memory_order_release` и `std::memory_order_acquire`, то операции над переменной `x`, напротив, выполняются в ослабленной семантике `std::memory_order_relaxed`. Таким образом, порядок выполнения операций над переменной `x` не связан никакими ограничениями. Поэтому ответ на вопрос о возможных комбинациях значений переменных `x` и `y` может дать только анализ переменной `y`. Имеют место следующие соотношения:
* операция записи в переменную `y` в строке `y.store(11, std::memory_order_release)` синхронизируется с операцией чтения из этой переменной в строке `std::cout << y.load(std::memory_order_acquire) << “ “`;
* операция записи в переменную `x` в строке `x.store(2000, std::memory_order_relaxed)` видима ранее операции записи в переменную `y` в строке `y.store(11, std::memory_order_release)`;
* операция чтения из переменной `y` в строке `std::cout << y.load(std::memory_order_acquire) << “ “;` видима ранее операции чтения из переменной `x` в строке `std::cout << x.load(std::memory_order_relaxed) << std::endl;`.

Остановимся подробнее на этих трёх утверждениях. Ключевое значение имеет то обстоятельство, что запись в переменную `y` в строке `y.store(11, std::memory_order_release)` синхронизируется с чтением из неё в строке `std::cout << y.load(std::memory_order_acquire) << “ “;`. Это справедливо потому, что обе операции работают с одной и той же атомарной переменной и используют при этом семантику захвата и освобождения: запись работает как освобождение, а чтение – как захват. Парные операции над переменной `y` обладают ещё одним важным свойством. Они делают эту переменную своеобразным барьером, относительно которого распределяются другие операции. Так, операция записи значения 2000 в переменную `x` не может быть выполнена после операции записи в переменную `y`, а операция чтения переменной `x` не может выполниться ранее чтения переменной `y`.

Семантика захвата и освобождения требует более сложных рассуждений, чем ранее рассмотренная семантика последовательной согласованности, но комбинации возможных значений переменных `x` и `y` остаются без изменений. Невозможной по-прежнему оказывается только ситуация, когда переменная `y` имеет значение 11, а переменная `x` – значение 0.

Возможны три разных порядка выполнения операций, которые приводят к трём комбинациям значений переменных:
* поток `thread1` полностью выполняется до начала потока `thread2`;
* поток `thread2` полностью выполняется до начала потока `thread1`;
* поток `thread1` выполняется до операции записи в строке 11 до того, как начнёт выполняться поток `thread2`.

Иными словами, имеем комбинации значений переменных, показанные в следующей таблице.

**Возможные значения переменных в семантике захвата и освобождения:**

| **y** | **x** | **Возможность** |
| ----- | ----- | --------------- |
| 0     | 0     | +               |
| 11    | 0     | -               |
| 0     | 2000  | +               |
| 11    | 2000  | +               |

Попробуем теперь проверить наши умозаключения с помощью инструмента `CppMem`.

### Анализ программы инструментом CppMem 2 

Ниже показана соответствующая программа на внутреннем языке `CppMem`.

**Семантика захвата и освобождения в системе `CppMem`:**
```c++
int main() {
	atomic_int x = 0;
	atomic_int y = 0;
	
	{{{ {
			x.store(2000, memory_order_relaxed);
			y.store(11, memory_order_release);
		}
	||| {
			y.load(memory_order_acquire);
			x.load(memory_order_relaxed);
		}
	}}}
}
```

Мы уже знаем, что в результате выполнения этой программы возможны все исходы, кроме одного (`y` = 11, `x` = 0).

#### Возможные варианты выполнения

Рассматриваем здесь лишь три графа с согласованным выполнением. На всех схемах показано отношение захвата-освобождения между операцией записи в переменную `y` (выступающей как освобождение) и операцией чтения из неё (работающей как захват). При этом не важно, выполняется ли чтение переменной `y` в главном потоке программы или в отдельном потоке. Соответствующие стрелки снабжены меткой `rf`. Кроме того, отношение синхронизации показано стрелками с меткой `sw`.

#### Вариант выполнения для случая y = 0, x = 0

![[ParallelProg_168.png]]

#### Вариант выполнения для случая y = 0, x = 2000

![[ParallelProg_169.png]]

#### Вариант выполнения для случая y = 11, x = 2000

![[ParallelProg_170.png]]

Можно было бы предположить, что переменную `x` вообще не нужно делать атомарной. Это кажущееся очевидным предположение оказывается неверным. Разберёмся почему.

## Смесь атомарных и неатомарных переменных

Типичная ошибка в понимании семантики захвата и освобождения – думать, будто операция захвата ждёт соответствующего освобождения. Из этого ложного предположения легко сделать столь же ложный вывод, что программу можно оптимизировать, сделав переменную `x` неатомарной. Рассмотрим следующую программу.

**Поэтапная оптимизация: смесь атомарных и неатомарных переменных:**
```c++
// ongoingOptimisationAcquireReleaseBroken.cpp

#include <atomic>
#include <iostream>
#include <thread>

int x = 0;
std::atomic<int> y{0};

void writing(){
	x = 2000;
	y.store(11, std::memory_order_release);
}

void reading() {
	std::cout << y.load(std::memory_order_acquire) << “ “;
	std::cout << x << std::endl;
}

int main(){
	std::thread thread1(writing);
	std::thread thread2(reading);

	thread1.join();
	thread2.join();
};
```

В этой программе имеется гонка данных по переменной `x` и, следовательно, её поведение не определено. Семантика захвата и освобождения гарантирует, что если запись в переменную `y` в строке `y.store(11, std::memory_order_release);` выполняется ранее операции чтения из этой переменной в строке `std::cout << y.load(std::memory_order_acquire) << “ “;`, то присваивание нового значения переменной `x` в строке `x = 2000;` выполнится до чтения из этой переменной в строке `std::cout << x << std::endl;`. Однако если это условие не выполнено, чтение и запись переменной `x` могут произойти одновременно. Итак, имеем одновременный доступ к общей переменной, и одна из операций при этом представляет собой запись. Это и есть, по определению, гонка данных.

Чтобы отчётливее понять поведение программы, воспользуемся инструментом `CppMem`.

### Анализ программы инструментом CppMem 3

**Смешивание атомарных и неатомарных переменных в системе `CppMem`:**
```c++
int main() {
	int x = 0;
	atomic_int y = 0;
	
	{{{ {
			X = 2000;
			y.store(11, memory_order_release);
		}
	||| {
			y.load(memory_order_acquire);
			x;
		}
	}}}
}
```

Гонка данных возникает, когда один поток выполняет присваивание `x` = 2000, в то время как другой поток читает значение переменной `x`. На схеме это изображено жёлтой стрелкой с меткой `dr` (data race – «гонка данных»).

![[ParallelProg_171.png]]

Процессу пошаговой оптимизации программы не хватает последнего шага – ослабленной семантики атомарных операций над обеими переменными.

## Атомарные переменные с ослабленной семантикой

При ослабленной семантике не происходит никакой синхронизации или упорядочивания операций – гарантируется лишь атомарность каждой из них.

**Поэтапная оптимизация: ослабленная семантика:**
```c++
// ongoingOptimisationRelaxedSemantic.cpp

#include <atomic>
#include <iostream>
#include <thread>

std::atomic<int> x{0};
std::atomic<int> y{0};

void writing() {
	x.store(2000, std::memory_order_relaxed);
	y.store(11, std::memory_order_relaxed);
}

void reading() {
	std::cout << y.load(std::memory_order_relaxed) << “ “;
	std::cout << x.load(std::memory_order_relaxed) << std::endl;
}

int main() {
	std::thread thread1(writing);
	std::thread thread2(reading);

	thread1.join();
	thread2.join();
};
```

Как и в предыдущих случаях, нужно найти ответы на два основных вопроса:
1. Обладает ли программа вполне определённым поведением?
2. Какие комбинации значений переменных возможны в результате выполнения программы?

В ослабленной семантике ответ на два основных вопроса очевиден. Поскольку все операции над обеими переменными атомарны, поведение программы вполне определено. С другой стороны, ослабленная семантика не налагает никаких ограничений на порядок выполнения операций в разных потоках. Это может привести к тому, что поток `thread2` увидит операции записи не в том порядке, в котором они выполняются потоком `thread1`. Впервые в ходе поэтапной оптимизации программы становится возможной ситуация, когда второй поток увидит в переменных `x` и `y` значения 0 и 11 соответственно. Таким образом, возможными становятся все четыре комбинации, как показано в следующей таблице.

**Возможные значения переменных в ослабленной семантике**

| **y** | **x** | **Возможность** |
| ----- | ----- | --------------- |
| 0     | 0     | +               |
| 11    | 0     | +               |
| 0     | 2000  | +               |
| 11    | 2000  | +               |

Интересно узнать, как инструмент `CppMem` изобразит граф выполнения программы для случая (`x` = 0, `y` = 11).

### Анализ инструментом CppMem 4

**Семантика захвата и освобождения в системе `CppMem`:**
```c++
int main() {
	atomic_int x = 0;
	atomic_int y = 0;
	
	{{{ {
			x.store(2000, memory_order_relaxed);
			y.store(11, memory_order_relaxed);
		}
	||| {
			y.load(memory_order_relaxed);
			x.load(memory_order_relaxed);
		}
	}}}
}
```

По представленной выше программе на внутреннем языке инструмент `CppMem` строит следующий граф, описывающий её необычное поведение.

![[ParallelProg_172.png]]

На схеме показано, что из переменной `x` читается значение 0, а из переменной `y` – значение 11, несмотря на то что в другом потоке запись в переменную `x` располагается перед записью в переменную `y`.
