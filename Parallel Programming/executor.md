
[[#executor|Исполнители]] 7.1
1. [[#Долгий путь исполнителя|Долгий путь исполнителя]] 7.1.1
2. [[#Что такое исполнитель|Что такое исполнитель]] 7.1.2
	1. [[#Свойства исполнителя|Свойства исполнителя]] 7.1.2.1
3. [[#Первые примеры|Первые примеры]] 7.1.3
	1. [[#Использование исполнителя|Использование исполнителя]] 7.1.3.1
		1. [[#Асинхронное обещание|Асинхронное обещание]] 7.1.3.1.1
		2. [[#Обход элементов контейнера|Обход элементов контейнера]] 7.1.3.1.2
		3. [[#Сетевое соединение с использованием системного исполнителя|Сетевое соединение с использованием системного исполнителя]] 7.1.3.1.3
		4. [[#Сетевое соединение с использованием явно заданного исполнителя|Сетевое соединение с использованием явно заданного исполнителя]] 7.1.3.1.4
	2. [[#Получение исполнителя|Получение исполнителя]] 7.1.3.2
		1. [[#Получение исполнителя из статического пула потоков|Получение исполнителя из статического пула потоков]] 7.1.3.2.1
		2. [[#Получение исполнителя из параллельной политики выполнения|Получение исполнителя из параллельной политики выполнения]] 7.1.3.2.2
		3. [[#Системный исполнитель по умолчанию|Системный исполнитель по умолчанию]] 7.1.3.2.3
		4. [[#Применение адаптера к существующему исполнителю|Применение адаптера к существующему исполнителю]] 7.1.3.2.4
4. [[#Цели разработки исполнителей|Цели разработки исполнителей]] 7.1.4
5. [[#Терминология|Терминология]] 7.1.5
6. [[#Функции выполнения|Функции выполнения]] 7.1.6
	1. [[#Единичная кардинальность|Единичная кардинальность]] 7.1.6.1
	2. [[#Множественная кардинальность|Множественная кардинальность]] 7.1.6.2
	3. [[#Проверка требований к исполнителю|Проверка требований к исполнителю]] 7.1.6.3
7. [[#Простой пример использования|Простой пример использования]] 7.1.7

# executor

Исполнитель (executor) содержит набор правил касательно того, где, когда и как выполнять вызываемый объект. Они представляют собой основные блоки, из которых строится выполнение программы, и определяют, должен ли тот или иной код выполняться в произвольном потоке, в пуле потоков или даже в едином потоке без распараллеливания. От них зависят расширения [[future|фьючерсов]], расширения для работы с сетью N4734, а также параллельные алгоритмы из стандартной библиотеки; другие средства параллельного программирования из стандартов C++ 20/23, такие как [[Latch_and_Barrier#Класс std latch|защёлки]], [[Latch_and_Barrier#Класс std barrier|барьеры]], [[Особенности сопрограмм|сопрограммы]], транзакционная память и [[task|блоки заданий]], также смогут использовать исполнители. 

Исполнители призваны стать основными блоками, из которых строится процесс выполнения программы; их роль можно сравнить с той, которую в языке C++ уже играют аллокаторы и контейнеры. Предполагается, что исполнителями будут пользоваться функции наподобие [[async#std async|std::async]], [[Parallel programming#Стандарт C++ 17. Параллельные алгоритмы в стандартной библиотеке|параллельные алгоритмы из стандартной библиотеки]], продолжения фьючерсов, функция-член `run` блока заданий, а также функции `post`, `dispatch`, `defer` из предполагаемого будущего модуля для работы с сетью. Да и вообще говоря, исполнение – одно из основополагающих понятий программирования. Однако в нынешнем стандарте нет единого способа управления способом выполнения функции. Рассмотрим пример, с которого начинается предложение к стандарту P07612.

**Различные реализации параллельного цикла:**
```c++
void parallel_for(int facility, int n, function<void(int)> f) {
	if(facility == OPENMP) {
		#pragma omp parallel for
		for(int i = 0; i < n; ++i) {
			f(i);
		}
	}
	else if(facility == GPU) {
		parallel_for_gpu_kernel<<<n>>>(f);
	}
	else if(facility == THREAD_POOL) {
		global_thread_pool_variable.submit(n, f);
	}
}
```

Представленная здесь функция `parallel_for` обладает рядом недостатков.

* Простая, казалось бы, функция оказывается сложной в поддержке, причём сложность поддержки растёт с добавлением новых механизмов параллельного выполнения.
* Ветки условного оператора по-разному ведут себя с точки зрения синхронизации. Механизм `OpenMP` может блокировать выполнение до тех пор, пока не закончат работу дочерние потоки, графический процессор обычно работает асинхронно, а пул потоков может как блокировать выполнение, так и не блокировать. Недостаточная синхронизация потоков может привести к гонке данных или к мёртвой блокировке. В лучшем случае программа может оказаться в состоянии гонки.
* Функция навязывает вызывающему контексту слишком жёсткие ограничения. Например, нет никакого способа передать в неё свой пул потоков взамен глобального.

## Долгий путь исполнителя

В октябре 2018 года было написано несколько предложений касательно исполнителей, принцип их работы до сих пор требует уточнения по ряду аспектов. Эта глава основана главным образом на предложении о принципе устройства исполнителей P07611 и на формальных описаниях P04332 и P12443. У этих предложений есть неплохие шансы войти в стандарт C++ 23. В этой главе также рассмотрим относительно новое предложение P10554 о «скромных» исполнителях.

## Что такое исполнитель

Прежде всего нужно ответить на вопрос, что собой представляет рассматриваемая сущность. Исполнитель – это набор правил, определяющих, где, когда и как запускать вызываемую единицу выполнения.

* Где. Вызываемая единица может выполняться на центральном процессоре, передаваться для выполнения на внешний или вспомогательный процессор – от этого зависит, каким образом можно получить результат вычисления.
* Когда. Вызываемую сущность можно выполнить немедленно или запланировать её выполнение на более позднее время.
* Как. Выполнение может происходить на центральном процессоре, графическом процессоре или посредством векторизации.

Если говорить более формально, исполнитель – это набор свойств, связанных с некоторой функцией выполнения.

### Свойства исполнителя

Следующие свойства можно связать с исполнителем двумя способами: механизм `execution::require` требует непременного выполнения свойства, а механизм `execution::prefer` означает, что в процессе выполнения кода следует предпочесть данное свойство, если это возможно. Перечень свойств приведён ниже.

* Направленность: функция выполнения может работать по принципу «выстрели и забудь» (`execution::oneway`), вернуть фьючерс (`execution::twoway`) или вернуть продолжение (`execution::then`).
* Кардинальность: функция выполнения может создать одного агента выполнения (`execution::single`) или множество таких агентов (`execution::bulk`).
* Блокировка: выполнение функции может блокировать или не блокировать текущий поток. Имеется три стратегии блокирования: `execution::blocking::never` запрещает блокировку, `execution::blocking::possibly` разрешает, а `execution::blocking::always` требует её.
* Способ продолжения: задание может выполняться в клиентском вызывающем потоке (`execution::continuation`) или нет (`execution::not_continuation`).
* Вероятность будущего задания: это свойство определяет, насколько вероятно появление задания в будущем (свойство `execution::outstanding_work::tracked` означает, что появление задания в будущем ожидается, а свойство `execution::outstanding_work::untracked` – что это маловероятно).
* Гарантии массового продвижения вперёд: какие имеются гарантии совокупного продвижения вперёд множества создаваемых агентов выполнения: `execution::bulk_sequenced_execution`, `execution::bulk_parallel_execution` и `execution::bulk_unsequenced_execution`.
* Гарантии размещения по потокам: должен ли каждый агент выполнения назначаться на отдельный поток (режим `execution::new_thread_execution_mapping`) или нет (режим `execution::thread_execution_mapping`).
* Аллокатор: к исполнителю может быть привязан объект, ответственный за управление памятью.

Программист может также добавлять собственные свойства.

> **Исполнители как строительные блоки**
> 
> Поскольку исполнители предполагается сделать основными строительными блоками процесса выполнения программы, средства параллельного программирования в будущем стандарте языка C++ должны сильно зависеть от них. Это в первую очередь касается расширенных фьючерсов, сетевых расширений, описанных в документе N47341, параллельных алгоритмов стандартной библиотеки, а также новых средств: защёлок, барьеров, сопрограмм, транзакционной памяти и блоков заданий.

## Первые примеры

### Использование исполнителя

Разберём ряд примеров, иллюстрирующих использование исполнителей.

#### Асинхронное обещание

**Асинхронное выполнение обещания посредством исполнителя:**
```c++
// как-либо получить объект-исполнитель
my_executor_type my_executor = ...

// запустить асинхронное выполнение
auto future = std::async(my_executor, [] {
	std::cout << "Hello world, from a new execution agent!" << '\n';
});
```

#### Обход элементов контейнера

**Обход элементов контейнера с использованием исполнителя:**
```c++
// как-либо получить объект-исполнитель
my_executor_type my_executor = ...

// запустить параллельный обход контейнера
std::for_each(std::execution::par.on(my_executor),
						data.begin(), data.end(), func);
```

#### Сетевое соединение с использованием системного исполнителя

**Использование системного исполнителя для приёма соединения:**
```c++
// как-либо получить объект для приёма входящих соединений
tcp::acceptor my_acceptor = ...

// выполнить асинхронную операцию для приёма соединения
acceptor.async_accept(
		[](std::error_code ec, tcp::socket new_connection)
			{
			...
			});
```

#### Сетевое соединение с использованием явно заданного исполнителя

**Использование системного исполнителя для приёма соединения:**
```c++
// как-либо получить объект для приёма входящих соединений
tcp::acceptor my_acceptor = ...

// получить объект-исполнитель, связанный с пулом потоков
auto my_thread_pool_executor = ...

// выполнить асинхронную операцию для приёма соединения
acceptor.async_accept(
	std::experimental::net::bind_executor(my_thread_pool_executor,
	[](std::error_code ec, tcp::socket new_connection)
	{
	...
	}
	));
```

Функция `bind_executor` из экспериментального модуля для поддержки сети позволяет подставить в асинхронную функцию сетевого взаимодействия пользовательский объект-исполнитель. В данном примере обработчик соединения выполнит [[Lambda|лямбда-функцию]] в пуле потоков.

### Получение исполнителя

Есть различные способы получить объект-исполнитель.

#### Получение исполнителя из статического пула потоков

**Получение исполнителя из статического пула потоков**
```c++
// создать пул на 4 потока
static_thread_pool pool(4);

// получить объект-исполнитель, связанный с пулом потоков
auto exec = pool.executor();

// использовать исполнителя для запуска продолжительного задания
auto task1 = long_running_task(exec);
```

#### Получение исполнителя из параллельной политики выполнения

**Получение исполнителя из параллельной политики выполнения:**
```c++
// получить объект-исполнитель, связанный с параллельной политикой
auto par_exec = std::execution::par.executor();

// использовать исполнителя для запуска продолжительного задания
auto task2 = long_running_task(par_exec);
```

#### Системный исполнитель по умолчанию

Исполнитель по умолчанию обычно предполагает создание нового потока для выполнения задания. Этот исполнитель используется в случае, если никакой другой исполнитель не задан явно.

#### Применение адаптера к существующему исполнителю

**Применение адаптера к существующему исполнителю:**
```c++
// получить объект-исполнитель, связанный с пулом потоков
auto exec = pool.executor();

// обернуть исполнителя в адаптер, выводящий диагностические сообщения
logging_executor<decltype(exec)> logging_exec(exec);

// отсортировать контейнер под управлением исполнителя с адаптером
std::sort(std::execution::par.on(logging_exec),
					my_data.begin(), my_data.end());
```

Исполнитель `logging_executor` в этом примере представляет собой адаптер поверх исполнителя, связанного с пулом потоков.

## Цели разработки исполнителей

Ниже перечислены цели, которыми руководствовались авторы документа P10551, формулируя понятие исполнителя.

1. **Дозируемость** – возможность управлять балансом между затратами на передачу вызываемого объекта и его размером.
2. **Гетерогенность** – возможность запускать вызываемый объект в разнородных средах (таких как графический процессор или внешний процессор) и получать назад результат вычислений.
3. **Упорядочиваемость** – возможность задавать порядок, в котором запускаются вызываемые объекты. Сюда относятся такие гарантии порядка выполнения, как стек (LIFO – last in, first out), очередь (FIFO – first in, first out), очередь с приоритетами, расписание или последовательное выполнение.
4. **Управляемость** – возможность назначить вызываемый объект на определённый вычислительный ресурс, отложить или отменить выполнение.
5. **Продолжаемость** – поддержка сигналов, позволяющих управлять асинхронным выполнением вызываемого объекта. Эти сигналы позволяют оповещать о готовности результата, о возникновении ошибки, а также о желании вызывающего клиента прервать выполнение задания. Также должны быть возможны явный запуск вызываемого объекта и отмена запуска запланированного задания.
6. **Многослойность** – иерархическое строение исполнителей должно поддерживать добавление свойств, не внося лишнюю сложность в прос­тые сценарии использования.
7. **Удобство** как со стороны разработчика исполнителей, так и со стороны автора прикладного кода, пользующегося исполнителями, составляет особенно важную цель.
8. **Комбинируемость** – программисту должна быть предоставлена возможность расширять исполнителей свойствами, не предусмотренными в стандарте.
9. **Минималистичность** – в понятие исполнителя, реализованное в стандарте языка, не должны входить никакие детали, которые можно было бы добавить извне, реализовав в некоторой сторонней библиотеке.

## Терминология

В документе-предложении P0761 определен ряд новых терминов, относящихся к выполнению вызываемого объекта.

* **Выполняющий ресурс** – экземпляр аппаратного или программного ресурса, способный выполнять вызываемый объект. Примерами выполняющего ресурса могут служить векторный модуль процессора или система выполнения, управляющая множеством потоков. Такие выполняющие ресурсы, как центральный или графический процессор, гетерогенны, так как их возможности и ограничения сильно различаются от экземпляра к экземпляру.
* **Контекст выполнения** – программный объект, представляющий определённый набор выполняющих ресурсов и агентов выполнения. Типичными примерами могут служить пул потоков, а также распределённая или гетерогенная вычислительная система.
* **Агент выполнения** – единица выполнения внутри определённого контекста выполнения, связанная с одним вызовом вызываемого объекта на выполняющем ресурсе. Примерами могут быть поток на центральном процессоре или единица выполнения на графическом процессоре.
* **Исполнитель** – программный объект, связанный с определённым контекстом выполнения. Он предоставляет одну или более функций для создания агента выполнения для заданного вызываемого объекта (например, функционального объекта или функции).

## Функции выполнения

Исполнитель предоставляет одну или более функций, создающих агента выполнения для некоторого вызываемого объекта. Исполнитель должен поддерживать по меньшей мере шесть следующих функций.

**Функции выполнения, обязательные для любого исполнителя:**

| **Имя**               | **Кардинальность** | **Направленность** |
| --------------------- | ------------------ | ------------------ |
| `execute`             | Единичная          | Односторонняя      |
| `twoway_execute`      | Единичная          | Двусторонняя       |
| `then_execute`        | Единичная          | Продолжение        |
| `bulk_execute`        | Множественная      | Односторонняя      |
| `bulk_twoway_execute` | Множественная      | Двусторонняя       |
| `bulk_then_execute`   | Множественная      | Продолжение        |

Каждая функция выполнения обладает двумя характеристиками: кардинальностью и направленностью.

* **Кардинальность** означает, сколь много агентов выполнения может создаваться для выполнения одного вызываемого объекта:
> единичная (single) предполагает создание единственного агента;
> множественная (bulk) означает возможность создавать группу агентов выполнения.
* Направленность:
> односторонняя (oneway) означает, что данные передаются в один конец, от вызывающего контекста в вызываемый объект; последний не возвращает результата;
> двусторонняя (twoway) означает, что вызывающий контекст требует возврата значения от выполняемого объекта; для ожидания значения может использоваться фьючерс;
> продолжение (then) означает, что в создаваемом агенте выполнения будет выполняться фьючерс, который начнёт своё выполнение после того, как получит результат выполнения некоторого другого фьючерса.

Все перечисленные функции принимают в качестве аргумента вызываемый объект. 

### Единичная кардинальность

Единичная кардинальность весьма очевидна. Однонаправленная функция выполнения запускает задание по принципу «выстрели и забудь» и не возвращает значения. Она ведёт себя подобно [[future|фьючерсам]], за исключением того, что не блокирует выполнение автоматически в деструкторе [[future|фьючерса]]. Двунаправленная функция выполнения возвращает [[future|фьючерс]], через который впоследствии можно забрать результат вычислений. Это роднит её с объектом-обещанием [[promise|std::promise]], который несёт в себе дескриптор для доступа к соответствующему [[future|фьючерсу]]. Функция выполнения с направленностью `then` присоединяет продолжение к существующему [[future|фьючерсу]] `pred`. Она возвращает новый [[future|фьючерс]], а соответствующий агент выполнения запускается только тогда, когда [[future|фьючерс]] `pred` сообщает о готовности своего результата.

### Множественная кардинальность

Случай множественной кардинальности сложнее. Эти функции создают группу агентов выполнения, каждый из которых выполняет одну и ту же вызываемую сущность `f`, передаваемую в функцию выполнения первым параметром. Второй параметр функции выполнения – целое число, максимальное количество агентов выполнения, которым может быть поручена работа. При этом вызываемый объект `f` должен первым параметром принимать индекс текущего агента. Если функция выполнения двунаправленна, её следующий параметр – фабрика результатов, задача которой состоит в том, чтобы из результатов запуска `f` на отдельных агентах выполнения собрать результат вычисления в целом. Последний аргумент функции выполнения – фабрика общего параметра; она создаёт некоторый объект, который затем передаётся каждому агенту выполнения.

В случае функции `bulk_then_execute` вызываемый объект `f` принимает фьючерс-предшественник в качестве параметра. Вызываемый объект `f` принимает общий параметр и фьючерс-предшественник по ссылке, так как ни один агент выполнения не должен владеть этими объектами.

### Проверка требований к исполнителю

Каким способом удостовериться, что исполнитель поддерживает ту или иную функцию выполнения? В частном случае, когда тип исполнителя известен заранее, известны и все поддерживаемые им функции, например:

**Использование однонаправленного единичного исполнителя:**
```c++
void concrete_context(const my_oneway_single_executor& ex)
{
	auto task = ...;

	ex.execute(task);
}
```

В общем же случае для проверки функциональных возможностей исполнителя можно воспользоваться функцией `execution::require`:

**Запрос двунаправленного единичного исполнителя:**
```c++
template<class Executor>
void generic_context(const Executor& ex)
{
	auto task = ...;

	// ensure .toway_execute() is available with execution::require()
	execution::require(ex, execution::single,
						execution::twoway).toway_execute(task);
}
```

## Простой пример использования

Основываясь на документе-предложении P0443R3 1, можно написать программу, демонстрирующую различные сценарии использования исполнителя.

**Пример использования исполнителей:**
```c++
// executor.cpp

#include <atomic>
#include <experimental/thread_pool>
#include <iostream>
#include <utility>

namespace execution = std::experimental::execution;
using std::experimental::static_thread_pool;
using std::experimental::executors_v1::future;

int main() {
	static_thread_pool pool{4};
	auto ex = pool.executor();

	// One way, single.
	ex.execute([]{ std::cout << “We made it!” << std::endl; });

	std::cout << std::endl;
	
	// Two way, single.
	future<int> f1 = ex.twoway_execute([]{ return 42; });
	f1.wait();
	std::cout << “The result is: “ << f1.get() << std::endl;
	
	std::cout << std::endl;

	// One way, bulk.
	ex.bulk_execute([](int n, int& sha){
		std::cout << “part “ << n << “: “ << “shared: “ << sha << “\n”;
		}, 8, []{ return 0; }
	);
	
	std::cout << std::endl;
	
	// Two way, bulk, void result.
	future<void> f2 = ex.bulk_twoway_execute(
		[](int n, std::atomic<short>& m){
			std::cout << “async part “ << n ;
			std::cout << “ atom: “ << m++ << std::endl;
		}, 8,[]{},[]{
			std::atomic<short> atom(0);
			return std::ref(atom);
		}
	);
	
	f2.wait();
	std::cout << “bulk result available” << std::endl;
	
	std::cout << std::endl;

	// Two way, bulk, non-void result.
	future<double> f3 = ex.bulk_twoway_execute(
		[](int n, double&, int &){
			std::cout << “async part “ << n << “ “;
			std::cout << std::this_thread::get_id() << std::endl;
		}, 8,[]{
				std::cout << “Result factory: “
						<< std::this_thread::get_id() << std::endl;
				return 123.456; },
			[]{
				std::cout << “Shared Parameter: “
						<< std::this_thread::get_id() << std::endl;
				return 0; }
	);
	
	f3.wait();
	std::cout << “bulk result is “ << f3.get() << std::endl;
}
```

В этой программе используется исполнитель, связанный с пулом на четыре потока (строки `static_thread_pool pool{4};` и `auto ex = pool.executor();`). В строках `ex.execute([]{ std::cout << “We made it!” << std::endl; });` и `future<int> f1 = ex.twoway_execute([]{ return 42; });` применены функции выполнения с единичной кардинальностью: для однонаправленного и двунаправленного (то есть возвращающего результат) заданий.

Остальные функции выполнения в этом примере (в строках `ex.bulk_execute([](int n, int& sha){ ...`, `future<void> f2 = ex.bulk_twoway_execute( ...` и `future<double> f3 = ex.bulk_twoway_execute( ... `) имеют множественную кардинальность. Каждая из них создаёт по восемь агентов (см. строки `}, 8,`). В первом случае вызываемый объект выводит на печать порядковый номер агента и общее значение `sha`, которое создаётся фабрикой в строке `[]{ return 0; }`. Второй случай, когда вызывается функция `bulk_twoway_execute`, интереснее. Хотя фабрика результатов не возвращает значения, общее состояние представляет собой атомарную переменную `atom`. Каждый агент увеличивает её значение на единицу. Последний вызов функции выполнения (строки `future<double> f3 = ex.bulk_twoway_execute( ... ) `) возвращает значение 123,456 благодаря фабрике результатов. Довольно интересно посмотреть, сколько потоков участвует в выполнении лямбда-функции, а также в работе фабрики общего параметра и фабрики результатов. Выводимый программой текст свидетельствует о том, что фабрики общего параметра и результатов работают в одном и том же потоке, тогда как агенты могут запускаться в различных потоках.

![[ParallelProg_192.png]]

