
[[#Оператор co_return и жадный фьючерс|Оператор co_return и жадный фьючерс]] 5.6


# Оператор co_return и жадный фьючерс

Здесь речь пойдёт о случае, когда для возврата значения из сопрограммы используется оператор `co_return`. Вероятно, следующая программа даёт простейший из возможных примеров сопрограмм, которые всё ещё делают что-то осмысленное: эта сопрограмма автоматически сохраняет значение в переменную.

**Жадный фьючерс:**
```c++
// eagerFuture.cpp

#include <coroutine>
#include <iostream>
#include <memory>

template<typename T>
struct MyFuture {
	std::shared_ptr<T> value;
	
	MyFuture(std::shared_ptr<T> p): value(p) {}
	~MyFuture() { }

	T get() {
		return *value;
	}

	struct promise_type {
		std::shared_ptr<T> ptr = std::make_shared<T>();
		~promise_type() { }
		
		MyFuture<T> get_return_object() {
			return ptr;
		}

		void return_value(T v) {
			*ptr = v;
		}
	
		std::suspend_never initial_suspend() {
			return {};
		}
	
		std::suspend_never final_suspend() noexcept {
			return {};
		}
	
		void unhandled_exception() {
			std::exit(1);
		}
	};
};

MyFuture<int> createFuture() {
	co_return 2021;
}

int main() {
	std::cout << ‘\n’;

	auto fut = createFuture();

	std::cout << “fut.get(): “ << fut.get() << ‘\n’;

	std::cout << ‘\n’;
}
```

Объект класса `MyFuture` ведёт себя как [[future#std future|фьючерс]], который начинает работу немедленно после создания. Вызов сопрограммы `createFuture` в строке `auto fut = createFuture();` возвращает [[future#std future|фьючерс]], а выражение `fut.get()` получает результат из соответствующего обещания.

Поведение этой сопрограммы отличается от поведения обычных [[future#std future|фьючерсов]] в одном аспекте: возвращаемое значение сопрограммы `createFuture` доступно сразу после вызова. Для удобства управлением временем жизни объект, с которым работает сопрограмма, находится под управлением умного указателя (строки `std::shared_ptr<T> value;` и `std::shared_ptr<T> ptr = std::make_shared<T>();`). Сопрограмма возвращает объекты типа `std::suspend_never` из обеих функций, запрашивающих приостановку, и, следовательно, не приостанавливается ни в начале, и в конце выполнения. Это означает, что сопрограмма отрабатывает при вызове функции `createFuture`. Функция-член `get_return_object` в строке `MyFuture<T> get_return_object()` создаёт объект-фьючерс, который отныне связан с сопрограммой, а функция-член `return_value` сохраняет в переменную результат работы сопрограммы, который поступает из оператора `co_return` 2021. Клиентский код вызывает функцию `fut.get` и использует [[future#std future|фьючерс]], чтобы получить доступ к данным, хранящимся в объекте-обещании. Функция-член `get` просто возвращает клиенту значение, хранящееся по умному указателю. Таким образом, программа печатает следующий результат:

![[ParallelProg_110.png]]

Читатель мог бы возразить, что создание сопрограммы, которая работает в точности как обычная функция, не стоит затраченных усилий. И это правда! Однако эта простейшая сопрограмма представляет хорошую отправную точку, чтобы впоследствии создавать разнообразные более сложные [[future#std future|фьючерсы]]. 

