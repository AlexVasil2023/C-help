
[[#Новые параллельные алгоритмы]]
1. [[#Новые перегрузки|Новые перегрузки]] 4.3.1
2. [[#Наследие функционального программирования|Наследие функционального программирования]] 4.3.2

# Новые параллельные алгоритмы

Новые алгоритмы находятся в пространстве имён `std`. Алгоритмы [[for_each#for_each|std::for_each]] и [[for_each#std for_each_n|std::for_each_n]] требуют заголовочного файла `<algorithm>`. Оставшимся шести нужен заголовочный файл `<numeric>`. Краткие сведения об этих алгоритмах представлены в следующей таблице.

| **Алгоритм**                                                         | **Описание**                                                                                                                                                                                                                                                                                                                                                                                  |
| -------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [[for_each#for_each\|for_each]]                                      | Применяет унарный вызываемый объект к каждому элементу диапазона                                                                                                                                                                                                                                                                                                                              |
| [[for_each#std for_each_n\|for_each_n]]                              | Применяет унарный вызываемый объект к первым `n` элементам диапазона                                                                                                                                                                                                                                                                                                                          |
| [[scan#std exclusive_scan\|std::exclusive_scan]]                     | Применяет вызываемый объект (принимающий два аргумента)<br>к элементам диапазона слева направо и записывает частичный результат каждой итерации (не включающий очередной элемент входного диапазона) в другой диапазон. Если вызываемый объект неассоциативен, результат алгоритма недетерминирован. Этот алгоритм представляет собой параллельный аналог алгоритма [[sum\|std::partial_sum]] |
| [[scan#std inclusive_scan\|std::inclusive_scan]]                     | Подобно предыдущему алгоритму, однако текущий элемент входного диапазона включается в соответствующий частичный результат, записываемый в выходной диапазон                                                                                                                                                                                                                                   |
| [[scan#std transform_exclusive_scan\|std::transform_exclusive_scan]] | Подобно алгоритму [[scan#std exclusive_scan\|std::exclusive_scan]], но с применением унарного преобразователя к каждому элементу входного диапазона                                                                                                                                                                                                                                           |
| [[scan#std transform_inclusive_scan\|std::transform_inclusive_scan]] | Подобно алгоритму [[scan#std inclusive_scan\|std::inclusive_scan]], но с применением унарного преобразователя к каждому элементу входного диапазона                                                                                                                                                                                                                                           |
| [[reduce#std reduce\|std::reduce]]                                   | Применяет вызываемый объект (требующий двух аргументов) ко всем элементам диапазона и начальному значению, возвращает итоговый результат. Если вызываемый объект неассоциативен или некоммутативен, результат недетерминирован. Представляет собой параллельный аналог алгоритма [[accumulate#std accumulate\|std::accumulate]]                                                               |
| [[reduce#std transform_reduce\|std::transform_reduce]]               | Применяет унарный вызываемый объект к входному диапазону (или бинарный вызываемый объект к двум входным диапазонам) и выполняет алгоритм [[reduce#std reduce\|std::reduce]] для полученных результатов                                                                                                                                                                                        |

Это краткое описание может оказаться непростым для понимания, но если уже знаком с алгоритмами [[accumulate#std accumulate|std::accumulate]] и [[sum#std partial_sum|std::partial_sum]], их параллельные вариации [[reduce#std reduce|std::reduce]] и [[scan#scan|std::scan]] также покажутся знакомыми. Алгоритм [[reduce#std reduce|std::reduce]] представляет собой параллельное дополнение к алгоритму [[accumulate#std accumulate|std::accumulate]], а два алгоритма [[scan#scan|std::scan]] – к алгоритму [[sum#std partial_sum|std::partial_sum]]. Параллельный характер вычислений есть та причина, по которой функции [[reduce#std reduce|std::reduce]], в отличие от функции [[accumulate#std accumulate|std::accumulate]], требуется ассоциативность и коммутативность вызываемого объекта. Это соображение справедливо и в отношении функций [[scan#scan|std::scan]], которые отличаются от функции [[sum#std partial_sum|std::partial_sum]] тем, что от вызываемого объекта требуют ассоциативности.

Разберём исчерпывающие примеры применения этих алгоритмов, а затем поговорим о том, как они связаны с парадигмой функционального программирования. Не станем останавливаться лишь на новой функции [[for_each#for_each|std::for_each]]. Её единственное отличие от более старой версии, известной начиная со стандарта C++ 98, состоит в том, что она не возвращает никакого значения, тогда как ранее возвращала унарную функцию. Если последовательный алгоритм [[accumulate#std accumulate|std::std::accumulate]] обрабатывает элементы по порядку, слева направо, то алгоритм [[reduce#std reduce|std::reduce]] делает это в произвольном порядке. Покажем для начала небольшой фрагмент кода, иллюстрирующий работу функций [[accumulate#std accumulate|std::accumulate]] и [[reduce#std reduce|std::reduce]]. Пусть обе применяют лямбда-функцию, перемножающую свои аргументы.

```c++
std::vector<int> v{1, 2, 3, 4};

std::accumulate(v.begin(), v.end(), 1, 
									[](int a, int b){ return a * b; });

std::reduce(std::execution::par, v.begin(), v.end(), 1,
									[](int a, int b){ return a * b; });
```

Следующие две диаграммы дают представление о стратегии вычислений, используемой функциями [[accumulate#std accumulate|std::accumulate]] и [[reduce#std reduce|std::reduce]]. Первая продвигается по контейнеру последовательно, на каждом шагу применяя бинарную операцию к ранее накопленному значению и очередному элементу.

![[ParallelProg_103.png]]

В противоположность ей вторая функция применяет бинарную операцию в заранее неопределённом порядке.

![[ParallelProg_104.png]]

Ассоциативность позволяет применять бинарную операцию к любым подряд стоящим парам элементов, а благодаря коммутативности вычислять промежуточные значения можно в любом порядке.

```c++
// newAlgorithm.cpp

#include <algorithm>
#include <execution>
#include <numeric>
#include <iostream>
#include <string>
#include <vector>

 int main(){
	// for_each_n
	{
		std::vector<int> intVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	
		std::for_each_n(std::execution::par, intVec.begin(), 5,
										[](int& arg){ arg *= arg; });
	
		std::cout << “for_each_n: “;
	
		for (auto v: intVec) 
			std::cout << v << “ “;
		
		std::cout << “\n\n”;	
	}

	// exclusive_scan 
	{
		std::vector<int> resVec{1, 2, 3, 4, 5, 6, 7, 8, 9};
	
		std::exclusive_scan( std::execution::par, 
						resVec.begin(), resVec.end(), resVec.begin(), 1,
						[](int fir, int sec){ return fir * sec; });
	
		std::cout << “exclusive_scan: “;
	
		for (auto v: resVec) 
			std::cout << v << “ “;
		
		std::cout << std::endl;	
	}

	//inclusive_scan
	{
		std::vector<int> resVec2{1, 2, 3, 4, 5, 6, 7, 8, 9};
	
		std::inclusive_scan(std::execution::par,
						resVec2.begin(), resVec2.end(), resVec2.begin(),
						[](int fir, int sec){ return fir * sec; },
						1);
						
		std::cout << “inclusive_scan: “;
		
		for (auto v: resVec2) 
			std::cout << v << “ “;
	
		std::cout << “\n\n”;	
	}

	// transform_exclusive_scan
	{
		std::vector<int> resVec3{1, 2, 3, 4, 5, 6, 7, 8, 9};
		std::vector<int> resVec4(resVec3.size());
	
		std::transform_exclusive_scan(std::execution::par,
						resVec3.begin(), resVec3.end(), resVec4.begin(), 
						0,
						[](int fir, int sec){ return fir + sec; },
						[](int arg){ return arg * arg; });
						
		std::cout << “transform_exclusive_scan: “;
		
		for (auto v: resVec4) 
			std::cout << v << “ “;
	
		std::cout << std::endl;	
	}

	// transform_inclusive_scan
	{
		std::vector<std::string> strVec{“Only”,”for”,”testing”,”purpose”};
		std::vector<int> resVec5(strVec.size());
	
		std::transform_inclusive_scan(std::execution::par,
						strVec.begin(), strVec.end(), resVec5.begin(),
						0,
						[](auto fir, auto sec){ return fir + sec; },
						[](auto s){ return s.length(); });
						
		std::cout << “transform_inclusive_scan: “;
		
		for (auto v: resVec5) 
			std::cout << v << “ “;
		
		std::cout << “\n\n”;	
	}

	// reduce and transform_reduce
	{
		std::vector<std::string> strVec2{
								“Only”,”for”,”testing”,”purpose”};

		std::string res = std::reduce(std::execution::par,
					strVec2.begin() + 1, strVec2.end(), strVec2[0],
					[](auto fir, auto sec){ return fir + “:” + sec; });

		std::cout << “reduce: “ << res << std::endl;
	
		std::size_t res7 = std::transform_reduce(std::execution::par,
					strVec2.begin(), strVec2.end(), 
					[](std::string s){ return s.length(); },
					0,
					[](std::size_t a, std::size_t b){ return a + b; });
	
		std::cout << “transform_reduce: “ << res7 << std::endl;	
	}
}
```

Новые параллельные алгоритмы применены здесь к вектору целых чисел, объявленному в строке 
`std::vector<int> intVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`, 
и к вектору строк, объявленному в строке 
`std::vector<std::string> strVec{“Only”,”for”,”testing”,”purpose”}`.

Алгоритм [[for_each#std for_each_n|std::for_each_n]] в строке `std::for_each_n( ... )` заменяет первые пять элементов вектора их квадратами.

Вызовы функций [[scan#std exclusive_scan|std::exclusive_scan]] в строке `std::exclusive_scan( ... )` и [[scan#std inclusive_scan|std::inclusive_scan]] в стро­ке `std::inclusive_scan( ... )` работают похожим образом. Обе применяют двухместную операцию к элементам диапазона. Различие состоит в том, что первая выдаёт промежуточное значение до того, как применить операцию к текущему элементу входного контейнера.

Вызов функции [[scan#std transform_exclusive_scan|std::transform_exclusive_scan]] довольно сложен для понимания и требует некоторых пояснений. К каждому элементу вектора `resVec3` сначала применяется лямбда-функция, возводящая его в квадрат. Затем к полученным значениям применяется операция сложения с нулём в качестве начального значения. Получаемые промежуточные результаты записываются в другой вектор `resVec4`.

Функция `std::transform_inclusive_scan` в работает сходным образом. Для каждой строки из входного контейнера вычисляется длина, затем полученные числа складываются, бегущие суммы помещаются в другой контейнер.

Работу функции [[reduce#std reduce|std::reduce]] понять просто: она вставляет двоеточие между каждой парой соседних элементов входного вектора строк. Чтобы строка-результат не начиналась с двоеточия, диапазон, к которому применяется алгоритм [[reduce#std reduce|std::reduce]], начинается со второго элемента (`strVec2.begin() + 1`), а в качестве начального значения берётся первый элемент `strVec2[0]`.

>**Превращение алгоритма [[reduce#std transform_reduce|transform_reduce]] в `map_reduce`**
>
> Функция [[reduce#std transform_reduce|transform_reduce]], заслуживает особого внимания. Заметим, во-первых, что алгоритм, названный `transform` в стандартной библиотеке языка C++, во многих других языках называется `map`. Поэтому функцию [[reduce#std transform_reduce|transform_reduce]] можно было бы также назвать `map_reduce`. Теперь читатель наверняка заметит, что функция [[reduce#std transform_reduce|transform_reduce]] есть не что иное, как реализация знаменитого параллельного алгоритма `MapReduce` на языке C++. В самом деле, эта функция применяет унарную функцию (в данном примере – функцию, возвращающую длину строки) к диапазону входных данных и затем сворачивает совокупность полученных значений в единственное значение-результат (в нашем примере – сумму длин).

Представленный на рисунке результат работы программы поможет понять работу этих алгоритмов.

![[ParallelProg_105.png]]

## Новые перегрузки

Все функции из семейств [[reduce#std reduce|reduce]] и [[scan#scan|scan]] в стандартной библиотеке языка C++ обладают несколькими перегруженными вариантами. В простейшей форме их можно вызывать без бинарной операции и начального значения. Если не передавать бинарную операцию, по умолчанию будет использовано сложение. Если же не задавать начальное значение, будет, в зависимости от алгоритма, использоваться такое значение:

* в алгоритмах [[scan#std inclusive_scan|std::inclusive_scan]] и [[scan#std transform_inclusive_scan|std::transform_inclusive_scan]] в качестве начального значения берётся первый элемент диапазона;
* в алгоритмах [[reduce#std reduce|std::reduce]] and [[reduce#std transform_reduce|std::transform_reduce]] берётся значение по умолчанию типа элемента входного диапазона:
```c++
typename std::iterator_traits<InputIt>::value_type{}
```

Посмотрим теперь на эти новые алгоритмы с точки зрения функционального программирования.

## Наследие функционального программирования

Если говорить кратко, то новые функции из стандарта языка C++ обладают прямыми аналогами в чистом функциональном языке `Haskell`:

* функция [[for_each#std for_each_n|for_each_n]] языка C++ соответствует в языке `Haskell` функции `map`;
* функции [[scan#std exclusive_scan|exclusive_scan]] и [[scan#std inclusive_scan|inclusive_scan]] соответствуют функциям `scanl` и `scanl1`;
* функции [[scan#std transform_exclusive_scan|transform_exclusive_scan]] и [[scan#std transform_inclusive_scan|transform_inclusive_scan]] подобны композиции функции `map` с функциями `scanl` и `scanl1`;
* функция [[reduce#std reduce|reduce]] делает то же, что в языке `Haskell` функции `foldl` и `foldl1`;
* функция [[reduce#std transform_reduce|transform_reduce]] соответствует композиции функции `map` с функциями `foldl` и `foldl1`.

Прежде чем продемонстрировать язык `Haskell` в действии, стоит сказать несколько слов об упомянутых здесь функциях:

* функция `map` применяет функцию к каждому элементу списка и строит список результатов;
* функции `foldl` и `foldl1` сворачивают список, применяя двухместную операцию ко всем его элементам и возвращая итоговое значение, причём функция `foldl` принимает начальное значение в качестве аргумента, а функция `foldl` требует, чтобы список был непустым – роль начального значения играет его первый элемент;
* функции `scanl` и `scanl1` применяют двухместную операцию к элементам списка, как функции `foldl` и `foldl1`, но возвращают список промежуточных результатов;
* функции `foldl`, `foldl1`, `scanl`, `scanl1` обрабатывают списки слева направо, т. е. от начала к концу.

Посмотрим на функции языка `Haskell` в действии. На следующем рисунке показано окно интерпретатора.

![[ParallelProg_106.png]]

В строках, помеченных цифрами (1) и (2), определены список целых чисел и список строк. В строке (3) к списку чисел применяется функция, возводящая свой аргумент в квадрат. Строки (4) и (5) несколько сложнее. Выражение (4) строит список произведений всех чисел с начала списка (1) до текущего элемента, начиная с числа 1 как нейтрального элемента умножения. Выражение 5 делает то же самое для операции сложения. Выражения (6), (7) и (9) бросают вызов тем, кто привык к императивному стилю. Читать их лучше справа налево. Выражение (7) представляет собой композицию функций. Точкой обозначается операция, которая результат одной функции (правого операнда) подаёт на вход другой (левого операнда). Сначала к списку-аргументу применяется функция `map`, которая каждой строке из входного списка ставит в соответствие её длину. Затем функция `scanl1` формирует список бегущих сумм. Выражение (9) похоже на (7) с тем отличием, что функция `foldl` вырабатывает лишь одно итоговое значение и требует начального значения – в данном случае это число 0. Выражение (8) должно быть понятным: оно соединяет между собой строки из входного списка, вставляя между ними двоеточие.

