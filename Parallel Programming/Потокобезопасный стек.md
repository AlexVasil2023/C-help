
[[#Потокобезопасный стек|Потокобезопасный стек]] 12.2
1. [[#Упрощённая реализация|Упрощённая реализация]] 12.2.1
2. [[#Полная реализация|Полная реализация]] 12.2.2

# Потокобезопасный стек

Прежде всего ответим на вопрос, что такое стек. Стек – это структура данных, работающая по принципу «последним пришёл – первым ушёл» (аргл. LIFO, last in first out). В стандартной библиотеке языка C++ есть специальный шаблон класса, для использования которого нужно подключить заголовочный файл `<stack>`. Из его функций-членов главные три.

![[ParallelProg_247.png]]

Вызов `sta.push(e)` помещает новый элемент e на вершину стека `sta`, вызов `sta.pop()` удаляет из стека верхний элемент, а вызов `sta.top()` возвращает ссылку на верхний элемент. Кроме того, стек в стандартной библиотеке поддерживает операции сравнения на равенство, неравенство и порядок, а также функцию-член, возвращающую его размер. Следующий код иллюстрирует работу со стеком.

```c++
#include <stack>

...

std::stack<int> myStack;

std::cout << myStack.empty() << ‘\n’;           // true
std::cout << myStack.size() << ‘\n’;            // 0

myStack.push(1);
myStack.push(2);
myStack.push(3);
std::cout << myStack.top() << ‘\n’;             // 3

while (!myStack.empty()){
	std::cout << myStack.top() << “ “;
	myStack.pop();
}                                               // 3 2 1

std::cout << myStack.empty() << ‘\n’;           // true
std::cout << myStack.size() << ‘\n’;            // 0
```

Построим потокобезопасный стек шаг за шагом.

## Упрощённая реализация

Первая реализация поддерживает только функцию-член `push`. Класс `ConcurrentStackPush` представляет собой лишь тонкую обёртку над стандартным типом [[stack#std stack|std::stack]].

**Потокобезопасный стек с операцией вталкивания:**
```c++
// concurrentStackPush.cpp

#include <list>
#include <mutex>
#include <stack>
#include <string>
#include <vector>
#include <utility>

template <typename T,
		template <typename, typename> class Cont = std::deque>
class ConcurrentStackPush {
	public:
		void push(T val) {
			std::lock_guard<std::mutex> lockStack(mutexStack);
			myStack.push(std::move(val));
		}

		ConcurrentStackPush() = default;
		ConcurrentStackPush(const ConcurrentStackPush&) = delete;
		ConcurrentStackPush& operator= (const ConcurrentStackPush&)
			= delete;
	
	private:
		mutable std::mutex mutexStack;
		std::stack<T, Cont<T, std::allocator<T>>> myStack;
};

int main() {
	ConcurrentStackPush<int> conStack;
	conStack.push(5);

	ConcurrentStackPush<double, std::vector> conStack2;
	conStack2.push(5.5);

	ConcurrentStackPush<std::string, std::list> conStack3;
	conStack3.push(“hello”);
}
```

С точки зрения параллельного программирования здесь существенно, что функция-член `push` этого класса, объявленная в строках `void push(T val) { ... }`, копирует новый элемент в подобъект `myStack`, объявленный в строке `std::stack<T, Cont<T, std::allocator<T>>> myStack;`. Благодаря мьютексу, объявленному в строке `mutable std::mutex mutexStack;`, эта операция потокобезопасна. Возможно, у читателя вызывает недоумение второй параметр шаблона. Параметр `Cont` представляет собой так называемый параметр-шаблон. По умолчанию в него подставляется шаблон [[deque#std deque (Очередь)|std::deque]]. Этот параметр-шаблон задаёт контейнер, в котором будут храниться элементы стека. Шаблон, подставляемый в параметр `Cont`, сам принимает два параметра: тип элемента и аллокатор (вспомогательный тип, отвечающий за распределение памяти). Данный параметр-шаблон применяется в строке `std::stack<T, Cont<T, std::allocator<T>>> myStack;` – сначала в него подставляются тип элемента и тип аллокатора, а затем получившийся тип подставляется в качестве второго аргумента в шаблон [[stack#std stack|std::stack]]. В строках `ConcurrentStackPush<int> conStack;`, `ConcurrentStackPush<double, std::vector> conStack2;` и `ConcurrentStackPush<std::string, std::list> conStack3;` показано, как объявить экземпляры шаблона `ConcurrentStackPush`, подставляя в него различные типы контейнеров – соответственно [[deque#std deque (Очередь)|std::deque]], [[vector#std vector|std::vector]] и [[list#std list|std::list]].

Стандартные шаблоны [[stack#std stack|std::stack]] и [[deque#std deque (Очередь)|std::queue]] – это так называемые адаптеры контейнеров, поскольку они служат обёртками над другими контейнерными типами и придают им интерфейс стека или очереди.

Читатель может спросить, отчего в приведённом выше примере потокобезопасный стек используется в однопоточном контексте и почему не показан результат работы программы. Ответ прост: когда у класса есть лишь одна функция-член, этого слишком мало для сколько-нибудь интересного примера. Показанный здесь класс `ConcurrentStackPush` может служить лишь отправной точкой для полной реализации.

## Полная реализация























