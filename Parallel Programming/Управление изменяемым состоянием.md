
[[#Управление изменяемым состоянием|Управление изменяемым состоянием]]
1. [[#Локальные блокировщики|Локальные блокировщики]] 9.2.1
2. [[#Параметризованные блокировщики|Параметризованные блокировщики]] 9.2.2
	1. [[#Шаблон «Стратегия»|Шаблон «Стратегия»]] 9.2.2.1
	2. [[#Реализация параметризованных блокировщиков|Реализация параметризованных блокировщиков]] 9.2.2.2

	


# Управление изменяемым состоянием

Если программа не пытается одновременно писать и читать одни и те же данные, гонка данных возникнуть не может. Самый простой способ добиться такого состояния – пользоваться неизменяемыми значениями. Помимо этого эмпирического правила широко распространены ещё две стратегии. Во-первых, критическую секцию можно защитить блокировщиком: [[#Локальные блокировщики|локальные блокировщики]] , [[#Параметризованные блокировщики|параметризованном блокировщики]]. В объектно-ориентированном программировании критическая секция обычно оформляется в виде объекта, обладающего определённым интерфейсом. Интерфейс называют потокобезопасным, если все его функции ставят блокировку на весь объект – см. #раздел_9_2_3. Во-вторых, поток, вносящий изменения в данные, может послать сигнал остальным потокам, когда его работа закончена. Эту стратегию называют охраняемой приостановкой, о ней речь пойдёт в #разделе_9_2_4.

## Локальные блокировщики

В основе локальных блокировщиков лежит идиома RAII (захват ресурса при инициализации), применённая к [[mutex|мьютексу]]. Напомним, эта идиома состоит в том, чтобы привязать захват и освобождение ресурса к началу и концу времени жизни объекта соответственно. Это, в свою очередь, означает, что владение ресурсом привязано к области видимости объекта: по правилам языка C++ с выходом за область видимости объекта автоматически вызывается его деструктор, что приводит к освобождению ресурса.

Показанный ниже класс `ScopedLock` представляет собой возможную реализацию локального блокировщика.

**Локальный блокировщик:**
```c++
// scopedLock.cpp

#include <iostream>
#include <mutex>
#include <new>
#include <string>
#include <utility>

class ScopedLock{
	private:
		std::mutex& mut;

	public:
		explicit ScopedLock(std::mutex& m): mut(m){
			mut.lock();
			std::cout << “Lock the mutex: “ << &mut << std::endl;
		}
	
		~ScopedLock(){
			std::cout << “Release the mutex: “ << &mut << std::endl;
			mut.unlock();
		}
};

int main(){
	std::cout << std::endl;

	std::mutex mutex1;
	ScopedLock scopedLock1{mutex1};

	std::cout << “\nBefore local scope” << std::endl;
	{
		std::mutex mutex2;
		ScopedLock scopedLock2{mutex2};
	}

	std::cout << “After local scope” << std::endl;

	std::cout << “\nBefore try-catch block” << std::endl;

	try{
		std::mutex mutex3;
		ScopedLock scopedLock3{mutex3};
		
		throw std::bad_alloc();
	}
	catch (std::bad_alloc& e){
		std::cout << e.what();
	}

	std::cout << “\nAfter try-catch block” << std::endl;

	std::cout << std::endl;
}
```

Конструктор класса `ScopedLock` получает [[mutex|мьютекс]] по ссылке. В конструкторе этот [[mutex|мьютекс]] запирается, а в деструкторе – отпирается. В соответствии с идиомой RAII деструкция объекта и, следовательно, освобождение [[mutex|мьютекса]] происходят автоматически.

![[ParallelProg_208.png]]

Область видимости объекта `scopedLock` простирается до конца главной функции. Следовательно, мьютекс `mutex1` отпирается с завершением программы. Мьютексы `mutex2` и `mutex3` объявлены во вложенных областях видимости. Для мьютекса `mutex3` предусмотрен выход из области видимости также и по исключению. Интересно, что для объекта `mutex3` повторно используется та же область памяти, которую раньше занимал объект `mutex`: программа печатает те же адреса.

Стандарт C++ 17 поддерживает блокировки четырёх видов. В библиотеке имеются шаблоны классов [[lock#Тип std lock_guard|std::lock_guard]] и [[lock#Тип std scoped_lock|std::scoped_lock]] для простых сценариев использования, когда мьютексы захватываются один раз при создании блокировщика и освобождаются только с его деструкцией, и шаблоны классов [[lock#Тип std unique_lock|std::unique_lock]] и [[lock#Блокировщик std shared_lock|std::shared_lock]] для более сложных случаев, предполагающих отпирание и повторное запирание блокировщика на протяжении времени его жизни. [[lock#Блокировщики|Подробнее о них]].

## Параметризованные блокировщики

Предположим, что нужно написать такой код (например, библиотеку), который должен использоваться в различных условиях, в том числе и в параллельных программах. Чтобы гарантировать корректную работу кода, критические секции в нём нужно защитить блокировками. Однако если библиотеку использовать в однопоточной среде, блокировки приведут к бессмысленной потере производительности, поскольку затратный механизм синхронизации, внедрённый в код библиотеки, оказывается ненужным. На выручку приходят параметризованные блокировщики.

Параметризованные блокировщики получаются, если шаблон проектирования «Стратегия» применить к обычным блокировщикам. Иными словами, различные стратегии блокирования критических секций нужно поместить в объекты с единым интерфейсом и подключать те или иные из них, в зависимости от потребностей. Для начала вспомним, что представляет собой шаблон «Стратегия».

### Шаблон «Стратегия»

![[ParallelProg_209.png]]

Шаблон «Стратегия» был описан ещё в классической книге «Банды четырёх», также известен под названием «Политика». Идея состоит в том, что семейство алгоритмов, по-разному решающих одну задачу, оформляется в виде семейства объектов, которые можно подключать к системе взаимозаменяемым образом. Следующая небольшая программа иллюстрирует основную идею шаблона.

**Шаблон «Стратегия»:**
```c++
// strategy.cpp

#include <iostream>
#include <memory>

class Strategy {
	public:
		virtual void operator()() = 0;
		virtual ~Strategy() = default;
};

class Context {
		std::shared_ptr<Strategy> _strat;
	
	public:
		explicit Context() : _strat(nullptr) {}
		
		void setStrategy(std::shared_ptr<Strategy> strat) {
			_strat = strat;
		}

		void strategy() { 
			if (_strat) 
				(*_strat)(); 
		}
};

class Strategy1 : public Strategy {
	
	void operator()() override {
		std::cout << “Foo” << std::endl;
	}
};

class Strategy2 : public Strategy {

	void operator()() override {
		std::cout << “Bar” << std::endl;
	}
};

class Strategy3 : public Strategy {

	void operator()() override {
		std::cout << “FooBar” << std::endl;
	}
};

int main() {
	std::cout << std::endl;

	Context con;

	con.setStrategy( std::shared_ptr<Strategy>(new Strategy1) );
	con.strategy();
	
	con.setStrategy( std::shared_ptr<Strategy>(new Strategy2) );
	con.strategy();
	
	con.setStrategy( std::shared_ptr<Strategy>(new Strategy3) );
	con.strategy();
	
	std::cout << std::endl;
}
```

Абстрактный класс `Strategy` определяет интерфейс, общий для всех конкретных стратегий. Всякая конкретная стратегия – например, классы `Strategy1`, `Strategy2` или `Strategy3` – должна поддерживать операцию функционального вызова. Класс `Context` играет роль клиента, пользующегося некоторой стратегией для своих вспомогательных задач. Конкретная стратегия устанавливается функцией `setStrategy` и применяется функцией `strategy`. Поскольку объект класса `Context` запускает стратегию через указатель на объект абстрактного класса `Strategy`, переопределение виртуальной функции-члена в них может быть скрыто в секции `private`. Объект `con` в главной функции программы поочерёдно пользуется разными стратегиями.

![[ParallelProg_211.png]]

### Реализация параметризованных блокировщиков





















