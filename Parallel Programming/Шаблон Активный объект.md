
[[#Активный объект|Активный объект]] 10.1
1. [[#Компоненты шаблона|Компоненты шаблона]] 10.1.1
2. [[#Преимущества и недостатки активных объектов|Преимущества и недостатки активных объектов]] 10.1.2
3. [[#Реализация|Реализация]] 10.1.3

# Активный объект

Шаблон проектирования «Активный объект» предполагает отделение выполнения функции-члена от её вызова для объектов, обладающих собственными потоками управления. Цель шаблона состоит в том, чтобы сделать работу системы параллельной за счёт асинхронных вызовов функций и планировщика, который управляет выполнением запросов.

Опишем данный шаблон более подробно. Когда клиент вызывает функцию-член объекта, на самом деле вызывается функция объекта-заместителя, который служит лишь интерфейсом активного объекта. Другой объект играет роль сервера и содержит реализацию всей функциональности активного объекта – он функционирует в отдельном потоке. Задача объекта-заместителя – превратить своих функций-членов в обращения к функциям объекта-сервера. Запросы к объекту-серверу ставятся в очередь, обработкой которой занимается планировщик. Планировщик постоянно выполняет цикл обработки событий, выбирает из очереди запросы по порядку и вызывает соответствующие функции объекта-сервера. Клиентский код получает результат вызова через посредство интерфейсного объекта-заместителя с помощью фьючерса.

## Компоненты шаблона

Шаблон «Активный объект» включает в себя шесть компонентов.

4. Объект-заместитель обеспечивает доступный для клиента интерфейс. Реализация интерфейсных функций объекта-заместителя состоит в создании запроса на вызов функции-члена и отправке его в очередь. Функции-члены этого объекта отрабатывают в клиентском потоке, который их вызывает.
5. Запрос на вызов функции – это объект данных, содержащий информацию о том, какую функцию и с какими аргументами нужно вызвать.
6. Очередь запросов – это линейная последовательность запросов на вызов, ожидающих своего выполнения. Она служит связующим звеном между клиентскими потоками, которые осуществляют вызовы, и потоком, в котором вызовы выполняются. Объект-заместитель помещает новые запросы в конец очереди, а планировщик изымает запросы из начала.
7. Планировщик работает в отдельном потоке. Он выбирает следующий по порядку запрос из очереди и вызывает соответствующую функцию-член объекта-сервера.
8. Объект-сервер содержит реализацию активного объекта. Его интерфейс совпадает с интерфейсом объекта-заместителя. Функции этого объекта вызываются в потоке планировщика.
9. Фьючерс, создаваемый объектом-заместителем. Он позволяет клиенту, обратившемуся к функции объекта-заместителя, получить результат вызова планировщиком соответствующей функции объекта-сервера. Клиент может как пассивно дождаться результата, так и активно опрашивать фьючерс на предмет готовности.

На следующем рисунке изображена последовательность взаимодействий между объектами, вместе составляющими активный объект.

![[ParallelProg_216.png]]

> **Объект-заместитель**
> 
> Шаблон проектирования «Заместитель» входит в число классических шаблонов, описанных в книге «Банды четырёх». В общем случае заместитель – это объект, который функционирует как представитель какого-либо иного объекта с тем же интерфейсом, делегируя ему свои функции. Типичными примерами могут служить объект-заместитель в технологии CORBA, заместитель, обеспечивающий безопасность объекта-сервера, виртуальный заместитель, создающий объект-сервер на лету, или умный указатель наподобие типа [[shared_ptr|std::shared_ptr]]. Всякий заместитель добавляет некоторую функциональность к объекту, который он замещает. Так, заместитель удалённого объекта инкапсулирует детали сетевого взаимодействия и создаёт у клиента иллюзию, будто объект-сервер функционирует на той же машине, что и клиент. Заместитель для обеспечения безопасности шифрует запросы к объекту-серверу и расшифровывает ответы от него. Виртуальный заместитель инкапсулирует создание тяжеловесного объекта-сервера в ленивом стиле. Наконец, умный указатель управляет временем жизни объекта-сервера.

![[ParallelProg_217.png]]

Основные характеристики шаблона таковы:

> объект-заместитель `Proxy` обладает тем же интерфейсом, что и объект-исполнитель `RealSubject`, содержит в себе ссылку на него и, возможно, управляет временем его жизни;
> 
> интерфейс `Subject` – общий для двух объектов: заместителя `Proxy` и исполнителя `RealSubject`;
> 
> объект `RealSubject` отвечает за реализацию всей полезной функциональности. Больше подробностей о шаблоне «Заместитель» можно почерпнуть в статье Википедии.

## Преимущества и недостатки активных объектов

Перед тем как показывать минимальную программную реализацию шаблона «Активный объект», перечислим его преимущества и недостатки. Начнём с преимуществ.

* Синхронизация только в потоке планировщика активного объекта, но не в клиентских потоках.
* Чёткое разграничение клиента (пользовательского кода) и сервера (реа­лизации функций объекта). При этом вся работа по синхронизации выполняется на стороне сервера.
* Повышение пропускной способности системы вследствие асинхронного способа обслуживания запросов. Продолжительные вызовы функций объекта-сервера не блокируют систему в целом.
* В планировщике можно реализовать различные стратегии выполнения ожидающих запросов. В зависимости от специфики задачи можно реализовать выполнение запросов не в том порядке, в котором они поступили.

Следует упомянуть также и о присущих данному шаблону недостатках.

* Если функции-члены активного объекта слишком просты и выполняются быстро, накладные расходы на прохождение вызова через объект-заместитель, очередь и планировщик могут оказаться чрезмерными.
* Наличие как собственного планировщика в составе активного объекта, так и планировщика потоков в операционной системе может сильно усложнить отладку активного объекта. Особенно сложной становится отладка, если задания выполняются сервером не в том порядке, в котором они заказаны клиентом.

## Реализация

Ниже представлена упрощённая реализация шаблона «Активный объект». Так, в этом коде отсутствует запрос на вызов как отдельного объекта данных, а планировщик всегда просто выбирает из очереди следующее задание. Типы данных, возникающие при работе с асинхронными заданиями, часто имеют слишком громоздкие имена, например:
```c++
std::future<std::vector<std::future<std::pair<bool, int>>>>
```

Во избежание этого в программе активно используется ключевое слово using.

**Активный объект:**
```c++
// activeObject.cpp

#include <algorithm>
#include <deque>
#include <functional>
#include <future>
#include <iostream>
#include <memory>
#include <mutex>
#include <numeric>
#include <random>
#include <thread>
#include <utility>
#include <vector>

using std::async;
using std::boolalpha;
using std::cout;
using std::deque;
using std::distance;
using std::endl;
using std::for_each;
using std::find_if;
using std::future;
using std::lock_guard;
using std::make_move_iterator;
using std::make_pair;
using std::move;
using std::mt19937;
using std::mutex;
using std::packaged_task;
using std::pair;
using std::random_device;
using std::sort;
using std::thread;
using std::uniform_int_distribution;
using std::vector;

class IsPrime {
	public:
		pair<bool, int> operator()(int i) {
			
			for (int j=2; j*j <= i; ++j) {
				if (i % j == 0) 
					return std::make_pair(false, i);
			}
			
			return std::make_pair(true, i);
		}
};

class ActiveObject {
	public:
		future<pair<bool, int>> enqueueTask(int i) {
			IsPrime isPrime;
			packaged_task<pair<bool, int>(int)> newJob(isPrime);
	
			auto isPrimeFuture = newJob.get_future();
			
			auto pair = make_pair(move(newJob), i);
			{
				lock_guard<mutex> lockGuard(activationListMutex);
				activationList.push_back(move(pair));
			}
			return isPrimeFuture;
		}
	
		void run() {
			thread servant([this] {
				while ( !isEmpty() ) {
					auto myTask = dequeueTask();
					myTask.first(myTask.second);
				}
			});
	
			servant.join();
		}
	private:
		pair<packaged_task<pair<bool, int>(int)>, int > dequeueTask() {
			lock_guard<mutex> lockGuard(activationListMutex);
			auto myTask= std::move(activationList.front());
			activationList.pop_front();
			return myTask;
		}
	
		bool isEmpty() {
			lock_guard<mutex> lockGuard(activationListMutex);
			auto empty = activationList.empty();
			return empty;
		}
	
		using TaskType = packaged_task<pair<bool, int>(int)>;
		deque<pair<TaskType, int>> activationList;
		mutex activationListMutex;
};

vector<int> getRandNumbers(int number) {
	random_device seed;
	mt19937 engine(seed());
	
	uniform_int_distribution<> dist(1000000, 1000000000);

	vector<int> numbers;
	
	for (long long i = 0 ; i < number; ++i)
		numbers.push_back(dist(engine));
	
	return numbers;
}

future<vector<future<pair<bool, int>>>> getFutures(
	ActiveObject& activeObject, int numberPrimes)
{
	return async([&activeObject, numberPrimes]{
		vector<future<pair<bool, int>>> futures;
		auto randNumbers = getRandNumbers(numberPrimes);

		for (auto numb: randNumbers){
			futures.push_back(activeObject.enqueueTask(numb));
		}

		return futures;
	});
}

int main() {
	cout << boolalpha << endl;

	ActiveObject activeObject;

	// a few clients enqueue work concurrently
	auto client1 = getFutures(activeObject, 1998);
	auto client2 = getFutures(activeObject, 2003);
	auto client3 = getFutures(activeObject, 2011);
	auto client4 = getFutures(activeObject, 2014);
	auto client5 = getFutures(activeObject, 2017);

	// give me the futures
	auto futures = client1.get();
	auto futures2 = client2.get();
	auto futures3 = client3.get();
	auto futures4 = client4.get();
	auto futures5 = client5.get();

	// put all futures together
	futures.insert(futures.end(),
		make_move_iterator(futures2.begin()),
		make_move_iterator(futures2.end()));

	futures.insert(futures.end(),
		make_move_iterator(futures3.begin()),
		make_move_iterator(futures3.end()));

	futures.insert(futures.end(),
		make_move_iterator(futures4.begin()),
		make_move_iterator(futures4.end()));

	futures.insert(futures.end(),
		make_move_iterator(futures5.begin()),
		make_move_iterator(futures5.end()));

	// run the promises
	activeObject.run();
	
	// get the results from the futures
	vector<pair<bool, int>> futResults;
	futResults.reserve(futures.size());

	for (auto& fut: futures) 
		futResults.push_back(fut.get());
	
	sort(futResults.begin(), futResults.end());

	// separate the primes from the non-primes
	auto prIt = find_if(futResults.begin(),futResults.end(),
		[](pair<bool, int> pa){ return pa.first == true; });

	cout
		<< “Total primes: “
		<< distance(prIt, futResults.end())
		<< endl;

	cout << “Primes:” << endl;

	for_each(prIt,futResults.end(),
		[](auto p){ cout << p.second << “ “;});
	
	cout << “\n\n”;
	
	cout
		<< “Total non-primes: “
		<< distance(futResults.begin(), prIt)
		<< endl;
	cout << “Non-primes:” << endl;

	for_each(futResults.begin(),prIt,
		[](auto p){ cout << p.second << “ “;} );

	cout << endl;
}
```

Принцип работы этой программы состоит в том, что клиенты, работая параллельно, добавляют в очередь свои задания, передавая в качестве аргумента целые числа. Задача сервера – определить, какие из этих чисел являются простыми. Очередь заданий здесь сделана частью активного объекта. Активный объект в отдельном потоке выбирает задания на выполнение, а клиенты получают результаты выполнения заданий. Рассмотрим подробнее внутреннее устройство программы. Пять клиентов (см. строки `auto client1 = getFutures(activeObject, 1998);` – `auto client5 = getFutures(activeObject, 2017);`) загружают активный объект работой через функцию `getFutures`. Эта функция принимает ссылку на активный объект, которому будет отправлена работа на выполнение, и целое число `numberPrimes` – количество случайных чисел в диапазоне от 1 000 000 до 1 000 000 000, которые нужно сгенерировать. Задания, отправленные активному объекту, складываются в контейнер – вектор фьючерсов. Фьючерс содержит в себе пару, первый компонент которой – логическое значение, а второй – то же целое число, которое послужило аргументом при запуске задания, причём логическое значение показывает, является ли число простым. Рассмотрим внимательнее строку `futures.push_back(activeObject.enqueueTask(numb));`. Она добавляет новое задание в очередь. Конечно, все операции над очередью синхронизированы. Очередь представляет собой контейнер объектов-обещаний. Каждое обещание, когда приходит время его выполнять, вызывает функциональный объект `IsPrime` (строки `class IsPrime { ... }`) с соответствующим аргументом. Возвращаемое значение – пара, состоящая из целого числа (того же, с которым был вызван функциональный объект) и логического значения, показывающего, простое ли оно. Таким образом, задания для последующего выполнения сформированы, пора приступить к вычислениям. Клиенты возвращают свои контейнеры фьючерсов в строках `auto futures = client1.get();` – `auto futures5 = client5.get();`. Слияние их в один контейнер (строки `futures.insert(... ` – и т.д.) упрощает дальнейшую обработку результатов. Вызов функции `run` активного объекта `activeObject` в строке `activeObject.run();` начинает выполнение заданий. Функция `run` запускает поток и выполняет задания из очереди, пока не окажутся выполненными все (строка `while ( !isEmpty() )`). Функция-член `isEmpty` (строка `bool isEmpty() { ... }`) определяет, пуста ли очередь, а функция-член `dequeTask` выбирает из очереди следующее задание. Цикл в строке `for (auto& fut: futures) futResults.push_back(fut.get());` извлекает из каждого фьючерса результат и помещает его в новый контейнер. Затем в строке `sort(futResults.begin(), futResults.end());` этот контейнер сортируется. 

Оставшаяся часть программы обрабатывает результаты вычислений. Итератор `ptIt` указывает на первое простое число в контейнере. Количество простых чисел определяется как расстояние между итератором `It` и концом контейнера, а количество чисел, не являющихся простыми, – как расстояние между началом контейнера и итератором `It`. На рисунке представлено лишь начало списка непростых чисел.

![[ParallelProg_218.png]]

Тщательно сделанной реализацией активного объекта на языке C++ можно ознакомиться по следующему пути `example/syscpp-master.zip`. 

