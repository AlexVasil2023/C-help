
[[#Вычисление суммы элементов вектора|Вычисление суммы элементов вектора]] 6.1
1. [[#Суммирование элементов вектора в одном потоке|Суммирование элементов вектора в одном потоке]] 6.1.1
	1. [[#Суммирование в цикле по диапазону|Суммирование в цикле по диапазону]] 6.1.1.1
	2. [[#Суммирование алгоритмом std accumulate|Суммирование алгоритмом std::accumulate]] 6.1.1.2
	3. [[#Использование блокировщика|Использование блокировщика]] 6.1.1.3
	4. [[#Использование атомарной переменной|Использование атомарной переменной]] 6.1.1.4  
	5. [[#Сводные данные по однопоточным алгоритмам|Сводные данные по однопоточным алгоритмам]] 6.1.1.5
2. [[#Многопоточное суммирование с общей переменной|Многопоточное суммирование с общей переменной]] 6.1.2
	1. [[#Использование блокировщика|Использование блокировщика]] 6.1.2.1
	2. [[#Использование атомарной переменной|Использование атомарной переменной]] 6.1.2.2
	3. [[#Использование атомарной переменной с функцией fetch_add|Использование атомарной переменной с функцией fetch_add]] 6.1.2.3
	4. [[#Использование ослабленной семантики|Использование ослабленной семантики]] 6.1.2.4
	5. [[#Сводные данные по алгоритмам с общей переменной|Сводные данные по алгоритмам с общей переменной]] 6.1.2.5
3. [[#Раздельное суммирование в потоках|Раздельное суммирование в потоках]] 6.1.3
	1. [[#Использование локальной переменной|Использование локальной переменной]] 6.1.3.1
		1. [[#Синхронизация итоговой суммы блокировщиком std lock_guard|Синхронизация итоговой суммы блокировщиком std::lock_guard]] 6.1.3.1.1
		2. [[#Сумма в атомарной переменной с последовательной согласованностью|Сумма в атомарной переменной с последовательной согласованностью]] 6.1.3.1.2
		3. [[#Использование атомарной переменной с ослабленной семантикой|Использование атомарной переменной с ослабленной семантикой]] 6.1.3.1.3
	2. [[#Использование переменных с потоковым временем жизни|Использование переменных с потоковым временем жизни]] 6.1.3.2
	3. [[#Использование асинхронных заданий|Использование асинхронных заданий]] 6.1.3.3
	4. [[#Сводные данные|Сводные данные]] 6.1.3.4
4. [[#Суммирование вектора подведение итогов|Суммирование вектора: подведение итогов]] 6.1.4
	1. [[#Однопоточные алгоритмы|Однопоточные алгоритмы]] 6.1.4.1
	2. [[#Многопоточные алгоритмы с общей переменной|Многопоточные алгоритмы с общей переменной]] 6.1.4.2
	3. [[#Многопоточные алгоритмы с локальными переменными|Многопоточные алгоритмы с локальными переменными]] 6.1.4.3

# Вычисление суммы элементов вектора

Какой способ сложения элементов контейнера [[vector#std vector|std::vector]] самый быстрый? Чтобы получить ответ, заполним контейнер [[vector#std vector|std::vector]] миллионом случайных, равномерно распределённых чисел от `1` до `10`. Задача будет состоять в том, чтобы вычислить суммы этих чисел множеством различных способов. Производительность однопоточного суммирования берётся в качестве основы для сравнения. В последующих разделах будут разобраны алгоритмы на основе атомарных переменных, блокировщиков, локальных данных потока и заданий. Начнём с простейшего однопоточного алгоритма.

## Суммирование элементов вектора в одном потоке

Даже однопоточный алгоритм можно реализовать несколькими способами.

### Суммирование в цикле по диапазону

Самый очевидный способ суммирования состоит в том, чтобы прибавлять очередной элемент к накопителю в цикле по диапазону. Само суммирование происходит в строке `sum += n;`.

**Суммирование в цикле по диапазону:**
```c++
// calculateWithLoop.cpp

#include <chrono>
#include <iostream>
#include <random>
#include <vector>

constexpr long long size = 100000000;

int main(){
	std::cout << std::endl;

	std::vector<int> randValues;
	randValues.reserve(size);

	// random values
	std::random_device seed;
	std::mt19937 engine(seed());
	std::uniform_int_distribution<> uniformDist(1, 10);

	for (long long i = 0 ; i < size ; ++i)
		randValues.push_back(uniformDist(engine));

	const auto sta = std::chrono::steady_clock::now();

		unsigned long long sum = {};
		for (auto n: randValues) 
			sum += n;

	const std::chrono::duration<double> dur =
							std::chrono::steady_clock::now() – sta;

	std::cout << “Time for addition “ << dur.count()
										<< “ seconds” << std::endl;
	std::cout << “Result: “ << sum << std::endl;

	std::cout << std::endl;
}
```

получились результаты, представленные на следующих двух рисунках.

![[ParallelProg_114.png]]
![[ParallelProg_115.png]]

Однако не стоит использовать циклы в явном виде. В большинстве случаев лучше пользоваться алгоритмами из стандартной библиотеки.

### Суммирование алгоритмом std::accumulate

Алгоритм [[accumulate#std accumulate|std::accumulate]] представляет собой наиболее правильное средство для суммирования элементов вектора. Для экономии места ниже показан лишь вызов функции, весь остальной код идентичен предыдущему.

**Суммирование алгоритмом [[accumulate#std accumulate|std::accumulate]]:**
```c++
// calculateWithStd.cpp

...

const unsigned long long sum = std::accumulate(
								randValues.begin(), randValues.end(), 0);
```

В системе Linux алгоритм [[accumulate#std accumulate|std::accumulate]] показывает примерно такую же производительность, что и цикл по диапазону. Однако в системе Windows различие значительно, и функция [[accumulate#std accumulate|std::accumulate]] явно выигрывает у цикла, как видно из следующих рисунков.

![[ParallelProg_116.png]]
![[ParallelProg_117.png]]

Теперь у нас есть опорные значения. Прежде чем переходить к параллельным алгоритмам, посмотрим ещё на две однопоточные реализации: одну с [[mutex|блокировщиком]] и другую – с [[atomic|атомарной переменной]]. Тем самым мы сможем точно измерить накладные расходы, которые влечёт за собой использование этих средств синхронизации, в отсутствие коллизий.

### Использование блокировщика

Если доступ к переменной-накопителю суммы защитить блокировщиком, можно получить ответы на следующие вопросы.

1.	Сколь затратна синхронизация посредством блокировщика при отсутствии коллизий?
2. Сколь быстрым может быть блокировщик в оптимальном случае?

Ниже показан лишь фрагмент кода, непосредственно связанный с использованием блокировщика [[lock#Тип std lock_guard|std::lock_guard]]. 

**Суммирование с блокировкой доступа к переменной-накопителю:**
```c++
// calculateWithLock.cpp

...

std::mutex myMutex;

for (auto i: randValues){
	std::lock_guard<std::mutex> myLockGuard(myMutex);
	sum += i;
}
```

Время выполнения алгоритма изменилось ожидаемым образом: доступ к переменной `sum` теперь осуществляется медленнее, как видно из следующих рисунков.

![[ParallelProg_118.png]]
![[ParallelProg_119.png]]

Таким образом, использование блокировщика [[lock#Тип std lock_guard|std::lock_guard]], даже при полном отсутствии коллизий, обходится в 50 – 150 раз дороже, чем использование стандартного алгоритма [[accumulate#std accumulate|std::accumulate]]. Посмотрим теперь, как обстоит дело с атомарными переменными.

### Использование атомарной переменной

Для [[atomic|атомарных переменных]] нужно дать ответы на те же два вопроса, которые интересовали нас в связи с [[lock|блокировщиками]].

1. Насколько дорого обходится использование [[atomic|атомарных переменных]]?
2.	Сколь быстрой может быть [[atomic|атомарная переменная]] в отсутствие коллизий?

Кроме того, поставим ещё один вопрос: каково различие в производительности [[lock|блокировщиков]] и [[atomic|атомарных переменных]]?

**Суммирование с использованием атомарной переменной-накопителя:**
```c++
// calculateWithAtomic.cpp

#include <atomic>
#include <chrono>
#include <iostream>
#include <numeric>
#include <random>
#include <vector>

constexpr long long size = 100000000;

int main(){
	std::cout << std::endl;

	std::vector<int> randValues;
	randValues.reserve(size);

	// random values
	std::random_device seed;
	std::mt19937 engine(seed());

	std::uniform_int_distribution<> uniformDist(1, 10);

	for (long long i = 0 ; i < size ; ++i)
		randValues.push_back(uniformDist(engine));

	std::atomic<unsigned long long> sum = {};

	std::cout << std::boolalpha << “sum.is_lock_free(): “
									<< sum.is_lock_free() << std::endl;

	std::cout << std::endl;

	auto sta = std::chrono::steady_clock::now();

		for (auto i: randValues) 
			sum += i;

	std::chrono::duration<double> dur = 
								std::chrono::steady_clock::now() – sta;

	std::cout << “Time for addition “ << dur.count()
											<< “ seconds” << std::endl;
	std::cout << “Result: “ << sum << std::endl;

	std::cout << std::endl;

	sum=0;

	sta = std::chrono::steady_clock::now();

		for (auto i: randValues) 
			sum.fetch_add(i);

	dur = std::chrono::steady_clock::now() – sta;

	std::cout << “Time for addition “ << dur.count()
											<< “ seconds” << std::endl;
	std::cout << “Result: “ << sum << std::endl;

	std::cout << std::endl;
}
```

Сначала, в строке `sum.is_lock_free()`, выполняется проверка, не использует ли переменная `sum` блокировку. Эта проверка необходима, так как в худшем случае может не оказаться разницы между использованием атомарных переменных и [[lock|блокировок]], как в предыдущей программе. На всех сколько-нибудь распространённых платформах, [[atomic|атомарные переменные]] свободны от [[lock|блокировок]]. Сумма в этой программе вычисляется двумя способами. В строке `sum += i;` используется перегруженная операция `+=`, тогда как в строке `sum.fetch_add(i);` – функция [[atomic#Атомарные типы с плавающей точкой в стандарте C++20|std::fetch_add]]. При выполнении в один поток оба варианта демонстрируют примерно одинаковую производительность, однако функция [[atomic#Атомарные типы с плавающей точкой в стандарте C++20|std::fetch_add]] позволяет в явном виде указывать порядок доступа к памяти, что будет использоваться в дальнейших разделах. Результаты работы программы показаны ниже.

![[ParallelProg_120.png]]
![[ParallelProg_121.png]]

### Сводные данные по однопоточным алгоритмам

Анализ полученных данных позволяет прийти к следующим трём выводам.
1. В системах Windows и Linux [[atomic|атомарные переменные]] ведут себя в 12 – 50 раз медленнее, чем алгоритм [[accumulate#std accumulate|std::accumulate]] без синхронизации.
2. [[atomic|Атомарные переменные]] в 2 – 3 раза быстрее [[lock|блокировок]] в системах Windows и Linux.
3. Реализация функции [[accumulate#std accumulate|std::accumulate]], доступная в системе Windows, по-видимому, чрезвычайно оптимизирована.

Прежде чем рассмотреть многопоточные реализации, соберём в таблицу результаты работы всех однопоточных алгоритмов. Все значения даны в секундах.

**Производительность однопоточных алгоритмов:**

| **Операционная система<br>и компилятор** | **Цикл<br>по диапазону** | **Функция<br>accumulate** | **Блокировщик** | **Атомарная<br>переменная** |
| ---------------------------------------- | ------------------------ | ------------------------- | --------------- | --------------------------- |
| Linux (GCC)                              | 0,07                     | 0,07                      | 3,34            | 1,34<br>1,33                |
| Windows (cl.exe)                         | 0,08                     | 0,03                      | 4,07            | 1,50<br>1,61                |

## Многопоточное суммирование с общей переменной

Читатель наверняка уже может предвидеть результат этого раздела. Использование общей переменной из четырёх потоков неоптимально, так как накладные расходы на синхронизацию доступа к ней превышают выигрыш от распараллеливания вычислений. В последующих разделах будут получены соответствующие числовые данные. Вопросы, на которые предстоит найти ответ, остаются прежними.

1. Насколько различается производительность алгоритмов суммирования с использованием [[lock|блокировки]] и [[atomic|атомарной переменной]]?
2. Насколько различается производительность однопоточного и многопоточного выполнений функции [[accumulate|std::accumulate]]?

### Использование блокировщика

Простейший способ сделать суммирование потокобезопасным – использовать блокировщик [[lock#Тип std lock_guard|std::lock_guard]].

**Многопоточное суммирование с блокировкой:**
```c++
// synchronisationWithLock.cpp
#include <chrono>
#include <iostream>
#include <mutex>
#include <random>
#include <thread>
#include <utility>
#include <vector>

constexpr long long size = 100000000;

constexpr long long fir = 25000000;
constexpr long long sec = 50000000;
constexpr long long thi = 75000000;
constexpr long long fou = 100000000;

std::mutex myMutex;

void sumUp(unsigned long long& sum, const std::vector<int>& val,
				unsigned long long beg, unsigned long long end){

	for (auto it = beg; it < end; ++it){
		std::lock_guard<std::mutex> myLock(myMutex);

		sum += val[it];
	}
}

int main(){
	std::cout << std::endl;

	std::vector<int> randValues;
	randValues.reserve(size);

	std::mt19937 engine;
	std::uniform_int_distribution<> uniformDist(1,10);
	
	for (long long i = 0 ; i < size ; ++i)
		randValues.push_back(uniformDist(engine));

	unsigned long long sum= 0;

	const auto sta = std::chrono::steady_clock::now();

	std::thread t1(sumUp, std::ref(sum), std::ref(randValues), 0, fir);
	std::thread t2(sumUp, std::ref(sum), std::ref(randValues), fir, sec);
	std::thread t3(sumUp, std::ref(sum), std::ref(randValues), sec, thi);
	std::thread t4(sumUp, std::ref(sum), std::ref(randValues), thi, fou);

	t1.join();
	t2.join();
	t3.join();
	t4.join();

	const std::chrono::duration<double> dur =
								std::chrono::steady_clock::now() – sta;
	
	std::cout << “Time for addition “ << dur.count()
											<< “ seconds” << std::endl;
	std::cout << “Result: “ << sum << std::endl;

	std::cout << std::endl;
}
```

Принцип работы этой программы объяснить легко. Функция `sumUp`, объявленная в строках `void sumUp( ... ) { ... }`, выполняется одновременно из нескольких потоков. Эта функция получает по ссылке переменную-накопитель `sum` и контейнер `val`. Параметры `beg` и `end` задают отрезок контейнера, в котором нужно выполнить суммирование. Блокировщик типа [[lock#Тип std lock_guard|std::lock_guard]] в строке `std::lock_guard<std::mutex> myLock(myMutex);` используется для того, чтобы защитить общую переменную от гонки данных. Каждый из четырёх потоков выполняет четверть общего объёма вычислений. Результаты измерения производительности этой программы показаны ниже.

![[ParallelProg_122.png]]
![[ParallelProg_123.png]]

Столь низкая производительность объясняется наличием узкого места – общей переменной `sum`, доступ к которой синхронизируется тяжеловесным блокировщиком [[lock#Тип std lock_guard|std::lock_guard]]. Сразу приходит в голову очевидное решение: заменить тяжеловесный блокировщик быстрой атомарной переменной.

### Использование атомарной переменной

Сделаем теперь переменную-накопитель суммы атомарной. Это означает, что блокировщик [[lock#Тип std lock_guard|std::lock_guard]] более не нужен. Ниже показана видоизменённая функция `sumUp`.

**Суммирование элементов вектора с помощью атомарной переменной:**
```c++
// synchronisationWithAtomic.cpp

...

void sumUp(std::atomic<unsigned long long>& sum,
			const std::vector<int>& val,
			unsigned long long beg,
			unsigned long long end)
{
	for (auto it = beg; it < end; ++it)
		sum += val[it];
}
```

В операционной системе Windows эта программа показала довольно странный результат: синхронизация с помощью [[lock|блокировщика]] оказалась быстрее решения на основе [[atomic|атомарной переменной]] более чем вдвое. Результат работы программы показан на рисунке.

![[ParallelProg_124.png]]
![[ParallelProg_125.png]]

Помимо операции `+=`, к атомарной переменной можно применять функцию-член [[atomic#Атомарные типы с плавающей точкой в стандарте C++20|std::fetch_add]]. Посмотрим, что из этого получится.

### Использование атомарной переменной с функцией fetch_add

Исходный код почти не подвергся изменениям. Лишь в одной строке пришлось изменить операцию сложения на вызов функции-члена [[atomic#Атомарные типы с плавающей точкой в стандарте C++20|std::fetch_add]].

**Суммирование с атомарной переменной с функцией [[atomic#Атомарные типы с плавающей точкой в стандарте C++20|std::fetch_add]]:**
```c++
// synchronisationWithFetchAdd.cpp

...

void sumUp(std::atomic<unsigned long long>& sum,
				const std::vector<int>& val,
				unsigned long long beg,
				unsigned long long end)
{
	for (auto it = beg; it < end; ++it) {
		sum.fetch_add(val[it]);
	}
}
```

Эта программа обладает почти такой же производительностью, как и предыдущий пример. Таким образом, различие между операцией `+=` и функцией [[atomic#Атомарные типы с плавающей точкой в стандарте C++20|std::fetch_add]] оказалось незначительным.

![[ParallelProg_126.png]]
![[ParallelProg_127.png]]

Хотя замена перегруженной операции `+=` функцией [[atomic#Атомарные типы с плавающей точкой в стандарте C++20|std::fetch_add]] никак не сказалась на производительности программы, последний вариант всё же обладает одним преимуществом: он позволяет в явном виде ослабить требования к упорядочению доступа к памяти, то есть применить ослабленную семантику.

### Использование ослабленной семантики

Изменение в исходном коде снова затрагивает лишь одну строку.

```c++
// synchronisationWithFetchAddRelaxed.cpp
...
void sumUp(std::atomic<unsigned long long>& sum,
					const std::vector<int>& val,
					unsigned long long beg,
					unsigned long long end)
{
	for (auto it = beg; it < end; ++it) {
		sum.fetch_add(val[it], std::memory_order_relaxed);
	}
}
```

По умолчанию [[atomic|атомарные переменные]] работают в модели последовательной согласованности. Это справедливо для комбинированной операции сложения с присваиванием и, конечно, для функции [[atomic#Атомарные типы с плавающей точкой в стандарте C++20|std::fetch_add]], но поведение последней можно оптимизировать. В этой программе порядок доступа к памяти заменён с используемого по умолчанию на ослабленный. Это слабейшая из всех моделей памяти и тем самым конечная точка оптимизации решения на базе общей переменной.

Ослабленная семантика допустима в данном случае потому, что предоставляет две гарантии: во-первых, каждая из операций [[atomic#Атомарные типы с плавающей точкой в стандарте C++20|std::fetch_add]] происходит атомарно, во-вторых – операции, выполняемые из различных потоков, окончательно синхронизируются между собой вызовом функции `join`. Слабейшая модель памяти позволяет добиться наилучшей (среди решений, основанных на общей переменной) производительности, как явствует из следующих рисунков.

![[ParallelProg_128.png]]
![[ParallelProg_129.png]]

### Сводные данные по алгоритмам с общей переменной

Полученные в описанных экспериментах данные сведены в следующую таблицу. Все величины даны в секундах.

**Производительность многопоточных алгоритмов с общей переменной**

| **Операционная система<br>и компилятор** | **lock_guard** | **+=** | **fetch_add** | **Ослабленная<br>семантика** |
| ---------------------------------------- | -------------- | ------ | ------------- | ---------------------------- |
| Linux (GCC)                              | 20,81          | 7,78   | 7,87          | 7,66                         |
| Windows (cl.exe)                         | 6,22           | 15,73  | 15,78         | 15,01                        |

Результаты экспериментов выглядят не слишком обнадёживающими. Вариант с атомарной общей переменной и ослабленной семантикой операций над ней работает примерно в сто раз медленнее, чем однопоточный алгоритм [[accumulate|std::accumulate]].

Попробуем теперь соединить две предыдущие стратегии суммирования. Будем использовать четыре потока, но сведём к минимуму синхронизацию между ними.

## Раздельное суммирование в потоках

Есть несколько способов минимизировать синхронизацию потоков. Так, можно воспользоваться локальными переменными, переменными потоков и заданиями.

### Использование локальной переменной

Если каждый поток пользуется собственной локальной переменной для подсчёта суммы своего участка контейнера, он может выполнять свою работу без какой бы то ни было синхронизации. Синхронизация понадобится только для того, чтобы сложить между собой результаты работы отдельных потоков. Последнее сложение играет в алгоритме ключевую роль, и его, конечно, нужно защитить от гонки данных. Есть разные способы сделать это. Отметим, что поскольку подсчёт окончательного результата требует сложения лишь четырёх чисел, для производительности алгоритма не имеет значения, какой способ синхронизации при этом используется. В следующих примерах применяются: блокировщик [[lock#Тип std lock_guard#std::lock_guard]], [[atomic|атомарная переменная]] с последовательной согласованностью операций и с ослабленной семантикой.

#### Синхронизация итоговой суммы блокировщиком std::lock_guard

**Раздельное суммирование и минимальная синхронизация блокировщиком:**
```c++
// localVariable.cpp

#include <mutex>
#include <chrono>
#include <iostream>
#include <random>
#include <thread>
#include <utility>
#include <vector>

constexpr long long size = 100000000;

constexpr long long fir = 25000000;
constexpr long long sec = 50000000;
constexpr long long thi = 75000000;
constexpr long long fou = 100000000;

std::mutex myMutex;

void sumUp(unsigned long long& sum, const std::vector<int>& val,
				unsigned long long beg, unsigned long long end){

	unsigned long long tmpSum{};
	for (auto i = beg; i < end; ++i){
		tmpSum += val[i];
	}

	std::lock_guard<std::mutex> lockGuard(myMutex);

	sum += tmpSum;
}

int main(){
	std::cout << std::endl;

	std::vector<int> randValues;
	randValues.reserve(size);
	
	std::mt19937 engine;
	std::uniform_int_distribution<> uniformDist(1, 10);

	for (long long i = 0; i < size; ++i)
		randValues.push_back(uniformDist(engine));

	unsigned long long sum{};

	const auto sta = std::chrono::system_clock::now();

	std::thread t1(sumUp, std::ref(sum), std::ref(randValues), 0, fir);
	std::thread t2(sumUp, std::ref(sum), std::ref(randValues), fir, sec);
	std::thread t3(sumUp, std::ref(sum), std::ref(randValues), sec, thi);
	std::thread t4(sumUp, std::ref(sum), std::ref(randValues), thi, fou);

	t1.join();
	t2.join();
	t3.join();
	t4.join();

	const std::chrono::duration<double> dur =
							std::chrono::system_clock::now() – sta;

	std::cout << “Time for addition “ << dur.count()
							<< “ seconds” << std::endl;
	std::cout << “Result: “ << sum << std::endl;

	std::cout << std::endl;
}
```

Здесь представляют интерес строки `std::lock_guard<std::mutex> lockGuard(myMutex);` и `sum += tmpSum;`. В них локальная сумма `tmpSum` прибавляется к глобальному накопителю `sum`. Производительность этой программы показана на следующих рисунках.

![[ParallelProg_130.png]]
![[ParallelProg_131.png]]

В следующих двух вариантах решения с локальной переменной меняется лишь функция `sumUp`, поэтому только её текст и будет показан. Полный исходный текст примеров можно найти на сайте.

#### Сумма в атомарной переменной с последовательной согласованностью

Изменим тип глобальной переменной `sum`, в которой накапливается итоговая сумма, на атомарный.

**Раздельное суммирование с итоговой суммой в атомарной переменной:**
```c++
// localVariableAtomic.cpp

...

void sumUp(std::atomic<unsigned long long>& sum,
			const std::vector<int>& val, 
			unsigned long long beg,
			unsigned long long end)
{
	unsigned long long tmpSum{};

	for (auto i = beg; i < end; ++i){
		tmpSum += val[i];
	}

	sum += tmpSum;
}
```

Измерение производительности даёт следующие результаты.

![[ParallelProg_132.png]]
![[ParallelProg_133.png]]

#### Использование атомарной переменной с ослабленной семантикой

Предыдущее решение можно ещё немного улучшить. Воспользуемся ослабленной семантикой вместо порядка доступа к памяти по умолчанию. Поведение программы останется вполне определённым, так как для её правильного функционирования нужны лишь две гарантии: что все операции прибавления к итоговой сумме произойдут и будут атомарными.

**Раздельное суммирование вектора с ослабленной семантикой:**
```c++
// localVariableAtomicRelaxed.cpp

...

void sumUp(std::atomic<unsigned long long>& sum,
				const std::vector<int>& val,
				unsigned long long beg,
				unsigned long long end)
{
	unsigned long long tmpSum{};

	for (auto i = beg; i < end; ++i){
		tmpSum += val[i];
	}

	sum.fetch_add(tmpSum, std::memory_order_relaxed);
}
```

Как и можно было ожидать, производительность алгоритма с раздельным суммированием никак не зависит от того, используется в ней [[lock|блокировщик]], [[atomic|атомарная переменная]] с последовательной согласованностью операций или же ослабленная семантика.

![[ParallelProg_134.png]]
![[ParallelProg_135.png]]

Данные потоков – это частный случай локальных данных. Их время жизни ограничено временем работы владеющих ими потоков, а не временем работы одной функции, как у обычных локальных переменных наподобие переменной `tmpSum` из предыдущего примера.

### Использование переменных с потоковым временем жизни

Переменная с потоковым временем жизни (также называемая потоковой переменной) принадлежит тому потоку, в котором была создана. Такая переменная появляется в памяти только тогда, когда становится нужна. Поэтому потоковая длительность хранения как нельзя лучше подходит для переменной `tmpSum`.

**Раздельное суммирование c использованием потоковой переменной:**
```c++
// threadLocalSummation.cpp

#include <atomic>
#include <chrono>
#include <iostream>
#include <random>
#include <thread>
#include <utility>
#include <vector>

constexpr long long size = 100000000;

constexpr long long fir = 25000000;
constexpr long long sec = 50000000;
constexpr long long thi = 75000000;
constexpr long long fou = 100000000;

thread_local unsigned long long tmpSum = 0;

void sumUp(std::atomic<unsigned long long>& sum,
					const std::vector<int>& val,
					unsigned long long beg,
					unsigned long long end)
{
	for (auto i = beg; i < end; ++i){
		tmpSum += val[i];
	}

	sum.fetch_add(tmpSum, std::memory_order_relaxed);
}

int main(){
	std::cout << std::endl;

	std::vector<int> randValues;
	randValues.reserve(size);

	std::mt19937 engine;
	std::uniform_int_distribution<> uniformDist(1, 10);
	
	for (long long i = 0; i < size; ++i)
		randValues.push_back(uniformDist(engine));

	std::atomic<unsigned long long> sum{};

	const auto sta = std::chrono::system_clock::now();

	std::thread t1(sumUp, std::ref(sum), std::ref(randValues), 0, fir);
	std::thread t2(sumUp, std::ref(sum), std::ref(randValues), fir, sec);
	std::thread t3(sumUp, std::ref(sum), std::ref(randValues), sec, thi);
	std::thread t4(sumUp, std::ref(sum), std::ref(randValues), thi, fou);

	t1.join();
	t2.join();
	t3.join();
	t4.join();

	const std::chrono::duration<double> dur=
								std::chrono::system_clock::now() – sta;
	std::cout << “Time for addition “ << dur.count()
								<< “ seconds” << std::endl;
	std::cout << “Result: “ << sum << std::endl;

	std::cout << std::endl;
}
```

Переменная `tmpSum` с потоковым временем жизни объявляется в строке `thread_local unsigned long long tmpSum = 0;` и используется в строках `tmpSum += val[i];` и `sum.fetch_add(tmpSum, std::memory_order_relaxed);`. Ниже представлены результаты измерения производительности этой программы.

![[ParallelProg_136.png]]
![[ParallelProg_137.png]]

Наконец, остаётся рассмотреть решение на основе асинхронных заданий.

### Использование асинхронных заданий

Воспользовавшись заданиями, можно сделать всю работу, не прибегая к явной синхронизации потоков. Каждый фрагмент контейнера суммируется в отельном потоке, а окончательный результат подсчитывается в главном потоке. Полный текст программы представлен ниже.

**Суммирование вектора на основе заданий:**
```c++
// tasksSummation.cpp

#include <chrono>
#include <future>
#include <iostream>
#include <random>
#include <thread>
#include <utility>
#include <vector>

constexpr long long size = 100000000;

constexpr long long fir = 25000000;
constexpr long long sec = 50000000;
constexpr long long thi = 75000000;
constexpr long long fou = 100000000;

void sumUp(std::promise<unsigned long long>&& prom,
						const std::vector<int>& val,
						unsigned long long beg,
						unsigned long long end)
{
	unsigned long long sum={};
	for (auto i = beg; i < end; ++i){
		sum += val[i];
	}
	prom.set_value(sum);
}

int main(){
	std::cout << std::endl;

	std::vector<int> randValues;
	randValues.reserve(size);

	std::mt19937 engine;
	std::uniform_int_distribution<> uniformDist(1,10);
	for (long long i = 0; i < size; ++i)
		randValues.push_back(uniformDist(engine));

	std::promise<unsigned long long> prom1;
	std::promise<unsigned long long> prom2;
	std::promise<unsigned long long> prom3;
	std::promise<unsigned long long> prom4;

	auto fut1= prom1.get_future();
	auto fut2= prom2.get_future();
	auto fut3= prom3.get_future();
	auto fut4= prom4.get_future();

	auto sta = std::chrono::system_clock::now();

	std::thread t1(
				sumUp, std::move(prom1), std::ref(randValues), 0, fir);
	std::thread t2(
				sumUp, std::move(prom2), std::ref(randValues), fir, sec);
	std::thread t3(
				sumUp, std::move(prom3), std::ref(randValues), sec, thi);
	std::thread t4(
				sumUp, std::move(prom4), std::ref(randValues), thi, fou);

	auto sum= fut1.get() + fut2.get() + fut3.get() + fut4.get();

	const std::chrono::duration<double> dur =
						std::chrono::system_clock::now() – sta;

	std::cout << “Time for addition “ << dur.count()
						<< “ seconds” << std::endl;
	std::cout << “Result: “ << sum << std::endl;

	t1.join();
	t2.join();
	t3.join();
	t4.join();

	std::cout << std::endl;
}
```

В строках `std::promise<unsigned long long> prom1;` – `std::promise<unsigned long long> prom4;` объявляются четыре объекта-обещания, а в строках `auto fut1= prom1.get_future();`– `auto fut4= prom4.get_future();` создаются связанные с ними [[future|фьючерсы]]. [[promise|Обещания]] передаются запускающимся потокам. Следует отметить, что [[promise|обещания]] не могут копироваться – их можно только перемещать. Четыре потока выполняют функцию `sumUp`. Функция `sumUp` принимает свой первый аргумент – [[promise|обещание]] – по ссылке [[rvalue|rvalue]]. В строке `auto sum= fut1.get() + fut2.get() + fut3.get() + fut4.get();` главный поток запрашивает у [[future|фьючерсов]] (посредством блокирующего вызова `get`) значения, подсчитанные четырьмя потоками. На следующих рисунках показаны результаты запуска этой программы.

![[ParallelProg_138.png]]
![[ParallelProg_139.png]]

В заключение раздела приведём сводку показателей производительности алгоритмов, основанных на использовании локальных переменных.

### Сводные данные

Как явствует из результатов измерений, нет большой разницы между использованием асинхронных заданий и локальных переменных (со всевозможными механизмами синхронизации для подсчёта итогового значения, например атомарных переменных). Лишь потоковые переменные, по-видимому, несколько замедляют работу программы. Это замедление наблюдается на обоих операционных системах: Windows и Linux. Различие времени работы одного и того же алгоритма в ОС Windows и Linux не говорит ни о чём, так как измерения проводились на различных компьютерах.

**Производительность алгоритмов с локальными переменными:**

| **ОС и компилятор** | **lock_guard** | **Атомарные<br>переменные<br>с последовательной<br>согласованностью** | **Атомарные<br>переменные<br>с ослабленной<br>семантикой** | **Переменные потоков** | Задания |
| ------------------- | -------------- | --------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------- | ------- |
| Linux (GCC)         | 0,03           | 0,03                                                                  | 0,03                                                       | 0,04                   | 0,03    |
| Windows (cl.exe)    | 0.10           | 0.10                                                                  | 0.10                                                       | 0.20                   | 0.10    |

Внимание привлекает одна интересная деталь. Многопоточная реализация с локальными переменными работает примерно вдвое быстрее однопоточного суммирования. Между тем можно было бы ожидать четырёхкратного увеличения производительности, ведь четыре потока выполняются на четырёх ядрах, не требуя никакой синхронизации. Почему же производительность оказывается вдвое ниже ожидаемой?

## Суммирование вектора: подведение итогов

### Однопоточные алгоритмы

Цикл по диапазону и алгоритм [[accumulate#std accumulate|std::accumulate]] из стандартной библиотеки обладают сопоставимой производительностью. При включенной оптимизации компилятор может использовать для суммирования быстродействующие инструкции расширенных наборов ОКМД1 (англ. SIMD) – SSE или AVX. В этом случае счётчик цикла увеличивается всякий раз на 4 (при использовании расширения SSE) или на 8 (в случае расширения AVX).

### Многопоточные алгоритмы с общей переменной

Опыт использования общей переменной в качестве накопителя суммы наглядно демонстрирует, что синхронизация обходится дорого, и поэтому её следует избегать, где только можно. Если использовать атомарную переменную и даже ослабить требование последовательной согласованности операций над ней, четыре параллельных потока выполняются примерно в сотню раз дольше, чем один поток. Когда речь идёт о быстродействии, первой целью разработчика должно стать сведение к минимуму дорогостоящих синхронизаций.

### Многопоточные алгоритмы с локальными переменными

Накопление каждым из четырёх потоков своей частичной суммы в локальной переменной оказывается лишь вдвое быстрее цикла по диапазону в единственном потоке или алгоритма [[accumulate#std accumulate|std::accumulate]]. Этот результат кажется удивительным, ведь от параллельной работы четырёх потоков было бы естественно ожидать четырёхкратного выигрыша производительности. Ещё удивительнее оказался график использования ядер, показывающий, что каждое ядро загружено далеко не полностью.

![[ParallelProg_140.png]]

Причина этого проста. Ядра не могут достаточно быстро извлекать данные из оперативной памяти. Выполнение этого алгоритма ограничено возможностями памяти (англ. memory bound). Иначе говоря, это память замедляет работу процессорных ядер. Следующий рисунок поясняет, где находится узкое место.

![[ParallelProg_141.png]]

Наглядная модель производительности систем, известная как модель кровли, позволяет оценивать производительность приложений, работающих на многоядерных или многопроцессорных архитектурах. В этой модели учитываются пиковая производительность, пиковая пропускная способность и интенсивность использования системы.

