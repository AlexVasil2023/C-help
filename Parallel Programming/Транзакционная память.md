
[[Транзакционная память|Транзакционная память]] 7.3
1. [[#Требования ACI(D)|Требования ACI(D)]] 7.3.1
2. [[#Синхронизированные и атомарные блоки|Синхронизированные и атомарные блоки]] 7.3.2
	1. [[#Синхронизированные блоки|Синхронизированные блоки]] 7.3.2.1
	2. [[#Атомарные блоки|Атомарные блоки]] 7.3.2.2
3. [[#Транзакционно-безопасный и транзакционно-небезопасный код|Транзакционно-безопасный и транзакционно-небезопасный код]] 7.3.3
4. 
5. 

# Транзакционная память

Понятие транзакционной памяти основано на понятии транзакции, развитом в теории баз данных. Транзакционная память упрощает работу с потоками в двух аспектах. Во-первых, полностью устраняется опасность гонок данных и мёртвых блокировок; во-вторых, транзакции легко компоновать в более крупные транзакции.

Транзакция – это операция, обладающая следующими четырьмя свойствами: атомарность, согласованность, изолированность, устойчивость (англ. atomicity, consistency, isolation, durability – ACID). Эти свойства должны выполняться и для транзакционной памяти в языке C++, за исключением требования устойчивости, которое означает гарантию сохранения результата операции в долговременном хранилище, и потому не имеет смысла для оперативной памяти. Из четырёх свойств остаются три, которые нужно рассмотреть подробнее.

## Требования ACI(D)

Что означают атомарность, согласованность и изолированность в применении к блоку операторов?

**Атомарный блок операторов:**
```c++
atomic {
	statement1;
	statement2;
	statement3;
}
```

**Атомарность**: в любой момент времени потокам программы либо виден результат выполнения всех операторов этого блока, либо не виден результат ни одного из них.

**Согласованность**: система всегда находится в согласованном состоянии. Все выполняющиеся в ней транзакции вполне упорядочены между собой в линейную последовательность.

**Изолированность**: любая транзакция выполняется в полной изоляции от всех остальных транзакций.

Как добиться выполнения этих трёх свойств? Транзакция запоминает начальное состояние данных и затем выполняется без всякой синхронизации над временной копией этих данных. Если во время выполнения её операторов обнаруживается конфликт (т. е. если какая-то другая транзакция успела за это время изменить состояние данных), выполнение текущей транзакции прерывается, и её выполнение начинается заново. Если же к моменту завершения транзакции состояние данных остаётся неизменным, транзакция подтверждается – данные в общем доступе обновляются из локальной копии. Для обнаружения конфликтов обычно применяются ссылки на помеченные состояния (англ. tagged state reference).

Транзакцию можно представить себе как действие, которое подготавливается без гарантии осуществления и осуществляется при условии, что не изменились начальные условия, исходя из которых происходила подготовка. В противоположность мьютексам здесь имеет место оптимистический подход. Применяя транзакцию, надеются, что она завершится без конфликта, но готовы к повторной попытке в случае неудачи. В основу мьютексов положен пессимистический подход: перед входом в критическую секцию поток убеждается, что ни один другой поток не находится в ней, а войдя в неё, блокирует такую возможность для остальных потоков.

В будущих стандартах языка C++ могут появиться два средства поддержки транзакционной памяти: синхронизированные блоки и атомарные блоки.

## Синхронизированные и атомарные блоки

До сих пор мы рассматривали лишь транзакции. Теперь речь пойдёт о синхронизированных и атомарных блоках. Строго говоря, синхронизированные блоки транзакциями не являются, так как внутри них может выполняться код, небезопасный с точки зрения транзакции. Примером транзакционно-небезопасного кода может служить вывод на консоль – действие, которое нельзя отменить. По этой причине синхронизированные блоки называют ещё ослабленными блоками.

### Синхронизированные блоки

Синхронизированные блоки ведут себя так, будто находятся под единой глобальной блокировкой. Это значит, что все синхронизированные блоки в процессе выполнения программы образуют линейную последовательность. В частности, все изменения общих данных, сделанные некоторым синхронизированным блоком, видны в следующем синхронизированном блоке. Между синхронизированными блоками имеет место следующее отношение: подтверждение транзакции, выполненной одним блоком, синхронизировано с началом другой транзакции.

Синхронизированные блоки не могут зайти в тупик именно в силу глобальной линейной упорядоченности. Если классический мьютекс защищает критическую секцию программы, глобальная упорядоченность синхронизированного блока защищает программу в целом. По этой причине следующая программа обладает вполне определённым поведением.

**Синхронизированный блок:**
```c++
// synchronized.cpp

#include <iostream>
#include <vector>
#include <thread>

int i= 0;

void increment(){
	synchronized{
		std::cout << ++i << “ ,”;
	}
}

int main(){
	std::cout << std::endl;

	std::vector<std::thread> vecSyn(10);
	
	for(auto& thr: vecSyn)
		thr = std::thread([]{ for(int n = 0; n < 10; ++n) increment(); });

	for(auto& thr: vecSyn) 
		thr.join();

	std::cout << “\n\n”;
}
```

Хотя переменная `i` объявлена в глобальной области видимости и функция `increment`, модифицирующая её, вызывается по десять раз из десяти параллельных потоков, программа обладает вполне определённым поведением. Операции над переменной `i`, как и операции вывода на консоль, выполняются в глобальном линейном порядке. Это и есть основное свойство синхронизированных блоков.

Выполнение программы даёт ожидаемый результат. Значения переменной `i` выводятся в возрастающей последовательности через запятую.

![[ParallelProg_194.png]]

Как теперь обстоят дела с гонками данных? Возможны ли они в программе, где есть синхронизированные блоки? Небольшая модификация предыдущей программы позволяет убедиться, что возможны – если в синхронизированные блоки поместить не все опасные операции.

**Гонка данных в программе с синхронизированными блоками:**
```c++
// nonsynchronized.cpp

#include <chrono>
#include <iostream>
#include <vector>
#include <thread>

using namespace std::chrono_literals;
using namespace std;

int i= 0;

void increment(){
	synchronized{
		cout << ++i << “ ,”;
		this_thread::sleep_for(1ns);
	}
}

int main(){
	cout << endl;

	vector<thread> vecSyn(10);
	vector<thread> vecUnsyn(10);

	for(auto& thr: vecSyn)
		thr = thread([] {
					for(int n = 0; n < 10; ++n) 
						increment();
		});

	for(auto& thr: vecUnsyn)
		thr = thread([] {
					for(int n = 0; n < 10; ++n) 
						cout << ++i << “ ,”;
		});

	for(auto& thr: vecSyn) 
		thr.join();

	for(auto& thr: vecUnsyn) 
		thr.join();

	cout << “\n\n”;
}
```

Синхронизированный блок теперь притормаживает выполнение на одну наносекунду. В то же время делается попытка доступа к потоку вывода [[cout#std cout|std::cout]] из потоков без синхронизированного блока. Таким образом, к глобальной переменной и потоку вывода обращаются 20 потоков, причём половина из них – без синхронизации. Результат работы программы показан на рисунке, проблема отчётливо видна.

![[ParallelProg_195.png]]

Некоторые места в выводимом программой тексте обведены красным. Это места, где по меньшей мере два потока одновременно осуществляют вывод в поток [[cout#std cout|std::cout]]. Стандарт C++ 11 гарантирует, что каждая отдельная операция вывода в поток происходит атомарным образом, поэтому здесь большой проблемы нет. Хуже то, что переменную `i` могут изменять одновременно несколько потоков. Это гонка данных. Следовательно, поведение программы не определено. Если присмотреться к напечатанному программой тексту внимательнее, гонку данных легко увидеть в действии. После того как 20 потоков увеличивают переменную на единицу каждый по 10 раз, окончательное значение переменной должно было быть равно 200, но вместо этого оказывается равным 199. Это значит, что одно из промежуточных значений счётчика было перезаписано в ходе гонки. Таким образом, для надёжной защиты от гонки данных мало использовать синхронизированные блоки где-то в программе – нужно делать это везде, где происходит обращение к глобальному состоянию.

Линейный порядок выполнения характерен не только для синхронизированных, но и для атомарных блоков.

### Атомарные блоки

Транзакции можно выполнять не только в синхронизированных, но и в атомарных блоках. Атомарные блоки могут выступать в трёх формах: `atomic_noexcept`, `atomic_commit` и `atomic_cancel`. Наименования вполне точно отражают стратегию обработки исключений в этих блоках:
> **atomic_noexcept** – если внутри блока возникает необработанное исключение, вызывается функция `std::abort`, и программа аварийно завершается;

> **atomic_cancel** – в случае исключения транзакция подтверждается;
>
> **atomic_commit** – в случае необработанного исключения в общем случае программа аварийно завершается. Однако если это исключение транзакционно-безопасно, транзакция прерывается, возвращается к исходному состоянию, а исключение пробрасывается наружу.

К транзакционно-безопасным относятся исключения типов `std::bad_alloc`, `std::bad_array_length`, `std::bad_array_new_length`, `std::bad_cast`, `std::bad_typeid`, `std::bad_exception`, `std::exception` и всех типов, производных от них.

## Транзакционно-безопасный и транзакционно-небезопасный код












