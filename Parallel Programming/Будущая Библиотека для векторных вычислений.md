
[[#Библиотека для векторных вычислений|Библиотека для векторных вычислений]] 7.5
1. [[#Векторные типы данных|Векторные типы данных]] 7.5.1
2. [[#Интерфейс векторизированных данных|Интерфейс векторизированных данных]] 7.5.2
	1. [[#Вспомогательные типы-признаки|Вспомогательные типы-признаки]] 7.5.2.1
		1. [[#Типы-признаки для управления способом хранения данных|Типы-признаки для управления способом хранения данных]] 7.5.2.1.1
		2. [[#Типы-признаки для управления выравниванием данных|Типы-признаки для управления выравниванием данных]] 7.5.2.1.2
	2. [[#Выражения над значениями векторного типа|Выражения над значениями векторного типа]] 7.5.2.2
	3. [[#Приведение типов|Приведение типов]] 7.5.2.3
	4. [[#Алгоритмы над векторизированными значениями|Алгоритмы над векторизированными значениями]] 7.5.2.4
	5. [[#Свёртка по операции|Свёртка по операции]] 7.5.2.5
	6. [[#Свёртка с маской|Свёртка с маской]] 7.5.2.6

# Библиотека для векторных вычислений

К включению в стандарт предлагается также ряд средств, поддерживающих параллельные вычисления на уровне данных, т. е. векторизированные вычисления. Принцип `SID` (англ. Single Instruction – Multiple Data) означает, что одна и та же операция может выполняться над многими элементами данных параллельно. Любая современная процессорная архитектура содержит расширения для векторизации вычислений, но нынешний стандарт языка C++ не содержит средств для управления ими. В следующей таблице дан обзор различных средств для векторных вычислений.

**Векторные расширения:**

| **Архитектура** | **Расширение**       | **Размер регистра, бит** |
| --------------- | -------------------- | ------------------------ |
| `ARM 32/64`     | NEON                 | 128                      |
| Power / PowerPC | AltiVec              | 128                      |
|                 | VSX                  | 128                      |
| x86 / AMD 64    | MMX / 3DNow          | 64                       |
|                 | SSE                  | 128                      |
|                 | AVX / AVX2 / AVX-512 | 128 / 256 / 512          |

Так, например, расширение SSE позволяет за одну операцию складывать четыре 32-битных целых числа. Это ровно вчетверо быстрее, чем выполнять четыре 32-битных сложения последовательно, поскольку на современных процессорах векторная операция требует такого же времени, как и скалярная.

> **Автоматическая векторизация**
>
> Автоматическая векторизация означает, что задача оптимизации кода под особенности конкретной архитектуры возлагается на сам компьютер. Часто на пути генерации наиболее эффективного кода встают различные препятствия. Как отмечается в руководстве разработчику на языке C++, выпущенному компанией Intel, главные причины затруднений таковы:
> > снижение эффективности кеш-памяти из-за произвольного порядка обращений к памяти;
> > зависимости по данным между итерациями цикла;
> > сложность условий цикла, когда число повторений невозможно определить до входа в цикл.
> 
>Можно назвать и иные факторы, затрудняющие автоматическую векторизацию:
> > зависимость по управлению между вызовами функций из тела цикла;
> > вложенность циклов (наличие цикла в теле другого цикла);
> > использование потоков с мьютексами и атомарными переменными.

Расширение стандарта C++ для поддержки векторных вычислений состоит из двух специальных типов и ряда операций над ними.

## Векторные типы данных

Предлагаемые в стандарт типы данных для поддержки векторизированных вычислений – это типы [[simd#std simd|std::simd]] и [[simd#std simd_mask|std::simd_mask]].

```c++
template <class T, class Abi = simd_abi::compatible<T>>
class simd;

template <class T, class Abi = simd_abi::compatible<T>>
class simd_mask;
```

Тип-параметр `T` – это тип данных, над которыми предполагается векторное вычисление. Второй тип-параметр `Abi` используется для определения количества элементов, группируемых между собой для векторной операции, и способа их хранения.

## Интерфейс векторизированных данных

Библиотека для векторных вычислений поддерживает вспомогательные типы для выравнивания данных, арифметические операции, разнообразные свойства данных.

### Вспомогательные типы-признаки

Эти типы позволяют программисту управлять хранением и выравниванием данных.

#### Типы-признаки для управления способом хранения данных

Следующие типы определяют способ упаковки элементов данных в вектор, удобный для выполнения параллельных операций.

**Типы-признаки способа хранения элементов:**

| **Имя**          | **Описание**                                        |
| ---------------- | --------------------------------------------------- |
| `scalar`         | Хранение единственного элемента данных              |
| `fixed_size`     | Хранение заданного числа элементов                  |
| `compatible`     | Подходящий доступный механизм хранения              |
| `native`         | Наиболее эффективный механизм хранения              |
| `max_fixed_size` | Наибольшее аппаратно поддерживаемое число элементов |

#### Типы-признаки для управления выравниванием данных

Эти типы определяют способ выравнивания элементов типа `T` при копировании данных в буфер или из буфера типа `U`.

**Признаки выравнивания**

| **Имя**           | **Описание**                                  |
| ----------------- | --------------------------------------------- |
| `element_aligned` | Данные в буфере выровнены на границу элемента |
| `vector_aligned`  | Данные выровнены по границе вектора           |
| `overaligned`     | Данные выровнены по заданному числу битов     |

### Выражения над значениями векторного типа

Следующие шаблоны классов позволяют строить выражения над выбранными элементами.

**Средства построения выражений:**

| **Имя**                  | **Описание**                                                  |
| ------------------------ | ------------------------------------------------------------- |
| `const_where_expression` | Применение немодифицирующей операции                          |
| `where_expression`       | Применение модифицирующей операции                            |
| `where`                  | Заменяется на `const_where_expression` или `where_expression` |

### Приведение типов

Операции приведения типов могут применяться к векторизированным данным поэлементно, разбивать векторизированное значение на ряд значений элементарного типа или, напротив, соединять несколько элементарных значений в одно векторизированное.

**Операции приведения типов:**

| **Имя**                                             | **Описание**                                                           |
| --------------------------------------------------- | ---------------------------------------------------------------------- |
| `simd_cast`,<br>`static_simd_cast`                  | Поэлементное статическое преобразование                                |
| `to_fixed_size`,<br>`to_compatible`,<br>`to_native` | Поэлементное преобразование двоичных представлений                     |
| `split`                                             | Разбиение одного векторизированного значения на множество элементарных |
| `concat`                                            | Сборка векторизированного значения из элементарных                     |

### Алгоритмы над векторизированными значениями

Следующие векторизированные алгоритмы принимают в качестве аргументов и возвращают векторизированные значения.

**Векторизированные алгоритмы:**

| **Имя**  | **Описание**                             |
| -------- | ---------------------------------------- |
| `min`    | Найти наименьший в каждой паре элементов |
| `max`    | Найти наибольший в каждой паре элементов |
| `minmax` | Найти наименьший и наибольший            |
| `clamp`  | Привести значение к интервалу (см. ниже) |

Под приведением к интервалу понимается следующая операция. Если даны значения `lo[i]` и `hi[i]` (границы интервала) и значение `v[i]`, то результат `sim[i]` определяется следующим образом:
> если  `v[i] < lo[i]`, то `sim[i] = lo[i]`;
>
> иначе если `hi[i] < v[i]`, то `sim[i] = hi[i]`;
>
> иначе `sim[i] = v[i]`.

Векторизированный алгоритм проделывает эту операцию одновременно с каждым элементарным значением, упакованным в векторное значение.

### Свёртка по операции

Эти алгоритмы производят свёртку всех элементарных значений, упакованных в одно векторное, по некоторой операции.

**Алгоритмы свёртки векторизированных значений:**

| **Имя**  | **Описание**                                  |
| -------- | --------------------------------------------- |
| `reduce` | Общий случай свёртки по произвольной операции |
| `hmin`   | Нахождение минимального значения              |
| `hmax`   | Нахождение максимального значения             |

### Свёртка с маской

Следующие алгоритмы применяют операцию исключительно к тем элементарным значениям, упакованным в векторизированное значение, для которых соответствующий элемент битовой маски установлен в значение `true`.

**Свёртка с маской:**

| **Имя**                                     | **Описание**                                                                                     |
| ------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| `all_of`, `any_of`,<br>`none_of`, `some_of` | Проверка, выполняется ли заданный предикат для всех (некоторых, ни одного, нескольких) элементов |
| `popcount`                                  | Подсчёт числа элементов, для которых предикат выполняется                                        |
| `find_first_set`,<br>`find_last_set`        | Нахождение индекса первого (последнего) элемента, для которого выполняется предикат              |

### Классы свойств

Эти классы-шаблоны и соответствующие им переменные-шаблоны позволяют во время компиляции получить параметры типов, используемых для векторных расширений.

| **Имя**             | **Описание**                                                                     |
| ------------------- | -------------------------------------------------------------------------------- |
| `is_abi_tag`        | Проверка, является ли тип признаком способа хранения                             |
| `is_simd`           | Является ли тип типом векторизированных данных                                   |
| `is_simd_mask`      | Является ли тип типом маски элементов                                            |
| `is_simd_flag_type` | Является ли тип типом флага                                                      |
| `simd_size`         | Число элементов заданного типа, помещающихся в заданном векторизированном типе   |
| `memory_alignment`  | Параметры выравнивания элементов данных                                          |
| `abi_for_size`      | Подходящий тип данных для упаковки заданного количества элементов заданного типа |
