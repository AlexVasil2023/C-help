[[#std async|Функция std::async]]
1. [[#Политика запуска|Политика запуска]]
2. [[#Запустить и забыть]]
3. [[#Параллельное вычисление скалярного произведения|Параллельное вычисление скалярного произведения]]

# std::async

Функция `std::async` ведёт себя как асинхронный вызов функции, заданной пользователем. В качестве аргументов функция `std::async` принимает вызываемый объект и аргументы для передачи ему. Функция `std::async` представляет собой вариадический шаблон и потому может принимать произвольное число аргументов. Результатом вызова функции `std::async` становится [[future|объект-фьючерс]]. Он играет роль разъёма, через который впоследствии можно получить (вызвав функцию-член `get`) результат асинхронного выполнения пользовательской функции.

> **Всегда следует предпочитать асинхронные вызовы**
> 
> Реализация стандартной библиотеки C++ сама решает, выполнять асинхронный вызов в отдельном потоке или нет. Это решение может зависеть от числа доступных ядер процессора, загруженности системы, размера пакета работы. Вызывая функцию `std::async`, программист лишь передаёт ей задание, которое должно быть выполнено. Вся работа по возможному созданию потока и управлению временем его жизни перекладывается на внутренние механизмы реализации.

Помимо того, при вызове функции `std::async` можно необязательным параметром передать политику запуска.

## Политика запуска

Посредством политики можно в явном виде указать, каким образом реализации следует выполнить асинхронный вызов: в том же потоке, который создал вызов (`std::launch::deferred`), или в другом потоке (`std::launch::async`).

> **Строгие и ленивые вычисления**
> 
> Строгое и ленивое вычисления – это две противоположных способа вычислять значение выражения. При строгой стратегии выражение вычисляется немедленно, тогда как при ленивой стратегии вычисление откладывается до тех пор, пока значение не станет необходимо. Строгое вычисление также называют жадным, а ленивое – отложенным, или вычислением по требованию. Ленивая стратегия вычислений часто помогает сберечь время и ресурсы процессора, предотвращает вычисление данных, которые могут не понадобиться в будущем.

Особенность выражения вида
```c++
auto fut = std::async(std::launch::deferred, ... )
```

состоит в том, что обещание не запускается немедленно. Вместо этого оно будет выполнено ленивым образом только в момент вызова `fut.get()`. Иными словами, обещание запускается только тогда, когда [[future|фьючерс]] в явном виде запрашивает его результат.

**Строгое и ленивое вычисления [[future|фьючерса]]:**
```c++
// asyncLazy.cpp

#include <chrono>
#include <future>
#include <iostream>

int main(){
	std::cout << std::endl;

	auto begin= std::chrono::system_clock::now();

	auto asyncLazy=std::async(std::launch::deferred,
						[]{ return std::chrono::system_clock::now(); });

	auto asyncEager=std::async(std::launch::async,
						[]{ return std::chrono::system_clock::now(); });

	std::this_thread::sleep_for(std::chrono::seconds(1));

	auto lazyStart= asyncLazy.get() – begin;
	auto eagerStart= asyncEager.get() – begin;

	auto lazyDuration= std::chrono::duration<double>(lazyStart).count();
	auto eagerDuration= std::chrono::duration<double>(eagerStart).count();

	std::cout << “asyncLazy evaluated after : “ << lazyDuration
											<< “ seconds.” << std::endl;
	std::cout << “asyncEager evaluated after: “ << eagerDuration
											<< “ seconds.” << std::endl;

	std::cout << std::endl;
}
```

Оба вызова функции `std::async` возвращают текущий момент времени. Однако первый вызов ленивый, тогда как второй – строгий. Односекундная задержка в строке `std::this_thread::sleep_for(std::chrono::seconds(1));` позволяет в этом убедиться. Вызов функции `get` в строке `auto lazyStart= asyncLazy.get() – begin;` запускает выполнение обещания, и полученный момент времени отделён одной секундой от начала выполнения программы. Для второго обещания дело обстоит иначе, поскольку его выполнение начинается немедленно в отдельном потоке. Пример выполнения программы показан на рисунке.

![[ParallelProg_82.png]]

В общем случае нет необходимости хранить [[future|фьючерс]] в переменной.

## Запустить и забыть

Особый случай составляют [[future|фьючерсы]], о которых забывают сразу после создания. Они не сохраняются в каких-либо переменных и должны запускаться немедленно в момент создания. Существенно, что обещания таких [[future|фьючерсов]] должны выполняться в отдельном потоке, чтобы [[future|фьючерс]] мог начать работу немедленно. Для этого нужно использовать политику запуска `std::launch::async`.

Сравним поведение обычного [[future|фьючерса]], присвоенного в переменную, и короткоживущего, который создаётся и в переменную не присваивается.

```c++
auto fut= std::async([]{ return 2011; });
std::cout << fut.get() << ‘\n’;

std::async(std::launch::async, 
					   []{ std::cout << “fire and forget” << ‘\n’; });
```

Короткоживущие [[future|фьючерсы]] выглядят удобными, но имеют существенный недостаток. Деструктор [[future|фьючерса]], созданного вызовом функции `std::async`, ожидает, пока соответствующее обещание не будет выполнено. В данном случае ожидание мало отличается от блокирования. Таким образом, выполнение программы блокируется на деструкторе [[future|фьючерса]]. Это особенно отчётливо проявляется, когда [[future|фьючерс]], созданный функцией `std::async`, не сохраняется в переменной. То, что, казалось бы, должно работать параллельно, выполняется на самом деле последовательно.

**Короткоживущие фьючерсы:**
```c++
// blocking.cpp

#include <chrono>
#include <future>
#include <iostream>
#include <thread>

int main(){
	std::cout << std::endl;

	std::async(std::launch::async, []{
				std::this_thread::sleep_for(std::chrono::seconds(2));
				std::cout << “first thread” << std::endl;
	});

	std::async(std::launch::async, []{
				std::this_thread::sleep_for(std::chrono::seconds(1));
				std::cout << “second thread” << std::endl;
	});

	std::cout << “main thread” << std::endl;
	std::cout << std::endl;
}
```

В этой программе два асинхронных задания запускаются в отдельных потоках. Однако получившиеся в результате запуска объекты-фьючерсы не присвоены переменным. Как следствие деструкторы обоих фьючерсов блокируют выполнение главного потока, пока связанные с ними обещания не будут выполнены. В результате этого обещания выполняются в том же порядке, в котором они записаны в исходном коде. Последовательность выполнения остаётся неизменной, сколько бы ни запускать программу. Вот что выводит программа в результате своего выполнения.

![[ParallelProg_83.png]]

## Параллельное вычисление скалярного произведения

Вычисление скалярного произведения векторов можно распределить между четырьмя асинхронными вызовами.

**Скалярное умножение векторов с помощью асинхронных вызовов:**
```c++
// dotProductAsync.cpp

#include <iostream>
#include <future>
#include <random>
#include <vector>
#include <numeric>

using namespace std;

static const int NUM= 100000000;

long long getDotProduct(vector<int>& v, vector<int>& w){
	auto vSize = v.size();

	auto future1 = async([&]{ return inner_product(
						&v[0], &v[vSize/4], &w[0], 0LL);
	});

	auto future2 = async([&]{ return inner_product(
						&v[vSize/4], &v[vSize/2], &w[vSize/4], 0LL);
	});

	auto future3 = async([&]{ return inner_product(
						&v[vSize/2], &v[vSize* 3/4], &w[vSize/2], 0LL);
	});

	auto future4 = async([&]{ return inner_product(
						&v[vSize * 3/4], &v[vSize], &w[vSize * 3/4], 0LL);
	});

	return future1.get() + future2.get() + future3.get() + future4.get();
}

int main(){
	cout << endl;

	random_device seed;

	// generator
	mt19937 engine(seed());

	// distribution
	uniform_int_distribution<int> dist(0, 100);

	// fill the vectors
	vector<int> v, w;
	v.reserve(NUM);
	w.reserve(NUM);

	for (int i=0; i< NUM; ++i){
		v.push_back(dist(engine));
		w.push_back(dist(engine));
	}

	cout << “getDotProduct(v, w): “ << getDotProduct(v, w) << endl;
	
	cout << endl;
}
```

В этой программе используются средства из библиотеки `random` для работы со случайными числами, которая присутствует в стандарте начиная с версии C++11. Сначала создаются и заполняются случайными значениями два вектора, `v` и `w`. Каждый вектор содержит сто миллионов элементов. Функция `dist`, параметризованная генератором `engine`, создаёт в строках `v.push_back(dist(engine));` и `w.push_back(dist(engine));` случайные числа, равномерно распределённые в диапазоне от 0 до 100. Вычисление скалярного произведения происходит в функции `dotProduct` (строки `long long getDotProduct(vector<int>& v, vector<int>& w){ ... }`). Под управлением стандартный алгоритм `std::inner_product` запускается асинхронно четыре раза, отдельно для каждой четверти длины вектора. В операторе `return` результаты этих четырёх асинхронных запусков суммируются. Ниже показан результат работы программы.

![[ParallelProg_84.png]]



