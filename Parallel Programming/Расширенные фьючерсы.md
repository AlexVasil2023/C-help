
[[#Расширенные фьючерсы|Расширенные фьючерсы]] 7.2
1. [[#Техническая спецификация|Техническая спецификация]] 7.2.1
	1. [[#Обновлённое понятие фьючерса|Обновлённое понятие фьючерса]] 7.2.1.1
		1. [[#Валидность и готовность|Валидность и готовность]] 7.2.1.1.1
		2. [[#Продолжение фьючерса|Продолжение фьючерса]] 7.2.1.1.2
	2. [[#Средства асинхронного выполнения|Средства асинхронного выполнения]] 7.2.1.2 




# Расширенные фьючерсы

## Техническая спецификация

### Обновлённое понятие фьючерса

Название «расширенный фьючерс» объясняется просто. Во-первых, интерфейс класса [[future|std::future]] предлагается расширить; во-вторых, предлагается добавить в стандарт ряд новых функций для создания специфических разновидностей фьючерсов, которые можно было бы состыковывать между собой. Начнём с первого аспекта.

В технической спецификации предлагается расширить тип фьючерса тремя новыми функциями-членами:

* конструктор, который принимает в качестве аргумента фьючерс, завёрнутый во фьючерс (`future<future<T>>`), и извлекает его из обёртки, снимая один уровень вложенности;
* предикат `is_ready`, позволяющий узнать, готово ли общее состояние;
* функция `then`, которая присоединяет к фьючерсу продолжение.

Начнём же рассмотрение с того обстоятельства, что в технической спецификации предлагается различать валидность (`valid`) и готовность (`ready`) состояния фьючерса.

#### Валидность и готовность

Напомним, что под состоянием имеется в виду объект данных, в котором фьючерс формирует результат своей работы.

* Валидность означает: состояние, которым фьючерс владеет совместно с объектом-обещанием, имеется в наличии. Это условие не всегда выполняется, так как фьючерс может быть создан посредством конструктора по умолчанию, без объекта-обещания.
* Готовность означает, что фьючерс уже поместил результат своей работы в объект-состояние.

Таким образом, валидность есть непременное условие готовности: не может быть готов фьючерс, если он не валиден.

Вспомним удобную умозрительную модель обещания и фьючерса как двух концов канала, по которому передаются данные.

![[ParallelProg_193.png]]

Теперь различие между валидностью и готовностью фьючерса выглядит естественным. Фьючерс валиден, если существует канал данных, связывающий его с обещанием. Фьючерс готов, если обещание уже выполнено, то есть если данные помещены на вход канала.

Разберёмся теперь с функцией-членом `then` и с продолжениями фьючерса.

#### Продолжение фьючерса

Функция-член `then` позволяет присоединить фьючерс к концу другого фьючерса. Кроме того, часто встречается ситуация, когда фьючерс упакован в другой фьючерс, то есть результатом работы фьючерса становится новый фьючерс. В этом случае особый конструктор помогает преобразовать вложенный фьючерс в одноуровневый, производящий только окончательный результат.

> **Предложение N3721**
> 
> Перед тем как показать пример кода, нужно сказать несколько слов о предложении N37211. Большая часть настоящего раздела основана на этом документе, озаглавленном «Улучшения типа `std::future<T>` и связанных с ним программных интерфейсов», в том числе и примеры кода. Удивительно, но авторы документа часто опускали в конце программы вызов функции-члена `get`, позволяющей получить из фьючерса результат его работы. В примерах ниже такой вызов добавлен, полученное из него значение сохранено в переменную. Также исправлены некоторые опечатки.

**Продолжение фьючерса**
```c++
#include <future>

using namespace std;

int main() {
	future<int> f1 = async([]() { return 123; });
	
	future<string> f2 = f1.then([](future<int> f) {
		return to_string(f.get()); // этот вызов get() не блокирует
	});

	auto myResult= f2.get();
}
```

Между двумя вызовами функции-члена `get`, в строках `return to_string(f.get());` и `auto myResult= f2.get();`, имеется тонкое различие. Как отмечено в комментарии к коду, первый вызов никогда не блокирует выполнение, тогда как вызов в строке `auto myResult= f2.get();` должен дождаться, пока не будет готов результат цепочки фьючерсов. Это справедливо как для сколь угодно длинных цепочек продолжений вида `f1.then(...).then(...).then(...).then(...)`, так и для композиции расширенных фьючерсов. Блокирующим оказывается только вызов функции `get` для получения окончательного результата.

### Средства асинхронного выполнения













