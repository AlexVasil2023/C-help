
[[#Расширенные фьючерсы|Расширенные фьючерсы]] 7.2
1. [[#Техническая спецификация|Техническая спецификация]] 7.2.1
	1. [[#Обновлённое понятие фьючерса|Обновлённое понятие фьючерса]] 7.2.1.1
		1. [[#Валидность и готовность|Валидность и готовность]] 7.2.1.1.1
		2. [[#Продолжение фьючерса|Продолжение фьючерса]] 7.2.1.1.2
	2. [[#Средства асинхронного выполнения|Средства асинхронного выполнения]] 7.2.1.2 
	3. [[#Создание новых фьючерсов|Создание новых фьючерсов]] 7.2.1.3
		1. [[#Функции для создания фьючерсов с готовым результатом|Функции для создания фьючерсов с готовым результатом]] 7.2.1.3.1
		2. [[#Композиции фьючерсов|Композиции фьючерсов]] 7.2.1.3.2
		3. [[#Пример применения функции std when_all|Пример применения функции std::when_all]] 7.2.1.3.3
		4. [[#Пример применения функции std when_any|Пример применения функции std::when_any]] 7.2.1.3.4
2. [[#Унифицированные фьючерсы|Унифицированные фьючерсы]] 7.2.2
	1. [[#Недостатки фьючерсов|Недостатки фьючерсов]] 7.2.2.1
		1. [[#Привязка фьючерсов и обещаний к потокам|Привязка фьючерсов и обещаний к потокам]] 7.2.2.1.1
		2. [[#Способ выполнения продолжений|Способ выполнения продолжений]] 7.2.2.1.2
		3. [[#Передача фьючерса в продолжение слишком громоздка|Передача фьючерса в продолжение слишком громоздка]] 7.2.2.1.3
		4. [[#Композиции фьючерсов возвращают слишком громоздкие типы|Композиции фьючерсов возвращают слишком громоздкие типы]] 7.2.2.1.4
		5. [[#Условную блокировку в деструкторе фьючерса нужно устранить|Условную блокировку в деструкторе фьючерса нужно устранить]] 7.2.2.1.5
		6. [[#Нужна совместимость непосредственно данных и будущих значений|Нужна совместимость непосредственно данных и будущих значений]] 7.2.2.1.6
	2. [[#Пять новых концептов|Пять новых концептов]] 7.2.2.2
	3. [[#Направления дальнейшей работы|Направления дальнейшей работы]] 7.2.2.3

# Расширенные фьючерсы

## Техническая спецификация

### Обновлённое понятие фьючерса

Название «расширенный фьючерс» объясняется просто. Во-первых, интерфейс класса [[future|std::future]] предлагается расширить; во-вторых, предлагается добавить в стандарт ряд новых функций для создания специфических разновидностей фьючерсов, которые можно было бы состыковывать между собой. Начнём с первого аспекта.

В технической спецификации предлагается расширить тип фьючерса тремя новыми функциями-членами:

* конструктор, который принимает в качестве аргумента фьючерс, завёрнутый во фьючерс (`future<future<T>>`), и извлекает его из обёртки, снимая один уровень вложенности;
* предикат `is_ready`, позволяющий узнать, готово ли общее состояние;
* функция `then`, которая присоединяет к фьючерсу продолжение.

Начнём же рассмотрение с того обстоятельства, что в технической спецификации предлагается различать валидность (`valid`) и готовность (`ready`) состояния фьючерса.

#### Валидность и готовность

Напомним, что под состоянием имеется в виду объект данных, в котором фьючерс формирует результат своей работы.

* Валидность означает: состояние, которым фьючерс владеет совместно с объектом-обещанием, имеется в наличии. Это условие не всегда выполняется, так как фьючерс может быть создан посредством конструктора по умолчанию, без объекта-обещания.
* Готовность означает, что фьючерс уже поместил результат своей работы в объект-состояние.

Таким образом, валидность есть непременное условие готовности: не может быть готов фьючерс, если он не валиден.

Вспомним удобную умозрительную модель обещания и фьючерса как двух концов канала, по которому передаются данные.

![[ParallelProg_193.png]]

Теперь различие между валидностью и готовностью фьючерса выглядит естественным. Фьючерс валиден, если существует канал данных, связывающий его с обещанием. Фьючерс готов, если обещание уже выполнено, то есть если данные помещены на вход канала.

Разберёмся теперь с функцией-членом `then` и с продолжениями фьючерса.

#### Продолжение фьючерса

Функция-член `then` позволяет присоединить фьючерс к концу другого фьючерса. Кроме того, часто встречается ситуация, когда фьючерс упакован в другой фьючерс, то есть результатом работы фьючерса становится новый фьючерс. В этом случае особый конструктор помогает преобразовать вложенный фьючерс в одноуровневый, производящий только окончательный результат.

> **Предложение N3721**
> 
> Перед тем как показать пример кода, нужно сказать несколько слов о предложении N37211. Большая часть настоящего раздела основана на этом документе, озаглавленном «Улучшения типа `std::future<T>` и связанных с ним программных интерфейсов», в том числе и примеры кода. Удивительно, но авторы документа часто опускали в конце программы вызов функции-члена `get`, позволяющей получить из фьючерса результат его работы. В примерах ниже такой вызов добавлен, полученное из него значение сохранено в переменную. Также исправлены некоторые опечатки.

**Продолжение фьючерса**
```c++
#include <future>

using namespace std;

int main() {
	future<int> f1 = async([]() { return 123; });
	
	future<string> f2 = f1.then([](future<int> f) {
		return to_string(f.get()); // этот вызов get() не блокирует
	});

	auto myResult= f2.get();
}
```

Между двумя вызовами функции-члена `get`, в строках `return to_string(f.get());` и `auto myResult= f2.get();`, имеется тонкое различие. Как отмечено в комментарии к коду, первый вызов никогда не блокирует выполнение, тогда как вызов в строке `auto myResult= f2.get();` должен дождаться, пока не будет готов результат цепочки фьючерсов. Это справедливо как для сколь угодно длинных цепочек продолжений вида `f1.then(...).then(...).then(...).then(...)`, так и для композиции расширенных фьючерсов. Блокирующим оказывается только вызов функции `get` для получения окончательного результата.

### Средства асинхронного выполнения

Не так много можно пока что сказать о предполагаемых расширениях функции [[async#std async|std::async]] типа [[promise#std promise|std::promise]] и о пакетах заданий [[task|std::package_task]]. Следует лишь отметить, что все они, согласно предложениям к будущему стандарту, должны работать с расширенными фьючерсами.

Композиция фьючерсов – более увлекательная тема. В новом стандарте могут появиться средства для сочленения асинхронных заданий между собой.

### Создание новых фьючерсов

Ожидается, что в стандарт C++23 войдут четыре новые функции для создания особенных фьючерсов: `std::make_ready_future`, `std::make_execptional_future`, `std::when_all` и `std::when_any`. Рассмотрим сначала первые две.

#### Функции для создания фьючерсов с готовым результатом

Функции `std::make_ready_future` и `std::make_execptional_future` создают фьючерсы, результат которых известен наперёд. Первая создаёт фьючерс, возвращающий фиксированное значение, а вторая – фьючерс, бросающий исключение. Хотя на первый взгляд это может показаться удивительным, в таких функциях есть смысл. В стандарте C++11 для создания фьючерса с заранее известным значением требовался бы объект-обещание. Необходим он даже в том случае, когда общее состояние уже имеется в наличии. Рассмотрим пример применения функции.

**Создание фьючерса с заранее известным результатом:**
```c++
future<int> compute(int x) {
	if (x < 0) 
		return make_ready_future<int>(-1);

	if (x == 0) 
		return make_ready_future<int>(0);

	future<int> f1 = async([]() { return do_work(x); });

	return f1;
}
```

Здесь результат вычисляется посредством обещания только при x > 0.

Отметим мимоходом, что эти две функции напоминают функцию `return` из языка `Haskell`, которая оборачивает значение в монаду. Перейдём к функциям, которые служат для сочленения фьючерсов.

#### Композиции фьючерсов

У функций `std::when_all` и `std::when_any` много общего. Посмотрим внимательнее на их объявления.

**Объявления функций `std::when_all` и `std::when_any`:**
```c++
template <class InputIt>
auto when_any(InputIt first, InputIt last)
	-> future<when_any_result<
		std::vector<typename std::iterator_traits<InputIt>::value_type>>>;

template <class... Futures>
auto when_any(Futures&&... futures)
	-> future<when_any_result<std::tuple<std::decay_t<Futures>...>>>;

template <class InputIt>
auto when_all(InputIt first, InputIt last)
	-> future<std::vector<
		typename std::iterator_traits<InputIt>::value_type>>;

template <class... Futures>
auto when_all(Futures&&... futures)
	-> future<std::tuple<std::decay_t<Futures>...>>;
```

Обе функции принимают в качестве аргументов либо пару итераторов по контейнеру фьючерсов, либо произвольное число фьючерсов. В перегрузке с итераторами все фьючерсы должны быть одного типа, тогда как в перегрузке с произвольным числом аргументов фьючерсы могут иметь различные типы – можно даже смешивать типы [[future#std future|std::future]] и [[future#std shared_future|std::shared_future]].

Тип возвращаемого значения этих функций различен для двух перегрузок. В любом случае возвращается фьючерс. В случае перегрузки с парой итераторов возвращается фьючерс с завёрнутым в него вектором фьючерсов. Перегрузка с произвольным числом аргументов возвращает фьючерс с кортежем фьючерсов.

При этом первая функция возвращает фьючерс, который становится готов тогда, когда готовы все фьючерсы, поступившие на вход функции, а вторая – когда готов хотя бы один из них. Следующие два примера иллюстрируют применение этих двух функций.

#### Пример применения функции std::when_all

**Композиция фьючерсов функцией std::when_all:**
```c++
#include <future>

using namespace std;

int main() {
	shared_future<int> shared_future1 = async(
					[] { return intResult(125); });
	future<string> future2 = async(
					[]() { return stringResult(“hi”); });

	future<tuple<shared_future<int>, future<string>>> all_f =
					when_all(shared_future1, future2);

	future<int> result = all_f.then(
				[](future<tuple<shared_future<int>, future<string>>> f){
					return doWork(f.get());
	});

	auto myResult = result.get();
}
```

Фьючерс `all_f` представляет собой композицию двух фьючерсов разных типов: `shared_future1` и `future2`. Фьючерс `result` представляет собой продолжение – он начинает выполняться, когда готов фьючерс `all_f`, который, в свою очередь, становится готов, когда готовы два фьючерса-компонента. Последняя строка кода забирает из него результат вычислений.

#### Пример применения функции std::when_any

**Композиция фьючерсов функцией std::when_any:**
```c++
#include <future>
#include <vector>

using namespace std;

int main(){
	vector<future<int>> v{ .... };
	auto future_any = when_any(v.begin(), v.end());

	when_any_result<vector<future<int>>> result = future_any.get();

	future<int>& ready_future = result.futures[result.index];

	auto myResult = ready_future.get();
}
```

Результат работы фьючерса `future_any` помещается в переменную `result`. В объекте шаблонного типа `when_any_result` содержится целочисленный индекс того из входных фьючерсов, который первым сообщил о своей готовности. Если не пользоваться типом `when_any_result`, пришлось бы опрашивать каждый фьючерс о его готовности, что было бы слишком утомительно.

Наконец, из контейнера фьючерсов в переменную `ready_future` извлекается тот, что готов, а из него – окончательный результат всего вычисления.

В документе P0701r11 отмечается, что ни фьючерсы, уже вошедшие в стандарт ранее, ни экспериментальные фьючерсы из технической спецификации «не являются столь обобщёнными, выразительными и мощными, как им следовало бы быть». Кроме того, обновлённые фьючерсы должны быть унифицированы с исполнителями как основным инструментом управления выполнением всевозможных заданий.

## Унифицированные фьючерсы

Рассмотрим недостатки, общие для фьючерсов – как стандартных, так и экспериментальных, предлагаемых в технической спецификации.

### Недостатки фьючерсов

В упоминавшемся выше документе дано превосходное описание недочётов, присущих фьючерсам.

#### Привязка фьючерсов и обещаний к потокам

В стандарте C++ 11 определён единственный вид исполнителя – поток, т. е. тип [[thread#std thread|std::thread]]. Следовательно, фьючерсы в их нынешнем виде неотделимы от потоков. Ситуация несколько меняется в стандарте C++ 17 с появлением параллельных алгоритмов. Ещё более существенных изменений следует ожидать с появлением в стандарте исполнителей, которые можно использовать для тонкой настройки способа выполнения фьючерса. Например, можно указать, что тот или иной фьючерс должен выполняться в отдельном потоке, через пул потоков или в вызывающем потоке.

#### Способ выполнения продолжений

Рассмотрим несложное продолжение – такое, как в следующем примере.

**Фьючерс с продолжением:**
```c++
future<int> f1 = async([]() { return 123; });

future<string> f2 = f1.then([](future<int> f) {
	return to_string(f.get());
});
```

Попробуем ответить на вопрос: где именно должно выполняться продолжение? Сейчас возможны следующие варианты:

1. потребитель: выполнением продолжения занимается тот выполняющий агент, в котором работает потребитель, запросивший результат фьючерса `f2`;
2. производитель: продолжение может выполняться в том же агенте, который выполнял фьючерс `f1`;
3. автоматический выбор: если в момент присоединения продолжения фьючерс `f1` готов, продолжение выполняется на стороне потребителя, в противном случае – на стороне производителя;
4. отдельный поток: для выполнения продолжения может создаваться новый поток.

Первые два варианта обладают существенным недостатком: они блокируют выполнение. В первом случае потребитель блокирует свой поток до тех пор, пока не будет готов производитель. Во втором же случае производитель блокирует поток до тех пор, пока не закончит свою работу продолжение.

Ниже показаны примеры передачи исполнителей по цепочке продолжений, взятые из документа P0707r1.

**Передача исполнителя по цепочке продолжений:**
```c++
auto i = std::async(thread_pool, f).then(g).then(h);
// f, g и h выполняются в пуле потоков

auto i = std::async(thread_pool, f).then(g, gpu).then(h);
// f выполняется в пуле потоков, g и h – на графическом процессоре

auto i = std::async(inline_executor, f).then(g).then(h);
// выражение h(g(f())) вызывается на агенте, выполняющем вызов
```

#### Передача фьючерса в продолжение слишком громоздка

В продолжение передаётся объект-фьючерс, а не выработанное им значение, что делает синтаксис довольно запутанным. Вот пример такого правильного, но излишне многословного кода.

**Продолжение фьючерса:**
```c++
std::future<int> f1 = std::async([]() { return 123; });

std::future<std::string> f2 = f1.then([](std::future<int> f) {
	return std::to_string(f.get());
});
```

Предположим теперь, что результат предыдущего фьючерса может передаваться в продолжение по значению – или что функция `to_string` имеет перегрузку для типа `std::future<int>`. В результате получим более компактный код.

**Продолжение фьючерса с передачей значения:**
```c++
std::future<int> f1 = std::async([]() { return 123; });
std::future<std::string> f2 = f1.then(std::to_string);
```

#### Композиции фьючерсов возвращают слишком громоздкие типы

Из [[#Композиции фьючерсов|примеров]] видно, что типы, возвращаемые функциями `when_all` и `when_any`, слишком сложны в использовании.

#### Условную блокировку в деструкторе фьючерса нужно устранить

Фьючерсы, работающие по принципу «выстрели и забудь», выглядят привлекательно, но обладают большим недостатком. Фьючерс, созданный функцией [[async#std async|std::async]], ждёт в своём деструкторе, пока не выполнится связанное с ним обещание. То, что на первый взгляд кажется параллельным, выполняется последовательно. Согласно документу P0707r1, такое поведение чревато ошибками и недопустимо. [[async#Запустить и забыть|аномалии, связанные с принципом «выстрели и забудь»]].

#### Нужна совместимость непосредственно данных и будущих значений

В стандарте C++ 11 нет удобного способа для создания фьючерсов – приходится начинать с объекта-обещания.

**Создание фьючерса в нынешнем стандарте:**
```c++
std::promise<std::string> p;

std::future<std::string> fut = p.get_future();
p.set_value(“hello”);
```

Эта ситуация может измениться с принятием в стандарт предложений, ныне оформленных в технической спецификации.

**Создание фьючерса средствами предполагаемого будущего стандарта:**
```c++
std::future<std::string> fut = make_ready_future(“hello”);
```

Если же в будущем появится возможность использовать будущие значения наряду с непосредственно данными, это заметно упростит работу программистов.

**Совместное использование непосредственно данных и будущих значений:**
```c++
bool f(std::string, double, int);

std::future<std::string> a = /* ... */;
std::future<int> c = /* ... */;

std::future<bool> d1 = when_all(a, make_ready_future(3.14), c).then(f);
// f(a.get(), 3.14, c.get())

std::future<bool> d2 = when_all(a, 3.14, c).then(f);
// f(a.get(), 3.14, c.get())
```

Ни одна из желаемых синтаксических форм `d1` и `d2` не реализуема даже средствами технической спецификации. Следует надеяться, этот пробел будет закрыт в будущем.

### Пять новых концептов

В предложении к стандарту 1054R0 определяются пять новых концептов, касающихся фьючерсов и обещаний.

* **FutureContinuation** – вызываемый объект, которому в качестве аргумента передаётся значение или исключение от фьючерса.
* **SemiFuture** – операция, которая принимает на вход исполнителя и возвращает объект, удовлетворяющий концепту **ContinuableFuture** (пример: `f = sf.via(exec))`.
* **ContinuableFuture** – конкретизация концепта `SemiFuture`; тип фьючерса, к экземплярам которого можно присоединить одно продолжение, удовлетворяющее концепту `FutureContinuation`, которое выполняется исполнителем, связанным с фьючерсом.
* **SharedFuture** – конкретизация концепта `ContinuableFuture`, позволяющая присоединять к экземпляру множество продолжений из концепта `FutureContinuation`.
* **Promise** – объект, связанный с фьючерсом и переводящий фьючерс в состояние готовности с вычисленным значением или исключением в качестве результата.

В документе приводится также объявление этих концептов.

**Предлагаемые новые концепты для фьючерсов и обещаний:**
```c++
template <typename T>
struct FutureContinuation
{
	// По меньшей мере она из двух следующих перегрузок
	auto operator()(T value);
	auto operator()(exception_arg_t, exception_ptr exception);
};

template <typename T>
struct SemiFuture
{
	template <typename Executor>
	ContinuableFuture<Executor, T> via(Executor&& exec) &&;
};

template <typename Executor, typename T>
struct ContinuableFuture
{
	template <typename RExecutor>
	ContinuableFuture<RExecutor, T> via(RExecutor&& exec) &&;

	template <typename Continuation>
	ContinuableFuture<Executor, auto> then(Continuation&& c) &&;
};

template <typename Executor, typename T>
struct SharedFuture
{
	template <typename RExecutor>
	ContinuableFuture<RExecutor, auto> via(RExecutor&& exec);

	template <typename Continuation>
	SharedFuture<Executor, auto> then(Continuation&& c);
};

template <typename T>
struct Promise
{
	void set_value(T value) &&;
	
	template <typename Error>
	void set_exception(Error exception) &&;

	bool valid() const;
};
```

Из этих объявлений можно сделать следующие выводы:

* экземпляру концепта `FutureContinuation` можно передать либо значение какого-то типа, либо исключение. Этот экземпляр представляет собой вызываемый объект, который принимает на вход значение или исключение и делает их результатом работы фьючерса;
* все виды фьючерсов (`SemiFuture`, `ContinuableFuture`, `SharedFuture`) обладают функцией-членом `via`, которая принимает аргумент-исполнитель и возвращает экземпляр концепта `ContinuableFuture`. Функция `via` позволяет превращать один тип фьючерса в другой, подставляя различные исполнители;
* функция-член `then` есть только у концептов `ContinuableFuture` и `SharedFuture`. Эта функция принимает экземпляр концепта `FutureContinuation` и возвращает экземпляр концепта `ContinuableFuture`;
* концепт `SharedFuture` поддерживает семантику неисключительного владения фьючерсом, его экземпляры могут копироваться;
* концепт `Promise` позволяет установить значение или исключение в качестве результата работы фьючерса.

### Направления дальнейшей работы

В предложении 1054R2 некоторые вопросы остаются открытыми:
* гарантии продвижения вперёд для фьючерсов и обещаний;
* требования синхронизации для использования фьючерсов и обещаний в непараллельных выполняющих агентах;
* интероперабельность фьючерсов и обещаний;
* раскрытие вложенных фьючерсов: как вида `future<future<T>>`, так и более сложных;
* функции `when_all`, `when_any` и `when_n`;
* семантика функции [[async#std async|async]].
