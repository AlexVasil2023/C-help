
[[#Процесс функционирования сопрограммы|Процесс функционирования сопрограммы]] 5.5
1. [[#Управление обещанием|Управление обещанием]] 5.5.1
2. [[#Управление ожиданием|Управление ожиданием]] 5.5.2

# Процесс функционирования сопрограммы

Компилятор преобразовывает сопрограмму и создаёт два механизма: механизм управления объектом-обещанием, находящимся снаружи от кода сопрограммы, и механизм управления ожиданием, работающий внутри сопрограммы.

## Управление обещанием

Если в теле функции используются ключевые слова `co_yield`, `co_await` или `co_return`, эта функция становится сопрограммой, и компилятор преобразовывает её тело в нечто наподобие следующего кода.

**Преобразованная сопрограмма:**
```c++
{
	Promise prom;
	co_await prom.initial_suspend();

	try {
		<тело функции с операторами co_return, co_yield, or co_await>
	}
	catch (...) {
		prom.unhandled_exception();
	}
	
	FinalSuspend:
		co_await prom.final_suspend();
}
```

Таким образом, преобразованный код работает с объектом-обещанием. Ниже перечислены основные этапы процедуры управления обещанием.

- Начинается выполнение сопрограммы:
	- выделяется память для кадра;
	- значения параметров функции копируются в кадр;
	- создаётся объект-обещание `prom` (строка `Promise prom;`);
	- совершается вызов `prom.get_return_object()`, чтобы получить дескриптор сопрограммы и сохранить его в локальной переменной. Результат этого вызова возвращается вызывающей стороне, когда сопрограмма в первый раз приостанавливает выполнение;
	- вызывается функция `prom.initial_suspend()`, её результат используется для ожидания с помощью оператора `co_await`, как показано в строке `co_await prom.initial_suspend();`. Напомним, что функция `initial_suspend` объекта-обещания может возвращать объекты `suspend_never` и `suspend_always` для жадной и ленивой стратегий вычислений соответственно;
	- когда начальное ожидание закончено, выполняется тело сопрограммы.
- Выполнение сопрограммы достигает точки приостанова:
	- значение `prom.get_return_object()` возвращается функции, которая пробудила сопрограмму.
- Выполнение сопрограммы достигает оператора `co_return`:
	- вызывается функция `prom.return_void()`, если оператор употреблён без аргумента или с выражением типа `void`;
	- вызывается функция `prom.return_value()`, если оператор употреблён с выражением-аргументом типа, отличного от `void`;
	- уничтожаются все переменные, созданные в стеке;
	- вызывается функция `prom.final_suspend()`, затем к полученному результату применяется оператор `co_await`.
- Выполнение сопрограммы завершается (например, после оператора `co_return`, вследствие необработанного исключения, или по запросу через дескриптор сопрограммы):
	- вызывается деструктор объекта-обещания;
	- вызываются деструкторы объектов-аргументов функции;
	- освобождается память, выделенная для кадра сопрограммы;
	- управление возвращается вызвавшему контексту.

Если сопрограмма завершается из-за необработанного исключения, дополнительно выполняются следующие действия:

* исключение перехватывается, затем из обработчика вызывается функция `prom.unhandled_exception()`;
* вызывается функция `prom.final_suspend()`, затем к полученному результату применяется оператор `co_await`.

## Управление ожиданием

Наличие в сопрограмме оператора `co_await` заставляет компилятор преобразовать его, добавив вызовы функций `await_ready`, `await_suspend` и `await_resume` контроллера ожидания `awaiter`. Основное назначение преобразованного кода можно охарактеризовать как управление ожиданием.

В первом приближении результат работы компилятора можно представить следующим псевдокодом.

**Генерируемый код управления ожиданием:**
```
если awaiter.await_ready() возвращает false:

	приостановить сопрограмму

	если awaiter.await_suspend(coroutineHandle) возвращает тип:

	void:
		awaiter.await_suspend(coroutineHandle);
		сопрограмма остаётся приостановленной
		вернуть управление вызвавшему коду

	bool:
		bool result = awaiter.await_suspend(coroutineHandle);
		если result имеет значение “истина”:
			сопрограмма остаётся приостановленной
			вернуть управление вызвавшему коду
	иначе:
		goto возобновление

	десприптор другой сопрограммы:
		auto anotherHandle = awaiter.await_suspend(coroutineHandle);
		anotherHandle.resume();
		вернуть управление вызвавшему коду

	возобновление:

	return awaiter.await_resume();
```

Все эти действия выполняются только в случае, если функция `awaiter.await_ready()` возвращает значение `false`. Если же этот вызов возвращает значение `true`, это означает, что сопрограмма уже вычислила свой результат – тогда остаётся лишь вызвать функцию `awaiter.await_resume` (строка `return awaiter.await_resume();`).

Предположим, что выражение `awaiter.await_ready()` даёт значение `false`. В первую очередь сопрограмма приостанавливается, вслед за этим сразу вызывается функция `awaiter.await_suspend`. Её возвращаемым типом может быть тип `void`, логический или дескриптор сопрограммы. Механизма управления ожиданием работает различным образом в каждом из этих трёх случаев.

**Управление ожиданием в зависимости от типа функции `await_suspend`:**

| **Тип**                 | **Описание**                                                                                                                                                           |
| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `void`                  | Сопрограмма приостанавливается и отдаёт управление вызвавшему коду                                                                                                     |
| `bool`                  | При значении `true`: сопрограмма приостанавливается и отдаёт управление вызвавшему коду.<br>При значении `false`: сопрограмма продолжает работу и не отдаёт управление |
| `std::coroutine_handle` | Другая сопрограмма пробуждается и продолжает выполнение. Текущая сопрограмма отдаёт управление                                                                         |

Что должно произойти при выбросе исключения? Это зависит от того, где возникает исключение: в функции `await_ready`, `await_suspend` или `await_resume`:
- функция `await_ready`: сопрограмма не приостанавливается, функции `await_suspend` и `await_resume` не вызываются;
- функция `await_suspend`: исключение перехватывается, сопрограмма продолжает свою работу, функция `await_resume` не вызывается;
- функция `await_resume`: вызовы функций `await_ready` и `await_suspend` уже отработали и вернули свои значения, но вызов функции `await_resume`, конечно, значения не возвращает.

Теперь пора показать, как эта теория работает на практике.


