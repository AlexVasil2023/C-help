
[[#Потокобезопасная очередь|Потокобезопасная очередь]] 12.3
1. [[#Блокировка очереди целиком|Блокировка очереди целиком]] 12.3.1
2. [[#Раздельная блокировка концов очереди|Раздельная блокировка концов очереди]] 12.3.2
	1. [[#Некорректная реализация|Некорректная реализация]] 12.3.2.1
	2. [[#Простая реализация очереди|Простая реализация очереди]] 12.3.2.2

# Потокобезопасная очередь

Как и в предыдущем разделе, начнём с ответа на вопрос, что такое очередь. Стандартный адаптер контейнера [[queue|std::queue]], объявленный в заголовочном файле `<queue>`, воплощает принцип «первым пришёл – первым ушёл» (англ. FIFO – first in first out). В его интерфейсе четыре основные функции.

![[ParallelProg_249.png]]

Функция-член `push` вставляет элемент в конец очереди, функция `pop` удаляет элемент из её начала; функция `back` позволяет получить ссылку на последний элемент очереди, а функция `front` – на первый. Кроме того, есть ещё вспомогательные функции, возвращающие размер очереди и позволяющие сравнивать очереди между собой. Пример использования очереди показан ниже.

```c++
#include <queue>

...

std::queue<int> myQueue;
std::cout << myQueue.empty() << ‘\n’;              // true
std::cout << myQueue.size() << ‘\n’;               // 0

myQueue.push(1);
myQueue.push(2);
myQueue.push(3);

std::cout << myQueue.back() << ‘\n’;              // 3
std::cout << myQueue.front() << ‘\n’;             // 1

while (!myQueue.empty()){
	std::cout << myQueue.back() << “ “;
	std::cout << myQueue.front() << “ : “;
	myQueue.pop();
}                                                // 3 1 : 3 2 : 3 3

std::cout << myQueue.empty() << ‘\n’;            // true
std::cout << myQueue.size() << ‘\n’;             // 0
```

Первый вариант реализации потокобезопасной очереди весьма похож на рассмотренную выше реализацию потокобезопасного стека.

## Блокировка очереди целиком

Начнём с наиболее очевидной реализации. Объединим функции-члены `front` и `pop` в функцию `frontAndPop`. Функция `push` остаётся без изменений и добавляет элемент в конец очереди. Что же касается функции `back`, которая возвращает последний элемент очереди, она для очереди в общем случае не обязательна, и есть большие сомнения, нужно ли её вообще поддерживать в данном примере. Вот некоторые основания для этого.
3. Поддержка функции `back` налагает на программиста дополнительные обязательства, тогда как клиенты редко нуждаются в этой операции.
4. Комбинированная операция `backAndPush` должна была бы возвращать значение, которое было в очереди последним перед добавлением нового элемента в конец. Такая составная операция могла бы выглядеть многообещающе, но обладает двумя серьёзными недостатками. Во-первых, значение, бывшее в очереди последним, эта функция должна возвращать путём копирования, поскольку возврат по ссылке или указателю открыл бы дорогу гонке данных. Однако копирование может нанести удар по производительности. Во-вторых, конструктор копирования может выбросить исключение.
5. Наличие двух отдельных функций `back` и `push` делает возможной гонку данных. В самом деле, пусть клиентский код делает некоторые предположения, основываясь на значении последнего элемента. Тогда может возникнуть ситуация, подобная той, что наблюдалась бы при наличии отдельных операций `front` и `pop`. Здесь справедливы те же соображения, которые мы разобрали выше в связи с операциями `pop` и `top` для потокобезопасного стека. Хотя подобный способ использования очереди выглядит необычным и маловероятен на практике, лучше поступить осторожно и не оставить даже теоретической возможности для такой ошибки.

Реализация потокобезопасной очереди довольно проста и весьма похожа на реализацию стека. Код показан ниже.

**Потокобезопасная очередь с полной блокировкой:**
```c++
// concurrentQueueCoarseLocking.cpp

#include <future>
#include <limits>
#include <iostream>
#include <mutex>
#include <queue>
#include <stdexcept>
#include <utility>

template <typename T,
		template <typename, typename> class Cont = std::deque>
class ConcurrentQueue {
	public:
		void push(T val) {
			std::lock_guard<std::mutex> lockQueue(mutexQueue);
			myQueue.push(std::move(val));
		}

		T frontAndPop() {
			std::lock_guard<std::mutex> lockQueue(mutexQueue);
			
			if ( myQueue.empty() )
				throw std::out_of_range(“The queue is empty!”);
			
			auto val = myQueue.front();
			myQueue.pop();
			return val;
		}

		ConcurrentQueue() = default;
		ConcurrentQueue(const ConcurrentQueue&) = delete;
		ConcurrentQueue& operator= (const ConcurrentQueue&) = delete;

	private:
		mutable std::mutex mutexQueue;
		std::queue<T, Cont<T, std::allocator<T>>> myQueue;
};

int main() {
	ConcurrentQueue<int> conQueue;

	auto fut0 = std::async([&conQueue]{ conQueue.push(2011); });
	auto fut1 = std::async([&conQueue]{ conQueue.push(2014); });
	auto fut2 = std::async([&conQueue]{ conQueue.push(2017); });
	auto fut3 = std::async([&conQueue]{ return conQueue.frontAndPop(); });
	auto fut4 = std::async([&conQueue]{ return conQueue.frontAndPop(); });
	auto fut5 = std::async([&conQueue]{ return conQueue.frontAndPop(); });

	fut0.get(), fut1.get(), fut2.get();

	std::cout << fut3.get() << std::endl;
	std::cout << fut4.get() << std::endl;
	std::cout << fut5.get() << std::endl;
}
```

Без пространных пояснений покажем сразу результат запуска программы.

![[ParallelProg_250.png]]

Можно ли считать задачу полностью решённой? Нет, так как у представленной здесь реализации имеется потенциал для оптимизации.

## Раздельная блокировка концов очереди

В отличие от стека, где добавление и изъятие элементов выполняются с одного и того же конца контейнера, в случае очереди операции `push` и `pop` работают с разными его концами.

### Некорректная реализация

Вместо того чтобы брать блокировку на всю очередь посредством единого мьютекса, можно было бы попытаться использовать отдельные мьютексы для начала и конца очереди в надежде, что это уменьшит общее количество синхронизаций.

**Некорректная реализация очереди с раздельной блокировкой:**
```c++
template <typename T,
			template <typename, typename> class Cont = std::deque>
class ConcurrentQueue {
	public:
		void push(T val) {
			std::lock_guard<std::mutex> lockQueue(mutexBackQueue);
			myQueue.push(std::move(val));
		}
		
		T frontAndPop() {
			std::lock_guard<std::mutex> lockQueue(mutexFrontQueue);
			
			if (myQueue.empty())
				throw std::out_of_range(“The queue is empty!”);

			auto val = myQueue.front();
			myQueue.pop();
			
			return val;
		}

		ConcurrentQueue() = default;
		ConcurrentQueue(const ConcurrentQueue&) = delete;
		ConcurrentQueue& operator= (const ConcurrentQueue&) = delete;

	private:
		mutable std::mutex mutexFrontQueue;
		mutable std::mutex mutexBackQueue;
		std::queue<T, Cont<T, std::allocator<T>>> myQueue;
};
```

Эта реализация содержит ошибку, которая делает её полностью некорректной. Если очередь пуста, её начало и конец совпадают, и операции `push` и `pop` работают над одним и тем же элементом, что приводит к гонке данных. Добавление в очередь фиктивного элемента, который всегда разделяет начало и конец, могло бы решить проблему.

Потокобезопасную очередь с раздельной блокировкой начала и конца невозможно построить, основываясь на абстракциях, предоставляемых стандартным типом [[queue|std::queue]]. Следовательно, структуру данных, лежащую в основе очереди, придётся реализовать самостоятельно. Прежде всего разберём, как можно реализовать очередь, а затем заделаем её потокобезопасной.

### Простая реализация очереди























