[[#Кооперативное прерывание потоков]]
1. [[#Класс std stop_source|Класс std::stop_source]] 3.6.1
2. [[#Класс std stop_token|Класс std::stop_token]] 3.6.2 
3. [[#Класс std stop_callback|Класс std::stop_callback]] 3.6.3
4. [[#Общий механизм посылки сигналов]] 3.6.4
5. [[thread#Особенности класса std jthread|Особенности класса std::jthread]] 3.6.5
6. [[variable conditions#Новые перегрузки функции wait в классе std condition_variable_any|Новые перегрузки функции wait в классе std::condition_variable_any]] 3.6.6
7. 

# Кооперативное прерывание потоков

Появившаяся в стандарте C++20 дополнительная возможность прерывать потоки кооперативно (т. е. с их согласия) основывается на классах [[#Класс std stop_source|std::stop_source]], [[#Класс std stop_token|std::stop_token]] и [[#Класс std stop_callback|std::stop_callback]]. Класс потоков [[thread#std jthread|std::jthread]] и класс переменных условия [[variable conditions|std::condition_variable_any]] также поддерживают кооперативное прерывание.

В первую очередь разберёмся, почему бы просто не «убить» поток.

> **Чем опасно жёсткое прерывание потоков**
> 
> Жёсткое прерывание потока может быть опасно, так как заранее неизвестно его текущее состояние. Внезапное прерывание потока грозит следующими двумя неприятными последствиями:
>
> * поток выполнил свою работу лишь наполовину. Невозможно определить, в каком состоянии он оставил данные, над которыми работал, а значит, и состояние всей программы. Это ведёт к неопределённому поведению, когда любые предположения о корректной работе программы теряют силу;
> * поток может находиться в критической секции и удерживать захваченный [[mutex|мьютекс]]. Прерывание потока в этом состоянии с большой вероятностью приведёт к мёртвой блокировке других потоков.
> * поток может удерживать некоторый ресурс, будь то динамическая память, открытый файл, графическое окно или системный таймер. Прерывание потока в этом состоянии лишает его возможности когда-либо освободить ресурс. В самом деле, владельцем ресурса, с точки зрения операционной системы, является целый процесс, а не тот или иной его поток. В частности, один поток может ресурс запрашивать (скажем, выделять динамическую память или открывать файл), а затем передавать владение им другому потоку. Поэтому прерывание потока может привести к утечке ресурсов, которая устраняется только завершением всего процесса.

Классы [[#Класс std stop_source|std::stop_source]] (источник останова), [[#Класс std stop_token|std::stop_token]] (признак останова) и [[#Класс std stop_callback|std::stop_callback]] (обработчик останова) позволяют одному потоку асинхронно попросить другой поток о завершении, а этому другому потоку – проверить, имел ли место запрос на завершение. Признак останова (объект типа [[#Класс std stop_token|std::stop_token]]) можно передать в поток в качестве аргумента, чтобы поток затем периодически опрашивал, не пришёл ли запрос для завершения, или использовал этот объект для регистрации обработчика типа [[#Класс std stop_callback|std::stop_callback]]. Для посылки запроса на останов используется объект [[#Класс std stop_source|std::stop_source]]. Сигнал от объекта-источника доходит до всех связанных с ним объектов-признаков типа [[#Класс std stop_token|std::stop_token]]. Объекты этих трёх классов совместно управляют состоянием завершения потока.

## Класс std::stop_source
#std_stop_source

Объекты этого класса можно создавать двумя способами.

**Конструкторы класса `std::stop_source`**
```c++
std::stop_source();
explicit std::stop_source(std::nostopstate_t) noexcept;
```

Конструктор по умолчанию `std::stop_source()` создаёт источник останова с новым состоянием останова. Конструктор, принимающий один аргумент типа `std::nostopstate_t`, создаёт пустой объект-источник, не связанный ни с каким состоянием останова.

**Функции-члены класса `std::stop_source`**


| **Функция**      | **Описание**                                                                                                                                                                                                                                                                        |
| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `get_token`      | Если останов возможен ( см. `stop_possible`), возвращает признак останова ([[#Класс std stop_token\|stop_token]]), связанный с тем же состоянием останова, что и объект-источник. В противном случае возвращает пустой (не связанный ни с каким состоянием останова) объект-признак |
| `stop_possible`  | Возвращает значение «истина», если через данный объект-источник можно запросить останов потока, иначе – «ложь»                                                                                                                                                                      |
| `stop_requested` | Возвращает значение «истина», если останов возможен и был запрошен для данного состояния останова через один из связанных с ним объектов-источников                                                                                                                                 |
| `request_stop`   | Запрашивает останов. Если останов для данного объекта невозможен или уже был запрошен, функция ничего не делает                                                                                                                                                                     |

Вызов функции `get_token` для объекта-источника возвращает новый объект типа [[#Класс std stop_token|std::stop_token]]. Этот объект-признак может использоваться внутри потока для проверки того, сделан ли запрос на останов и возможен ли такой запрос. Таким образом, объект-признак наблюдает за состоянием останова, которым управляют объекты-источники.

Вызов функции `request_stop` у объекта-источника становится виден всем объектам-признакам и другим объектам-источникам, связанным с тем же самым состоянием останова. Помимо этого, вызываются все обработчики, зарегистрированные для признаков останова. Все ожидающие переменные условия типа [[variable conditions|std::condition_variable_any]], у которых ожидание связано с соответствующими объектами [[#Класс std stop_token|stop_token]], пробуждаются. Когда запрос на останов сделан, отменить его уже невозможно. Функции `request_stop` (при условии что останов уже был запрошен) и `stop_possible` выполняются атомарным образом.

Функция `stop_requested` возвращает значение `true`, если объект-источник связан с некоторым состоянием останова и останов для него был запрошен ранее. Вызов функции `request_stop` считается успешным и возвращает значение `true`, если состояние останова у источника существует и останов ранее не запрашивался.

## Класс std::stop_token

**Функции-члены класса std::stop_token:**

| **Функция**      | **Описание**                                                                                         |
| ---------------- | ---------------------------------------------------------------------------------------------------- |
| `stop_possible`  | Возвращает значение «истина», если через данный объект-признак связан с каким-то состоянием останова |
| `stop_requested` | Возвращает значение «истина», если останов был запрошен для данного состояния останова, иначе «ложь» |

Функция `stop_possible` возвращает значение «истина» и в том случае, если запрос на останов уже был сделан. Объект типа [[#Класс std stop_token|std::stop_token]], созданный конструктором по умолчанию, не связан ни с каким состоянием останова.

Функция `stop_requested` возвращает значение «истина», если данный объект-признак связан с состоянием останова и для него выполнен запрос на останов.

Если всю функциональность объекта [[#Класс std stop_token|std::stop_token]] нужно временно отключить, его можно подменить объектом-признаком, созданным по умолчанию. Следующий небольшой фрагмент кода демонстрирует, как отключать и снова включать способность потока реагировать на запрос останова.

**Временное отключение признака останова:**
```c++
std::jthread jthr([](std::stop_token stoken) {
	...

	std::stop_token interruptDisabled;
	std::swap(stoken, interruptDisabled);

	...

	std::swap(stoken, interruptDisabled);

	...
}
```

Объект `interruptDisabled` не связан ни с каким состоянием останова. Это означает, что поток `jthr` способен откликаться на просьбу об останове либо до строки `std::swap(stoken, interruptDisabled)`, либо после повторного вызова `std::swap(stoken, interruptDisabled)`.

## Класс std::stop_callback

Класс `std::stop_callback` воплощает идиому RAII: в его конструкторе регистрируется вызываемый объект (в частности, функция), а в деструкторе регистрация отменяется. В следующем примере показано, как пользоваться обработчиками останова.

**Использование обработчиков останова:**
```c++
// invokeCallback.cpp

#include <atomic>
#include <chrono>
#include <iostream>
#include <thread>
#include <vector>

using namespace std::literals;

auto func = [](std::stop_token stoken) {
	std::atomic<int> counter{0};

	auto thread_id = std::this_thread::get_id();

	std::stop_callback callBack(stoken, [&counter, thread_id] {
		std::cout << “Thread id: “ << thread_id
							<< “; counter: “ << counter << ‘\n’;
	});

	while (counter < 10) {
		std::this_thread::sleep_for(0.2s);
		++counter;
	}
};

int main() {
	std::cout << ‘\n’;

	std::vector<std::jthread> vecThreads(10);

	for(auto& thr: vecThreads) 
		thr = std::jthread(func);

	std::this_thread::sleep_for(1s);

	for(auto& thr: vecThreads) 
		thr.request_stop();
		
	std::cout << ‘\n’;
}
```

Каждый из десяти потоков выполняет лямбда-функцию `func`. Эта функция в строках `std::stop_callback callBack(stoken, [&counter, thread_id]...` выводит на печать идентификатор потока и текущее значение атомарного счётчика. Счётчик, должен быть атомарным, поскольку он модифицируется в дочернем потоке и одновременно читается в обработчике, который вызывается в главном потоке. Благодаря односекундной задержке в главном потоке и задержкам на каждой итерации дочерних потоков в момент запроса на останов обработчик отображает значение счётчиков, равное четырём. Вызов функции `request_stop` для объекта `thr` типа [[thread#std jthread|std::jthread]] посылает потоку запрос на останов и, следовательно, приводит к вызову обработчика. Ниже показан результат работы программы. 

> Приведённый здесь пример нуждается в дополнительных пояснениях и может быть улучшен. Во-первых: если функция (или, говоря шире, вызываемый объект) принимает первый параметр типа [[#Класс std stop_token|std::stop_token]], конструктор класса [[thread#std jthread|std::jthread]] неявно передаёт объект-признак, связанный с тем же состоянием останова, что и логически содержащийся в объекте [[thread#std jthread|std::jthread]] подобъект `stop_source`.
> 
> Таким образом, десять дочерних потоков обладают каждый своим источником останова. Поэтому каждому из них нужно посылать свой сигнал останова (строка `thr.request_stop();`). Можно было бы вместо типа [[thread#std jthread|std::jthread]] использовать более простой тип [[thread#std thread|std::thread]] без встроенной поддержки останова и останавливать все потоки единым сигналом извне, как показано ниже:
```c++
std::stop_source source;

std::vector<std::thread> vecThreads(10);

for (auto& thr : vecThreads)
	thr = std::thread(func, source.get_token());
	
std::this_thread::sleep_for(1s);
source.request_stop();

for (auto& thr : vecThreads) 
	thr.join();
```

> Далее, приведённый пример, иллюстрируя вызов обработчика, вызываемого в ответ на сигнал останова, не прерывает выполнение потока. Этого легко добиться, изменив условие цикла следующим образом:
```c++
while (counter < 10 && !stoken.stop_requested())
```

Объявление `func` как лямбда-функции вряд ли оправдано. Поведение программы ничуть не изменилось бы, `func` будь обычной функцией:
```c++
void func(std::stop_token stoken)
```

![[ParallelProg_70.png]]

Обработчики останова, зарегистрированные в конструкторе класса [[#Класс std stop_callback|std::stop_callback]], вызываются, как правило, в том потоке, который вызывает функцию `request_stop` соответствующего объекта [[#Класс std stop_source|std::stop_source]]. Однако если останов уже был запрошен к моменту регистрации, обработчик вызывается в том потоке, который конструирует объект [[#Класс std stop_callback|std::stop_callback]].

Для любого из потоков, использующих один объект [[#Класс std stop_token|std::stop_token]], можно регистрировать сколь угодно много обработчиков останова. Стандарт языка C++ ничего не говорит о том, в каком порядке они вызываются. Пример множественных обработчиков представлен ниже.

**Регистрация нескольких обработчиков останова в двух потоках:**
```c++
// invokeCallbacks.cpp

#include <chrono>
#include <iostream>
#include <thread>

using namespace std::literals;

void func(std::stop_token stopToken) {
	std::this_thread::sleep_for(100ms);

	for (int i = 0; i <= 9; ++i) {
		std::stop_callback cb(stopToken, [i] { std::cout << i; });
	}

	std::cout << ‘\n’;
}

int main() {
	std::cout << ‘\n’;

	std::jthread thr1 = std::jthread(func);
	std::jthread thr2 = std::jthread(func);

	thr1.request_stop();
	thr2.request_stop();
	
	std::cout << ‘\n’;
}
```

![[ParallelProg_71.png]]

## Общий механизм посылки сигналов

Можно сказать, что работающие в паре классы [[#Класс std stop_source|std::stop_source]] и [[#Класс std stop_token|std::stop_token]] составляют универсальный механизм для посылки сигналов. Копируя объект [[#Класс std stop_token|std::stop_token]], можно один и тот же сигнал рассылать любым сущностям, выполняющим какой-либо код. В следующем примере показано, как этот механизм рассылки сигналов работает с классами [[async|std::async]], [[promise|std::promise]], [[thread#std thread|std::thread]] и [[thread#std jthread|std::jthread]] в разных комбинациях.

**Рассылка сигнала разным единицам выполнения:**
```c++
// signalStopRequests.cpp

#include <iostream>
#include <thread>
#include <future>

using namespace std::literals;

void function1(std::stop_token stopToken, const std::string& str){
	std::this_thread::sleep_for(1s);

	if (stopToken.stop_requested())
		std::cout << str << “: Stop requested\n”;
}

void function2(std::promise<void> prom,
					std::stop_token stopToken, const std::string& str)
{
	std::this_thread::sleep_for(1s);
	
	std::stop_callback callBack(stopToken, [&str] {
		std::cout << str << “: Stop requested\n”;
	});

	prom.set_value();
}

int main() {
	std::cout << ‘\n’;

	std::stop_source stopSource;
	std::stop_token stopToken = std::stop_token(stopSource.get_token());

	std::thread thr1 = std::thread(function1, stopToken, “std::thread”);
	std::jthread jthr = std::jthread(
								function1, stopToken, “std::jthread”);

	auto fut1 = std::async([stopToken] {
		std::this_thread::sleep_for(1s);

		if (stopToken.stop_requested())
			std::cout << “std::async: Stop requested\n”;
	});


	std::promise<void> prom;
	auto fut2 = prom.get_future();

	std::thread thr2(
				function2, std::move(prom), stopToken, “std::promise”);

	stopSource.request_stop();
	if (stopToken.stop_requested())
		std::cout << “main: Stop requested\n”;

	thr1.join();
	thr2.join();

	std::cout << ‘\n’;
}
```

Имея объект `stopSource` (объявлен `std::stop_source stopSource;`), можно создать объект [[#Класс std stop_token|stop-Token]] (`std::stop_token stopToken = std::stop_token(stopSource.get_token());`) и снимать с него копию при создании каждой единицы выполнения: [[thread#std thread|std::thread]] (`std::thread thr1 = std::thread(function1, stopToken, “std::thread”);`), [[thread#std jthread|std::jthread]] (`std::jthread jthr = std::jthread(function1, stopToken, “std::jthread”);`), [[async|std::async]] (`auto fut1 = std::async([stopToken] { ... });`) и [[promise|std::promise]] (`auto fut2 = prom.get_future();`). Копирование объектов типа [[#Класс std stop_token|std::stop_token]] – дешёвая операция. В строке `stopSource.request_stop();` для объекта `stopSource` вызывается функция `request_stop`. В числе прочих адресатов сигнал получает и главный поток. Класс [[thread#std jthread|std::jthread]] используется в этом примере из-за набора удобных функций-членов, позволяющих в явном виде управлять кооперативным прерыванием потоков. 

![[ParallelProg_72.png]]

Может быть любопытно, зачем единицы выполнения ожидают по одной секунде (`std::this_thread::sleep_for(1s);`). Задержки нужны для того, чтобы вызову функции `request_stop` в строке `stopSource.request_stop();` было что делать. Единицы выполнения, такие как [[thread#std thread|std::thread]] (`std::thread thr1 = std::thread(function1, stopToken, “std::thread”);`), [[thread#std jthread|std::jthread]] (строка `std::jthread jthr = std::jthread(function1, stopToken, “std::jthread”);`), [[async|std::async]] (строка `auto fut1 = std::async([stopToken] { ... });`) и [[promise|std::promise]] (строка `std::promise<void> prom;`), в момент появления запроса на останов могут находиться в одном из следующих состояний:

* **не запущена.** Тогда вызов функции `stop_requested`, когда до него дойдёт выполнение, вернёт значение `true`, и обработчик выполнится;
* **выполняется.** Единица выполнения получает сигнал в процессе своей работы. Чтобы запрос на останов оказал действие, он должен быть отправлен до того, как единица выполнения дойдёт до вызова функции `stop_requested`, или до инициализации обработчика;
* **завершена.** Вызов функции `request_stop` не оказывает никакого действия на единицу выполнения, обработчик не вызывается.

Посмотрим, что случится, если дождаться завершения потоков `thr1` и `thr2` до того, как посылать сигнал останова. Для этого нужно строки `thr1.join();` и `thr2.join();` поставить перед строкой `stopSource.request_stop();`, как показано ниже.

**Отправка сигнала после завершения потоков**
```c++
thr1.join();
thr2.join();

stopSource.request_stop();
if (stopToken.stop_requested())
	std::cout << “main: Stop requested\n”;
```

Такая перестановка строк приводит к тому, что теперь лишь главный поток реагирует на сигнал.

![[ParallelProg_73.png]]

## Особенности класса std::jthread

см. [[thread#Особенности класса std jthread|Особенности класса std::jthread]]

## Новые перегрузки функции wait в классе std::condition_variable_any

см. [[variable conditions#Новые перегрузки функции wait в классе std condition_variable_any|Новые перегрузки функции wait в классе std::condition_variable_any]]


