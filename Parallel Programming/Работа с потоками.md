
[[#Работа с потоками|Работа с потоками]] 11.2
1. [[#Общие вопросы многопоточного программирования|Общие вопросы многопоточного программирования]] 11.2.1
	1. [[#Создание как можно меньшего числа потоков|Создание как можно меньшего числа потоков]] 11.2.1.1
		1. [[#Затраты памяти|Затраты памяти]] 11.2.1.1.1
		2. [[#Затраты на создание потока|Затраты на создание потока]] 11.2.1.1.2
		3. [[#Система Linux|Система Linux]] 11.2.1.1.3
		4. [[#Система Windows|Система Windows]] 11.2.1.1.4
	2. [[#Использование заданий вместо потоков|Использование заданий вместо потоков]] 11.2.1.2
	3. [[#Особая осторожность при отсоединении потока|Особая осторожность при отсоединении потока]] 11.2.1.3
	4. [[#Предпочтительность потоков с автоматическим присоединением|Предпочтительность потоков с автоматическим присоединением]] 11.2.1.4
2. [[#Управление доступом к данным|Управление доступом к данным]] 11.2.2
	1. [[#Передача данных по значению|Передача данных по значению]] 11.2.2.1
	2. [[#Использование умного указателя для совместного владения данными|Использование умного указателя для совместного владения данными]] 11.2.2.2
	3. [[#Сокращение времени блокировки|Сокращение времени блокировки]] 11.2.2.3
	4. [[#Обёртывание мьютекса в блокировщик|Обёртывание мьютекса в блокировщик]] 11.2.2.4
	5. [[#Предпочтительный захват одного мьютекса|Предпочтительный захват одного мьютекса]] 11.2.2.5
	6. [[#Необходимость давать блокировщикам имена|Необходимость давать блокировщикам имена]] 11.2.2.6
	7. [[#Атомарный захват нескольких мьютексов|Атомарный захват нескольких мьютексов]] 11.2.2.7

# Работа с потоками

## Общие вопросы многопоточного программирования

Напомним, что потоки – это основные блоки, из которых строятся параллельные программы.

### Создание как можно меньшего числа потоков

Сколь дорого обходится создание потока? Весьма дорого! Именно с этим связано данное эмпирическое правило. Рассмотрим сначала типичные затраты памяти, а затем затраты на процедуру создания потока.

#### Затраты памяти

Объект типа [[thread#std thread|std::thread]] представляет собой тонкую обёртку вокруг потока, находящегося под управлением операционной системы. Поэтому нужно выяснить, сколько памяти занимают потоки в ОС Windows и ОС семейства `Posix`:
* для системы Windows, по заявлению её разработчиков, стек потока занимает 1 мегабайт;
* для систем семейства POSIX, согласно странице руководства `pthread_create`, стек потока имеет размер 2 мегабайта на архитектурах i386 и x86_64. Данные для различных архитектур приведены в следующей таблице.

| **Архитектура** | **Размер стека по умолчинию, Мб** |
| --------------- | --------------------------------- |
| i386            | 2                                 |
| IA-64           | 32                                |
| PowerPC         | 4                                 |
| S/390           | 2                                 |
| Sparc-32        | 2                                 |
| Sparc-64        | 4                                 |
| x86_64          | 2                                 |

#### Затраты на создание потока

Автору не удалось найти в источниках данные о том, сколько времени занимает создание нового потока. Чтобы получить приблизительное представление об этом, понадобилось самостоятельно создать тестовую программу и измерить её производительность в системах Linux и Windows.

Для замера производительности использовался компилятор GCC 6.2.1 на настольной системе и `cl.exe`, входящий в состав среды Microsoft Visual Studio 2017, на переносном компьютере. В обоих случаях программа компилировалась с максимальным уровнем оптимизации: с флагом `O3` в системе Linux и с флагом `Ox` в системе Windows. Исходный текст этой программы показан ниже.

**Программа для измерения скорости создания потоков:**
```c++
// threadCreationPerformance.cpp

#include <chrono>
#include <iostream>
#include <thread>

static const long long numThreads= 1’000’000;

int main(){
	auto start = std::chrono::system_clock::now();

	for (volatile int i = 0; i < numThreads; ++i) 
		std::thread([]{}).detach();

	std::chrono::duration<double> dur =
		std::chrono::system_clock::now() – start;

	std::cout << “time: “ << dur.count() << “ seconds” << std::endl;
}
```

Эта программа создаёт один миллион потоков, в каждом из которых выполняется пустая лямбда-функция, и измеряет понадобившееся для этого суммарное время. В следующих подразделах представлены результаты её работы в двух операционных системах.

#### Система Linux

На следующем рисунке показан результат нескольких запусков тестовой программы.

![[ParallelProg_229.png]]

Из этих данных следует, что в среднем на создание одного потока в системе Linux на данном компьютере тратится около 14,5 микросекунды.

#### Система Windows

Результат нескольких запусков программы показан на следующем рисунке.

![[ParallelProg_230.png]]

Таким образом, в среднем создание каждого потока в системе Windows на данном компьютере обошлось в 44 микросекунды.

Если посмотреть на полученные показатели производительности с противоположной стороны, получим, что за одну секунду на этом компьютере можно создать около 69 тысяч потоков в системе Linux и лишь 23 тысячи – в системе Windows.

### Использование заданий вместо потоков

Рассмотрим следующую программу, в которой одно и то же вычисление выполняется двумя разными способами: в отдельном потоке и в асинхронном задании.

**Сравнение асинхронных заданий с потоками:**
```c++
// asyncVersusThread.cpp

#include <future>
#include <thread>
#include <iostream>

int main(){
	std::cout << std::endl;

	int res;
	std::thread t([&]{ res = 2000 + 11; });
	t.join();

	std::cout << “res: “ << res << std::endl;

	auto fut= std::async([]{ return 2000 + 11; });

	std::cout << “fut.get(): “ << fut.get() << std::endl;
	std::cout << std::endl;
}
```

На примере этой программы можно увидеть несколько причин отдавать предпочтение заданиям, а не потокам. Так, в случае потоков необходим общий доступ к переменной и синхронизация такого доступа. Асинхронные задания, напротив, предоставляют удобный и безопасный канал для передачи результата наружу вычислений, будь то вычисленное значение, оповещение или исключение.

Если использовать [[Расширенные фьючерсы#Расширенные фьючерсы|расширенные фьючерсы]], появляется возможность компоновать фьючерсы между собой, получая таким образом сложные схемы обработки данных. Для этого в первую очередь предназначено продолжение `then` и различные комбинации условий `when_all` и `when_any`.

### Особая осторожность при отсоединении потока

Следующий небольшой фрагмент года должен приковать к себе внимание программиста:

```c++
std::string s{“C++11”}

std::thread t([&s]{ std::cout << s << ‘\n’; });
t.detach();
```

Поток `t` отсоединяется от кода, который его создаёт. При этом могут возникнуть два разных состояния гонки.
3. Время жизни потока `t` может превысить время выполнения блока, в котором он создаётся. В этом случае поток продолжит пользоваться ссылкой на объект `s`, уже прекративший своё существование.
4. Программа может начать своё завершение до того, как поток `t` выполнит свою работу. Это может привести к уничтожению глобального объекта [[cout#std cout|std::cout]], время жизни которого ограничено временем выполнения главного потока программы, в то время как поток `t` всё ещё пытается его использовать.

### Предпочтительность потоков с автоматическим присоединением

Говорят, что поток `t` находится в присоединяемом состоянии, если вызываемый объект в нём присутствует и если не происходили вызовы `t.join()` или `t.detach()`. Деструктор потока, находящегося в присоединяемом состоянии, аварийно завершает программу вызовом функции [[terminate|std::terminate]]. Чтобы не упустить необходимость присоединения потока, можно создать класс-обёртку над классом [[thread#std thread|std::thread]]. Эта обёртка должна проверять, находится ли поток по-прежнему в присоединяемом состоянии, и, если это так, в своём деструкторе дожидаться его завершения с помощью функции `join`.

Программисту нет нужды создавать такую обёртку самостоятельно. Можно воспользоваться готовым классом [[thread#std scoped_thread|scoped_thread]] Энтони Вильямса или классом `gsl::joining_thread` из библиотеки `guideline support library` (https://github.com/Microsoft/GSL. 
#https_github_com_Microsoft_GSL

## Управление доступом к данным

Все трудности многопоточного программирования начинаются там, где появляется совместный доступ к изменяемым данным.

### Передача данных по значению

Рассмотрим следующий код:
```c++
std::string s{“C++11”}

std::thread t1([s]{ ... }); // действия над s
t1.join();

std::thread t2([&s]{ ... }); // действия над s
t2.join();

// действия над s
```

В поток `t1` строка передаётся путём копирования, поэтому поток-создатель и созданный им поток `t1` никак не связаны по данным. Ситуация оказывается иной для потока `t2`. Он получает ссылку на объект `s`. Это означает, что доступ к нему из главного потока и из потока `t2` необходимо синхронизировать. Это чревато ошибками и наносит урон производительности программы.

### Использование умного указателя для совместного владения данными

Пусть имеется объект, к которому нужен доступ из нескольких потоков. Один из важнейших вопросов в этом случае – какой из потоков должен считаться владельцем объекта и, следовательно, отвечает за его уничтожение. Без ответа на него пришлось бы выбирать между утечкой памяти – в случае если занимаемую объектом память не освободит ни один поток – и неопределённым поведением – если потоки пытаются удалить объект более одного раза. Неопределённое поведение чаще всего приводит к краху программы. Следующая программа иллюстрирует этот неразрешимый вопрос.

**Неопределённое владение объектом:**
```c++
// threadSharesOwnership.cpp

#include <iostream>
#include <thread>

using namespace std::literals::chrono_literals;

struct MyInt {
	int val{2017};
	~MyInt() {
		std::cout << “Good Bye” << std::endl;
	}
};

void showNumber(MyInt* myInt) {
	std::cout << myInt->val << std::endl;
}

void threadCreator() {
	MyInt* tmpInt= new MyInt;

	std::thread t1(showNumber, tmpInt);
	std::thread t2(showNumber, tmpInt);

	t1.detach();
	t2.detach();
}

int main() {
	std::cout << std::endl;

	threadCreator();
	std::this_thread::sleep_for(1s);

	std::cout << std::endl;
}
```

Этот пример намеренно сделан предельно простым. Главный поток засыпает на одну секунду, чтобы дать потокам `t1` и `t2` время завершиться. Конечно же, такой механизм синхронизации никак нельзя назвать приемлемым для разработки реальных программ, но для задач данного раздела он подходит. Ключевой вопрос теперь звучит так: какой поток должен удалить объект `tmpInt`? В этом примере возможных вариантов три: это может быть поток `t1`, `t2` или главный поток. Однако, поскольку невозможно предсказать продолжительность работы каждого потока, пришлось смириться с утечкой памяти. Поэтому деструктор объекта никогда не вызывается, в чём легко убедиться, запустив программу.

![[ParallelProg_231.png]]

Управление временем жизни объекта становится довольно лёгкой задачей, если воспользоваться умным указателем [[shared_ptr|std::shared_ptr]]. Ниже приведён текст реализации.

**Управление временем жизни объекта через умный указатель:**
```c++
// threadSharesOwnershipSharedPtr.cpp

#include <iostream>
#include <memory>
#include <thread>

using namespace std::literals::chrono_literals;

struct MyInt{
	int val{2017};
	~MyInt() {
		std::cout << “Good Bye” << ‘\n’;
	}
};

void showNumber(std::shared_ptr<MyInt> myInt) {
	std::cout << myInt->val << ‘\n’;
}

void threadCreator() {
	auto sharedPtr = std::make_shared<MyInt>();

	std::thread t1(showNumber, sharedPtr);
	std::thread t2(showNumber, sharedPtr);

	t1.detach();
	t2.detach();
}

int main(){
	std::cout << ‘\n’;

	threadCreator();

	std::this_thread::sleep_for(1s);
	
	std::cout << ‘\n’;
}
```

Эта программа отличается от предыдущей двумя важными деталями. Во-первых, вместо встроенного в язык типа указателя `MyInt*` в строке `auto sharedPtr = std::make_shared<MyInt>();` теперь используется библиотечный тип-обёртка [[shared_ptr|std::shared_ptr]]. Во-вторых, соответственно изменён тип функции `showNumber` (строка `void showNumber(std::shared_ptr<MyInt> myInt)`) – теперь она принимает аргумент типа умного указателя. Результат работы программы показан на рисунке. Из него видно, что деструктор для объекта вызывается – утечки памяти не происходит.

![[ParallelProg_232.png]]

### Сокращение времени блокировки

Пока какой-либо поток удерживает блокировку, никакой другой поток не может войти в критическую секцию, защищённую тем же мьютексом, и продолжить свою работу. Рассмотрим пример.
```c++
void setDataReadyBad(){
	std::lock_guard<std::mutex> lck(mutex_);
	mySharedWork = {1, 0, 3};
	dataReady = true;
	std::cout << “Data prepared” << ‘\n’;
	condVar.notify_one();
} // разблокировка

void setDataReadyGood(){
	mySharedWork = {1, 0, 3};
	{
		std::lock_guard<std::mutex> lck(mutex_);
		dataReady = true;
	} // разблокировка
	
	std::cout << “Data prepared” << ‘\n’;
	condVar.notify_one();
}
```

Функции `setDataReadyBad` и `setDataReadyGood` разными способами делают одно и то же – оповещают переменную условия о готовности некоторых данных. Переменная `dataReady` нужна для предотвращения [[variable conditions#Утерянные и ложные пробуждения|ложных и потерянных пробуждений]]. Поскольку эта переменная имеет неатомарный тип, доступ к ней необходимо синхронизировать – для этого используется блокировщик `lck`. Для того чтобы удерживать блокировку как можно меньшее время, в функции `setDataReadyGood` сделан внутренний блок, при выходе из которого блокировка снимается, и остальные действия, не связанные с переменной `dataReady`, выполняются уже за пределами блокировки.

### Обёртывание мьютекса в блокировщик

Не следует использовать мьютекс сам по себе, без обёртывания его в объект-блокировщик. Рассмотрим фрагмент кода.

```c++
std::mutex m;
m.lock();
// критическая секция
m.unlock();
```

Что-то неожиданное может произойти в критической секции или программист забудет вставить в конце вызов функции `unlock` – итог один. Мьютекс останется запертым, и другие потоки будут заблокированы, что может привести к мёртвой блокировке всей системы.

Благодаря блокировщикам, которые автоматизируют управление мьютексом, риск попадания в мёртвую блокировку значительно уменьшается. В соответствии с идиомой RAII блокировщик захватывает мьютекс в конструкторе и освобождает в деструкторе. Тогда показанный выше фрагмент кода принимает следующий вид.

```c++
std::mutex m;
...

{
	std::lock_guard<std::mutex> lockGuard(m);
	// критическая секция
} // освободить мьютекс
```

Дополнительный блок, ограниченный фигурными скобками, гарантирует автоматическое уничтожение локального объекта и, следовательно, освобождение мьютекса.

### Предпочтительный захват одного мьютекса

Логику программы следует продумывать таким образом, чтобы всякий раз требовался захват лишь одного мьютекса. Хотя, конечно, на практике бывают задачи, требующие одновременного захвата нескольких мьютексов, в этом случае заметно возрастает риск мёртвых блокировок, о чём пойдёт речь в одном из следующих разделов.

### Необходимость давать блокировщикам имена

Если объявить безымянный объект-блокировщик (например, типа [[lock#Тип std lock_guard|std::lock_guard]]), как в следующем примере, он уничтожится немедленно после создания:
```c++
std::mutex m;
...
{
	std::lock_guard<std::mutex>{m};
	// критическая секция
}
```

На первый взгляд, этот код выглядит вполне невинно, однако блокировщик уничтожается сразу после создания. Следовательно, критическая секция выполняется далее без всякой синхронизации. Напомним, что привязка времени жизни объекта к блоку кода, ограниченному фигурными скобками, составляет общепринятый приём программирования на языке C++, известный как идиома RAII. В частности, блокировщик должен захватывать мьютекс в конструкторе и освобождать в деструкторе. Следующий развёрнутый пример иллюстрирует странное поведение идиомы RAII, если объекту-обёртке не дать имени.

**Ошибочная реализация идиомы RAII с безымянным блокировщиком:**
```c++
// myGuard.cpp

#include <mutex>
#include <iostream>

template <typename T>
class MyGuard {
		T& myMutex;
	
	public:
		MyGuard(T& m):myMutex(m) {
			myMutex.lock();
			std::cout << “lock” << std::endl;
		}

		~MyGuard() {
			myMutex.unlock();
			std::cout << “unlock” << std::endl;
		}
};

int main() {
	std::cout << std::endl;

	std::mutex m;
	MyGuard<std::mutex> {m};                           // (1)
	std::cout << “CRITICAL SECTION” << std::endl;      // (2)

	std::cout << std::endl;
}                                                      // (3)
```

Конструктор и деструктор класса `MyGuard` вызывают функции `lock` и `unlock` мьютекса. Однако, поскольку объекту этого класса не дано имя, этот объект – временный, и его деструктор вызывается сразу после конструктора, в строке `MyGuard<std::mutex> {m};`, а не при выходе из блока. Следовательно, критическая секция в строке `std::cout << “CRITICAL SECTION” << std::endl;` выполняется без синхронизации. Запустив программу, можно убедиться, что разблокировка мьютекса происходит раньше, чем начинает выполняться критическая секция.

![[ParallelProg_233.png]]

### Атомарный захват нескольких мьютексов

Если потоку необходимо захватить более одного мьютекса, программисту нужно соблюдать крайнюю осторожность, чтобы во всех местах они захватывались в одном и том же порядке. В противном случае неудачное стечение обстоятельств при перемежающемся выполнении потоков может спровоцировать мёртвую блокировку. Рассмотрим пример.
































