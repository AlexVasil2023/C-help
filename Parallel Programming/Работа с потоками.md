
[[#Работа с потоками|Работа с потоками]] 11.2
1. [[#Общие вопросы многопоточного программирования|Общие вопросы многопоточного программирования]] 11.2.1
	1. [[#Создание как можно меньшего числа потоков|Создание как можно меньшего числа потоков]] 11.2.1.1
		1. [[#Затраты памяти|Затраты памяти]] 11.2.1.1.1
		2. [[#Затраты на создание потока|Затраты на создание потока]] 11.2.1.1.2
		3. [[#Система Linux|Система Linux]] 11.2.1.1.3
		4. [[#Система Windows|Система Windows]] 11.2.1.1.4
	2. [[#Использование заданий вместо потоков|Использование заданий вместо потоков]] 11.2.1.2
	3. [[#Особая осторожность при отсоединении потока|Особая осторожность при отсоединении потока]] 11.2.1.3
	4. [[#Предпочтительность потоков с автоматическим присоединением|Предпочтительность потоков с автоматическим присоединением]] 11.2.1.4
2. [[#Управление доступом к данным|Управление доступом к данным]] 11.2.2
	1. [[#Передача данных по значению|Передача данных по значению]] 11.2.2.1

# Работа с потоками

## Общие вопросы многопоточного программирования

Напомним, что потоки – это основные блоки, из которых строятся параллельные программы.

### Создание как можно меньшего числа потоков

Сколь дорого обходится создание потока? Весьма дорого! Именно с этим связано данное эмпирическое правило. Рассмотрим сначала типичные затраты памяти, а затем затраты на процедуру создания потока.

#### Затраты памяти

Объект типа [[thread#std thread|std::thread]] представляет собой тонкую обёртку вокруг потока, находящегося под управлением операционной системы. Поэтому нужно выяснить, сколько памяти занимают потоки в ОС Windows и ОС семейства `Posix`:
* для системы Windows, по заявлению её разработчиков, стек потока занимает 1 мегабайт;
* для систем семейства POSIX, согласно странице руководства `pthread_create`, стек потока имеет размер 2 мегабайта на архитектурах i386 и x86_64. Данные для различных архитектур приведены в следующей таблице.

| **Архитектура** | **Размер стека по умолчинию, Мб** |
| --------------- | --------------------------------- |
| i386            | 2                                 |
| IA-64           | 32                                |
| PowerPC         | 4                                 |
| S/390           | 2                                 |
| Sparc-32        | 2                                 |
| Sparc-64        | 4                                 |
| x86_64          | 2                                 |

#### Затраты на создание потока

Автору не удалось найти в источниках данные о том, сколько времени занимает создание нового потока. Чтобы получить приблизительное представление об этом, понадобилось самостоятельно создать тестовую программу и измерить её производительность в системах Linux и Windows.

Для замера производительности использовался компилятор GCC 6.2.1 на настольной системе и `cl.exe`, входящий в состав среды Microsoft Visual Studio 2017, на переносном компьютере. В обоих случаях программа компилировалась с максимальным уровнем оптимизации: с флагом `O3` в системе Linux и с флагом `Ox` в системе Windows. Исходный текст этой программы показан ниже.

**Программа для измерения скорости создания потоков:**
```c++
// threadCreationPerformance.cpp

#include <chrono>
#include <iostream>
#include <thread>

static const long long numThreads= 1’000’000;

int main(){
	auto start = std::chrono::system_clock::now();

	for (volatile int i = 0; i < numThreads; ++i) 
		std::thread([]{}).detach();

	std::chrono::duration<double> dur =
		std::chrono::system_clock::now() – start;

	std::cout << “time: “ << dur.count() << “ seconds” << std::endl;
}
```

Эта программа создаёт один миллион потоков, в каждом из которых выполняется пустая лямбда-функция, и измеряет понадобившееся для этого суммарное время. В следующих подразделах представлены результаты её работы в двух операционных системах.

#### Система Linux

На следующем рисунке показан результат нескольких запусков тестовой программы.

![[ParallelProg_229.png]]

Из этих данных следует, что в среднем на создание одного потока в системе Linux на данном компьютере тратится около 14,5 микросекунды.

#### Система Windows

Результат нескольких запусков программы показан на следующем рисунке.

![[ParallelProg_230.png]]

Таким образом, в среднем создание каждого потока в системе Windows на данном компьютере обошлось в 44 микросекунды.

Если посмотреть на полученные показатели производительности с противоположной стороны, получим, что за одну секунду на этом компьютере можно создать около 69 тысяч потоков в системе Linux и лишь 23 тысячи – в системе Windows.

### Использование заданий вместо потоков

Рассмотрим следующую программу, в которой одно и то же вычисление выполняется двумя разными способами: в отдельном потоке и в асинхронном задании.

**Сравнение асинхронных заданий с потоками:**
```c++
// asyncVersusThread.cpp

#include <future>
#include <thread>
#include <iostream>

int main(){
	std::cout << std::endl;

	int res;
	std::thread t([&]{ res = 2000 + 11; });
	t.join();

	std::cout << “res: “ << res << std::endl;

	auto fut= std::async([]{ return 2000 + 11; });

	std::cout << “fut.get(): “ << fut.get() << std::endl;
	std::cout << std::endl;
}
```

На примере этой программы можно увидеть несколько причин отдавать предпочтение заданиям, а не потокам. Так, в случае потоков необходим общий доступ к переменной и синхронизация такого доступа. Асинхронные задания, напротив, предоставляют удобный и безопасный канал для передачи результата наружу вычислений, будь то вычисленное значение, оповещение или исключение.

Если использовать [[Расширенные фьючерсы#Расширенные фьючерсы|расширенные фьючерсы]], появляется возможность компоновать фьючерсы между собой, получая таким образом сложные схемы обработки данных. Для этого в первую очередь предназначено продолжение `then` и различные комбинации условий `when_all` и `when_any`.

### Особая осторожность при отсоединении потока

Следующий небольшой фрагмент года должен приковать к себе внимание программиста:

```c++
std::string s{“C++11”}

std::thread t([&s]{ std::cout << s << ‘\n’; });
t.detach();
```

Поток `t` отсоединяется от кода, который его создаёт. При этом могут возникнуть два разных состояния гонки.
3. Время жизни потока `t` может превысить время выполнения блока, в котором он создаётся. В этом случае поток продолжит пользоваться ссылкой на объект `s`, уже прекративший своё существование.
4. Программа может начать своё завершение до того, как поток `t` выполнит свою работу. Это может привести к уничтожению глобального объекта [[cout#std cout|std::cout]], время жизни которого ограничено временем выполнения главного потока программы, в то время как поток `t` всё ещё пытается его использовать.

### Предпочтительность потоков с автоматическим присоединением

Говорят, что поток `t` находится в присоединяемом состоянии, если вызываемый объект в нём присутствует и если не происходили вызовы `t.join()` или `t.detach()`. Деструктор потока, находящегося в присоединяемом состоянии, аварийно завершает программу вызовом функции [[terminate|std::terminate]]. Чтобы не упустить необходимость присоединения потока, можно создать класс-обёртку над классом [[thread#std thread|std::thread]]. Эта обёртка должна проверять, находится ли поток по-прежнему в присоединяемом состоянии, и, если это так, в своём деструкторе дожидаться его завершения с помощью функции `join`.

Программисту нет нужды создавать такую обёртку самостоятельно. Можно воспользоваться готовым классом [[thread#std scoped_thread|scoped_thread]] Энтони Вильямса или классом `gsl::joining_thread` из библиотеки `guideline support library` (https://github.com/Microsoft/GSL. 
#https_github_com_Microsoft_GSL

## Управление доступом к данным

Все трудности многопоточного программирования начинаются там, где появляется совместный доступ к изменяемым данным.

### Передача данных по значению


























