[[#Управление потоками]]
1. [[thread#Базовые потоки класс std thread|Базовые потоки: класс std::thread]] 3.1
	1. [[thread#Создание потока|Создание потока]] 3.1.1
	2. [[thread#Время жизни потоков|Время жизни потоков]] 3.1.2
		1. [[thread#Функции join и detach|Функции join и detach]] 3.1.2.1
	3. [[thread#Передача аргументов при создании потока|Передача аргументов при создании потока]] 3.1.3
		1. [[thread#Передача по значению и по ссылке|Передача по значению и по ссылке]] 3.1.3.1
	4. [[thread#Перечень функций-членов|Перечень функций-членов]] 3.1.4
2. [[thread#std jthread|Усовершенствованные потоки: класс std::jthread (стандарт С++ 20)]] 3.2
	1. [[thread#Автоматическое присоединение к потоку|Автоматическое присоединение к потоку]] 3.2.1
	2. [[thread#Прерывание по запросу в классе std jthread|Прерывание по запросу в классе std::jthread]] 3.2.2
3. [[#Данные в совместном доступе|Данные в совместном доступе]] 3.3
	1. [[mutex#std mutex|Мьютексы]] 3.3.1
		1. [[mutex#Затруднения с мьютексами|Затруднения с мьютексами]] 3.3.1.1
		2. [[mutex#Исключения и неизвестный код|Исключения и неизвестный код]] 3.3.1.2
		3. [[mutex#Захват мьютексов в различном порядке|Захват мьютексов в различном порядке]] 3.3.1.3
	2. [[lock#Блокировщики|Блокировщики]] 3.3.2
		1. [[lock#Тип std lock_guard|Тип std::lock_guard]] 3.3.2.1
		2. [[lock#Тип std scoped_lock|Тип std::scoped_lock]] 3.3.2.2
		3. [[lock#Тип std unique_lock|Тип std::unique_lock]] 3.3.2.3
		4. [[lock#Блокировщик std shared_lock|Блокировщик std::shared_lock]] 3.3.2.4
			1. [[lock#Как побороть неопределённое поведение|Как побороть неопределённое поведение]] 3.3.2.4.1
	3. [[lock#Функция std lock|Функция std::lock]] 3.3.3
	4. [[Thread_Safe initialization#Потокобезопасная инициализация|Потокобезопасная инициализация]] 3.3.4
		1. [[Thread_Safe initialization#Константные выражения|Константные выражения]] 3.3.4.1
		2. [[Thread_Safe initialization#Функция std call_once и флаг std once_flag|Функция std::call_once и флаг std::once_flag]] 3.3.4.2
		3. [[Thread_Safe initialization#Локальные статические переменные|Локальные статические переменные]] 3.3.4.3
4. [[#Данные с потоковой длительностью хранения|Данные с потоковой длительностью хранения]] 3.4
	1. [[ThreadLocal#Данные с потоковой длительностью хранения|Данные с потоковой длительностью хранения]]
5. [[#Переменные условия|Переменные условия]] 3.5
	1. [[variable conditions#Переменные условия|Переменные условия]]
	2. [[variable conditions#Использование предиката в функции ожидания|Использование предиката в функции ожидания]] 3.5.1
	3. [[variable conditions#Утерянные и ложные пробуждения|Утерянные и ложные пробуждения]] 3.5.2
	4. [[variable conditions#Процедура ожидания|Процедура ожидания]] 3.5.3
	5. [[variable conditions#Новые перегрузки функции wait в классе std condition_variable_any|Новые перегрузки функции wait в классе std::condition_variable_any]] 3.6.6
6. [[#Кооперативное прерывание потоков|Кооперативное прерывание потоков]] 3.6
	1. [[Кооперативное прерывание потоков#Кооперативное прерывание потоков|Кооперативное прерывание потоков]]
	2. [[Кооперативное прерывание потоков#Класс std stop_source|Класс std::stop_source]] 3.6.1
	3. [[Кооперативное прерывание потоков#Класс std stop_token|Класс std::stop_token]] 3.6.2
	4. [[Кооперативное прерывание потоков#Класс std stop_callback|Класс std::stop_callback]] 3.6.3
	5. [[Кооперативное прерывание потоков#Общий механизм посылки сигналов|Общий механизм посылки сигналов]] 3.6.4
	6. [[thread#Особенности класса std jthread|Особенности класса std::jthread]] 3.6.5
	7. [[variable conditions#Новые перегрузки функции wait в классе std condition_variable_any|Новые перегрузки функции wait в классе std::condition_variable_any]] 3.6.6
7. [[#Семафоры (стандарт C++ 20)|Семафоры (стандарт C++ 20)]] 3.7
	1. [[semaphore#Семафоры (стандарт C++ 20)|Семафоры (стандарт C++ 20)]]
8. [[#Защёлки и барьеры (стандарт C++20)|Защёлки и барьеры (стандарт C++20)]] 
	1. [[Latch_and_Barrier#Защёлки и барьеры (стандарт C++20)|Защёлки и барьеры (стандарт C++20)]] 3.8
	2. [[Latch_and_Barrier#Класс std latch|Класс std::latch]] 3.8.1
	3. [[Latch_and_Barrier#Класс std barrier|Класс std::barrier]] 3.8.2
9. [[#Асинхронные задания|Асинхронные задания]] 3.9
	1. [[asyncVersus#Асинхронные задания|Асинхронные задания]] 3.9
	2. [[asyncVersus#Отличие заданий от потоков|Отличие заданий от потоков]] 3.9.1
	3. [[async#std async|Функция std::async]] 3.9.2
		1. [[async#Политика запуска|Политика запуска]] 3.9.2.1
		2. [[async#Запустить и забыть|Запустить и забыть]] 3.9.2.2
		3. [[async#Параллельное вычисление скалярного произведения|Параллельное вычисление скалярного произведения]] 3.9.2.3
	4. [[packaged_task#std packaged_task|Тип std::packaged_task]] 3.9.3
	5. [[Promise and Future#Типы std promise и std future|Типы std::promise и std::future]] 3.9.4
		1. [[promise#std promise|Тип std::promise]] 3.9.4.1
		2. [[future#std future|Тип std::future]] 3.9.4.2
			1. [[future#Состояние фьючерса|Состояние фьючерса]] 3.9.4.2.1
	6. [[future#std shared_future|Тип std::shared_future]] 3.9.5
	7. [[Error_in_Assinc_task|Обработка исключений в асинхронных заданиях]] 3.9.6
	8. [[Notify#Оповещения|Оповещения]] 3.9.7
10. [[#Синхронизированные потоки вывода (стандарт С++ 20)|Синхронизированные потоки вывода (стандарт С++ 20)]] 3.10
	1. [[basic_syncbuf#Синхронизированные потоки вывода (стандарт С++ 20)|Синхронизированные потоки вывода (стандарт С++ 20)]] 3.10


# Управление потоками

Язык C++ обладает интерфейсом управления потоками начиная со стандарта C++11, и этот интерфейс содержит всё необходимое для создания многопоточных программ. В нём есть собственно потоки, примитивы синхронизации для доступа к общим данным – [[mutex|мьютексы]] и блокировщики, локальные данные потоков, более сложные средства синхронизации потоков, такие как переменные условия, а также [[task|задания]]. [[task|Задания]], также называемые обещаниями и [[future|фьючерсами]], составляют более высокий уровень абстракции по сравнению с собственно потоками.

![[ParallelProg_48.png]]

Библиотека языка C++ поддерживает два вида потоков: базовые потоки типа [[thread#std thread|std::thread]] (стандарт C++ 11) и усовершенствованные потоки типа [[thread#std jthread|std::jthread]] (стандарт C++ 20). 

# Данные в совместном доступе

Нужно чётко понимать, что усилия по синхронизации нужны только тогда, когда имеются изменяемые данные, доступные нескольким потокам, поскольку именно в этом случае становится возможной гонка данных. Если в программе происходят одновременные несинхронизированные операции чтения и записи данных, программа в целом обладает неопределённым поведением.

Самый простой способ воочию увидеть результат одновременных несинхронизированных модификаций общего объекта – это из нескольких потоков отправлять текст в поток вывода `std::cout`.

**Несинхронизированный вывод в поток `std::cout`:**
```c++
// coutUnsynchronised.cpp

#include <chrono>
#include <iostream>
#include <thread>

class Worker{
	public:
		Worker(std::string n):name(n){};

		void operator() (){
			for (int i = 1; i <= 3; ++i){
				// begin work
				std::this_thread::sleep_for(
									std::chrono::milliseconds(200));
				// end work
				
				std::cout << name << “: “ << “Work “ << i 
										<< “ done !!!” << std::endl;
			}
		}
		
	private:
		std::string name;
};

int main(){
	std::cout << std::endl;
	std::cout << “Boss: Let’s start working.\n\n”;

	std::thread herb= std::thread(Worker(“Herb”));
	std::thread andrei= std::thread(Worker(“ Andrei”));
	std::thread scott= std::thread(Worker(“Scott”));
	std::thread bjarne= std::thread(Worker(“Bjarne”));
	std::thread bart= std::thread(Worker(“Bart”));
	std::thread jenne= std::thread(Worker(“Jenne”));
	
	herb.join();
	andrei.join();
	scott.join();
	bjarne.join();
	bart.join();
	jenne.join();
	
	std::cout << “\n” << “Boss: Let’s go home.” << std::endl;
	std::cout << std::endl;
}
```

Эта программа моделирует рабочий процесс. У начальника есть шесть работников (строки `std::thread herb= std::thread(Worker(“Herb”));` – `std::thread jenne= std::thread(Worker(“Jenne”));`). Каждому работнику нужно выполнить три задания. Каждое задание занимает 1/5 секунды (строка `std::this_thread::sleep_for(std::chrono::milliseconds(200))`). Закончив задание, работник громко сообщает об этом начальнику (строка `std::cout << name << “: “ << “Work “ << i << “ done !!!” << std::endl`). Когда начальник
получит отчёт от всех работников, он отпускает всех по домам (строка `std::cout << “\n” << “Boss: Let’s go home.” << std::endl`).

Сколько же путаницы возникает в столь простой организации!
![[ParallelProg_57.png]]

Самое очевидное решение – воспользоваться [[mutex|мьютексом]].

# Данные с потоковой длительностью хранения

см. [[ThreadLocal#Данные с потоковой длительностью хранения|Данные с потоковой длительностью хранения]]

# Переменные условия

см. [[variable conditions#Переменные условия|Переменные условия]]

# Кооперативное прерывание потоков

см. [[Кооперативное прерывание потоков#Кооперативное прерывание потоков|Кооперативное прерывание потоков]]

# Семафоры (стандарт C++ 20)

см. [[semaphore#Семафоры (стандарт C++ 20)|Семафоры (стандарт C++ 20)]] 

# Защёлки и барьеры (стандарт C++20)

см. [[Latch_and_Barrier#Защёлки и барьеры (стандарт C++20)|Защёлки и барьеры (стандарт C++20)]] 

# Асинхронные задания

см. [[asyncVersus#Асинхронные задания|Асинхронные задания]]

# Синхронизированные потоки вывода (стандарт С++ 20)

см. [[basic_syncbuf#Синхронизированные потоки вывода (стандарт С++ 20)|Синхронизированные потоки вывода (стандарт С++ 20)]]


