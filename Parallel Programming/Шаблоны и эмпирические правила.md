
[[#Шаблоны и эмпирические правила|Шаблоны и эмпирические правила]] 8
1. [[#История понятия|История понятия]] 8.1
2. [[#Неоценимая польза шаблонов|Неоценимая польза шаблонов]] 8.2
3. [[#Шаблоны или эмпирические правила|Шаблоны или эмпирические правила]] 8.3
4. [[#Антишаблоны|Антишаблоны]] 8.4

# Шаблоны и эмпирические правила

Задача этой главы – дать читателю представление о том, что такое шаблоны проектирования и для чего они бывают полезны. Данная тема будет рассматриваться неформально и главным образом через призму языка C++. Более строгое изложение можно найти в литературе по ссылкам.

Ответим сначала на главный вопрос: что такое шаблон?

«Шаблон проектирования представляет собой трёхстороннее привило, выражающее отношение между определённым контекстом, проблемой и решением», как писал Кристофер Александер.

Если говорить менее формально, шаблон – это устоявшееся и хорошо описанное решение типовой инженерной задачи в определённой области.

## История понятия

Отцом шаблонов проектирования считается процитированный выше Кристофер Александер, чьи шаблоны дружественного к человеку градостроительства, проектирования зданий и дизайна интерьеров нашли продолжение в сфере разработки программ. В 1994 году вышла знаменитая книга «Приемы объектно-ориентированного проектирования. Паттерны проектирования» коллектива авторов, известного как «Банда четырёх» (Эрик Гамма, Ричард Хелм, Ральф Джонсон и Джон Влиссидес). В этой книге описаны 23 шаблона объектно-ориентированной разработки программ. Эти шаблоны разбиты на три категории: порождающие, структурные шаблоны и шаблоны поведения. Тем самым вводится единый словарь для индустрии программного обеспечения. Следующие шаблоны проектирования получили наибольшее распространение.

> Порождающие шаблоны:
>  * фабричный метод;
>  * объект-одиночка.

> Структурные шаблоны:
> * адаптер;
> * мост;
> * композит;
> * декоратор;
> * фасад;
> * прокси.

> Шаблоны поведения:
> * команда;
> * итератор;
> * наблюдатель;
> * стратегия;
> * шаблонный метод;
> * посетитель.

Годом позже Фрэнк Бушман, Регина Мёнье, Ханс Ронерт, Петер Зоммерфельд и Михаэль Шталь опубликовали свою книгу «Шиблонно-ориентированная архитектура программного обеспечения: система шаблонов» (также известную как POSA), оказавшую значительное влияние на всю отрасль. Эта книга положила начало серии из пяти книг. Она вышла в 1995 году и содержала три категории шаблонов: архитектурные шаблоны, шаблоны проектирования и идиомы. Многие из них прочно вошли в обиход:

> архитектурные шаблоны:
> * многослойность;
> * конвейеры и фильтры;
> * брокер;
> * модель-визуализатор-контроллер;
>
> шаблоны проектирования:
> * главный-дублёр;
> * издатель-подписчик;
>
> идиомы:
> * указатель со счётчиком владельцев.

В чём различие между этими тремя категориями? В центре внимания архитектурного шаблона находится вся программная система как целое. Шаблоны этой группы более абстрактны, чем шаблоны проектирования, которые относятся к взаимодействию подсистем. Идиомы, в свою очередь, относятся к воплощению шаблонов в конкретном языке программирования и находятся на самом низком уровне абстракции.

Из книг серии `POSA` со второй по пятую каждая посвящена своей теме. Вторая книга носит заглавие `«Шаблоны параллельных и сетевых объектов»`, третья – `«Шаблоны управления ресурсами»`, четвёртая называется `«Язык шаблонов для распределённых вычислений»` и пятая – `«О шаблонах и языке шаблонов»`.

## Неоценимая польза шаблонов

Появление шаблонов внесло неоценимый вклад в развитие индустрии программного обеспечения в целом. Конечно же, это относится и к параллельному программированию в частности. Повсеместное принятие шаблонов в практику разработки принесло главным образом три следующих преимущества: установление чёткой терминологии, улучшенную документированность разработки и возможность обучения на наилучших примерах.

Вклад шаблонов в развитие терминологии состоит в том, что разработчики получили возможность пользоваться единым недвусмысленным словарём для описания своих идей. Недопонимание между разработчиками по поводу устройства и принципов функционирования программы, как и необходимость в многословных объяснениях, уходит в прошлое. Если разработчик спрашивает совета о том, как семейство подобных по назначению алгоритмов реализовать так, чтобы можно было гибко переключаться между ними во время выполнения, ответ можно дать одной фразой: использовать шаблон «Стратегия». Если разработчик знает, что означает это название, он может сразу приступить к анализу преимуществ и накладных расходов от использования данного шаблона; в противном случае он может обратиться к литературе, чтобы понять полученный совет.

Документированность разработки улучшается двояким образом. Во-первых, если новый разработчик, знакомящийся с системой, узнаёт из текс­туального или графического описания, что в ней присутствует сущность под названием «наблюдатель» (англ. observer), он уже может немало заключить об устройстве и функционировании системы. Скажем, в системе имеются источники событий (`subject`), наблюдатели могут регистрироваться на получение всех или некоторых событий от определённых источников, как и отменять свою регистрацию; источники, в свою очередь, при некоторых условиях рассылают оповещения (англ. `notify`) своим наблюдателям. Во-вторых, можно просто открыть исходный код и отыскать в нём ряд слов, таких как `observer`, `subject`, `notify` в нашем примере.

Шаблоны – это ещё и удобный способ передачи лучшего опыта. С помощью шаблонов начинающий программист учится сразу наилучшим решениям и освобождается от необходимости повторять ошибки, с которыми был сопряжен поиск этих решений. Шаблоны проектирования – это проверенные временем решения типовых задач, а значит, и инструмент борьбы со сложностью. Описание каждого шаблона содержит сведения о том, в каких ситуациях его стоит применять, каковы последствия его применения, а также в каких известных системах он используется.

## Шаблоны или эмпирические правила

Читатель мог заметить, что в заглавии настоящей главы говорится не только о шаблонах, но и об эмпирических правилах разработки. Что общего между этими понятиями и что делает их различными? Следует признать, что вопрос о том, следует тот или иной типовой подход – например, неизменяемость общих данных или чистоту функций – отнести к шаблонам или к эмпирическим правилам, может вызвать интенсивный спор с самим собой. В конечном счёте что такое шаблоны, как не детально описанные эмпирические правила. Из многочисленных споров с собой автор настоящей книги извлёк ряд общих выводов.

> Невозможно с абсолютной чёткостью разграничить эти два понятия.
> 
> Если некоторый подход к решению типовой проблемы детально и строго описан, его стоит отнести к шаблонам.
> 
> Если подход к решению типовой проблемы по форме похож на полезный совет и не структурирован строго, лучше считать его эмпирическим правилом.
> 
> То, что сегодня выглядит эмпирическим правилом, может завтра стать шаблоном.

## Антишаблоны

Если шаблон представляет собой концентрированное выражение положительного опыта разработки программ, то антишаблон – это описание горького урока, или, словами Эндрю Кёнига, «описание плохого решения задачи, повлекшего за собой плохую ситуацию». Например, если внимательно изучить­ старую литературу по параллельному программированию, можно обнаружить «шаблон блокировки с двойной проверкой» (double-checked lock). В нескольких словах: этот шаблон призван оптимизировать потокобезопасную инициализацию общего состояния, в роли которого часто выступает объект-одиночка (`singleton`). Подробный разбор [[Потокобезопасное создание объекта-одиночки#Шаблон «Блокировка с двойной проверкой»|блокировки с двойной проверкой]], не случаен: этим подчёркивается, что непродуманное использование двойной проверки может привести к неопределённому поведению. Проблемы, связанные с двойной проверкой, оказываются в конечном счёте теми же самыми, что и известные проблемы объекта-одиночки.

Программист, раздумывающий об использовании объекта-одиночки в своей программе, должен подумать о следующих связанных с ним трудностях: 

> во-первых и в-главных: одиночка – это глобальное состояние. По этой причине объект-одиночка чаще всего используется напрямую, а не через интерфейс. Как следствие весь код, в котором используется одиночка, получает лишнюю скрытую зависимость;
> 
> одиночка – это статический объект. Единожды созданный, он не может быть уничтожен. Время его жизни ограничено только временем выполнения программы;
> 
> если статический член класса (в частности, класса одиночки) зависит от статического члена иного класса, определённого в другой единице трансляции, нет никаких гарантий относительно порядка, в котором они будут проинициализированы при запуске программы. Вероятность промахнуться с инициализацией составляет 50 %;
> 
> шаблон «одиночка» нередко используют в ситуациях, когда на самом деле вполне можно было бы использовать экземпляр класса. Некоторые разработчики применяют этот шаблон только для того, чтобы доказать своё знание шаблонов.

