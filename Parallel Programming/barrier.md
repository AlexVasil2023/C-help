[[#Барьеры|Барьеры]]
1. [[#Барьер `std atomic_thread_fence`|Барьер std::atomic_thread_fence]] 2.5.1
	1. [[#Что такое барьеры памяти]] 2.5.1.1
	2. [[#Три барьера]] 2.5.1.2
		1. [[#Полный барьер]] 2.5.1.2.1
		2. [[#Барьер захвата]] 2.5.1.2.2
		3. [[#Барьер освобождения]] 2.5.1.2.3
		4. [[#Виды барьеров, вместе взятые|Виды барьеров, вместе взятые]] 2.5.1.2.4
	3. [[#Барьеры захвата и освобождения|Барьеры захвата и освобождения]] 2.5.1.3
		1. [[#Сравнение атомарных операций с барьерами|Сравнение атомарных операций с барьерами]] 2.5.1.3.1
		2. [[#Операции захвата|Операции захвата]] 2.5.1.3.2
		3. [[#Операции освобождения|Операции освобождения]] 2.5.1.3.3
	4. [[#Синхронизация с использованием атомарных переменных и барьеров|Синхронизация с использованием атомарных переменных и барьеров]] 2.5.1.4
		1. [[#Реализация на основе атомарных операций|Реализация на основе атомарных операций]] 2.5.1.4.1
		2. [[#Барьеры памяти|Барьеры памяти]] 2.5.1.4.2
2. [[#Барьер std atomic_signal_fence|Барьер std::atomic_signal_fence]] 2.5.2

# Барьеры

В стандартной библиотеке языка C++ определены два вида барьеров: `std::atomic_thread_fence` и `std::atomic_signal_fence`.

> Барьер `std::atomic_thread_fence` служит для синхронизации доступа к памяти между потоками.
> 
> Барьер `std::atomic_signal_fence` служит для синхронизации между обработчиком сигнала и кодом, выполняющимся в том же потоке.

## Барьер `std::atomic_thread_fence`

Барьер `std::atomic_thread_fence` непроницаем для некоторых операций. Этому барьеру для работы не нужны никакие атомарные переменные. Последние, однако, часто называют барьерами памяти. 

### Что такое барьеры памяти

Что означает фраза «барьер непроницаем для некоторых операций»? Для каких именно операций? Глядя с высоты птичьего полёта, можно сказать, что есть лишь два вида операций: чтение и запись. Выражение `if (resultRead) return result`, например, состоит из операции чтения, за которой следует операция записи. Всего существует четыре способа соединить между собой две операции:

> **LoadLoad**: чтение, затем чтение;
> 
> **LoadStore**: чтение, затем запись;
> 
> **StoreLoad**: запись, затем чтение;
> 
> **StoreStore**: запись, затем запись.

Конечно же, бывают и более сложные операции, состоящие из нескольких чтений и записей (например, операция `count++`), однако после разложения на элементарные операции они вписываются в эту классификацию.

Причём здесь барьеры памяти? Если поставить барьер между двумя операциями, можно гарантировать, что порядок операций в парах `LoadLoad`, `LoadStore`, `StoreLoad` или `StoreStore` останется неизменным. В отсутствие барьера могут быть переупорядочены неатомарные операции или атомарные операции с ослабленной семантикой.

### Три барьера

Обычно используются три вида барьеров. Их называют `полным барьером`, `барьером захвата` и `барьером освобождения`. Напомним, что операция чтения соответствует захвату, а запись – освобождению. Что случится, если поместить один из этих трёх барьеров в каждую из четырёх пар операций?

> **Полный барьер.** Вызов `std::atomic_thread_fence()`, помещённый между двумя произвольными операциями, предотвращает их переупорядочивание с одним исключением: пара `StoreLoad` может быть переупорядочена.
> 
> **Барьер захвата.** Вызов `std::atomic_thread_fence(std::memory_order_acquire)` запрещает операцию чтения, расположенную перед барьером, менять местами с операцией чтения или записи после барьера.
> 
> **Барьер освобождения.** Барьер `std::atomic_thread_fence(std::memory_order_release)` не позволяет операцию записи, расположенную после барьера, менять местами с операцией чтения или записи, расположенной до барьера.

Много сил может уйти на то, чтобы правильно понять определения барьеров захвата и освобождения и значение этих определений для неблокирующего программирования. Особенно трудны для понимания тонкие различия в семантике захвата и освобождения для атомарных операций. Поскольку изложение вплотную подходит к этой точке, стоит пояснить определения графически.

Какие виды операций могут пересекать тот или иной барьер? Посмотрим на следующие три рисунка. Если стрелка перечёркнута красной линией, барьер непроницаем для данного вида операций.

#### Полный барьер

![[ParallelProg_37.png]]

`Store` - Атомарным образом присвоить атомарной переменной новое значение
`Load` - Атомарным образом вернуть текущее значение атомарной переменной

Вместо использования значения по умолчанию, `std::atomic_thread_fence()`, можно, конечно, указать барьер в явном виде: `thread_fence(std::memory_order_seq_cst)`. К барьерам обычно применяются правила последовательной согласованности. Таким образом, барьеры `std::atomic_thread_fence()` выполняются в едином глобальном порядке.

#### Барьер захвата

![[ParallelProg_38.png]]

#### Барьер освобождения

![[ParallelProg_39.png]]

Три вида барьеров можно изобразить ещё более ясно.

#### Виды барьеров, вместе взятые

![[ParallelProg_40.png]]

Барьеры захвата и освобождения дают такие же гарантии синхронизации и упорядочивания доступа, как и атомарные операции с семантикой захвата и освобождения.

### Барьеры захвата и освобождения

Наиболее очевидное различие между барьерами памяти и атомарными операциями состоит в том, что для барьеров не нужны атомарные переменные. Есть и ещё одно тонкое различие: барьеры захвата и освобождения более тяжеловесны, чем соответствующие атомарные операции.

#### Сравнение атомарных операций с барьерами

Для простоты изложения будем называть операциями захвата атомарные операции с семантикой захвата, аналогично для освобождения.

Смысл операций захвата и освобождения состоит в том, что они налагают на потоки ограничения, связанные с синхронизацией и упорядочиванием доступа к памяти. Эти ограничения соблюдаются также для атомарных операций с ослабленной семантикой и для неатомарных операций. Нужно иметь в виду, что операции захвата и освобождения встречаются парами. Кроме того, атомарные операции с семантикой захвата-освобождения должны относиться к одной и той же атомарной переменной. Сделав вводные замечания, можно теперь рассмотреть эти операции по отдельности. Начнём с операций захвата.

#### Операции захвата

Операции чтения над атомарными переменными, выполняемые с параметром `std::memory_order_acquire`, представляют собой операции захвата. Соответствующее ограничение на порядок доступа к памяти показано на следующем рисунке.

![[ParallelProg_41.png]]

Барьер `std::atomic_thread_fence` с порядком `std::memory_order_acquire` накладывает более жёсткие ограничения на переупорядочивание операций, как показано на следующем рисунке.

![[ParallelProg_42.png]]

Из этого сравнения видны два важных обстоятельства:

> 1. барьер с семантикой захвата накладывает более строгие ограничения на порядок операций. Хотя захват как атомарной переменной, так и барьера одинаково запрещает перемещать последующие операции чтения или записи перед захватом, барьер предоставляет ещё одну гарантию: никакие более ранние операции чтения не будут перемещены после захвата;
> 
> 2. для чтения атомарной переменной `var` при использовании барьера довольно ослабленной семантики, ведь эта операция не будет перемещена после барьера.

#### Операции освобождения

Операции записи над атомарными переменными, выполняемые с параметром `std::memory_order_release`, представляют собой операции освобождения. Ограничение на порядок доступа к памяти показано на следующем рисунке.

![[ParallelProg_43.png]]

Ниже показано соответствующее ограничение для барьера.

![[ParallelProg_44.png]]

В дополнение к ограничениям, характерным для операции освобождения атомарной переменной, освобождение барьера гарантирует два дополнительных свойства:

1. последующие операции записи не могут быть перемещены перед барьером;
2. для работы с переменной `var` достаточно ослабленной семантики.

### Синхронизация с использованием атомарных переменных и барьеров

Реализуем на основе семантики захвата и освобождения типичную систему из производителя и потребителя данных. Сначала воспользуемся для этого атомарными операциями, а затем используем вместо них барьеры.

#### Реализация на основе атомарных операций

Атомарные операции с семантикой захвата и освобождения

```c++
// acquireRelease.cpp
#include <atomic>
#include <thread>
#include <iostream>
#include <string>
using namespace std;

atomic<string*> ptr;
atomic<int> atoData;
int data;

void producer(){
	string* p = new string(“C++11”);
	data = 2011;

	atoData.store(2014, memory_order_relaxed);
	ptr.store(p, memory_order_release);
}

void consumer(){
	string* p2;
	
	while (!(p2 = ptr.load(memory_order_acquire)));

	cout << “*p2: “ << *p2 << endl;
	cout << “data: “ << data << endl;
	cout << “atoData: “ << atoData.load(memory_order_relaxed) << endl;
}

int main(){
	cout << endl;

	thread t1(producer);
	thread t2(consumer);
	
	t1.join();
	t2.join();
	
	cout << endl;
}
```

Эта программа должна выглядеть вполне понятной. Это классический пример, уже использованный в разделе, посвящённом модели [[sync and Memory model#Модель памяти std memory_order_consume|std::memory_order_consume]]. На следующем рисунке показано, что поток-потребитель `t2` получает все значения от потока-производителя `t1`.

![[ParallelProg_45.png]]

Поведение программы вполне определено в силу транзитивности отношения «происходит ранее». Нужно лишь объединить в цепочку три таких отношения:

> 1. операции в строках `string* p = new string(“C++11”)` - `atoData.store(2014, memory_order_relaxed)` происходят ранее строки `ptr.store(p, memory_order_release)`, где присваивается значение указателю;
> 2. строка `while (!(p2 = ptr.load(memory_order_acquire)))` с циклом ожидания происходит ранее строк `cout << “*p2: “ << *p2 << endl` - `cout << “atoData: “ << atoData.load(memory_order_relaxed) << endl`;
> 3. строка `ptr.store(p, memory_order_release)` синхронизируется со строкой `while (!(p2 = ptr.load(memory_order_acquire)))`. Следовательно, строка `ptr.store(p, memory_order_release)` происходит между потоками ранее строки `while (!(p2 = ptr.load(memory_order_acquire)))`.

Однако сейчас дело станет ещё интереснее, когда перейдём к использованию барьеров. Их незаслуженно обходят вниманием в литературе по языку C++ и его моделям памяти.

#### Барьеры памяти

Порядок захвата и освобождения с использованием барьеров:

```c++
// acquireReleaseFences.cpp

#include <atomic>
#include <thread>
#include <iostream>
#include <string>

using namespace std;

atomic<string*> ptr;
atomic<int> atoData;
int data;

void producer(){
	string* p = new string(“C++11”);
	data = 2011;
	
	atoData.store(2014, memory_order_relaxed);
	atomic_thread_fence(memory_order_release);
	ptr.store(p, memory_order_relaxed);
}

void consumer(){
	string* p2;
	
	while (!(p2 = ptr.load(memory_order_relaxed)));
	
	atomic_thread_fence(memory_order_acquire);
	
	cout << “*p2: “ << *p2 << endl;
	cout << “data: “ << data << endl;
	cout << “atoData: “ << atoData.load(memory_order_relaxed) << endl;
}

int main(){
	cout << endl;
	
	thread t1(producer);
	thread t2(consumer);

	t1.join();
	t2.join();
	
	delete ptr;
	
	cout << endl;
}
```

Первый шаг состоит в том, чтобы вставить в программу барьеры с семантикой освобождения (строка `atomic_thread_fence(memory_order_release)`) и захвата (строка `atomic_thread_fence(memory_order_acquire)`). Затем нужно заменить семантику атомарных операций с освобождения и захвата на ослабленную (строки `ptr.store(p, memory_order_relaxed)` и `while (!(p2 = ptr.load(memory_order_relaxed)))`). Это довольно очевидно. Конечно же, атомарные операции захвата и освобождения можно заменить только на соответствующие барьеры. Ключевой момент состоит в том, что барьер освобождения синхронизируется с барьером захвата, что влечёт межпоточное отношение «происходит ранее». Ниже представлен результат работы программы.

![[ParallelProg_46.png]]

Для любителей визуальной формы подачи материала ниже представлено графическое пояснение отношений синхронизации в этой программе.

Ключевой вопрос здесь звучит так: почему операции после барьера захвата видят результаты операций, стоящих перед барьером освобождения? Эта гарантия особенно интересна потому, что переменная `data` неатомарна, а операция `store` над переменной `atoData` выполняется с ослабленной семантикой. Могло бы показаться, что порядок этих операций может быть изменён реализацией, однако – благодаря барьеру освобождения в строке `atomic_thread_fence(memory_order_release)` и барьеру захвата в строке `atomic_thread_fence(memory_order_acquire)` – они обязательно выполняются в правильном порядке.

![[ParallelProg_47.png]]

Для большей ясности приведём рассуждение полностью.

1. Предотвращено изменение порядка атомарных и неатомарных операций относительно барьеров захвата и освобождения.
2. Поток-потребитель `t2` ждёт в цикле (строка `while (!(p2 = ptr.load(memory_order_relaxed)))`), пока переменной-указателю `ptr` не будет присвоено значение в потоке-производителе `t1`.
3. Барьер освобождения синхронизируется с барьером захвата.
4. В конечном счёте результаты всех операций с ослабленной семантикой и неатомарных операций, происходящих ранее барьера освобождения, видны после барьера захвата.

> **Синхронизация между барьерами освобождения и захвата**
> 
> Следующее место из документа N4659 (рабочий вариант стандарта языка C++) может оказаться довольно трудным для понимания: «Барьер освобождения `A` синхронизируется с барьером захвата `B`, если существуют атомарные операции `X` и `Y`, работающие с одним и тем же атомарным объектом `M`, такие, что барьер `A` расположен перед операцией `X`, операция `X` модифицирует объект `M`, операция `Y` расположена перед барьером `B` и операция `Y` читает значение, записанное объектом `X`, или значение, записанное побочным эффектом какой-либо гипотетической последовательностью освобождения, которая начиналась бы с операции `X`, если бы `X` была операцией освобождения».
> 
> Это предложение стоит пояснить на примере только что разобранной программы:
> • строка `atomic_thread_fence(memory_order_release)` представляет собой барьер освобождения `A`;
> • строка `atomic_thread_fence(memory_order_acquire)` – это барьер захвата `B`;
> • переменная `ptr`, объявленная в строке `atomic<string*> ptr`, есть атомарный объект `M`;
> • операция `store` над объектом `ptr` в строке `ptr.store(p, memory_order_relaxed)` есть операция записи `X`;
> • операция `load` над объектом `ptr` в строке `while (!(p2 = ptr.load(memory_order_relaxed)))` – это операция чтения `Y`.

Напоследок отметим, что можно даже использовать операции захвата и освобождения, как в программе `acquireRelease.cpp`, с барьерами захвата и освобождения, как в программе `acquireReleaseFence.cpp`, без ущерба для отношений синхронизации.

## Барьер std::atomic_signal_fence

Барьер `std::atomic_signal_fence` позволяет установить порядок синхронизации неатомарных операций и атомарных операций с ослабленной семантикой между потоком и обработчиком сигнала, выполняемым в этом же потоке.

Пример использования такого барьера показан в следующей программе.

Синхронизация с обработчиком сигнала:
```c++
// atomicSignal.cpp

#include <atomic>
#include <cassert>
#include <csignal>

std::atomic<bool> a{false};
std::atomic<bool> b{false};

extern “C” void handler(int) {
	if (a.load(std::memory_order_relaxed)) {
		std::atomic_signal_fence(std::memory_order_acquire);
		assert(b.load(std::memory_order_relaxed));
	}
}

int main() {
	std::signal(SIGTERM, handler);
	
	b.store(true, std::memory_order_relaxed);
	std::atomic_signal_fence(std::memory_order_release);
	a.store(true, std::memory_order_relaxed);
}
```

Программа начинается с установки (в строке `std::signal(SIGTERM, handler)`) обработчика для одного определённого сигнала – `SIGTERM`. Сигнал `SIGTERM` означает требование завершить программу. В программе расположены два барьера `std::atomic_signal_fence`: с семантикой освобождения в строке `std::atomic_signal_fence(std::memory_order_release)` и с семантикой захвата в строке `std::atomic_signal_fence(std::memory_order_acquire)`. Они запрещают переупорядочивание операций: операции освобождения не могут перемещаться через барьер освобождения, а операции захвата – через барьер захвата. Следовательно, контрольное утверждение в строке `assert(b.load(std::memory_order_relaxed))` никогда не будет нарушено: ведь если операция `store` над переменной `a` (строка `a.store(true, std::memory_order_relaxed)`) выполнилась, то операция `store` над переменной `b` (строка `b.store(true, std::memory_order_relaxed)`) должна была выполниться ещё раньше.


