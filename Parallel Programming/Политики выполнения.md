
[[#Политики выполнения|Политики выполнения]] 4.1
1. [[#Параллельное и векторизованное выполнение]] 4.1.1
	1. [[#Код без оптимизации]] 4.1.1.1
	2. [[#Максимальная оптимизация]] 4.1.1.2
2. [[#Обработка исключений]] 4.1.2
3. [[#Опасность гонок данных и мёртвых блокировок|Опасность гонок данных и мёртвых блокировок]] 4.1.3


# Политики выполнения

Стандартом определены следующие три политики:

* `std::execution::sequenced_policy`;
* `std::execution::parallel_policy`;
* `std::execution::parallel_unsequenced_policy`.

Соответствующие им значения-константы определяют, должен ли алгоритм выполняться последовательно, параллельно или векторизированно:

* `std::execution::seq` предписывает последовательное, в один поток, выполнение алгоритма;
* `std::execution::par` разрешает выполнение в несколько потоков;
* `std::execution::par_unseq` разрешает выполнять алгоритм в несколько потоков, чередовать итерации циклов в этих потоках и, кроме того, разрешает использование расширенных векторных инструкций ОКМД.

Таким образом, передача в функцию объектов `std::execution::par` и `std::execution::par_unseq` в качестве аргументов позволяет алгоритму выполняться в параллельном или параллельно-векторном режиме. Подчеркнём, что политика означает именно разрешение параллельной работы, а не требование.

> Стоит упомянуть, что в стандарте C++20 появилась также четвертая политика выполнения, кодируемая типом `unsequenced_policy` и константой `unseq` этого типа, которая предписывает выполнять алгоритм в один поток, но разрешает при этом пользоваться расширенными векторными инструкциями.
> 
> Следует подчеркнуть, что первые три (`sequenced_policy`, `parallel_policy`, `parallel_unsequenced_policy`) суть типы данных, тогда как последние три (`seq`, `par`, `par_unseq`) – константы этих типов. Типы данных, используемые для политик выполнения, фиктивны в том смысле, что в объектах этих типов не содержится никаких данных и, следовательно, передавая объекты-политики в функции стандартной библиотеки, программист не передаёт им никаких данных на этапе выполнения. Типы-политики нужны исключительно на этапе компиляции для выбора соответствующей перегрузки.
> 
> **ОКМД** (одиночные команды, множественные данные, англ. SIMD – single instructions, multiple data) – способ аппаратной поддержки параллельных вычислений, при котором одна арифметическая инструкция применяется не к одиночному значению, а к набору (вектору) данных одновременно.

В следующем фрагменте кода показано применение трёх политик выполнения.

**Политики выполнения:**
```c++
std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9};

// standard sequential sort
std::sort(v.begin(), v.end());

// sequential execution 
// Последовательное выполнение
std::sort(std::execution::seq, v.begin(), v.end());

// permitting parallel execution 
// Параллельное выполнение
std::sort(std::execution::par, v.begin(), v.end());

// permitting parallel and vectorized execution 
// Параллельное с векторизацией
std::sort(std::execution::par_unseq, v.begin(), v.end());
```

В строке `std::sort(v.begin(), v.end())` показано использование классического последовательного варианта функции [[sort|std::sort]]. Кроме того, стандарт C++17 позволяет явно указывать нужный вариант алгоритма: последовательный (строка `std::sort(std::execution::seq, v.begin(), v.end())`), параллельный (строка `std::sort(std::execution::par, v.begin(), v.end())`) или параллельный с векторизацией (строка `std::sort(std::execution::par_unseq, v.begin(), v.end())`).

С помощью шаблона `std::is_execution_policy` можно узнать, является ли тип `T` стандартной или зависящей от реализации политикой выполнения: для этого нужно взять значение выражения
```c++
std::is_execution_policy<T>::value
```

Это выражение имеет значение `true`, если тип `T` есть один из типов `sequenced_policy`, `parallel_policy`, `parallel_unsequenced_policy` или тип политики выполнения, специфичный для конкретной реализации. В противном случае данное выражение даёт значение `false`.

## Параллельное и векторизованное выполнение

Выполняется ли алгоритм параллельным и векторизованным способом, зависит от множества факторов. Например, это зависит от того, поддерживает ли процессор и операционная система инструкции типа `ОКОД` (англ. SIMD). Также это зависит от компилятора и от уровня оптимизации, использованного при трансляции кода.

В следующем примере показан простой цикл, заполняющий [[vector|вектор]] значениями.

**Заполнение [[vector|вектора]] значениями:**
```c++
const int SIZE= 8;

int vec[] = {1, 2, 3, 4, 5, 6, 7, 8};
int res[] = {0, 0, 0, 0, 0, 0, 0, 0};

int main(){
	for (int i = 0; i < SIZE; ++i) {
		res[i] = vec[i]+5;
	}
}
```

Строка `res[i] = vec[i]+5;` играет в этом примере ключевую роль. Благодаря средству `Compiler Explorer` можно в подробностях изучить машинные инструкции, которые генерирует компилятор `clang 3.6`.

### Код без оптимизации

Ниже показаны ассемблерные инструкции, которые выдаёт компилятор с выключенной оптимизацией. Все сложения выполняются последовательно.

![[ParallelProg_100.png]]

### Максимальная оптимизация

При наивысшем уровне оптимизации `-03` генерируется машинный код, использующий специальные регистры наподобие `xmm0`, в которых может храниться 128 бит, или 4 целых числа. В этом случае сложение выполняется одновременно для четырёх элементов вектора.

![[ParallelProg_101.png]]

Перегруженная версия алгоритма без политики выполнения отличается от перегрузки с явно заданной последовательной политикой `std::execution::seq` в одном отношении: обработкой исключений.

## Обработка исключений

Если во время выполнения алгоритма с явно заданной политикой выполнения возникает исключение, вызывается функция [[terminate|std::terminate]]. Эта функция вызывает обработчик `std::terminate_handler`. В свою очередь, обработчик по умолчанию вызывает функцию `std::abort`, которая аварийно завершает программу. Обработка исключений составляет различие между вызовом алгоритма без какой-либо политики выполнения и вызовом с явно заданной последовательной политикой `std::execution::seq`. Алгоритм без политики выполнения пропускает исключение наружу, тем самым давая возможность его обработать. Следующая программа иллюстрирует это различие.

**Политики выполнения и обработка исключений:**
```c++
// exceptionExecutionPolicy.cpp

#include <algorithm>
#include <execution>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>

 int main(){
	std::cout << std::endl;

	std::vector<int> myVec{1, 2, 3, 4, 5};

	try{
		std::for_each(myVec.begin(), myVec.end(),
				[](int){ throw std::runtime_error(
										“Without execution policy”); }
		);
	}
	catch(const std::runtime_error& e){
		std::cout << e.what() << std::endl;
	}

	try{
		std::for_each(std::execution::seq, myVec.begin(), myVec.end(),
			[](int){ throw std::runtime_error(“With execution policy”); }
		);
	}
	catch(const std::runtime_error& e){
		std::cout << e.what() << std::endl;
	}
	catch(...){
		std::cout << “Catch-all exceptions” << std::endl;
	}
}
```

Обработчик в строке `catch(const std::runtime_error& e)` успешно ловит исключение типа `std::runtime_error`, но следующий обработчик в строке `catch(const std::runtime_error& e)` и даже универсальный обработчик в строке `catch(...)` не отрабатывает.

Если воспользоваться новой версией компилятора `MSVC` с флагом `std:c++latest`, программа выдаёт ожидаемый результат:

![[ParallelProg_102.png]]

Легко убедиться, что перехватывается только первое исключение.

## Опасность гонок данных и мёртвых блокировок

Параллельные алгоритмы не обеспечивают автоматическую защиту от гонок данных и мёртвых блокировок. Рассмотрим пример.

**Параллельное выполнение с гонкой данных:**
```c++
std::vector<int> v = {1, 2, 3 };

int sum = 0;

std::for_each(std::execution::par, v.begin(), v.end(), 
			  [&sum](int x){sum += x * x;
});
```

В этом крохотном фрагменте кода имеет место гонка данных. Переменная `sum`, в которой должна накапливаться сумма квадратов элементов вектора, может модифицироваться параллельно из нескольких потоков. Эту переменную нужно защитить от одновременных модификаций, например так, как показано ниже.

**Корректное параллельное выполнение:**
```c++
std::vector<int> v = {1, 2, 3 };

int sum = 0;
std::mutex m;

std::for_each(std::execution::par, v.begin(), v.end(), 
			  [&sum](int x){
					std::lock_guard<std::mutex> lock(m);
					sum += x * x;
});
```

Если теперь изменить политику выполнения на параллельно-векторизованную (`par_unseq`), как показано ниже, получится состояние гонки, обычно приводящее к мёртвой блокировке.

**Параллельно-векторизованное выполнение с мёртвой блокировкой:**
```c++
std::vector<int> v = {1, 2, 3 };

int sum = 0;
std::mutex m;

std::for_each(std::execution::par_unseq, v.begin(), v.end(), 
			  [&sum](int x){
					std::lock_guard<std::mutex> lock(m);
					sum += x * x;
});
```

При данной политике выполнения могут произойти два подряд вызова лямбда-функции в одном и том же потоке. Повторная попытка захватить нерекурсивный [[mutex|мьютекс]] представляет собой неопределённое поведение и в большинстве случаев приводит к мёртвой блокировке. Этого можно избежать, если сделать переменную `sum` атомарной, как показано ниже.

**Корректное параллельно-векторизованное выполнение:**
```c++
std::vector<int> v = {1, 2, 3 };
std::atomic<int> sum = 0;

std::for_each(std::execution::par_unseq, v.begin(), v.end(), 
			  [&sum](int x){
					sum += x * x;
});
```

Поскольку переменная стала [[atomic|атомарной]], можно воспользоваться даже ослабленной семантикой, заменив оператор присваивания следующим:
```c++
sum.fetch_add(x * x, std::memory_order_relaxed);
```

Политику выполнения можно передавать в качестве параметра в 69 алгоритмов из стандартной библиотеки. Кроме того, стандарт C++17 пополнился восемью новыми алгоритмами.

