[[#Блокировщики]]
1. [[#Тип std lock_guard]] 3.3.2.1
2. [[#Тип std scoped_lock]] 3.3.2.2
3. [[#Тип std unique_lock|Тип std::unique_lock]] 3.3.2.3
4. [[#Блокировщик std shared_lock|Блокировщик std::shared_lock]] 3.3.2.4
	1. [[#Как побороть неопределённое поведение]] 3.3.2.4.1
[[#Функция std lock]] 3.3.3

# Блокировщики

Блокировщики управляют захватом и освобождением ресурса посредством идиомы `RAII`. Блокировщик автоматически захватывает [[mutex|мьютекс]] в конструкторе и освобождает в деструкторе. Это существенно снижает риск мёртвых блокировок, поскольку освобождение [[mutex|мьютекса]] гарантируется при любом завершении захватившего участка кода.

В стандарте имеется четыре вида [[mutex|мьютексов]]. Тип [[lock#Тип std lock_guard|std::lock_guard]] предназначен для простейших сценариев, тип [[lock#Тип std unique_lock|std::unique_lock]] – для более сложных. Тип [[lock#Блокировщик std shared_lock|std::shared_lock]], появившийся в стандарте C++14, можно использовать для блокировки читателей и писателей. С выходом стандарта C++17 в руках у программистов оказался также блокировщик [[lock#Тип std scoped_lock|std::scoped_lock]], который умеет запирать несколько [[mutex|мьютексов]] за одну атомарную операцию.

Начнём с разбора наиболее простого сценария.

## Тип std::lock_guard

Посмотрим на фрагмент кода:
```c++
std::mutex m;

m.lock();
	sharedVariable = getVar();
m.unlock();
```

[[mutex|Мьютекс]] `m` должен гарантировать, что доступ к критической секции (строке кода, где присваивается значение переменной `sharedVariable`) происходит последовательно. Иными словами, если несколько потоков одновременно подходят к этой критической секции, они будут заходить в неё по одному. Тем самым устанавливается глобальный для системы порядок доступа к общим данным. Этот код выглядит просто, но потенциально подвержен мёртвой блокировке, например если изнутри критической секции выбрасывается исключение или если программист забывает разблокировать [[mutex|мьютекс]] функцией `unlock`. Блокировщик `std::lock_guard` позволяет решить данную задачу более элегантно:

```c++
{
	std::mutex m;
	
	std::lock_guard<std::mutex> lockGuard(m);
	sharedVariable = getVar();
}
```

Код выглядит просто. Однако зачем в нём появились открывающая и закрывающая фигурные скобки? Они ограничивают область видимости и время жизни объекта-блокировщика, объявленного внутри этих скобок. Это означает, что как только выполнение достигает закрывающей скобки, время жизни блокировщика заканчивается, отрабатывает его деструктор и – как нетрудно догадаться – освобождает [[mutex|мьютекс]]. Это происходит совершенно автоматически, даже если функция `getVar` изнутри критической секции выбрасывает исключение. Тело функции и тело цикла также представляют собой блоки, ограничивающие время жизни объекта.

## Тип std::scoped_lock

В стандарте C++17 библиотека пополнилась типом `std::scoped_lock`. Он очень похож на тип [[#Тип std lock_guard|std::lock_guard]], но позволяет управлять одновременно произвольным количеством [[mutex|мьютексов]]. Нужно иметь в виду несколько обстоятельств.

1. Если в блокировщик `std::scoped_lock` завернуть только один [[mutex|мьютекс]], блокировщик ведёт себя в точности как [[#Тип std lock_guard|тип std::lock_guard]] и в конструкторе вызывает функцию `lock` [[mutex|мьютекса]]. Если же в конструктор блокировщика передать несколько [[mutex|мьютексов]], для них вызывается функция `std::lock`.
2. Если текущий поток уже захватил один из [[mutex|мьютексов]] и если этот [[mutex|мьютекс]] не рекурсивного типа, поведение не определено. На практике это с большой вероятностью может означать мёртвую блокировку.
3. Блокировщик позволяет также забрать себе управление уже захваченным [[mutex|мьютексом]] без попытки захватить его. Для этого нужно передать в конструктор блокировщика дополнительный аргумент типа `std::adopt_lock_t`.

Описанную выше трудность с мёртвой блокировкой можно элегантно решить, воспользовавшись типом `std::scoped_lock`. 

## Тип std::unique_lock

Тип блокировщика `std::unique_lock` превосходит возможностями своего младшего брата [[#Тип std lock_guard|std::lock_guard]], но и обходится дороже. В дополнение к возможностям, которые предоставляет [[#Тип std lock_guard|тип std::lock_guard]], тип `std::unique_lock` позволяет также:
* создавать блокировщик, не связанный с каким-либо [[mutex|мьютексом]];
* создавать блокировщик, не блокируя переданный ему [[mutex|мьютекс]];
* в явном виде многократно захватывать и освобождать [[mutex|мьютекс]];
* запирать [[mutex|мьютекс]] рекурсивно;
* перемещать [[mutex|мьютекс]] в другой блокировщик;
* пытаться захватить [[mutex|мьютекс]];
* задавать предельное время ожидания при попытке захвата мьютекса.

Функции-члены этого класса показаны в следующей таблице.

**Интерфейс класса `std::unique_lock`:**

| **Функция**                         | **Описание**                                                                             |
| ----------------------------------- | ---------------------------------------------------------------------------------------- |
| `lock`                              | Захватывает завёрнутый в объект мьютекс                                                  |
| `try_lock`                          | Пытается захватить [[mutex\|мьютекс]]; если он уже захвачен, возвращает значение `false` |
| `try_lock_for`,<br>`try_lock_until` | То же с предельным временем ожидания                                                     |
| `unlock`                            | Освобождает мьютекс                                                                      |
| `release`                           | Отдаёт управление мьютексом, не освобождая его                                           |
| `swap`                              | Обменивает мьютексы между двумя блокировщиками; аналог вызова `std::swap(lk1, lk2)`      |
| `mutex`                             | Возвращает указатель на мьютекс, завёрнутый блокировщик                                  |
| `owns_lock`,<br>`operator bool`     | Проверяет, занят ли мьютекс                                                              |

Функции-члену `try_lock_for` требуется временной интервал относительно текущего момента, в течение которого можно ожидать занятый [[mutex|мьютекс]]; функция `try_lock_until` принимает абсолютное значение – момент времени. Функции `try_lock_for` и `try_lock_until` блокировщика вызывают соответствующую функцию [[mutex|мьютекса]]. При этом [[mutex|мьютекс]] должен сам поддерживать попытку захвата с предельным временем ожидания. При указании времени следует пользоваться монотонными часами (`std::chrono::steady_clock`), которые гарантируют неубывание показателей и которые невозможно переводить.

Функция-член `try_lock` пытается захватить [[mutex|мьютекс]] и возвращает управление немедленно. Если захват удался, функция возвращает значение `true`, в противном случае – `false`. В отличие от него, функции `try_lock_for` и `try_lock_until` в случае занятого [[mutex|мьютекса]] блокируют выполнение своего потока до тех пор, пока [[mutex|мьютекс]] не освободится или пока не истечёт предельное время ожидания. Все три функции бросают исключение [[system_error|std::system_error]], если с объектом-блокировщиком не связан никакой [[mutex|мьютекс]] или если [[mutex|мьютекс]] уже захвачен этим блокировщиком.

Функция `release` разрывает связь объекта-блокировщика с завёрнутым в него [[mutex|мьютексом]] и возвращает указатель на этот [[mutex|мьютекс]]. Код, вызвавший эту функцию, должен отныне сам позаботиться об освобождении [[mutex|мьютекса]].

## Блокировщик std::shared_lock

В стандарте C++14 был добавлен блокировщик `std::shared_lock`. Он обладает таким же интерфейсом, как и [[#Тип std unique_lock|тип std::unique_lock]], но по-иному ведёт себя, когда применяется к объектам типов [[mutex|std::shared_mutex]] и [[mutex|std::shared_timed_mutex]]. Такие [[mutex|мьютексы]] могут захватываться (в совместном режиме) одновременно несколькими потоками, чем, в частности, реализуется шаблон читателей и писателей. Этот шаблон очень прост и исключительно полезен. Любое число потоков могут одновременно обращаться к критическим данным в режиме чтения, но модифицировать эти данные может только один
поток.

Блокировка в режиме чтения и записи не устраняет корень проблемы – соперничество потоков за доступ к общим данным, – но помогает заметно расширить «бутылочное горлышко».

Хорошим примером использования блокировок на чтение и запись служит телефонная книга. Обычно в каждый момент времени множество людей желает искать в ней информацию, но лишь изредка кто-либо меняет её содержимое. Рассмотрим следующий код.

**Блокировка на чтение и запись**
```c++
// readerWriterLock.cpp

#include <iostream>
#include <map>
#include <shared_mutex>
#include <string>
#include <thread>

std::map<std::string,int> teleBook{
	{“Dijkstra”, 1972}, {“Scott”, 1976}, {“Ritchie”, 1983}};

std::shared_timed_mutex teleBookMutex;

void addToTeleBook(const std::string& na, int tele){
	std::lock_guard<std::shared_timed_mutex> writerLock(teleBookMutex);
	std::cout << “\nSTARTING UPDATE “ << na;
	
	std::this_thread::sleep_for(std::chrono::milliseconds(500));
	teleBook[na]= tele;
	
	std::cout << “ ... ENDING UPDATE “ << na << std::endl;
}

void printNumber(const std::string& na){
	std::shared_lock<std::shared_timed_mutex> readerLock(teleBookMutex);
	
	std::cout << na << “: “ << teleBook[na];
}

int main(){
	std::cout << std::endl;

	std::thread reader1([]{ printNumber(“Scott”); });
	std::thread reader2([]{ printNumber(“Ritchie”); });
	
	std::thread w1([]{ addToTeleBook(“Scott”,1968); });

	std::thread reader3([]{ printNumber(“Dijkstra”); });
	std::thread reader4([]{ printNumber(“Scott”); });

	std::thread w2([]{ addToTeleBook(“Bjarne”,1965); });

	std::thread reader5([]{ printNumber(“Scott”); });
	std::thread reader6([]{ printNumber(“Ritchie”); });
	std::thread reader7([]{ printNumber(“Scott”); });
	std::thread reader8([]{ printNumber(“Bjarne”); });

	reader1.join();
	reader2.join();
	reader3.join();
	reader4.join();
	reader5.join();
	reader6.join();
	reader7.join();
	reader8.join();

	w1.join();
	w2.join();

	std::cout << std::endl;
	std::cout << “\nThe new telephone book” << std::endl;

	for (auto teleIt: teleBook){
		std::cout << teleIt.first << “: “ << teleIt.second << std::endl;
	}

	std::cout << std::endl;
}
```

Телефонная книга, объявленная в строке `std::map<std::string,int> teleBook{`, находится в общем доступе у всех потоков, поэтому её нужно защищать от несогласованных операций.

Восемь потоков изъявляют желание читать из телефонной книги, а два потока пытаются её изменить (строки `std::thread reader1([]{ printNumber(“Scott”); })` – `std::thread reader8([]{ printNumber(“Bjarne”); });`). Для синхронизации параллельного доступа к телефонной книге потоки-читатели пользуются в строке `std::shared_lock<std::shared_timed_mutex> readerLock(teleBookMutex);` блокировщиком `std::shared_lock`. В отличие от них потоки-писатели требуют исключительного доступа к критическим данным. Исключительность достигается использованием блокировщика `std::lock_guard` в строке `td::lock_guard<std::shared_timed_mutex> writerLock(teleBookMutex);`. В конце программа отображает обновлённое содержимое телефонной книги.

![[ParallelProg_61.png]]

Из результата работы программы видно, что вывод из потоков-читателей перемешивается, тогда как потоки-писатели выполняются по одному. Это означает, что операции с блокировкой только на чтение выполняются одновременно.

Решение оказалось удивительно простым. Слишком простым. И неправильным.

### Как побороть неопределённое поведение

Представленная выше программа обладает неопределённым поведением. Говоря конкретнее, в ней присутствует гонка данных. Как это могло случиться? Прежде чем продолжать, читателю рекомендуется подумать несколько минут. Одновременный доступ к потоку `std::cout` здесь, кстати, ни при чём. 

Определение гласит, что гонка данных – это ситуация, когда по меньшей мере два потока имеют одновременный доступ к некоторой переменной и хотя бы один из потоков производит её запись. Именно это может произойти в процессе выполнения представленной программы. Интересная особенность ассоциативного контейнера состоит в том, что чтение данных из контейнера операцией индексирования может на самом деле изменить его. Это происходит, когда элемента с заданным ключом в контейнере не оказывается. Если, скажем, во время чтения в контейнере не обнаруживается элемент с ключом «Bjarne», пара («Bjarne», 0) создаётся и помещается в контейнер. Гонку данных легко сделать очевидной, если печать значения по ключу «Bjarne» поместить перед остальными потоками. Посмотрим, что получится. Первым сообщением программа выдаёт для ключа «Bjarne» значение 0.

![[ParallelProg_62.png]]

Очевидный способ исправить положение состоит в том, чтобы использовать в функции `printNumber` исключительно операции, не модифицирующие контейнер.

**Исправленная программа с блокировкой на чтение и запись:**
```c++
// readerWriterLocksResolved.cpp
...

void printNumber(const std::string& na){
	std::shared_lock<std::shared_timed_mutex> readerLock(teleBookMutex);

	auto searchEntry = teleBook.find(na);
	if(searchEntry != teleBook.end()){
		std::cout << searchEntry->first << “: “ << 
										searchEntry->second << std::endl;
	}
	else {
		std::cout << na << “ not found!” << std::endl;
	}
}

...
```

Если запрошенного ключа в телефонной книге нет, эта программа печатает ключ и текст `«not found!»` («не найдено»).

![[ParallelProg_63.png]]

При втором запуске программа выдала сообщение «Bjarne not found». При первом запуске поток с добавлением записи в телефонную книгу успел выполниться первым, поэтому данные по ключу «Bjarne» нашлись.

# Функция std::lock

Функция `std::lock` умеет захватывать сколь угодно много [[mutex|мьютексов]], [[#Блокировщики|блокировщиков]] или иных объектов, подпадающих под понятие `Lockable` (запираемый), за одно атомарное действие. Именованный набор требований `Lockable` объединяет типы, которые поддерживают функции-члены `lock`, `unlock` и `try_lock`. Функция `std::lock` представляет собой вариадический шаблон, т. е. может принимать любое число аргументов. Функция пытается захватить все переданные ей запираемые объекты с помощью алгоритма, предотвращающего мёртвые блокировки. Объекты захватываются в неопределённой последовательности вызовом их функций-членов `lock` и `try_lock`. Если вызов операции `lock` для какого-либо [[mutex|мьютекса]] привёл к исключению, функция `std::lock` вызывает функцию-член `unlock` для всех объектов, которые успела захватить, а затем передаёт это исключение наружу.

Вспомним ещё раз программу [[mutex#Захват мьютексов в различном порядке|deadlock.cpp]] и преобразуем её так, чтобы исключить проблему. Для этого функция `deadLock` должна захватывать оба мьютекса одновременно – именно это делается в следующем примере.

**Отложенный захват мьютексов:**

```c++
// deadlockResolved.cpp

#include <iostream>
#include <chrono>
#include <mutex>
#include <thread>

using namespace std;

struct CriticalData{
	mutex mut;
};

void deadLock(CriticalData& a, CriticalData& b){
	unique_lock<mutex> guard1(a.mut, defer_lock);	
	cout << “Thread: “ << this_thread::get_id() 
											<< “ first mutex” << endl;

	this_thread::sleep_for(chrono::milliseconds(1));

	unique_lock<mutex> guard2(b.mut, defer_lock);
	cout << “ Thread: “ << this_thread::get_id() 
											<< “ second mutex” << endl;

	cout << “Thread: “ << this_thread::get_id() 
										<< “ get both mutexes” << endl;
	lock(guard1,guard2);
	// do something with a and b
}

int main(){
	cout << endl;
	
	CriticalData c1;
	CriticalData c2;
	
	thread t1([&]{deadLock(c1,c2);});
	thread t2([&]{deadLock(c2,c1);});
	
	t1.join();
	t2.join();
	
	cout << endl;
}
```

При вызове конструктора [[#Тип std unique_lock|std::unique_lock]] с параметром `std::defer_lock` [[mutex|мьютекс]] не запирается. В момент создания (строки `unique_lock<mutex> guard1(a.mut, defer_lock)` и `unique_lock<mutex> guard2(b.mut, defer_lock)`) объекты [[#Тип std unique_lock|std::unique_lock]] всего лишь становятся обёртками для своих [[mutex|мьютексов]]. Затем (строка `lock(guard1,guard2)`) шаблонная функция `std::lock` с переменным числом аргументов запирает два [[mutex|мьютекса]] одновременно.

В этом примере объекты типа [[#Тип std unique_lock|std::unique_lock]] служат для освобождения [[mutex|мьютексов]] при окончании времени жизни, а функция `std::lock` – для захвата этих объектов. Можно было бы сделать и наоборот: сначала захватить [[mutex|мьютексы]] функцией `std::lock`, затем взять их под управление блокировщиками [[#Тип std unique_lock|std::unique_lock]]. Пример такого подхода показан ниже.

```c++
std::lock(a.mut, b.mut);

std::lock_guard<std::mutex> guard1(a.mut, std::adopt_lock);
std::lock_guard<std::mutex> guard2(b.mut, std::adopt_lock);
```

Оба способа устраняют мёртвую блокировку.

![[ParallelProg_64.png]]

> **Использование блокировщика [[#Тип std scoped_lock|std::scoped_lock]]:**
> 
> С появлением стандарта С++ 17 решение проблемы мёртвой блокировки становится совсем простым. Теперь есть класс [[#Тип std scoped_lock|std::scoped_lock]], который позволяет захватывать любое число [[mutex|мьютексов]] в конструкторе. Всё, что нужно, – это просто создать объект типа [[#Тип std scoped_lock|std::scoped_lock]]. Ниже показана видоизменённая функция `deadlock`.

#std_scoped_lock
```c++
// deadlockResolvedScopedLock.cpp
...
void deadLock(CriticalData& a, CriticalData& b){
	cout << “Thread: “ << this_thread::get_id() 
											<< “ first mutex” << endl;

	this_thread::sleep_for(chrono::milliseconds(1));

	cout << “ Thread: “ << this_thread::get_id() 
											<< “ second mutex” << endl;

	cout << “ Thread: “ << this_thread::get_id() 
										<< “ get both mutexes” << endl;
	
	std::scoped_lock (a.mut, b.mut);
	// do something with a and b
}

...
```



