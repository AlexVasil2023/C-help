
1. [[#std atomic_flag|std::atomic_flag]] 2.3.2
	1. [[#Циклическая блокировка|Циклическая блокировка]]
	2. [[#Сравнение циклической блокировки с мьютексом|Сравнение циклической блокировки с мьютексом]] 
	3. [[#Синхронизация потоков|Синхронизация потоков]]
2. [[#std atomic]] 2.3.3
	1. [[#Фундаментальный атомарный интерфейс|Фундаментальный атомарный интерфейс]]
		1. [[#Тип `std atomic<bool>`|Тип std::atomic<bool>]] 2.3.3.1.1
		2. [[#Моделирование переменных условия|Моделирование переменных условия]] 2.3.3.1.2
		3. [[#Операции compare_exchange_strong и compare_exchange_weak|Операции compare_exchange_strong и compare_exchange_weak]] 2.3.3.1.3
		4. [[#Синхронизация потоков с помощью типа `std atomic<bool>`|Синхронизация потоков с помощью типа `std atomic<bool>`]] 2.3.3.1.4
		5. [[#Атомарные обёртки для пользовательских типов|Атомарные обёртки для пользовательских типов]] 2.3.3.1.5
		6. [[#Атомарные умные указатели в стандарте C++ 20|Атомарные умные указатели в стандарте C++ 20]] 2.3.3.1.6
		7. [[#Потокобезопасный односвязный список|Потокобезопасный односвязный список]] 2.3.3.1.7
	2. [[#Атомарные типы с плавающей точкой в стандарте C++20|Атомарные типы с плавающей точкой в стандарте C++20]] 2.3.3.2
	3. [[#Атомарный тип указателя|Атомарный тип указателя]] 2.3.3.3
	4. [[#Атомарные целочисленные типы|Атомарные целочисленные типы]] 2.3.3.4
	5. [[#Псевдонимы типов|Псевдонимы типов]] 2.3.3.5
3. [[#Функции-члены атомарных типов|Функции-члены атомарных типов]] 2.3.4
4. [[#Свободные функции над атомарными типами|Свободные функции над атомарными типами]] 2.3.5
	1. [[#Особенности типа std shared_ptr (до стандарта C++ 20)]] 2.3.5.1
		1. [[#Атомарные операции над типом std shared_ptr]] 2.3.5.1.1
5. [[#Шаблон класса std atomic_ref в стандарте C++ 20|Шаблон класса std::atomic_ref в стандарте C++ 20]] 2.3.6
	1. [[#Мотивация|Мотивация]] 2.3.6.1
	2. [[#Специализации шаблона std atomic_ref]] 2.3.6.2
		1. [[#Основной вариант шаблона|Основной вариант шаблона]] 2.3.6.2.1
		2. [[#Частичные специализации для типов указателей|Частичные специализации для типов указателей]] 2.3.6.2.2
		3. [[#Специализации для арифметических типов|Специализации для арифметических типов]] 2.3.6.2.3
	3. [[#Полный список атомарных операций]] 2.3.6.3
6. [[#std atomic<std shared_ptr>|std::atomic<std::shared_ptr>]]
7. [[#std atomic<std weak_ptr>|std::atomic<std::weak_ptr>]]

# std::atomic_flag

Тип `std::atomic_flag` – это логический тип, все операции над которым атомарны. У него два состояния: установлен и сброшен. Для простоты состояние сброшенного флага будем впредь обозначать `false`, а состояние установленного – `true`. Функция-член `clear` устанавливает значение флага в `false`. Функция-член `test_and_set` устанавливает значение в `true` и возвращает предыдущее значение флага. Поначалу отсутствовала функция, которая бы просто возвращала текущее значение. Это исправлено в стандарте C++20. В этом стандарте тип `std::atomic_flag` получает функцию-член `test` и даже может использоваться для синхронизации потоков благодаря появлению функций-членов `notify_one`, `notify_all` и `wait`. В следующей таблице показаны все функции-члены этого класса.

| **Имя функции**                 | **Описание**                                   |
| ------------------------------- | ---------------------------------------------- |
| atomicFlag.clear()              | Сбросить флаг                                  |
| atomicFlag.test_and_set()       | Установить флаг и вернуть его старое состояние |
| atomicFlag.test() (C++20)       | Вернуть текущее значение флага                 |
| atomicFlag.notify_one() (C++20) | Разблокировать одну операцию ожидания          |
| atomicFlag.notify_all() (C++20) | Разблокировать все операции ожидания           |
| atomicFlag.wait(bool) (C++20)   | Заблокировать до прихода оповещения            |

Вызов `atomicFlag.test()` возвращает текущее состояние флага `atomicFlag`, не изменяя его. Более того, типом `std::atomic_flag` можно пользоваться для синхронизации потоков: для этого служат вызовы `atomicFlag.wait(bool)`, `atomicFlag.notify_one()` и `atomicFlag.notify_all()`. Функции-члены `notify_one` и `notify_all` оповещают, соответственно, один или все потоки, заблокированные на вызове `wait`. Вызов `atomicFlag.wait(bool)` требует аргумента `bool` логического типа. Этот вызов блокирует выполнение потока до тех пор, пока поток не будет разбужен оповещением (`notify_one` или `notify_all`) из другого потока, или до ложного пробуждения. Пробудившись, данная функция-член проверяет, равно ли текущее значение флага `atomicFlag` значению аргумента `bool` и, если не равно, разблокирует выполнение. Таким образом, аргумент `bool` служит защитой от ложных пробуждений.

Помимо этого, в отличие от C++11, в стандарте C++20 конструктор по умолчанию устанавливает объект `std::atomic_flag` в начальное состояние `false`.

> **Инициализация атомарных флагов в стандарте C++11**
> Стандарт C++11 требовал, чтобы переменные типа `std::atomic_flag` инициализировались следующим образом:
```c++
std::atomic_flag flag = ATOMIC_FLAG_INIT;
```

Никакие иные способы инициализации, например` std::atomic_flag flag(ATOMIC_FLAG_INIT)`, в стандарте не определены.

Тип `std::atomic_flag` обладает двумя замечательными свойствами:

> это единственный атомарный тип, для которого гарантируется отсутствие блокировок;
> 
> он используется для построения связанных с потоками абстракций более высокого уровня.

Почему говорят, что это единственный тип без блокировок? Остальные, более мощные атомарные типы могут, в соответствии со стандартом C++, в своих внутренних механизмах использовать [[mutex|мьютексы]]. Эти прочие атомарные типы обладают функцией-членом `is_lock_free`, позволяющей проверить, используются ли [[mutex|мьютексы]] в их внутренней реализации. На всех широко распространённых микропроцессорных архитектурах эти функции возвращают `true`. Программисту следует знать об этом и делать такую проверку, если хочется обеспечить в программе отсутствие блокировок.

> **Независимость от адресации**
> Атомарные операции, гарантированно свободные от блокировок, должны быть также независимы от адресации (англ. address-free). Это означает, что операции, выполняемые двумя разными процессами над одной областью памяти, остаются атомарными.

> **Функция `std::is_always_lock_free`**
> У каждого отдельно взятого объекта `obj` атомарного типа или типа `atomic_ref` (появившегося в стандарте C++ 20) можно спросить, гарантирует ли он отсутствие блокировок: для этого служит вызов `obj.is_lock_free()`. Такая проверка проходит на этапе выполнения. С появлением [[constexpr| constexpr-функции]] `atomic<type>::is_always_lock_free` стало возможным для всякого атомарного типа проверять, гарантирует ли он отсутствие блокировок на всех аппаратных платформах, на которых может запускаться исполняемый модуль. Эта функция даёт результат `true`, только если блокировок заведомо не будет на всех поддерживаемых видах аппаратуры. Проверка отрабатывает на этапе компиляции. Функция доступна начиная со стандарта С++17.

Следующее контрольное утверждение никогда не нарушается:

```c++
if (std::atomic<T>::is_always_lock_free)
	assert(std::atomic<T>().is_lock_free();
```

Интерфейс класса `std::atomic_flag` достаточно мощен, чтобы с его помощью реализовать циклическую блокировку. Циклическая блокировка позволяет защищать критические секции таким же образом, как и [[mutex|мьютекс]].

## Циклическая блокировка

Циклическая блокировка (также называемая спин-блокировкой, спинлоком, англ. spinlock) – это примитив синхронизации наподобие [[mutex|мьютекса]]. В отличие от [[mutex|мьютекса]], однако, он не пассивно ожидает возможности продолжить выполнения. Вместо этого он постоянно продолжает запрашивать право на доступ к критической секции. В случае ожидания циклическая блокировка предотвращает дорогостоящую операцию переключения контекста между пользовательским режимом и режимом ядра, однако при этом она активно использует центральный процессор и впустую нагружает его командами.

Если потоки блокируются лишь на очень короткое время, циклические блокировки весьма эффективны. Также часто используются комбинации из циклической блокировки и [[mutex|мьютекса]]. Поначалу в течение ограниченного времени применяется циклическая блокировка. Если за это время блокировка не освободилась, поток переводится в состояние ожидания.

Никогда не следует пользоваться циклическими блокировками на однопроцессорной системе. В лучшем случае цикл будет расходовать ресурсы и замедлять выполнение своего потока. В худшем случае можно получить мёртвую блокировку (`deadlock`).

Ниже показана реализация цикла блокировки на основе типа `std::atomic_flag`.

```c++
// spinLock.cpp

#include <atomic>
#include <thread>

class Spinlock {
	std::atomic_flag flag = ATOMIC_FLAG_INIT;

	public:
		void lock() {
			while(flag.test_and_set());
		}

		void unlock() {
			flag.clear();
		}
};

Spinlock spin;

void workOnResource() {
	spin.lock();

	// shared resource
	
	spin.unlock();
}

int main() {
	std::thread t1(workOnResource);
	std::thread t2(workOnResource);

	t1.join();
	t2.join();
}
```

Два потока, `t1` и `t2`, соревнуются между собой за доступ к критической секции. Для простоты в этом примере критическая секция состоит лишь из `// shared resource`. Как эта программа работает? Класс `Spinlock`, подобно [[mutex|мьютексу]], обладает функциями-членами `lock` и `unlock`. В дополнение к этому переменная типа `std::atomic_flag` получает начальное значение `false`. Когда поток `t1` собирается выполнить функцию `workOnResource`, возможны следующие два случая:

1. Поток `t1` захватывает блокировку, и вызов функции-члена `lock` сразу завершается. Это может произойти тогда, когда флаг на момент вызова функции `lock` содержал значение false. В этом случае поток `t1` оказывается первым, кто устанавливает значение флага в `true`. Если теперь поток `t2` постарается захватить блокировку, условие в цикле `while` вернёт значение `true`. Поток `t2` начинает бег по кругу. Он не может сам сбросить флаг в `false`, поэтому раз за разом проверяет в цикле условие до тех пор, пока поток `t1` не выполнит функцию-член `unlock` и не сбросит флаг – пос­ле этого поток `t2` сможет покинуть цикл и продолжить выполнение.
2. Поток `t1` не успевает первым захватить блокировку. Происходит то же самое, что и в предыдущем случае, только потоки `t1` и `t2` меняются местами.

Читателю стоит обратить внимание на функцию-член `test_and_set` класса `std::atomic_flag`. Эта функция выполняет две операции: чтение старого и запись нового значения флага. Однако обе эти операции должны выполняться как одна атомарная операция. Если бы это было не так, два потока осуществляли бы одновременные попытки чтения и записи в общую область памяти. Это по определению является гонкой данных, и программа в целом обладала бы неопределённым поведением.

Было бы интересно сравнить активное ожидание посредством циклической блокировки с пассивным ожиданием, реализованным на основе [[mutex|мьютекса]].

## Сравнение циклической блокировки с мьютексом

Что произойдёт с нагрузкой на центральный процессор, если функция `workOnResource` будет захватывать блокировку на 2 секунды?

```c++
// spinLockSleep.cpp

#include <atomic>
#include <chrono>
#include <thread>

class Spinlock {
	std::atomic_flag flag = ATOMIC_FLAG_INIT;

	public:
		void lock() {
			while( flag.test_and_set() );
		}

		void unlock() {
			flag.clear();
		}
};

Spinlock spin;

void workOnResource(){
	spin.lock();
	
	std::this_thread::sleep_for(std::chrono::milliseconds(2000));

	spin.unlock();
}

int main(){
	std::thread t1(workOnResource);
	std::thread t2(workOnResource);

	t1.join();
	t2.join();
}
```

Если принцип работы циклической блокировки описан правильно, то одно из процессорных ядер должно быть полностью загружено. Именно это и происходит в действительности, как видно из следующего графика.

![[ParallelProg_14.png]]
Циклическая блокировка на две секунды

На графике хорошо видно, что при активном ожидании нагрузка на одно из четырёх ядер подскакивает до 100 %. При каждом запуске программы это
может оказаться новое ядро.

Теперь вместо циклической блокировки воспользуемся [[mutex|мьютексом]] и посмотрим, что изменится.

```c++
// mutex.cpp

#include <chrono>
#include <mutex>
#include <thread>

std::mutex mut;

void workOnResource(){
	mut.lock();
	
	std::this_thread::sleep_for(std::chrono::milliseconds(2000));

	mut.unlock();
}

int main(){
	std::thread t1(workOnResource);
	std::thread t2(workOnResource);

	t1.join();
	t2.join();
}
```

Сколько бы раз ни запускать эту программу, ни одно из ядер не показывает заметного увеличения нагрузки, о чём свидетельствует следующий график.

![[ParallelProg_15.png]]
Блокировка [[mutex|мьютекса]] на две секунды

Тем не менее с помощью типа `std::atomic_flag` синхронизацию потоков можно сделать очевидной и быстрой.

## Синхронизация потоков

Синхронизация потоков на основе типа `std::atomic_flag`

```c++
// threadSynchronisationAtomicFlag.cpp

#include <atomic>
#include <iostream>
#include <thread>
#include <vector>

std::vector<int> myVec{};
std::atomic_flag atomicFlag{};

void prepareWork() {
	myVec.insert(myVec.end(), {0, 1, 0, 3});
	std::cout << “Sender: Data prepared.” << ‘\n’;
	
	atomicFlag.test_and_set();
	atomicFlag.notify_one();
}

void completeWork() {
	std::cout << “Waiter: Waiting for data.” << ‘\n’;

	atomicFlag.wait(false);

	myVec[2] = 2;
	std::cout << “Waiter: Complete the work.” << ‘\n’;

	for (auto i: myVec) std::cout << i << “ “;
		std::cout << ‘\n’;
}

int main() {
	std::cout << ‘\n’;

	std::thread t1(prepareWork);
	std::thread t2(completeWork);

	t1.join();
	t2.join();

	std::cout << ‘\n’;
}
```

Первый поток готовит исходные данные, а затем устанавливает переменную `atomicFlag` в значение `true` (`atomicFlag.test_and_set()`) и посылает оповещение. Второй поток, который обрабатывает эти данные, ждёт оповещения. Он разблокируется только тогда, когда переменная `atomicFlag` примет значение `true`.

Ниже представлен результат нескольких запусков этой программы, откомпилированной с помощью компилятора фирмы Microsoft.

![[ParallelProg_16.png]]
Синхронизация потоков с использованием типа `std::atomic_flag`

Даже если первый поток отправит своё оповещение до того, как второй поток начнёт его ожидать, оповещение не будет потеряно. Флаги типа `std::atomic_flag` не подвержены утере пробуждений.

Теперь пора от типа `std::atomic_flag` как наиболее элементарного механизма перейти к более сложным атомарным типам – к шаблону `std::atomic`.

# std::atomic

В библиотеке имеется множество различных вариаций для шаблона класса `std::atomic`. Так, для типов `std::atomic<bool>` и `std::atomic<пользовательский_тип>` используется общее определение шаблона. Частичные специализации доступны для типов указателей `std::atomic<T*>`, а начиная со стандарта C++ 20 – и для типов умных указателей `std::atomic<std::shared_ptr<U>>` и `std::atomic<std::weak_ptr<U>>`. Полные специализации определены для целочисленных типов, а начиная со стандарта С++ 20 – и для действительных типов с плавающей точкой.

Атомарный логический тип, атомарные пользовательские типы и атомарные умные указатели поддерживают один и тот же интерфейс. Будем называть его фундаментальным атомарным интерфейсом. Атомарные указатели расширяют фундаментальный атомарный интерфейс. Ещё более расширен интерфейс атомарных арифметических типов: у атомарных типов с плавающей точкой интерфейс расширен по сравнению с интерфейсом атомарных указателей, а атомарные целочисленные типы обладают интерфейсом, более широким, чем типы с плавающей точкой.

Недостаток различных вариаций шаблона `std::atomic` состоит в том, что они не дают гарантии отсутствия блокировок. В следующих подразделах будут рассмотрены различные атомарные типы, сгруппированные по интерфейсам. 

## Фундаментальный атомарный интерфейс

Три специализации шаблона (для типа `bool`, пользовательских типов и типов умных указателей) поддерживают фундаментальный атомарный интерфейс.

| **Функции-члены**                                 | **Описание**                                                                                                                                                                                                                                         |
| ------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| is_lock_free                                      | Проверить отсутствие блокировок                                                                                                                                                                                                                      |
| is_always_lock_free                               | Проверить отсутствие блокировок на этапе компиляции                                                                                                                                                                                                  |
| load                                              | Атомарным образом вернуть текущее значение атомарной переменной                                                                                                                                                                                      |
| operator T                                        | Эквивалент предыдущей функции                                                                                                                                                                                                                        |
| store                                             | Атомарным образом присвоить атомарной переменной новое значение (неатомарного типа)                                                                                                                                                                  |
| exchange                                          | Атомарным образом присвоить атомарной переменной новое значение и вернуть старое                                                                                                                                                                     |
| compare_exchange_strong,<br>compare_exchange_weak | Атомарным образом сравнить и, возможно, обменять значение с неатомарной переменной.                                                                                                                                                                  |
| notify_one (C++ 20)                               | Оповестить одну ожидающую операцию                                                                                                                                                                                                                   |
| notify_all (C++ 20)                               | Оповестить все ожидающие операции                                                                                                                                                                                                                    |
| wait (C++ 20)                                     | Заблокировать поток до прихода оповещения. Получив оповещение, сравнить текущее значение со старым для защиты от ложных пробуждений и утери пробуждения. Если текущее значение отличается от старого, функция завершается, иначе продолжает ожидание |

Тип `std::atomic<bool>` заслуживает особого рассмотрения.

### Тип `std::atomic<bool>`

Тип `std::atomic<bool>` предоставляет клиентам гораздо больше возможностей, чем тип [[#std atomic_flag|std::atomic_flag]]. Так, переменным этого типа можно в явном виде присваивать значения `true` и `false`.

>Шаблон atomic – это не спецификатор volatile
>
>Что общего между ключевым словом [[volatile|volatile]] в языках C# и Java и ключевым словом [[volatile|volatile]] в языке C++? Ничего! Различие между атомарными и volatile-переменными таковы:
> * спецификатор [[volatile|volatile]] предназначен для особых объектов, операции чтения и записи которых не разрешается оптимизировать;
> * шаблон `std::atomic` позволяет объявлять переменные, предназначенные для безопасного чтения и записи из различных потоков.
> 
> В этом кроется причина недоразумения. Ключевое слово [[volatile|volatile]] в языках C++ и Java имеет тот же смысл, что и шаблон `std::atomic` в языке C++. С другой стороны, слово [[volatile|volatile]] в языке C++ не имеет отношения к многопоточности. В языках C и C++ слово [[volatile|volatile]] обычно используется при программировании встроенных систем для обозначения переменных, которые могут менять свои значения независимо от хода выполнения программы. Одним из примеров может служить переменная, представляющая внешнее устройство (т. е. ввод-вывод с прямым отображением на память). Поскольку значения этих переменных могут изменяться независимо от выполнения программы, операции над ними должны всегда содержать обращение к основной памяти, поэтому использовать буферную память для оптимизации таких операций нельзя.

Типа `std::atomic<bool>` уже достаточно для синхронизации потоков; на основе этого типа вполне можно реализовать аналог переменной условия.

### Моделирование переменных условия

Покажем сначала, как для синхронизации двух потоков использовать обычную переменную условия.

**Использование переменных условия**
```c++
// conditionVariable.cpp

 #include <condition_variable>
 #include <iostream>
 #include <thread>
 #include <vector>

 std::vector<int> mySharedWork;
 std::mutex mutex_;
 std::condition_variable condVar;

 bool dataReady{false};

void waitingForWork() {
	std::cout << “Waiting “ << std::endl;
	
	std::unique_lock<std::mutex> lck(mutex_);
	condVar.wait(lck, []{ return dataReady; });
	mySharedWork[1] = 2;
	
	std::cout << “Work done “ << std::endl;
}

void setDataReady() {
	mySharedWork = {1, 0, 3};
	{
		std::lock_guard<std::mutex> lck(mutex_);
		dataReady = true;
	}

	std::cout << “Data prepared” << std::endl;
	
	condVar.notify_one();
}

int main() {
	std::cout << std::endl;

	std::thread t1(waitingForWork);
	std::thread t2(setDataReady);

	t1.join();
	t2.join();

	for (auto v: mySharedWork) {
		std::cout << v << “ “;
	}

	std::cout << “\n\n”;
}
```

Здесь опишем работу этой программы лишь в общих чертах. 

Поток `t1` в строке `condVar.wait(lck, []{ return dataReady; });` ждёт оповещения от потока `t2`. Оба потока пользуются одной переменной условия `condVar` и одним и тем же мьютексом `mutex_`. Как происходит взаимодействие между ними?

Поток `t1`:

* подготавливает исходные данные присваиванием `mySharedWork = {1, 0, 3};
* устанавливает неатомарную логическую переменную `dataReady` в значение `true`;
* посылает оповещение ожидающему потоку с помощью вызова `condVar.notify_one()`.

Переменная `dataReady` логического типа, которую поток `t1` устанавливает в значение `true`, а поток `t2` проверяет с помощью лямбда-функции, играет роль памяти для переменной условия, которая сама по себе состоянием не обладает. Переменные условия бывают подвержены двум неприятным явлениям:

1. ложное пробуждение – ситуация, когда ожидающий поток просыпается, хотя никакого оповещения отправитель не присылал;
2. утерянное пробуждение – ситуация, когда отправитель посылает оповещение до того, как поток-получатель переходит в состояние ожидания.

Наличие условия в операции `wait` позволяет справиться с обеими проблемами.

Теперь посмотрим, как то же самое поведение реализовать с помощью типа `std::atomic<bool>`.

**Реализация переменной условия на основе типа `std::atomic<bool>`**

```c++
// atomicCondition.cpp

#include <atomic>
#include <chrono>
#include <iostream>
#include <thread>
#include <vector>

std::vector<int> mySharedWork;
std::atomic<bool> dataReady(false);

void waitingForWork() {
	std::cout << “Waiting “ << std::endl;
	
	while (!dataReady.load()) { // C
		std::this_thread::sleep_for(std::chrono::milliseconds(5));
	}

	mySharedWork[1] = 2; // D
	
	std::cout << “Work done “ << std::endl;
}

void setDataReady(){
	mySharedWork = {1, 0, 3}; // A
	dataReady = true; // B
	
	std::cout << “Data prepared” << std::endl;
}

int main(){
	std::cout << std::endl;

	std::thread t1(waitingForWork);
	std::thread t2(setDataReady);

	t1.join();
	t2.join();

	for (auto v: mySharedWork) {
		std::cout << v << “ “;
	}

	std::cout << “\n\n”;
}
```

Чем гарантируется, что строка `mySharedWork[1] = 2;` выполнится после строки `while (!dataReady.load()) {`? Или, в более общем плане, что поток `t1` выполнит присваивание `mySharedWork[1] = 2` после того, как поток `t2` выполнит оператор `mySharedWork = {1, 0, 3}`. Теперь взаимодействие потоков можно определить более строго:

* строка `mySharedWork = {1, 0, 3};` предшествует строке `dataReady = true;`;
* строка `while (!dataReady.load()) {` предшествует строке `mySharedWork[1] = 2;`;
* строка `dataReady = true;` синхронизирована со строкой `while (!dataReady.load()) {`;
* поскольку отношение синхронизации включает в себя предшествование и поскольку отношение предшествования транзитивно, получаем, что оператор `mySharedWork = {1, 0, 3}` выполнится до оператора `mySharedWork[1] = 2.`

Для простоты в этом рассуждении опущены промежуточные звенья: отношение синхронизации влечёт за собой отношение межпоточного предшествования, а оно, в свою очередь, влечёт предшествование. 

Следует ещё раз подчеркнуть это исключительно важное обстоятельство: доступ к общей переменной `mySharedWork` синхронизируется посредством переменной условия `condVar` или атомарной переменной `dataReady`. Это так даже несмотря на то, что переменная `mySharedWork` сама по себе не атомарна и не защищена блокировщиком.

Обе представленные программы выдают один и тот же результат, как показано на следующем рисунке.

![[ParallelProg_17.png]]

> **Принцип втягивания и вталкивания**
> И всё-таки это была не полная правда. Есть одно важное различие между синхронизацией потоков с помощью переменной условия и синхронизацией на основе типа `std::atomic<bool>`. Переменная условия вызовом `condVar.notify()` оповещает ожидающий поток о том, что тот может продолжить свою работу. Во второй программе, напротив, ожидающий поток постоянно проверяет, сделал ли поток-производитель свою работу, т. е. выполнил ли присваивание `dataRead = true`.
> 
> Переменная условия оповещает ожидающий поток, реализуя тем самым принцип вталкивания, тогда как реализация на основе атомарной переменной логического типа раз за разом запрашивает значение, пока оно не станет истинным – тем самым реализуя принцип втягивания.

Тип `std::atomic<bool>`, как и все другие полные и частичные специализации шаблона `std::atomic`, поддерживают наиболее важные из всех атомарных операций: операции `compare_exchange_strong` и `compare_exchange_weak`.

### Операции compare_exchange_strong и compare_exchange_weak

Первая операция обладает следующей сигнатурой:

```c++
bool compare_exchange_strong(T& expected, T& desired)
```

Поскольку эта операция производит сравнение и обмен значений за одну атомарную операцию, в англоязычной литературе её часто называют «compare and swap» (сравнить и поменять местами), или сокращённо CAS. Подобные операции имеются во многих языках программирования и составляют основу неблокирующих алгоритмов. Конечно, поведение подобных операций в разных языках может немного отличаться. Операция, о которой идёт речь здесь, ведёт себя следующим образом:

* если сравнение текущего значения переменной `atomicValue` со значением аргумента `expected` даёт положительный результат, переменной `atomicValue` в рамках этой же атомарной операции присваивается значение аргумента `desired`;
* если же сравнение даёт отрицательный результат, то переменной `expected` присваивается текущее значение переменной `atomicValue`.

Причина, по которой операция названа «сильной» (`strong`), станет сейчас очевидной. Рядом с ней есть также операция под названием `compare_exchange_weak` (англ. weak – слабая). Данная операция может допускать промахи. Это означает, что даже если условие `*atomicValue == expected` выполнено, присваивания переменной `atomicValue` со значения `expected` не происходит, а функция возвращает значение `false`, так что вызов этой операции нужно выполнять в цикле:

```c++
while (!atomicValue.compare_exchange_weak(expected, desired))
```

Слабая форма существует потому, что некоторые процессоры не поддерживают атомарную инструкцию сравнения и обмена. Поэтому если операцию предполагается использовать в цикле, следует предпочесть слабую форму. На некоторых моделях процессоров она выполняется быстрее.

Для операций семейства CAS характерна так называемая проблема ABA. А именно, если значение переменной прочесть дважды, и оба раза это оказывается одно и то же значение `A`, можно заключить, будто переменная своего значения не изменяла. Однако может оказаться, что между двумя чтениями она успела изменять своё значение на `B` и вернуться к прежнему значению. 

### Синхронизация потоков с помощью типа `std::atomic<bool>`

Пример программы с синхронизацией потоков можно легко переписать, используя вместо типа [[#std atomic_flag|std::atomic_flag]] тип [[#Тип `std atomic<bool>`|std::atomic<bool>]].

Синхронизация потоков с помощью типа `std::atomic<bool>`

```c++
// threadSynchronisationAtomicBool.cpp

#include <atomic>
#include <iostream>
#include <thread>
#include <vector>

std::vector<int> myVec{};
std::atomic<bool> atomicBool{false};

void prepareWork() {
	myVec.insert(myVec.end(), {0, 1, 0, 3});
	std::cout << “Sender: Data prepared.” << ‘\n’;

	atomicBool.store(true);
	atomicBool.notify_one();
}

void completeWork() {
	std::cout << “Waiter: Waiting for data.” << ‘\n’;
	atomicBool.wait(false);
	myVec[2] = 2;
	std::cout << “Waiter: Complete the work.” << ‘\n’;
	
	for (auto i: myVec) 
		std::cout << i << “ “;
	
	std::cout << ‘\n’;
 }

int main() {
	std::cout << ‘\n’;
	
	std::thread t1(prepareWork);
	std::thread t2(completeWork);
	
	t1.join();
	t2.join();
	
	std::cout << ‘\n’;
}
```

Здесь операция `atomicBool.wait(false)` блокирует выполнение потока до тех пор, пока выполняется условие `atomicBool == false`. Вызов `atomicBool.store(true)` устанавливает этой переменной значение `true`, затем отсылается оповещение, что приводит к разблокировке первого потока.

Так же, как в случае реализации на основе типа `std::atomic_flag`, приведём результаты четырёх запусков программы, собранной компилятором фирмы Microsoft

![[ParallelProg_18.png]]

Помимо логического типа, атомарными можно сделать типы указателей, целочисленные и пользовательские типы. Для пользовательских типов действуют особые правила. Однако операции CAS поддерживают все вариации шаблона [[#std atomic|std::atomic]].

### Атомарные обёртки для пользовательских типов

Благодаря шаблону [[#std atomic|std::atomic]] становится возможным делать атомарными типы, созданные программистом. Имеется ряд довольно строгих ограничений, которым должен удовлетворять пользовательский тип, чтобы его можно было подставлять в шаблон [[#std atomic|std::atomic]]. Атомарный тип `std::atomic<user_defined_type>` поддерживает тот же интерфейс, что и тип `std::atomic<bool>`. Ограничения, накладываемые на атомарные пользовательские типы, таковы:

* копирующие операции присваивания для самого этого типа, всех его базовых классов и всех нестатических членов-данных должны быть тривиальны. Это означает, что в типе нельзя своими руками определять копирующую операцию присваивания, однако о создании такой операции можно попросить компилятор, воспользовавшись ключевым словом `default`;

* пользовательский тип не должен обладать виртуальными функциями-членами или виртуальными базовыми классами;

* пользовательский тип должен допускать побитовое копирование и сравнение, т. е. к нему должны быть применимы функции `memcpy` и `memcmp`.

На широко распространённых платформах операции над типами вида `std::atomic<user_defined_type>` могут быть атомарными только тогда, когда размер пользовательского типа не превышает размер типа `int`.

> Свойства пользовательских типов можно проверять на этапе компиляции, используя следующие функции: `std::is_trivially_copy_constructible`, `std::is_polymorphic` и `std::is_trivial`. Эти функции входят в чрезвычайно мощную библиотеку свойств типов.

### Атомарные умные указатели в стандарте C++ 20

Объект типа [[shared_ptr|std::shared_ptr]] содержит в себе указатели на блок служебных данных и на объект-ресурс. Блок служебных данных потокобезопасен, а ресурс – нет. Операции над счётчиком ссылок атомарны, а ресурс уничтожается гарантированно ровно один раз.

> Стоит сделать небольшое отступление, чтобы подчеркнуть, насколько это важно для типа [[shared_ptr|std::shared_ptr]] – иметь хорошо определённую семантику в многопоточной среде. На первый взгляд, использование умных указателей типа [[shared_ptr|std::shared_ptr]] не выглядит разумным выбором для многопоточного программирования. Эти указатели по определению реализуют семантику совместного владения изменяемым объектом данных и потому словно напрашиваются на несинхронизированные операции чтения и записи и, следовательно, на неопределённое поведение. С другой стороны, при программировании на современном языке C++ действует правило: не использовать «сырые» указатели. Поэтому в программах, включая многопоточные, следует пользоваться умными указателями.

Предложение, касающееся атомарных умных указателей, прямо нацелено на недостатки существующей реализации. Эти недостатки сводятся к трём основным аспектам: согласованности, корректности и производительности.

> **Согласованность**: атомарные операции над типом [[shared_ptr|std::shared_ptr]] – единственные атомарные операции над неатомарным типом, что нарушает единство системы типов.
> **Корректность**: использование глобально-атомарных операций для умных указателей чревато ошибками, так как требует от программиста самодисциплины. Очень просто забыть о необходимости использования атомарной операции – например, написать `ptr = localPtr` вместо `std::atomic_store(&ptr, localPtr)`. Результатом такой ошибки может стать неопределённое поведение по причине гонки данных. Если бы вместо этого использовался тип атомарного умного указателя, система типов сделала бы подобную ошибку невозможной.
> **Производительность**: атомарные умные указатели обладают значительным преимуществом перед функциями семейства `std::atomic_*`. Атомарная версия умных указателей разрабатывается специально для определённой задачи и может, например, иметь в основе своей реализации дешевую циклическую блокировку с типом [[#std atomic_flag|std::atomic_flag]]. Попытка же сделать неатомарную версию функций над умными указателями потокобезопасной может оказаться напрасным трудом, если эти указатели используются в однопоточной среде. Кроме того, это может привести к потере производительности.

Аргумент, касающийся корректности, вероятно, самый важный. Почему? Ответ дан в документе. В предложении приведена реализация односвязного списка с операциями вставки, удаления и поиска элементов. Причём список реализован без использования блокировок.

### Потокобезопасный односвязный список

Все изменения, которые нужно внести, чтобы программу стало возможно откомпилировать компилятором, поддерживающим только стандарт C++ 11, отмечены красным. Реализация на основе атомарных умных указателей гораздо проще и потому менее подвержена ошибкам. Система типов языка С++ 20 не позволяет применять неатомарные операции к атомарным умным указателям.

В предложении `N4162` говорилось о том, чтобы добавить в библиотеку новые типы атомарных умных указателей: [[#std atomic<std shared_ptr>|std::atomic<std shared_ptr>]] и [[#std atomic<std weak_ptr>|std::atomic_weak_ptr]]. При интеграции предложения в действующий международный стандарт языка они превратились в частичные специализации шаблона [[#std atomic|std::atomic]], а именно [[#std atomic<std shared_ptr>|std::atomic<std::shared_ptr>]] и [[#std atomic<std weak_ptr>|std::atomic<std::weak_ptr>]].

Потокобезопасный односвязный список:
![[ParallelProg_19.png]]

В то же время атомарные операции над типом [[shared_ptr|std::shared_ptr]] в стандарте C++20 объявлены устаревшими.

В следующей программе показаны пять потоков, которые одновременно модифицируют переменную типа `std::atomic<std::shared_ptr<std::string>>` без использования явных примитивов синхронизации.

```c++
// atomicSharedPtr.cpp

 #include <iostream>
 #include <memory>
 #include <atomic>
 #include <string>
 #include <thread>

 int main() {
	std::cout << ‘\n’;

	std::atomic<std::shared_ptr<std::string>> sharString(
				std::make_shared<std::string>(“Zero”));

	std::thread t1([&sharString]{
		sharString.store(std::make_shared<std::string>(
					*sharString.load() + “One”));
	});
	
	std::thread t2([&sharString]{
		sharString.store(std::make_shared<std::string>(
					*sharString.load() + “Two”));
	});
	
	std::thread t3([&sharString]{
		sharString.store(std::make_shared<std::string>(
					*sharString.load() +”Three”));
	});
	
	std::thread t4([&sharString]{
		sharString.store(std::make_shared<std::string>(
					*sharString.load() +”Four”));
	});
	
	std::thread t5([&sharString]{
		sharString.store(std::make_shared<std::string>(
					*sharString.load() +”Five”));
	});
	
	t1.join();
	t2.join();
	t3.join();
	t4.join();
	t5.join();
	
	std::cout << *sharString.load() << ‘\n’;
```

Атомарная переменная `sharString` типа [[shared_ptr|std::shared_ptr]] инициализируется текстом `«Zero»`. Каждый из пяти потоков `t1–t5` дописывает в конец этой строки свой фрагмент. Если в этой программе подставить тип [[shared_ptr|std::shared_ptr]] вместо типа [[#std atomic<std shared_ptr>|std::atomic<std::shared_ptr>]], возникнет гонка данных.

Запуск программы демонстрирует, как перемежается выполнение различных потоков.

Потокобезопасная модификация строки через умный указатель:
![[ParallelProg_20.png]]

## Атомарные типы с плавающей точкой в стандарте C++20

Помимо фундаментального атомарного интерфейса, атомарные типы с плавающей точкой поддерживают также сложение и вычитание.

Операции, расширяющие фундаментальный атомарный интерфейс

| Функция-член  | Описание                                                                |
| ------------- | ----------------------------------------------------------------------- |
| fetch_add, += | Атомарным образом прибавить заданное значение и вернуть старое значение |
| fetch_sub, -= | Атомарным образом отнять заданное значение и вернуть старое значение    |

В библиотеке имеются полные специализации шаблона для типов `float`, `double` и `long double`.

## Атомарный тип указателя

Тип `std::atomic<T*>` – это частичная специализация шаблона [[#std atomic|std::atomic]]. Она ведёт себя как обычный указатель `T*`. По сравнению с типами с плавающей точкой, этот тип также поддерживает операции пре- и постинкремента и декремента.

Операции, расширяющие интерфейс атомарных типов с плавающей точкой

| Функция-член | Описание                                                                                                     |
| ------------ | ------------------------------------------------------------------------------------------------------------ |
| ++, --       | Увеличивает или уменьшает значение атомарной переменной на единицу (с префиксной или постфиксной семантикой) |

Рассмотрим небольшой пример.

```c++
int intArray[5];
std::atomic<int*> p(intArray);
p++;
assert(p.load() == &intArray[1]);
p+=1;
assert(p.load() == &intArray[2]);
--p;
assert(p.load() == &intArray[1]);
```

Кроме рассмотренных, стандарт C++ 11 содержит ещё атомарные обёртки для целочисленных типов.

## Атомарные целочисленные типы

Для каждого целочисленного типа в библиотеке определена полная специализация шаблона [[#std atomic|std::atomic]]. Специализации `std::atomic<integral_type>` поддерживают все те же операции, что и типы `std::atomic<T*>` и `std::atomic<floating_point_type>`. Кроме того, они поддерживают ещё побитовые логические операции «И», «ИЛИ» и «исключающее ИЛИ».

Операции над атомарными целочисленными значениями

| Функция-член                                    | Описание                                                                                               |
| ----------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| fetch_or, \|=<br>fetch_and, &=<br>fetch_xor, ^= | Атомарным образом выполняют побитовую операцию над значением атомарной переменной и значением операнда |

Есть небольшое различие в поведении между комбинированной операцией с присваиванием и соответствующей функцией из семейства `fetch_`. Комбинированные побитовые операции с присваиванием возвращают новое значение атомарной переменной, тогда как функции `fetch_` – старое.

При внимательном рассмотрении бросается в глаза отсутствие атомарного умножения, атомарного деления, а также атомарных операций побитового сдвига. Это ограничение вряд ли окажется обременительным, так как данные операции бывают нужны нечасто и в случае необходимости их можно реализовать самостоятельно. Ниже представлен пример атомарного умножения.

Атомарное умножение с помощью операции [[#Операции compare_exchange_strong и compare_exchange_weak|compare_exchange_strong]]

```c++
// fetch_mult.cpp

#include <atomic>
#include <iostream>

template <typename T>
T fetch_mult(std::atomic<T>& shared, T mult){
	
	T oldValue = shared.load();

	while (!shared.compare_exchange_strong(oldValue, oldValue * mult));
	
	return oldValue;
}

int main(){
	std::atomic<int> myInt{5};
	std::cout << myInt << std::endl;

	fetch_mult(myInt,5);
	std::cout << myInt << std::endl;
}
```

Алгоритм атомарного умножения работает следующим образом. Сначала в переменную `oldValue` помещается текущее значение атомарной переменной. К тому времени, как выполнение доходит до строки `while (!shared.compare_exchange_strong(oldValue, oldValue * mult))`, эту переменную может модифицировать другой поток. Поэтому операция `compare_exchange_strong` проверяет, по-прежнему ли атомарная переменная имеет значение `oldValue`. Если это так, то произведение `oldValue * mult` записывается в атомарную переменную. В противном случае модификации атомарной переменной не происходит, вместо этого в переменную `oldValue` помещается нынешнее значение атомарной переменной и делается новая попытка поместить в неё произведение. Через неизвестное заранее число итераций алгоритму, скорее всего, повезёт – никакой другой поток не успеет модифицировать переменную между итерациями цикла, и алгоритм завершит свою работу.

> Алгоритм `fetch_mult` умножит атомарную переменную `shared` на значение `mult`. Важнейшее обстоятельство состоит в том, что между чтением значения атомарной переменной и попыткой присваивания ей нового значения проходит некоторое время, пусть и небольшое. Поэтому другой поток может вклиниться в этот промежуток и изменить значение переменной `shared`. Если теперь представить себе чрезвычайно неудачную очерёдность выполнения потоков, когда другой поток всегда успевает изменить значение атомарной переменной, легко видеть, что алгоритм не гарантирует достижения конечного результата за какое-либо конечное время. Таким образом, этот алгоритм свободен от блокировок (англ. lock-free), но не свободен от ожидания (англ. wait-free).

Для каких именно целочисленных типов определены специализации? Ниже приведён подробный список:

> - символьные типы: `char`, `char8_t` (C++20), `char16_t`, `char32_t` и `wchar_t`;
> 
> - стандартные целочисленные типы со знаком: `signed char`, `short int`, `long` и `long long`;
> 
> - стандартные целочисленные типы без знака: `unsigned char`, `unsigned short int`, `unsigned long` и `unsigned long long`;
> 
> - дополнительные целочисленные типы, определённые в заголовочном файле `<cstdint>`:
> >	 –  `int8_t`, `int16_t`, `int32_t`, `int64_t` (типы со знаком разрядностью ровно 8, 16, 32 и 64 бита соответственно);
> >	 – `uint8_t`, `uint16_t`, `uint32_t`, `uint64_t` (беззнаковые типы разрядностью ровно 8, 16, 32 и 64 бита соответственно);
> >	 – `int_fast8_t`, `int_fast16_t`, `int_fast32_t` и `int_fast64_t` (наиболее быстрые типы со знаком разрядностью не менее 8, 16, 32 и 64 бита соответственно);
> >	 – `uint_fast8_t`, `uint_fast16_t`, `uint_fast32_t` и `uint_fast64_t` (наиболее быстрые типы без знака разрядностью не менее 8, 16, 32 и 64 бита соответственно);
> >	 – `int_least8_t`, `int_least16_t`, `int_least32_t` и `int_least64_t` (типы со знаком с наименьшей доступной разрядностью не менее 8, 16, 32 и 64 би­та соответственно);
> >	 – `uint_least8_t`, `uint_least16_t`, `uint_least32_t` и `uint_least64_t` (типы без знака с наименьшей доступной разрядностью не менее 8, 16, 32 и 64 бита соответственно);
> >	 – `intmax_t` и `uintmax_t` (знаковый и беззнаковый целочисленный типы с наибольшей доступной разрядностью);
> >	 – `intptr_t` и `uintptr_t` (знаковый и беззнаковый целочисленный типы, позволяющие хранить значения указателей).

## Псевдонимы типов

Для типа `std::atomic<bool>` и специализаций шаблона [[#std atomic|std::atomic]] всеми доступными целочисленными типами в стандартной библиотеке языка C++ определены псевдонимы, как показано в следующей таблице.

Псевдонимы специализаций шаблона [[#std atomic|std::atomic]]

| Псевдоним                              | Определение                        |
| -------------------------------------- | ---------------------------------- |
| std::atomic_bool                       | `std::atomic<bool>`                |
| std::atomic_char                       | `std::atomic<char>`                |
| std::atomic_schar                      | `std::atomic<signed char>`         |
| std::atomic_uchar                      | `std::atomic<unsigned char>`       |
| std::atomic_short                      | `std::atomic<short>`               |
| std::atomic_ushort                     | `std::atomic<unsigned short>`      |
| std::atomic_int                        | `std::atomic<int>`                 |
| std::atomic_uint                       | `std::atomic<unsigned int>`        |
| std::atomic_long                       | `std::atomic<long>`                |
| std::atomic_ulong                      | `std::atomic<unsigned long>`       |
| std::atomic_llong                      | `std::atomic<long long>`           |
| std::atomic_ullong                     | `std::atomic<unsigned long long>`  |
| std::atomic_char8_t (C++20)            | `std::atomic<char8_t>` (C++20)     |
| std::atomic_char16_t                   | `std::atomic<char16_t>`            |
| std::atomic_char32_t                   | `std::atomic<char32_t>`            |
| std::atomic_wchar_t                    | `std::atomic<wchar_t>`             |
| std::atomic_int8_t                     | `std::atomic<std::int8_t>`         |
| std::atomic_uint8_t                    | `std::atomic<std::uint8_t>`        |
| std::atomic_int16_t                    | `std::atomic<std::int16_t>`        |
| std::atomic_uint16_t                   | `std::atomic<std::uint16_t>`       |
| std::atomic_int32_t                    | `std::atomic<std::int32_t>`        |
| std::atomic_uint32_t                   | `std::atomic<std::uint32_t>`       |
| std::atomic_int64_t                    | `std::atomic<std::int64_t>`        |
| std::atomic_uint64_t                   | `std::atomic<std::uint64_t>`       |
| std::atomic_int_least8_t               | `std::atomic<std::int_least8_t>`   |
| std::atomic_uint_least8_t              | `std::atomic<std::uint_least8_t>`  |
| std::atomic_int_least16_t              | `std::atomic<std::int_least16_t>`  |
| std::atomic_uint_least16_t             | `std::atomic<std::uint_least16_t>` |
| std::atomic_int_least32_t              | `std::atomic<std::int_least32_t>`  |
| std::atomic_uint_least32_t             | `std::atomic<std::uint_least32_t>` |
| std::atomic_int_least64_t              | `std::atomic<std::int_least64_t>`  |
| std::atomic_uint_least64_t             | `std::atomic<std::uint_least64_t>` |
| std::atomic_int_fast8_t                | `std::atomic<std::int_fast8_t>`    |
| std::atomic_uint_fast8_t               | `std::atomic<std::uint_fast8_t>`   |
| std::atomic_int_fast16_t               | `std::atomic<std::int_fast16_t>`   |
| std::atomic_uint_fast16_t              | `std::atomic<std::uint_fast16_t>`  |
| std::atomic_int_fast32_t               | `std::atomic<std::int_fast32_t>`   |
| std::atomic_uint_fast32_t              | `std::atomic<std::uint_fast32_t>`  |
| std::atomic_int_fast64_t               | `std::atomic<std::int_fast64_t>`   |
| std::atomic_uint_fast64_t              | `std::atomic<std::uint_fast64_t>`  |
| std::atomic_intptr_t                   | `std::atomic<std::intptr_t>`       |
| std::atomic_uintptr_t                  | `std::atomic<std::uintptr_t>`      |
| std::atomic_size_t                     | `std::atomic<std::size_t>`         |
| std::atomic_ptrdiff_t                  | `std::atomic<std::ptrdiff_t>`      |
| std::atomic_intmax_t                   | `std::atomic<std::intmax_t>`       |
| std::atomic_uintmax_t                  | `std::atomic<std::uintmax_t>`      |
| std::atomic_signed_lock_free (C++20)   | `std::atomic<signed_integral>`     |
| std::atomic_unsigned_lock_free (C++20) | `std::atomic<unsigned_integral>`   |

Псевдонимы `atomic_signed_lock_free` и `atomic_unsigned_lock_free` ссылаются на специализации шаблона [[#std atomic|std::atomic]], соответственно, знаковыми или беззнаковыми целочисленными типами. Эти псевдонимы доступны только для таких целочисленных типов, у которых соответствующие специализации шаблона [[#std atomic|std::atomic]] гарантируют отсутствие блокировок. Выбор наиболее эффективной специализации может зависеть от реализации.

# Функции-члены атомарных типов

Прежде всего приведём полный список функций-членов из всех атомарных типов.

| Функция-член                                    | Описание                                                                                                                                                                |
| ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| test_and_set                                    | Атомарным образом установить значение флага в `true` и вернуть предыдущее значение                                                                                      |
| clear                                           | Атомарным образом установить значение флага в `false`                                                                                                                   |
| is_lock_free                                    | Проверить, гарантирует ли объект работу без блокировок                                                                                                                  |
| is_always_lock_free                             | Проверить на этапе компиляции, гарантирует ли тип работу без блокировок                                                                                                 |
| load                                            | Атомарным образом вернуть значение                                                                                                                                      |
| operator T                                      | Атомарным образом вернуть значение, эквивалентное операции `atom.load()`                                                                                                |
| store                                           | Атомарным образом поместить в атомарную переменную новое значение                                                                                                       |
| exchange                                        | Атомарным образом поместить в атомарную переменную новое значение и вернуть её старое значение                                                                          |
| compare_exchange_strong compare_exchange_weak   | Атомарным образом сравнить значение атомарной переменной с заданным и в зависимости от результата сравнения обменять значение с неатомарной переменной.                 |
| fetch_add, +=                                   | Атомарным образом увеличить значение атомарной переменной на заданную величину                                                                                          |
| fetch_sub, -=                                   | Атомарным образом уменьшить значение атомарной переменной на заданную величину                                                                                          |
| fetch_or, \|=<br>fetch_and, &=<br>fetch_xor, ^= | Атомарным образом выполнить над атомарной переменной и заданным значением соответствующую побитовую операцию (ИЛИ, И, исключающее ИЛИ)                                  |
| ++, --                                          | Пре- и постинкремент (декремент) атомарной переменной                                                                                                                   |
| notify_one (C++20)                              | Оповестить один ожидающий поток                                                                                                                                         |
| notify_all (C++20)                              | Оповестить все ожидающие потоки                                                                                                                                         |
| wait (C++20)                                    | Заблокировать поток до оповещения. При пробуждении сравнить текущее значение атомарной переменной со старым значением для предотвращения ложных и утерянных пробуждений |

У атомарных типов отсутствует конструктор копирования и копирующая операция присваивания, однако присваивание их значений возможно на основе неявного преобразования к завёрнутому в них обычному типу. Комбинированные операции присваивания возвращают новое значение, тогда как соответствующие им `fetch_-функции` – старое. Важно отметить, что комбинированные операции присваивания возвращают значение, а не ссылку
на объект.

Неявное преобразование к завёрнутому типу:

```c++
std::atomic<long long> atomObj(2011);

atomObj = 2014;

long long nonAtomObj = atomObj;
```

Каждая функция-член принимает, помимо основного, ещё параметр, отвечающий за упорядочение доступа к памяти. По умолчанию используется значение `std::memory_order_seq_cst`, однако также можно явно передавать значения `std::memory_order_relaxed`, `std::memory_order_consume`, `std::memory_order_acquire`, `std::memory_order_release` или `std::memory_order_acq_rel`. Функции-члены [[#Операции compare_exchange_strong и compare_exchange_weak|compare_exchange_strong and compare_exchange_weak]] принимают два параметра, управляющих упорядочением доступа к памяти: один на случай успешного выполнения операции и второй – для неуспешного. Если в явном виде указать лишь один параметр, он будет использован в обоих случаях. [[sync and Memory model|Разные порядки доступа подробно рассмотрены тут]].

Конечно, не каждый атомарный тип поддерживает все эти операции. В следующей таблице показано, какие операции определены для каждой разновидности атомарных типов.

Поддержка операций атомарными типами

| Функция-член            | atomic_flag | `atomic<bool>`,<br>`atomic<user>`,<br>`atomic<smart<T>>` | `atomic <floating>` | `atomic<T*>` | `atomic <integral>` |
| ----------------------- | ----------- | -------------------------------------------------------- | ------------------- | ------------ | ------------------- |
| test_and_set            | +           |                                                          |                     |              |                     |
| clear                   | +           |                                                          |                     |              |                     |
| is_lock_free            |             | +                                                        | +                   | +            | +                   |
| is_always_lock_free     |             | +                                                        | +                   | +            | +                   |
| load                    |             | +                                                        | +                   | +            | +                   |
| operator T              |             | +                                                        | +                   | +            | +                   |
| store                   |             | +                                                        | +                   | +            | +                   |
| exchange                |             | +                                                        | +                   | +            | +                   |
| compare_exchange_strong |             | +                                                        | +                   | +            | +                   |
| compare_exchange_weak   |             | +                                                        | +                   | +            | +                   |
| fetch_add, +=           |             |                                                          | +                   | +            | +                   |
| fetch_sub, -=           |             |                                                          | +                   | +            | +                   |
| fetch_or, \|=           |             |                                                          |                     |              | +                   |
| fetch_and, &=           |             |                                                          |                     |              | +                   |
| fetch_xor, ^=           |             |                                                          |                     |              | +                   |
| ++, --                  |             |                                                          |                     |              | +                   |
| notify_one (C++20)      | +           | +                                                        | +                   | +            | +                   |
| notify_all (C++20)      | +           | +                                                        | +                   | +            | +                   |
| wait (C++20)            | +           | +                                                        | +                   | +            | +                   |

# Свободные функции над атомарными типами

К типу [[#std atomic_flag|std::atomic_flag]] и типам, получаемым из шаблона [[#std atomic|std::atomic]], можно применять также и ряд свободных (т. е. не являющихся членами класса) функций. Поскольку в этих функциях для передачи аргументов используются указатели, а не ссылки, они совместимы с языком C.

Свободные функции над типом [[#std atomic_flag|std::atomic_flag]] – это `std::atomic_clear`, `std::atomic_clear_explicit`, `std::atomic_flag_test_and_set` и `std::atomic_flag_test_set_explicit`. Первый аргумент у всех этих функций – указатель на объект [[#std atomic_flag|std::atomic_flag]]. Помимо того, две функции, имена которых оканчиваются на `_explicit`, принимают ещё один аргумент, который задаёт упорядочение доступа к памяти.

Для каждой функции-члена каждого типа, получаемого из шаблона [[#std atomic|std::atomic]], существует и соответствующая свободная функция. Имена этих функций строятся по одному и тому же простому шаблону: нужно всего лишь перед именем функции-члена поставить префикс `atomic_`. Например, функция-член `at.store` из шаблона [[#std atomic|std::atomic]] превращается в свободные функции `std::atomic_store` и `std::atomic_store_explicit`. Первая из них принимает один аргумент типа указателя, а вторая – ещё один аргумент, управляющий порядком доступа к памяти. Полный список перегруженных свободных функций над атомарными типами можно найти в справочнике1.

За единственным исключением, атомарные свободные функции определены только для атомарных типов. Исключение составляют функции над умными указателями [[shared_ptr|std::shared_ptr]].

### Особенности типа std::shared_ptr (до стандарта C++ 20)

Шаблон [[shared_ptr|std::shared_ptr]] представляет собой единственный неатомарный тип данных, для которого определены атомарные функции. Стоит сначала рассказать о причинах, по которым сделано это важное исключение. Комитет по стандартизации языка C++ счёл необходимым, чтобы умные указатели предоставляли хотя бы минимальные гарантии атомарности при многопоточном программировании. Что подразумевается под минимальными гарантиями атомарности со стороны типов `std::shared_ptr`? Блок служебных данных умного указателя `std::shared_ptr` потокобезопасен. Это означает, что инкремент и декремент счётчика ссылок – атомарные операции. Также гарантируется, что ресурс уничтожается ровно один раз.

Гарантии, предоставляемые типом `std::shared_ptr`, хорошо описаны в документации к библиотеке `Boost`:

1. Экземпляр `shared_ptr` можно «читать» (т. е. вызывать одни лишь константные операции) одновременно из нескольких потоков.
2. В различные экземпляры `shared_ptr` можно «писать» (т. е. вызывать модифицирующие операции наподобие `operator=` или `reset`) одновременно из нескольких потоков (даже если эти экземпляры представляют собой копии друг друга и имеют под собой общий счётчик ссылок)

Чтобы пояснить смысл этих двух утверждений, стоит привести пример. Снимать указатели [[shared_ptr|std::shared_ptr]] копии и отдавать их различным потокам – вполне нормально.

Потокобезопасное копирование умных указателей [[shared_ptr|std::shared_ptr]]:

```c++
std::shared_ptr<int> ptr = std::make_shared<int>(2011);

for (auto i = 0; i < 10; i++) {
	std::thread([ptr] {
				std::shared_ptr<int> localPtr(ptr);
				ptr = std::make_shared<int>(2014);
	}).detach();
}
```

Посмотрим на строку `std::shared_ptr<int> localPtr(ptr)`. Вызов конструктора копирования типа [[shared_ptr|std::shared_ptr]] при создании переменной `localPtr` затрагивает лишь блок служебных данных. Это потокобезопасно. Строка `ptr = std::make_shared<int>(2014)` несколько интереснее: указателю `ptr` присваивается новое значение. Однако и здесь проблем с точки зрения многопоточности не возникает: лямбда-функция в строке `std::thread([ptr]` захватывает переменную `ptr` по значению, поэтому модифицирующая операция применяется к копии.

Картина разительно меняется, если захватывать переменную по ссылке.

Гонка данных при работе с типом [[shared_ptr|std::shared_ptr]]:

```c++
std::shared_ptr<int> ptr = std::make_shared<int>(2011);

for (auto i = 0; i < 10; i++) {
	std::thread([&ptr] {
				ptr = std::make_shared<int>(2014);
	}).detach();
}
```

Лямбда-выражение в строке `std::thread([&ptr]` захватывает переменную `ptr` по ссылке. Это означает, что присваивание в строке `ptr = std::make_shared<int>(2014)` может привести к одновременному чтению и записи общих данных из нескольких потоков, поэтому программа в целом обладает неопределённым поведением.

Нужно признаться: построить этот последний пример оказалось нелёгким делом. Использование типа [[shared_ptr|std::shared_ptr]] в многопоточной среде требует особого внимания. Тип [[shared_ptr|std::shared_ptr]] – единственный неатомарный тип данных в стандарте языка C++, для которого определены атомарные операции.

#### Атомарные операции над типом std::shared_ptr

У атомарных операций `load`, `store`, `compare_and_exchange` существуют специализированные версии для типа [[shared_ptr|std::shared_ptr]]. Функции с именами, заканчивающимися на `_explicit`, позволяют дополнительно задавать порядок доступа к памяти. Ниже приведён список всех свободных атомарных функций над типом [[shared_ptr|std::shared_ptr]]

**Атомарные операции над типом [[shared_ptr|std::shared_ptr]]**:
```c++
std::atomic_is_lock_free(std::shared_ptr)
std::atomic_load(std::shared_ptr)
std::atomic_load_explicit(std::shared_ptr)
std::atomic_store(std::shared_ptr)
std::atomic_store_explicit(std::shared_ptr)
std::atomic_exchange(std::shared_ptr)
std::atomic_exchange_explicit(std::shared_ptr)
std::atomic_compare_exchange_weak(std::shared_ptr)
std::atomic_compare_exchange_strong(std::shared_ptr)
std::atomic_compare_exchange_weak_explicit(std::shared_ptr)
std::atomic_compare_exchange_strong_explicit(std::shared_ptr)
```

Подробное описание этих функций можно найти в справочнике ( #cppreferenc_com_w_cpp_memory_shared_ptr.). С их помощью потокобезопасная модификация умного указателя, переданного по ссылке, оказывается довольно простой.

**Устранение гонки данных при работе с типом [[shared_ptr|std::shared_ptr]]**:
```c++
std::shared_ptr<int> ptr = std::make_shared<int>(2011);

for (auto i = 0; i < 10; i++) {
	std::thread([&ptr] {
		auto localPtr= std::make_shared<int>(2014);
		std::atomic_store(&ptr, localPtr);
	}).detach();
}
```

Модификация переменной ptr типа [[shared_ptr|std::shared_ptr]] в выражении `std::atomic_store(&ptr, localPtr)` потокобезопасна. Всё ли теперь хорошо? Нет! Языку C++ нужны настоящие атомарные умные указатели.

# Шаблон класса std::atomic_ref в стандарте C++ 20

Шаблон класса `std::atomic_ref` позволяет применять атомарные операции через ссылку на объект. Таким образом, параллельно выполняемые над атомарным объектом операции чтения и записи не приводят к гонке данных. Время жизни объекта по ссылке должно превышать время жизни объекта типа `std::atomic_ref`. Доступ к подобъектам объекта, переданного через ссылку `atomic_ref`, однако, не имеет чётко определенного поведения.

## Мотивация

Здесь следует остановиться и подумать. На первый взгляд может показаться, что использования ссылки на объект атомарного типа было бы достаточно. К сожалению, это не так. В следующем примере объявляется класс `ExpensiveToCopy` с дорогой операцией копирования, в котором есть член `counter` (счётчик). Пусть несколько потоков параллельно наращивают значение счётчика. Тогда переменную-член `counter` нужно защитить от гонки данных.

Использование ссылки на атомарный объект:
```c++
// atomicReference.cpp

#include <atomic>
#include <iostream>
#include <random>
#include <thread>
#include <vector>

struct ExpensiveToCopy {
	int counter{};
};

int getRandom(int begin, int end) {

	std::random_device seed; // initial randomness
	std::mt19937 engine(seed()); // generator
	std::uniform_int_distribution <> uniformDist(begin, end);
	
	return uniformDist(engine);
}

void count(ExpensiveToCopy& exp) {
	std::vector<std::thread> v;
	std::atomic<int> counter{exp.counter};

	for (int n = 0; n < 10; ++n) {
		v.emplace_back([&counter] {
			auto randomNumber = getRandom(100, 200);
			for (int i = 0; i < randomNumber; ++i) 
				{ ++counter; }
		});
	}

	for (auto& t : v) 
		t.join();
}

int main() {
	std::cout << ‘\n’;
	
	ExpensiveToCopy exp;
	count(exp);
	std::cout << “exp.counter: “ << exp.counter << ‘\n’;
	
	std::cout << ‘\n’;
}
```

Переменная `exp`, объявленная в строке `ExpensiveToCopy exp`, представляет собой объект, который копировать слишком накладно. Для повышения производительности функция `count` принимает объект `exp` по ссылке. Функция `count` инициализирует переменную типа `std::atomic<int>` из поля `exp.counter`. Далее создаются десять потоков, в каждом из которых выполняется лямбда-выражение, принимающее ссылку на переменную `counter`.

Это лямбда-выражение берёт случайное число между 100 и 200 (строка `auto randomNumber = getRandom(100, 200)`) и соответствующее число раз увеличивает значение счётчика на единицу. 

Функция `getRandom` начинается с создания начального значения, затем с помощью генератора случайных чисел, известного как вихрь Мерсенна, вычисляется случайное число с равномерным распределением между 100 и 200.

В конце программы поле `exp.counter` должно иметь значение около 1500, поскольку каждый из десяти потоков прибавляет единицу к счётчику примерно по 150 раз. Однако выполнение этой программы с помощью интерактивного компилятора Wandbox даёт неожиданный результат:

![[ParallelProg_21.png]]

Счётчик равен нулю. Почему? Дело в строке `std::atomic<int> counter{exp.counter}`. Инициализация переменной в выражении `std::atomic<int> counter{exp.counter}` создаёт копию первоначального счётчика. Следующий небольшой фрагмент иллюстрирует проблему.

Копирование ссылки:
```c++
// atomicRefCopy.cpp

#include <atomic>
#include <iostream>

int main() {
	std::cout << ‘\n’;

	int val{5};
	int& ref = val;

	std::atomic<int> atomicRef(ref);
	++atomicRef;

	std::cout << “ref: “ << ref << ‘\n’;
	std::cout << “atomicRef.load(): “ << atomicRef.load() << ‘\n’;
	
	std::cout << ‘\n’;
}
```

Операция инкремента в строке `++atomicRef` не имеет отношения к ссылке, объявленной в строке `int& ref = val`. Значение по ссылке не меняется.

![[ParallelProg_22.png]]

Замена типа переменной `counter` с `std::atomic<int>` на `std::atomic_ref<int>`
решает проблему.

**Использование типа `std::atomic_ref<int>`**
```c++
//atomicReference.cpp

#include <atomic>
#include <iostream>
#include <random>
#include <thread>
#include <vector>

struct ExpensiveToCopy {
	int counter{};
};

int getRandom(int begin, int end) {
	std::random_device seed; // initial randomness
	std::mt19937 engine(seed()); // generator
	std::uniform_int_distribution<> uniformDist(begin, end);
	
	return uniformDist(engine);
}

void count(ExpensiveToCopy& exp) {
	std::vector<std::thread> v;
	std::atomic_ref<int> counter{exp.counter};

	for (int n = 0; n < 10; ++n) {
		v.emplace_back([&counter] {
			auto randomNumber = getRandom(100, 200);
			for (int i = 0; i < randomNumber; ++i) { ++counter; }
		});
	}

	for (auto& t : v) 
		t.join();
}

int main() {
	std::cout << ‘\n’;
	
	ExpensiveToCopy exp;
	count(exp);
	std::cout << “exp.counter: “ << exp.counter << ‘\n’;
	
	std::cout << ‘\n’;
}
```

Теперь программа выдаёт ожидаемый результат:

![[ParallelProg_23.png]]

Подобно шаблону [[#std atomic|std::atomic]], определены специализации шаблона `std::atomic_ref` для различных стандартных типов данных.

## Специализации шаблона std::atomic_ref

Шаблон `std::atomic_ref` позволяет подставлять пользовательские типы данных, а также обладает частичными специализациями для типов указателей и полными специализациями для арифметических типов, в частности целочисленных и вещественных с плавающей точкой.

### Основной вариант шаблона

Основное определение шаблона `std::atomic_ref` позволяет подставить в качестве параметра пользовательский тип `T` с тривиальным копированием, т. е. удовлетворяющий ограничению `TriviallyCopyable`. Например:
```c++
struct Counter {
	int a;
	int b;
};

Counter counter;
std::atomic_ref<Counter> cnt(counter);
```

### Частичные специализации для типов указателей

Стандартом определены частичные специализации шаблона для типов указателей: `std::atomic_ref<T*>`.

### Специализации для арифметических типов

В стандарте определены полные специализации для целочисленных типов и типов с плавающей точкой:

* символьные типы: `char`, `char8_t (C++20)`, `char16_t`, `char32_t` и `wchar_t`;
* стандартные целочисленные типы со знаком: `signed char`, `short int`, `long` и `long long`;
* стандартные целочисленные типы без знака: `unsigned char`, `unsigned short int`, `unsigned long` и `unsigned long long`;
* дополнительные целочисленные типы, определённые в заголовочном файле `<cstdint>`:
	- `int8_t`, `int16_t`, `int32_t`, `int64_t` (типы со знаком разрядностью ровно 8, 16, 32 и 64 бита соответственно);
	- `uint8_t`, `uint16_t`, `uint32_t`, `uint64_t` (беззнаковые типы разрядностью ровно 8, 16, 32 и 64 бита соответственно);
	- `int_fast8_t`, `int_fast16_t`, `int_fast32_t` и `int_fast64_t` (наиболее быстрые типы со знаком разрядностью не менее 8, 16, 32 и 64 бита соответственно);
	- `uint_fast8_t`, `uint_fast16_t`, `uint_fast32_t` и `uint_fast64_t` (наиболее быстрые типы без знака разрядностью не менее 8, 16, 32 и 64 бита соответственно);
	- `int_least8_t`, `int_least16_t`, `int_least32_t` и `int_least64_t` (типы со знаком с наименьшей доступной разрядностью не менее 8, 16, 32 и 64 бита соответственно);
	- `uint_least8_t`, `uint_least16_t`, `uint_least32_t` и `uint_least64_t` (типы без знака с наименьшей доступной разрядностью не менее 8, 16, 32 и 64 бита соответственно);
	- `intmax_t` и `uintmax_t` (знаковый и беззнаковый целочисленный типы с наибольшей доступной разрядностью);
	- `intptr_t` и `uintptr_t` (знаковый и беззнаковый целочисленный типы, позволяющие хранить значения указателей);
* стандартные типы с плавающей точкой: `float`, `double` и `long double`.

## Полный список атомарных операций

Ниже приведён полный перечень операций, поддерживаемых шаблоном `std::atomic_ref`.

| Функция-член                                     | Описание                                                                                                                                                                |
| ------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| is_lock_free                                     | Проверить, гарантирует ли объект работу без блокировок                                                                                                                  |
| is_always_lock_free                              | Проверить на этапе компиляции, гарантирует ли тип работу без блокировок                                                                                                 |
| load                                             | Атомарным образом вернуть значение                                                                                                                                      |
| operator T                                       | Атомарным образом вернуть значение эквивалентно операции<br>`atom.load()`                                                                                               |
| store                                            | Атомарным образом поместить в атомарную переменную новое значение                                                                                                       |
| exchange                                         | Атомарным образом поместить в атомарную переменную новое значение и вернуть её старое значение                                                                          |
| compare_exchange_strong<br>compare_exchange_weak | Атомарным образом сравнить значение атомарной переменной с заданным и в зависимости от результата сравнения обменять значение с неатомарной переменной.                 |
| fetch_add, +=<br>fetch_sub, -=                   | Атомарным образом увеличить (уменьшить) значение атомарной переменной на заданную величину                                                                              |
| fetch_or, \|=<br>fetch_and, &=<br>fetch_xor, ^=  | Атомарным образом выполнить над атомарной переменной и заданным значением соответствующую побитовую операцию (ИЛИ, И, исключающее ИЛИ)                                  |
| ++, --                                           | Пре- и постинкремент (декремент) атомарной переменной                                                                                                                   |
| notify_one (C++20)                               | Оповестить один ожидающий поток                                                                                                                                         |
| notify_all (C++20)                               | Оповестить все ожидающие потоки                                                                                                                                         |
| wait (C++20)                                     | Заблокировать поток до оповещения. При пробуждении сравнить текущее значение атомарной переменной со старым значением для предотвращения ложных и утерянных пробуждений |

Комбинированные операции присваивания возвращают новое значение переменной по ссылке, тогда как соответствующие им fetch-функции возвращают старое значение.

Каждая функция-член принимает, помимо основного, ещё параметр, отвечающий за упорядочение доступа к памяти. По умолчанию используется значение `std::memory_order_seq_cst`, однако также можно явно передавать значения `std::memory_order_relaxed`, `std::memory_order_consume`, `std::memory_order_acquire`, `std::memory_order_release` или `std::memory_order_acq_rel`. Функции-члены `compare_exchange_strong` и `compare_exchange_weak` принимают два параметра, управляющих упорядочением доступа к памяти: один на случай успешного выполнения операции и второй – для неуспешного. Если в явном виде указать лишь один параметр, он будет использован в обоих случаях.

Конечно, не каждая из этих операций поддерживается для любых типов данных, которые могут подставляться в качестве параметра в шаблон `std::atomic_ref`. В следующей таблице показана поддержка операций в зависимости от типа-параметра.

Поддержка операций шаблоном `std::atomic_ref` в зависимости от типа-параметра

| Функция                 | `atomic_ref<T>` | `atomic_ref`<br>`<floating>` | `atomic_ref<T*>` | atomic_ref<br>`<integral>` |
| ----------------------- | --------------- | ---------------------------- | ---------------- | -------------------------- |
| is_lock_free            | +               | +                            | +                | +                          |
| is_always_lock_free     | +               | +                            | +                | +                          |
| load                    | +               | +                            | +                | +                          |
| operator T              | +               | +                            | +                | +                          |
| store                   | +               | +                            | +                | +                          |
| exchange                | +               | +                            | +                | +                          |
| compare_exchange_strong | +               | +                            | +                | +                          |
| compare_exchange_weak   | +               | +                            | +                | +                          |
| fetch_add, +=           |                 | +                            | +                | +                          |
| fetch_sub, -=           |                 | +                            | +                | +                          |
| fetch_or, \|=           |                 |                              |                  | +                          |
| fetch_and, &=           |                 |                              |                  | +                          |
| fetch_xor, ^=           |                 |                              |                  | +                          |
| ++, --                  |                 |                              | +                | +                          |
| notify_one (C++20)      | +               | +                            | +                | +                          |
| notify_all (C++20)      | +               | +                            | +                | +                          |
| wait (C++20)            | +               | +                            | +                | +                          |

Атомарные переменные и атомарные операции играют роль основных строительных блоков, на которых основывается модель памяти. Они позволяют устанавливать требования к синхронизации и упорядочиванию доступа к памяти – ограничения, которые остаются в силе также и для неатомарных переменных. 

# std::atomic<std::shared_ptr>
#std_atomic_std_shared_ptr

# std::atomic<std::weak_ptr>
#std_atomic_std_weak_ptr



