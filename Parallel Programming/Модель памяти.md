
[[#Модель памяти|Модель памяти]] 11.3
1. [[#Недопустимость volatile-переменных для синхронизации|Недопустимость volatile-переменных для синхронизации]] 11.3.1
	1. [[#Совет избегать неблокирующего программирования|Совет избегать неблокирующего программирования]] 11.3.1.1
2. [[#Использование шаблонов неблокирующего программирования|Использование шаблонов неблокирующего программирования]] 11.3.2
3. [[#Использование гарантий, предоставляемых языком|Использование гарантий, предоставляемых языком]] 11.3.3
4. [[#Не нужно изобретать велосипед|Не нужно изобретать велосипед]] 11.3.4
	1. [[#Библиотека Boost.Lockfree|Библиотека Boost.Lockfree]] 11.3.4.1
	2. [[#Библиотека CDS|Библиотека CDS]] 11.3.4.2

# Модель памяти

В основе многопоточного программирования лежит хорошо определённая модель памяти. Понимание принципов работы памяти помогает лучше понять сложности многопоточного программирования и пути их преодоления.

## Недопустимость volatile-переменных для синхронизации

В отличие от языков C# и Java, в языке C++ семантика спецификатора [[volatile|volatile]] никак не связана с многопоточностью. В языках C# и Java спецификатор [[volatile|volatile]] похож на тип [[atomic#std atomic|std::atomic]] из стандартной библиотеки языка C++ и означает, что значение переменной может меняться независимо различными потоками. В языке C++ этот спецификатор означает лишь, что значение переменной может измениться независимо от хода выполнения программ. Следовательно, операции над этой переменной запрещается оптимизировать, например хранить её в буфере.

### Совет избегать неблокирующего программирования

Этот совет может показаться странным в книге, посвящённой параллельному программированию, особенно после того, как целая глава была посвящена моделям памяти и атомарным операциям. Причина проста. Неблокирующее программирование отличается крайней сложностью и высокой вероятностью допустить ошибку, оно требует от программиста чрезвычайно высокой квалификации. В частности, при реализации неблокирующих структур данных нужно опасаться так называемой проблемы ABA, о которой речь пойдёт в #разделе_13_1. Таким образом, без крайней необходимости и надлежащих умений эту область лучше не трогать.

## Использование шаблонов неблокирующего программирования

Если в программе обнаружено узкое место, устранить которое можно именно за счёт исключения блокировок, стоит применять общепринятые шаблоны неблокирующего программирования.

Использование атомарной переменной логического типа в качестве флага или атомарной целочисленной переменной в качестве счётчика вполне безопас­но и не требует предосторожностей.

Для реализации сценария «производитель–потребитель» следует пользоваться потокобезопасными и неблокирующими контейнерами. Если контейнер потокобезопасен, значения можно помещать и извлекать, не заботясь о синхронизации. Тем самым программист перекладывает сложности неблокирующего программирования на библиотеку.

## Использование гарантий, предоставляемых языком

Зачастую программист может вообще не тратить усилий на реализацию своих абстракций, если сам язык предоставляет необходимые гарантии. Например, были подробно рассмотрены различные [[Потокобезопасное создание объекта-одиночки#Потокобезопасное создание объекта-одиночки|способы потокобезопасной инициализации объекта]], находящегося в свободном доступе. Среди них упоминались константные выражения, статические переменные в области видимости, а также функция [[Thread_Safe initialization#Функция std call_once и флаг std once_flag|std::call_once вместе с флагом std::once_flag]]. Реализация, основанная на статической переменной, оказалась и самой эффективной, и самой лаконичной. Таким образом, сам язык предоставляет готовое решение, избавляя программиста от необходимости изобретать своё.

Программируя на языке C++, можно реализацию своих абстракций строить на атомарных переменных, с усложнённой логикой, основанной на семантике захвата и освобождения. Не нужно этого делать без крайней необходимости. К таким средствам стоит прибегать, только если обнаружено узкое место, измерена производительность критического пути и доказано, что решение, реализованное своими руками, превосходит по быстродействию встроенных средств языка.

## Не нужно изобретать велосипед

Создание потокобезопасных структур данных – довольно трудоёмкое занятие. Ещё труднее программировать неблокирующие структуры данных. Поэтому рекомендуется пользоваться существующими библиотеками: например, `Boost.Lockfree` и `CDS`.

### Библиотека Boost.Lockfree

Эта библиотека содержит три структуры данных.
* очередь с множественными поставщиками и множественными потребителями;
* стек с множественными поставщиками и множественными потребителями;
* свободная от ожиданий очередь с единственным поставщиком и единственным потребителем (также известная как кольцевой буфер).

### Библиотека CDS

Название библиотеки CDS означает Concurrent Data Structures – параллельные структуры данных. В неё входит ряд контейнеров, как владеющих своими элементами, так и не владеющих – в этом случае данные, необходимые для управления временем жизни, хранятся в самих элементах. Напомним, что контейнеры из стандартной библиотеки языка C++ владеют элементами, автоматически управляют их временем жизни и не хранят в элементах свои служебные данные. Среди контейнеров, входящих в библиотеку CDS, имеются:
* стек (неблокирующий);
* очереди и очереди с приоритетами (неблокирующие);
* упорядоченные списки;
* упорядоченные множества и ассоциативные массивы (как неблокирующие, так и с блокировками);
* неупорядоченные множества и ассоциативные массивы (как неблокирующие, так и с блокировками).
