
[[#Переменные условия]]
1. [[#Использование предиката в функции ожидания|Использование предиката в функции ожидания]] 3.5.1
2. [[#Утерянные и ложные пробуждения]] 3.5.2
3. [[#Процедура ожидания]] 3.5.3
4. [[#Новые перегрузки функции wait в классе std condition_variable_any|Новые перегрузки функции wait в классе std::condition_variable_any]]

# Переменные условия
#std_condition_variable

Переменные условия позволяют синхронизировать потоки посредством обмена сообщениями. Для их использования нужно подключить заголовочный файл `<condition_variable>`. Один поток выступает отправителем сообщения, а другой поток – получателем. Получатель ждёт, пока не придёт сообщение.

Чаще всего переменные условия применяются, когда нужно реализовать способ обработки данных по типу издателя и подписчика или производителя и потребителя. Переменная условия служит связующим звеном между отправителем и получателем сообщения.

**Функции-члены переменных условия:**

| **Функция**     | **Описание**                                                                                 |
| --------------- | -------------------------------------------------------------------------------------------- |
| `notify_one`    | Оповестить один ожидающий поток о наступлении события                                        |
| `notify_all`    | Оповестить все ожидающие потоки                                                              |
| `wait`          | Ожидать сообщения, держа блокировщик открытым                                                |
| `wait_for`      | Ожидать сообщения, держа блокировщик открытым, но не более заданного промежутка времени      |
| `wait_until`    | Ожидать сообщения, держа блокировщик открытым, но не более, чем до заданного момента времени |
| `native_handle` | Возвращает системный дескриптор переменной условия                                           |

Тонкое различие между функциями `notify_all` и `notify_one` состоит в том, что первая оповещает все потоки, ожидающие прихода сообщения, тогда как вторая оповещает только один из них. Следующий пример призван пояснить – перед тем как мы погрузимся в леденящие душу подробности, – что можно передавать в функцию `wait` последним аргументом.

**Использование переменных условия:**
```c++
// conditionVariable.cpp

#include <iostream>
#include <condition_variable>
#include <mutex>
#include <thread>

std::mutex mutex_;
std::condition_variable condVar;

bool dataReady{false};

void doTheWork(){
	std::cout << “Processing shared data.” << std::endl;
}

void waitingForWork(){
	std::cout << “Worker: Waiting for work.” << std::endl;
	
	std::unique_lock<std::mutex> lck(mutex_);
	
	condVar.wait(lck, []{ return dataReady; });
	
	doTheWork();

	std::cout << “Work done.” << std::endl;
 }

void setDataReady(){
	{
		std::lock_guard<std::mutex> lck(mutex_);
		dataReady = true;
	}
	std::cout << “Sender: Data is ready.” << std::endl;

	condVar.notify_one();
}

int main(){
	std::cout << std::endl;

	std::thread t1(waitingForWork);
	std::thread t2(setDataReady);

	t1.join();
	t2.join();
	
	std::cout << std::endl;
}
```

В этой программе создаются два дочерних потока, `t1` и `t2`. В них выполняются, соответственно, функции `waitingForWork` и `setDataReady` (строки `std::thread t1(waitingForWork)` и `std::thread t2(setDataReady)`).

Функция `setDataReady` оповещает – через переменную условия `condVar`, вызвав у неё функцию `notify_one`, – о завершении некоторой подготовительной работы. Тем временем поток-получатель `t1`, удерживая блокировку, начинает ожидание, для чего вызывает у переменной условия `condVar` функцию `wait`. Блокировщик [[mutex|мьютекса]] нужен как отправителю, так и получателю. При этом отправителю вполне довольно блокировщика [[lock#Тип std lock_guard|std::lock_guard]], так как захватить и отпустить [[mutex|мьютекс]] нужно только один раз. Получателю же необходим [[lock#Тип std unique_lock|блокировщик std::unique_lock]], поскольку функция `wait` может многократно захватывать и освобождать [[mutex|мьютекс]]. Ниже представлен пример работы этой программы.

> Следует подчеркнуть важную деталь: на момент начала ожидания, т. е. в момент вызова функции `wait` переменной условия, поток-получатель должен удерживать [[mutex|мьютекс]] захваченным; сама же функция `wait` проверяет условие и, если оно оказывается ложным, отпускает [[mutex|мьютекс]] и переводит поток в режим ожидания. Функция `wait` повторно захватывает [[mutex|мьютекс]] в момент пробуждения, когда через переменную условия приходит оповещение. Предикат (второй аргумент функции `wait`) проверяется при захваченном [[mutex|мьютексе]]. Если проверка проходит, функция `wait` завершается, [[mutex|мьютекс]] остаётся захваченным, и выполнение потока-получателя продолжается. В противном случае функция `wait` снова освобождает [[mutex|мьютекс]] и погружает поток в ожидание. Таким образом, поток-отправитель имеет возможность захватить [[mutex|мьютекс]] для себя и выполнять свою работу над общими данными. Когда эта работа сделана, он вместе с оповещением через переменную условия отдаёт и [[mutex|мьютекс]], тем самым давая потоку-получателю возможность доступа к общим данным как для проверки предиката, так и для последующей их обработки. 

![[ParallelProg_68.png]]

> **Тип `std::condition_variable_any`**
>
> Условные переменные типа `std::condition_variable` могут использовать для ожидания только блокировщики типа [[lock#Тип std unique_lock|std::unique_lock<mutex>]]; более общий тип `std::condition_variable_any`, обладающий тем же интерфейсом, допускает любые пользовательские типы, подпадающие под понятие `BasicLockable`.

## Использование предиката в функции ожидания

Возможно, интересно узнать, зачем передавать предикат вторым аргументом в функцию `wait`, ведь этот параметр необязателен. Рассмотрим пример.

**Бесконечное ожидание переменной условия без предиката:**
```c++
// conditionVariableBlock.cpp

#include <iostream>
#include <condition_variable>
#include <mutex>
#include <thread>

std::mutex mutex_;
std::condition_variable condVar;

void waitingForWork() {
	std::cout << “Worker: Waiting for work.” << std::endl;
	
	std::unique_lock<std::mutex> lck(mutex_);
	
	condVar.wait(lck);

	// do the work
	
	std::cout << “Work done.” << std::endl;
}

void setDataReady() {
	std::cout << “Sender: Data is ready.” << std::endl;
	
	condVar.notify_one();
}

int main() {
	std::cout << std::endl;
	
	std::thread t1(setDataReady);
	std::thread t2(waitingForWork);
	
	t1.join();
	t2.join();
	
	std::cout << std::endl;
}
```

При первом запуске программа отработала нормально. Однако на втором запуске она зависла, так как отсылка оповещения одним потоком (строка `condVar.notify_one()`) произошла раньше, чем второй поток вошёл в режим ожидания (строка `condVar.wait(lck)`).

![[ParallelProg_69.png]]

Теперь всё становится ясно. Предикат наделяет переменную условия состоянием. Функция ожидания всегда должна сначала проверить истинность предиката. Предикат, таким образом, помогает бороться с двумя известными слабыми местами переменных условия: утерянным пробуждением и ложным пробуждением.

## Утерянные и ложные пробуждения

**Утерянным пробуждением** называется ситуация, когда поток-отправитель успевает послать оповещение до того, как получатель начинает его ожидать. Как следствие оповещение оказывается утерянным. В стандарте языка C++ переменные условия описаны как механизм одновременной синхронизации:

«Класс `condition_variable` – это примитив синхронизации, который можно использовать для блокировки потока или нескольких потоков одновременно». В случае потерянного оповещения потоку-получателю остаётся ждать, ждать, ждать…

**Ложное пробуждение** – это пробуждение ожидающего потока, когда отправители никаких оповещений не посылали. По меньшей мере потоки `POSIX2` и `API` системы Windows обладают этим недостатком. Одна из причин такого явления – похищенное пробуждение: перед тем как пробуждённый поток-адресат получает шанс запуститься, другой поток успевает вклиниться первым и начинает выполнение.

## Процедура ожидания

Ожидающий поток работает по довольно сложному алгоритму. Приведём две самые важные строки из рассмотренного ранее примера `conditionVariable.cpp`:
```c++
std::unique_lock<std::mutex> lck(mutex_);
condVar.wait(lck, []{ return dataReady; });
```

Эти две строки эквивалентны следующему коду:
```c++
std::unique_lock<std::mutex> lck(mutex_);

while ( ![]{ return dataReady; }() ) {
	condVar.wait(lck);
}
```

Прежде всего необходимо различать, для чего служат блокировка [[mutex|мьютекса]] созданием объекта `lck` и последующее ожидание оповещения функцией `wait`.

 * В самом начале поток захватывает [[mutex|мьютекс]], тем самым получая исключительное право доступа к общим данным, и проверяет предикат – в данном случае просто отрицание переменной `dataReady`:
	– если предикат даёт значение `true`, поток продолжает свою работу;
	– если предикат даёт значение `false`, функция `wait` освобождает [[mutex|мьютекс]] и переводит поток в состояние ожидания.

* Функция `wait` переменной условия блокирует поток до тех пор, пока через переменную условия не придёт оповещение или пока не произойдёт ложное пробуждение. Вслед за этим выполняется такая последовательность действий:
	– поток просыпается и заново захватывает [[mutex|мьютекс]];
	– проверяется предикат:
		* если предикат даёт значение `true`, поток продолжает свою работу;
		* если предикат даёт значение `false`, функция `wait` освобождает [[mutex|мьютекс]] и переводит поток в состояние ожидания.

Даже если все общие данные потоков состоят из единственной [[atomic|атомарной переменной]], её изменение должно происходить под [[mutex|мьютексом]], чтобы корректно передавать обновлённые данные ожидающему потоку.

> **Необходимость мьютекса**
>
>Даже если переменную `dataReady` в этом примере сделать [[atomic|атомарной]], её модификацию нужно прикрыть [[mutex|мьютексом]]. В противном случае изменение её значения хоть и станет видимым для ожидающего потока, но это обновление может неправильно синхронизироваться. В итоге состояние гонок может привести к мёртвой блокировке. Что это означает – видимое, но некорректно синхронизированное изменение?
>
> Рассмотрим в подробностях процедуру ожидания в предположении, что переменная `dataReady` атомарна, а её изменение не защищено [[mutex|мьютексом]].
> 
> Тогда оповещение может прийти в тот момент, когда переменная условия `condVar` ещё не начала его ожидать. Иными словами, оповещение может прийти после того, как завершена проверка предиката, но до вызова функции `wait`. В этом случае оповещение теряется, а поток-получатель, скорее всего, будет вечно спать, ожидая оповещения.
> 
> Этого бы не случилось, если бы переменная `dataReady` изменяла своё значение под защитой [[mutex|мьютекса]]. Благодаря синхронизации оповещение могло бы быть отправлено только после того, как поток-получатель перешёл в состояние ожидания.

В большинстве случаев [[task|задания (task)]] предоставляют менее подверженный ошибкам механизм синхронизации. 

## Новые перегрузки функции wait в классе std::condition_variable_any

Класс `std::condition_variable_any` представляет собой расширенный вариант класса [[#Переменные условия|std::condition_variable]]. Объекты класса [[#Переменные условия|std::condition_variable]] требуют для работы исключительно [[lock|блокировщиков]] типа [[lock#Тип std unique_lock|std::unique_lock<std::mutex>]], тогда как тип `std::condition_variable_any` может работать с любым типом блокировщика, поддерживающим функции-члены `lock` и `unlock`.

У трёх знакомых по предыдущим разделам функций-членов: `wait`, `wait_for` и `wait_until` – появляются в классе `std::condition_variable_any` новые перегрузки, принимающие аргумент типа [[Кооперативное прерывание потоков#Класс std stop_token|std::stop_token]].

**Новые перегрузки функций ожидания:**
```c++
template <class Predicate>

bool wait(
	Lock& lock,
	stop_token stoken,
	Predicate pred);

template <class Rep, class Period, class Predicate>

bool wait_for(
	Lock& lock,
	stop_token stoken,
	const chrono::duration<Rep, Period>& rel_time,
	Predicate pred);

template <class Clock, class Duration, class Predicate>
bool wait_until(
	Lock& lock,
	stop_token stoken,
	const chrono::time_point<Clock, Duration>& abs_time,
	Predicate pred);
```

Новым перегрузкам требуется предикат в качестве обязательного аргумента. Эти функции сначала проверяют, запрошен ли останов потока через объект [[Кооперативное прерывание потоков#Класс std stop_token|std::stop_token]]. Три новые функции возвращают значение, которое даёт вычисление предиката. При этом возвращаемое значение не зависит от того, был ли запрошен останов потока, как и от истечения предельного времени ожидания. Новые перегрузки эквивалентны следующим фрагментам кода.

**Возможные реализации трёх новых перегрузок:**
```c++
// функция wait
while (!stoken.stop_requested()) {
	if (pred()) 
		return true;

	wait(lock);
}
return pred();

// функция wait_for
return wait_until(
	lock,
	std::move(stoken),
	chrono::steady_clock::now() + rel_time,
	std::move(pred));

// функция wait_until
while (!stoken.stop_requested()) {
	if (pred()) 
		return true;

	if (wait_until(lock, timeout_time) == std::cv_status::timeout)
		return pred();
}
return pred();
```

После обращения к функции `wait` можно проверить, был ли запрос на останов потока.

**Обработка прерывания потока с помощью функции `wait`**
```c++
cv.wait(lock, stoken, predicate);
if (stoken.stop_requested()){
	// interrupt occurred
}
```

В следующем примере показано использование переменной условия совместно с механизмом прерывания потока.

**Использование переменной условия с запросом на прерывание потока**
```c++
// conditionVariableAny.cpp

#include <condition_variable>
#include <thread>
#include <iostream>
#include <chrono>
#include <mutex>
#include <thread>

using namespace std::literals;

std::mutex mut;
std::condition_variable_any condVar;

bool dataReady;

void receiver(std::stop_token stopToken) {
	std::cout << “Waiting” << ‘\n’;

	std::unique_lock<std::mutex> lck(mut);
	bool ret = condVar.wait(lck, stopToken, []{return dataReady;});
	if (ret){
		std::cout << “Notification received: “ << ‘\n’;
	}
	else{
		std::cout << “Stop request received” << ‘\n’;
	}
}

void sender() {
	std::this_thread::sleep_for(5ms);
	
	{
		std::lock_guard<std::mutex> lck(mut);
		dataReady = true;
		std::cout << “Send notification” << ‘\n’;
	}
	
	condVar.notify_one();
}

int main(){
	std::cout << ‘\n’;

	std::jthread t1(receiver);
	std::jthread t2(sender);

	t1.request_stop();

	t1.join();
	t2.join();

	std::cout << ‘\n’;
}
```

Поток-получатель (строки `void receiver(std::stop_token stopToken) { ... }`) ждёт оповещения от потока-отправителя (строки `void sender() { ... }`). Перед тем как поток-отправитель посылает оповещение в строке `condVar.notify_one();`, главный поток успевает в строке `t1.request_stop();` потребовать остановки потока. Вывод программы свидетельствует о том, что запрос на останов происходит ранее, чем оповещение о готовности данных.

![[ParallelProg_74.png]]



