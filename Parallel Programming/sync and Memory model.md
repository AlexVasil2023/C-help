[[#Синхронизация и порядок доступа к памяти]] 2.4
1. [[#Шесть вариантов модели памяти в языке C++|Шесть вариантов модели памяти в языке C++]] 2.4.1
	1. [[#Виды атомарных операций]] 2.4.1.1
	2. [[#Ограничения на синхронизацию и порядок доступа]] 2.4.1.2
2. [[#Последовательно-согласованное выполнение]] 2.4.2
3. [[#Семантика захвата и освобождения|Семантика захвата и освобождения]] 2.4.3
	1. [[#Транзитивность]] 2.4.3.1
	2. [[#Типичное недоразумение|Типичное недоразумение]] 2.4.3.2
		1. [[#Цикл ожидания присутствует|Цикл ожидания присутствует]] 2.4.3.2.1
		2. [[#Если…|Если…]] 2.4.3.2.2
		3. [[#Решение|Решение]] 2.4.3.2.3
	3. [[#Последовательность освобождений|Последовательность освобождений]] 2.4.3.3
4. [[#Модель памяти std memory_order_consume|Модель памяти std::memory_order_consume]] 2.4.4
	1. [[#Порядок захвата и освобождения]] 2.4.4.1
	2. [[#Порядок освобождения и потребления]] 2.4.4.2
	3. [[#Различие порядков «освобождение-захват» и «освобождение-потребление»]] 2.4.4.3
	4. [[#Зависимости данных в модели std memory_order_consume|Зависимости данных в модели std::memory_order_consume]] 2.4.4.4
5. [[#Ослабленная семантика|Ослабленная семантика]] 2.4.5
	1. [[#Отсутствие ограничений на синхронизацию и порядок операций|Отсутствие ограничений на синхронизацию и порядок операций]] 2.4.5.1
	2. 
6. 


# Синхронизация и порядок доступа к памяти

Невозможно каким-либо образом настроить поведение атомарного типа данных, однако у атомарных операций можно настраивать ограничения, связанные с синхронизацией и порядком доступа к памяти. Возможность изменять параметры синхронизации и порядка доступа составляет исключительную особенность языка C++; модель памяти, принятая в языках C# и Java, этого делать не позволяет.

В языке C++ имеется шесть вариантов модели памяти. Чрезвычайно важно понимать их отличительные черты.

## Шесть вариантов модели памяти в языке C++

Способов упорядочения доступа к памяти в языке C++ имеется шесть. По умолчанию в атомарных операциях используется порядок `std::memory_order_seq_cst`. Его название означает «последовательная согласованность» (англ. sequential consistency). Кроме того, можно в явном виде указать какой-либо из оставшихся пяти порядков. Какие же варианты существуют в языке C++?

Порядки доступа к памяти
```c++
enum memory_order {
	memory_order_relaxed,
	memory_order_consume,
	memory_order_acquire,
	memory_order_release,
	memory_order_acq_rel,
	memory_order_seq_cst
}
```

Чтобы разобраться в этих шести способах упорядочивания доступа к памяти, стоит ответить на два вопроса:

1. Какой порядок доступа к памяти следует использовать для тех или иных видов атомарных операций?
2. Какие ограничения на синхронизацию и порядок доступа к памяти накладываются в каждой из шести моделей?

Наш план прост: ответить на оба вопроса.

### Виды атомарных операций

Существует три вида атомарных операций:

* операции чтения – с ними применяются порядки `memory_order_acquire` и `memory_order_consume`;
* операции записи, с которыми нужно использовать порядок `memory_order_release`;
* операции чтения-модификации-записи, для которых подходят порядки `memory_order_acq_rel` и `memory_order_seq_cst`.

Вариант `memory_order_relaxed` вообще не накладывает ограничений на синхронизацию и порядок доступа к памяти. Он не вписывается в рассматриваемую классификацию.

В следующей таблице атомарные операции разделены по типам в соответствии с тем, осуществляют они чтение или запись.

| Функция                 | Чтение | Запись | Чтение-модификация-запись |
| ----------------------- | ------ | ------ | ------------------------- |
| test_and_set            |        |        | +                         |
| clear                   |        | +      |                           |
| is_lock_free            | +      |        |                           |
| load                    | +      |        |                           |
| operator T              | +      |        |                           |
| store                   |        | +      |                           |
| exchange                |        |        | +                         |
| compare_exchange_strong |        |        | +                         |
| compare_exchange_weak   |        |        | +                         |
| fetch_add, +=           |        |        | +                         |
| fetch_sub, -=           |        |        | +                         |
| fetch_or, \|=           |        |        | +                         |
| fetch_and, &=           |        |        | +                         |
| fetch_xor, ^=           |        |        | +                         |
| ++, --                  |        |        | +                         |
| notify_one              |        | +      |                           |
| notify_all              |        | +      |                           |
| wait                    | +      |        |                           |

Операции чтения-модификации-записи предоставляют ещё одну дополнительную гарантию: они всегда работают с самым новым значением переменной. Это означает, например, что многократные вызовы вида `atomVar.fetch_sub` из различных потоков дают убывающую последовательность чисел без дублирующихся или пропущенных значений.

Если в операции атомарного чтения вида `atomVar.load()` использовать модель памяти, предназначенную для операций записи или чтения-модификации-записи, то часть модели памяти, относящаяся к записи, не сыграет никакой роли. Например, вызов `atomVar.load(std::memory_order_acq_rel)` ведёт себя так же, как и вызов `atomVar.load(std::memory_order_acquire)`. Подобным же образом вызов `atomVar.load(std::memory_order_release)` эквивалентен вызову `atomVar.load(std::memory_order_relaxed)`.

### Ограничения на синхронизацию и порядок доступа

Говоря упрощённо, в языке C++ определены три различных ограничения на синхронизацию и порядок доступа:

* последовательно-согласованное выполнение (`memory_order_seq_cst`);
* синхронизация захвата и освобождения (`memory_order_consume`, `memory_order_acquire`, `memory_order_release` и `memory_order_acq_rel`);
* ослабленная синхронизация (`memory_order_relaxed`).

Если последовательно-согласованное выполнение устанавливает глобальный порядок для всех операций, выполняемых всеми потоками, то семантика захвата и освобождения требует лишь синхронизации операций чтения с операциями записи, выполняемыми из различных потоков над одной и той же атомарной переменной. Ослабленная семантика гарантирует только упорядоченную модификацию некоторой атомарной переменной `m`. Упорядоченная модификация означает лишь, что все модификации данной атомарной переменной `m` образуют некоторую вполне упорядоченную последовательность. Это значит, что операции чтения атомарного объекта из какого-нибудь потока никогда не увидят значений, более старых, чем те, что поток уже успел увидеть.

Разнообразие моделей памяти и влияний, которые они оказывают на атомарные и неатомарные операции, делает модель памяти языка C++ увлекательным и сложным предметом. Рассмотрим подробнее ограничения на синхронизацию и порядок доступа к памяти, присущие последовательно-согласованной семантике, семантике захвата и освобождения и ослабленной семантике.

## Последовательно-согласованное выполнение

Познакомимся глубже с последовательной согласованностью. Ключевую роль здесь играет то обстоятельство, что все операции во всех потоках выполняются как бы по единым часам. Наличие глобальных часов делает эту модель памяти интуитивно понятной.

Интуитивная очевидность последовательно-согласованного выполнения имеет, однако, свою цену. Система должна синхронизировать потоки между собой.

Ниже показан пример программы, которая синхронизирует потоки производителя и потребителя, используя для этого семантику последовательной согласованности.

Синхронизация производителя и потребителя на основе последовательной согласованности:

```c++
// producerConsumer.cpp

#include <atomic>

std::string work;
std::atomic<bool> ready(false);

void consumer() {
	while(!ready.load()) {}
	
	std::cout<< work << std::endl;
}

void producer() {
	work = “done”;
	ready = true;
}

int main() {
	std::thread prod(producer);
	std::thread con(consumer);

	prod.join();
	con.join();
}
```

Результат выполнения этой программы может показаться не слишком впечатляющим.

![[ParallelProg_24.png]]

Благодаря последовательно-согласованному выполнению операций поведение программы детерминировано. Она всегда печатает сообщение «done» (с англ. «сделано»).

На следующем рисунке показана последовательность выполнения операций. Поток-потребитель ожидает в цикле до тех пор, пока в атомарной переменной `ready` не окажется значение `true`. После этого поток-потребитель продолжает свою работу.

![[ParallelProg_26.png]]

Нетрудно понять, что программа всегда печатает сообщение `«done»`. Нужно лишь привлечь две главные черты последовательно-согласованной семантики. С одной стороны, оба потока выполняют свои операции в том порядке, в котором они указаны в исходном коде. С другой стороны, каждый поток видит результат выполнения операций другим потоком в том же порядке, в котором тот их выполнил. Оба потока работают по одним и тем же глобальным часам. Таким образом, конструкция `while(!ready.load()){}` обеспечивает синхронизацию потоков производителя и потребителя.

Это рассуждение можно провести более формальным образом, если воспользоваться терминологией, принятой для порядка доступа к памяти.

1. `work= «done»` располагается прежде `ready = true`. Следовательно, `work= «done»` происходит прежде `ready = true`.
2. `while(!ready.load()){}` располагается прежде `std::cout << work << std::endl`. Следовательно, `while(!ready.load()){}` происходит прежде `std::cout<< work << std::endl`.
3. `ready = true` синхронизировано с `while(!ready.load()){}`. Следовательно, `ready = true` происходит между потоками прежде `while(!ready.load()){}`. Следовательно, `ready = true` происходит прежде `while (!ready.load()){}`.

В силу транзитивности отношения предшествования отсюда следует, что `work = «done»` происходит прежде, чем `ready = true`, затем происходит `ready = true`, далее `while (!ready.load()){}`, после чего происходит `std::cout << work << std::endl`.

В модели последовательной согласованности каждый поток видит результаты операций, выполняемых любым другим потоком (а значит, и всех потоков вместе взятых) в одном и том же порядке. Эта важнейшая особенность последовательно согласованного выполнения не имеет места, если атомарные операции выполняются в соответствии с семантикой захвата и освобождения. Семантика захвата и освобождения – это область, в которую языки C# и Java не вторгаются. Также это область, в которой наша интуиция начинает давать сбои.

## Семантика захвата и освобождения

При семантике захвата и освобождения нет глобальной синхронизации между всеми потоками; синхронизируются лишь атомарные операции над одной и той же атомарной переменной. Операция записи в некоторую атомарную переменную, выполняемая одним потоком, синхронизируется с операцией чтения из этой же переменной в другом потоке.

Семантика захвата и освобождения основывается на одном ключевом правиле: операция освобождения атомарной переменной синхронизируется с операцией захвата этой же переменной – тем самым устанавливается ограничение на порядок их выполнения. Ограничение это состоит в том, что никакие операции чтения и записи атомарной переменной не могут быть перемещены после операции освобождения; никакие операции чтения и записи атомарной переменной не могут быть перемещены ранее операции захвата.

Что такое операции захвата и освобождения? Чтение из атомарной переменной посредством функций `load` или `test_and_set` – это операция захвата.

Но это ещё не всё: освобождение мьютекса синхронизируется с захватом этого мьютекса другим потоком. Создание потока синхронизируется с запуском выполняемого объекта в этом потоке. Завершение потока синхронизируется с вызовом функции-члена `join` для этого потока. Завершение выполняемого объекта, обёрнутого в задание, синхронизируется с вызовом функции `wait` или `get` этого задания. Операции захвата и освобождения всегда появляются парами.

Будет полезным понять следующую диаграмму.

![[ParallelProg_27.png]]

> Вот и ещё одна причина, по которой следует помнить модели памяти. Семантика захвата и освобождения помогает лучше понять примитивы синхронизации высокого уровня, например мьютекс. Та же логика подходит и для запуска потока с последующим вызовом функции-члена `join`. В обоих случаях имеют место операции захвата и освобождения. Эту линию продолжают и операции `wait` и `notify_one` для переменной условия: функция-член `wait` представляет собой захват, а функция-член `notify_one` – освобождение. Чем тогда является функция-член `notify_all`? Это тоже операция освобождения.

Рассмотрим ещё раз пример с циклом ожидания из раздела, посвящённого типу [[atomic#std atomic_flag|std::atomic_flag]]. Его можно реализовать более эффективным образом, так как в основе реализации лежит переменная типа [[atomic#std atomic_flag|std::atomic_flag]], к которой применима семантика захвата и освобождения.

Цикл ожидания на основе семантики захвата и освобождения
```c++
// spinlockAcquireRelease.cpp

#include <atomic>
#include <thread>

class Spinlock{
		std::atomic_flag flag;
	public:
		Spinlock(): flag(ATOMIC_FLAG_INIT) {}

		void lock() {
			while(flag.test_and_set(std::memory_order_acquire));
		}

		void unlock() {
			flag.clear(std::memory_order_release);
		}
};

Spinlock spin;

void workOnResource() {
	spin.lock();
	// shared resource
	spin.unlock();
}

int main() {
	std::thread t(workOnResource);
	std::thread t2(workOnResource);
	
	t.join();
	t2.join();
}
```

Вызов `flag.clear` в строке `flag.clear(std::memory_order_release)` представляет собой операцию освобождения, а вызов `flag.test_and_set` – операцию захвата, а захват синхронизируется с освобождением. Тяжеловесная синхронизация потоков на основе последовательной согласованности (`std::memory_order_seq_cst`) заменяется более лёгкой и быстрой семантикой захвата и освобождения (`std::memory_order_acquire` и `std::memory_order_release`). Поведение программы при этом не изменяется.

Хотя вызов `flag.test_and_set`(Атомарным образом установить значение флага в `true` и вернуть предыдущее значение) и представляет собой операцию чтения-модификации-записи, в данном случае для неё довольно семантики захвата. В общем итоге: переменная `flag` атомарна и потому гарантирует строгий порядок модификаций. Это означает, что все модификации над переменной `flag` происходят в определённом порядке, и этот порядок полон.

Порядок выполнения, налагаемый семантикой захвата и освобождения, транзитивен. Это значит, что если между потоками `a` и `b` установлено отношение захвата и освобождения, и если отношение захвата и освобождения существует между потоками `b` и `c`, то это отношение имеет место и между потоками `a` и `c`.

### Транзитивность

Операция освобождения синхронизируется с операцией захвата этой же атомарной переменной, и между ними устанавливается ограничение на порядок выполнения. Этого хватает, чтобы синхронизировать потоки, если они работают с одной и той же атомарной переменной. Однако как быть, если у двух потоков нет доступа к общей атомарной переменной? Не хотелось бы использовать семантику последовательной согласованности из-за чрезмерных накладных расходов, хорошо было бы заменить её легковесной семантикой захвата и освобождения.

Ответ вполне очевиден. Синхронизировать не связанные между собой потоки можно, если воспользоваться транзитивностью семантики захвата и освобождения.

В следующем примере поток `t2`, выполняющий функцию `deliveryBoy` (с англ. «разносчик»), служит связующим звеном между потоками `t1` и `t3`.

Транзитивность в семантике захвата и освобождения:
```c++
// transitivity.cpp

#include <atomic>
#include <iostream>
#include <thread>
#include <vector>

std::vector<int> mySharedWork;
std::atomic<bool> dataProduced(false);
std::atomic<bool> dataConsumed(false);

void dataProducer() {
	mySharedWork = {1,0,3};
	dataProduced.store(true, std::memory_order_release);
}

void deliveryBoy() {
	while(!dataProduced.load(std::memory_order_acquire));
	
	dataConsumed.store(true, std::memory_order_release);
}

void dataConsumer() {
	while(!dataConsumed.load(std::memory_order_acquire));
	
	mySharedWork[1] = 2;
}

int main() {
	std::cout << std::endl;
	
	std::thread t1(dataConsumer);
	std::thread t2(deliveryBoy);
	std::thread t3(dataProducer);
	
	t1.join();
	t2.join();
	t3.join();

	for (auto v: mySharedWork) {
		std::cout << v << “ “;
	}

	std::cout << “\n\n”;
}
```

Результат работы этой программы детерминирован: переменная-контейнер `mySharedWork` содержит значения 1, 2 и 3.

![[ParallelProg_28.png]]

Два обстоятельства играют здесь ключевую роль:

1) поток `t2` в строке `while(!dataProduced.load(std::memory_order_acquire))` ждёт, пока поток `t3` поставит переменную `dataProduced` в значение `true` в строке `dataProduced.store(true, std::memory_order_release);`;
2) поток `t1` в строке `while(!dataConsumed.load(std::memory_order_acquire))` ждёт, пока поток `t2` поставит переменную `dataConsumed` в значение `true` в строке `dataConsumed.store(true, std::memory_order_release);`.

Остальное легко пояснить графически.

![[ParallelProg_29.png]]

Самое важное на этом рисунке – стрелки.

* Голубые стрелки изображают отношение «располагается перед». Оно означает, что все операции в пределах одного потока выполняются в том порядке, в котором они расположены в исходном коде.
* Красные стрелки – это отношения «синхронизируется с». Это отношение имеет место потому, что им связаны операции над одной и той же атомарной переменной в семантике захвата и освобождения. Синхронизация действий над атомарными переменными и, следовательно, синхронизация потоков выполняется в особых местах кода.
* Отношение «располагается перед» влечёт за собой отношение «происходит ранее», а отношение «синхронизируется с» влечёт отношение «происходит ранее между потоками».

Остались сущие мелочи. Порядок операций «происходит ранее» и «происходит ранее между потоками» соответствует направлению стрелок сверху вниз. Наконец, мы установили гарантию, что операция `mySharedWork[1] == 2` выполнится последней.

Операция освобождения синхронизируется с операцией захвата той же атомарной переменной, поэтому можно легко синхронизировать между собой потоки, если… Именно с этим «если» связано распространённое недоразумение.

### Типичное недоразумение

Зачем посвящать особый раздел неправильному пониманию захвата и освобождения? Дело в том, что многие читатели и студенты автора уже попадались в эту ловушку. Рассмотрим простой пример.

#### Цикл ожидания присутствует

Начнём с простой программы.

Захват и освобождение с ожиданием
```c++
// acquireReleaseWithWaiting.cpp

#include <atomic>
#include <iostream>
#include <thread>
#include <vector>

std::vector<int> mySharedWork;
std::atomic<bool> dataProduced(false);

void dataProducer() {
	mySharedWork = {1, 0, 3};
	dataProduced.store(true, std::memory_order_release);
}

void dataConsumer() {
	while( !dataProduced.load(std::memory_order_acquire) );
	
	mySharedWork[1] = 2;
}

int main() {
	std::cout << std::endl;
	std::thread t1(dataConsumer);
	std::thread t2(dataProducer);
	
	t1.join();
	t2.join();

	for (auto v: mySharedWork) {
		std::cout << v << “ “;
	}

	std::cout << “\n\n”;
}
```

Поток-потребитель `t1` в строке `while( !dataProduced.load (std::memory_order_acquire) )` ожидает, пока поток-производитель `t2`
в строке `dataProduced.store(true, std::memory_order_release)` установит переменную `dataProduced` в значение `true`. Переменная играет роль стражника, который гарантирует, что доступ к неатомарной переменной `mySharedWork` из разных потоков синхронизирован. Синхронизация в данном примере означает, что сначала поток-производитель `t2` инициализирует переменную `mySharedWork`, а лишь затем поток-потребитель `t1` подхватывает работу с этой переменной, присваивая элементу `mySharedWork[1]` значение `2`. В целом поведение программы вполне определено.

![[ParallelProg_30.png]]

На следующем рисунке показаны отношения «происходит ранее» в пределах потока и отношения «синхронизируется с» между потоками. При этом отношение «синхронизируется с» влечёт за собой отношение «происходит ранее между потоками». Оставшаяся часть рассуждения сводится к транзитивности отношения «происходит ранее».

В конечном итоге получаем, что операция `mySharedWork = {1, 0, 3}` происходит ранее, чем операция `mySharedWork[1] = 2`.

![[ParallelProgr_31.png]]

Какую деталь часто упускают из виду, рассуждая о поведении подобных программ? Это то самое «если», о котором говорилось выше.

#### Если…

Что произойдёт, если поток-потребитель `t1` в строке `while( !dataProduced.load (std::memory_order_acquire) )` не станет ждать потока-производителя `t2`?

Захват и освобождение без ожидания:
```c++
// acquireReleaseWithoutWaiting.cpp

#include <atomic>
#include <iostream>
#include <thread>
#include <vector>

std::vector<int> mySharedWork;
std::atomic<bool> dataProduced(false);

void dataProducer() {
	mySharedWork = {1, 0, 3};
	dataProduced.store(true, std::memory_order_release);
}

void dataConsumer() {
	dataProduced.load(std::memory_order_acquire);
	mySharedWork[1] = 2;
}

int main() {
	std::cout << std::endl;
	
	std::thread t1(dataConsumer);
	std::thread t2(dataProducer);
	
	t1.join();
	t2.join();

	for (auto v: mySharedWork){
		std::cout << v << “ “;
	}
	
	std::cout << “\n\n”;
}
```

Эта программа обладает неопределённым поведением, поскольку при работе с переменной `mySharedWork` возникает гонка данных. Запуская программу, можно убедиться в недетерминированности её поведения.

![[ParallelProg_31.png]]

В чём проблема? Операция освобождения `dataProduced.store` по-прежнему синхронизируется с операцией захвата `dataProduced.load`, но это отнюдь не означает, что операция захвата станет ждать операцию освобождения, и именно эта ситуация изображена на следующем рисунке. Операция `dataProduced.load` происходит до начала выполнения операции `dataProduced.store`, и синхронизация потоков пропадает.

![[ParallelProg_32.png]]

#### Решение

Отношение «синхронизируется с» означает в нашем примере следующее: если операция `dataProduced.store(true, std::memory_order_release)` происходит раньше, чем операция `dataProduced.load(std::memory_order_acquire)`, то все видимые результаты операций, предшествующих операции `store`, должны стать видимыми другому потоку с момента выполнения операции `load`. Ключевую роль в этой формулировке играет слово «если». В первой версии программы условие выполнялось благодаря оператору `while(!dataProduced.load(std::memory_order_acquire)`.

Повторим это же рассуждение на более высоком уровне строгости. 

Все операции, выполняемые ранее операции `dataProduced.store(true, std::memory_order_release)`, происходят ранее, чем все операции другого потока, выполняемые после операции `dataProduced.load(std::memory_order_acquire)`, если соблюдено следующее условие: операция `store` происходит ранее операции `load`.

### Последовательность освобождений

Последовательность освобождений – довольно сложное понятие, возникающее в связи с семантикой захвата и освобождения. Поэтому в следующем примере начнём с семантики захвата и освобождения.

Цикл ожидания с задержкой:
```c++
// releaseSequence.cpp

#include <atomic>
#include <thread>
#include <iostream>
#include <mutex>

std::atomic<int> atom{0};
int somethingShared{0};

using namespace std::chrono_literals;

void writeShared() {
	somethingShared = 2011;
	atom.store(2, std::memory_order_release);
}

void readShared() {
	while ( !(atom.fetch_sub(1, std::memory_order_acquire) > 0) ){
		std::this_thread::sleep_for(100ms);
	}

	std::cout << “somethingShared: “ << somethingShared << std::endl;
}

int main() {
	std::cout << std::endl;

	std::thread t1(writeShared);
	std::thread t2(readShared);
	std::thread t3(readShared);
	
	t1.join();
	t2.join();
	t3.join();

	std::cout << “atom: “ << atom << std::endl;

	std::cout << std::endl;
}
```

Рассмотрим этот пример сперва без потока `t3`. Операция записи в атомарную переменную в строке `atom.store(2, std::memory_order_release)` синхронизируется с операцией чтения этой же переменной в строке `while ( !(atom.fetch_sub(1, std::memory_order_acquire) > 0) )`. Синхронизация гарантирует, что результаты всех операций, выполненных перед записью, будут доступны после чтения. В том числе это означает, что обращение к переменной `somethingShared` не приводит к гонке данных.

Что изменится с появлением потока `t3`? Теперь, по-видимому, возникает гонка данных. Как уже говорилось выше, первый вызов операции `fetch_sub` в строке `while ( !(atom.fetch_sub(1, std::memory_order_acquire) > 0) )` обладает семантикой захвата и освобождения в паре с вызовом операции store в строке `atom.store(2, std::memory_order_release);`. Поэтому гонки данных по переменной `somethingShared` и не возникало.

Однако это неверно для второго вызова `fetch_sub`. Это операция чтения-модификации-записи, и вызывается она без флага `std::memory_order_release`. Это означает, что второй вызов операции `fetch_sub` не синхронизируется с первым, и это, казалось бы, может привести к гонке данных при работе с переменной `somethingShared`. Может, но не приводит – благодаря последовательности освобождений. Последовательность освобождений охватывает как первый, так и второй вызов операции `fetch_sub`. Следовательно, первый вызов операции `fetch_sub` связан со вторым отношением «происходит ранее».

В заключение приведём результат работы программы.
![[ParallelProg_33.png]]

За более формальным изложением вопроса следует обратиться к рабочему варианту стандарта языка C++, документ N4659.

> Последовательность освобождений над атомарным объектом `M`, начинающаяся с операции освобождения `A`, – это максимальная непрерывная последовательность побочных эффектов в порядке модификации объекта `M`, в которой первой стоит операция `A` и каждая последующая операция `*` либо выполняется тем же потоком, который выполнил операцию `A`, либо `*` представляет собой атомарную операцию чтения-модификации-записи.

## Модель памяти std::memory_order_consume

Модель памяти `std::memory_order_consume` из всех шести моделей в наибольшей степени окутана легендами. Для этого есть две причины: во-первых, она чрезвычайно трудна для понимания, а во-вторых, – это может измениться в будущем – сейчас её не поддерживает ни один компилятор. С появлением стандарта C++17 положение даже ухудшилось. Вот официальная формулировка: «Определение порядка захвата и потребления в настоящее время подвергается пересмотру, использование модели `std::memory_order_consume` временно не рекомендуется».

Как возможно, чтобы компилятор, реализующий стандарт C++11, не поддерживал модель памяти `std::memory_order_consume`? Ответ состоит в том, что компилятор подменяет её моделью `std::memory_order_acquire`. Такая замена допустима, поскольку обе предполагают операцию чтения, или захвата. Модель `std::memory_order_consume` накладывает более мягкие ограничения на синхронизацию и упорядочивание доступа к памяти, чем модель `std::memory_order_acquire`. Поэтому модель захвата и освобождения выходит потенциально менее быстрой, но – и это самое главное – хорошо определённой.

### Порядок захвата и освобождения

Начнём с примера программы, состоящей из двух потоков: `t1` и `t2`. Поток `t1` играет роль производителя, а поток `t2` – потребителя. Атомарная переменная `ptr` помогает синхронизировать производителя с потребителем.

Порядок захвата и освобождения:
```c++
// acquireRelease.cpp

#include <atomic>
#include <thread>
#include <iostream>
#include <string>

using namespace std;

atomic<string*> ptr;
atomic<int> atoData;
int data;

void producer(){
	string* p = new string(“C++11”);
	data = 2011;

	atoData.store(2014, memory_order_relaxed);
	ptr.store(p, memory_order_release);
}

void consumer(){
	string* p2;
	
	while (!(p2 = ptr.load(memory_order_acquire)));

	cout << “*p2: “ << *p2 << endl;
	cout << “data: “ << data << endl;
	cout << “atoData: “ << atoData.load(memory_order_relaxed) << endl;
}

int main(){
	cout << endl;

	thread t1(producer);
	thread t2(consumer);
	
	t1.join();
	t2.join();
}
```

Прежде чем анализировать эту программу в подробностях, нужно сделать одну небольшую поправку.

### Порядок освобождения и потребления

Заменим модель памяти `std::memory_order_acquire` в строке `while (!(p2 = ptr.load(memory_order_acquire)))` порядком `std::memory_order_consume`.

Порядок освобождения и потребления:
```c++
// acquireRelease.cpp

#include <atomic>
#include <thread>
#include <iostream>
#include <string>

using namespace std;

atomic<string*> ptr;
atomic<int> atoData;
int data;

void producer(){
	string* p = new string(“C++11”);
	data = 2011;

	atoData.store(2014, memory_order_relaxed);
	ptr.store(p, memory_order_release);
}

void consumer(){
	string* p2;
	
	while (!(p2 = ptr.load(memory_order_acquire)));

	cout << “*p2: “ << *p2 << endl;
	cout << “data: “ << data << endl;
	cout << “atoData: “ << atoData.load(memory_order_relaxed) << endl;
}

int main(){
	cout << endl;

	thread t1(producer);
	thread t2(consumer);
	
	t1.join();
	t2.join();

	cout << endl;
}
```

Теперь программа обладает неопределённым поведением. Это утверждение носит умозрительный характер – например, компилятор GCC 5.4 просто заменяет модель `std::memory_order_consume` на модель `std::memory_order_acquire`, поэтому «под капотом» обе программы работают одинаково.

### Различие порядков «освобождение-захват» и «освобождение-потребление»

Результат работы обеих программ оказывается одинаковым.

![[ParallelProg_34.png]]

Рискуя лишний раз повториться, всё же следует сказать несколько слов о том, почему первая программа, `acquireRelease.cpp`, обладает вполне определённым поведением.

Операция `store` в строке `atoData.store(2014,memory_order_relaxed)` синхронизируется с операцией `load` в строке `while (!(p2 = ptr.load(memory_order_consume)))`. Причина этого в том, что в операции `store` используется порядок `std::memory_order_release`, а в операции `load` – порядок `std::memory_order_acquire`. Отношение между операциями `store` и `load` предполагает синхронизацию. Какие ограничения налагает модель памяти на порядок выполнения операции захвата и освобождения? Порядок освобождения и захвата гарантирует, что результаты всех операций, выполнявшихся ранее операции записи (строка `atoData.store(2014,memory_order_relaxed)`), доступны после операции чтения (строка `while (!(p2 = ptr.load(memory_order_consume)))`). Таким образом, операции освобождения и захвата упорядочивают доступ как к неатомарной переменной `data` (строка `data = 2011`) и атомарной переменной `atoData` (строка `atoData.store(2014,memory_order_relaxed)`).

Причём это справедливо даже несмотря на то, что для доступа к переменной `atoData` используется модель `std::memory_order_relaxed`. Важнейший вопрос теперь звучит так: что произойдёт, если модель `std::memory_order_acquire` заменить моделью `std::memory_order_consume`?

### Зависимости данных в модели std::memory_order_consume

В модели `std::memory_order_consume` учитываются зависимости между атомарными переменными. Эти зависимости бывают двоякого рода. Это отношения переноса зависимости (англ. carries-a-dependency-to) в пределах потока и отношения порядка изменения (англ. dependency-ordered before) между операциями разных потоков. Оба вида зависимостей влекут за собой отношение «происходит ранее». Эти отношения имеют для нашей темы основополагающее значение. Что же в точности они означают?

* Если результат операции `A` используется в качестве операнда операции `B`, говорят, что операция `A` переносит зависимость на операцию `B`.
* Операция сохранения `store A` (при использовании моделей `std::memory_order_release`, `std::memory_order_acq_rel` или `std::memory_order_seq_cst`) предшествует в порядке изменения операции чтения `load B` (при использовании модели `std::memory_order_consume`), если результат операции `B` используется в какой-либо последующей операции `C` в том же потоке. Подчеркнём важность условия, что операции `B` и `С` должны находиться в одном и том же потоке.

Автору из личного опыта известно, что эти определения бывает поначалу нелегко осмыслить. Следующая диаграмма поможет представить данные понятия наглядно.

![[ParallelProg_35.png]]

Выражение `ptr.store(p, std::memory_order_release)` в порядке изменения предшествует выражению `while (!(p2 = ptr.load(std::memory_order_consume)))`, поскольку в строке s`td::cout << "*p2: " << *p2 << std::endl` используется её результат. Помимо того, оказывается, что строка `while (!(p2 = ptr.load(std::memory_order_consume)))` переносит зависимость на строку `std::cout << "*p2: " << *p2 << std::endl`, поскольку используемая в последней переменная `*p2` есть результат операции `ptr.load`.

Относительно выводимых на печать значений переменных `data` и `atoData` никаких гарантий дать нельзя. В самом деле, операции над этими переменными не связаны переносом зависимости с операцией `ptr.load`. Однако и это ещё не всё: поскольку переменная `data` не атомарна, при работе с ней возникает гонка данных. Это происходит потому, что два потока могут осуществлять доступ к ней одновременно, и один из них – поток `t1` – её модифицирует. Поэтому программа в целом обладает неопределённым поведением.

## Ослабленная семантика

Ослабленная семантика занимает крайнее положение в спектре моделей памяти. Это наислабейшая из моделей, она гарантирует лишь порядок модификации отдельно взятой атомарной переменной. Это означает, что все модифицирующие операции над атомарной переменной выполняются вполне упорядоченным образом.

### Отсутствие ограничений на синхронизацию и порядок операций

Здесь всё довольно просто. Если нет никаких правил, их невозможно нарушить. Однако это даже слишком просто – программа всё же должна обладать хорошо определённым поведением. Хорошо определённое поведение обычно предполагает использование синхронизации и гарантий упорядоченности операций из более сильных моделей памяти. А именно: поскольку один поток может видеть результаты операций, выполняемых другим потоком, в произвольном порядке, необходимо обеспечить в программе такие точки, в которых операции из разных потоков синхронизируются между собой.

Типичный пример атомарной операции, в которой порядок выполнения операций несуществен, – это счётчик. Главное для счётчика – не то, как различные потоки его наращивают, а то, что каждая операция приращения атомарна и все приращения в конечном счёте будут выполнены. Рассмотрим следующий пример.

Счётчик с ослабленной семантикой:
```c++
// relaxed.cpp

#include <vector>
#include <iostream>
#include <thread>
#include <atomic>

std::atomic<int> count = {0};

void add()
{
	for (int n = 0; n < 1000; ++n) {
		count.fetch_add(1, std::memory_order_relaxed);
	}
}
//================================

int main()
{
	std::vector<std::thread> v;

	for (int n = 0; n < 10; ++n) {
		v.emplace_back(add);
	}
	
	for (auto& t : v) {
		t.join();
	}
	
	std::cout << “Final counter value is “ << count << ‘\n’;
}
```

Три самые замечательные строки в этой программе – это строки `count.fetch_add(1, std::memory_order_relaxed)`, `t.join()` и `std::cout << “Final counter value is “ << count << ‘\n’`. В строке `count.fetch_add(1, std::memory_order_relaxed)` атомарная переменная `count` наращивается с ослабленной семантикой – таким образом, у нас есть гарантия, что эта операция выполняется атомарно. Все операции `fetch_add` из разных потоков выполняются по порядку. Функция `add` выполняется параллельно в каждом потоке. Потоки, выполняющие эту функцию, запускаются в строке `v.emplace_back(add)`.

Создание потоков образует одну точку синхронизации; вторую составляет вызов `t.join()`. Иными словами, главный поток, создавший ряд дочерних потоков, позднее синхронизируется с ними в строке `t.join()`. Посредством вызова `t.join()` он ждёт завершения каждого дочернего потока. Именно вызов `t.join()` делает результаты предшествующих атомарных операций видимыми для других потоков. Говоря более формально, вызов `t.join()` играет роль операции освобождения.

В заключение остаётся сказать, что между операцией приращения переменной `counter` в строке `count.fetch_add(1, std::memory_order_relaxed)` и взятием её значения в строке `std::cout << “Final counter value is “ << count << ‘\n’` имеет место отношение «происходит ранее».

В результате выполнения программы на печать всегда выводится число 10000. Однообразно? Нет, обнадёживающе!

![[ParallelProg_36.png]]

Типичный пример использования ослабленной семантики с атомарным счётчиком – это счётчик ссылок из внутренней реализации типа [[shared_ptr|std::shared_ptr]]. Ослабленная семантика применяется только для наращивания счётчика. Единственное, что существенно при прибавлении единицы к счётчику ссылок, – это чтобы операция выполнялась атомарным образом. Порядок выполнения этих операций значения не имеет. Однако для операций уменьшения счётчика ослабленная семантика не годится. Для уменьшения счётчика в деструкторе применяется семантика захвата и освобождения.

> **Наращивание счётчика как алгоритм без ожидания**
> Рассмотрим подробнее функцию `add`. Операция инкремента в строке `count.fetch_add(1, std::memory_order_relaxed)` никак не синхронизируется с другими операциями – она лишь прибавляет единицу к атомарной переменной `count`. Следовательно, перед нами алгоритм не только без блокировок, но и без ожидания.

