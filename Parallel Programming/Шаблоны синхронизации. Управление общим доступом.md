
[[#Управление общим доступом|Управление общим доступом]]
1. [[#Копирование значения|Копирование значения]] 9.1.1
	1. [[#Гонка данных при передаче по ссылке|Гонка данных при передаче по ссылке]] 9.1.1.1
		1. [[#Когда передача по ссылке оборачивается копированием|Когда передача по ссылке оборачивается копированием]] 9.1.1.1.1
	2. 


# Управление общим доступом

Если состояние не находится в общем доступе у разных потоков, гонка данных возникнуть не может. Отсутствие общего доступа означает, что каждый поток работает с собственными локальными переменными. Этого можно добиться копированием значений, использованием потокового класса памяти, а также передачей результатов вычислений через фьючерс, по защищённому каналу. Шаблоны, описанные в этом разделе, довольно очевидны, однако для полноты изложения их нужно показать и снабдить краткими пояснениями.

## Копирование значения

Если поток получает свои аргументы в виде скопированных значений, а не по ссылке на исходные значения, нет нужды синхронизировать доступ к этим данным. Ни гонка данных, ни неприятности со временем жизни объектов в этом случае невозможны.

### Гонка данных при передаче по ссылке

В следующей программе запускаются три потока. Один поток получает аргумент путём копирования значения, второй получает данные по ссылке, а третий – по константной ссылке.

**Гонка данных при передаче по ссылке:**
```c++
// copiedValueDataRace.cpp

#include <functional>
#include <iostream>
#include <string>
#include <thread>

using namespace std::chrono_literals;

void byCopy(bool b){
	std::this_thread::sleep_for(1ms);
	std::cout << “byCopy: “ << b << std::endl;
}

void byReference(bool& b){
	std::this_thread::sleep_for(1ms);
	std::cout << “byReference: “ << b << std::endl;
}

void byConstReference(const bool& b){
	std::this_thread::sleep_for(1ms);
	std::cout << “byConstReference: “ << b << std::endl;
}

int main(){
	std::cout << std::boolalpha << std::endl;

	bool shared{false};

		std::thread t1(byCopy, shared);
		std::thread t2(byReference, std::ref(shared));
		std::thread t3(byConstReference, std::cref(shared));
	
	shared = true;
	
	t1.join();
	t2.join();
	t3.join();
	
	std::cout << std::endl;
}
```

Каждый поток спит одну миллисекунду, перед тем как напечатать логическое значение. Различие между потоками состоит в том, что поток `t1` работает с локальной копией значения и потому не может приводить к гонке данных. Результат работы программы свидетельствует о том, что логические значения, с которыми работают потоки `t2` и `t3`, модифицируются без синхронизации.

![[ParallelProg_204.png]]

Показанная выше программа основывается на предположении, очевидном для логического типа, но нетривиальном для более сложных типов. Передача аргументов по значению застрахована от гонки данных, если аргумент представляет собой так называемый объект-значение.

> **Объекты-значения**
> 
> Объекты-значения – это такие объекты, сравнение которых на равенство основывается не на их индивидуальности, а только на состоянии. Объекты-значения должны быть неизменяемыми – чтобы два объекта, созданных равными, оставались равными между собой на протяжении всего времени жизни. Если объект-значение передаётся в поток, нет нужды синхронизировать доступ к нему. Следуя статье «ValueObject» Мартина Фаулера, можно считать, что существуют две категории объектов: объекты-значения и объекты-ссылки.

#### Когда передача по ссылке оборачивается копированием

Читатель мог бы предположить, что поток `t3` в предыдущем примере можно создавать и более простым способом, передавая непосредственно переменную `shared`. Программа в этом случае откомпилируется и заработает, однако то, что в ней выглядит передачей по ссылке, на самом деле работает как копирование значения. Причина в том, что к каждому аргументу, передаваемому в конструктор потока, применяется преобразователь типа [[decay#std decay|std::decay]].

Он меняет тип аргумента, превращая [[rvalue|lvalue в rvalue]], массив в указатель, а функцию – в указатель на функцию. В частности, тип ссылки он приводит к типу значения посредством преобразования [[remove_reference|std::remove_reference]].

Проиллюстрируем сказанное следующей программой. В ней объявляется класс, для которого запрещена операция копирования.

**Неявное копирование в поток, принимающий аргумент по ссылке:**
```c++
// perConstReference.cpp

#include <thread>

class NonCopyableClass{
	public:
		// the compiler generated default constructor
		NonCopyableClass() = default;

		// disallow copying
		NonCopyableClass& operator = (const NonCopyableClass&) = delete;
		NonCopyableClass (const NonCopyableClass&) = delete;
};

void perConstReference(const NonCopyableClass& nonCopy){}

int main(){
	NonCopyableClass nonCopy;

	perConstReference(nonCopy);

	std::thread t(perConstReference, nonCopy);
	t.join();
}
```

Объект `nonCopy` копировать нельзя. Вызов функции `perConstReference` с передачей этого объекта законен, так как функция принимает аргумент по константной ссылке. Однако использование той же самой функции с тем же самым аргументом для создания потока заставляет компилятор GCC 6 выдать подробное сообщение об ошибке, простирающееся на триста с лишним строк, как показано на следующем рисунке.

![[ParallelProg_205.png]]

При этом единственно важной в этом тексте оказывается строка, выделенная красным на следующем рисунке: «использование удалённой функции». Конструктор копирования для класса `NonCopyableClass` недоступен.

![[ParallelProg_206.png]]



















