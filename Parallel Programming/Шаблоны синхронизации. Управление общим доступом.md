
[[#Управление общим доступом|Управление общим доступом]]
1. [[#Копирование значения|Копирование значения]] 9.1.1
	1. [[#Гонка данных при передаче по ссылке|Гонка данных при передаче по ссылке]] 9.1.1.1
		1. [[#Когда передача по ссылке оборачивается копированием|Когда передача по ссылке оборачивается копированием]] 9.1.1.1.1
	2. [[#Проблемы со временем жизни объектов, передаваемых по ссылке|Проблемы со временем жизни объектов, передаваемых по ссылке]] 9.1.1.2
2. [[#Потоковая область хранения|Потоковая область хранения]] 9.1.2
	1. [[#Материал для дальнейшего изучения|Материал для дальнейшего изучения]] 9.1.2.1
3. [[#Использование фьючерсов|Использование фьючерсов]] 9.1.3

# Управление общим доступом

Если состояние не находится в общем доступе у разных потоков, гонка данных возникнуть не может. Отсутствие общего доступа означает, что каждый поток работает с собственными локальными переменными. Этого можно добиться копированием значений, использованием потокового класса памяти, а также передачей результатов вычислений через фьючерс, по защищённому каналу. Шаблоны, описанные в этом разделе, довольно очевидны, однако для полноты изложения их нужно показать и снабдить краткими пояснениями.

## Копирование значения

Если поток получает свои аргументы в виде скопированных значений, а не по ссылке на исходные значения, нет нужды синхронизировать доступ к этим данным. Ни гонка данных, ни неприятности со временем жизни объектов в этом случае невозможны.

### Гонка данных при передаче по ссылке

В следующей программе запускаются три потока. Один поток получает аргумент путём копирования значения, второй получает данные по ссылке, а третий – по константной ссылке.

**Гонка данных при передаче по ссылке:**
```c++
// copiedValueDataRace.cpp

#include <functional>
#include <iostream>
#include <string>
#include <thread>

using namespace std::chrono_literals;

void byCopy(bool b){
	std::this_thread::sleep_for(1ms);
	std::cout << “byCopy: “ << b << std::endl;
}

void byReference(bool& b){
	std::this_thread::sleep_for(1ms);
	std::cout << “byReference: “ << b << std::endl;
}

void byConstReference(const bool& b){
	std::this_thread::sleep_for(1ms);
	std::cout << “byConstReference: “ << b << std::endl;
}

int main(){
	std::cout << std::boolalpha << std::endl;

	bool shared{false};

		std::thread t1(byCopy, shared);
		std::thread t2(byReference, std::ref(shared));
		std::thread t3(byConstReference, std::cref(shared));
	
	shared = true;
	
	t1.join();
	t2.join();
	t3.join();
	
	std::cout << std::endl;
}
```

Каждый поток спит одну миллисекунду, перед тем как напечатать логическое значение. Различие между потоками состоит в том, что поток `t1` работает с локальной копией значения и потому не может приводить к гонке данных. Результат работы программы свидетельствует о том, что логические значения, с которыми работают потоки `t2` и `t3`, модифицируются без синхронизации.

![[ParallelProg_204.png]]

Показанная выше программа основывается на предположении, очевидном для логического типа, но нетривиальном для более сложных типов. Передача аргументов по значению застрахована от гонки данных, если аргумент представляет собой так называемый объект-значение.

> **Объекты-значения**
> 
> Объекты-значения – это такие объекты, сравнение которых на равенство основывается не на их индивидуальности, а только на состоянии. Объекты-значения должны быть неизменяемыми – чтобы два объекта, созданных равными, оставались равными между собой на протяжении всего времени жизни. Если объект-значение передаётся в поток, нет нужды синхронизировать доступ к нему. Следуя статье «ValueObject» Мартина Фаулера, можно считать, что существуют две категории объектов: объекты-значения и объекты-ссылки.

#### Когда передача по ссылке оборачивается копированием

Читатель мог бы предположить, что поток `t3` в предыдущем примере можно создавать и более простым способом, передавая непосредственно переменную `shared`. Программа в этом случае откомпилируется и заработает, однако то, что в ней выглядит передачей по ссылке, на самом деле работает как копирование значения. Причина в том, что к каждому аргументу, передаваемому в конструктор потока, применяется преобразователь типа [[decay#std decay|std::decay]].

Он меняет тип аргумента, превращая [[rvalue|lvalue в rvalue]], массив в указатель, а функцию – в указатель на функцию. В частности, тип ссылки он приводит к типу значения посредством преобразования [[remove_reference|std::remove_reference]].

Проиллюстрируем сказанное следующей программой. В ней объявляется класс, для которого запрещена операция копирования.

**Неявное копирование в поток, принимающий аргумент по ссылке:**
```c++
// perConstReference.cpp

#include <thread>

class NonCopyableClass{
	public:
		// the compiler generated default constructor
		NonCopyableClass() = default;

		// disallow copying
		NonCopyableClass& operator = (const NonCopyableClass&) = delete;
		NonCopyableClass (const NonCopyableClass&) = delete;
};

void perConstReference(const NonCopyableClass& nonCopy){}

int main(){
	NonCopyableClass nonCopy;

	perConstReference(nonCopy);

	std::thread t(perConstReference, nonCopy);
	t.join();
}
```

Объект `nonCopy` копировать нельзя. Вызов функции `perConstReference` с передачей этого объекта законен, так как функция принимает аргумент по константной ссылке. Однако использование той же самой функции с тем же самым аргументом для создания потока заставляет компилятор GCC 6 выдать подробное сообщение об ошибке, простирающееся на триста с лишним строк, как показано на следующем рисунке.

![[ParallelProg_205.png]]

При этом единственно важной в этом тексте оказывается строка, выделенная красным на следующем рисунке: «использование удалённой функции». Конструктор копирования для класса `NonCopyableClass` недоступен.

![[ParallelProg_206.png]]

### Проблемы со временем жизни объектов, передаваемых по ссылке

Если поток принимает аргумент по ссылке, нужно быть предельно осторожным с отсоединением этого потока от потока-родителя. Следующая небольшая программа обладает неопределённым поведением.

**Проблемы со временем жизни объектов, передаваемых по ссылке:**
```c++
// copiedValueLifetimeIssues.cpp

#include <iostream>
#include <string>
#include <thread>

void executeTwoThreads(){
	const std::string localString(“local string”);

	std::thread t1([localString]{
		std::cout << “Per Copy: “ << localString << std::endl;
	});
	std::thread t2([&localString]{
		std::cout << “Per Reference: “ << localString << std::endl;
	});

	t1.detach();
	t2.detach();
}

using namespace std::chrono_literals;

int main(){
	std::cout << std::endl;

	executeTwoThreads();

	std::this_thread::sleep_for(1s);

	std::cout << std::endl;
}
```

Функция `executeTwoThreads` запускает два потока. Оба потока отсоединяются после создания и выводят на печать строковую переменную `localString`. Первый поток получает аргумент в виде копии значения, а второй – ссылку на локальную переменную функции `executeTwoThreads`. Для простоты в обоих случаях используется лямбда-функция.

Поскольку функция `executeTwoThreads` завершается, не дожидаясь завершения созданных ею потоков, поток `t2` работает с объектом, который может прекратить своё существование. Это приводит к неопределённому поведению. Примечательно, что компилятор GCC 6 с максимальным уровнем оптимизации -`O3` производит по-видимому работоспособный код, тогда как неоптимизированная версия терпит крах.

![[ParallelProg_207.png]]

## Потоковая область хранения

Потоковая область хранения позволяет многочисленным потокам пользоваться своими копиями некоторых переменных так, как если бы они были глобальными. Спецификатор класса памяти `thread_local` делает переменную с глобальной областью видимости потоковой переменной. Поток может пользоваться ею без какой-либо синхронизации.

Рассмотрим типичный пример. Пусть нужно подсчитать сумму элементов вектора. Самый очевидный способ суммирования – цикл по диапазону.

```c++
// calculateWithLoop.cpp
...
unsigned long long sum = {};

for (auto n: randValues) sum += n;
```

Однако у компьютера, скажем, четыре процессорных ядра. Поэтому последовательную программу хочется преобразовать в параллельную.

```c++
// threadLocalSummation.cpp

...

thread_local unsigned long long tmpSum = 0;

void sumUp(
	std::atomic<unsigned long long>& sum,
	const std::vector<int>& val,
	unsigned long long beg, unsigned long long end)
{
	for (auto i = beg; i < end; ++i) {
		tmpSum += val[i];
	}

	sum.fetch_add(tmpSum, std::memory_order_relaxed);
}

...

std::atomic<unsigned long long> sum{};
std::thread t1(sumUp, std::ref(sum), std::ref(randValues), 0, fir);
std::thread t2(sumUp, std::ref(sum), std::ref(randValues), fir, sec);
std::thread t3(sumUp, std::ref(sum), std::ref(randValues), sec, thi);
std::thread t4(sumUp, std::ref(sum), std::ref(randValues), thi, fou);
```

Цикл по диапазону помещён в функцию, каждый вызов этой функции в отдельном потоке делает четвёртую часть работы, накапливая частичную сумму в переменной `tmpSum`, находящейся в потоковой области. После завершения цикла накопленный частичный результат прибавляется к общему итогу `sum` посредством атомарной операции.

[[Вычисление суммы элементов вектора#Вычисление суммы элементов вектора|Различные способы суммирования элементов вектора]]. Там можно найти полный текст программы с комментариями.

> **Использование алгоритмов из стандартной библиотеки:**
>
> Программисту не нужно своими руками писать цикл, если задачу можно решить с помощью алгоритма из стандартной библиотеки. В данном примере суммирование всех элементов вектора или его части можно поручить алгоритму [[accumulate#std accumulate|std::accumulate]]. Начиная со стандарта C++ 17 можно также пользоваться алгоритмом [[reduce#std reduce|std::reduce]], который представляет собой вариацию предыдущего алгоритма с поддержкой параллельной стратегии выполнения.

### Материал для дальнейшего изучения

Более подробные сведения можно найти в статье об объектах-значениях и во второй книге серии POSA.

## Использование фьючерсов

Стандарт C++ 11 содержит три способа работы с фьючерсами: функцию [[async#std async|std::async]], класс [[packaged_task#std packaged_task|std::packaged_task]] и работающие в паре типы [[promise#std promise|std::promise]] и [[future#std future|std::future]]. Термин `«promise»` (обещание) уходит корнями в 1970-е годы. Фьючерс можно представить себе как доступное только для чтения хранилище на одно значение, для заполнения которого служит доступный для записи объект – обещание. Главное с точки зрения синхронизации свойство пары «обещание–фьючерс» состоит в том, что эти два объекта связаны между собой потокобезопасным каналом.

При воплощении фьючерсов в каком-либо языке программирования нужно принять решения по следующим вопросам:

> значение фьючерса можно запрашивать неявно или явно – как это сделано в стандарте языка C++;
> 
> фьючерс может начинать свою работу жадным или ленивым способом. В стандартной библиотеке языка C++ только функция [[async#std async|std::async]] поддерживает ленивые вычисления посредством политик запуска. 

Проиллюстрируем сказанное примером.

```c++
auto lazyOrEager = std::async([]{ return “LazyOrEager”; });
auto lazy = std::async(std::launch::deferred, []{ return “Lazy”; });
auto eager = std::async(std::launch::async, []{ return “Eager”; });

lazyOrEager.get();
lazy.get();
eager.get();
```

Если не задать в явном виде политику запуска, система сама вправе решать, каким способом выполнять асинхронное задание: жадным или ленивым. Использование политики [[async#Политика запуска|std::launch::async]] означает создание нового потока и немедленный запуск задания. Политика [[async#Политика запуска|deferred]], напротив, откладывает выполнение задания до тех пор, пока его результат не будет запрошен функцией `get`. Такое обещание выполняется в потоке, запросившем результат.

Фьючерс может заблокировать выполнение, если значение обещания не готово. В стандартной библиотеке языка C++ блокироваться могут вызовы функций-членов `wait` и `get`. Кроме того, можно ожидать значения с заданным предельным временем ожидания с помощью функций `wait_for` и `wait_until`.

Существует ряд способов реализации фьючерсов: например, [[Особенности сопрограмм#Особенности сопрограмм|сопрограммы]], [[Func-Generator#Функция-генератор|генераторы]], каналы.

