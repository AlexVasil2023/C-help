
[[#Управление общим доступом|Управление общим доступом]]
1. [[#Копирование значения|Копирование значения]] 9.1.1
	1. [[#Гонка данных при передаче по ссылке|Гонка данных при передаче по ссылке]] 9.1.1.1
		1. [[#Когда передача по ссылке оборачивается копированием|Когда передача по ссылке оборачивается копированием]] 9.1.1.1.1
	2. [[#Проблемы со временем жизни объектов, передаваемых по ссылке|Проблемы со временем жизни объектов, передаваемых по ссылке]] 9.1.1.2
2. [[#Потоковая область хранения|Потоковая область хранения]] 9.1.2
	1. 


# Управление общим доступом

Если состояние не находится в общем доступе у разных потоков, гонка данных возникнуть не может. Отсутствие общего доступа означает, что каждый поток работает с собственными локальными переменными. Этого можно добиться копированием значений, использованием потокового класса памяти, а также передачей результатов вычислений через фьючерс, по защищённому каналу. Шаблоны, описанные в этом разделе, довольно очевидны, однако для полноты изложения их нужно показать и снабдить краткими пояснениями.

## Копирование значения

Если поток получает свои аргументы в виде скопированных значений, а не по ссылке на исходные значения, нет нужды синхронизировать доступ к этим данным. Ни гонка данных, ни неприятности со временем жизни объектов в этом случае невозможны.

### Гонка данных при передаче по ссылке

В следующей программе запускаются три потока. Один поток получает аргумент путём копирования значения, второй получает данные по ссылке, а третий – по константной ссылке.

**Гонка данных при передаче по ссылке:**
```c++
// copiedValueDataRace.cpp

#include <functional>
#include <iostream>
#include <string>
#include <thread>

using namespace std::chrono_literals;

void byCopy(bool b){
	std::this_thread::sleep_for(1ms);
	std::cout << “byCopy: “ << b << std::endl;
}

void byReference(bool& b){
	std::this_thread::sleep_for(1ms);
	std::cout << “byReference: “ << b << std::endl;
}

void byConstReference(const bool& b){
	std::this_thread::sleep_for(1ms);
	std::cout << “byConstReference: “ << b << std::endl;
}

int main(){
	std::cout << std::boolalpha << std::endl;

	bool shared{false};

		std::thread t1(byCopy, shared);
		std::thread t2(byReference, std::ref(shared));
		std::thread t3(byConstReference, std::cref(shared));
	
	shared = true;
	
	t1.join();
	t2.join();
	t3.join();
	
	std::cout << std::endl;
}
```

Каждый поток спит одну миллисекунду, перед тем как напечатать логическое значение. Различие между потоками состоит в том, что поток `t1` работает с локальной копией значения и потому не может приводить к гонке данных. Результат работы программы свидетельствует о том, что логические значения, с которыми работают потоки `t2` и `t3`, модифицируются без синхронизации.

![[ParallelProg_204.png]]

Показанная выше программа основывается на предположении, очевидном для логического типа, но нетривиальном для более сложных типов. Передача аргументов по значению застрахована от гонки данных, если аргумент представляет собой так называемый объект-значение.

> **Объекты-значения**
> 
> Объекты-значения – это такие объекты, сравнение которых на равенство основывается не на их индивидуальности, а только на состоянии. Объекты-значения должны быть неизменяемыми – чтобы два объекта, созданных равными, оставались равными между собой на протяжении всего времени жизни. Если объект-значение передаётся в поток, нет нужды синхронизировать доступ к нему. Следуя статье «ValueObject» Мартина Фаулера, можно считать, что существуют две категории объектов: объекты-значения и объекты-ссылки.

#### Когда передача по ссылке оборачивается копированием

Читатель мог бы предположить, что поток `t3` в предыдущем примере можно создавать и более простым способом, передавая непосредственно переменную `shared`. Программа в этом случае откомпилируется и заработает, однако то, что в ней выглядит передачей по ссылке, на самом деле работает как копирование значения. Причина в том, что к каждому аргументу, передаваемому в конструктор потока, применяется преобразователь типа [[decay#std decay|std::decay]].

Он меняет тип аргумента, превращая [[rvalue|lvalue в rvalue]], массив в указатель, а функцию – в указатель на функцию. В частности, тип ссылки он приводит к типу значения посредством преобразования [[remove_reference|std::remove_reference]].

Проиллюстрируем сказанное следующей программой. В ней объявляется класс, для которого запрещена операция копирования.

**Неявное копирование в поток, принимающий аргумент по ссылке:**
```c++
// perConstReference.cpp

#include <thread>

class NonCopyableClass{
	public:
		// the compiler generated default constructor
		NonCopyableClass() = default;

		// disallow copying
		NonCopyableClass& operator = (const NonCopyableClass&) = delete;
		NonCopyableClass (const NonCopyableClass&) = delete;
};

void perConstReference(const NonCopyableClass& nonCopy){}

int main(){
	NonCopyableClass nonCopy;

	perConstReference(nonCopy);

	std::thread t(perConstReference, nonCopy);
	t.join();
}
```

Объект `nonCopy` копировать нельзя. Вызов функции `perConstReference` с передачей этого объекта законен, так как функция принимает аргумент по константной ссылке. Однако использование той же самой функции с тем же самым аргументом для создания потока заставляет компилятор GCC 6 выдать подробное сообщение об ошибке, простирающееся на триста с лишним строк, как показано на следующем рисунке.

![[ParallelProg_205.png]]

При этом единственно важной в этом тексте оказывается строка, выделенная красным на следующем рисунке: «использование удалённой функции». Конструктор копирования для класса `NonCopyableClass` недоступен.

![[ParallelProg_206.png]]

### Проблемы со временем жизни объектов, передаваемых по ссылке

Если поток принимает аргумент по ссылке, нужно быть предельно осторожным с отсоединением этого потока от потока-родителя. Следующая небольшая программа обладает неопределённым поведением.

**Проблемы со временем жизни объектов, передаваемых по ссылке:**
```c++
// copiedValueLifetimeIssues.cpp

#include <iostream>
#include <string>
#include <thread>

void executeTwoThreads(){
	const std::string localString(“local string”);

	std::thread t1([localString]{
		std::cout << “Per Copy: “ << localString << std::endl;
	});
	std::thread t2([&localString]{
		std::cout << “Per Reference: “ << localString << std::endl;
	});

	t1.detach();
	t2.detach();
}

using namespace std::chrono_literals;

int main(){
	std::cout << std::endl;

	executeTwoThreads();

	std::this_thread::sleep_for(1s);

	std::cout << std::endl;
}
```

Функция `executeTwoThreads` запускает два потока. Оба потока отсоединяются после создания и выводят на печать строковую переменную `localString`. Первый поток получает аргумент в виде копии значения, а второй – ссылку на локальную переменную функции `executeTwoThreads`. Для простоты в обоих случаях используется лямбда-функция.

Поскольку функция `executeTwoThreads` завершается, не дожидаясь завершения созданных ею потоков, поток `t2` работает с объектом, который может прекратить своё существование. Это приводит к неопределённому поведению. Примечательно, что компилятор GCC 6 с максимальным уровнем оптимизации -`O3` производит по-видимому работоспособный код, тогда как неоптимизированная версия терпит крах.

![[ParallelProg_207.png]]

## Потоковая область хранения

Потоковая область хранения позволяет многочисленным потокам пользоваться своими копиями некоторых переменных так, как если бы они были глобальными. Спецификатор класса памяти `thread_local` делает переменную с глобальной областью видимости потоковой переменной. Поток может пользоваться ею без какой-либо синхронизации.

Рассмотрим типичный пример. Пусть нужно подсчитать сумму элементов вектора. Самый очевидный способ суммирования – цикл по диапазону.

```c++
// calculateWithLoop.cpp
...
unsigned long long sum = {};

for (auto n: randValues) sum += n;
```

Однако у компьютера, скажем, четыре процессорных ядра. Поэтому последовательную программу хочется преобразовать в параллельную.

```c++
// threadLocalSummation.cpp

...

thread_local unsigned long long tmpSum = 0;

void sumUp(
	std::atomic<unsigned long long>& sum,
	const std::vector<int>& val,
	unsigned long long beg, unsigned long long end)
{
	for (auto i = beg; i < end; ++i) {
		tmpSum += val[i];
	}

	sum.fetch_add(tmpSum, std::memory_order_relaxed);
}

...

std::atomic<unsigned long long> sum{};
std::thread t1(sumUp, std::ref(sum), std::ref(randValues), 0, fir);
std::thread t2(sumUp, std::ref(sum), std::ref(randValues), fir, sec);
std::thread t3(sumUp, std::ref(sum), std::ref(randValues), sec, thi);
std::thread t4(sumUp, std::ref(sum), std::ref(randValues), thi, fou);
```

Цикл по диапазону помещён в функцию, каждый вызов этой функции в отдельном потоке делает четвёртую часть работы, накапливая частичную сумму в переменной `tmpSum`, находящейся в потоковой области. После завершения цикла накопленный частичный результат прибавляется к общему итогу `sum` посредством атомарной операции.























