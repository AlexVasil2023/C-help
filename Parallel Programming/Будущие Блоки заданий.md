
[[#Блоки заданий|Блоки заданий]] 7.4
1. [[#Разветвление и слияние|Разветвление и слияние]] 7.4.1
2. [[#Две функции для создания блоков заданий|Две функции для создания блоков заданий]] 7.4.2
3. [[#Интерфейс|Интерфейс]] 7.4.3
4. [[#Планировщик заданий|Планировщик заданий]] 7.4.4

# Блоки заданий

Блоки заданий представляют собой средство для организации параллельного выполнения заданий в соответствии с широко известным шаблоном разветвления и слияния. Они уже включены в техническую спецификацию по расширенной поддержке параллельного программирования в языке C++ версии 21. Поэтому вполне возможно, что скоро они будут включены в очередную версию стандарта языка.

Кто изобрёл поддержку блоков заданий в языке C++? Как компания Microsoft, разработавшая библиотеку параллельных шаблонов `PPL2`, так и компания Intel с библиотекой строительных блоков для программирования потоков участвовали в выработке предложения N44414. Кроме того, компания Intel использовала свой опыт разработки библиотеки Cilk Plus5.

Сущность шаблона разветвления и слияния объяснить довольно просто.

## Разветвление и слияние

Шаблон разветвления и слияния проще всего объяснить с помощью графической схемы.

![[ParallelProg_210.png]]

Как работает изображённая здесь система? Главный поток создаёт блок заданий с помощью функции `define_task_block` или `define_task_block_restore_thread`. Внутри блока могут создаваться новые задания или может происходить ожидание существующих заданий. В роли точки синхронизации выступает конец блока. Создание заданий в блоке – это фаза разветвления; синхронизация заданий в конце блока представляет собой фазу слияния. Это общее описание и впрямь выглядит очень простым. Рассмотрим теперь фрагмент программного кода.

**Определение блока заданий:**
```c++
template <typename Func>
int traverse(node& n, Func && f){
	int left = 0, right = 0;
	
	define_task_block(
		[&](task_block& tb){
			if (n.left) 
				tb.run([&]{ left = traverse(*n.left, f); });
			
			if (n.right) 
				tb.run([&]{ right = traverse(*n.right, f); });
		}
	);
	
	return f(n) + left + right;
}
```

Шаблонная функция `traverse` вызывает функцию `f` для каждого узла дерева. Функция `define_task_block` создаёт блок заданий. Лямбда-функция, переданная в качестве аргумента, составляет первое задание блока. Она может создавать и добавлять в блок новые задания. Именно это происходит с левым и правым поддеревьями: их обход происходит в отдельных заданиях, находящихся под управлением этого блока. Окончание блока является также и точкой синхронизации – в этой точке блок ожидает завершения всех своих заданий.

> **Каркас HPX для высокопроизводительных параллельных вычислений**
>
> Приведённый выше пример взят из документации к каркасу HPX (High-Performance ParallelX), который представляет собой систему широкого назначения для поддержки разнообразных параллельных и распределённых вычислений любого масштаба. В составе каркаса HPX уже реализованы многие из описанных в этой главе перспективных средств, предполагающихся к включению в будущие стандарты языка C++.

Для создания блока заданий предлагаются две функции. Рассмотрим подробнее различие между ними.

## Две функции для создания блоков заданий

Тонкое различие межу функциями `define_task_block` и `define_task_block_restore_thread` состоит в том, что вторая из них, в отличие от первой, гарантирует, что потоком, выполняющимся после завершения блока заданий, станет тот же поток, который этот блок создал. Пусть дан следующий код.

**Две функции для создания блоков заданий:**
```c++
...

define_task_block([&](auto& tb){
	tb.run([&]{[] func(); });
	define_task_block_restore_thread([&](auto& tb){
		tb.run([&]([]{ func2(); });
		define_task_block([&](auto& tb){
			tb.run([&]{ func3(); }
		});
		...
		...
	});
	...
	...
});
...
...
```

Для создания вложенного блока заданий в строке `define_task_block_restore_thread([&](auto& tb){` использована функция сохраняющая поток. Поэтому гарантируется, что операторы в строках `...` будут выполняться в том же потоке, который выполнил строки `tb.run([&]{[] func(); });` и `define_task_block_restore_thread([&](auto& tb){`. 

## Интерфейс

Интерфейс блока заданий минималистичен. Пользователь не может создавать в явном виде, разрушать, копировать или перемещать объекты класса `task_block`. Создание блока заданий возможно только с помощью двух рассмотренных выше функций. Созданный блок заданий передаётся помещённой в него функции как аргумент `tb` и может использоваться внутри неё для создания новых заданий (`tb.run`) и для ожидания завершения имеющихся заданий (`tb.wait`).

**Интерфейс блока заданий на примере:**
```c++
define_task_block([&](auto& tb){
	tb.run([&]{ process(x1, x2) });
	if (x2 == x3) tb.wait();
	process(x3, x4);
});
```

Что делает этот фрагмент кода? В строке `tb.run([&]{ process(x1, x2) });` запускается новое задание. Ему для работы нужны переменные `x1` и `x2`. В строке `process(x3, x4);` используются также переменные `x3` и `x4`. Если выполняется условие `x2 == x3`, переменные нужно защитить от одновременного доступа. Поэтому главное задание блокируется до тех пор, пока задание, запущенное в строке `tb.run([&]{ process(x1, x2) });`, не завершится.

Если в блоке заданий обнаруживается исключение, выполнение блока прерывается, а наружу выбрасывается исключение типа `task_cancelled_exception`.

## Планировщик заданий

Планировщик управляет выполняющимися потоками. Это значит, что распределение заданий по потокам перестаёт быть делом программиста. Потоки становятся лишь деталью реализации.

Есть две стратегии выполнения вновь созданного задания (в следующем описании под родителем будем понимать поток, создавший задание, а под ребёнком – новое задание).

> Похищение ребёнка – планировщик берёт задание под свой контроль и отправляет его на выполнение в какой-либо поток по своему усмотрению.
>
> Похищение родителя – блок заданий сам принимается за выполнение нового задания. Тем временем планировщик забирает блок заданий и решает, какому потоку его отправить на выполнение.

В предложении N44411 поддерживаются обе стратегии.

