
[[#Библиотека для работы со временем|Библиотека для работы со временем]] 14
1. [[#Взаимосвязь моментов, промежутков времени и часов|Взаимосвязь моментов, промежутков времени и часов]] 14.1
2. [[#std chrono time_point (Моменты времени)|std::chrono::time_point (Моменты времени)]] 14.2
	1. [[#Перевод моментов времени в календарный формат|Перевод моментов времени в календарный формат]] 14.2.1
	2. [[#Выход за пределы допустимого диапазона часов|Выход за пределы допустимого диапазона часов]] 14.2.2
3. [[#Промежутки времени|Промежутки времени]] 14.3
	1. [[#Вычисления с промежутками времени|Вычисления с промежутками времени]] 14.3.1
4. [[#Типы часов|Типы часов]] 14.4

[[#std chro­no system_clock|std::chro­no::system_clock]]
[[#std chrono steady_clock|std::chrono::steady_clock]]
[[#std chrono high_resolution_clock|std::chrono::high_resolution_clock]]
[[#std chrono duration|std::chrono::duration]]


# Библиотека для работы со временем

## Взаимосвязь моментов, промежутков времени и часов

**Момент времени** определяется точкой отсчёта – так называемым началом эпохи – и промежутком времени, отсчитываемым от начала эпохи.

**Промежуток времени** – это промежуток между двумя моментами времени. Он измеряется количеством определённых единиц.

**Часы** характеризуются начальной точкой и единицей измерения. Они позволяют определить текущий момент времени как промежуток от начальной точки, измеренный в данных единицах.

Моменты времени можно между собой сравнивать. Также можно к моменту времени прибавить промежуток и получить другой момент времени. Единица измерения определяет точность, с которой часы могут измерять промежутки времени. Например, в нашей традиции за начало эпохи берут год предполагаемого рождения Христа; для многих практических задач подходящей единицей измерения является год.

Эти три понятия можно проиллюстрировать на примере биографии Денниса Ритчи. Создатель языка C родился в 1941 году и ушёл из жизни в 2011 го­ду. Для простоты будем считать время лишь с точностью до года.

![[ParallelProg_256.png]]

За начало нашей эры берётся Рождество Христово. Тогда точки, отмеченные числами 1941 и 2011, определяются началом отсчёта и принятой в данном контексте единицей измерения. Конечно же, начало эпохи тоже представляет собой момент времени. Если вычесть момент времени 1941 из момента 2011, получим промежуток времени. В нашем примере продолжительность измеряется с точностью до года. Как видно из этого вычисления, Деннис Ритчи прожил 70 лет.

Перейдём к более подробному рассмотрению компонентов этой библиотеки.

## std::chrono::time_point (Моменты времени)

Моменты времени моделируются объектами типа std::chrono::time_point. Это шаблон с двумя параметрами. Первый параметр задаёт тип часов. Второй параметр – тип промежутка времени – необязательный: по умолчанию тип промежутка берётся из типа часов.

**Шаблон класса std::chrono::time_point:**
```c++
template<class Clock, class Duration= typename Clock::duration>
class time_point;
```

С часами связаны четыре особых момента времени:
* **epoch** – точка отсчёта часов;
* **now** – текущий момент времени;
* **min** – наименьший (наиболее давний) момент времени, который может быть измерен этими часами;
* **max** – наибольший момент времени, который может быть измерен этими часами.

Точность, наименьший и наибольший моменты времени могут быть различны у разных часов. В стандартной библиотеке имеются часы [[#std chro­no system_clock|std::chro­no::system_clock]], [[#std chrono steady_clock|std::chrono::steady_clock]] и [[#std chrono high_resolution_clock|std::chrono::high_resolution_clock]]. Стандарт языка C++ не даёт гарантий относительно точности, точки отсчёта и диапазона часов. За начало отсчёта часов [[#std chro­no system_clock|std::chrono::system_clock]] обычно берётся 1 января 1970 года – начало эпохи UNIX. Как явствует из названия, часы [[#std chrono high_resolution_clock|std::chrono::high_resolution_clock]] имеют наибольшую точность.

### Перевод моментов времени в календарный формат

У часов [[#std chro­no system_clock|std::chrono::system_clock]] есть функция `to_time_t`, которая позволяет преобразовывать моменты времени, отмеренные с помощью этих часов, в значения типа [[time_t|std::time_t]]. Это значение, в свою очередь, можно преобразовать функцией `std::gmtime` в календарное время, выраженное в стандарте UTC (всемирное координированное время). Наконец, это календарное время можно передать функции [[asctime|std::asctime]], чтобы получить текстовое представление даты и времени.

**Отображение даты и времени в текстовом виде:**
```c++
// timepoint.cpp

#include <chrono>
#include <ctime>
#include <iostream>
#include <string>

int main() {
	std::cout << std::endl;

	std::chrono::time_point<std::chrono::system_clock> sysTimePoint;
	std::time_t tp= std::chrono::system_clock::to_time_t(sysTimePoint);
	std::string sTp= std::asctime(std::gmtime(&tp));
	std::cout << “Epoch: “ << sTp << std::endl;

	tp= std::chrono::system_clock::to_time_t(sysTimePoint.min());
	sTp= std::asctime(std::gmtime(&tp));
	std::cout << “Time min: “ << sTp << std::endl;

	tp= std::chrono::system_clock::to_time_t(sysTimePoint.max());
	sTp= std::asctime(std::gmtime(&tp));
	std::cout << “Time max: “ << sTp << std::endl;

	sysTimePoint= std::chrono::system_clock::now();
	tp= std::chrono::system_clock::to_time_t(sysTimePoint);
	sTp= std::asctime(std::gmtime(&tp));
	std::cout << “Time now: “ << sTp << std::endl;
}
```

Эта программа выводит на печать допустимый диапазон часов [[#std chro­no system_clock|std::chrono::system_clock]]. На компьютере автора под управлением ОС Linux эти часы имеют своей точкой отсчёта начало эры UNIX и могут представлять даты в интервале от 1677 до 2262 года.

![[time_1.png]]

К моментам времени можно прибавлять промежутки времени. Прибавление промежутка, выводящее момент времени за пределы допустимого диапазона часов, представляет собой неопределённое поведение.

### Выход за пределы допустимого диапазона часов

Следующая программа берёт текущий момент времени и прибавляет или отнимает от него 1000 лет. Для простоты не будем обращать внимания на високосные годы и положим, что каждый год содержит ровно 365 дней.

**Выход за пределы допустимого диапазона часов:**
```c++
// timepointAddition.cpp

#include <chrono>
#include <ctime>
#include <iostream>
#include <string>

using namespace std::chrono;
using namespace std;

string timePointAsString(const time_point<system_clock>& timePoint){
	time_t tp= system_clock::to_time_t(timePoint);
	return asctime(gmtime(&tp));
}

int main(){
	cout << endl;

	time_point<system_clock> nowTimePoint= system_clock::now();
	cout<< “Now:“<< timePointAsString(nowTimePoint)<< endl;

	const auto thousandYears= hours(24*365*1000);
	time_point<system_clock> historyTimePoint =
			nowTimePoint – thousandYears;
	cout<< “Now – 1000 years: “
			<< timePointAsString(historyTimePoint)<< endl;

	time_point<system_clock> futureTimePoint =
			nowTimePoint + thousandYears;
	cout<< “Now + 1000 years: “
			<< timePointAsString(futureTimePoint)<< endl;
}
```

Для удобства чтения пространство имён `std::chrono` предполагается по умолчанию. Запуск программы демонстрирует, что переполнение счётчика ведёт к неверным результатам. Вычитание тысячи лет из текущего момента времени даёт момент времени в будущем, а прибавление тысячи лет – напротив, переносит в прошлое.

![[time_2.png]]

Два разных момента времени, измеренных по одним часам, различаются промежутком, отделяющим момент времени от начала отсчёта. Промежутки поддерживают основные арифметические операции и могут быть представлены в различных единицах измерения.

## Промежутки времени

Для моделирования промежутков времени предназначен шаблон класса [[#std chrono duration|std::chrono::duration]], принимающий два параметра: арифметический тип `Rep` для количества единиц времени и тип `Period`, который определяет единицу времени относительно секунды.

**Шаблон класса std::chrono::duration:**
```c++
template<class Rep,class Period = std::ratio<1>> 
class duration;
```

По умолчанию за единицу измерения берётся тип `std::ratio<1>`, что соответствует одной секунде и может также быть записано в виде `std::ratio<1, 1>`. Остальное довольно просто: тип `std::ratio<60>` соответствует минуте, а тип `std::ratio<1, 1000>` – миллисекунде. Если в качестве типа `Rep` взят тип с плавающей запятой, возможно измерять время также дробным числом единиц.

В стандарте языка C++ предопределены следующие наиболее важные типы промежутков времени:
```c++
typedef duration<signed int, nano> nanoseconds;
typedef duration<signed int, micro> microseconds;
typedef duration<signed int, millT> milliseconds;
typedef duration<signed int> seconds;
typedef duration<signed int, ratio< 60>> minutes;
typedef duration<signed int, ratio<3600>> hours;
```

Попытаемся определить, сколько времени прошло с начала эры UNIX (т. е. с 1 января 1970 года). Благодаря псевдонимам для различных типов промежутков времени ответить на этот вопрос довольно просто. Для простоты не будем принимать во внимание високосные годы и примем длительность года за 365 дней.

**Измерение промежутка времени в разных единицах:**
```c++
// timeSinceEpoch.cpp

#include <chrono>
#include <iostream>

using namespace std;

int main() {
	cout << fixed << endl;

	cout << “Time since 1.1.1970:\n” << endl;

	const auto timeNow= chrono::system_clock::now();
	const auto duration= timeNow.time_since_epoch();
	
	cout << duration.count() << “ nanoseconds “ << endl;

	typedef chrono::duration<long double, ratio<1, 1000000>>
			MyMicroSecondTick;
	MyMicroSecondTick micro(duration);
	cout << micro.count() << “ microseconds” << endl;


	typedef chrono::duration<long double, ratio<1, 1000>>
			MyMilliSecondTick;
	MyMilliSecondTick milli(duration);
	cout << milli.count() << “ milliseconds” << endl;

	typedef chrono::duration<long double> MySecondTick;
	MySecondTick sec(duration);
	cout << sec.count() << “ seconds “ << endl;

	typedef chrono::duration<double, ratio<60>> MyMinuteTick;
	MyMinuteTick myMinute(duration);
	cout << myMinute.count() << “ minutes” << endl;

	typedef chrono::duration<double, ratio<60*60>> MyHourTick;
	MyHourTick myHour(duration);
	cout << myHour.count() << “ hours” << endl;

	typedef chrono::duration<double, ratio<60*60*24*365>> MyYearTick;
	MyYearTick myYear(duration);
	cout << myYear.count() << “ years” << endl;

	typedef chrono::duration<double, ratio<60*45>> MyLessonTick;
	MyLessonTick myLesson(duration);
	cout << myLesson.count() << “ lessons” << endl;

	cout << endl;
}
```

В этой программе объявляются собственные типы, соответствующие единицам измерения времени: микросекунде, миллисекунде, секунде, минуте, часу и году. Кроме того, объявляется ещё одна единица времени – академический час (45 минут). Результат работы программы показан на рисунке.

![[time_3.png]]

Проводить вычисления с промежутками времени довольно удобно, этому будет посвящён следующий раздел.

### Вычисления с промежутками времени

Типы промежутков времени поддерживают основные арифметические операции. В частности, промежуток времени можно умножать или делить на число. Конечно, промежутки можно сравнивать между собой. Следует подчеркнуть, что все эти операции проводятся с учётом единиц измерения.

Начиная со стандарта C++ 14 работа с промежутками времени становится ещё удобнее. В этой версии стандарта появились литералы для единиц измерения времени.

**Предопределённые литералы для единиц времени:**

| **Тип**                     | **Суффикс** | **Пример** |
| --------------------------- | ----------- | ---------- |
| `std::chrono::hours`        | h           | 5h         |
| `std::chrono::minutes`      | min         | 5min       |
| `std::chrono::seconds`      | s           | 5s         |
| `std::chrono::milliseconds` | ms          | 5ms        |
| `std::chrono::microseconds` | us          | 5us        |
| `std::chrono::nanoseconds`  | ns          | 5ns        |

Автор заинтересовался, сколько времени его семнадцатилетний сын Мариус посвящает учёбе школе каждый день. Следующая программа вычисляет ответ и выводит его в различных единицах.

**Продолжительность школьного дня в разных единицах:**
```c++
// schoolDay.cpp

#include <iostream>
#include <chrono>

using namespace std::literals::chrono_literals;
using namespace std::chrono;
using namespace std;

int main(){
	cout << endl;

	constexpr auto schoolHour= 45min;
	constexpr auto shortBreak= 300s;
	constexpr auto longBreak= 0.25h;
	constexpr auto schoolWay= 15min;
	constexpr auto homework= 2h;

	constexpr auto schoolDaySec =
		2 * schoolWay +
		6 * schoolHour +
		4 * shortBreak +
		longBreak + homework;

	cout << “School day in seconds: “ << schoolDaySec.count() << endl;

	constexpr duration<double, ratio<3600>> schoolDayHour = schoolDaySec;
	constexpr duration<double, ratio<60>> schoolDayMin = schoolDaySec;
	constexpr duration<double, ratio<1,1000>> schoolDayMilli= 
			schoolDaySec;

	cout << “School day in hours: “ << schoolDayHour.count() << endl;
	cout << “School day in minutes: “ << schoolDayMin.count() << endl;
	cout << “School day in milliseconds: “ << schoolDayMilli.count() 
			<< endl;

	cout << endl;
}
```

Здесь объявлены единицы времени, соответствующие академическому часу, короткой перемене, длинной перемене, продолжительности дороги в школу или из школы, а также продолжительности подготовки домашних заданий. Результат вычислений доступен даже на этапе компиляции. Результат запуска программы показан на рисунке.

![[time_4.png]]

> **Вычисления на этапе компиляции**
>
> Промежутки времени, заданные литералами, результат вычислений в секундах `schoolDaySec`, а также этот промежуток, выраженные в других единицах, являются константами этапа компиляции, о чём свидетельствует ключевое слово [[constexpr|constexpr]]. Таким образом, все вычисления выполняются при сборке программы, и лишь вывод результата происходит на этапе выполнения.

Точность, с которой можно измерить промежутки времени, зависит от используемых для этого часов. В стандартной библиотеке языка C++ определены три типа часов, о них пойдёт речь в следующем разделе.

## Типы часов

















# std::chro­no::system_clock
#std_chro­no_system_clock

# std::chrono::steady_clock
#std_chrono_steady_clock

# std::chrono::high_resolution_clock
#std_chrono_high_resolution_clock

# std::chrono::duration
#std_chrono_duration
