
[[#Потокобезопасное создание объекта-одиночки|Потокобезопасное создание объекта-одиночки]] 6.2
1. [[#Шаблон «Блокировка с двойной проверкой»|Шаблон «Блокировка с двойной проверкой»]] 6.2.1
2. [[#Измерение производительности|Измерение производительности]] 6.2.2
3. [[#Потокобезопасный вариант реализации Мейерса|Потокобезопасный вариант реализации Мейерса]] 6.2.3
4. [[#Реализации на основе блокировщика|Реализации на основе блокировщика]] 6.2.4
5. [[#Реализация на основе функции std call_once|Реализация на основе функции std::call_once]] 6.2.5
6. [[#Решение на основе атомарных переменных|Решение на основе атомарных переменных]] 6.2.6
	1. [[#Семантика последовательной согласованности|Семантика последовательной согласованности]] 6.2.6.1
	2. [[#Семантика захвата и освобождения|Семантика захвата и освобождения]] 6.2.6.2
7. [[#Сводные данные|Сводные данные]] 6.2.7

# Потокобезопасное создание объекта-одиночки

Перед тем как погрузиться в указанную тему, следует подчеркнуть: автор вовсе не пропагандирует использование шаблона «Одиночка». Разбор потокобезопасных способов инициализации одиночки необходимо начать с предостережения.

> **Несколько мыслей об объектах-одиночках**
> 
> Единственная причина, по которой шаблон «Одиночка» используется в этой книге, состоит в том, что он представляет собой классический пример переменной, которая должна быть проинициализирована потокобезопасным образом. Как шаблон проектирования, объект-одиночка обладает рядом серьёзных недостатков. Ниже приведены некоторые его проблемы.
> 
>	* Объект-одиночка есть, в сущности, глобальная переменная. Это обстоятельство заметно затрудняет тестирование программ, так как их поведение зависит от глобального состояния.
>	* Для того чтобы использовать объект-одиночку в некоторой функции, чаще всего вызывают статическую функцию-член его класса – например, `MySingleton::getInstance()`. Это означает, что интерфейс функции никак не сообщает её пользователю, что внутри неё используется объект этого класса. Зависимость от одиночного объекта оказывается скрытой в деталях реализации.
>	* Если в разных исходных файлах определены два статических объекта, `x` и `y`, и конструктор каждого из них зависит от другого объекта, имеет место ситуация, известная как фиаско статической инициализации, поскольку нет никакой гарантии, какой из статических объектов будет инициализирован первым. Объекты-одиночки представляют собой именно статические объекты.
>	* Шаблон «Одиночка» управляет отложенным созданием объекта, но не его уничтожением. Ситуация, когда ставший ненужным объект не уничтожается, называется утечкой ресурсов (в частности, памяти).
>	* Предположим, программист захочет объявить подкласс класса одиночки. Как этот подкласс должен быть устроен? Как им пользоваться в программе? Можно ли такое допускать?
>	* Потокобезопасная и быстрая инициализация одиночек – довольно сложное дело.

Разбор подходов к потокобезопасной инициализации объектов-одиночек начнём с одного вырожденного случая.

## Шаблон «Блокировка с двойной проверкой»

Блокировка с двойной проверкой считается классическим способом потокобезопасной инициализации объектов-одиночек. Однако то, что выглядит устоявшейся общепринятой практикой и шаблоном проектирования, на деле представляет собой антишаблон. Этот подход предполагает гарантии относительно модели памяти, которые имелись в традиционных реализациях, но более не предоставляются языками Java, C# или C++. Ложное предположение состоит в атомарности операции создания объекта. Как следствие решение, кажущееся потокобезопасным, таковым на самом деле не является.

Что представляет собой блокировка с двойной проверкой? Этот шаблон придуман для того, чтобы улучшить производительность простейшего потокобезопасного метода инициализации одиночки, где инициализация выполняется под блокировкой.

**Потокобезопасная инициализация с простой блокировкой:**
```c++
std::mutex myMutex;

class MySingleton{
	public:
		static MySingleton& getInstance() {
			std::lock_guard<mutex> myLock(myMutex);

			if(!instance) 
				instance = new MySingleton();

			return *instance;
		}

	private:
		MySingleton() = default;
		~MySingleton() = default;
		MySingleton(const MySingleton&) = delete;
		MySingleton& operator= (const MySingleton&) = delete;

		static MySingleton* instance;
};

MySingleton* MySingleton::instance = nullptr;
```

Хорошее ли это решение? И да, и нет. Да, поскольку оно совершенно потокобезопасно. Нет – потому что его быстродействие оставляет желать лучшего. Каждое обращение к объекту-одиночке упирается в тяжеловесную блокировку. Однако все обращения после инициализации происходят исключительно в режиме чтения, и блокировка становится не нужна. Для борьбы с этой проблемой и был предложен шаблон с двойной проверкой. Посмотрим на функцию `getInstance` после небольшого изменения.

**Блокировка с двойной проверкой:**
```c++
static MySingleton& getInstance(){
	if (!instance){                            // проверка
		lock_guard<mutex> myLock(myMutex);     // блокировка
		
		if(!instance) 
			instance = new MySingleton();      // проверка
	}
	
	return *instance;
}
```

Прежде чем использовать тяжеловесную блокировку, в строке `if (!instance){ ... }` используется быстрая операция сравнения указателей. Только если указатель `instance` пуст, захватывается [[mutex|мьютекс]] (строка `lock_guard<mutex> myLock(myMutex);`). Поскольку существует возможность того, что какой-то другой поток успел проинициализировать указатель между операцией сравнения и блокировкой, значение указателя необходимо проверить ещё раз, это делается в строке `if(!instance)`. Таким образом, шаблон вполне оправдывает своё название: два раза выполняется проверка и один раз – блокировка.

Остроумно? Да. Потокобезопасно? Нет. В чём проблема? Операция присваивания в строке `instance = new MySingleton();` состоит из по меньшей мере трёх шагов:
1) выделить память для объекта `MySingleton`;
2) проинициализировать объект `MySingleton`;
3) присвоить адрес объекта `MySingleton` в переменную `instance`.

Проблема состоит в том, что реализация языка C++ никоим образом не гарантирует, что эти шаги будут выполнены именно в таком порядке. Процессор вполне может поменять их местами, получив в итоге последовательность 1, 3, 2. В этом случае сначала выделяется память, затем переменной `instance` присваивается адрес неинициализированного объекта. Если в этот момент другой поток попытается получить доступ к единственному экземпляру, проверка в строке `if (!instance)` покажет, что экземпляр уже создан. Следовательно, второй поток получит ссылку на неинициализированный объект, что делает поведение программы неопределённым.

## Измерение производительности

Хотелось бы измерить накладные расходы на доступ к объекту-одиночке. За основу для сравнения различных подходов берётся алгоритм, который в одном потоке получает доступ к объекту-одиночке 40 миллионов раз подряд. Конечно, первое из этих обращений инициализирует объект. С этим базовым случаем будем сравнивать программу, которая обращается к одиночному объекту из четырёх параллельных потоков. Чтобы получить общий показатель производительности, нужно сложить время выполнения всех четырёх потоков. Таким способом сравним производительность реализаций, основанных на статической переменной с ограниченной областью видимости, известную как реализация Мейерса, на блокировщике [[lock#Тип std lock_guard|std::lock_guard]], функции [[Thread_Safe initialization#Функция std call_once и флаг std once_flag|std::call_once]] в сочетании с флагом `std::once_flag`, а также на [[atomic|атомарных переменных]] с семантикой последовательной согласованности и с семантикой захвата и освобождения.

Измерения скорости работы программ проводятся на двух компьютерах. Компьютер под управлением ОС Linux с компилятором GCC имеет четыре процессорных ядра, а компьютер с ОС Windows и компилятором cl.exe – два. Во всех экспериментах программы компилируются с максимальным уровнем оптимизации. Читателю рекомендуется освежить в памяти замечание, сделанное в самом начале главы о сравнении производительности программы на разных компьютерах.

Эксперименты должны дать ответы на два вопроса:
1.	Как соотносится производительность различных реализаций объекта-одиночки?
2.	Имеются ли существенные различия между работой этих алгоритмов в ОС Linux с компилятором GCC и в ОС Windows с компилятором cl.exe?

Результаты всех измерений будут сведены в таблицу.

Как было указано выше, измерению производительности различных многопоточных реализаций должна предшествовать однопоточная. Представленная в следующем коде функция `getInstance` не является потокобезопасной согласно стандарту C++ 03.

**Однопоточная реализация объекта-одиночки по Мейерсу:**
```c++
// singletonSingleThreaded.cpp

#include <chrono>
#include <iostream>

constexpr auto tenMill = 10000000;

class MySingleton {
	public:
		static MySingleton& getInstance() {
			static MySingleton instance;
			volatile int dummy{};
			return instance;
		}
		
	private:
		MySingleton() = default;
		~MySingleton() = default;
		MySingleton(const MySingleton&) = delete;
		MySingleton& operator=(const MySingleton&) = delete;
};

int main() {
	constexpr auto fourtyMill = 4 * tenMill;

	auto begin= std::chrono::system_clock::now();

		for ( size_t i = 0; i <= fourtyMill; ++i) {
			MySingleton::getInstance();
		}
	
	auto end = std::chrono::system_clock::now() – begin;

	std::cout << std::chrono::duration<double>(end).count() << std::endl;
}
```

В этой базовой реализации используется так называемый объект-одиночка Мейерса, названный так в честь автора, Скотта Мейерса. Красота этого подхода состоит в том, что единственный экземпляр в строке `static MySingleton instance;` объявлен как [[static|статическая переменная]] с ограниченной областью видимости. Стандарт языка гарантирует, что инициализация выполняется лишь один раз – а именно когда статическая функция-член `getInstance` (строки `static MySingleton& getInstance() { ... }`) вызывается в первый раз.

> **Зачем нужна переменная `dummy`**
> 
> Если бы не было объявления переменной `dummy` с квалификатором [[volatile|volatile]] в строке `volatile int dummy{};`, компилятор просто убрал бы вызов функции `getInstance` в строке `MySingleton::getInstance();`, потому что результат этого вызова никак не используется. Однако наличие [[volatile|volatile]] - переменной запрещает оптимизатору устранять вызов функции.

Ниже показан результат запуска этой однопоточной программы, дающий базу для сравнения многопоточных реализаций.

![[ParallelProg_142.png]]
![[ParallelProg_143.png]]

## Потокобезопасный вариант реализации Мейерса

Стандарт C++ 11 гарантирует, что статические переменные с областью видимости, ограниченной блоком, инициализируются потокобезопасным образом. В представленной выше реализации Мейерса статическая переменная объявлена внутри блока, поэтому никаких усилий от программиста более не требуется. Единственное, что нужно сделать, – это изменить главную функцию программы, чтобы она обращалась к объекту-одиночке из нескольких параллельных потоков.

**Реализация объекта-одиночки по Мейерсу в многопоточной среде:**
```c++
// singletonMeyers.cpp

#include <chrono>
#include <iostream>
#include <future>

constexpr auto tenMill = 10000000;

class MySingleton{
	public:
		static MySingleton& getInstance() {
			static MySingleton instance;
			volatile int dummy{};
			return instance;
		}
	
	private:
		MySingleton() = default;
		~MySingleton() = default;
		MySingleton(const MySingleton&) = delete;
		MySingleton& operator=(const MySingleton&) = delete;
};

std::chrono::duration<double> getTime() {
	const auto begin = std::chrono::system_clock::now();
		for (size_t i = 0; i <= tenMill; ++i) {
			MySingleton::getInstance();
		}
	return std::chrono::system_clock::now() – begin;
};

int main() {
	auto fut1= std::async(std::launch::async, getTime);
	auto fut2= std::async(std::launch::async, getTime);
	auto fut3= std::async(std::launch::async, getTime);
	auto fut4= std::async(std::launch::async, getTime);

	const auto total= fut1.get() + fut2.get() + fut3.get() + fut4.get();

	std::cout << total.count() << std::endl;
}
```

Обращение к объекту-одиночке происходит из функции `getTime`. Эта функция запускается из четырёх обещаний. Результаты, полученные из фьючерсов, суммируются. Вот и всё: остаётся лишь посмотреть на результат выполнения программы.

![[ParallelProg_144.png]]
![[ParallelProg_145.png]]

> **Сокращение текста примеров**
> 
> Функция `getTime`, которая измеряет время выполнения потока, и функция `main` во всех примерах практически одинаковы. Поэтому будем опускать их в последующих разделах. 

Перейдём теперь к наиболее очевидной из реализаций с явной синхронизацией, а именно к реализации на основе блокировщика.

## Реализации на основе блокировщика

Мьютекс, завёрнутый в блокировщик [[lock#Тип std lock_guard|std::lock_guard]], гарантирует потокобезопасную реализацию объекта-одиночки.

**Объект-одиночка с блокировщиком:**
```c++
// singletonLock.cpp
#include <chrono>
#include <iostream>
#include <future>
#include <mutex>

constexpr auto tenMill = 10000000;

 std::mutex myMutex;

class MySingleton{
	public:
		static MySingleton& getInstance(){
			std::lock_guard<std::mutex> myLock(myMutex);
			
			if (!instance){
				instance= new MySingleton();
			}

			volatile int dummy{};

			return *instance;
		}
		
	private:
		MySingleton() = default;
		~MySingleton() = default;
		MySingleton(const MySingleton&) = delete;
		MySingleton& operator=(const MySingleton&) = delete;

		static MySingleton* instance;
};

MySingleton* MySingleton::instance = nullptr;
```

![[ParallelProg_146.png]]
![[ParallelProg_147.png]]

Следующая версия потокобезопасного объекта-одиночки также основывается на средствах стандартной библиотеки – в ней используется функция [[Thread_Safe initialization#Функция std call_once и флаг std once_flag|std::call_once]] в сочетании с флагом `std::once_flag`.

## Реализация на основе функции std::call_once

С помощью функции [[Thread_Safe initialization#Функция std call_once и флаг std once_flag|std::call_once]] вместе с флагом `std::once_flag` можно регистрировать вызываемый объект, чтобы в нужный момент он был вызван ровно один раз потокобезопасным образом.

**Реализация на основе функции [[Thread_Safe initialization#Функция std call_once и флаг std once_flag|std::call_once]]:**
```c++
// singletonCallOnce.cpp

#include <chrono>
#include <iostream>
#include <future>
#include <mutex>
#include <thread>

constexpr auto tenMill = 10000000;

class MySingleton{
	public:
		static MySingleton& getInstance(){
			std::call_once(initInstanceFlag, &MySingleton::initSingleton);
			
			volatile int dummy{};
			
			return *instance;
		}

	private:
		MySingleton() = default;
		~MySingleton() = default;
		MySingleton(const MySingleton&) = delete;
		MySingleton& operator=(const MySingleton&) = delete;

		static MySingleton* instance;
		static std::once_flag initInstanceFlag;

		static void initSingleton() {
			instance= new MySingleton;
		}
};
MySingleton* MySingleton::instance = nullptr;
std::once_flag MySingleton::initInstanceFlag;
```
Результаты работы программы показаны ниже.

![[ParallelProg_148.png]]
![[ParallelProg_149.png]]

Разбор различных реализаций объекта-одиночки продолжим решением, основанным на [[atomic|атомарных переменных]].

## Решение на основе атомарных переменных

Использование [[atomic|атомарных переменных]] делает задачу значительно более сложной. Так, для атомарных переменных можно даже задать порядок доступа к памяти. Следующие две реализации потокобезопасного объекта-одиночки основываются на разобранном ранее шаблоне блокировки с двойной проверкой.

### Семантика последовательной согласованности

В первой версии решения с [[atomic|атомарными переменными]] воспользуемся атомарными операциями, не задавая в явном виде порядок доступа к памяти. Это означает, что по умолчанию будет использоваться семантика последовательной согласованности.

**Решение на атомарных переменных с последовательной согласованностью:**
```c++
// singletonSequentialConsistency.cpp
#include <atomic>
#include <iostream>
#include <future>
#include <mutex>
#include <thread>

constexpr auto tenMill = 10000000;

class MySingleton{
	public:
		static MySingleton* getInstance() {
			MySingleton* sin = instance.load();
			
			if (!sin) {
				std::lock_guard<std::mutex> myLock(myMutex);
				sin = instance.load(std::memory_order_relaxed);

				if(!sin){
					sin= new MySingleton();
					instance.store(sin);
				}
			}

			volatile int dummy{};
			
			return sin;
		}

	private:
		MySingleton() = default;
		~MySingleton() = default;
		MySingleton(const MySingleton&) = delete;
		MySingleton& operator=(const MySingleton&) = delete;

		static std::atomic<MySingleton*> instance;

		static std::mutex myMutex;
};
std::atomic<MySingleton*> MySingleton::instance;
std::mutex MySingleton::myMutex;
```

В отличие от классической блокировки с двойной проверкой, эта реализация действительно гарантирует, что операция присваивания в строке `sin= new MySingleton()` выполняется раньше, чем функция `store` в строке `instance.store(sin)`. Эта гарантия следует из последовательной согласованности [[atomic|атомарных операций]] как порядка доступа к памяти по умолчанию. Нужно обратить внимание на операцию `load` в строке `in = instance.load(std::memory_order_relaxed)` с ослабленным порядком `std::memory_order_relaxed`. Эта операция нужна потому, что между первой операцией `load` в строке `MySingleton* sin = instance.load();` и входом в критическую секцию в строке `std::lock_guard<std::mutex> myLock(myMutex);` какой-то другой поток может вклиниться и изменить значение переменной `instance`.

![[ParallelProg_150.png]]
![[ParallelProg_151.png]]

Эту программу можно оптимизировать ещё сильнее.

### Семантика захвата и освобождения

Рассмотрим пристальнее последний пример потокобезопасной реализации объекта-одиночки на основе [[atomic|атомарных переменных]]. Чтение значения переменной в строке `MySingleton* sin = instance.load(std::memory_order_acquire);` представляет собой операцию захвата, а запись этой переменной в строке `instance.store(sin, std::memory_order_release);` – операцию освобождения. Обе операции работают с одной и той же [[atomic|атомарной переменной]]. Поэтому семантика последовательной согласованности здесь чрезмерна. Стандарт C++ 11 гарантирует, что операция освобождения синхронизируется с операцией захвата той же самой [[atomic|атомарной переменной]], чем устанавливается определённый порядок операций. А именно никакие последующие операции чтения и записи не могут ставиться перед операцией захвата. В этом и состоит минимум гарантий, необходимый для реализации потокобезопасного объекта-одиночки.

**Реализация на атомарных переменных с семантикой захвата и освобождения:**
```c++
// singletonAcquireRelease.cpp

#include <atomic>
#include <iostream>
#include <future>
#include <mutex>
#include <thread>

constexpr auto tenMill = 10000000;

class MySingleton{
	public:
		static MySingleton* getInstance() {
			MySingleton* sin = instance.load(std::memory_order_acquire);

			if (!sin) {
				std::lock_guard<std::mutex> myLock(myMutex);
				sin = instance.load(std::memory_order_relaxed);

				if(!sin) {
					sin = new MySingleton();
					instance.store(sin, std::memory_order_release);
				}
			}
			
			volatile int dummy{};

			return sin;
		}
	
	private:
		MySingleton() = default;
		~MySingleton() = default;
		MySingleton(const MySingleton&) = delete;
		MySingleton& operator=(const MySingleton&) = delete;

		static std::atomic<MySingleton*> instance;
		static std::mutex myMutex;
};

std::atomic<MySingleton*> MySingleton::instance;
std::mutex MySingleton::myMutex;
```

Производительность реализации, основанной на семантике захвата и освобождения, незначительно отличается от реализации с семантикой последовательной согласованности.

![[ParallelProg_152.png]]
![[ParallelProg_153.png]]

Близость показателей не должна удивлять, поскольку в архитектуре x86 эти два порядка доступа к памяти работают весьма сходным образом. Более существенного выигрыша производительности можно было бы ожидать на архитектурах ARMv71 или PowerPC2. 

В завершение темы остаётся лишь сравнить все полученные результаты.

## Сводные данные

Результаты измерений говорят сами за себя. Реализация Мейерса оказалась самой быстрой. Более того, она ещё наиболее проста в исполнении. Она работает примерно вдвое быстрее реализаций на основе [[atomic|атомарных переменных]]. Как и ожидалось, синхронизация с помощью [[lock|блокировщика]] – самая неповоротливая из всех. Функция [[Thread_Safe initialization#Функция std call_once и флаг std once_flag|std::call_once]] довольно медленно работает в системе Windows.

| **Операционная система и компилятор**                                                     | **Linux (GCC)** | **Windows (cl.exe)** |
| ----------------------------------------------------------------------------------------- | --------------- | -------------------- |
| Однопоточная                                                                              | 0,03            | 0,02                 |
| Реализация Мейерса                                                                        | 0,04            | 0,03                 |
| [[lock#Тип std lock_guard\|std::lock_guard]]                                              | 12,47           | 15,48                |
| [[Thread_Safe initialization#Функция std call_once и флаг std once_flag\|std::call_once]] | 0,22            | 1,74                 |
| Последовательная согласованность                                                          | 0,09            | 0,07                 |
| Захват и освобождение                                                                     | 0,07            | 0,07                 |

Следует подчеркнуть, что представленные в таблице числа – это сумма длительностей выполнения по всем четырём потокам. Это значит, что вариант Мейерса лучше всего работает в многопоточной среде, так как он демонстрирует почти такую же скорость, как и однопоточная реализация.

