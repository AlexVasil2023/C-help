# Данные с потоковой длительностью хранения

Данные потоков, также называемые данными с потоковой длительностью хранения, создаются для каждого потока отдельно. Они напоминают локальные статические данные тем, что их время жизни ограничено временем выполнения потоков, и тем, что инициализируются переменные при первом использовании. Это означает, что переменные потоков, объявленные в пространстве имён и объявленные как статические члены класса, инициализируются до первого использования, а переменные потоков, объявленные внутри функции, создаются при её первом вызове. Переменная с потоковой длительностью хранения полностью принадлежит своему потоку.

**Данные с потоковой длительностью хранения:**
```c++
// threadLocal.cpp

#include <iostream>
#include <string>
#include <mutex>
#include <thread>

std::mutex coutMutex;
thread_local std::string s(“hello from “);

void addThreadLocal(std::string const& s2){
	s += s2;
	
	// protect std::cout
	std::lock_guard<std::mutex> guard(coutMutex);

	std::cout << s << std::endl;
	std::cout << “&s: “ << &s << std::endl;
	std::cout << std::endl;
}

int main(){
	std::cout << std::endl;

	std::thread t1(addThreadLocal,”t1”);
	std::thread t2(addThreadLocal,”t2”);
	std::thread t3(addThreadLocal,”t3”);
	std::thread t4(addThreadLocal,”t4”);

	t1.join();
	t2.join();
	t3.join();
	t4.join();
}
```

При объявлении переменной `s` в строке `thread_local std::string s(“hello from “);` используется ключевое слово `thread_local`, поэтому переменная локальна для потока. В потоках `t1` – `t4`, создаваемых в строках `std::thread t1(addThreadLocal,”t1”);`– `std::thread t4(addThreadLocal,”t4”);`, выполняется одна и та же функция `addThreadLocal`. Потоки получают в качестве аргументов строки от `«t1»` до `«t4»` и добавляют их в конец строки `s`. Кроме того, в строке `std::cout << “&s: “ << &s << std::endl;` функция выводит на печать адрес переменной `s`. Ниже показан результат запуска программы.

![[ParallelProg_66.png]]

Что для переменной значит принадлежать потоку, неявно демонстрируется выводом в строке `std::cout << s << std::endl;` и явно – в строке `std::cout << “&s: “ << &s << std::endl;`. Свой экземпляр переменой `s` создаётся для каждого потока. Каждый поток, во-первых, показывает значение своей переменой `s`, а во-вторых – свой, отличный от других потоков, её адрес.

На своих семинарах автор этой книги часто предлагает вопрос, в чём различие между [[static|статическими (static)]], `потоковыми (thread_local)` и локальными переменными. Время жизни [[static|статической переменной]] ограничено временем жизни главного потока; переменная потока живёт до тех пор, пока выполняется её поток; наконец, время жизни локальной переменной определяется временем выполнения блока, в котором она объявлена. Чтобы отчётливее пояснить это различие, ниже показана предыдущая программа `threadLocal.cpp` с небольшим изменением.

**Общее состояние для нескольких функций:**
```c++
// threadLocalState.cpp

#include <iostream>
#include <string>
#include <mutex>
#include <thread>

std::mutex coutMutex;
thread_local std::string s(“hello from “);

void first(){
	s += “first “;
}

void second(){
	s += “second “;
}

void third(){
	s += “third”;
}

void addThreadLocal(std::string const& s2){
	s += s2;
	
	first();
	second();
	third();

	// protect std::cout
	std::lock_guard<std::mutex> guard(coutMutex);

	std::cout << s << std::endl;
	std::cout << “&s: “ << &s << std::endl;
	std::cout << std::endl;
}

int main(){
	std::cout << std::endl;
	
	std::thread t1(addThreadLocal,”t1: “);
	std::thread t2(addThreadLocal,”t2: “);
	std::thread t3(addThreadLocal,”t3: “);
	std::thread t4(addThreadLocal,”t4: “);
	
	t1.join();
	t2.join();
	t3.join();
	t4.join();
}
```

В этой версии программы функция `addThreadLocal` вызывает функции `first`, `second` и `third`. Каждая из этих функций дописывает к переменной потока `s` своё имя. Таким образом, строка `s` играет роль состояния, общего для нескольких функций, выполняемых в одном потоке (строки `irst();` –
`third();`). Выводимый программой результат свидетельствует о том, что эти переменные в каждом потоке вполне независимы друг от друга.

![[ParallelProg_67.png]]

> **Переработка однопоточной программы в многопоточную**
> 
> Потоковые переменные помогают при переносе однопоточных программ в многопоточную среду. Если глобальные переменные объявить потоковыми, появляется гарантия, что каждый поток получает свою копию данных. Таким образом устраняется возможность общего изменяемого состояния, которое могло бы привести к гонке данных и, следовательно, к неопределённому поведению.

В отличие от локальных данных потока, переменные условия не столь просты в использовании.


