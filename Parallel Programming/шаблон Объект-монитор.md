
[[#Объект-монитор|Объект-монитор]] 10.2
1. [[#Требования|Требования]] 10.2.1
2. [[#Компоненты|Компоненты]] 10.2.2
3. [[#Принцип действия монитора|Принцип действия монитора]] 10.2.3
	1. [[#Преимущества и недостатки мониторов|Преимущества и недостатки мониторов]] 10.2.3.1
	2. [[#Реализация монитора|Реализация монитора]] 10.2.3.2

# Объект-монитор

Идея шаблона «Монитор» состоит в синхронизации параллельного выполнения функций-членов объекта так, чтобы не более одной из них могло выполняться в каждый момент времени. Кроме того, данный шаблон позволяет строить последовательность выполнения функций-членов объекта для решения общей задачи. Этот шаблон известен также под названием «Потокобезопасный пассивный объект».

## Требования

Если несколько потоков одновременно имеют доступ к одному объекту, должны соблюдаться следующие ограничения.

4. Во избежание гонки данных находящийся в общем доступе объект должен быть защищён от несинхронизированных операций записи и чтения.
5. Необходимые для этого механизмы синхронизации должны составлять деталь реализации объекта, а не часть его интерфейса.
6. Когда какой-либо поток заканчивает работу с общим объектом, ожидающие потоки должны получать оповещение о том, что могут приступить к работе с объектом. Этот механизм позволяет избежать мёртвых блокировок и улучшает общую производительность системы.
7. После того как функция-член объекта отработает, истинность инвариантов общего объекта должна сохраняться.

Шаблон «Монитор» представляет собой решение всех четырёх задач. Поток-клиент может получить доступ к синхронизированным функциям-членам объекта-монитора – причём благодаря наличию блокировки только одна функция может выполняться в любой момент времени. Каждый объект-монитор содержит переменную условия, через которую происходит оповещение ожидающих клиентов.

## Компоненты

Объект-монитор состоит из четырёх компонентов, как показано на следующем рисунке.

![[ParallelProg_219.png]]

8. Собственно объект-монитор, который поддерживает одну или несколько функций-членов. Каждый клиент может обращаться к объекту только посредством этих функций. Вызванная функция выполняется в потоке клиента.
9. Синхронизированные функции-члены объекта-монитора. Механизм синхронизации гарантирует, что только одна из них может выполняться в любой заданный момент времени. Для этого хорошо подходит [[Управление изменяемым состоянием#Потокобезопасный интерфейс|шаблон «Потокобезопасный интерфейс»]], – он предписывает делать различие между интерфейсными функциями-членами и внутренними, составляющими детали реализации.
10. Блокировщик монитора. Каждый объект-монитор содержит один примитив блокировки, используемый для синхронизации интерфейсных функций.
11. Условия монитора, которые позволяют различным потокам согласовать между собой вызовы функций-членов монитора. Всякий раз, когда клиент заканчивает выполнение синхронизированной функции-члена, по условию пробуждается следующий клиент, ожидающий своего права вызвать функцию монитора.

Если блокировщик гарантирует исключительный доступ к монитору единственного клиента, то условие монитора сводит к минимуму время ожидания клиентов. Если блокировщик защищает монитор от гонки данных, то условия защищают от мёртвых блокировок.

## Принцип действия монитора

Взаимодействие между различными составными частями шаблона происходит в несколько этапов.

* Когда клиент вызывает синхронизированную функцию-член монитора, в первую очередь запирается блокировщик объекта. Если клиенту удалось захватить блокировку, выполняется вызванная функция, после чего снимается блокировка. Если же захват блокировки не удался, клиент блокируется.
* Заблокированный клиент ждёт оповещения от условия монитора. Оповещение происходит в момент освобождения монитора предыдущим клиентом. Оно может отсылаться одному взятому наугад ожидающему клиенту или всем таким клиентам. Ожидание условия обычно экономно расходует машинные ресурсы, в отличие от цикла активного ожидания.
* Когда клиент получает оповещение и пробуждается, он запирает блокировщик монитора и выполняет функцию. По окончании этого блокировка снимается и высылается оповещение, пробуждающее следующего клиента.

### Преимущества и недостатки мониторов

Мониторы обладают следующими преимуществами.

* Клиент не перегружен деталями синхронизации – они полностью скрыты в реализации монитора.
* Синхронизированные функции-члены по мере вызова автоматически выстраиваются в очередь. Механизм ожидания и оповещения, воплощённый в виде условия, работает как простой планировщик.

Данный шаблон не свободен также от ряда недостатков.

* Непросто бывает изменить механизм синхронизации, заложенный в функциях-членах монитора, поскольку полезная нагрузка функции и механизм синхронизации слишком жёстко связаны друг с другом.
* Если синхронизированная функция-член монитора вызывает, прямо или косвенно, функцию того же самого объекта-монитора, может произойти мёртвая блокировка.

### Реализация монитора

В следующем примере показана реализация потокобезопасной очереди на основе шаблона «Монитор».

**Объект-монитор:**
```c++
#include <condition_variable>
#include <functional>
#include <queue>
#include <iostream>
#include <mutex>
#include <random>
#include <thread>

template <typename T>
class Monitor {
	public:
		void lock() const {
			monitMutex.lock();
		}

		void unlock() const {
			monitMutex.unlock();
		}

		void notify_one() const noexcept {
			monitCond.notify_one();
		}

		void wait() const {
			std::unique_lock<std::recursive_mutex> monitLock(monitMutex);
			monitCond.wait(monitLock);
		}
	
	private:
		mutable std::recursive_mutex monitMutex;
		mutable std::condition_variable_any monitCond;
};

template <typename T>
class ThreadSafeQueue: public Monitor<ThreadSafeQueue<T> > {
	public:
		void add(T val) {
			derived.lock();

			myQueue.push(val);

			derived.unlock();
			derived.notify_one();
		}

		T get() {
			derived.lock();
			while (myQueue.empty()) 
				derived.wait();

			auto val = myQueue.front();
			myQueue.pop();

			derived.unlock();

			return val;
		}

	private:
		std::queue<T> myQueue;
		ThreadSafeQueue<T>& derived =
		static_cast<ThreadSafeQueue<T>&>(*this);
};

class Dice {
	public:
		int operator()() { return rand(); }
	
	private:
		std::function<int()> rand = std::bind(
			std::uniform_int_distribution<>(1, 6),
			std::default_random_engine()
		);
};

int main(){
	std::cout << std::endl;

	constexpr auto NUM = 100;

	ThreadSafeQueue<int> safeQueue;
	auto addLambda = [&safeQueue] (int val){ safeQueue.add(val); };
	auto getLambda = [&safeQueue] {
			std::cout
			<< safeQueue.get()
			<< “ “
			<< std::this_thread::get_id()
			<< “; “;
	};

	std::vector<std::thread> addThreads(NUM);
	Dice dice;
	
	for (auto& thr: addThreads) 
		thr = std::thread(addLambda, dice() );

	std::vector<std::thread> getThreads(NUM);
	for (auto& thr: getThreads) 
		thr = std::thread(getLambda);

	for (auto& thr: addThreads) 
		thr.join();
		
	for (auto& thr: getThreads) 
		thr.join();
		
	std::cout << “\n\n”;
}		
```

Основная идея этого примера состоит в том, что монитор реализован в виде класса и, следовательно, допускает многократное использование. В классе `Monitor` используются вспомогательные переменные-члены типа [[mutex#std recursive_mutex|std::recursive_mutex]] для блокировки и типа [[variable conditions|std::condition_variable_any]] в качестве условия монитора. В отличие от знакомого по предыдущим примерам типа [[variable conditions|std::condition_variable]], этот последний может использоваться совместно с рекурсивным мьютексом. Обе эти переменные объявлены с ключевым словом [[mutable|mutable]] и, следовательно, их можно модифицировать в константных функциях. Класс `Monitor` обладает минимально возможным интерфейсом, который должен поддерживать всякий объект-монитор.

Класс `ThreadSafeQueue`, объявленный в строках `class ThreadSafeQueue: public Monitor<ThreadSafeQueue<T> > { ... }`, представляет собой обёртку над стандартным типом очереди [[queue|std::queue]] с потокобезопасным интерфейсом. Для этого класс `ThreadSafeQueue` порождён от класса `Monitor` и пользуется его функциями-членами в реализации своих синхронизированных функций `add` и `get`. Эти две функции используют предоставляемый монитором примитив блокировки, для того чтобы защитить состояние монитора, в частности контейнер `myQueue`. Функция `add` оповещает ожидающие потоки о добавлении в очередь нового элемента. Отсылка оповещения происходит потокобезопасным образом.

Порождение класса (в данном примере – класса `ThreadSafeQueue`) от шаблона класса, параметризованного этим же самым порождённым классом, – часто используемая идиома, характерная для языка C++, известная под названием CRTP1. Ключевую роль в этой идиоме играет переменная-член `derived` типа `ThreadSafeQueue<T>&`. Она представляет собой ссылку на текущий объект, приведённую к порождённому классу.

> Представленная в этой главе программа недостаточно показательна в качестве примера использования идиомы CRTP. В самом деле, поведение программы не изменится, если из шаблона класса `Monitor` сделать обычный класс, тогда отпадает необходимость в переменной-ссылке `derived`, появляется возможность обращаться к членам базового класса напрямую. #Хороший_материал_для_начального_знакомства_с_идиомой_CRTP_на_русском_языке_можно_найти_здесь: https://habr.com/ru/post/543098

> Это утверждение крайне спорно. В идиоме CRTP объявление переменной-ссылки `derived` (или заменяющей её функции-члена) должно располагаться не в порождённом классе, как показано в данном примере, а в базовом – это даёт возможность из базового класса обращаться к членам порождённого класса, реализуя тем самым полиморфизм на этапе компиляции. Эта ключевая особенность, составляющая суть идиомы CRTP, в данном примере никак не используется. Объявление ссылки `derived` типа `ThreadSafeQueue<T>&` в порождённом классе никакой полезной нагрузки не несёт, так как указатель `this` в нём и без того имеет нужный тип.

Объект-монитор `safeQueue`, объявленный в строке `ThreadSafeQueue<int> safeQueue;`, используется в двух лямбда-функциях: первая из них добавляет число в очередь, а другая извлекает его. `ThreadSafeQueue` представляет собой шаблон класса и может хранить значения произвольного типа. Начиная со строки `std::vector<std::thread> addThreads(NUM);` показано, как 100 потоков-клиентов, работая параллельно, добавляют по 100 случайных чисел из диапазона от 1 до 6 в очередь `safeQueue`, тем временем как другие 100 потоков выбирают из очереди каждый по 100 чисел. При этом программа выводит на печать числа и идентификаторы потоков.

![[ParallelProg_220.png]]

> **CRTP: странно рекурсивный шаблон**
>
> Сокращение CRTP образовано от словосочетания «curiously recurring template pattern» и означает часто используемую в языке C++ идиому, состоящую в том, что производный класс `Derived` порождается от класса-шаблона `Base`, в который класс `Derived` подставлен в качестве аргумента:
```c++
template<class T>
class Base{
	....
};

class Derived : public Base<Derived>{
	....
};
```

> Ключ к пониманию идиомы CRTP состоит в том, что инстанцирование функций-членов выполняется ленивым способом. Это значит, что код функций-членов генерируется только тогда, когда это становится необходимо. У идиомы CRTP два основных применения.
>	> Статический полиморфизм – подход, позволяющий, подобно динамическому полиморфизму, через интерфейс базового класса вызывать реализацию функции в некотором порождённом классе, о котором базовый класс не знает. В отличие от динамического полиморфизма, однако, здесь выбор конкретной реализации осуществляется на этапе компиляции.
>	> Программирование примесей (англ. mixin). Это популярный подход, состоящий в разработке классов таким образом, чтобы пользователям легко было добавлять в них новый код. В приведённом примере класс `ThreadSafeQueue` порождён от базового класса `Monitor` и получает все функции-члены этого класса.
>
> В статье «Язык C++ ленив: CRTP» эта идиома описана более подробно.

Шаблоны проектирования «Активный объект» и «Объект-монитор» похожи между собой, но отличаются рядом важных аспектов. Оба шаблона имеют целью синхронизацию доступа к совместно используемому объекту. Функции-члены активного объекта выполняются не в том потоке, который их вызвал, в отличие от объекта-монитора. Это означает, что активный объект обеспечивает более глубокую развязку между вызовом и выполнением функций-членов, и, следовательно, построенные на его основе системы проще поддерживать.

