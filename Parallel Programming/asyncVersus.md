
[[#Асинхронные задания]] 3.9
1. [[#Отличие заданий от потоков|Отличие заданий от потоков]] 3.9.1
2. [[async#std async|Функция std::async]] 3.9.2
	1. [[async#Политика запуска|Политика запуска]] 3.9.2.1
	2. [[async#Запустить и забыть|Запустить и забыть]] 3.9.2.2
	3. [[async#Параллельное вычисление скалярного произведения|Параллельное вычисление скалярного произведения]] 3.9.2.3
3. [[packaged_task#std packaged_task|Тип std::packaged_task]] 3.9.3
4. [[Promise and Future#Типы std promise и std future|Типы std::promise и std::future]] 3.9.4
	1. [[promise#std promise|Тип std::promise]] 3.9.4.1
	2. [[future#std future|Тип std::future]] 3.9.4.2
		1. [[future#Состояние фьючерса|Состояние фьючерса]] 3.9.4.2.1
5. [[future#std shared_future|Тип std::shared_future]] 3.9.5
6. [[Error_in_Assinc_task|Обработка исключений в асинхронных заданиях]] 3.9.6
7. [[Notify#Оповещения|Оповещения]] 3.9.7

# Асинхронные задания

Помимо [[thread#std thread|потоков]], стандарт языка C++ включает ещё [[task#std task|задания]], позволяющие выполнять работу асинхронно. Чтобы использовать задания, нужно подключить заголовочный файл `<future>`. Задание характеризуется пакетом работы, которую предстоит выполнить, и обладает двумя частями: [[promise|обещанием (promise)]] и [[future|фьючерсом (future)]]. Они соединены собой в подобие канала, по которому проходят данные. [[promise|Обещание]] запускает пакет работы и помещает результат его выполнения в канал; [[future|фьючерс]] извлекает этот результат из канала. Оба этих разъёма могут функционировать в различных потоках. Существенно, что [[future|фьючерс]] позволяет забрать готовый результат работы в любое время после того, как он готов. Поэтому запуск [[task|задания]] посредством [[promise|обещания]] и запрос результата через соответствующий [[future|фьючерс]] становятся независимыми друг от друга.

> **Задания как каналы передачи данных:**
>
> [[task|Задания]] ведут себя подобно каналам, по которым данные проходят от входного разъёма до выходного. Один конец канала называется [[promise|обещанием]], другой – [[future|фьючерсом]].
> 
> Этими разъёмами может управлять один и тот же канал, а могут – разные. [[promise|Обещание]] помещает данные в канал. [[future|Фьючерс]] в неопределённый момент в будущем извлекает из канала результат их преобразования.

![[ParallelProg_80.png]]

## Отличие заданий от потоков

Задания – совсем не то же самое, что потоки. Начнём с примера.

**Отличие асинхронных заданий от потоков:**
```c++
// asyncVersusThread.cpp

#include <future>
#include <thread>
#include <iostream>

int main(){
	std::cout << std::endl;
	
	int res;
	std::thread t([&]{ res = 2000 + 11; });
	t.join();
	
	std::cout << “res: “ << res << std::endl;

	auto fut= std::async([]{ return 2000 + 11; });
	std::cout << “fut.get(): “ << fut.get() << std::endl;
	
	std::cout << std::endl;
}
```

Дочерний поток `t` и асинхронная функция `fut` выполняют одно и то же вычисление: складывают числа `2000` и `11`. Родительский поток получает результат из потока `t` через находящуюся в общем доступе переменную `res` и отображает её значение в строке `std::cout << “res: “ << res << std::endl`. Вызов функции [[async|std::async]] в создаёт канал передачи данных от источника ([[promise|обещания]]) к получателю ([[future|фьючерсу]]). Далее, в строке `std::cout << “fut.get(): “ << fut.get() << std::endl`, [[future|фьючерс]] используется для того, чтобы запросить данные из канала функцией `get`, и тем вынуждает выполнить асинхронное вычисление до конца. Поэтому вызов функции `get` блокирует выполнение главного потока. Ниже представлен результат работы программы.

![[ParallelProg_81.png]]

Разобрав этот пример, можно более точно описать различия между [[thread|потоками]] и [[task|заданиями]]. Различия показаны в следующей таблице.

**Отличие заданий от потоков:**

| **Критерий**                           | **Потоки**                                      | **Задания**                         |
| -------------------------------------- | ----------------------------------------------- | ----------------------------------- |
| Основные сущности                      | Родительский и дочерний потоки                  | Обещание и фьючерс                  |
| Способ передачи данных                 | Общая переменная                                | Канал                               |
| Отдельный поток                        | Всегда                                          | Иногда                              |
| Синхронизация                          | Функция `join` ожидает завершения потока        | Функция `get` блокирует выполнение  |
| Исключение в дочернем потоке (задании) | Оба потока завершаются вместе со всем процессом | Передаётся через обещание и фьючерс |
| Передаваемые данные                    | Значения                                        | Значения, оповещения и исключения   |

Для работы с потоками нужно подключить заголовочный файл `<thread>`, а для работы с заданиями – `<future>`. Для обмена данными между родительским и дочерним потоками нужна переменная, к которой имеют доступ оба потока. Взаимодействие с заданием происходит через канал. Как следствие заданиям не нужны примитивы синхронизации наподобие [[mutex|мьютексов]].

Если общей переменной, через которую обмениваются данными родительский и дочерний потоки, можно злоупотребить, взаимодействие с заданием носит более явный характер. Результат выполнения задания можно запросить через [[future|фьючерс]] только один раз, вызвав его функцию `get`. Повторный вызов этой функции на том же [[future#std future|фьючерсе]] приводит к неопределённому поведению. Это не относится, однако, к классу [[future#std shared_future|std::shared_future]], из которого значение можно запрашивать многократно.

Родительский поток ждёт завершения дочернего, вызывая функцию `join`. С [[future|фьючерсом]] нужно использовать функцию `get`, которая блокирует выполнение до тех пор, пока результат задания не станет доступен.

Если исключение возникает и не перехватывается в потоке, завершается и этот поток, и создавший его, и весь процесс. Для сравнения: [[promise|обещание]] умеет отправить своё исключение [[future|фьючерсу]], откуда его можно достать и обработать.

[[promise|Обещание]] может обслуживать один или несколько [[future|фьючерсов]]. Оно может посылать значение, исключение или просто оповещение. [[promise|Обещания]] можно использовать в качестве безопасной замены для [[variable conditions|переменной условия]].

Самый простой способ создать [[future|фьючерс]] предоставляет функция [[async|std::async]].

## Функция std::async

см. [[async#std async|Функция std::async]]

## Тип std::packaged_task

см. [[packaged_task#std packaged_task|Тип std::packaged_task]]

## Типы std::promise и std::future

см. [[Promise and Future#Типы std promise и std future|Типы std::promise и std::future]]

## Тип std::shared_future

см. [[future#std shared_future|Тип std::shared_future]]

## Обработка исключений в асинхронных заданиях

см. [[Error_in_Assinc_task|Обработка исключений в асинхронных заданиях]]

## Оповещения

см. [[Notify#Оповещения|Оповещения]]
