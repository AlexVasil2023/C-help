[[#std thread|std::thread]]
1. [[#Базовые потоки класс std thread|Базовые потоки: класс std::thread]] 3.1
	1. [[#Создание потока]] 3.1.1
	2. [[#Время жизни потоков]] 3.1.2
		1. [[#Функции join и detach]] 3.1.2.1
	3. [[#Передача аргументов при создании потока|Передача аргументов при создании потока]] 3.1.3
		1. [[#Передача по значению и по ссылке|Передача по значению и по ссылке]] 3.1.3.1
	4. [[#Перечень функций-членов]] 3.1.4 
2. [[#std jthread|Усовершенствованные потоки: класс std::jthread (стандарт С++ 20)]] 3.2
	1. [[#Автоматическое присоединение к потоку|Автоматическое присоединение к потоку]] 3.2.1
	2. [[#Прерывание по запросу в классе std jthread|Прерывание по запросу в классе std::jthread]] 3.2.2
	3. [[#Особенности класса std jthread]] 3.6.5
3. [[#std scoped_thread|std::scoped_thread]]

# std::thread

Класс `std::thread` служит обёрткой для потока – независимой единицы выполнения в составе программы. Выполняемая единица запускается сразу после своего создания, для этого она должна получить на вход вызываемый объект, который и задаёт, что должно быть сделано в потоке. Вызываемый объект может быть именованной функцией, функциональным объектом или лямбда-функцией.

Код, который создаёт поток, отвечает за его дальнейшую судьбу. Единица выполнения, работающая в потоке, завершается с окончанием работы своего вызываемого объекта. Создатель потока может либо присоединить поток, т.е. подождать его завершения посредством вызова `join`, либо отсоединиться от потока, вызвав функцию `detach`. Поток `t` находится в присоединяемом состоянии, если над ним не выполнялась ни одна из операций `join` и `detach`. Если в момент вызова деструктора объект-поток находится в присоединяемом состоянии, деструктор вызывает функцию `std::terminate`, которая приводит к аварийному завершению программы.

Поток, отсоединённый от своего создателя, часто называют потоком-демоном, поскольку он выполняется в фоновом режиме.

Под именем `std::thread` скрывается шаблон класса с переменным числом параметров. Это означает, что при создании потока можно передавать любое число аргументов, так как разное число аргументов могут принимать выполняющиеся в потоке вызываемые объекты.

Библиотека `std::thread` предоставляет стандартный способ управления потоками.
```c++
void foo(bool clause) { 
	/* do something... */ 
} 

std::vector<std::thread> threadsVector; 
threadsVector.emplace_back([]() { 
	// Лямбда-функция, которая будет вызвана 
}); 

threadsVector.emplace_back(foo, true); // поток запустит foo(true) 

for (auto& thread : threadsVector) 
	thread.join(); // ожидание окончания работы потоков
```

# Базовые потоки: класс std::thread

Чтобы создать поток в программе на языке C++, нужно подключить заголовочный файл `<thread>`.

## Создание потока

Объект типа `std::thread` представляет единицу выполнения программы. То, что должно быть выполнено в потоке, передаётся объекту `std::thread` при его создании в виде вызываемого объекта.

Вызываемый объект ведёт себя подобно функции. Конечно, он может быть в том числе и функцией, но также может быть функциональным объектом или лямбда-функцией. Значение, возвращаемое вызываемым объектом, игнорируется.

Сделав эти вводные замечания, можно рассмотреть пример.

Создание потоков с различными вызываемыми объектами:
```c++
// createThread.cpp

#include <iostream>
#include <thread>

void helloFunction(){
	std::cout << “Hello from a function.” << std::endl;
}

class HelloFunctionObject{
	public:
		void operator()() const {
			std::cout << “Hello from a function object.” << std::endl;
		}
};

int main(){
	std::cout << std::endl;
	
	std::thread t1(helloFunction);
	
	HelloFunctionObject helloFunctionObject;

	std::thread t2(helloFunctionObject);
	std::thread t3([]{std::cout << “Hello from a lambda.” << std::endl;});

	t1.join();
	t2.join();
	t3.join();
	
	std::cout << std::endl;
};
```

Все три потока, `t1`, `t2` и `t3`, печатают сообщения на консоль. При этом в потоке `t1` выполняется обычная функция, в потоке `t2` выполняется функциональный объект (класс), а в потоке `t2` – лямбда-функция. В строках `t1.join()` – `t3.join()` главный поток ожидает завершения всех дочерних потоков.

Посмотрим, как работает эта программа. Результаты её запуска довольно интересны.

![[ParallelProg_49.png]]

Три потока могут выполняться в произвольном порядке. Даже тексты, выводимые из разных потоков, могут перемешиваться между собой.

В этом примере главный поток, создающий дочерние потоки, отвечает за время жизни этих объектов.

## Время жизни потоков

Родители должны заботиться о своих детях. Из этого простого принципа вытекают далекоидущие следствия касательно времени жизни потоков. Рассмотрим пример: следующая программа должна запускать поток и выводить его идентификатор.

Забытое ожидание завершения потока:
```c++
// threadWithoutJoin.cpp

#include <iostream>
#include <thread>

int main(){
	std::thread t([]{std::cout << std::this_thread::get_id() << std::endl;});
}
```

Однако программа этого не делает.
![[ParallelProg_50.png]]

### Функции join и detach

Жизнь потока `t` завершается с окончанием выполнения его вызываемого объекта. У создателя потока есть на выбор два варианта:

* подождать завершения дочернего потока с помощью вызова `t.join()`;
* оборвать связь с дочерним потоком с помощью вызова `t.detach()`.

Вызов `t.join()` полезен в случаях, когда последующий код каким-то образом зависит от результатов работы дочернего потока. Вызов `t.detach()` позволяет дочернему потоку выполняться независимо от объекта `t`. Это значит, что поток, отсоединённый от объекта, будет выполняться до тех пор, пока не завершится выполняющийся в нём код. Чаще всего отсоединяют потоки, в которых выполняется долгая фоновая работа, например потоки-серверы.

Объект-поток с завёрнутым в него вызываемым объектом (объекты типа `std::thread` можно создавать и пустыми, без вызываемых объектов) называется присоединяемым (англ. joinable), если для него не вызывалась ни одна из функций-членов `join` и `detach`. Деструктор объекта-потока в присоединяемом состоянии вызывает аварийное завершение программы посредством [[terminate|std::terminate]]. Именно в этом причина аварийного завершения программы `threadWithoutJoin.cpp`. Если применить функцию `join` или `detach` к объекту, для которого какая-либо из этих функций-членов уже была вызвана ранее, произойдёт исключение типа `std::system_error`.

Исправить предыдущую программу довольно легко – для объекта-потока `t` вызвать функцию-член `join`.

```c++
// threadWithoutJoin.cpp

#include <iostream>
#include <thread>

int main(){
	std::thread t([]{std::cout << std::this_thread::get_id() << std::endl;});
	
	t.join();
}
```

Теперь программа работает так, как ожидалось.

Число, которое программа выводит на печать, – это уникальный идентификатор потока в системе.

> **Трудность с функцией `detach`**
> 
> Конечно же, в последней программе вместо функции `join` можно было бы применить функцию `detach`. Объект-поток `t` перешёл бы в неприсоединяемое состояние, и его деструктор не стал бы аварийно завершать программу. Но в этом случае возникло бы иное затруднение. Поведение такой программы не определено, поскольку главный поток может завершиться раньше дочернего, и тогда последнему просто не останется времени, чтобы вывести на печать свой результат. Подробнее об #разделе_13_7.

> **Класс `scoped_thread` Энтони Уильямса**
> 
>Если своими руками управлять временем жизни потоков слишком обременительно, можно инкапсулировать класс `std::thread` в собственный класс-обёртку. Деструктор этого класса должен автоматически вызывать функцию `join` потока, если тот всё ещё находится в присоединяемом состоянии. Конечно, можно поступить и противоположным образом, автоматически вызывая для потока функцию `detach` – однако это может быть сопряжено с определёнными трудностями.
>
> Энтони Уильямс создал такой полезный класс и описал его в своей превосходной книге «Параллельное программирование на C++ в действии». Класс-обёртку он назвал `scoped_thread`. Конструктор этого класса принимает в качестве аргумента поток `t` и проверяет, находится ли он попрежнему в присоединяемом состоянии. Если поток-аргумент `t` не поддерживает присоединение, нет и необходимости в классе `scoped_thread`. Если же поток `t` можно присоединить, деструктор класса вызывает `t.join()`. Поскольку конструктор копирования и копирующая операция присваивания в явном виде удалены, экземпляры класса `scoped_thread` не могут копироваться никаким способом.

```c++
// scoped_thread.cpp
#include <iostream>
#include <thread>
#include <utility>

class scoped_thread{
		std::thread t;
	
	public:
		explicit scoped_thread(std::thread t_): t(std::move(t_)){
			if (!t.joinable()) throw std::logic_error(“No thread”);
		}
		
		~scoped_thread(){
			t.join();
		}
		
	scoped_thread(scoped_thread&)= delete;
	scoped_thread& operator=(scoped_thread const &)= delete;
};
```

## Передача аргументов при создании потока

Вызываемый объект, выполняющийся в потоке (в частности, обычная функция), может получать свои аргументы посредством копирования значения, по перемещению или по ссылке. Класс `std::thread` представляет собой шаблон с переменным числом аргументов, или, как их ещё называют, вариадический шаблон.

Если поток получает на вход данные по ссылке, нужно быть чрезвычайно осторожным в том, что касается времени жизни передаваемых объектов и совместного доступа к данным.

### Передача по значению и по ссылке

Рассмотрим следующий небольшой фрагмент кода:

```C++
std::string s{“C++11”}

std::thread t1([=]{ std::cout << s << std::endl; });
t1.join();

std::thread t2([&]{ std::cout << s << std::endl; });
t2.detach();
```

Поток `t1` получает данные по значению (т. е. путём создания копии), а поток `t2` – по ссылке.

> **Передача аргументов в поток по ссылке**
> 
> По правде говоря, в этом примере допущено некоторое упрощение. Там сказано, что поток `t2` получает аргумент по ссылке, однако на самом деле это лямбда-функция захватывает ссылку на локальные данные. Чтобы передать по ссылке аргумент в функцию потока, нужно завернуть его в класс-обёртку ссылок. Это просто сделать, воспользовавшись вспомогательной функцией `std::ref`, определённой в заголовочном файле `<functional>`. Например:
```c++
void transferMoney(int amount, Account& from, Account& to){
	...
}

...

std::thread thr1(transferMoney, 50, std::ref(account1),
				 std::ref(account2));
```

> Здесь поток `thr1` выполняет функцию `transferMoney`, которая получает аргументы по ссылке. Благодаря использованию функции `std::ref` в функцию будут переданы ссылки на объекты `account1` и `account2`.

Какие тонкости могут таиться в этих строчках кода? Поток `t2` получает строку `s` по ссылке, а затем отсоединяется от родительского потока. Время жизни строки `s` ограничено временем выполнения объемлющей функции. Время жизни глобального объекта `std::cout` ограничивается только временем выполнения главного потока программы. Поэтому время жизни объектов `s` и `std::cout` может оказаться короче, чем время выполнения потока `t2`. Таким образом мы оказываемся по уши в неопределённом поведении.

Передача в поток аргументов по ссылке:
```c++
// threadArguments.cpp

#include <chrono>
#include <iostream>
#include <thread>

class Sleeper{
	public:
		Sleeper(int& i_):i{i_}{};

		void operator() (int k){
			for (unsigned int j= 0; j <= 5; ++j){
				std::this_thread::sleep_for(
									std::chrono::milliseconds(100));
				i += k;
			}
		}
		
	private:
		int& i;
};

int main(){
	std::cout << std::endl;

	int valSleeper = 1000;
	std::thread t(Sleeper(valSleeper), 5);
	t.detach();
	
	std::cout << “valSleeper = “ << valSleeper << std::endl;
	
	std::cout << std::endl;
}
```

Какое значение имеет переменная `valSleeper` в строке `std::cout << “valSleeper = “ << valSleeper << std::endl`? Переменная `valSleeper` живёт, пока выполняется функция `main`. Поток `t` получает для работы функциональный объект, в который завёрнута ссылка на переменную `valSleeper`, и число 5. Главное в этом примере то, что поток `t` получает переменную `valSleeper` по ссылке (`Sleeper(int& i_):i{i_}{}`) и отсоединяется от главного потока (строка `t.detach()`). В дочернем потоке выполняется перегруженная операция вызова функционального объекта (`void operator() (int k)`). В этой функции цикл увеличивает счётчик от 0 до 5 включительно, на каждой итерации ждёт 1/10 секунды и увеличивает переменную `i` на величину `k`. В конце дочерний поток должен напечатать свой идентификатор. Считая, как говорят в Германии, «по Адаму Ризе», результат должен составлять
```
1000 + 6 * 5 = 1030
```

Однако как же программа работает на самом деле? Что-то в ней идёт не так.

![[ParallelProg_52.png]]

Программа обнаруживает два странных свойства. Во-первых, значение переменной `valSleeper` в конце оказывается равным `1000`, а во-вторых, идентификатор дочернего потока на печать не выводится. Программа страдает по меньшей мере двумя изъянами.

4. Разные потоки имеют ничем не ограниченный доступ к переменной `valSleeper`. Здесь имеет место гонка данных, поскольку потоки могут одновременно производить чтение и запись этой переменной.
5. Время жизни главного потока завершается раньше, чем дочерний поток успевает выполнить все свои вычисления и вывести свой идентификатор в поток `std::cout`.

Оба названных обстоятельства переводят программу в состояние гонки, поскольку результат работы программы зависит от относительной скорости выполнения операций в разных потоках. Состояние гонок выступает причиной гонки данных.

Исправить гонку данных довольно просто. Для этого достаточно защитить переменную `valSleeper` мьютексом или сделать её атомарной. Что-бы преодолеть ошибку, связанную со временем жизни объектов `valSleeper` и `std::cout`, нужно не отсоединять дочерний поток, а, напротив, присоединить его выполнение (функция `join`). Ниже представлена исправленная функция `main`.
```c++
int main(){
	std::cout << std::endl;

	int valSleeper= 1000;
	std::thread t(Sleeper(valSleeper),5);
	t.join();
	
	std::cout << “valSleeper = “ << valSleeper << std::endl;
	
	std::cout << std::endl;
}
```

Теперь программа выдаёт правильный результат, хотя, конечно, и выполняется медленнее.

![[ParallelProg_53.png]]

## Перечень функций-членов

Интерфейс класса `std::thread` показан ниже в виде таблицы. Более подробные сведения можно найти на сайте cppreference.com.

**Функции-члены класса `std::thread`**

| **Функция**                             | **Описание**                                                          |
| --------------------------------------- | --------------------------------------------------------------------- |
| `join`                                  | Ждать завершения потока                                               |
| `detach`                                | Разорвать связь с потоком и оставить его выполняться независимо       |
| `joinable`                              | Узнать, находится ли поток в присоединяемом состоянии                 |
| `get_id`,<br>`std::this_thread::get_id` | Узнать идентификатор потока                                           |
| `hardware_concurrency`                  | Узнать, сколько потоков может выполняться параллельно                 |
| `std::this_thread::sleep_until`         | Погрузить поток в сон до определённого абсолютного момента времени    |
| `std::this_thread::sleep_for`           | Погрузить поток в сон на заданное время относительно текущего момента |
| `std::this_thread::yield`               | Уступить выполнение другому потоку                                    |
| `t1.swap(t2)`<br>`std::swap(t1, t2)`    | Обменять местами два объекта                                          |

> **Доступ к системно-зависимой реализации**
> 
> Классы из стандартной библиотеки представляют собой обёртку над реализацией потоков в конкретной платформе. Для доступа к системному дескриптору потока можно воспользоваться функцией `native_handle`. Такие системные дескрипторы можно получать для потоков, [[mutex|мьютексов]] и переменных условия.

Объекты класса `std::thread` нельзя копировать, но можно перемещать. Функция `swap` обменивает местами содержимое двух объектов, пользуясь для этого перемещением.

**Функции-члены класса `std::thread`**
```c++
// threadMethods.cpp

#include <iostream>
#include <thread>
using namespace std;

int main(){
	cout << boolalpha << endl;

	cout << “hardware_concurrency()= “
						<< thread::hardware_concurrency() << endl;

	thread t1([]{cout << “t1 with id= “ << this_thread::get_id() 
														<< endl;});
	thread t2([]{cout << “t2 with id= “ << this_thread::get_id() 
														<< endl;});

	cout << endl;
	
	cout << “FROM MAIN: id of t1 “ << t1.get_id() << endl;
	cout << “FROM MAIN: id of t2 “ << t2.get_id() << endl;

	cout << endl;

	swap(t1,t2);

	cout << “FROM MAIN: id of t1 “ << t1.get_id() << endl;
	cout << “FROM MAIN: id of t2 “ << t2.get_id() << endl;
	
	cout << endl;
	
	cout << “FROM MAIN: id of main= “ << this_thread::get_id() << endl;

	cout << endl;

	cout << “t1.joinable(): “ << t1.joinable() << endl;

	cout << endl;

	t1.join();
	t2.join();
	
	cout << endl;
	
	cout << “t1.joinable(): “ << t1.joinable() << endl;
	
	cout << endl;
}
```

результат её работы:
![[ParallelProg_54.png]]

Может показаться странным, что потоки `t1` и `t2` (строки `thread t1([]{cout << “t1 with id= “ << this_thread::get_id() << endl;})` и `thread t2([]{cout << “t2 with id= “ << this_thread::get_id() << endl;})`) отрабатывают в столь различные моменты времени. Однако это нормально: у программиста нет никаких гарантий относительно того, когда и с какой скоростью выполняются потоки. С уверенностью можно сказать лишь, что выполнение потоков завершится к моменту завершения функции `join`, вызванной в строках `t1.join()` и `t2.join()`.

Управление параллельными потоками тем труднее, чем больше изменяемых (т. е. неконстантных) данных находится у них в общем доступе.

# std::jthread

Название `jthread` означает «присоединяемый» (англ. joinable) поток. В дополнение ко всему, что умеет делать класс [[thread#std thread|std::thread]], введённый в стандарте C++11, этот класс ожидает завершения потока в деструкторе и поддерживает кооперативное прерывание. Тем самым класс `std::jthread` расширяет интерфейс класса [[thread#std thread|std::thread]].

В следующей таблице представлен обзор функциональных возможностей, добавленных в классе `std::jthread`.

**Дополнительные функции-члены класса `std::jthread`:**

| **Имя**           | **Описание**                                                             |
| ----------------- | ------------------------------------------------------------------------ |
| `get_stop_source` | Возвращает объект типа `std::stop_source`, связанный с флагом завершения |
| `get_stop_token`  | Возвращает объект типа `std::stop_token`, связанный с флагом завершения  |
| `request_stop`    | Запрашивает завершение выполнения через флаг                             |

## Автоматическое присоединение к потоку

Поведение класса [[#std thread|std::thread]] противоречит ожиданиям: если на момент вызова деструктора поток находится в присоединяемом состоянии, выполнение всей программы аварийно завершается вызовом [[terminate|std::terminate]]. Напомним, что поток находится в присоединяемом состоянии, если он был запущен и для него не вызывалась ни одна из функций `join` или `detach`.

**Аварийно завершающаяся программа с присоединяемым потоком:**
```c++
// threadJoinable.cpp

#include <iostream>
#include <thread>

int main() {
	std::cout << std::endl;
	std::cout << std::boolalpha;
	
	std::thread thr{[]{ std::cout << “Joinable std::thread” 
												<< std::endl; }};
	std::cout << “thr.joinable(): “ << thr.joinable() 
												<< std::endl;
	
	std::cout << std::endl;
}
```

Если эту программу запустить, она завершится с ошибкой.

![[ParallelProg_55.png]]

Оба запуска программы завершаются с ошибкой. При этом во второй раз у потока `thr` оказывается вдоволь времени, чтобы вывести своё сообщение: `«Joinable std::thread»`.

Следующий код во всём подобен предыдущему, за исключением замены класса [[#std thread|std::thread]] классом `std::jthread` из стандарта C++ 20.

**Завершение потока `std::jthread` в присоединяемом состоянии:**
```c++
// jthreadJoinable.cpp

#include <iostream>
#include <thread>

int main() {
	std::cout << std::endl;
	std::cout << std::boolalpha;

	std::jthread thr{[]{ std::cout << “Joinable std::jthread” 
												<< std::endl; }};

	std::cout << “thr.joinable(): “ << thr.joinable() << std::endl;
	std::cout << std::endl;
}
```

Теперь выполнение дочернего потока автоматически присоединяется к главному потоку при деструкции объекта `thr`, поскольку в момент выхода за область видимости он всё ещё находится в присоединяемом состоянии.

Ниже показано, как мог бы быть реализован деструктор класса `std::jthread`.

**Деструктор класса std::jthread:**
```c++
jthread::~jthread() {
	if(joinable()) {
		request_stop();
		join();
	}
}
```

В первую очередь деструктор проверяет, по-прежнему ли поток допускает присоединение (строка `if(joinable())`). Поток находится в присоединяемом состоянии, если он был запущен и для него не вызывалась ни одна из функций `join` или `detach`. Если присоединение имеет смысл, деструктор запрашивает завершение потока (строка `request_stop()`) и затем вызывает функцию `join`. Этот вызов блокирует вызывающий поток до тех пор, пока не закончится выполнение дочернего потока.

## Прерывание по запросу в классе std::jthread

Чтобы проиллюстрировать основную идею, начнём с простого примера.

**Прерываемый и непрерываемый потоки:**
```c++
// interruptJthread.cpp

#include <chrono>
#include <iostream>
#include <thread>

using namespace::std::literals;

int main() {
	std::cout << ‘\n’;
	
	std::jthread nonInterruptable([]{
		int counter{0};
		while (counter < 10){
			std::this_thread::sleep_for(0.2s);
			std::cerr << “nonInterruptable: “ << counter << ‘\n’;
			++counter;
		}
	});
	
	std::jthread interruptable([](std::stop_token stoken){
		int counter{0};
		while (counter < 10){
			std::this_thread::sleep_for(0.2s);
			if (stoken.stop_requested()) return;
			std::cerr << “interruptable: “ << counter << ‘\n’;
			++counter;
		}
	});
	
	std::this_thread::sleep_for(1s);

	std::cerr << ‘\n’;
	std::cerr << “Main thread interrupts both jthreads” << ‘\n’;
	
	nonInterruptable.request_stop();
	interruptable.request_stop();
	
	std::cout << ‘\n’;
}
```

В главном потоке запускаются два дочерних потока: `nonInterruptible` (с англ. «непрерываемый») в строке `std::jthread nonInterruptable([]{` и `interruptible` (соотв. «прерываемый») в строке `std::jthread interruptable([](std::stop_token stoken){`. В отличие от непрерываемого потока, прерываемый получает объект `std::stop_token` (флаг завершения) и использует его в строке `if (stoken.stop_requested()) return;` для проверки того, не запросил ли кто-либо завершение потока (для этого служит функция-член `stop_requested`). Если завершение запрошено, [[Lambda|лямбда-функция]] возвращает управление, и тем самым завершается работа потока.

Вызов функции `request_stop` в строке `interruptable.request_stop();` запрашивает завершение потока. Однако на первый поток `nonInterruptible` этот запрос не действует: поток просто не реагирует на него.

![[ParallelProg_56.png]]

## Особенности класса std::jthread

Класс [[#std jthread|std::jthread]] представляет собой почти что копию класса [[#std thread|std::thread]] с дополнительными возможностями: кооперативным прерыванием и автоматическим присоединением. Для поддержки обеих этих возможностей поток [[#std thread|std::thread]] обладает встроенным объектом [[Кооперативное прерывание потоков#Класс std stop_token|std::stop_token]].

| **Функция**       | **Описание**                                                                                                                         |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `get_stop_source` | Возвращает объект типа [[Кооперативное прерывание потоков#Класс std stop_source\|std::stop_source]], связанный с состоянием останова |
| `get_stop_token`  | Возвращает объект типа [[Кооперативное прерывание потоков#Класс std stop_token\|std::stop_token]], связанный с состоянием останова   |
| `request_stop`    | Запрашивает останов потока через состояние останова                                                                                  |

# std::scoped_thread
#std_scoped_thread
