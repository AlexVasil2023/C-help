[[#std thread|std::thread]]
1. [[#Базовые потоки класс std thread|Базовые потоки: класс std::thread]] 3.1
	1. [[#Создание потока]] 3.1.1
	2. [[#Время жизни потоков]] 3.1.2
		1. [[#Функции join и detach]] 3.1.2.1
	3. [[#Передача аргументов при создании потока|Передача аргументов при создании потока]] 3.1.3
		1. [[#Передача по значению и по ссылке|Передача по значению и по ссылке]] 3.1.3.1
	4. [[#Перечень функций-членов]] 3.1.4 
2. [[#std jthread|Усовершенствованные потоки: класс std::jthread (стандарт С++ 20)]] 3.2
	1. [[#Автоматическое присоединение к потоку|Автоматическое присоединение к потоку]] 3.2.1
	2. [[#Прерывание по запросу в классе std jthread|Прерывание по запросу в классе std::jthread]] 3.2.2
	3. [[#Особенности класса std jthread]] 3.6.5
3. [[#std scoped_thread|std::scoped_thread]]
4. [[#Запуск потока|Запуск потока]] 2.1.1 (multithread)
5. [[#Ожидание завершения потока|Ожидание завершения потока]] 2.1.2 (multithread)
6. [[#Ожидание в исключительных обстоятельствах|Ожидание в исключительных обстоятельствах]] 2.1.3 (multithread)
7. [[#Запуск потоков в фоновом режиме|Запуск потоков в фоновом режиме]] 2.1.4 (multithread)
8. [[#Передача аргументов функции потока|Передача аргументов функции потока]] 2.2 (multithread)
9. [[#Передача права владения потоком|Передача права владения потоком]] 2.3 (multithread)
10. [[#Выбор количества потоков в ходе выполнения программы|Выбор количества потоков в ходе выполнения программы]] 2.4 (multithread)
11. [[#Идентификация потоков|Идентификация потоков]] 2.5 (multithread)
12. [[#std thread hardware_concurrency()|std::thread::hardware_concurrency()]]

# std::thread

Класс `std::thread` служит обёрткой для потока – независимой единицы выполнения в составе программы. Выполняемая единица запускается сразу после своего создания, для этого она должна получить на вход вызываемый объект, который и задаёт, что должно быть сделано в потоке. Вызываемый объект может быть именованной функцией, функциональным объектом или лямбда-функцией.

Код, который создаёт поток, отвечает за его дальнейшую судьбу. Единица выполнения, работающая в потоке, завершается с окончанием работы своего вызываемого объекта. Создатель потока может либо присоединить поток, т.е. подождать его завершения посредством вызова `join`, либо отсоединиться от потока, вызвав функцию `detach`. Поток `t` находится в присоединяемом состоянии, если над ним не выполнялась ни одна из операций `join` и `detach`. Если в момент вызова деструктора объект-поток находится в присоединяемом состоянии, деструктор вызывает функцию `std::terminate`, которая приводит к аварийному завершению программы.

Поток, отсоединённый от своего создателя, часто называют потоком-демоном, поскольку он выполняется в фоновом режиме.

Под именем `std::thread` скрывается шаблон класса с переменным числом параметров. Это означает, что при создании потока можно передавать любое число аргументов, так как разное число аргументов могут принимать выполняющиеся в потоке вызываемые объекты.

Библиотека `std::thread` предоставляет стандартный способ управления потоками.
```c++
void foo(bool clause) { 
	/* do something... */ 
} 

std::vector<std::thread> threadsVector; 
threadsVector.emplace_back([]() { 
	// Лямбда-функция, которая будет вызвана 
}); 

threadsVector.emplace_back(foo, true); // поток запустит foo(true) 

for (auto& thread : threadsVector) 
	thread.join(); // ожидание окончания работы потоков
```

# Базовые потоки: класс std::thread

Чтобы создать поток в программе на языке C++, нужно подключить заголовочный файл `<thread>`.

## Создание потока

Объект типа `std::thread` представляет единицу выполнения программы. То, что должно быть выполнено в потоке, передаётся объекту `std::thread` при его создании в виде вызываемого объекта.

Вызываемый объект ведёт себя подобно функции. Конечно, он может быть в том числе и функцией, но также может быть функциональным объектом или лямбда-функцией. Значение, возвращаемое вызываемым объектом, игнорируется.

Сделав эти вводные замечания, можно рассмотреть пример.

Создание потоков с различными вызываемыми объектами:
```c++
// createThread.cpp

#include <iostream>
#include <thread>

void helloFunction(){
	std::cout << “Hello from a function.” << std::endl;
}

class HelloFunctionObject{
	public:
		void operator()() const {
			std::cout << “Hello from a function object.” << std::endl;
		}
};

int main(){
	std::cout << std::endl;
	
	std::thread t1(helloFunction);
	
	HelloFunctionObject helloFunctionObject;

	std::thread t2(helloFunctionObject);
	std::thread t3([]{std::cout << “Hello from a lambda.” << std::endl;});

	t1.join();
	t2.join();
	t3.join();
	
	std::cout << std::endl;
};
```

Все три потока, `t1`, `t2` и `t3`, печатают сообщения на консоль. При этом в потоке `t1` выполняется обычная функция, в потоке `t2` выполняется функциональный объект (класс), а в потоке `t2` – лямбда-функция. В строках `t1.join()` – `t3.join()` главный поток ожидает завершения всех дочерних потоков.

Посмотрим, как работает эта программа. Результаты её запуска довольно интересны.

![[ParallelProg_49.png]]

Три потока могут выполняться в произвольном порядке. Даже тексты, выводимые из разных потоков, могут перемешиваться между собой.

В этом примере главный поток, создающий дочерние потоки, отвечает за время жизни этих объектов.

## Время жизни потоков

Родители должны заботиться о своих детях. Из этого простого принципа вытекают далекоидущие следствия касательно времени жизни потоков. Рассмотрим пример: следующая программа должна запускать поток и выводить его идентификатор.

Забытое ожидание завершения потока:
```c++
// threadWithoutJoin.cpp

#include <iostream>
#include <thread>

int main(){
	std::thread t([]{std::cout << std::this_thread::get_id() << std::endl;});
}
```

Однако программа этого не делает.
![[ParallelProg_50.png]]

### Функции join и detach

Жизнь потока `t` завершается с окончанием выполнения его вызываемого объекта. У создателя потока есть на выбор два варианта:

* подождать завершения дочернего потока с помощью вызова `t.join()`;
* оборвать связь с дочерним потоком с помощью вызова `t.detach()`.

Вызов `t.join()` полезен в случаях, когда последующий код каким-то образом зависит от результатов работы дочернего потока. Вызов `t.detach()` позволяет дочернему потоку выполняться независимо от объекта `t`. Это значит, что поток, отсоединённый от объекта, будет выполняться до тех пор, пока не завершится выполняющийся в нём код. Чаще всего отсоединяют потоки, в которых выполняется долгая фоновая работа, например потоки-серверы.

Объект-поток с завёрнутым в него вызываемым объектом (объекты типа `std::thread` можно создавать и пустыми, без вызываемых объектов) называется присоединяемым (англ. joinable), если для него не вызывалась ни одна из функций-членов `join` и `detach`. Деструктор объекта-потока в присоединяемом состоянии вызывает аварийное завершение программы посредством [[terminate|std::terminate]]. Именно в этом причина аварийного завершения программы `threadWithoutJoin.cpp`. Если применить функцию `join` или `detach` к объекту, для которого какая-либо из этих функций-членов уже была вызвана ранее, произойдёт исключение типа `std::system_error`.

Исправить предыдущую программу довольно легко – для объекта-потока `t` вызвать функцию-член `join`.

```c++
// threadWithoutJoin.cpp

#include <iostream>
#include <thread>

int main(){
	std::thread t([]{std::cout << std::this_thread::get_id() << std::endl;});
	
	t.join();
}
```

Теперь программа работает так, как ожидалось.

Число, которое программа выводит на печать, – это уникальный идентификатор потока в системе.

> **Трудность с функцией `detach`**
> 
> Конечно же, в последней программе вместо функции `join` можно было бы применить функцию `detach`. Объект-поток `t` перешёл бы в неприсоединяемое состояние, и его деструктор не стал бы аварийно завершать программу. Но в этом случае возникло бы иное затруднение. Поведение такой программы не определено, поскольку главный поток может завершиться раньше дочернего, и тогда последнему просто не останется времени, чтобы вывести на печать свой результат.

> **Класс `scoped_thread` Энтони Уильямса**
> 
>Если своими руками управлять временем жизни потоков слишком обременительно, можно инкапсулировать класс `std::thread` в собственный класс-обёртку. Деструктор этого класса должен автоматически вызывать функцию `join` потока, если тот всё ещё находится в присоединяемом состоянии. Конечно, можно поступить и противоположным образом, автоматически вызывая для потока функцию `detach` – однако это может быть сопряжено с определёнными трудностями.
>
> Энтони Уильямс создал такой полезный класс и описал его в своей превосходной книге «Параллельное программирование на C++ в действии». Класс-обёртку он назвал `scoped_thread`. Конструктор этого класса принимает в качестве аргумента поток `t` и проверяет, находится ли он попрежнему в присоединяемом состоянии. Если поток-аргумент `t` не поддерживает присоединение, нет и необходимости в классе `scoped_thread`. Если же поток `t` можно присоединить, деструктор класса вызывает `t.join()`. Поскольку конструктор копирования и копирующая операция присваивания в явном виде удалены, экземпляры класса `scoped_thread` не могут копироваться никаким способом.

```c++
// scoped_thread.cpp
#include <iostream>
#include <thread>
#include <utility>

class scoped_thread{
		std::thread t;
	
	public:
		explicit scoped_thread(std::thread t_): t(std::move(t_)){
			if (!t.joinable()) throw std::logic_error(“No thread”);
		}
		
		~scoped_thread(){
			t.join();
		}
		
	scoped_thread(scoped_thread&)= delete;
	scoped_thread& operator=(scoped_thread const &)= delete;
};
```

## Передача аргументов при создании потока

Вызываемый объект, выполняющийся в потоке (в частности, обычная функция), может получать свои аргументы посредством копирования значения, по перемещению или по ссылке. Класс `std::thread` представляет собой шаблон с переменным числом аргументов, или, как их ещё называют, вариадический шаблон.

Если поток получает на вход данные по ссылке, нужно быть чрезвычайно осторожным в том, что касается времени жизни передаваемых объектов и совместного доступа к данным.

### Передача по значению и по ссылке

Рассмотрим следующий небольшой фрагмент кода:

```C++
std::string s{“C++11”}

std::thread t1([=]{ std::cout << s << std::endl; });
t1.join();

std::thread t2([&]{ std::cout << s << std::endl; });
t2.detach();
```

Поток `t1` получает данные по значению (т. е. путём создания копии), а поток `t2` – по ссылке.

> **Передача аргументов в поток по ссылке**
> 
> По правде говоря, в этом примере допущено некоторое упрощение. Там сказано, что поток `t2` получает аргумент по ссылке, однако на самом деле это лямбда-функция захватывает ссылку на локальные данные. Чтобы передать по ссылке аргумент в функцию потока, нужно завернуть его в класс-обёртку ссылок. Это просто сделать, воспользовавшись вспомогательной функцией `std::ref`, определённой в заголовочном файле `<functional>`. Например:
```c++
void transferMoney(int amount, Account& from, Account& to){
	...
}

...

std::thread thr1(transferMoney, 50, std::ref(account1),
				 std::ref(account2));
```

> Здесь поток `thr1` выполняет функцию `transferMoney`, которая получает аргументы по ссылке. Благодаря использованию функции `std::ref` в функцию будут переданы ссылки на объекты `account1` и `account2`.

Какие тонкости могут таиться в этих строчках кода? Поток `t2` получает строку `s` по ссылке, а затем отсоединяется от родительского потока. Время жизни строки `s` ограничено временем выполнения объемлющей функции. Время жизни глобального объекта `std::cout` ограничивается только временем выполнения главного потока программы. Поэтому время жизни объектов `s` и `std::cout` может оказаться короче, чем время выполнения потока `t2`. Таким образом мы оказываемся по уши в неопределённом поведении.

Передача в поток аргументов по ссылке:
```c++
// threadArguments.cpp

#include <chrono>
#include <iostream>
#include <thread>

class Sleeper{
	public:
		Sleeper(int& i_):i{i_}{};

		void operator() (int k){
			for (unsigned int j= 0; j <= 5; ++j){
				std::this_thread::sleep_for(
									std::chrono::milliseconds(100));
				i += k;
			}
		}
		
	private:
		int& i;
};

int main(){
	std::cout << std::endl;

	int valSleeper = 1000;
	std::thread t(Sleeper(valSleeper), 5);
	t.detach();
	
	std::cout << “valSleeper = “ << valSleeper << std::endl;
	
	std::cout << std::endl;
}
```

Какое значение имеет переменная `valSleeper` в строке `std::cout << “valSleeper = “ << valSleeper << std::endl`? Переменная `valSleeper` живёт, пока выполняется функция `main`. Поток `t` получает для работы функциональный объект, в который завёрнута ссылка на переменную `valSleeper`, и число 5. Главное в этом примере то, что поток `t` получает переменную `valSleeper` по ссылке (`Sleeper(int& i_):i{i_}{}`) и отсоединяется от главного потока (строка `t.detach()`). В дочернем потоке выполняется перегруженная операция вызова функционального объекта (`void operator() (int k)`). В этой функции цикл увеличивает счётчик от 0 до 5 включительно, на каждой итерации ждёт 1/10 секунды и увеличивает переменную `i` на величину `k`. В конце дочерний поток должен напечатать свой идентификатор. Считая, как говорят в Германии, «по Адаму Ризе», результат должен составлять
```
1000 + 6 * 5 = 1030
```

Однако как же программа работает на самом деле? Что-то в ней идёт не так.

![[ParallelProg_52.png]]

Программа обнаруживает два странных свойства. Во-первых, значение переменной `valSleeper` в конце оказывается равным `1000`, а во-вторых, идентификатор дочернего потока на печать не выводится. Программа страдает по меньшей мере двумя изъянами.

4. Разные потоки имеют ничем не ограниченный доступ к переменной `valSleeper`. Здесь имеет место гонка данных, поскольку потоки могут одновременно производить чтение и запись этой переменной.
5. Время жизни главного потока завершается раньше, чем дочерний поток успевает выполнить все свои вычисления и вывести свой идентификатор в поток `std::cout`.

Оба названных обстоятельства переводят программу в состояние гонки, поскольку результат работы программы зависит от относительной скорости выполнения операций в разных потоках. Состояние гонок выступает причиной гонки данных.

Исправить гонку данных довольно просто. Для этого достаточно защитить переменную `valSleeper` мьютексом или сделать её атомарной. Что-бы преодолеть ошибку, связанную со временем жизни объектов `valSleeper` и `std::cout`, нужно не отсоединять дочерний поток, а, напротив, присоединить его выполнение (функция `join`). Ниже представлена исправленная функция `main`.
```c++
int main(){
	std::cout << std::endl;

	int valSleeper= 1000;
	std::thread t(Sleeper(valSleeper),5);
	t.join();
	
	std::cout << “valSleeper = “ << valSleeper << std::endl;
	
	std::cout << std::endl;
}
```

Теперь программа выдаёт правильный результат, хотя, конечно, и выполняется медленнее.

![[ParallelProg_53.png]]

## Перечень функций-членов

Интерфейс класса `std::thread` показан ниже в виде таблицы. Более подробные сведения можно найти на сайте cppreference.com.

**Функции-члены класса `std::thread`**

| **Функция**                             | **Описание**                                                          |
| --------------------------------------- | --------------------------------------------------------------------- |
| `join`                                  | Ждать завершения потока                                               |
| `detach`                                | Разорвать связь с потоком и оставить его выполняться независимо       |
| `joinable`                              | Узнать, находится ли поток в присоединяемом состоянии                 |
| `get_id`,<br>`std::this_thread::get_id` | Узнать идентификатор потока                                           |
| `hardware_concurrency`                  | Узнать, сколько потоков может выполняться параллельно                 |
| `std::this_thread::sleep_until`         | Погрузить поток в сон до определённого абсолютного момента времени    |
| `std::this_thread::sleep_for`           | Погрузить поток в сон на заданное время относительно текущего момента |
| `std::this_thread::yield`               | Уступить выполнение другому потоку                                    |
| `t1.swap(t2)`<br>`std::swap(t1, t2)`    | Обменять местами два объекта                                          |

> **Доступ к системно-зависимой реализации**
> 
> Классы из стандартной библиотеки представляют собой обёртку над реализацией потоков в конкретной платформе. Для доступа к системному дескриптору потока можно воспользоваться функцией `native_handle`. Такие системные дескрипторы можно получать для потоков, [[mutex|мьютексов]] и переменных условия.

Объекты класса `std::thread` нельзя копировать, но можно перемещать. Функция `swap` обменивает местами содержимое двух объектов, пользуясь для этого перемещением.

**Функции-члены класса `std::thread`**
```c++
// threadMethods.cpp

#include <iostream>
#include <thread>
using namespace std;

int main(){
	cout << boolalpha << endl;

	cout << “hardware_concurrency()= “
						<< thread::hardware_concurrency() << endl;

	thread t1([]{cout << “t1 with id= “ << this_thread::get_id() 
														<< endl;});
	thread t2([]{cout << “t2 with id= “ << this_thread::get_id() 
														<< endl;});

	cout << endl;
	
	cout << “FROM MAIN: id of t1 “ << t1.get_id() << endl;
	cout << “FROM MAIN: id of t2 “ << t2.get_id() << endl;

	cout << endl;

	swap(t1,t2);

	cout << “FROM MAIN: id of t1 “ << t1.get_id() << endl;
	cout << “FROM MAIN: id of t2 “ << t2.get_id() << endl;
	
	cout << endl;
	
	cout << “FROM MAIN: id of main= “ << this_thread::get_id() << endl;

	cout << endl;

	cout << “t1.joinable(): “ << t1.joinable() << endl;

	cout << endl;

	t1.join();
	t2.join();
	
	cout << endl;
	
	cout << “t1.joinable(): “ << t1.joinable() << endl;
	
	cout << endl;
}
```

результат её работы:
![[ParallelProg_54.png]]

Может показаться странным, что потоки `t1` и `t2` (строки `thread t1([]{cout << “t1 with id= “ << this_thread::get_id() << endl;})` и `thread t2([]{cout << “t2 with id= “ << this_thread::get_id() << endl;})`) отрабатывают в столь различные моменты времени. Однако это нормально: у программиста нет никаких гарантий относительно того, когда и с какой скоростью выполняются потоки. С уверенностью можно сказать лишь, что выполнение потоков завершится к моменту завершения функции `join`, вызванной в строках `t1.join()` и `t2.join()`.

Управление параллельными потоками тем труднее, чем больше изменяемых (т. е. неконстантных) данных находится у них в общем доступе.

# std::jthread

Название `jthread` означает «присоединяемый» (англ. joinable) поток. В дополнение ко всему, что умеет делать класс [[thread#std thread|std::thread]], введённый в стандарте C++11, этот класс ожидает завершения потока в деструкторе и поддерживает кооперативное прерывание. Тем самым класс `std::jthread` расширяет интерфейс класса [[thread#std thread|std::thread]].

В следующей таблице представлен обзор функциональных возможностей, добавленных в классе `std::jthread`.

**Дополнительные функции-члены класса `std::jthread`:**

| **Имя**           | **Описание**                                                             |
| ----------------- | ------------------------------------------------------------------------ |
| `get_stop_source` | Возвращает объект типа `std::stop_source`, связанный с флагом завершения |
| `get_stop_token`  | Возвращает объект типа `std::stop_token`, связанный с флагом завершения  |
| `request_stop`    | Запрашивает завершение выполнения через флаг                             |

## Автоматическое присоединение к потоку

Поведение класса [[#std thread|std::thread]] противоречит ожиданиям: если на момент вызова деструктора поток находится в присоединяемом состоянии, выполнение всей программы аварийно завершается вызовом [[terminate|std::terminate]]. Напомним, что поток находится в присоединяемом состоянии, если он был запущен и для него не вызывалась ни одна из функций `join` или `detach`.

**Аварийно завершающаяся программа с присоединяемым потоком:**
```c++
// threadJoinable.cpp

#include <iostream>
#include <thread>

int main() {
	std::cout << std::endl;
	std::cout << std::boolalpha;
	
	std::thread thr{[]{ std::cout << “Joinable std::thread” 
												<< std::endl; }};
	std::cout << “thr.joinable(): “ << thr.joinable() 
												<< std::endl;
	
	std::cout << std::endl;
}
```

Если эту программу запустить, она завершится с ошибкой.

![[ParallelProg_55.png]]

Оба запуска программы завершаются с ошибкой. При этом во второй раз у потока `thr` оказывается вдоволь времени, чтобы вывести своё сообщение: `«Joinable std::thread»`.

Следующий код во всём подобен предыдущему, за исключением замены класса [[#std thread|std::thread]] классом `std::jthread` из стандарта C++ 20.

**Завершение потока `std::jthread` в присоединяемом состоянии:**
```c++
// jthreadJoinable.cpp

#include <iostream>
#include <thread>

int main() {
	std::cout << std::endl;
	std::cout << std::boolalpha;

	std::jthread thr{[]{ std::cout << “Joinable std::jthread” 
												<< std::endl; }};

	std::cout << “thr.joinable(): “ << thr.joinable() << std::endl;
	std::cout << std::endl;
}
```

Теперь выполнение дочернего потока автоматически присоединяется к главному потоку при деструкции объекта `thr`, поскольку в момент выхода за область видимости он всё ещё находится в присоединяемом состоянии.

Ниже показано, как мог бы быть реализован деструктор класса `std::jthread`.

**Деструктор класса std::jthread:**
```c++
jthread::~jthread() {
	if(joinable()) {
		request_stop();
		join();
	}
}
```

В первую очередь деструктор проверяет, по-прежнему ли поток допускает присоединение (строка `if(joinable())`). Поток находится в присоединяемом состоянии, если он был запущен и для него не вызывалась ни одна из функций `join` или `detach`. Если присоединение имеет смысл, деструктор запрашивает завершение потока (строка `request_stop()`) и затем вызывает функцию `join`. Этот вызов блокирует вызывающий поток до тех пор, пока не закончится выполнение дочернего потока.

## Прерывание по запросу в классе std::jthread

Чтобы проиллюстрировать основную идею, начнём с простого примера.

**Прерываемый и непрерываемый потоки:**
```c++
// interruptJthread.cpp

#include <chrono>
#include <iostream>
#include <thread>

using namespace::std::literals;

int main() {
	std::cout << ‘\n’;
	
	std::jthread nonInterruptable([]{
		int counter{0};
		while (counter < 10){
			std::this_thread::sleep_for(0.2s);
			std::cerr << “nonInterruptable: “ << counter << ‘\n’;
			++counter;
		}
	});
	
	std::jthread interruptable([](std::stop_token stoken){
		int counter{0};
		while (counter < 10){
			std::this_thread::sleep_for(0.2s);
			if (stoken.stop_requested()) return;
			std::cerr << “interruptable: “ << counter << ‘\n’;
			++counter;
		}
	});
	
	std::this_thread::sleep_for(1s);

	std::cerr << ‘\n’;
	std::cerr << “Main thread interrupts both jthreads” << ‘\n’;
	
	nonInterruptable.request_stop();
	interruptable.request_stop();
	
	std::cout << ‘\n’;
}
```

В главном потоке запускаются два дочерних потока: `nonInterruptible` (с англ. «непрерываемый») в строке `std::jthread nonInterruptable([]{` и `interruptible` (соотв. «прерываемый») в строке `std::jthread interruptable([](std::stop_token stoken){`. В отличие от непрерываемого потока, прерываемый получает объект `std::stop_token` (флаг завершения) и использует его в строке `if (stoken.stop_requested()) return;` для проверки того, не запросил ли кто-либо завершение потока (для этого служит функция-член `stop_requested`). Если завершение запрошено, [[Lambda|лямбда-функция]] возвращает управление, и тем самым завершается работа потока.

Вызов функции `request_stop` в строке `interruptable.request_stop();` запрашивает завершение потока. Однако на первый поток `nonInterruptible` этот запрос не действует: поток просто не реагирует на него.

![[ParallelProg_56.png]]

## Особенности класса std::jthread

Класс [[#std jthread|std::jthread]] представляет собой почти что копию класса [[#std thread|std::thread]] с дополнительными возможностями: кооперативным прерыванием и автоматическим присоединением. Для поддержки обеих этих возможностей поток [[#std thread|std::thread]] обладает встроенным объектом [[Кооперативное прерывание потоков#Класс std stop_token|std::stop_token]].

| **Функция**       | **Описание**                                                                                                                         |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `get_stop_source` | Возвращает объект типа [[Кооперативное прерывание потоков#Класс std stop_source\|std::stop_source]], связанный с состоянием останова |
| `get_stop_token`  | Возвращает объект типа [[Кооперативное прерывание потоков#Класс std stop_token\|std::stop_token]], связанный с состоянием останова   |
| `request_stop`    | Запрашивает останов потока через состояние останова                                                                                  |

# std::scoped_thread
#std_scoped_thread

# Запуск потока

В [[Практика многопоточного программирования|Здравствуй, мир конкурентности C++]] было показано, что потоки запускаются созданием объекта [[thread#std thread|std::thread]], в котором определяется выполняемая в потоке задача. В простейшем случае эта задача представляет собой обычную функцию, которая возвращает `void-значение`, и не принимает никаких параметров. Эта функция выполняется в собственном потоке, пока не вернет управление, после чего поток останавливается. В иных случаях задача может быть функциональным объектом, принимающим дополнительные параметры и выполняющим ряд независимых операций, которые задаются посредством некоей системы обмена сообщениями в ходе его выполнения. Поток останавливается только при получении соответствующего сигнала, опять же через некую систему сообщений. Что бы ни собирался делать поток и откуда бы он ни запускался, его запуск с использованием стандартной библиотеки C++ всегда сводится к созданию объекта [[thread#std thread|std::thread]]:
```c++
void do_some_work();
std::thread my_thread(do_some_work);
```

Проще, наверное, и быть не может. Конечно, чтобы компилятор мог видеть определение класса [[thread#std thread|std::thread]], нужно убедиться, что в программу включен заголовок `<thread>`. Как и основная часть содержимого стандартной библиотеки C++, [[thread#std thread|std::thread]] работает с любым вызываемым типом, поэтому конструктору [[thread#std thread|std::thread]] можно также передать экземпляр класса с оператором вызова функции:
```c++
class background_task
{
	public:
		void operator()() const
		{
			do_something();
			do_something_else();
		}
};

background_task f;
std::thread my_thread(f);
```

В данном случае предоставленный функциональный объект копируется в хранилище, принадлежащее вновь созданному потоку выполнения, и вызывается оттуда. Поэтому важно, чтобы копия действовала аналогично оригиналу, иначе результат может не соответствовать ожидаемому.

При передаче функционального объекта в конструктор потока следует избегать так называемого самого неприятного случая синтаксического анализа C++. Если передается временная, а не именованная переменная, синтаксис может быть таким же, как и при объявлении функции. В этом случае компилятор интерпретирует его именно таким образом, а не как определение объекта. Например, код:
```c++
std::thread my_thread(background_task());
```

объявляет функцию `my_thread`, принимающую единственный параметр наподобие указателя на функцию, не принимающую параметры и возвращающую объект фоновой задачи `background_task`, и вместо запуска нового потока возвращает объект [[thread#std thread|std::thread]]. Такого развития событий можно избежать, присвоив функциональному объекту имя, как было показано ранее, с помощью дополнительных скобок или нового унифицированного синтаксиса инициализации, например:
```c++
std::thread my_thread((background_task()));
std::thread my_thread{background_task()};
```

В первом примере дополнительные скобки не позволяют интерпретировать код как объявление функции, разрешая объявить `my_thread` переменной типа [[thread#std thread|std::thread]]. Во втором примере используется новый унифицированный синтаксис инициализации с фигурными, а не круглыми скобками, также позволяющий объявить переменную.

Одним из типов вызываемого объекта, позволяющего избегать возникновения рассматриваемой проблемы, является лямбда-выражение. Эта новая особенность, появившаяся в стандарте C++11, допускает создание локальной функции с возможным захватом некоторых локальных переменных, избавляя от необходимости передачи дополнительных аргументов (см. #раздел_2_2). Более подробно лямбда-выражения рассматриваются в #разделе_A_5. С помощью лямбда-выражения предыдущий пример можно записать следующим образом:
```c++
std::thread my_thread([]{
	do_something();
	do_something_else();
});
```

Научившись запускать поток, нужно принять однозначное решение, ждать ли его завершения (присоединив его — см. #подраздел_2_1_2) или пустить его на самотек (путем его отсоединения — см. #подраздел_2_1_3). Если не принять решение до уничтожения объекта [[thread#std thread|std::thread]], то программа завершится (деструктор [[thread#std thread|std::thread]] вызовет метод [[terminate|std::terminate()]]). Поэтому даже при выдаче исключений необходимо убедиться, что поток правильно присоединен или отсоединен. Методы, позволяющие справиться с таким сценарием, рассмотрены в #подразделе_2_1_3. Учтите, что решение нужно принимать до того, как объект std::thread будет уничтожен. Сам же поток вполне мог бы завершиться задолго до его присоединения или отсоединения. Если его отсоединить, то при условии, что он все еще выполняется, он и будет выполняться, и этот процесс может продолжаться еще долго и после уничтожения объекта [[thread#std thread|std::thread]]. Выполнение будет прекращено, только когда в конце концов произойдет возвращение из функции потока.

Если не дожидаться завершения потока, необходимо убедиться, что данные, к которым он обращается, будут действительны, пока он не закончит работать с ними. Эта проблема не отличается новизной — даже в однопоточном коде поведение приложения при доступе к объекту после его уничтожения характеризуется неопределенностью, но при использовании потоков вероятность столкнуться с подобными проблемами времени жизни объектов возрастает.

К примеру, похожие проблемы могут возникнуть, если функция потока содержит указатели или ссылки на локальные переменные, а поток при выходе из функции не завершается. Пример такого сценария:
![[practice_multithreaded-5.png]]
Функция, возвращающая управление, в то время как в потоке сохраняется обращение к локальным переменным

В данном случае новый поток, связанный с `my_thread`, при выходе из `oops`, вероятно, все еще будет выполняться, поскольку, судя по вызову `detach()`, было принято решение не дожидаться его завершения. Если поток все еще выполняется, все идет по сценарию, показанному в табл. 2.1: следующий вызов `do_something(i)` будет обращаться к уже уничтоженной переменной. Все это похоже на обычный однопоточный код, в котором сохранять указатель или ссылку на локальную переменную после выхода из функции непозволительно, но вероятность допустить такую ошибку при использовании многопоточного кода значительно выше, поскольку ее негативные проявления видны не сразу.

Таблица 2.1. Обращение к локальной переменной в отсоединенном потоке после того, как она была уничтожена

| Основной поток                                         | Новый поток                                                                                                                           |
| ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| Создание `my_func` со ссылкой<br>на `some_local_state` |                                                                                                                                       |
| Запуск нового потока `my_thread`                       | Запуск<br>Вызов `func::operator()`                                                                                                    |
| Отсоединение `my_thread`                               | Запуск `func::operator()`; возможен<br>вызов do_something со ссылкой на `some_local_state`                                            |
| Уничтожение `some_local_state`                         | Продолжение выполнения                                                                                                                |
| Выход из `oops`                                        | Продолжение выполнения `func::operator()`; возможен вызов `do_something` со ссылкой на `some_local_state =>` неопределенное поведение |

Справиться с подобным сценарием можно одним из распространенных способов: сделать функцию потока автономной и вместо разделения данных скопировать их в поток. При использовании вызываемого объекта для функции потока этот объект копируется в поток, поэтому исходный объект можно тут же уничтожить. Тем не менее следует опасаться объектов, содержащих указатели или ссылки, как, к примеру, выше. В частности, не рекомендуется создавать внутри функции поток, имеющий доступ к ее локальным переменным, если только не будет обеспечено завершение потока до выхода из этой функции. Или же, присоединив поток до выхода из функции, можно убедиться в завершении его выполнения.

# Ожидание завершения потока

Дождаться завершения потока можно, вызвав [[thread#Функции join и detach|join()]] для связанного экземпляра [[thread#std thread|std::thread]]. Что касается кода выше, то замены вызова `my_thread.detach()` перед закрывающей фигурной скобкой тела функции вызовом `my_thread.join()` было бы достаточно, чтобы гарантировать завершение потока до выхода из функции и, следовательно, до уничтожения локальных переменных. В данном случае это означало бы, что запускать функцию в отдельном потоке нет смысла, поскольку первый поток во время ожидания не будет выполнять никакой полезной работы. Но в реальном коде исходный поток будет либо выполнять полезную работу, либо запускать несколько потоков для выполнения полезной работы, прежде чем входить в режим ожидания их завершения.

Применение метода [[thread#Функции join и detach|join()]] — простой и незамысловатый прием: либо вы ждете завершения потока, либо нет. Если нужен более утонченный контроль над ожиданием потока, допустим, с проверкой завершения потока или ожиданием в течение строго определенного времени, придется воспользоваться альтернативными механизмами, например условными переменными и [[future|фьючерсами]], которые будут рассматриваться в #главе_4. Вызов [[thread#Функции join и detach|join()]] также приводит к очистке любого хранилища, связанного с потоком, поэтому объект [[thread#std thread|std::thread]] больше не связан с завершенным потоком. Мало того, он не связан ни с одним потоком. Это означает, что [[thread#Функции join и detach|join()]] можно вызвать для конкретного потока только один раз: как только вызван метод [[thread#Функции join и detach|join()]], объект [[thread#std thread|std::thread]] утрачивает возможность присоединения, а метод `joinable()` вернет значение `false`.

## Ожидание в исключительных обстоятельствах

Как упоминалось ранее, следует убедиться, что вызов [[thread#Функции join и detach|либо join(), либо detach()]] был выполнен еще до уничтожения объекта [[thread#std thread|std::thread]]. При отсоединении потока метод [[thread#Функции join и detach|detach()]] можно вызвать сразу же после запуска этого потока, так что это не проблема. Но если есть намерение дожидаться завершения потока, то место в коде, где будет выполнен вызов метода [[thread#Функции join и detach|join()]], нужно выбирать с особой тщательностью, поскольку при выдаче исключения после запуска потока, но до вызова [[thread#Функции join и detach|join()]] вызов этого метода можно пропустить.

Чтобы избежать завершения приложения при выдаче исключения, необходимо решить, что делать в таком случае. Вообще, если вы намеревались вызвать [[thread#Функции join и detach|join()]] при нормальном выполнении программы, вам, чтобы избежать проблем, связанных с временем жизни, необходимо вызвать [[thread#Функции join и detach|join()]] и при выдаче исключения. Простой код, выполняющий именно такие действия, показан ниже.
![[practice_multithreaded-6.png]]
**Листинг 2.2.** Ожидание завершения потока.

Код в листинге 2.2 содержит блок [[try|try-catch]], позволяющий гарантировать, что поток с доступом к локальному состоянию завершится до выхода из функции независимо от того, завершается ли функция нормально или из-за выдачи исключения. Использование блоков [[try|try-catch]] растягивает код, повышая вероятность получения неправильной области видимости, поэтому данный сценарий далек от идеала. Если есть веские причины обеспечить завершение потока до выхода из функции, скажем, из-за наличия ссылки на другие локальные переменные или чего-нибудь еще, важно убедиться, что учтены все возможные пути выхода, как нормальные, так и исключительные, и желательно обеспечить для этого простой и лаконичный механизм.

Кроме иных способов, это можно сделать с использованием стандартного способа `RAII` и, как показано в `листинге 2.3`, предоставить класс, выполняющий метод [[thread#Функции join и detach|join()]] в своем деструкторе. Посмотрите, насколько при этом упрощается функция `f()`.
```c++
class thread_guard
{
	    std::thread& t;
	public:
	    explicit thread_guard(std::thread& t_)
		    :t(t_)
	    {}
	    
	    ~thread_guard()
	    {
	        if (t.joinable())
	        {
	            t.join();
	        }
	    }
	    
	    thread_guard(thread_guard const&) = delete;
	    thread_guard& operator=(thread_guard const&) = delete;
};

struct func; // см. определение в листинге 2.1
void f()
{
    int some_local_state = 0;
    func my_func(some_local_state);
    std::thread t(my_func);
    thread_guard g(t);
    do_something_in_current_thread();
}
```
листинг 2.3. Использование `RAII` для ожидания завершения потока

Когда выполнение текущего потока достигает конца функции `f`, локальные объекты уничтожаются в порядке, обратном порядку их построения. Следовательно, сначала уничтожается объект `g` типа `thread_guard`, а в его деструкторе происходит присоединение к потоку. Это наблюдается даже при завершении выполнения функции, поскольку `do_something_in_current_thread` выдает исключение.

Перед вызовом метода [[thread#Функции join и detach|join()]] деструктор `thread_guard` в листинге 2.3 сначала
проверяет с помощью метода `joinable()`, является ли объект [[thread#std thread|std::thread]] присоединяемым. Важность этого действия обусловливается тем, что метод [[thread#Функции join и detach|join()]] для конкретного потока выполнения можно вызвать только один раз, поэтому, если поток уже был присоединен, его вызов станет ошибкой.

Копирующий конструктор и операторы копирующего присваивания помечают спецификатором `=delete`, чтобы запретить компилятору автоматически предоставлять их. Копирование или присваивание такого объекта было бы опасным, поскольку тогда время его жизни могло бы превысить время жизни присоединяемого потока. При объявлении их удаленными любая попытка скопировать объект `thread_guard` будет приводить к выдаче ошибки компиляции. Более подробно удаленные функции рассматриваются в #разделе_A_2.

Если ждать завершения потока не нужно, проблемы безопасности исключений можно избежать, отсоединив этот поток. Тем самым разрывается его связь с объектом [[thread#std thread|std::thread]] и гарантируется, что метод [[terminate|std::terminate()]] не будет вызван при удалении объекта [[thread#std thread|std::thread]], даже если поток все еще выполняется в фоновом режиме.

## Запуск потоков в фоновом режиме

Вызов метода [[thread#Функции join и detach|detach()]] для объекта [[thread#std thread|std::thread]] позволяет потоку выполняться в фоновом режиме, непосредственное взаимодействие с ним не требуется. Возможность дождаться завершения этого потока исчезает: если поток отсоединяется, получить ссылающийся на него объект [[thread#std thread|std::thread]] невозможно, поэтому такой поток больше нельзя присоединить. Отсоединенные потоки фактически выполняются в фоновом режиме, владение и управление ими передаются в библиотеку среды выполнения C++, которая гарантирует правильное высвобождение ресурсов, связанных с потоком, при выходе из него.

Отсоединенные потоки часто называются потоками-демонами по аналогии с существующей в `UNIX` концепцией процесса-демона, который выполняется в фоновом режиме без какого-либо явного пользовательского интерфейса. Как правило, такие потоки являются весьма продолжительными, работая в течение практически всего времени жизни приложения и выполняя фоновую задачу, например отслеживая состояние файловой системы, удаляя неиспользуемые записи из кэш-памяти объектов или оптимизируя структуры данных. В то же время есть смысл использовать отсоединенный поток, если существует иной механизм определения факта завершения потока или когда нужно запустить задачу и «забыть» о ней.

Как было показано в [[thread#Ожидание завершения потока|Ожидание завершения потока]], поток отсоединяется путем вызова для объекта [[thread#std thread|std::thread]] компонентной функции [[thread#Функции join и detach|detach()]]. После завершения вызова объект [[thread#std thread|std::thread]] больше не связан с фактическим потоком выполнения, поэтому данный поток больше нельзя присоединить:
```c++
std::thread t(do_background_work);
t.detach();
assert(!t.joinable());
```

Чтобы отсоединить поток от объекта [[thread#std thread|std::thread]], должен существовать отсоединяемый поток: метод [[thread#Функции join и detach|detach()]] нельзя вызывать для объекта [[thread#std thread|std::thread]], не имеющего связанного с ним потока выполнения. Это требование аналогично тому, которое предъявляется к вызову метода [[thread#Функции join и detach|join()]], и проверку можно провести точно таким же образом — вызывать для объекта `t` типа [[thread#std thread|std::thread]] метод `t.detach()` возможно, только если метод `t.joinable()` вернет значение `true`.

Рассмотрим приложение, к примеру текстовый процессор, позволяющий одновременно редактировать несколько документов. Есть множество способов справиться с такой задачей как на уровне пользовательского интерфейса, так и на уровне внутренних механизмов. Один из них, получающий сейчас все более широкое распространение, — использование нескольких независимых окон верхнего уровня, по одному для каждого редактируемого документа. Хотя эти окна представляются полностью независимыми и каждое имеет собственные меню, они работают в одном и том же экземпляре приложения. Один из способов справиться с этим за счет внутренних механизмов — запустить все окна редактирования документа в собственных потоках. Каждый поток будет выполнять один и тот же код, но с разными данными, относящимися к редактируемому документу и соответствующими свойствам окна. Следовательно, открытие нового документа потребует запуска нового потока. Поток, обрабатывающий запрос, не станет дожидаться завершения этого другого потока, потому что он работает над другим, независимым документом, что делает новый поток основным кандидатом для запуска в отсоединенном режиме. В `листинге 2.4` показано общее представление кода реализации рассматриваемого подхода.
```c++
void edit_document(std::string const& filename)
{
	open_document_and_display_gui(filename);

	while(!done_editing())
	{
		user_command cmd=get_user_input();
		if(cmd.type==open_new_document)
		{
			std::string const new_name=get_filename_from_user();
			std::thread t(edit_document,new_name);
			t.detach();
		}
		else
		{
			process_user_input(cmd);
		}
	}
}
```
**Листинг 2.4.** Отсоединение потока для обработки другого документа

Если пользователь решает открыть новый документ, ему предлагается сделать это, после чего для открытия этого документа запускается новый поток, который затем отсоединяется. Поскольку новый поток выполняет ту же операцию, что и текущий, но в другом файле, той же функцией (`edit_document`) можно воспользоваться повторно, взяв в качестве аргумента новое выбранное имя файла.

В этом примере также показана ситуация, когда есть смысл передать аргументы в функцию, используемую для запуска потока: вместо простой передачи имени функции в конструктор [[thread#std thread|std::thread]] ему передается параметр `filename`. Для этого можно использовать и другие механизмы, например вместо обычной функции с параметрами задействовать функциональный объект с компонентными данными, для чего стандартная библиотека C++ предоставляет очень простой способ.

# Передача аргументов функции потока

В `листинге 2.4` было показано, что передача аргументов вызываемому объекту или функции сводится к простой передаче дополнительных аргументов конструктору [[thread#std thread|std::thread]]. Но важно учесть, что по умолчанию аргументы копируются во внутреннее хранилище, где к ним может получить доступ вновь созданный поток выполнения, а затем передаются вызываемому объекту или функции как [[r-значение#Традиционные l- и r-значения|r-значения (rvalues)]], как будто они временные. Так делается, даже если соответствующий параметр в функции ожидает ссылку. Рассмотрим пример:
```c++
void f(int i, std::string const& s);
std::thread t(f, 3, "hello");
```

В результате создается новый поток выполнения, связанный с `t`, который вызывает функцию `f(3,"hello")`. Обратите внимание: даже если `f` в качестве второго параметра принимает [[string|std::string]], строковый литерал передается как `char const *` и преобразуется в [[string|std::string]] только в контексте нового потока. Это становится особенно важным, когда, как показано далее, предоставленный аргумент является указателем на автоматическую переменную:
```c++
void f(int i,std::string const& s);
void oops(int some_param)
{
	char buffer[1024];
	sprintf(buffer, "%i", some_param);
	std::thread t(f, 3, buffer);
	t.detach();
}
```

Здесь это указатель на буфер локальной переменной, который передается в новый поток. И высока вероятность того, что выход из функции `oops` произойдет, прежде чем буфер будет в новом потоке преобразован в [[string|std::string]], что вызовет неопределенное поведение. Решением является приведение к типу [[string|std::string]] перед передачей буфера в конструктор [[thread|std::thread]]:
```c++
void f(int i, std::string const& s);
void not_oops(int some_param)
{
    char buffer[1024];
    sprintf(buffer, "%i", some_param);
 
	// использование std::string предотвращает обращение к
	// недействительному указателю
	std::thread t(f, 3, std::string(buffer));
    t.detach();
}
```

В данном случае причиной возникновения проблемы является надежда на подразумеваемое преобразование указателя на буфер в объект [[string|std::string]], ожидаемый в качестве параметра функции, но это преобразование происходит слишком поздно, поскольку конструктор [[thread#std thread|std::thread]] копирует предоставленные значения как есть, не преобразуя в ожидаемый тип аргумента.

Обратный сценарий получить невозможно: объект скопирован и вам нужна не `const‑ссылка`, поскольку она не скомпилируется. Все это можно попробовать, если поток обновляет структуру данных, переданную по ссылке, например:
```c++
void update_data_for_widget(widget_id w, widget_data& data);
void oops_again(widget_id w)
{
	widget_data data;
	std::thread t(update_data_for_widget, w, data);
	
	display_status();
	
	t.join();
	process_widget_data(data);
}
```

Хотя `update_data_for_widget` ожидает, что второй параметр будет передан по ссылке, конструктор [[thread#std thread|std::thread]] не знает об этом, он не обращает внимания на типы аргументов, которые ожидает функция, и слепо копирует предоставленные значения. Но внутренний код передает скопированные аргументы в качестве [[r-значение#Традиционные l- и r-значения|r‑значений]], чтобы работать с типами, предназначенными только для перемещений, и пытается таким образом вызвать `update_data_for_widget` с [[r-значение#Традиционные l- и r-значения|r-значением]]. Этот код не пройдет компиляцию, так как нельзя передать [[r-значение#r-значения|r-значение]] функции, ожидающей `не-const-ссылку`. Для тех, кто знаком с [[bind|std::bind]], решение будет очевидным: аргументы, которые должны быть ссылками, следует заключать в [[ref|std::ref]]. В этом случае при изменении вызова потока на:
```c++
std::thread t(update_data_for_widget, w, std::ref(data));
```

`update_data_for_widget` будет корректно передана ссылка на данные, а не временная копия данных и код успешно пройдет компиляцию.

Если работать с [[bind|std::bind]] уже приходилось, то в семантике передачи параметров не будет ничего нового, поскольку и операция конструктора [[thread#std thread|std::thread]], и операция [[bind|std::bind]] определены в рамках одного и того же механизма. То есть можно, например, передать указатель на компонентную функцию в виде функции при условии, что в качестве первого аргумента предоставлен подходящий указатель на объект:
```c++
class X
{
	public:
		void do_lengthy_work();
};

X my_x;
std::thread t(&X::do_lengthy_work, &my_x);
```

Этот код вызовет `my_x.do_lengthy_work()` в новом потоке, поскольку в качестве указателя на объект предоставляется адрес `my_x` . Такому вызову компонентной функции можно также предоставлять аргументы: третий аргумент конструктора [[thread#std thread|std::thread]] будет первым аргументом компонентной функции и т. д. 

Еще один интересный сценарий предоставления аргументов применяется, когда аргументы нельзя скопировать, а можно только переместить: данные, содержащиеся в одном объекте, передаются в другой, и исходный объект остается пустым.

Примером может послужить тип [[unique_ptr|std::unique_ptr]], обеспечивающий автоматическое управление памятью для динамически выделяемых объектов. В одно и то же время на данный объект может указывать только один экземпляр [[unique_ptr|std::unique_ptr]], и когда этот экземпляр уничтожается, объект, на который он указывал, удаляется. Перемещающий конструктор и перемещающий оператор присваивания позволяют передавать права владения объектом между экземплярами [[unique_ptr|std::unique_ptr]] (более подробно семантика перемещения рассматривается в #подразделе_А_1_1. В результате этого исходный объект остается с нулевым указателем. Такое перемещение значений позволяет принимать объекты данного типа в качестве параметров функции или возвращать их из функций. Если исходный объект временный, перемещение выполняется автоматически, но если источником является именованное значение, передача должна быть запрошена напрямую путем вызова метода [[move|std::move()]]. В следующем примере показано использование [[move|std::move]] для передачи потоку права владения динамическим объектом:
```c++
void process_big_object(std::unique_ptr<big_object>);
std::unique_ptr<big_object> p(new big_object);
p->prepare_data(42);
std::thread t(process_big_object, std::move(p));
```

Поскольку при вызове конструктора [[thread#std thread|std::thread]] указан метод `std::move(p)`, право владения `big_object` сначала передается внутреннему хранилищу вновь созданного потока, а затем переходит к `process_big_object`.

Некоторые классы в стандартной библиотеке C++ имеют ту же семантику прав владения, что и [[unique_ptr|std::unique_ptr]], и одним из них является [[thread#std thread|std::thread]]. Хотя экземпляры [[thread#std thread|std::thread]] не владеют, как [[unique_ptr|std::unique_ptr]], динамическим объектом, они владеют ресурсом: каждый экземпляр отвечает за управление потоком выполнения. Это право собственности разрешается передавать между экземплярами, потому что экземпляры [[thread#std thread|std::thread]] можно переместить, даже если их нельзя скопировать. Тем самым гарантируется, что в любой момент связь с конкретным потоком выполнения будет только у одного объекта, что позволяет программистам передавать это право собственности между объектами.

# Передача права владения потоком

Предположим, что нужно написать функцию, которая создает поток для выполнения в фоновом режиме, но не ожидает его завершения, а передает право собственности на новый поток обратно вызывающей функции, или же сделать обратное: создать поток и передать владение им некоторой функции, которая должна дождаться его завершения. В любом случае нужно передать право собственности из одного места в другое.

Именно здесь и пригодится поддержка перемещения, имеющаяся в [[thread#std thread|std::thread]]. Как говорилось в предыдущем разделе, перемещаться, но не копироваться могут многие типы стандартной библиотеки C++, владеющие ресурсами, например [[fstream#ifstream|std::ifstream]] и [[unique_ptr|std::unique_ptr]], и одним из таких типов является [[thread#std thread|std::thread]].

А это значит, что владение конкретным потоком выполнения можно перемещать между экземплярами [[thread#std thread|std::thread]], что и показано в следующем примере. В нем создаются два потока выполнения, а права собственности на них передаются между тремя экземплярами [[thread#std thread|std::thread]] — `t1`, `t2` и `t3`:
```c++
void some_function();
void some_other_function();

std::thread t1(some_function);
std::thread t2 = std::move(t1);

std::thread t3;
t3 = std::move(t2);
t1 = std::move(t3); //Это присваивание приведет к завершению программы!
```

Сначала запускается новый поток, который связывается с `t1`. Затем при создании `t2` путем вызова [[move|std::move()]] для явного перемещения владельца право собственности передается `t2`. В этот момент у `t1` больше нет связанного потока выполнения, и поток, выполняющий `some_function`, теперь связан с `t2`.

Затем запускается новый поток, связанный с временным объектом типа [[thread#std thread|std::thread]]. Последующая передача права собственности в `t1` не требует вызова [[move|std::move()]] для его явного перемещения, потому что владелец является временным объектом, а передача права собственности временными объектами подразумевается и выполняется автоматически.

Объект `t3` создан с установками по умолчанию, то есть без связанного с ним потока выполнения. Право собственности на поток, который в данный момент связан с `t2`, передается `t3`, для чего опять применяется явный вызов [[move|std::move()]], поскольку `t2` — именованный объект. После всех этих перемещений `t1` ассоциируется с потоком, выполняющим функцию `some_other_function`, у `t2` связанного потока нет, а `t3` связан с потоком, выполняющим `some_function`.

Последнее перемещение переносит владение потоком, выполняющим `some_function`, обратно в `t1`, откуда он начинался. Но в данном случае объект `t1` уже имел связанный с ним поток, который выполнял `some_other_function`, поэтому для завершения программы вызывается метод [[terminate|std::terminate()]].

Это делается для обеспечения согласованности с деструктором [[thread#std thread|std::thread]]. В #подразделе_2_1_1 было показано, что нужно ожидать явного завершения или отсоединения потока перед уничтожением, то же самое относится и к присваиванию: нельзя просто удалить поток, присвоив управляющему им объекту [[thread#std thread|std::thread]] новое значение.

Реализованная в [[thread#std thread|std::thread]] поддержка перемещения означает, что право собственности можно легко передать из функции (`листинг 2.5`).
```c++
std::thread f()
{
	void some_function();
	return std::thread(some_function);
}

std::thread g()
{
	void some_other_function(int);
	std::thread t(some_other_function, 42);
	return t;
}
```
**Листинг 2.5.** Возвращение `std::thread` из функции

Аналогично если владение должно быть передано функции, то, как показано далее, она может принять экземпляр [[thread#std thread|std::thread]] по значению в качестве одного из параметров:
```c++
void f(std::thread t);

void g()
{
	void some_function();
	
	f(std::thread(some_function));
	std::thread t(some_function);
	f(std::move(t));
}
```

Одно из преимуществ поддержки перемещения [[thread#std thread|std::thread]] — возможность надстроить класс `thread_guard`, показанный в `листинге 2.3`, и принудить его к владению потоком. Это позволит избежать неприятных последствий в том случае, если объект `thread_guard` переживет поток, на который ссылается. Это также означает, что никто другой не может присоединить или отсоединить поток после того, как право собственности на него передано объекту. Поскольку цель всего этого — в первую очередь обеспечить завершение потоков до выхода из области видимости, я назвал данный класс `scoped_thread`. Реализация и простой пример показаны в `листинге 2.6`.
```c++
class scoped_thread
{
	    std::thread t;
	public:
	    explicit scoped_thread(std::thread t_)
		    : t(std::move(t_))
	    {
	        if (!t.joinable())
	            throw std::logic_error("No thread");
	    }
	    
	    ~scoped_thread()
	    {
	        t.join();
	    }
	    
	    scoped_thread(scoped_thread const&) = delete;
	    scoped_thread& operator=(scoped_thread const&) = delete;
};

struct func;               // См. листинг 2.1
void f()
{
    int some_local_state;
    scoped_thread t{std::thread(func(some_local_state))};
    do_something_in_current_thread();
}
```
**Листинг 2.6.** Класс scoped_thread и пример его применения

Код примера похож на приведенный в `листинге 2.3`, но новый поток вместо создания для него отдельной именованной переменной передается непосредственно в `scoped_thread`. Когда исходный поток достигает конца `f`, объект `scoped_thread` уничтожается, а затем этот поток присоединяется к потоку, переданному конструктору. В ходе работы с классом `thread_guard` из `листинга 2.3` деструктор должен был проверить, что поток все еще является присоединяемым, а здесь это можно сделать в конструкторе, выдав в случае отрицательного результата исключение.

Одно из предложений для C++17 касалось класса `joining_thread`, который был бы похож на [[thread#std thread|std::thread]], за исключением того, что автоматически включался бы в деструктор так же, как это делает `scoped_thread`. Но к согласию в Комитете прийти не удалось, и это предложение не было включено в стандарт (хотя в виде класса [[thread#std jthread|std::jthread]] оно все еще актуально для перспективного стандарта C++20), но его относительно несложно создать. Одна из возможных реализаций показана в `листинге 2.7`.
```c++
class joining_thread
{
		std::thread t;
		
	public:
		joining_thread() noexcept=default;
		
		template<typename Callable,typename … Args>
		explicit joining_thread(Callable&& func,Args&& … args)
			: t(std::forward<Callable>(func),std::forward<Args>(args)…)
		{}
		
		explicit joining_thread(std::thread t_) noexcept
			: t(std::move(t_))
		{}
		
		joining_thread(joining_thread&& other) noexcept
			: t(std::move(other.t))
		{}
		
		joining_thread& operator=(joining_thread&& other) noexcept
		{
			if(joinable())
				join();
				
			t=std::move(other.t);
			return *this;
		}
		
		joining_thread& operator=(std::thread other) noexcept
		{
			if(joinable())
				join();
				
			t=std::move(other);
			return *this;
		}
		
		~joining_thread() noexcept
		{
			if(joinable())
				join();
		}
		
		void swap(joining_thread& other) noexcept
		{
			t.swap(other.t);
		}
		
		std::thread::id get_id() const noexcept
		{
			return t.get_id();
		}
		
		bool joinable() const noexcept
		{
			return t.joinable();
		}
		
		void join()
		{
			t.join();
		}
		
		void detach()
		{
			t.detach();
		}
		
		std::thread& as_thread() noexcept
		{
			return t;
		}
		
		const std::thread& as_thread() const noexcept
		{
			return t;
		}
}
```
**Листинг 2.7.** Класс joining_thread

Поддержка перемещения в [[thread#std thread|std::thread]] допускает также использование контейнеров объектов [[thread#std thread|std::thread]], если эти контейнеры поддерживают перемещения, например применение обновленного [[vector|std::vector<>]]. Это позволяет создавать код из `листинга 2.8` — он порождает несколько потоков, а затем ожидает их завершения.
```c++
void do_work(unsigned id);

void f()
{
    std::vector<std::thread> threads;
    
    for (unsigned i = 0; i < 20; ++i)
    {
        threads.emplace_back(do_work, i); // Порождение потоков
    }
    
    for (auto& entry : threads)          // Поочередный вызов join() для 
        entry.join();                    // каждого потока
}
```
**Листинг 2.8.** Порождение нескольких потоков и ожидание их завершения

Если потоки, как часто требуется, используются для разделения работы алгоритма, то перед возвратом управления вызывающему коду все они должны быть завершены. Простая структура `листинга 2.8` подразумевает, что работа, выполняемая потоками, автономна, а результатом их операций являются только побочные эффекты для совместно используемых данных. Если бы функция `f()` должна была вернуть вызывающей программе значение, зависящее от результатов операций, выполненных в потоках, то при такой организации получить это значение можно было бы только после анализа разделяемых данных по завершении всех потоков. Альтернативные схемы передачи результатов операций между потоками рассматриваются в #главе_4.

Помещение объектов [[thread#std thread|std::thread]] в [[vector|std::vector]] — шаг к автоматизации управления этими потоками: вместо создания для них отдельных переменных и непосредственного соединения с ними можно рассматривать их как группу. Или пойти дальше, создав динамическое количество потоков, определяемое в ходе выполнения программы, а не фиксированное, как в `листинге 2.8`.

# Выбор количества потоков в ходе выполнения программы

Одна из функций стандартной библиотеки C++, помогающая решить данную задачу, — [[#std thread hardware_concurrency()|std::thread::hardware_concurrency()]]. Она возвращает то количество потоков, которые действительно могут работать одновременно в ходе выполнения программы. Например, в многоядерной системе оно может быть увязано с числом ядер центрального процессора. Функция дает всего лишь подсказку и может вернуть `0`, если информация недоступна, но ее данные способны принести пользу при разбиении задачи на потоки.

В `листинге 2.9` показана простая реализация параллельной версии [[accumulate|std::accumulate]]. В реальном коде потребуется, скорее всего, не самостоятельно создавать эту функцию, а использовать параллельную версию [[reduce|std::reduce]], рассматриваемую в #главе_10, но данная реализация служит иллюстрацией основной идеи. Она распределяет работу между потоками с минимальным количеством элементов на каждый из них, чтобы избежать высоких издержек на слишком большое количество потоков. Заметьте, здесь предполагается, что ни одна из операций не выдаст исключение, даже если они возможны. Конструктор [[thread#std thread|std::thread]], к примеру, будет выдавать исключение, если не сможет запустить новый поток выполнения. В этом простом примере обработка исключений в подобном алгоритме не предусмотрена (она рассматривается в #главе_8).
```c++
template<typename Iterator,typename T>
struct accumulate_block
{
	void operator()(Iterator first, Iterator last, T& result)
	{
		result=std::accumulate(first,last,result);
	}
};

template<typename Iterator,typename T>
T parallel_accumulate(Iterator first, Iterator last, T init)
{
	unsigned long const length = std::distance(first, last);
	if(!length)
		return init;
		
	unsigned long const min_per_thread=25;
	unsigned long const max_threads=
			(length+min_per_thread-1)/min_per_thread;
			
	unsigned long const hardware_threads=
			std::thread::hardware_concurrency();

	unsigned long const num_threads=
			std::min(hardware_threads!=0?hardware_threads:2,max_threads);

	unsigned long const block_size=length/num_threads;

	std::vector<T> results(num_threads);
	std::vector<std::thread> threads(num_threads-1);
	Iterator block_start=first;

	for(unsigned long i=0;i<(num_threads-1);++i)
	{
		Iterator block_end = block_start;
		std::advance(block_end, block_size);
		
		threads[i]=std::thread(
				accumulate_block<Iterator,T>(),
				block_start, block_end, std::ref(results[i]));

		block_start=block_end;
	}
	
	accumulate_block<Iterator,T>()(
			block_start, last, results[num_threads-1]);
}
```
**Листинг 2.9.** Простейшая параллельная версия [[accumulate|std::accumulate]]

Несмотря на большой объем кода, в этой функции нет ничего сложного. Если входной диапазон пуст, возвращается исходное значение, указанное в качестве значения параметра `init`. В противном случае в диапазоне есть хотя бы один элемент, поэтому, чтобы получить максимальное количество потоков, количество обрабатываемых элементов можно разделить на минимальный размер блока. Это сделано для того, чтобы не создавать 32 потока на 32-ядерном компьютере, если в диапазоне только пять значений.

Количество запускаемых потоков — это минимальное значение из полученного в результате расчетов максимума и количества аппаратных потоков. Не следует запускать больше потоков, чем может поддерживать имеющееся оборудование (приводя к появлению так называемого превышения лимитов), поскольку переключение контекста при превышении количества потоков повлечет за собой снижение производительности. Если при вызове [[#std thread hardware_concurrency()|std::thread::hardware_concurrency()]] возвращается `0`, количество выбирается по вашему усмотрению, в данном случае я выбрал `2`. Запускать слишком много потоков нежелательно, поскольку на одноядерном компьютере это замедлит работу, но нежелательно запускать и слишком мало потоков, потому что будет не реа­лизована возможность использования доступной конкурентности.

Количество элементов, обрабатываемых каждым потоком, равно длине диапазона, разделенной на количество потоков. Если число не делится без остатка, не стоит беспокоиться, с этой ситуацией мы справимся чуть позже.

После определения количества существующих потоков можно создать `std::vector<T>` для промежуточных результатов и `std::vector<std::thread>` для потоков. Следует отметить, что нужно запустить на один поток меньше, чем значение `num_threads`, поскольку один поток уже имеется.

После того как накоплены результаты для последнего блока, можно дождаться завершения всех потоков, созданных, как в `листинге 2.8`, с помощью [[for_each|std::for_each]], а затем сложить результаты с финальным вызовом [[accumulate|std::accumulate]].

Прежде чем распрощаться с этим примером, стоит отметить, что там, где оператор сложения для типа `T` не является ассоциативным (например, для `float` или `double`), результаты этого `parallel_accumulate` могут отличаться от результатов [[accumulate#std accumulate|std::accumulate]] из-за разбиения диапазона на блоки. Кроме того, к итераторам предъявляются несколько более жесткие требования: они должны быть по меньшей мере однонаправленными, [[collectulate|std::collectulate]] может работать с однопроходными входными итераторами, а `T` должен допускать конструирование по умолчанию, чтобы можно было создать вектор результатов `results`. Изменения требований такого рода общие для параллельных алгоритмов: чтобы стать параллельными, они по своей природе должны быть другими, что отражается на результатах и требованиях. Более подробно реализация параллельных алгоритмов рассматривается в #главе_8, а #глава_10 посвящена стандартным средствам, имеющимся в C++17 (эквивалентом рассмотренного здесь `parallel_accumulate` является параллельная форма [[reduce|std::reduce]]). Стоит также отметить, что невозможность возвращать значение непосредственно из потока вынуждает передавать ссылку на соответствующую запись в векторе результатов `results`. Альтернативные способы возвращения результатов из потоков с помощью [[future|фьючерсов]] рассматриваются в #главе_4.

В данном случае вся информация, необходимая каждому потоку, включая место, где будет храниться результат его вычисления, была передана при запуске потока. Но так бывает не всегда, и порой в процессе работы необходимо каким-то образом идентифицировать потоки. Можно, как в `листинге 2.8`, передать идентификационный номер в виде значения `i`, но если функция, нуждающаяся в идентификаторе, находится в стеке вызовов глубже на несколько уровней и может быть вызвана из любого потока, то делать это таким образом неудобно. Эта необходимость была нами предусмотрена при разработке стандартной библиотеки C++, поэтому уникальный идентификатор имеется у каждого потока.

# Идентификация потоков

Идентификаторы потоков относятся к типу `std::thread::id`, и их можно получить двумя способами. Во-первых, идентификатор потока можно получить из связанного с ним объекта [[thread#std thread|std::thread]], вызвав компонентную функцию get_id(). Если у объекта [[thread#std thread|std::thread]] нет связанного с ним потока выполнения, вызов `get_id()` возвращает созданный по умолчанию объект `std::thread::id`, который означает «не поток». Во-вторых, идентификатор можно получить, если вызвать функцию `std::this_thread::get_id()`, которая также определена в заголовке `<thread>`.

Объекты типа `std::thread::id` можно свободно копировать и сравнивать, иначе в качестве идентификаторов от них не было бы никакой пользы. Если два объекта типа `std::thread::id` равны, значит, они представляют один и тот же поток или оба имеют значение «не поток». Если два объекта не равны, они представляют разные потоки или один представляет поток, а другой имеет значение «не поток».

Стандартная библиотека C++ не ограничивает возможности лишь проверкой того, одинаковы идентификаторы потоков или нет: объекты типа `std::thread::id` предлагают полный набор операторов сравнения, предоставляющих весь спектр возможностей по упорядочению всех отличающихся друг от друга значений. Поэтому их можно использовать в качестве ключей в ассоциативных контейнерах, сортировать или сравнивать любым другим способом, который программист сочтет нужным. Операторы сравнения обеспечивают полноценное упорядочение всех неравных значений `std::thread::id`, поэтому они ведут себя интуитивно предсказуемым образом: если `a<b` и `b<c`, то `a<c` и т. д. Стандартная библиотека также предоставляет класс `std::hash<std::thread::id>`, поэтому значения типа `std::thread::id` можно использовать в качестве ключей в новых неупорядоченных ассоциативных контейнерах.

Экземпляры `std::thread::id` часто применяются для проверки необходимости выполнения потоком какой-либо операции. Например, если потоки, как в `листинге 2.9`, используются для разделения работы, то исходному потоку, запустившему другие потоки, может потребоваться выполнить свою работу в середине алгоритма немного иначе. В данном случае он может сохранить результат std::this_thread::get_id() перед запуском других потоков, а затем основная часть алгоритма, которая является общей для всех потоков, может проверить собственный идентификатор потока на предмет соответствия сохраненному значению:
```c++
std::thread::id master_thread;

void some_core_part_of_algorithm()
{
	if(std::this_thread::get_id()==master_thread)
	{
		do_master_thread_work();
	}
	
	do_common_work();
}
```

Как вариант, `std::thread::id` текущего потока может храниться в структуре данных как часть операции. Затем последующие операции с той же структурой данных могут сравнить сохраненный идентификатор на предмет соответствия идентификатору потока, выполняющего операцию, чтобы определить, какие операции разрешены или необходимы.

Точно так же идентификаторы потока можно применять в качестве ключей в ассоциативных контейнерах, где конкретные данные должны быть связаны с потоком, а альтернативные варианты, такие как локальное хранилище потока, для этого не подходят. Такой контейнер может, к примеру, использоваться управляющим потоком для хранения информации о каждом из потоков, находящихся под его управлением, или для передачи информации между ними.

Суть в том, что в большинстве случаев `std::thread::id` в качестве общего идентификатора для потока вполне достаточно, альтернативный вариант может понадобиться, только если идентификатор должен иметь связанное с ним семантическое значение, например, должен быть индексом в массиве. Экземпляр `std::thread::id` можно даже записать в выходной поток, например в [[cout|std::cout]]:
```c++
std::cout<<std::this_thread::get_id();
```

Конкретный вывод полностью зависит от реализации, стандарт лишь гарантирует, что идентификаторы потоков, определяемые при сравнении как одинаковые, выдают одинаковый вывод, а неодинаковые — различный. Следовательно, в первую очередь это пригодится при отладке и ведении учетных записей, но значения не несут никакой семантической нагрузки, и сделать на их основе дополнительные выводы невозможно.

# std::thread::hardware_concurrency()
#std_threadhardware_concurrency











