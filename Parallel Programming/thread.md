[[#std thread|std::thread]]
1. [[#Базовые потоки класс std thread|Базовые потоки: класс std::thread]] 3.1
	1. [[#Создание потока]] 3.1.1
	2. [[#Время жизни потоков]] 3.1.2
		1. [[#Функции join и detach]] 3.1.2.1
	3. [[#Передача аргументов при создании потока|Передача аргументов при создании потока]] 3.1.3
		1. [[#Передача по значению и по ссылке|Передача по значению и по ссылке]] 3.1.3.1
	4. [[#Перечень функций-членов]] 3.1.4 
2. [[#std jthread|Усовершенствованные потоки: класс std::jthread (стандарт С++ 20)]] 3.2
	1. [[#Автоматическое присоединение к потоку|Автоматическое присоединение к потоку]] 3.2.1
	2. [[#Прерывание по запросу в классе std jthread|Прерывание по запросу в классе std::jthread]] 3.2.2
	3. [[#Особенности класса std jthread]] 3.6.5
3. [[#std scoped_thread|std::scoped_thread]]
4. [[#Запуск потока|Запуск потока]] 2.1.1 (multithread)
5. [[#Ожидание завершения потока|Ожидание завершения потока]] 2.1.2 (multithread)
6. [[#Ожидание в исключительных обстоятельствах|Ожидание в исключительных обстоятельствах]] 2.1.3 (multithread)
7. [[#Запуск потоков в фоновом режиме|Запуск потоков в фоновом режиме]] 2.1.4 (multithread)

# std::thread

Класс `std::thread` служит обёрткой для потока – независимой единицы выполнения в составе программы. Выполняемая единица запускается сразу после своего создания, для этого она должна получить на вход вызываемый объект, который и задаёт, что должно быть сделано в потоке. Вызываемый объект может быть именованной функцией, функциональным объектом или лямбда-функцией.

Код, который создаёт поток, отвечает за его дальнейшую судьбу. Единица выполнения, работающая в потоке, завершается с окончанием работы своего вызываемого объекта. Создатель потока может либо присоединить поток, т.е. подождать его завершения посредством вызова `join`, либо отсоединиться от потока, вызвав функцию `detach`. Поток `t` находится в присоединяемом состоянии, если над ним не выполнялась ни одна из операций `join` и `detach`. Если в момент вызова деструктора объект-поток находится в присоединяемом состоянии, деструктор вызывает функцию `std::terminate`, которая приводит к аварийному завершению программы.

Поток, отсоединённый от своего создателя, часто называют потоком-демоном, поскольку он выполняется в фоновом режиме.

Под именем `std::thread` скрывается шаблон класса с переменным числом параметров. Это означает, что при создании потока можно передавать любое число аргументов, так как разное число аргументов могут принимать выполняющиеся в потоке вызываемые объекты.

Библиотека `std::thread` предоставляет стандартный способ управления потоками.
```c++
void foo(bool clause) { 
	/* do something... */ 
} 

std::vector<std::thread> threadsVector; 
threadsVector.emplace_back([]() { 
	// Лямбда-функция, которая будет вызвана 
}); 

threadsVector.emplace_back(foo, true); // поток запустит foo(true) 

for (auto& thread : threadsVector) 
	thread.join(); // ожидание окончания работы потоков
```

# Базовые потоки: класс std::thread

Чтобы создать поток в программе на языке C++, нужно подключить заголовочный файл `<thread>`.

## Создание потока

Объект типа `std::thread` представляет единицу выполнения программы. То, что должно быть выполнено в потоке, передаётся объекту `std::thread` при его создании в виде вызываемого объекта.

Вызываемый объект ведёт себя подобно функции. Конечно, он может быть в том числе и функцией, но также может быть функциональным объектом или лямбда-функцией. Значение, возвращаемое вызываемым объектом, игнорируется.

Сделав эти вводные замечания, можно рассмотреть пример.

Создание потоков с различными вызываемыми объектами:
```c++
// createThread.cpp

#include <iostream>
#include <thread>

void helloFunction(){
	std::cout << “Hello from a function.” << std::endl;
}

class HelloFunctionObject{
	public:
		void operator()() const {
			std::cout << “Hello from a function object.” << std::endl;
		}
};

int main(){
	std::cout << std::endl;
	
	std::thread t1(helloFunction);
	
	HelloFunctionObject helloFunctionObject;

	std::thread t2(helloFunctionObject);
	std::thread t3([]{std::cout << “Hello from a lambda.” << std::endl;});

	t1.join();
	t2.join();
	t3.join();
	
	std::cout << std::endl;
};
```

Все три потока, `t1`, `t2` и `t3`, печатают сообщения на консоль. При этом в потоке `t1` выполняется обычная функция, в потоке `t2` выполняется функциональный объект (класс), а в потоке `t2` – лямбда-функция. В строках `t1.join()` – `t3.join()` главный поток ожидает завершения всех дочерних потоков.

Посмотрим, как работает эта программа. Результаты её запуска довольно интересны.

![[ParallelProg_49.png]]

Три потока могут выполняться в произвольном порядке. Даже тексты, выводимые из разных потоков, могут перемешиваться между собой.

В этом примере главный поток, создающий дочерние потоки, отвечает за время жизни этих объектов.

## Время жизни потоков

Родители должны заботиться о своих детях. Из этого простого принципа вытекают далекоидущие следствия касательно времени жизни потоков. Рассмотрим пример: следующая программа должна запускать поток и выводить его идентификатор.

Забытое ожидание завершения потока:
```c++
// threadWithoutJoin.cpp

#include <iostream>
#include <thread>

int main(){
	std::thread t([]{std::cout << std::this_thread::get_id() << std::endl;});
}
```

Однако программа этого не делает.
![[ParallelProg_50.png]]

### Функции join и detach

Жизнь потока `t` завершается с окончанием выполнения его вызываемого объекта. У создателя потока есть на выбор два варианта:

* подождать завершения дочернего потока с помощью вызова `t.join()`;
* оборвать связь с дочерним потоком с помощью вызова `t.detach()`.

Вызов `t.join()` полезен в случаях, когда последующий код каким-то образом зависит от результатов работы дочернего потока. Вызов `t.detach()` позволяет дочернему потоку выполняться независимо от объекта `t`. Это значит, что поток, отсоединённый от объекта, будет выполняться до тех пор, пока не завершится выполняющийся в нём код. Чаще всего отсоединяют потоки, в которых выполняется долгая фоновая работа, например потоки-серверы.

Объект-поток с завёрнутым в него вызываемым объектом (объекты типа `std::thread` можно создавать и пустыми, без вызываемых объектов) называется присоединяемым (англ. joinable), если для него не вызывалась ни одна из функций-членов `join` и `detach`. Деструктор объекта-потока в присоединяемом состоянии вызывает аварийное завершение программы посредством [[terminate|std::terminate]]. Именно в этом причина аварийного завершения программы `threadWithoutJoin.cpp`. Если применить функцию `join` или `detach` к объекту, для которого какая-либо из этих функций-членов уже была вызвана ранее, произойдёт исключение типа `std::system_error`.

Исправить предыдущую программу довольно легко – для объекта-потока `t` вызвать функцию-член `join`.

```c++
// threadWithoutJoin.cpp

#include <iostream>
#include <thread>

int main(){
	std::thread t([]{std::cout << std::this_thread::get_id() << std::endl;});
	
	t.join();
}
```

Теперь программа работает так, как ожидалось.

Число, которое программа выводит на печать, – это уникальный идентификатор потока в системе.

> **Трудность с функцией `detach`**
> 
> Конечно же, в последней программе вместо функции `join` можно было бы применить функцию `detach`. Объект-поток `t` перешёл бы в неприсоединяемое состояние, и его деструктор не стал бы аварийно завершать программу. Но в этом случае возникло бы иное затруднение. Поведение такой программы не определено, поскольку главный поток может завершиться раньше дочернего, и тогда последнему просто не останется времени, чтобы вывести на печать свой результат.

> **Класс `scoped_thread` Энтони Уильямса**
> 
>Если своими руками управлять временем жизни потоков слишком обременительно, можно инкапсулировать класс `std::thread` в собственный класс-обёртку. Деструктор этого класса должен автоматически вызывать функцию `join` потока, если тот всё ещё находится в присоединяемом состоянии. Конечно, можно поступить и противоположным образом, автоматически вызывая для потока функцию `detach` – однако это может быть сопряжено с определёнными трудностями.
>
> Энтони Уильямс создал такой полезный класс и описал его в своей превосходной книге «Параллельное программирование на C++ в действии». Класс-обёртку он назвал `scoped_thread`. Конструктор этого класса принимает в качестве аргумента поток `t` и проверяет, находится ли он попрежнему в присоединяемом состоянии. Если поток-аргумент `t` не поддерживает присоединение, нет и необходимости в классе `scoped_thread`. Если же поток `t` можно присоединить, деструктор класса вызывает `t.join()`. Поскольку конструктор копирования и копирующая операция присваивания в явном виде удалены, экземпляры класса `scoped_thread` не могут копироваться никаким способом.

```c++
// scoped_thread.cpp
#include <iostream>
#include <thread>
#include <utility>

class scoped_thread{
		std::thread t;
	
	public:
		explicit scoped_thread(std::thread t_): t(std::move(t_)){
			if (!t.joinable()) throw std::logic_error(“No thread”);
		}
		
		~scoped_thread(){
			t.join();
		}
		
	scoped_thread(scoped_thread&)= delete;
	scoped_thread& operator=(scoped_thread const &)= delete;
};
```

## Передача аргументов при создании потока

Вызываемый объект, выполняющийся в потоке (в частности, обычная функция), может получать свои аргументы посредством копирования значения, по перемещению или по ссылке. Класс `std::thread` представляет собой шаблон с переменным числом аргументов, или, как их ещё называют, вариадический шаблон.

Если поток получает на вход данные по ссылке, нужно быть чрезвычайно осторожным в том, что касается времени жизни передаваемых объектов и совместного доступа к данным.

### Передача по значению и по ссылке

Рассмотрим следующий небольшой фрагмент кода:

```C++
std::string s{“C++11”}

std::thread t1([=]{ std::cout << s << std::endl; });
t1.join();

std::thread t2([&]{ std::cout << s << std::endl; });
t2.detach();
```

Поток `t1` получает данные по значению (т. е. путём создания копии), а поток `t2` – по ссылке.

> **Передача аргументов в поток по ссылке**
> 
> По правде говоря, в этом примере допущено некоторое упрощение. Там сказано, что поток `t2` получает аргумент по ссылке, однако на самом деле это лямбда-функция захватывает ссылку на локальные данные. Чтобы передать по ссылке аргумент в функцию потока, нужно завернуть его в класс-обёртку ссылок. Это просто сделать, воспользовавшись вспомогательной функцией `std::ref`, определённой в заголовочном файле `<functional>`. Например:
```c++
void transferMoney(int amount, Account& from, Account& to){
	...
}

...

std::thread thr1(transferMoney, 50, std::ref(account1),
				 std::ref(account2));
```

> Здесь поток `thr1` выполняет функцию `transferMoney`, которая получает аргументы по ссылке. Благодаря использованию функции `std::ref` в функцию будут переданы ссылки на объекты `account1` и `account2`.

Какие тонкости могут таиться в этих строчках кода? Поток `t2` получает строку `s` по ссылке, а затем отсоединяется от родительского потока. Время жизни строки `s` ограничено временем выполнения объемлющей функции. Время жизни глобального объекта `std::cout` ограничивается только временем выполнения главного потока программы. Поэтому время жизни объектов `s` и `std::cout` может оказаться короче, чем время выполнения потока `t2`. Таким образом мы оказываемся по уши в неопределённом поведении.

Передача в поток аргументов по ссылке:
```c++
// threadArguments.cpp

#include <chrono>
#include <iostream>
#include <thread>

class Sleeper{
	public:
		Sleeper(int& i_):i{i_}{};

		void operator() (int k){
			for (unsigned int j= 0; j <= 5; ++j){
				std::this_thread::sleep_for(
									std::chrono::milliseconds(100));
				i += k;
			}
		}
		
	private:
		int& i;
};

int main(){
	std::cout << std::endl;

	int valSleeper = 1000;
	std::thread t(Sleeper(valSleeper), 5);
	t.detach();
	
	std::cout << “valSleeper = “ << valSleeper << std::endl;
	
	std::cout << std::endl;
}
```

Какое значение имеет переменная `valSleeper` в строке `std::cout << “valSleeper = “ << valSleeper << std::endl`? Переменная `valSleeper` живёт, пока выполняется функция `main`. Поток `t` получает для работы функциональный объект, в который завёрнута ссылка на переменную `valSleeper`, и число 5. Главное в этом примере то, что поток `t` получает переменную `valSleeper` по ссылке (`Sleeper(int& i_):i{i_}{}`) и отсоединяется от главного потока (строка `t.detach()`). В дочернем потоке выполняется перегруженная операция вызова функционального объекта (`void operator() (int k)`). В этой функции цикл увеличивает счётчик от 0 до 5 включительно, на каждой итерации ждёт 1/10 секунды и увеличивает переменную `i` на величину `k`. В конце дочерний поток должен напечатать свой идентификатор. Считая, как говорят в Германии, «по Адаму Ризе», результат должен составлять
```
1000 + 6 * 5 = 1030
```

Однако как же программа работает на самом деле? Что-то в ней идёт не так.

![[ParallelProg_52.png]]

Программа обнаруживает два странных свойства. Во-первых, значение переменной `valSleeper` в конце оказывается равным `1000`, а во-вторых, идентификатор дочернего потока на печать не выводится. Программа страдает по меньшей мере двумя изъянами.

4. Разные потоки имеют ничем не ограниченный доступ к переменной `valSleeper`. Здесь имеет место гонка данных, поскольку потоки могут одновременно производить чтение и запись этой переменной.
5. Время жизни главного потока завершается раньше, чем дочерний поток успевает выполнить все свои вычисления и вывести свой идентификатор в поток `std::cout`.

Оба названных обстоятельства переводят программу в состояние гонки, поскольку результат работы программы зависит от относительной скорости выполнения операций в разных потоках. Состояние гонок выступает причиной гонки данных.

Исправить гонку данных довольно просто. Для этого достаточно защитить переменную `valSleeper` мьютексом или сделать её атомарной. Что-бы преодолеть ошибку, связанную со временем жизни объектов `valSleeper` и `std::cout`, нужно не отсоединять дочерний поток, а, напротив, присоединить его выполнение (функция `join`). Ниже представлена исправленная функция `main`.
```c++
int main(){
	std::cout << std::endl;

	int valSleeper= 1000;
	std::thread t(Sleeper(valSleeper),5);
	t.join();
	
	std::cout << “valSleeper = “ << valSleeper << std::endl;
	
	std::cout << std::endl;
}
```

Теперь программа выдаёт правильный результат, хотя, конечно, и выполняется медленнее.

![[ParallelProg_53.png]]

## Перечень функций-членов

Интерфейс класса `std::thread` показан ниже в виде таблицы. Более подробные сведения можно найти на сайте cppreference.com.

**Функции-члены класса `std::thread`**

| **Функция**                             | **Описание**                                                          |
| --------------------------------------- | --------------------------------------------------------------------- |
| `join`                                  | Ждать завершения потока                                               |
| `detach`                                | Разорвать связь с потоком и оставить его выполняться независимо       |
| `joinable`                              | Узнать, находится ли поток в присоединяемом состоянии                 |
| `get_id`,<br>`std::this_thread::get_id` | Узнать идентификатор потока                                           |
| `hardware_concurrency`                  | Узнать, сколько потоков может выполняться параллельно                 |
| `std::this_thread::sleep_until`         | Погрузить поток в сон до определённого абсолютного момента времени    |
| `std::this_thread::sleep_for`           | Погрузить поток в сон на заданное время относительно текущего момента |
| `std::this_thread::yield`               | Уступить выполнение другому потоку                                    |
| `t1.swap(t2)`<br>`std::swap(t1, t2)`    | Обменять местами два объекта                                          |

> **Доступ к системно-зависимой реализации**
> 
> Классы из стандартной библиотеки представляют собой обёртку над реализацией потоков в конкретной платформе. Для доступа к системному дескриптору потока можно воспользоваться функцией `native_handle`. Такие системные дескрипторы можно получать для потоков, [[mutex|мьютексов]] и переменных условия.

Объекты класса `std::thread` нельзя копировать, но можно перемещать. Функция `swap` обменивает местами содержимое двух объектов, пользуясь для этого перемещением.

**Функции-члены класса `std::thread`**
```c++
// threadMethods.cpp

#include <iostream>
#include <thread>
using namespace std;

int main(){
	cout << boolalpha << endl;

	cout << “hardware_concurrency()= “
						<< thread::hardware_concurrency() << endl;

	thread t1([]{cout << “t1 with id= “ << this_thread::get_id() 
														<< endl;});
	thread t2([]{cout << “t2 with id= “ << this_thread::get_id() 
														<< endl;});

	cout << endl;
	
	cout << “FROM MAIN: id of t1 “ << t1.get_id() << endl;
	cout << “FROM MAIN: id of t2 “ << t2.get_id() << endl;

	cout << endl;

	swap(t1,t2);

	cout << “FROM MAIN: id of t1 “ << t1.get_id() << endl;
	cout << “FROM MAIN: id of t2 “ << t2.get_id() << endl;
	
	cout << endl;
	
	cout << “FROM MAIN: id of main= “ << this_thread::get_id() << endl;

	cout << endl;

	cout << “t1.joinable(): “ << t1.joinable() << endl;

	cout << endl;

	t1.join();
	t2.join();
	
	cout << endl;
	
	cout << “t1.joinable(): “ << t1.joinable() << endl;
	
	cout << endl;
}
```

результат её работы:
![[ParallelProg_54.png]]

Может показаться странным, что потоки `t1` и `t2` (строки `thread t1([]{cout << “t1 with id= “ << this_thread::get_id() << endl;})` и `thread t2([]{cout << “t2 with id= “ << this_thread::get_id() << endl;})`) отрабатывают в столь различные моменты времени. Однако это нормально: у программиста нет никаких гарантий относительно того, когда и с какой скоростью выполняются потоки. С уверенностью можно сказать лишь, что выполнение потоков завершится к моменту завершения функции `join`, вызванной в строках `t1.join()` и `t2.join()`.

Управление параллельными потоками тем труднее, чем больше изменяемых (т. е. неконстантных) данных находится у них в общем доступе.

# std::jthread

Название `jthread` означает «присоединяемый» (англ. joinable) поток. В дополнение ко всему, что умеет делать класс [[thread#std thread|std::thread]], введённый в стандарте C++11, этот класс ожидает завершения потока в деструкторе и поддерживает кооперативное прерывание. Тем самым класс `std::jthread` расширяет интерфейс класса [[thread#std thread|std::thread]].

В следующей таблице представлен обзор функциональных возможностей, добавленных в классе `std::jthread`.

**Дополнительные функции-члены класса `std::jthread`:**

| **Имя**           | **Описание**                                                             |
| ----------------- | ------------------------------------------------------------------------ |
| `get_stop_source` | Возвращает объект типа `std::stop_source`, связанный с флагом завершения |
| `get_stop_token`  | Возвращает объект типа `std::stop_token`, связанный с флагом завершения  |
| `request_stop`    | Запрашивает завершение выполнения через флаг                             |

## Автоматическое присоединение к потоку

Поведение класса [[#std thread|std::thread]] противоречит ожиданиям: если на момент вызова деструктора поток находится в присоединяемом состоянии, выполнение всей программы аварийно завершается вызовом [[terminate|std::terminate]]. Напомним, что поток находится в присоединяемом состоянии, если он был запущен и для него не вызывалась ни одна из функций `join` или `detach`.

**Аварийно завершающаяся программа с присоединяемым потоком:**
```c++
// threadJoinable.cpp

#include <iostream>
#include <thread>

int main() {
	std::cout << std::endl;
	std::cout << std::boolalpha;
	
	std::thread thr{[]{ std::cout << “Joinable std::thread” 
												<< std::endl; }};
	std::cout << “thr.joinable(): “ << thr.joinable() 
												<< std::endl;
	
	std::cout << std::endl;
}
```

Если эту программу запустить, она завершится с ошибкой.

![[ParallelProg_55.png]]

Оба запуска программы завершаются с ошибкой. При этом во второй раз у потока `thr` оказывается вдоволь времени, чтобы вывести своё сообщение: `«Joinable std::thread»`.

Следующий код во всём подобен предыдущему, за исключением замены класса [[#std thread|std::thread]] классом `std::jthread` из стандарта C++ 20.

**Завершение потока `std::jthread` в присоединяемом состоянии:**
```c++
// jthreadJoinable.cpp

#include <iostream>
#include <thread>

int main() {
	std::cout << std::endl;
	std::cout << std::boolalpha;

	std::jthread thr{[]{ std::cout << “Joinable std::jthread” 
												<< std::endl; }};

	std::cout << “thr.joinable(): “ << thr.joinable() << std::endl;
	std::cout << std::endl;
}
```

Теперь выполнение дочернего потока автоматически присоединяется к главному потоку при деструкции объекта `thr`, поскольку в момент выхода за область видимости он всё ещё находится в присоединяемом состоянии.

Ниже показано, как мог бы быть реализован деструктор класса `std::jthread`.

**Деструктор класса std::jthread:**
```c++
jthread::~jthread() {
	if(joinable()) {
		request_stop();
		join();
	}
}
```

В первую очередь деструктор проверяет, по-прежнему ли поток допускает присоединение (строка `if(joinable())`). Поток находится в присоединяемом состоянии, если он был запущен и для него не вызывалась ни одна из функций `join` или `detach`. Если присоединение имеет смысл, деструктор запрашивает завершение потока (строка `request_stop()`) и затем вызывает функцию `join`. Этот вызов блокирует вызывающий поток до тех пор, пока не закончится выполнение дочернего потока.

## Прерывание по запросу в классе std::jthread

Чтобы проиллюстрировать основную идею, начнём с простого примера.

**Прерываемый и непрерываемый потоки:**
```c++
// interruptJthread.cpp

#include <chrono>
#include <iostream>
#include <thread>

using namespace::std::literals;

int main() {
	std::cout << ‘\n’;
	
	std::jthread nonInterruptable([]{
		int counter{0};
		while (counter < 10){
			std::this_thread::sleep_for(0.2s);
			std::cerr << “nonInterruptable: “ << counter << ‘\n’;
			++counter;
		}
	});
	
	std::jthread interruptable([](std::stop_token stoken){
		int counter{0};
		while (counter < 10){
			std::this_thread::sleep_for(0.2s);
			if (stoken.stop_requested()) return;
			std::cerr << “interruptable: “ << counter << ‘\n’;
			++counter;
		}
	});
	
	std::this_thread::sleep_for(1s);

	std::cerr << ‘\n’;
	std::cerr << “Main thread interrupts both jthreads” << ‘\n’;
	
	nonInterruptable.request_stop();
	interruptable.request_stop();
	
	std::cout << ‘\n’;
}
```

В главном потоке запускаются два дочерних потока: `nonInterruptible` (с англ. «непрерываемый») в строке `std::jthread nonInterruptable([]{` и `interruptible` (соотв. «прерываемый») в строке `std::jthread interruptable([](std::stop_token stoken){`. В отличие от непрерываемого потока, прерываемый получает объект `std::stop_token` (флаг завершения) и использует его в строке `if (stoken.stop_requested()) return;` для проверки того, не запросил ли кто-либо завершение потока (для этого служит функция-член `stop_requested`). Если завершение запрошено, [[Lambda|лямбда-функция]] возвращает управление, и тем самым завершается работа потока.

Вызов функции `request_stop` в строке `interruptable.request_stop();` запрашивает завершение потока. Однако на первый поток `nonInterruptible` этот запрос не действует: поток просто не реагирует на него.

![[ParallelProg_56.png]]

## Особенности класса std::jthread

Класс [[#std jthread|std::jthread]] представляет собой почти что копию класса [[#std thread|std::thread]] с дополнительными возможностями: кооперативным прерыванием и автоматическим присоединением. Для поддержки обеих этих возможностей поток [[#std thread|std::thread]] обладает встроенным объектом [[Кооперативное прерывание потоков#Класс std stop_token|std::stop_token]].

| **Функция**       | **Описание**                                                                                                                         |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `get_stop_source` | Возвращает объект типа [[Кооперативное прерывание потоков#Класс std stop_source\|std::stop_source]], связанный с состоянием останова |
| `get_stop_token`  | Возвращает объект типа [[Кооперативное прерывание потоков#Класс std stop_token\|std::stop_token]], связанный с состоянием останова   |
| `request_stop`    | Запрашивает останов потока через состояние останова                                                                                  |

# std::scoped_thread
#std_scoped_thread

# Запуск потока

В [[Практика многопоточного программирования|Здравствуй, мир конкурентности C++]] было показано, что потоки запускаются созданием объекта [[thread#std thread|std::thread]], в котором определяется выполняемая в потоке задача. В простейшем случае эта задача представляет собой обычную функцию, которая возвращает `void-значение`, и не принимает никаких параметров. Эта функция выполняется в собственном потоке, пока не вернет управление, после чего поток останавливается. В иных случаях задача может быть функциональным объектом, принимающим дополнительные параметры и выполняющим ряд независимых операций, которые задаются посредством некоей системы обмена сообщениями в ходе его выполнения. Поток останавливается только при получении соответствующего сигнала, опять же через некую систему сообщений. Что бы ни собирался делать поток и откуда бы он ни запускался, его запуск с использованием стандартной библиотеки C++ всегда сводится к созданию объекта [[thread#std thread|std::thread]]:
```c++
void do_some_work();
std::thread my_thread(do_some_work);
```

Проще, наверное, и быть не может. Конечно, чтобы компилятор мог видеть определение класса [[thread#std thread|std::thread]], нужно убедиться, что в программу включен заголовок `<thread>`. Как и основная часть содержимого стандартной библиотеки C++, [[thread#std thread|std::thread]] работает с любым вызываемым типом, поэтому конструктору [[thread#std thread|std::thread]] можно также передать экземпляр класса с оператором вызова функции:
```c++
class background_task
{
	public:
		void operator()() const
		{
			do_something();
			do_something_else();
		}
};

background_task f;
std::thread my_thread(f);
```

В данном случае предоставленный функциональный объект копируется в хранилище, принадлежащее вновь созданному потоку выполнения, и вызывается оттуда. Поэтому важно, чтобы копия действовала аналогично оригиналу, иначе результат может не соответствовать ожидаемому.

При передаче функционального объекта в конструктор потока следует избегать так называемого самого неприятного случая синтаксического анализа C++. Если передается временная, а не именованная переменная, синтаксис может быть таким же, как и при объявлении функции. В этом случае компилятор интерпретирует его именно таким образом, а не как определение объекта. Например, код:
```c++
std::thread my_thread(background_task());
```

объявляет функцию `my_thread`, принимающую единственный параметр наподобие указателя на функцию, не принимающую параметры и возвращающую объект фоновой задачи `background_task`, и вместо запуска нового потока возвращает объект [[thread#std thread|std::thread]]. Такого развития событий можно избежать, присвоив функциональному объекту имя, как было показано ранее, с помощью дополнительных скобок или нового унифицированного синтаксиса инициализации, например:
```c++
std::thread my_thread((background_task()));
std::thread my_thread{background_task()};
```

В первом примере дополнительные скобки не позволяют интерпретировать код как объявление функции, разрешая объявить `my_thread` переменной типа [[thread#std thread|std::thread]]. Во втором примере используется новый унифицированный синтаксис инициализации с фигурными, а не круглыми скобками, также позволяющий объявить переменную.

Одним из типов вызываемого объекта, позволяющего избегать возникновения рассматриваемой проблемы, является лямбда-выражение. Эта новая особенность, появившаяся в стандарте C++11, допускает создание локальной функции с возможным захватом некоторых локальных переменных, избавляя от необходимости передачи дополнительных аргументов (см. #раздел_2_2). Более подробно лямбда-выражения рассматриваются в #разделе_A_5. С помощью лямбда-выражения предыдущий пример можно записать следующим образом:
```c++
std::thread my_thread([]{
	do_something();
	do_something_else();
});
```

Научившись запускать поток, нужно принять однозначное решение, ждать ли его завершения (присоединив его — см. #подраздел_2_1_2) или пустить его на самотек (путем его отсоединения — см. #подраздел_2_1_3). Если не принять решение до уничтожения объекта [[thread#std thread|std::thread]], то программа завершится (деструктор [[thread#std thread|std::thread]] вызовет метод [[terminate|std::terminate()]]). Поэтому даже при выдаче исключений необходимо убедиться, что поток правильно присоединен или отсоединен. Методы, позволяющие справиться с таким сценарием, рассмотрены в #подразделе_2_1_3. Учтите, что решение нужно принимать до того, как объект std::thread будет уничтожен. Сам же поток вполне мог бы завершиться задолго до его присоединения или отсоединения. Если его отсоединить, то при условии, что он все еще выполняется, он и будет выполняться, и этот процесс может продолжаться еще долго и после уничтожения объекта [[thread#std thread|std::thread]]. Выполнение будет прекращено, только когда в конце концов произойдет возвращение из функции потока.

Если не дожидаться завершения потока, необходимо убедиться, что данные, к которым он обращается, будут действительны, пока он не закончит работать с ними. Эта проблема не отличается новизной — даже в однопоточном коде поведение приложения при доступе к объекту после его уничтожения характеризуется неопределенностью, но при использовании потоков вероятность столкнуться с подобными проблемами времени жизни объектов возрастает.

К примеру, похожие проблемы могут возникнуть, если функция потока содержит указатели или ссылки на локальные переменные, а поток при выходе из функции не завершается. Пример такого сценария:
![[practice_multithreaded-5.png]]
Функция, возвращающая управление, в то время как в потоке сохраняется обращение к локальным переменным

В данном случае новый поток, связанный с `my_thread`, при выходе из `oops`, вероятно, все еще будет выполняться, поскольку, судя по вызову `detach()`, было принято решение не дожидаться его завершения. Если поток все еще выполняется, все идет по сценарию, показанному в табл. 2.1: следующий вызов `do_something(i)` будет обращаться к уже уничтоженной переменной. Все это похоже на обычный однопоточный код, в котором сохранять указатель или ссылку на локальную переменную после выхода из функции непозволительно, но вероятность допустить такую ошибку при использовании многопоточного кода значительно выше, поскольку ее негативные проявления видны не сразу.

Таблица 2.1. Обращение к локальной переменной в отсоединенном потоке после того, как она была уничтожена

| Основной поток                                         | Новый поток                                                                                                                           |
| ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| Создание `my_func` со ссылкой<br>на `some_local_state` |                                                                                                                                       |
| Запуск нового потока `my_thread`                       | Запуск<br>Вызов `func::operator()`                                                                                                    |
| Отсоединение `my_thread`                               | Запуск `func::operator()`; возможен<br>вызов do_something со ссылкой на `some_local_state`                                            |
| Уничтожение `some_local_state`                         | Продолжение выполнения                                                                                                                |
| Выход из `oops`                                        | Продолжение выполнения `func::operator()`; возможен вызов `do_something` со ссылкой на `some_local_state =>` неопределенное поведение |

Справиться с подобным сценарием можно одним из распространенных способов: сделать функцию потока автономной и вместо разделения данных скопировать их в поток. При использовании вызываемого объекта для функции потока этот объект копируется в поток, поэтому исходный объект можно тут же уничтожить. Тем не менее следует опасаться объектов, содержащих указатели или ссылки, как, к примеру, выше. В частности, не рекомендуется создавать внутри функции поток, имеющий доступ к ее локальным переменным, если только не будет обеспечено завершение потока до выхода из этой функции. Или же, присоединив поток до выхода из функции, можно убедиться в завершении его выполнения.

# Ожидание завершения потока

Дождаться завершения потока можно, вызвав [[thread#Функции join и detach|join()]] для связанного экземпляра [[thread#std thread|std::thread]]. Что касается кода выше, то замены вызова `my_thread.detach()` перед закрывающей фигурной скобкой тела функции вызовом `my_thread.join()` было бы достаточно, чтобы гарантировать завершение потока до выхода из функции и, следовательно, до уничтожения локальных переменных. В данном случае это означало бы, что запускать функцию в отдельном потоке нет смысла, поскольку первый поток во время ожидания не будет выполнять никакой полезной работы. Но в реальном коде исходный поток будет либо выполнять полезную работу, либо запускать несколько потоков для выполнения полезной работы, прежде чем входить в режим ожидания их завершения.

Применение метода [[thread#Функции join и detach|join()]] — простой и незамысловатый прием: либо вы ждете завершения потока, либо нет. Если нужен более утонченный контроль над ожиданием потока, допустим, с проверкой завершения потока или ожиданием в течение строго определенного времени, придется воспользоваться альтернативными механизмами, например условными переменными и [[future|фьючерсами]], которые будут рассматриваться в #главе_4. Вызов [[thread#Функции join и detach|join()]] также приводит к очистке любого хранилища, связанного с потоком, поэтому объект [[thread#std thread|std::thread]] больше не связан с завершенным потоком. Мало того, он не связан ни с одним потоком. Это означает, что [[thread#Функции join и detach|join()]] можно вызвать для конкретного потока только один раз: как только вызван метод [[thread#Функции join и detach|join()]], объект [[thread#std thread|std::thread]] утрачивает возможность присоединения, а метод `joinable()` вернет значение `false`.

## Ожидание в исключительных обстоятельствах

Как упоминалось ранее, следует убедиться, что вызов [[thread#Функции join и detach|либо join(), либо detach()]] был выполнен еще до уничтожения объекта [[thread#std thread|std::thread]]. При отсоединении потока метод [[thread#Функции join и detach|detach()]] можно вызвать сразу же после запуска этого потока, так что это не проблема. Но если есть намерение дожидаться завершения потока, то место в коде, где будет выполнен вызов метода [[thread#Функции join и detach|join()]], нужно выбирать с особой тщательностью, поскольку при выдаче исключения после запуска потока, но до вызова [[thread#Функции join и detach|join()]] вызов этого метода можно пропустить.

Чтобы избежать завершения приложения при выдаче исключения, необходимо решить, что делать в таком случае. Вообще, если вы намеревались вызвать [[thread#Функции join и detach|join()]] при нормальном выполнении программы, вам, чтобы избежать проблем, связанных с временем жизни, необходимо вызвать [[thread#Функции join и detach|join()]] и при выдаче исключения. Простой код, выполняющий именно такие действия, показан ниже.
![[practice_multithreaded-6.png]]
**Листинг 2.2.** Ожидание завершения потока.

Код в листинге 2.2 содержит блок [[try|try-catch]], позволяющий гарантировать, что поток с доступом к локальному состоянию завершится до выхода из функции независимо от того, завершается ли функция нормально или из-за выдачи исключения. Использование блоков [[try|try-catch]] растягивает код, повышая вероятность получения неправильной области видимости, поэтому данный сценарий далек от идеала. Если есть веские причины обеспечить завершение потока до выхода из функции, скажем, из-за наличия ссылки на другие локальные переменные или чего-нибудь еще, важно убедиться, что учтены все возможные пути выхода, как нормальные, так и исключительные, и желательно обеспечить для этого простой и лаконичный механизм.

Кроме иных способов, это можно сделать с использованием стандартного способа `RAII` и, как показано в `листинге 2.3`, предоставить класс, выполняющий метод [[thread#Функции join и detach|join()]] в своем деструкторе. Посмотрите, насколько при этом упрощается функция `f()`.
```c++
class thread_guard
{
	    std::thread& t;
	public:
	    explicit thread_guard(std::thread& t_)
		    :t(t_)
	    {}
	    
	    ~thread_guard()
	    {
	        if (t.joinable())
	        {
	            t.join();
	        }
	    }
	    
	    thread_guard(thread_guard const&) = delete;
	    thread_guard& operator=(thread_guard const&) = delete;
};

struct func; // см. определение в листинге 2.1
void f()
{
    int some_local_state = 0;
    func my_func(some_local_state);
    std::thread t(my_func);
    thread_guard g(t);
    do_something_in_current_thread();
}
```
листинг 2.3. Использование `RAII` для ожидания завершения потока

Когда выполнение текущего потока достигает конца функции `f`, локальные объекты уничтожаются в порядке, обратном порядку их построения. Следовательно, сначала уничтожается объект `g` типа `thread_guard`, а в его деструкторе происходит присоединение к потоку. Это наблюдается даже при завершении выполнения функции, поскольку `do_something_in_current_thread` выдает исключение.

Перед вызовом метода [[thread#Функции join и detach|join()]] деструктор `thread_guard` в листинге 2.3 сначала
проверяет с помощью метода `joinable()`, является ли объект [[thread#std thread|std::thread]] присоединяемым. Важность этого действия обусловливается тем, что метод [[thread#Функции join и detach|join()]] для конкретного потока выполнения можно вызвать только один раз, поэтому, если поток уже был присоединен, его вызов станет ошибкой.

Копирующий конструктор и операторы копирующего присваивания помечают спецификатором `=delete`, чтобы запретить компилятору автоматически предоставлять их. Копирование или присваивание такого объекта было бы опасным, поскольку тогда время его жизни могло бы превысить время жизни присоединяемого потока. При объявлении их удаленными любая попытка скопировать объект `thread_guard` будет приводить к выдаче ошибки компиляции. Более подробно удаленные функции рассматриваются в #разделе_A_2.

Если ждать завершения потока не нужно, проблемы безопасности исключений можно избежать, отсоединив этот поток. Тем самым разрывается его связь с объектом [[thread#std thread|std::thread]] и гарантируется, что метод [[terminate|std::terminate()]] не будет вызван при удалении объекта [[thread#std thread|std::thread]], даже если поток все еще выполняется в фоновом режиме.

## Запуск потоков в фоновом режиме






