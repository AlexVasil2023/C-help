[[#std thread|std::thread]]
1. [[#Базовые потоки класс std thread|Базовые потоки: класс std::thread]] 3.1
	1. [[#Создание потока]] 3.1.1
	2. [[#Время жизни потоков]] 3.1.2
		1. [[#Функции join и detach]] 3.1.2.1
	3. [[#Передача аргументов при создании потока|Передача аргументов при создании потока]] 3.1.3
		1. [[#Передача по значению и по ссылке|Передача по значению и по ссылке]] 3.1.3.1
	4. [[#Перечень функций-членов]] 3.1.4 
2. [[#std jthread|Усовершенствованные потоки: класс std::jthread (стандарт С++ 20)]] 3.2
	1. [[#Автоматическое присоединение к потоку|Автоматическое присоединение к потоку]] 3.2.1
	2. [[#Прерывание по запросу в классе std jthread|Прерывание по запросу в классе std::jthread]] 3.2.2
	3. [[#Особенности класса std jthread]] 3.6.5
3. [[#std scoped_thread|std::scoped_thread]]
4. [[#Запуск потока|Запуск потока]] 2.1.1 (multithread)
5. [[#Ожидание завершения потока|Ожидание завершения потока]] 2.1.2 (multithread)
6. [[#Ожидание в исключительных обстоятельствах|Ожидание в исключительных обстоятельствах]] 2.1.3 (multithread)
7. [[#Запуск потоков в фоновом режиме|Запуск потоков в фоновом режиме]] 2.1.4 (multithread)
8. [[#Передача аргументов функции потока|Передача аргументов функции потока]] 2.2 (multithread)

# std::thread

Класс `std::thread` служит обёрткой для потока – независимой единицы выполнения в составе программы. Выполняемая единица запускается сразу после своего создания, для этого она должна получить на вход вызываемый объект, который и задаёт, что должно быть сделано в потоке. Вызываемый объект может быть именованной функцией, функциональным объектом или лямбда-функцией.

Код, который создаёт поток, отвечает за его дальнейшую судьбу. Единица выполнения, работающая в потоке, завершается с окончанием работы своего вызываемого объекта. Создатель потока может либо присоединить поток, т.е. подождать его завершения посредством вызова `join`, либо отсоединиться от потока, вызвав функцию `detach`. Поток `t` находится в присоединяемом состоянии, если над ним не выполнялась ни одна из операций `join` и `detach`. Если в момент вызова деструктора объект-поток находится в присоединяемом состоянии, деструктор вызывает функцию `std::terminate`, которая приводит к аварийному завершению программы.

Поток, отсоединённый от своего создателя, часто называют потоком-демоном, поскольку он выполняется в фоновом режиме.

Под именем `std::thread` скрывается шаблон класса с переменным числом параметров. Это означает, что при создании потока можно передавать любое число аргументов, так как разное число аргументов могут принимать выполняющиеся в потоке вызываемые объекты.

Библиотека `std::thread` предоставляет стандартный способ управления потоками.
```c++
void foo(bool clause) { 
	/* do something... */ 
} 

std::vector<std::thread> threadsVector; 
threadsVector.emplace_back([]() { 
	// Лямбда-функция, которая будет вызвана 
}); 

threadsVector.emplace_back(foo, true); // поток запустит foo(true) 

for (auto& thread : threadsVector) 
	thread.join(); // ожидание окончания работы потоков
```

# Базовые потоки: класс std::thread

Чтобы создать поток в программе на языке C++, нужно подключить заголовочный файл `<thread>`.

## Создание потока

Объект типа `std::thread` представляет единицу выполнения программы. То, что должно быть выполнено в потоке, передаётся объекту `std::thread` при его создании в виде вызываемого объекта.

Вызываемый объект ведёт себя подобно функции. Конечно, он может быть в том числе и функцией, но также может быть функциональным объектом или лямбда-функцией. Значение, возвращаемое вызываемым объектом, игнорируется.

Сделав эти вводные замечания, можно рассмотреть пример.

Создание потоков с различными вызываемыми объектами:
```c++
// createThread.cpp

#include <iostream>
#include <thread>

void helloFunction(){
	std::cout << “Hello from a function.” << std::endl;
}

class HelloFunctionObject{
	public:
		void operator()() const {
			std::cout << “Hello from a function object.” << std::endl;
		}
};

int main(){
	std::cout << std::endl;
	
	std::thread t1(helloFunction);
	
	HelloFunctionObject helloFunctionObject;

	std::thread t2(helloFunctionObject);
	std::thread t3([]{std::cout << “Hello from a lambda.” << std::endl;});

	t1.join();
	t2.join();
	t3.join();
	
	std::cout << std::endl;
};
```

Все три потока, `t1`, `t2` и `t3`, печатают сообщения на консоль. При этом в потоке `t1` выполняется обычная функция, в потоке `t2` выполняется функциональный объект (класс), а в потоке `t2` – лямбда-функция. В строках `t1.join()` – `t3.join()` главный поток ожидает завершения всех дочерних потоков.

Посмотрим, как работает эта программа. Результаты её запуска довольно интересны.

![[ParallelProg_49.png]]

Три потока могут выполняться в произвольном порядке. Даже тексты, выводимые из разных потоков, могут перемешиваться между собой.

В этом примере главный поток, создающий дочерние потоки, отвечает за время жизни этих объектов.

## Время жизни потоков

Родители должны заботиться о своих детях. Из этого простого принципа вытекают далекоидущие следствия касательно времени жизни потоков. Рассмотрим пример: следующая программа должна запускать поток и выводить его идентификатор.

Забытое ожидание завершения потока:
```c++
// threadWithoutJoin.cpp

#include <iostream>
#include <thread>

int main(){
	std::thread t([]{std::cout << std::this_thread::get_id() << std::endl;});
}
```

Однако программа этого не делает.
![[ParallelProg_50.png]]

### Функции join и detach

Жизнь потока `t` завершается с окончанием выполнения его вызываемого объекта. У создателя потока есть на выбор два варианта:

* подождать завершения дочернего потока с помощью вызова `t.join()`;
* оборвать связь с дочерним потоком с помощью вызова `t.detach()`.

Вызов `t.join()` полезен в случаях, когда последующий код каким-то образом зависит от результатов работы дочернего потока. Вызов `t.detach()` позволяет дочернему потоку выполняться независимо от объекта `t`. Это значит, что поток, отсоединённый от объекта, будет выполняться до тех пор, пока не завершится выполняющийся в нём код. Чаще всего отсоединяют потоки, в которых выполняется долгая фоновая работа, например потоки-серверы.

Объект-поток с завёрнутым в него вызываемым объектом (объекты типа `std::thread` можно создавать и пустыми, без вызываемых объектов) называется присоединяемым (англ. joinable), если для него не вызывалась ни одна из функций-членов `join` и `detach`. Деструктор объекта-потока в присоединяемом состоянии вызывает аварийное завершение программы посредством [[terminate|std::terminate]]. Именно в этом причина аварийного завершения программы `threadWithoutJoin.cpp`. Если применить функцию `join` или `detach` к объекту, для которого какая-либо из этих функций-членов уже была вызвана ранее, произойдёт исключение типа `std::system_error`.

Исправить предыдущую программу довольно легко – для объекта-потока `t` вызвать функцию-член `join`.

```c++
// threadWithoutJoin.cpp

#include <iostream>
#include <thread>

int main(){
	std::thread t([]{std::cout << std::this_thread::get_id() << std::endl;});
	
	t.join();
}
```

Теперь программа работает так, как ожидалось.

Число, которое программа выводит на печать, – это уникальный идентификатор потока в системе.

> **Трудность с функцией `detach`**
> 
> Конечно же, в последней программе вместо функции `join` можно было бы применить функцию `detach`. Объект-поток `t` перешёл бы в неприсоединяемое состояние, и его деструктор не стал бы аварийно завершать программу. Но в этом случае возникло бы иное затруднение. Поведение такой программы не определено, поскольку главный поток может завершиться раньше дочернего, и тогда последнему просто не останется времени, чтобы вывести на печать свой результат.

> **Класс `scoped_thread` Энтони Уильямса**
> 
>Если своими руками управлять временем жизни потоков слишком обременительно, можно инкапсулировать класс `std::thread` в собственный класс-обёртку. Деструктор этого класса должен автоматически вызывать функцию `join` потока, если тот всё ещё находится в присоединяемом состоянии. Конечно, можно поступить и противоположным образом, автоматически вызывая для потока функцию `detach` – однако это может быть сопряжено с определёнными трудностями.
>
> Энтони Уильямс создал такой полезный класс и описал его в своей превосходной книге «Параллельное программирование на C++ в действии». Класс-обёртку он назвал `scoped_thread`. Конструктор этого класса принимает в качестве аргумента поток `t` и проверяет, находится ли он попрежнему в присоединяемом состоянии. Если поток-аргумент `t` не поддерживает присоединение, нет и необходимости в классе `scoped_thread`. Если же поток `t` можно присоединить, деструктор класса вызывает `t.join()`. Поскольку конструктор копирования и копирующая операция присваивания в явном виде удалены, экземпляры класса `scoped_thread` не могут копироваться никаким способом.

```c++
// scoped_thread.cpp
#include <iostream>
#include <thread>
#include <utility>

class scoped_thread{
		std::thread t;
	
	public:
		explicit scoped_thread(std::thread t_): t(std::move(t_)){
			if (!t.joinable()) throw std::logic_error(“No thread”);
		}
		
		~scoped_thread(){
			t.join();
		}
		
	scoped_thread(scoped_thread&)= delete;
	scoped_thread& operator=(scoped_thread const &)= delete;
};
```

## Передача аргументов при создании потока

Вызываемый объект, выполняющийся в потоке (в частности, обычная функция), может получать свои аргументы посредством копирования значения, по перемещению или по ссылке. Класс `std::thread` представляет собой шаблон с переменным числом аргументов, или, как их ещё называют, вариадический шаблон.

Если поток получает на вход данные по ссылке, нужно быть чрезвычайно осторожным в том, что касается времени жизни передаваемых объектов и совместного доступа к данным.

### Передача по значению и по ссылке

Рассмотрим следующий небольшой фрагмент кода:

```C++
std::string s{“C++11”}

std::thread t1([=]{ std::cout << s << std::endl; });
t1.join();

std::thread t2([&]{ std::cout << s << std::endl; });
t2.detach();
```

Поток `t1` получает данные по значению (т. е. путём создания копии), а поток `t2` – по ссылке.

> **Передача аргументов в поток по ссылке**
> 
> По правде говоря, в этом примере допущено некоторое упрощение. Там сказано, что поток `t2` получает аргумент по ссылке, однако на самом деле это лямбда-функция захватывает ссылку на локальные данные. Чтобы передать по ссылке аргумент в функцию потока, нужно завернуть его в класс-обёртку ссылок. Это просто сделать, воспользовавшись вспомогательной функцией `std::ref`, определённой в заголовочном файле `<functional>`. Например:
```c++
void transferMoney(int amount, Account& from, Account& to){
	...
}

...

std::thread thr1(transferMoney, 50, std::ref(account1),
				 std::ref(account2));
```

> Здесь поток `thr1` выполняет функцию `transferMoney`, которая получает аргументы по ссылке. Благодаря использованию функции `std::ref` в функцию будут переданы ссылки на объекты `account1` и `account2`.

Какие тонкости могут таиться в этих строчках кода? Поток `t2` получает строку `s` по ссылке, а затем отсоединяется от родительского потока. Время жизни строки `s` ограничено временем выполнения объемлющей функции. Время жизни глобального объекта `std::cout` ограничивается только временем выполнения главного потока программы. Поэтому время жизни объектов `s` и `std::cout` может оказаться короче, чем время выполнения потока `t2`. Таким образом мы оказываемся по уши в неопределённом поведении.

Передача в поток аргументов по ссылке:
```c++
// threadArguments.cpp

#include <chrono>
#include <iostream>
#include <thread>

class Sleeper{
	public:
		Sleeper(int& i_):i{i_}{};

		void operator() (int k){
			for (unsigned int j= 0; j <= 5; ++j){
				std::this_thread::sleep_for(
									std::chrono::milliseconds(100));
				i += k;
			}
		}
		
	private:
		int& i;
};

int main(){
	std::cout << std::endl;

	int valSleeper = 1000;
	std::thread t(Sleeper(valSleeper), 5);
	t.detach();
	
	std::cout << “valSleeper = “ << valSleeper << std::endl;
	
	std::cout << std::endl;
}
```

Какое значение имеет переменная `valSleeper` в строке `std::cout << “valSleeper = “ << valSleeper << std::endl`? Переменная `valSleeper` живёт, пока выполняется функция `main`. Поток `t` получает для работы функциональный объект, в который завёрнута ссылка на переменную `valSleeper`, и число 5. Главное в этом примере то, что поток `t` получает переменную `valSleeper` по ссылке (`Sleeper(int& i_):i{i_}{}`) и отсоединяется от главного потока (строка `t.detach()`). В дочернем потоке выполняется перегруженная операция вызова функционального объекта (`void operator() (int k)`). В этой функции цикл увеличивает счётчик от 0 до 5 включительно, на каждой итерации ждёт 1/10 секунды и увеличивает переменную `i` на величину `k`. В конце дочерний поток должен напечатать свой идентификатор. Считая, как говорят в Германии, «по Адаму Ризе», результат должен составлять
```
1000 + 6 * 5 = 1030
```

Однако как же программа работает на самом деле? Что-то в ней идёт не так.

![[ParallelProg_52.png]]

Программа обнаруживает два странных свойства. Во-первых, значение переменной `valSleeper` в конце оказывается равным `1000`, а во-вторых, идентификатор дочернего потока на печать не выводится. Программа страдает по меньшей мере двумя изъянами.

4. Разные потоки имеют ничем не ограниченный доступ к переменной `valSleeper`. Здесь имеет место гонка данных, поскольку потоки могут одновременно производить чтение и запись этой переменной.
5. Время жизни главного потока завершается раньше, чем дочерний поток успевает выполнить все свои вычисления и вывести свой идентификатор в поток `std::cout`.

Оба названных обстоятельства переводят программу в состояние гонки, поскольку результат работы программы зависит от относительной скорости выполнения операций в разных потоках. Состояние гонок выступает причиной гонки данных.

Исправить гонку данных довольно просто. Для этого достаточно защитить переменную `valSleeper` мьютексом или сделать её атомарной. Что-бы преодолеть ошибку, связанную со временем жизни объектов `valSleeper` и `std::cout`, нужно не отсоединять дочерний поток, а, напротив, присоединить его выполнение (функция `join`). Ниже представлена исправленная функция `main`.
```c++
int main(){
	std::cout << std::endl;

	int valSleeper= 1000;
	std::thread t(Sleeper(valSleeper),5);
	t.join();
	
	std::cout << “valSleeper = “ << valSleeper << std::endl;
	
	std::cout << std::endl;
}
```

Теперь программа выдаёт правильный результат, хотя, конечно, и выполняется медленнее.

![[ParallelProg_53.png]]

## Перечень функций-членов

Интерфейс класса `std::thread` показан ниже в виде таблицы. Более подробные сведения можно найти на сайте cppreference.com.

**Функции-члены класса `std::thread`**

| **Функция**                             | **Описание**                                                          |
| --------------------------------------- | --------------------------------------------------------------------- |
| `join`                                  | Ждать завершения потока                                               |
| `detach`                                | Разорвать связь с потоком и оставить его выполняться независимо       |
| `joinable`                              | Узнать, находится ли поток в присоединяемом состоянии                 |
| `get_id`,<br>`std::this_thread::get_id` | Узнать идентификатор потока                                           |
| `hardware_concurrency`                  | Узнать, сколько потоков может выполняться параллельно                 |
| `std::this_thread::sleep_until`         | Погрузить поток в сон до определённого абсолютного момента времени    |
| `std::this_thread::sleep_for`           | Погрузить поток в сон на заданное время относительно текущего момента |
| `std::this_thread::yield`               | Уступить выполнение другому потоку                                    |
| `t1.swap(t2)`<br>`std::swap(t1, t2)`    | Обменять местами два объекта                                          |

> **Доступ к системно-зависимой реализации**
> 
> Классы из стандартной библиотеки представляют собой обёртку над реализацией потоков в конкретной платформе. Для доступа к системному дескриптору потока можно воспользоваться функцией `native_handle`. Такие системные дескрипторы можно получать для потоков, [[mutex|мьютексов]] и переменных условия.

Объекты класса `std::thread` нельзя копировать, но можно перемещать. Функция `swap` обменивает местами содержимое двух объектов, пользуясь для этого перемещением.

**Функции-члены класса `std::thread`**
```c++
// threadMethods.cpp

#include <iostream>
#include <thread>
using namespace std;

int main(){
	cout << boolalpha << endl;

	cout << “hardware_concurrency()= “
						<< thread::hardware_concurrency() << endl;

	thread t1([]{cout << “t1 with id= “ << this_thread::get_id() 
														<< endl;});
	thread t2([]{cout << “t2 with id= “ << this_thread::get_id() 
														<< endl;});

	cout << endl;
	
	cout << “FROM MAIN: id of t1 “ << t1.get_id() << endl;
	cout << “FROM MAIN: id of t2 “ << t2.get_id() << endl;

	cout << endl;

	swap(t1,t2);

	cout << “FROM MAIN: id of t1 “ << t1.get_id() << endl;
	cout << “FROM MAIN: id of t2 “ << t2.get_id() << endl;
	
	cout << endl;
	
	cout << “FROM MAIN: id of main= “ << this_thread::get_id() << endl;

	cout << endl;

	cout << “t1.joinable(): “ << t1.joinable() << endl;

	cout << endl;

	t1.join();
	t2.join();
	
	cout << endl;
	
	cout << “t1.joinable(): “ << t1.joinable() << endl;
	
	cout << endl;
}
```

результат её работы:
![[ParallelProg_54.png]]

Может показаться странным, что потоки `t1` и `t2` (строки `thread t1([]{cout << “t1 with id= “ << this_thread::get_id() << endl;})` и `thread t2([]{cout << “t2 with id= “ << this_thread::get_id() << endl;})`) отрабатывают в столь различные моменты времени. Однако это нормально: у программиста нет никаких гарантий относительно того, когда и с какой скоростью выполняются потоки. С уверенностью можно сказать лишь, что выполнение потоков завершится к моменту завершения функции `join`, вызванной в строках `t1.join()` и `t2.join()`.

Управление параллельными потоками тем труднее, чем больше изменяемых (т. е. неконстантных) данных находится у них в общем доступе.

# std::jthread

Название `jthread` означает «присоединяемый» (англ. joinable) поток. В дополнение ко всему, что умеет делать класс [[thread#std thread|std::thread]], введённый в стандарте C++11, этот класс ожидает завершения потока в деструкторе и поддерживает кооперативное прерывание. Тем самым класс `std::jthread` расширяет интерфейс класса [[thread#std thread|std::thread]].

В следующей таблице представлен обзор функциональных возможностей, добавленных в классе `std::jthread`.

**Дополнительные функции-члены класса `std::jthread`:**

| **Имя**           | **Описание**                                                             |
| ----------------- | ------------------------------------------------------------------------ |
| `get_stop_source` | Возвращает объект типа `std::stop_source`, связанный с флагом завершения |
| `get_stop_token`  | Возвращает объект типа `std::stop_token`, связанный с флагом завершения  |
| `request_stop`    | Запрашивает завершение выполнения через флаг                             |

## Автоматическое присоединение к потоку

Поведение класса [[#std thread|std::thread]] противоречит ожиданиям: если на момент вызова деструктора поток находится в присоединяемом состоянии, выполнение всей программы аварийно завершается вызовом [[terminate|std::terminate]]. Напомним, что поток находится в присоединяемом состоянии, если он был запущен и для него не вызывалась ни одна из функций `join` или `detach`.

**Аварийно завершающаяся программа с присоединяемым потоком:**
```c++
// threadJoinable.cpp

#include <iostream>
#include <thread>

int main() {
	std::cout << std::endl;
	std::cout << std::boolalpha;
	
	std::thread thr{[]{ std::cout << “Joinable std::thread” 
												<< std::endl; }};
	std::cout << “thr.joinable(): “ << thr.joinable() 
												<< std::endl;
	
	std::cout << std::endl;
}
```

Если эту программу запустить, она завершится с ошибкой.

![[ParallelProg_55.png]]

Оба запуска программы завершаются с ошибкой. При этом во второй раз у потока `thr` оказывается вдоволь времени, чтобы вывести своё сообщение: `«Joinable std::thread»`.

Следующий код во всём подобен предыдущему, за исключением замены класса [[#std thread|std::thread]] классом `std::jthread` из стандарта C++ 20.

**Завершение потока `std::jthread` в присоединяемом состоянии:**
```c++
// jthreadJoinable.cpp

#include <iostream>
#include <thread>

int main() {
	std::cout << std::endl;
	std::cout << std::boolalpha;

	std::jthread thr{[]{ std::cout << “Joinable std::jthread” 
												<< std::endl; }};

	std::cout << “thr.joinable(): “ << thr.joinable() << std::endl;
	std::cout << std::endl;
}
```

Теперь выполнение дочернего потока автоматически присоединяется к главному потоку при деструкции объекта `thr`, поскольку в момент выхода за область видимости он всё ещё находится в присоединяемом состоянии.

Ниже показано, как мог бы быть реализован деструктор класса `std::jthread`.

**Деструктор класса std::jthread:**
```c++
jthread::~jthread() {
	if(joinable()) {
		request_stop();
		join();
	}
}
```

В первую очередь деструктор проверяет, по-прежнему ли поток допускает присоединение (строка `if(joinable())`). Поток находится в присоединяемом состоянии, если он был запущен и для него не вызывалась ни одна из функций `join` или `detach`. Если присоединение имеет смысл, деструктор запрашивает завершение потока (строка `request_stop()`) и затем вызывает функцию `join`. Этот вызов блокирует вызывающий поток до тех пор, пока не закончится выполнение дочернего потока.

## Прерывание по запросу в классе std::jthread

Чтобы проиллюстрировать основную идею, начнём с простого примера.

**Прерываемый и непрерываемый потоки:**
```c++
// interruptJthread.cpp

#include <chrono>
#include <iostream>
#include <thread>

using namespace::std::literals;

int main() {
	std::cout << ‘\n’;
	
	std::jthread nonInterruptable([]{
		int counter{0};
		while (counter < 10){
			std::this_thread::sleep_for(0.2s);
			std::cerr << “nonInterruptable: “ << counter << ‘\n’;
			++counter;
		}
	});
	
	std::jthread interruptable([](std::stop_token stoken){
		int counter{0};
		while (counter < 10){
			std::this_thread::sleep_for(0.2s);
			if (stoken.stop_requested()) return;
			std::cerr << “interruptable: “ << counter << ‘\n’;
			++counter;
		}
	});
	
	std::this_thread::sleep_for(1s);

	std::cerr << ‘\n’;
	std::cerr << “Main thread interrupts both jthreads” << ‘\n’;
	
	nonInterruptable.request_stop();
	interruptable.request_stop();
	
	std::cout << ‘\n’;
}
```

В главном потоке запускаются два дочерних потока: `nonInterruptible` (с англ. «непрерываемый») в строке `std::jthread nonInterruptable([]{` и `interruptible` (соотв. «прерываемый») в строке `std::jthread interruptable([](std::stop_token stoken){`. В отличие от непрерываемого потока, прерываемый получает объект `std::stop_token` (флаг завершения) и использует его в строке `if (stoken.stop_requested()) return;` для проверки того, не запросил ли кто-либо завершение потока (для этого служит функция-член `stop_requested`). Если завершение запрошено, [[Lambda|лямбда-функция]] возвращает управление, и тем самым завершается работа потока.

Вызов функции `request_stop` в строке `interruptable.request_stop();` запрашивает завершение потока. Однако на первый поток `nonInterruptible` этот запрос не действует: поток просто не реагирует на него.

![[ParallelProg_56.png]]

## Особенности класса std::jthread

Класс [[#std jthread|std::jthread]] представляет собой почти что копию класса [[#std thread|std::thread]] с дополнительными возможностями: кооперативным прерыванием и автоматическим присоединением. Для поддержки обеих этих возможностей поток [[#std thread|std::thread]] обладает встроенным объектом [[Кооперативное прерывание потоков#Класс std stop_token|std::stop_token]].

| **Функция**       | **Описание**                                                                                                                         |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `get_stop_source` | Возвращает объект типа [[Кооперативное прерывание потоков#Класс std stop_source\|std::stop_source]], связанный с состоянием останова |
| `get_stop_token`  | Возвращает объект типа [[Кооперативное прерывание потоков#Класс std stop_token\|std::stop_token]], связанный с состоянием останова   |
| `request_stop`    | Запрашивает останов потока через состояние останова                                                                                  |

# std::scoped_thread
#std_scoped_thread

# Запуск потока

В [[Практика многопоточного программирования|Здравствуй, мир конкурентности C++]] было показано, что потоки запускаются созданием объекта [[thread#std thread|std::thread]], в котором определяется выполняемая в потоке задача. В простейшем случае эта задача представляет собой обычную функцию, которая возвращает `void-значение`, и не принимает никаких параметров. Эта функция выполняется в собственном потоке, пока не вернет управление, после чего поток останавливается. В иных случаях задача может быть функциональным объектом, принимающим дополнительные параметры и выполняющим ряд независимых операций, которые задаются посредством некоей системы обмена сообщениями в ходе его выполнения. Поток останавливается только при получении соответствующего сигнала, опять же через некую систему сообщений. Что бы ни собирался делать поток и откуда бы он ни запускался, его запуск с использованием стандартной библиотеки C++ всегда сводится к созданию объекта [[thread#std thread|std::thread]]:
```c++
void do_some_work();
std::thread my_thread(do_some_work);
```

Проще, наверное, и быть не может. Конечно, чтобы компилятор мог видеть определение класса [[thread#std thread|std::thread]], нужно убедиться, что в программу включен заголовок `<thread>`. Как и основная часть содержимого стандартной библиотеки C++, [[thread#std thread|std::thread]] работает с любым вызываемым типом, поэтому конструктору [[thread#std thread|std::thread]] можно также передать экземпляр класса с оператором вызова функции:
```c++
class background_task
{
	public:
		void operator()() const
		{
			do_something();
			do_something_else();
		}
};

background_task f;
std::thread my_thread(f);
```

В данном случае предоставленный функциональный объект копируется в хранилище, принадлежащее вновь созданному потоку выполнения, и вызывается оттуда. Поэтому важно, чтобы копия действовала аналогично оригиналу, иначе результат может не соответствовать ожидаемому.

При передаче функционального объекта в конструктор потока следует избегать так называемого самого неприятного случая синтаксического анализа C++. Если передается временная, а не именованная переменная, синтаксис может быть таким же, как и при объявлении функции. В этом случае компилятор интерпретирует его именно таким образом, а не как определение объекта. Например, код:
```c++
std::thread my_thread(background_task());
```

объявляет функцию `my_thread`, принимающую единственный параметр наподобие указателя на функцию, не принимающую параметры и возвращающую объект фоновой задачи `background_task`, и вместо запуска нового потока возвращает объект [[thread#std thread|std::thread]]. Такого развития событий можно избежать, присвоив функциональному объекту имя, как было показано ранее, с помощью дополнительных скобок или нового унифицированного синтаксиса инициализации, например:
```c++
std::thread my_thread((background_task()));
std::thread my_thread{background_task()};
```

В первом примере дополнительные скобки не позволяют интерпретировать код как объявление функции, разрешая объявить `my_thread` переменной типа [[thread#std thread|std::thread]]. Во втором примере используется новый унифицированный синтаксис инициализации с фигурными, а не круглыми скобками, также позволяющий объявить переменную.

Одним из типов вызываемого объекта, позволяющего избегать возникновения рассматриваемой проблемы, является лямбда-выражение. Эта новая особенность, появившаяся в стандарте C++11, допускает создание локальной функции с возможным захватом некоторых локальных переменных, избавляя от необходимости передачи дополнительных аргументов (см. #раздел_2_2). Более подробно лямбда-выражения рассматриваются в #разделе_A_5. С помощью лямбда-выражения предыдущий пример можно записать следующим образом:
```c++
std::thread my_thread([]{
	do_something();
	do_something_else();
});
```

Научившись запускать поток, нужно принять однозначное решение, ждать ли его завершения (присоединив его — см. #подраздел_2_1_2) или пустить его на самотек (путем его отсоединения — см. #подраздел_2_1_3). Если не принять решение до уничтожения объекта [[thread#std thread|std::thread]], то программа завершится (деструктор [[thread#std thread|std::thread]] вызовет метод [[terminate|std::terminate()]]). Поэтому даже при выдаче исключений необходимо убедиться, что поток правильно присоединен или отсоединен. Методы, позволяющие справиться с таким сценарием, рассмотрены в #подразделе_2_1_3. Учтите, что решение нужно принимать до того, как объект std::thread будет уничтожен. Сам же поток вполне мог бы завершиться задолго до его присоединения или отсоединения. Если его отсоединить, то при условии, что он все еще выполняется, он и будет выполняться, и этот процесс может продолжаться еще долго и после уничтожения объекта [[thread#std thread|std::thread]]. Выполнение будет прекращено, только когда в конце концов произойдет возвращение из функции потока.

Если не дожидаться завершения потока, необходимо убедиться, что данные, к которым он обращается, будут действительны, пока он не закончит работать с ними. Эта проблема не отличается новизной — даже в однопоточном коде поведение приложения при доступе к объекту после его уничтожения характеризуется неопределенностью, но при использовании потоков вероятность столкнуться с подобными проблемами времени жизни объектов возрастает.

К примеру, похожие проблемы могут возникнуть, если функция потока содержит указатели или ссылки на локальные переменные, а поток при выходе из функции не завершается. Пример такого сценария:
![[practice_multithreaded-5.png]]
Функция, возвращающая управление, в то время как в потоке сохраняется обращение к локальным переменным

В данном случае новый поток, связанный с `my_thread`, при выходе из `oops`, вероятно, все еще будет выполняться, поскольку, судя по вызову `detach()`, было принято решение не дожидаться его завершения. Если поток все еще выполняется, все идет по сценарию, показанному в табл. 2.1: следующий вызов `do_something(i)` будет обращаться к уже уничтоженной переменной. Все это похоже на обычный однопоточный код, в котором сохранять указатель или ссылку на локальную переменную после выхода из функции непозволительно, но вероятность допустить такую ошибку при использовании многопоточного кода значительно выше, поскольку ее негативные проявления видны не сразу.

Таблица 2.1. Обращение к локальной переменной в отсоединенном потоке после того, как она была уничтожена

| Основной поток                                         | Новый поток                                                                                                                           |
| ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| Создание `my_func` со ссылкой<br>на `some_local_state` |                                                                                                                                       |
| Запуск нового потока `my_thread`                       | Запуск<br>Вызов `func::operator()`                                                                                                    |
| Отсоединение `my_thread`                               | Запуск `func::operator()`; возможен<br>вызов do_something со ссылкой на `some_local_state`                                            |
| Уничтожение `some_local_state`                         | Продолжение выполнения                                                                                                                |
| Выход из `oops`                                        | Продолжение выполнения `func::operator()`; возможен вызов `do_something` со ссылкой на `some_local_state =>` неопределенное поведение |

Справиться с подобным сценарием можно одним из распространенных способов: сделать функцию потока автономной и вместо разделения данных скопировать их в поток. При использовании вызываемого объекта для функции потока этот объект копируется в поток, поэтому исходный объект можно тут же уничтожить. Тем не менее следует опасаться объектов, содержащих указатели или ссылки, как, к примеру, выше. В частности, не рекомендуется создавать внутри функции поток, имеющий доступ к ее локальным переменным, если только не будет обеспечено завершение потока до выхода из этой функции. Или же, присоединив поток до выхода из функции, можно убедиться в завершении его выполнения.

# Ожидание завершения потока

Дождаться завершения потока можно, вызвав [[thread#Функции join и detach|join()]] для связанного экземпляра [[thread#std thread|std::thread]]. Что касается кода выше, то замены вызова `my_thread.detach()` перед закрывающей фигурной скобкой тела функции вызовом `my_thread.join()` было бы достаточно, чтобы гарантировать завершение потока до выхода из функции и, следовательно, до уничтожения локальных переменных. В данном случае это означало бы, что запускать функцию в отдельном потоке нет смысла, поскольку первый поток во время ожидания не будет выполнять никакой полезной работы. Но в реальном коде исходный поток будет либо выполнять полезную работу, либо запускать несколько потоков для выполнения полезной работы, прежде чем входить в режим ожидания их завершения.

Применение метода [[thread#Функции join и detach|join()]] — простой и незамысловатый прием: либо вы ждете завершения потока, либо нет. Если нужен более утонченный контроль над ожиданием потока, допустим, с проверкой завершения потока или ожиданием в течение строго определенного времени, придется воспользоваться альтернативными механизмами, например условными переменными и [[future|фьючерсами]], которые будут рассматриваться в #главе_4. Вызов [[thread#Функции join и detach|join()]] также приводит к очистке любого хранилища, связанного с потоком, поэтому объект [[thread#std thread|std::thread]] больше не связан с завершенным потоком. Мало того, он не связан ни с одним потоком. Это означает, что [[thread#Функции join и detach|join()]] можно вызвать для конкретного потока только один раз: как только вызван метод [[thread#Функции join и detach|join()]], объект [[thread#std thread|std::thread]] утрачивает возможность присоединения, а метод `joinable()` вернет значение `false`.

## Ожидание в исключительных обстоятельствах

Как упоминалось ранее, следует убедиться, что вызов [[thread#Функции join и detach|либо join(), либо detach()]] был выполнен еще до уничтожения объекта [[thread#std thread|std::thread]]. При отсоединении потока метод [[thread#Функции join и detach|detach()]] можно вызвать сразу же после запуска этого потока, так что это не проблема. Но если есть намерение дожидаться завершения потока, то место в коде, где будет выполнен вызов метода [[thread#Функции join и detach|join()]], нужно выбирать с особой тщательностью, поскольку при выдаче исключения после запуска потока, но до вызова [[thread#Функции join и detach|join()]] вызов этого метода можно пропустить.

Чтобы избежать завершения приложения при выдаче исключения, необходимо решить, что делать в таком случае. Вообще, если вы намеревались вызвать [[thread#Функции join и detach|join()]] при нормальном выполнении программы, вам, чтобы избежать проблем, связанных с временем жизни, необходимо вызвать [[thread#Функции join и detach|join()]] и при выдаче исключения. Простой код, выполняющий именно такие действия, показан ниже.
![[practice_multithreaded-6.png]]
**Листинг 2.2.** Ожидание завершения потока.

Код в листинге 2.2 содержит блок [[try|try-catch]], позволяющий гарантировать, что поток с доступом к локальному состоянию завершится до выхода из функции независимо от того, завершается ли функция нормально или из-за выдачи исключения. Использование блоков [[try|try-catch]] растягивает код, повышая вероятность получения неправильной области видимости, поэтому данный сценарий далек от идеала. Если есть веские причины обеспечить завершение потока до выхода из функции, скажем, из-за наличия ссылки на другие локальные переменные или чего-нибудь еще, важно убедиться, что учтены все возможные пути выхода, как нормальные, так и исключительные, и желательно обеспечить для этого простой и лаконичный механизм.

Кроме иных способов, это можно сделать с использованием стандартного способа `RAII` и, как показано в `листинге 2.3`, предоставить класс, выполняющий метод [[thread#Функции join и detach|join()]] в своем деструкторе. Посмотрите, насколько при этом упрощается функция `f()`.
```c++
class thread_guard
{
	    std::thread& t;
	public:
	    explicit thread_guard(std::thread& t_)
		    :t(t_)
	    {}
	    
	    ~thread_guard()
	    {
	        if (t.joinable())
	        {
	            t.join();
	        }
	    }
	    
	    thread_guard(thread_guard const&) = delete;
	    thread_guard& operator=(thread_guard const&) = delete;
};

struct func; // см. определение в листинге 2.1
void f()
{
    int some_local_state = 0;
    func my_func(some_local_state);
    std::thread t(my_func);
    thread_guard g(t);
    do_something_in_current_thread();
}
```
листинг 2.3. Использование `RAII` для ожидания завершения потока

Когда выполнение текущего потока достигает конца функции `f`, локальные объекты уничтожаются в порядке, обратном порядку их построения. Следовательно, сначала уничтожается объект `g` типа `thread_guard`, а в его деструкторе происходит присоединение к потоку. Это наблюдается даже при завершении выполнения функции, поскольку `do_something_in_current_thread` выдает исключение.

Перед вызовом метода [[thread#Функции join и detach|join()]] деструктор `thread_guard` в листинге 2.3 сначала
проверяет с помощью метода `joinable()`, является ли объект [[thread#std thread|std::thread]] присоединяемым. Важность этого действия обусловливается тем, что метод [[thread#Функции join и detach|join()]] для конкретного потока выполнения можно вызвать только один раз, поэтому, если поток уже был присоединен, его вызов станет ошибкой.

Копирующий конструктор и операторы копирующего присваивания помечают спецификатором `=delete`, чтобы запретить компилятору автоматически предоставлять их. Копирование или присваивание такого объекта было бы опасным, поскольку тогда время его жизни могло бы превысить время жизни присоединяемого потока. При объявлении их удаленными любая попытка скопировать объект `thread_guard` будет приводить к выдаче ошибки компиляции. Более подробно удаленные функции рассматриваются в #разделе_A_2.

Если ждать завершения потока не нужно, проблемы безопасности исключений можно избежать, отсоединив этот поток. Тем самым разрывается его связь с объектом [[thread#std thread|std::thread]] и гарантируется, что метод [[terminate|std::terminate()]] не будет вызван при удалении объекта [[thread#std thread|std::thread]], даже если поток все еще выполняется в фоновом режиме.

## Запуск потоков в фоновом режиме

Вызов метода [[thread#Функции join и detach|detach()]] для объекта [[thread#std thread|std::thread]] позволяет потоку выполняться в фоновом режиме, непосредственное взаимодействие с ним не требуется. Возможность дождаться завершения этого потока исчезает: если поток отсоединяется, получить ссылающийся на него объект [[thread#std thread|std::thread]] невозможно, поэтому такой поток больше нельзя присоединить. Отсоединенные потоки фактически выполняются в фоновом режиме, владение и управление ими передаются в библиотеку среды выполнения C++, которая гарантирует правильное высвобождение ресурсов, связанных с потоком, при выходе из него.

Отсоединенные потоки часто называются потоками-демонами по аналогии с существующей в `UNIX` концепцией процесса-демона, который выполняется в фоновом режиме без какого-либо явного пользовательского интерфейса. Как правило, такие потоки являются весьма продолжительными, работая в течение практически всего времени жизни приложения и выполняя фоновую задачу, например отслеживая состояние файловой системы, удаляя неиспользуемые записи из кэш-памяти объектов или оптимизируя структуры данных. В то же время есть смысл использовать отсоединенный поток, если существует иной механизм определения факта завершения потока или когда нужно запустить задачу и «забыть» о ней.

Как было показано в [[thread#Ожидание завершения потока|Ожидание завершения потока]], поток отсоединяется путем вызова для объекта [[thread#std thread|std::thread]] компонентной функции [[thread#Функции join и detach|detach()]]. После завершения вызова объект [[thread#std thread|std::thread]] больше не связан с фактическим потоком выполнения, поэтому данный поток больше нельзя присоединить:
```c++
std::thread t(do_background_work);
t.detach();
assert(!t.joinable());
```

Чтобы отсоединить поток от объекта [[thread#std thread|std::thread]], должен существовать отсоединяемый поток: метод [[thread#Функции join и detach|detach()]] нельзя вызывать для объекта [[thread#std thread|std::thread]], не имеющего связанного с ним потока выполнения. Это требование аналогично тому, которое предъявляется к вызову метода [[thread#Функции join и detach|join()]], и проверку можно провести точно таким же образом — вызывать для объекта `t` типа [[thread#std thread|std::thread]] метод `t.detach()` возможно, только если метод `t.joinable()` вернет значение `true`.

Рассмотрим приложение, к примеру текстовый процессор, позволяющий одновременно редактировать несколько документов. Есть множество способов справиться с такой задачей как на уровне пользовательского интерфейса, так и на уровне внутренних механизмов. Один из них, получающий сейчас все более широкое распространение, — использование нескольких независимых окон верхнего уровня, по одному для каждого редактируемого документа. Хотя эти окна представляются полностью независимыми и каждое имеет собственные меню, они работают в одном и том же экземпляре приложения. Один из способов справиться с этим за счет внутренних механизмов — запустить все окна редактирования документа в собственных потоках. Каждый поток будет выполнять один и тот же код, но с разными данными, относящимися к редактируемому документу и соответствующими свойствам окна. Следовательно, открытие нового документа потребует запуска нового потока. Поток, обрабатывающий запрос, не станет дожидаться завершения этого другого потока, потому что он работает над другим, независимым документом, что делает новый поток основным кандидатом для запуска в отсоединенном режиме. В `листинге 2.4` показано общее представление кода реализации рассматриваемого подхода.
```c++
void edit_document(std::string const& filename)
{
	open_document_and_display_gui(filename);

	while(!done_editing())
	{
		user_command cmd=get_user_input();
		if(cmd.type==open_new_document)
		{
			std::string const new_name=get_filename_from_user();
			std::thread t(edit_document,new_name);
			t.detach();
		}
		else
		{
			process_user_input(cmd);
		}
	}
}
```
**Листинг 2.4.** Отсоединение потока для обработки другого документа

Если пользователь решает открыть новый документ, ему предлагается сделать это, после чего для открытия этого документа запускается новый поток, который затем отсоединяется. Поскольку новый поток выполняет ту же операцию, что и текущий, но в другом файле, той же функцией (`edit_document`) можно воспользоваться повторно, взяв в качестве аргумента новое выбранное имя файла.

В этом примере также показана ситуация, когда есть смысл передать аргументы в функцию, используемую для запуска потока: вместо простой передачи имени функции в конструктор [[thread#std thread|std::thread]] ему передается параметр `filename`. Для этого можно использовать и другие механизмы, например вместо обычной функции с параметрами задействовать функциональный объект с компонентными данными, для чего стандартная библиотека C++ предоставляет очень простой способ.

# Передача аргументов функции потока

В `листинге 2.4` было показано, что передача аргументов вызываемому объекту или функции сводится к простой передаче дополнительных аргументов конструктору [[thread#std thread|std::thread]]. Но важно учесть, что по умолчанию аргументы копируются во внутреннее хранилище, где к ним может получить доступ вновь созданный поток выполнения, а затем передаются вызываемому объекту или функции как [[r-значение#Традиционные l- и r-значения|r-значения (rvalues)]], как будто они временные. Так делается, даже если соответствующий параметр в функции ожидает ссылку. Рассмотрим пример:
```c++
void f(int i, std::string const& s);
std::thread t(f, 3, "hello");
```

В результате создается новый поток выполнения, связанный с `t`, который вызывает функцию `f(3,"hello")`. Обратите внимание: даже если `f` в качестве второго параметра принимает [[string|std::string]], строковый литерал передается как `char const *` и преобразуется в [[string|std::string]] только в контексте нового потока. Это становится особенно важным, когда, как показано далее, предоставленный аргумент является указателем на автоматическую переменную:
```c++
void f(int i,std::string const& s);
void oops(int some_param)
{
	char buffer[1024];
	sprintf(buffer, "%i", some_param);
	std::thread t(f, 3, buffer);
	t.detach();
}
```

Здесь это указатель на буфер локальной переменной, который передается в новый поток. И высока вероятность того, что выход из функции `oops` произойдет, прежде чем буфер будет в новом потоке преобразован в [[string|std::string]], что вызовет неопределенное поведение. Решением является приведение к типу [[string|std::string]] перед передачей буфера в конструктор [[thread|std::thread]]:
```c++
void f(int i, std::string const& s);
void not_oops(int some_param)
{
    char buffer[1024];
    sprintf(buffer, "%i", some_param);
 
	// использование std::string предотвращает обращение к
	// недействительному указателю
	std::thread t(f, 3, std::string(buffer));
    t.detach();
}
```

В данном случае причиной возникновения проблемы является надежда на подразумеваемое преобразование указателя на буфер в объект [[string|std::string]], ожидаемый в качестве параметра функции, но это преобразование происходит слишком поздно, поскольку конструктор [[thread#std thread|std::thread]] копирует предоставленные значения как есть, не преобразуя в ожидаемый тип аргумента.

Обратный сценарий получить невозможно: объект скопирован и вам нужна не `const‑ссылка`, поскольку она не скомпилируется. Все это можно попробовать, если поток обновляет структуру данных, переданную по ссылке, например:
```c++
void update_data_for_widget(widget_id w, widget_data& data);
void oops_again(widget_id w)
{
	widget_data data;
	std::thread t(update_data_for_widget, w, data);
	
	display_status();
	
	t.join();
	process_widget_data(data);
}
```

Хотя `update_data_for_widget` ожидает, что второй параметр будет передан по ссылке, конструктор [[thread#std thread|std::thread]] не знает об этом, он не обращает внимания на типы аргументов, которые ожидает функция, и слепо копирует предоставленные значения. Но внутренний код передает скопированные аргументы в качестве [[r-значение#Традиционные l- и r-значения|r‑значений]], чтобы работать с типами, предназначенными только для перемещений, и пытается таким образом вызвать `update_data_for_widget` с [[r-значение#Традиционные l- и r-значения|r-значением]]. Этот код не пройдет компиляцию, так как нельзя передать [[r-значение#r-значения|r-значение]] функции, ожидающей `не-const-ссылку`. Для тех, кто знаком с [[bind|std::bind]], решение будет очевидным: аргументы, которые должны быть ссылками, следует заключать в [[ref|std::ref]]. В этом случае при изменении вызова потока на:
```c++
std::thread t(update_data_for_widget, w, std::ref(data));
```

`update_data_for_widget` будет корректно передана ссылка на данные, а не временная копия данных и код успешно пройдет компиляцию.

Если работать с [[bind|std::bind]] уже приходилось, то в семантике передачи параметров не будет ничего нового, поскольку и операция конструктора [[thread#std thread|std::thread]], и операция [[bind|std::bind]] определены в рамках одного и того же механизма. То есть можно, например, передать указатель на компонентную функцию в виде функции при условии, что в качестве первого аргумента предоставлен подходящий указатель на объект:
```c++
class X
{
	public:
		void do_lengthy_work();
};

X my_x;
std::thread t(&X::do_lengthy_work, &my_x);
```

Этот код вызовет `my_x.do_lengthy_work()` в новом потоке, поскольку в качестве указателя на объект предоставляется адрес `my_x` . Такому вызову компонентной функции можно также предоставлять аргументы: третий аргумент конструктора [[thread#std thread|std::thread]] будет первым аргументом компонентной функции и т. д. 

Еще один интересный сценарий предоставления аргументов применяется, когда аргументы нельзя скопировать, а можно только переместить: данные, содержащиеся в одном объекте, передаются в другой, и исходный объект остается пустым.





