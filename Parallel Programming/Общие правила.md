
[[#Общие правила|Общие правила]] 11.1
1. [[#Рецензирование кода|Рецензирование кода]] 11.1.1
2. [[#Сведение к минимуму совместного доступа к изменяемым данным|Сведение к минимуму совместного доступа к изменяемым данным]] 11.1.2
3. [[#Минимизация ожидания|Минимизация ожидания]] 11.1.3
4. [[#Предпочтительное использование неизменяемых данных|Предпочтительное использование неизменяемых данных]] 11.1.4
	1. [[#Пользовательские типы данных и константы этапа компиляции|Пользовательские типы данных и константы этапа компиляции]] 11.1.4.1
5. [[#Использование чистых функций|Использование чистых функций]] 11.1.5



# Общие правила

Начнём обзор с наиболее общих правил, справедливых и для атомарных переменных, и для потоков.

## Рецензирование кода

Рецензирование кода должно быть непременной частью любого профессионального процесса разработки программ. Это становится особенно важным, когда дело идёт о параллельных вычислениях. Параллельному программированию внутренне присуща особая сложность, оно требует вдумчивости и опыта.

Чтобы сделать рецензирование более эффективным, свой код следует отсылать рецензентам как можно раньше для предварительного ознакомления. У рецензентов должно быть вдоволь времени для изучения кода до официального начала рецензирования. Стоит явно формулировать инварианты, которые должны сохраняться в ходе выполнения программы.

Если эти положения кажутся читателю неубедительными, рассмотрим один пример. Для этого нужно вспомнить гонку данных из [[lock#Блокировщик std shared_lock|программы readerWriterLock.cpp]].

**Блокировка на чтение и запись:**
```c++
// readerWriterLock.cpp

#include <iostream>
#include <map>
#include <shared_mutex>
#include <string>
#include <thread>

std::map<std::string,int> teleBook{
	{“Dijkstra”, 1972}, {“Scott”, 1976}, {“Ritchie”, 1983}};

std::shared_timed_mutex teleBookMutex;

void addToTeleBook(const std::string& na, int tele){
	std::lock_guard<std::shared_timed_mutex> writerLock(teleBookMutex);
	std::cout << “\nSTARTING UPDATE “ << na;

	std::this_thread::sleep_for(std::chrono::milliseconds(500));

	teleBook[na]= tele;
	std::cout << “ ... ENDING UPDATE “ << na << std::endl;
}

void printNumber(const std::string& na){
	std::shared_lock<std::shared_timed_mutex> readerLock(teleBookMutex);
	std::cout << na << “: “ << teleBook[na];
}

int main(){
	std::cout << std::endl;

	std::thread reader1([]{ printNumber(“Scott”); });
	std::thread reader2([]{ printNumber(“Ritchie”); });
	std::thread w1([]{ addToTeleBook(“Scott”,1968); });
	std::thread reader3([]{ printNumber(“Dijkstra”); });
	std::thread reader4([]{ printNumber(“Scott”); });
	std::thread w2([]{ addToTeleBook(“Bjarne”,1965); });
	std::thread reader5([]{ printNumber(“Scott”); });
	std::thread reader6([]{ printNumber(“Ritchie”); });
	std::thread reader7([]{ printNumber(“Scott”); });
	std::thread reader8([]{ printNumber(“Bjarne”); });

	reader1.join();
	reader2.join();
	reader3.join();
	reader4.join();
	reader5.join();
	reader6.join();
	reader7.join();
	reader8.join();
	w1.join();
	w2.join();

	std::cout << std::endl;
	std::cout << “\nThe new telephone book” << std::endl;

	for (auto teleIt: teleBook){
		std::cout << teleIt.first << “: “ << teleIt.second << std::endl;
	}

	std::cout << std::endl;
}
```

Проблема здесь в том, что операция обращения к элементу контейнера `teleBook[na]` в строке `std::cout << na << “: “ << teleBook[na];` может модифицировать контейнер. Гонку данных можно спровоцировать, поставив читающий поток `reader8` перед остальными потоками-читателями. Автор часто использует эту программу в качестве упражнения на своих семинарах по языку C++. Задание состоит в том, чтобы обнаружить гонку данных. Лишь около 10 % участников укладываются в пять минут.

## Сведение к минимуму совместного доступа к изменяемым данным

Совместный доступ к изменяемым данным нужно по возможности исключать сразу по двум причинам: для производительности и для безопасности. Безопасность здесь понимается главным образом как защита от гонки данных. Здесь сконцентрируем внимание на производительности – о корректности поговорим в следующем разделе.

В [[Вычисление суммы элементов вектора#Вычисление суммы элементов вектора|разделе]] дан подробный анализ производительности различных средств параллельного программирования. Экспериментально измерено, сколь быстро происходит суммирование элементов вектора. Ниже показан главный участок кода, работающего в один поток.

**Суммирование в один поток**
```c++
constexpr long long size = 100000000;
std::cout << ‘\n’;
std::vector<int> randValues;
randValues.reserve(size);

// random values
std::random_device seed;std::mt19937 engine(seed());
std::uniform_int_distribution<> uniformDist(1, 10);
const unsigned long long sum = std::accumulate(
	randValues.begin(),
	randValues.end(),
	0);
```

Затем суммировать стали в четыре потока. Первое наивное решение состояло в том, чтобы накапливать сумму в единой переменной, общей всем потокам, с синхронизацией доступа.

**Многопоточное суммирование с блокировкой доступа к переменной:**
```c++
std::mutex myMutex;

void sumUp(unsigned long long& sum, const std::vector<int>& val,
				unsigned long long beg, unsigned long long end){
	for (auto it = beg; it < end; ++it){
		std::lock_guard<std::mutex> myLock(myMutex);
		sum += val[it];
	}
}
```

Затем эта программа была немного оптимизирована за счёт использования атомарной переменной.

**Многопоточное суммирование с использованием атомарной переменной:**
```c++
void sumUp(std::atomic<unsigned long long>& sum,
			const std::vector<int>& val,
			unsigned long long beg,
			unsigned long long end)
{
	for (auto it = beg; it < end; ++it) {
		sum.fetch_add(val[it]);
	}
}
```

Существенного прироста производительности удалось добиться, суммируя без синхронизации элементы сегментов контейнера и затем складывая полученные результаты.

**Раздельное суммирование и минимальная синхронизация блокировщиком:**
```c++
void sumUp(unsigned long long& sum, const std::vector<int>& val,
				unsigned long long beg, unsigned long long end){

	unsigned long long tmpSum{};
	for (auto i = beg; i < end; ++i){
		tmpSum += val[i];
	}
	
	std::lock_guard<std::mutex> lockGuard(myMutex);
	sum += tmpSum;
}
```

Показатели производительности впечатляют и дают ясное понимание: чем меньше в программе общего доступа к изменяемому состоянию, тем более эффективно используются ядра процессора.

| **Способ**                                   | **Время, с** |
| -------------------------------------------- | ------------ |
| Однопоточный                                 | 0.07         |
| [[lock#Тип std lock_guard\|std::lock_guard]] | 3.34         |
| [[atomic\|Атомарные переменные]]             | 1.34         |
| Локальные переменные                         | 0.03         |

## Минимизация ожидания

Читатель мог слышать о законе Амдала. Он устанавливает теоретический верхний предел выигрыша в скорости от распараллеливания алгоритма между несколькими процессорами или ядрами. Закон довольно прост. Если `p` – доля кода, которая может выполняться без синхронизации, то максимально возможный выигрыш скорости при неограниченном числе процессоров составляет `1/(1-p)`. Так, если 90 % кода могут выполняться параллельно, то на многопроцессорной системе можно получить не более, чем десятикратный выигрыш в скорости:

![[ParallelProg_224.png]]

На это можно посмотреть и с другой стороны: если 10 % времени код должен выполняться последовательно из-за блокировки, общее время параллельного выполнения кода может сократиться лишь в 10 раз. Подчеркнём, что при этом предполагается наличие неограниченного ресурса процессоров. На следующем графике закон Амдала показан наглядно.

![[ParallelProg_225.png]]

Оптимальное число ядер, таким образом, сильно зависит от доли кода, который может выполняться параллельно без синхронизации. Например, если доля параллельного выполнения составляет 50 %, система вплотную приближается к теоретическому максимуму производительности при 16 процессорах. Дальнейшее наращивание их числа не может привести к сколько-нибудь заметному выигрышу производительности. Если же доля параллельного кода составляет 95 %, то к теоретическому максимуму производительности система приближается при 2048 процессорах.

## Предпочтительное использование неизменяемых данных

Гонка данных – это ситуация, при которой по меньшей мере два потока получают доступ к одной и той же переменной, причём по крайней мере один из этих потоков пытается эту переменную модифицировать. Таким образом, необходимым условием гонки данных является наличие изменяемого состояния в совместном доступе. Следующий рисунок поясняет эту мысль.

![[ParallelProg_226.png]]

Если данные, с которыми работают потоки, неизменяемы, гонка данных возникнуть не может. Нужно лишь гарантировать, что эти данные инициализируются потокобезопасным образом. [[Thread_Safe initialization#Потокобезопасная инициализация|Четыре способа потокобезопасной инициализации данных]]:
* ранняя – до запуска потоков – инициализация данных;
* использование константных выражений;
* функция [[Thread_Safe initialization#Функция std call_once и флаг std once_flag|std::call_once с флагом std::once_flag]];
* статическая переменная в локальной области видимости.

В языке C++ есть два способа объявлять неизменяемые данные: ключевые слова [[const|const]] и [[constexpr|constexpr]]. Если спецификатор [[const|const]] позволяет во время выполнения сделать данные неизменяемыми в том или ином контексте, то специ­фикатор [[constexpr|constexpr]] гарантирует, что данные вычисляются и подставляются на этапе компиляции и, следовательно, их использование потокобезопасно. На этапе компиляции могут инициализироваться даже данные пользовательских типов.

### Пользовательские типы данных и константы этапа компиляции

Для того чтобы значения пользовательского типа могли вычисляться на этапе компиляции, этот тип должен удовлетворять некоторым условиям.

Так, constexpr-конструктор:
* должен вызываться с аргументами, которые сами являются константными выражениями;
* не может использовать обработку исключений;
* в стандарте C++ 11 должен быть объявлен как [[default|default]], [[delete|delete]] или иметь пустое тело.

Тип в целом:
* не должен иметь виртуальных базовых классов;
* каждый базовый класс и каждый нестатический член данных должен быть проинициализирован в списке инициализаторов конструктора или непосредственно в объявлении класса. Это означает, что все используемые для этого конструкторы базовых классов и данных-членов должны быть constexpr-конструкторами, а передаваемые им аргументы должны быть константными выражениями.

На сайте-справочнике `cppreference.com` приведён полный перечень правил для пользовательских типов, допускающих конструирование на этапе компиляции. Чтобы подкрепить эту теорию практикой, разберём пример. В следующей программе объявляется класс `MyInt`. Этот класс отвечает всем перечисленным выше требованиям. Кроме того, его функция-член также имеет спецификатор [[constexpr|constexpr]].

**Пользовательский тип с поддержкой неизменяемых данных:**
```c++
// userdefinedTypes.cpp

#include <iostream>
#include <ostream>

class MyInt{
	public:
		constexpr MyInt()= default;
		constexpr MyInt(int fir, int sec)
			: myVal1(fir), myVal2(sec){}

		MyInt(int i){
			myVal1= i – 2;
			myVal2= i + 3;
		}

		constexpr int getSum() const 
		{ 
			return myVal1 + myVal2; 
		}

		friend std::ostream& operator<< (
			std::ostream &out, const MyInt& myInt)
		{
			out << “(“ << myInt.myVal1 << “,” << myInt.myVal2 << “)”;
			return out;
		}
	private:
		int myVal1= 1998;
		int myVal2= 2003;
};

int main(){
	std::cout << std::endl;

	constexpr MyInt myIntConst1;

	constexpr int sec = 2014;
	constexpr MyInt myIntConst2(2011, sec);
	
	std::cout << “myIntConst2.getSum(): “
				<< myIntConst2.getSum()
				<< std::endl;

	int arr[myIntConst2.getSum()];

	static_assert( myIntConst2.getSum() == 4025, 
					“2011 + 2014 should be 4025” );

	std::cout << std::endl;
}
```

Класс `MyInt` обладает двумя constexpr-конструкторами: это конструктор по умолчанию, объявленный в строке `constexpr MyInt()= default;`, и конструктор с двумя аргументами, объявленный в строке `constexpr MyInt(int fir, int sec)`. Кроме этого, в классе объявлена одна функция-член `getSum`, которая благодаря спецификатору [[constexpr|constexpr]] также может вычисляться на этапе компиляции. Функция-член объявлена не только со спецификатором [[constexpr|constexpr]], но и со спецификатором [[const|const]], потому что в стандарте C++14 (в отличие от стандарта C++11) constexpr-функция не является автоматически const-функцией.

Проинициализировать переменные-члены `myVal1` и `myVal2` можно двумя способами. Во-первых, их значения можно установить с помощью списка инициализаторов в конструкторе (строка `constexpr MyInt(int fir, int sec):`). Во-вторых, начальные значения можно указать прямо в объявлении класса (строки `int myVal1= 1998;` и `int myVal2= 2003;`). Если объект создаётся конструктором по умолчанию, используется второй способ, если же объект конструируется явно – первый способ имеет приоритет.

В строках `int arr[myIntConst2.getSum()];` и `static_assert` показано, что значение, возвращаемое constexpr-функцией, можно использовать в контексте, требующем константу этапа компиляции. Ниже показан результат работы программы.

![[ParallelProg_227.png]]

Следует подчеркнуть: к объекту данных, объявленному со спецификатором [[constexpr|constexpr]], на этапе выполнения можно применять только функции-члены со спецификатором [[const|const]].

В языках функционального программирования наподобие `Haskell` вообще нет изменяемых объектов данных – поэтому на них особенно удобно писать параллельные программы.

## Использование чистых функций

Язык `Haskell` называют чистым функциональным языком, поскольку в его основе лежат чистые функции. Чистой называется функция, которая при вызове с одинаковыми аргументами всегда возвращает одно и то же значение. У таких функций нет побочных эффектов, и, следовательно, они не могут менять состояние программы.

Чистые функции обладают важным преимуществом с точки зрения параллельного программирования. Их выполнение можно произвольно переупорядочивать или назначать отдельным потокам.

Функции в языке C++ по умолчанию не являются чистыми. Ниже показаны три чистые функции, каждая со своими особенностями.

```c++
int powFunc(int m, int n) {
	if (n == 0) return 1;
	
	return m * powFunc(m, n-1);
}
```

Здесь `powFunc` – это обычная функция, отрабатывающая на этапе выполнения программы.
























