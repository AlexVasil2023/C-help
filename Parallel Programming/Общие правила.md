
[[#Общие правила|Общие правила]] 11.1
1. [[#Рецензирование кода|Рецензирование кода]] 11.1.1
2. [[#Сведение к минимуму совместного доступа к изменяемым данным|Сведение к минимуму совместного доступа к изменяемым данным]] 11.1.2
3. [[#Минимизация ожидания|Минимизация ожидания]] 11.1.3
4. [[#Предпочтительное использование неизменяемых данных|Предпочтительное использование неизменяемых данных]] 11.1.4



# Общие правила

Начнём обзор с наиболее общих правил, справедливых и для атомарных переменных, и для потоков.

## Рецензирование кода

Рецензирование кода должно быть непременной частью любого профессионального процесса разработки программ. Это становится особенно важным, когда дело идёт о параллельных вычислениях. Параллельному программированию внутренне присуща особая сложность, оно требует вдумчивости и опыта.

Чтобы сделать рецензирование более эффективным, свой код следует отсылать рецензентам как можно раньше для предварительного ознакомления. У рецензентов должно быть вдоволь времени для изучения кода до официального начала рецензирования. Стоит явно формулировать инварианты, которые должны сохраняться в ходе выполнения программы.

Если эти положения кажутся читателю неубедительными, рассмотрим один пример. Для этого нужно вспомнить гонку данных из [[lock#Блокировщик std shared_lock|программы readerWriterLock.cpp]].

**Блокировка на чтение и запись:**
```c++
// readerWriterLock.cpp

#include <iostream>
#include <map>
#include <shared_mutex>
#include <string>
#include <thread>

std::map<std::string,int> teleBook{
	{“Dijkstra”, 1972}, {“Scott”, 1976}, {“Ritchie”, 1983}};

std::shared_timed_mutex teleBookMutex;

void addToTeleBook(const std::string& na, int tele){
	std::lock_guard<std::shared_timed_mutex> writerLock(teleBookMutex);
	std::cout << “\nSTARTING UPDATE “ << na;

	std::this_thread::sleep_for(std::chrono::milliseconds(500));

	teleBook[na]= tele;
	std::cout << “ ... ENDING UPDATE “ << na << std::endl;
}

void printNumber(const std::string& na){
	std::shared_lock<std::shared_timed_mutex> readerLock(teleBookMutex);
	std::cout << na << “: “ << teleBook[na];
}

int main(){
	std::cout << std::endl;

	std::thread reader1([]{ printNumber(“Scott”); });
	std::thread reader2([]{ printNumber(“Ritchie”); });
	std::thread w1([]{ addToTeleBook(“Scott”,1968); });
	std::thread reader3([]{ printNumber(“Dijkstra”); });
	std::thread reader4([]{ printNumber(“Scott”); });
	std::thread w2([]{ addToTeleBook(“Bjarne”,1965); });
	std::thread reader5([]{ printNumber(“Scott”); });
	std::thread reader6([]{ printNumber(“Ritchie”); });
	std::thread reader7([]{ printNumber(“Scott”); });
	std::thread reader8([]{ printNumber(“Bjarne”); });

	reader1.join();
	reader2.join();
	reader3.join();
	reader4.join();
	reader5.join();
	reader6.join();
	reader7.join();
	reader8.join();
	w1.join();
	w2.join();

	std::cout << std::endl;
	std::cout << “\nThe new telephone book” << std::endl;

	for (auto teleIt: teleBook){
		std::cout << teleIt.first << “: “ << teleIt.second << std::endl;
	}

	std::cout << std::endl;
}
```

Проблема здесь в том, что операция обращения к элементу контейнера `teleBook[na]` в строке `std::cout << na << “: “ << teleBook[na];` может модифицировать контейнер. Гонку данных можно спровоцировать, поставив читающий поток `reader8` перед остальными потоками-читателями. Автор часто использует эту программу в качестве упражнения на своих семинарах по языку C++. Задание состоит в том, чтобы обнаружить гонку данных. Лишь около 10 % участников укладываются в пять минут.

## Сведение к минимуму совместного доступа к изменяемым данным

Совместный доступ к изменяемым данным нужно по возможности исключать сразу по двум причинам: для производительности и для безопасности. Безопасность здесь понимается главным образом как защита от гонки данных. Здесь сконцентрируем внимание на производительности – о корректности поговорим в следующем разделе.

В [[Вычисление суммы элементов вектора#Вычисление суммы элементов вектора|разделе]] дан подробный анализ производительности различных средств параллельного программирования. Экспериментально измерено, сколь быстро происходит суммирование элементов вектора. Ниже показан главный участок кода, работающего в один поток.

**Суммирование в один поток**
```c++
constexpr long long size = 100000000;
std::cout << ‘\n’;
std::vector<int> randValues;
randValues.reserve(size);

// random values
std::random_device seed;std::mt19937 engine(seed());
std::uniform_int_distribution<> uniformDist(1, 10);
const unsigned long long sum = std::accumulate(
	randValues.begin(),
	randValues.end(),
	0);
```

Затем суммировать стали в четыре потока. Первое наивное решение состояло в том, чтобы накапливать сумму в единой переменной, общей всем потокам, с синхронизацией доступа.

**Многопоточное суммирование с блокировкой доступа к переменной:**
```c++
std::mutex myMutex;

void sumUp(unsigned long long& sum, const std::vector<int>& val,
				unsigned long long beg, unsigned long long end){
	for (auto it = beg; it < end; ++it){
		std::lock_guard<std::mutex> myLock(myMutex);
		sum += val[it];
	}
}
```

Затем эта программа была немного оптимизирована за счёт использования атомарной переменной.

**Многопоточное суммирование с использованием атомарной переменной:**
```c++
void sumUp(std::atomic<unsigned long long>& sum,
			const std::vector<int>& val,
			unsigned long long beg,
			unsigned long long end)
{
	for (auto it = beg; it < end; ++it) {
		sum.fetch_add(val[it]);
	}
}
```

Существенного прироста производительности удалось добиться, суммируя без синхронизации элементы сегментов контейнера и затем складывая полученные результаты.

**Раздельное суммирование и минимальная синхронизация блокировщиком:**
```c++
void sumUp(unsigned long long& sum, const std::vector<int>& val,
				unsigned long long beg, unsigned long long end){

	unsigned long long tmpSum{};
	for (auto i = beg; i < end; ++i){
		tmpSum += val[i];
	}
	
	std::lock_guard<std::mutex> lockGuard(myMutex);
	sum += tmpSum;
}
```

Показатели производительности впечатляют и дают ясное понимание: чем меньше в программе общего доступа к изменяемому состоянию, тем более эффективно используются ядра процессора.

| **Способ**                                   | **Время, с** |
| -------------------------------------------- | ------------ |
| Однопоточный                                 | 0.07         |
| [[lock#Тип std lock_guard\|std::lock_guard]] | 3.34         |
| [[atomic\|Атомарные переменные]]             | 1.34         |
| Локальные переменные                         | 0.03         |

## Минимизация ожидания

Читатель мог слышать о законе Амдала. Он устанавливает теоретический верхний предел выигрыша в скорости от распараллеливания алгоритма между несколькими процессорами или ядрами. Закон довольно прост. Если `p` – доля кода, которая может выполняться без синхронизации, то максимально возможный выигрыш скорости при неограниченном числе процессоров составляет `1/(1-p)`. Так, если 90 % кода могут выполняться параллельно, то на многопроцессорной системе можно получить не более, чем десятикратный выигрыш в скорости:

![[ParallelProg_224.png]]

На это можно посмотреть и с другой стороны: если 10 % времени код должен выполняться последовательно из-за блокировки, общее время параллельного выполнения кода может сократиться лишь в 10 раз. Подчеркнём, что при этом предполагается наличие неограниченного ресурса процессоров. На следующем графике закон Амдала показан наглядно.

![[ParallelProg_225.png]]

Оптимальное число ядер, таким образом, сильно зависит от доли кода, который может выполняться параллельно без синхронизации. Например, если доля параллельного выполнения составляет 50 %, система вплотную приближается к теоретическому максимуму производительности при 16 процессорах. Дальнейшее наращивание их числа не может привести к сколько-нибудь заметному выигрышу производительности. Если же доля параллельного кода составляет 95 %, то к теоретическому максимуму производительности система приближается при 2048 процессорах.

## Предпочтительное использование неизменяемых данных

Гонка данных – это ситуация, при которой по меньшей мере два потока получают доступ к одной и той же переменной, причём по крайней мере один из этих потоков пытается эту переменную модифицировать. Таким образом, необходимым условием гонки данных является наличие изменяемого состояния в совместном доступе. Следующий рисунок поясняет эту мысль.

![[ParallelProg_226.png]]






















