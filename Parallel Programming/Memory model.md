
[[#Модель памяти]]  2
1. [[#Начальное представление о модели памяти]] 2.1
	1. [[#Что такое область памяти?|Что такое область памяти?]]  2.1.1
	2. [[#Что происходит, когда два потока обращаются к одной области памяти|Что происходит, когда два потока обращаются к одной области памяти]] 2.1.2
2. [[#Модель памяти как контракт]] 2.2 
	1. [[#Основы|Основы]]
	2. [[#Трудности|Трудности]]
3. [[#Атомарные переменные|Атомарные переменные]]  2.3
	1. [[#Отличие сильной модели памяти от слабой]] 2.3.1
		1. [[#Сильная модель памяти]]
		2. [[#Слабая модель памяти]]
	2. [[#Атомарный флаг]] 2.3.2
		1. [[#Циклическая блокировка|Циклическая блокировка]]
		2. [[#Сравнение циклической блокировки с мьютексом|Сравнение циклической блокировки с мьютексом]]
		3. [[#Синхронизация потоков|Синхронизация потоков]]
	3. [[#std atomic|Шаблон std::atomic]] 2.3.3
		1. [[#Фундаментальный атомарный интерфейс|Фундаментальный атомарный интерфейс]] 2.3.3.1
			1. [[#Тип `std atomic<bool>`|Тип std::atomic<bool>]]
			2. [[#Моделирование переменных условия|Моделирование переменных условия]]
			3. [[#Операции compare_exchange_strong и compare_exchange_weak|Операции compare_exchange_strong и compare_exchange_weak]]
			4. [[atomic#Синхронизация потоков с помощью типа `std atomic<bool>`|Синхронизация потоков с помощью типа `std::atomic<bool>`]]
			5. [[atomic#Атомарные обёртки для пользовательских типов|Атомарные обёртки для пользовательских типов]]
			6. [[atomic#Атомарные умные указатели в стандарте C++ 20|Атомарные умные указатели в стандарте C++ 20]]
			7. [[atomic#Потокобезопасный односвязный список|Потокобезопасный односвязный список]]
		2. [[atomic#Атомарные типы с плавающей точкой в стандарте C++20|Атомарные типы с плавающей точкой в стандарте C++20]]
		3. [[atomic#Атомарный тип указателя|Атомарный тип указателя]]
		4. [[atomic#Атомарные целочисленные типы|Атомарные целочисленные типы]]
		5. [[atomic#Псевдонимы типов|Псевдонимы типов]]
	4. [[atomic#Функции-члены атомарных типов|Функции-члены атомарных типов]] 2.3.4
	5. [[atomic#Свободные функции над атомарными типами|Свободные функции над атомарными типами]] 2.3.5
		1. [[atomic#Особенности типа std shared_ptr (до стандарта C++ 20)|Особенности типа std::shared_ptr (до стандарта C++ 20)]] 2.3.5.1
			1. [[atomic#Атомарные операции над типом std shared_ptr|Атомарные операции над типом std::shared_ptr]] 2.3.5.1.1
	6. [[atomic#Шаблон класса std atomic_ref в стандарте C++ 20|Шаблон класса std::atomic_ref в стандарте C++ 20]] 2.3.6
		1. [[atomic#Мотивация|Мотивация]] 2.3.6.1
		2. [[atomic#Специализации шаблона std atomic_ref|Специализации шаблона std atomic_ref]] 2.3.6.2
			1. [[atomic#Основной вариант шаблона|Основной вариант шаблона]] 2.3.6.2.1
			2. [[atomic#Частичные специализации для типов указателей|Частичные специализации для типов указателей]] 2.3.6.2.2
			3. [[atomic#Специализации для арифметических типов|Специализации для арифметических типов]] 2.3.6.2.3
		3. [[atomic#Полный список атомарных операций|Полный список атомарных операций]] 2.3.6.3
	7. [[atomic#std atomic<std shared_ptr>|std::atomic<std::shared_ptr>]]
	8. [[atomic#std atomic<std weak_ptr>|std::atomic<std::weak_ptr>]]
4. [[sync and Memory model#Синхронизация и порядок доступа к памяти|Синхронизация и порядок доступа к памяти]] 2.4
	1. [[sync and Memory model#Шесть вариантов модели памяти в языке C++|Шесть вариантов модели памяти в языке C++]] 2.4.1
		1. [[sync and Memory model#Виды атомарных операций|Виды атомарных операций]] 2.4.1.1
		2. [[sync and Memory model#Ограничения на синхронизацию и порядок доступа|Ограничения на синхронизацию и порядок доступа]] 2.4.1.2
	2. [[sync and Memory model#Последовательно-согласованное выполнение|Последовательно-согласованное выполнение]] 2.4.2
	3. [[sync and Memory model#Семантика захвата и освобождения|Семантика захвата и освобождения]] 2.4.3
		1. [[sync and Memory model#Транзитивность|Транзитивность]] 2.4.3.1
		2. [[sync and Memory model#Типичное недоразумение|Типичное недоразумение]] 2.4.3.2
			1. [[sync and Memory model#Цикл ожидания присутствует|Цикл ожидания присутствует]] 2.4.3.2.1
			2. [[sync and Memory model#Если…|Если…]] 2.4.3.2.2
			3. [[sync and Memory model#Решение|Решение]] 2.4.3.2.3
		3. [[sync and Memory model#Последовательность освобождений|Последовательность освобождений]] 2.4.3.3
	4. [[sync and Memory model#Модель памяти std memory_order_consume|Модель памяти std::memory_order_consume]] 2.4.4
		1. [[sync and Memory model#Порядок захвата и освобождения|Порядок захвата и освобождения]] 2.4.4.1
		2. [[sync and Memory model#Порядок освобождения и потребления|Порядок освобождения и потребления]] 2.4.4.2
		3. [[sync and Memory model#Различие порядков «освобождение-захват» и «освобождение-потребление»|Различие порядков «освобождение-захват» и «освобождение-потребление»]] 2.4.4.3
		4. [[sync and Memory model#Зависимости данных в модели std memory_order_consume|Зависимости данных в модели std::memory_order_consume]] 2.4.4.4
	5. [[sync and Memory model#Ослабленная семантика|Ослабленная семантика]] 2.4.5
		1. [[sync and Memory model#Отсутствие ограничений на синхронизацию и порядок операций|Отсутствие ограничений на синхронизацию и порядок операций]] 2.4.5.1
5. [[barrier#Барьеры|Барьеры]] 2.5
	1. [[barrier#Барьер `std atomic_thread_fence`|Барьер std:: atomic_thread_fence]] 2.5.1
		1. [[barrier#Что такое барьеры памяти|Что такое барьеры памяти]] 2.5.1.1
		2. [[barrier#Три барьера|Три барьера]] 2.5.1.2
			1. [[barrier#Полный барьер|Полный барьер]] 2.5.1.2.1
			2. [[barrier#Барьер захвата|Барьер захвата]] 2.5.1.2.2
			3. [[barrier#Барьер освобождения|Барьер освобождения]] 2.5.1.2.3
			4. [[barrier#Виды барьеров, вместе взятые|Виды барьеров, вместе взятые]] 2.5.1.2.4
		3. [[barrier#Барьеры захвата и освобождения|Барьеры захвата и освобождения]] 2.5.1.3
			1. [[barrier#Сравнение атомарных операций с барьерами|Сравнение атомарных операций с барьерами]] 2.5.1.3.1
			2. [[barrier#Операции захвата|Операции захвата]] 2.5.1.3.2
			3. [[barrier#Операции освобождения|Операции освобождения]] 2.5.1.3.3
		4. [[barrier#Синхронизация с использованием атомарных переменных и барьеров|Синхронизация с использованием атомарных переменных и барьеров]] 2.5.1.4
			1. [[barrier#Реализация на основе атомарных операций|Реализация на основе атомарных операций]] 2.5.1.4.1
			2. [[barrier#Барьеры памяти|Барьеры памяти]] 2.5.1.4.2
	2. [[barrier#Барьер std atomic_signal_fence|Барьер std::atomic_signal_fence]] 2.5.2 
	3. 
7. 

# Модель памяти

Основу параллельного программирования составляет чётко определённая модель памяти. Читателю она откроется с двух сторон. Во-первых, своей невероятной сложностью и зачастую разительным несоответствием интуитивным представлениям. Во-вторых, тем, как сильно она поможет в глубинном понимании сложностей параллельного программирования.

![[ParallelProg_2.png]]
В ней должны быть отражены следующие аспекты:

> **Атомарные операции** – операции, выполнение которых не может быть прервано до их полного завершения.
> 
> **Частичное упорядочение операций** – последовательности операций, порядок выполнения которых не должен нарушаться.
> 
> **Видимые эффекты операций** – гарантия того, что результат операций над переменными, находящимися в общем доступе, будет заметен из других потоков.

Модель памяти, разработанная для языка C++, испытала заметное влияние предшественника – модели памяти для языка Java. В отличие от последней, однако, язык C++ позволяет снимать требование временной согласованности операций, по умолчанию накладываемое на атомарные операции.

Временная согласованность состоит из двух гарантий:

1. Инструкции программы выполняются в том порядке, в котором они записаны в её исходном коде.
2. Существует глобальный порядок выполнения всех операций во всех параллельных потоках.

Понятие модели памяти, в свою очередь, основывается на понятии атомарной операции, выполняемой над данными атомарных типов – для краткости их называют атомарными переменными.

## Начальное представление о модели памяти

С точки зрения параллельного программирования, модель памяти определяется ответами на два вопроса:

> Что такое область памяти?
> 
> Что происходит, когда два потока одновременно осуществляют доступ к одной области памяти?

### Что такое область памяти?

Согласно сайту `cppreference.com`, область памяти – это

* объект скалярного типа (арифметический тип, указатель, перечисление или [[nullptr_t|std::nullptr_t]]),
* наибольшая непрерывная последовательность битовых полей ненулевой длины.

Рассмотрим пример:

```c++
struct S {
	char a;              // область 1
	int b : 5;           // область 2
	int c : 11,          // область 2 (продолжение)
		  : 0,
		d : 8;           // область 3
	int e;               // область 4
	double f;            // область 5
	std::string g;       // несколько областей
} obj;
```

В первую очередь бросается в глаза, что объект `obj` состоит из семи подобъектов, однако два битовых поля, `b` и `c`, делят между собой одну область памяти.

Отметим ряд важных наблюдений:

* Каждая переменная есть объект.
* Объект скалярного типа занимает одну область памяти.
* Подряд расположенные битовые поля (в данном примере – поля `b` и `c`) занимают одну область памяти.
* Всякая переменная занимает по меньшей мере одну область памяти.

Теперь можно перейти к самому важному вопросу многопоточного программирования.

### Что происходит, когда два потока обращаются к одной области памяти

Если два потока одновременно обращаются к одной области памяти (напомним, что подряд расположенные битовые поля также образуют единую область) и хотя бы один из потоков её модифицирует, в программе имеет место гонка данных, за исключением следующих случаев:

1. Область памяти модифицируется атомарной операцией.
2. Доступ одного потока к области памяти завершается до начала доступа другого.

Второй случай особенно интересен потому, что примитивы синхронизации – такие как [[mutex|мьютексы]] – существуют именно для того, чтобы обеспечивать отношение «раньше – позже» между операциями. Отношения «раньше – позже» имеют место между атомарными операциями, а также могут быть распространены на операции над неатомарными типами. Правила упорядочения операций определяют подробности того, как отношения «раньше – позже» выстраиваются в каждом конкретном случае, и поэтому составляют существенную часть модели памяти.

Таково первоначальное формальное объяснение понятия «модель памяти». Пора получить наглядное представление о модели памяти. Модель памяти в языке C++ – это контракт.

## Модель памяти как контракт

Контракт, о котором здесь идёт речь, заключается между программистом и вычислительной системой. В состав системы входят: компилятор, генерирующий машинный код; процессор, на котором машинный код выполняется; кроме того, в процессоре имеются разнообразные буферы сверхоперативной памяти, в которые могут помещаться элементы состояния программы для ускорения доступа. Каждый компонент системы старается, насколько возможно, внести свой вклад в ускорение работы программы. Например, компилятор может использовать регистры процессора для часто меняющихся переменных или разворачивать циклы; в процессоре может происходить внеочередное выполнение или предсказание переходов; буферизация позволяет наперёд загружать машинные инструкции и сохранять в сверхбыстрой памяти данные, к которым обращения происходят особенно часто. Результатом этих оптимизаций – если они выполняются правильно – становится хорошо определённый исполняемый код, полностью оптимизированный для определённой аппаратной платформы. Для большей точности следовало бы говорить не об одном контракте, а о детально проработанном наборе контрактов. Это можно сформулировать иначе: чем менее жёсткие ограничения накладываются на программиста, тем больше остаётся возможностей для оптимизации кода и процесса его выполнения.

Эмпирическое правило таково: чем жёстче условия контракта, тем меньше у системы свободы в выборе способов генерации и выполнения кода с высокой степенью оптимизации. Увы, обратной закономерностью воспользоваться трудно. Когда программист пользуется чрезвычайно слабым контрактом с системой (иначе говоря, очень слабой моделью памяти), он оставляет системе самый большой выбор оптимизаций. Однако в результате их получится программа, разобраться в функционировании которой сможет лишь горстка светил мирового уровня.

Говоря упрощённо, в стандарте C++11 определены три уровня контрактов:

![[ParallelProg_10.png]]

До появления стандарта C++11 существовал только один контракт. Спецификация языка C++ не содержала контрактов для многопоточного программирования или атомарных операций. В системе предполагался только один поток управления, поэтому возможности оптимизировать исполняемый код оказывались крайне ограниченными. Система непременно должна была дать программисту гарантию, что наблюдаемое поведение программы соответствует последовательности инструкций в исходном коде. Конечно, это означало фактическое отсутствие какой-либо модели памяти. Вместо этого существовало понятие точки следования (англ. sequence point). Точкой следования называется такая точка в программе, в которой результаты всех предшествующих инструкций должны стать наблюдаемыми. Начало и конец выполнения функции – это точки следования. При вызове функции с двумя или более аргументами старый стандарт языка C++ не давал никаких гарантий относительно того, какой из них будет вычисляться первым, т. е. порядок вычисления аргументов оставался неопределённым. Это вполне объяснимо: запятая, которой разделяются аргументы, не является точкой следования. 

Всё изменилось в стандарте C++11. Это первый стандарт языка C++, в котором учитывается возможность параллельного выполнения нескольких потоков. В основу подробно определённого поведения потоков в языке C++ была положена модель памяти, испытавшая значительное влияние модели памяти для языка Java. Однако модель памяти в языке C++ идёт – как всегда – на несколько шагов впереди. Программисту достаточно соблюдать несколько правил при работе с переменными в совместном доступе, чтобы получить программу с хорошо определённым поведением. Поведение программы не определено, если в ней присутствует хотя бы одна гонка данных. Как уже отмечалось выше, программисту нужно иметь в виду опасность гонки данных, если потоки имеют совместный доступ к изменяемым данным.

Проще всего программировать в терминах [[task|заданий]], заметно сложнее – в терминах [[thread|потоков]] и переменных условия. [[atomic|Атомарные переменные]] и операции – вотчина профессионалов. Это тем более очевидно, чем более ослабляется контракт, налагаемый моделью памяти. В контексте атомарных переменных часто говорят о неблокирующем (англ. lock-free) программировании – столь же интересном, сколь и сложном.

В этом разделе речь шла о сильных и слабых гарантиях. Разумеется, последовательная согласованность представляет собой более сильную модель памяти, а ослабленная семантика – более слабую.

### Основы

Модель памяти в языке C++ должна охватывать следующие вопросы:

* Атомарные операции: выполнение каких операций гарантированно не может быть прервано до полного завершения.
* Частичное упорядочение операций: какие последовательности выполнения операций не должны нарушаться.
* Видимые результаты операций: каковы гарантии того, что результаты операций над переменными в общем доступе становятся видимыми в других потоках.

В основе контракта лежат операции над [[atomic|атомарными значениями]]. Эти операции обладают двумя особенностями: они по определению неделимы и не могут быть прерваны; они накладывают на выполнение программы ограничения, связанные с синхронизацией и порядком выполнения. Эти ограничения на порядок и синхронизацию также сохраняются и для операций над неатомарными значениями. В то время как операции над атомарными переменными всегда атомарны, синхронизацию и упорядочение можно подстроить под свои нужды.

### Трудности

Чем более ослабляется модель памяти, тем более программисту необходимо концентрировать внимание на следующих обстоятельствах:

> Доступно больше возможностей оптимизации программы.
> 
> Возможное число путей выполнения программы растёт экспоненциально.
>
> Всё большее мастерство требуется от программиста.
> 
> Поведение программы противоречит интуитивным ожиданиям.
> 
> Программист погружается в микрооптимизацию.

Чтобы заниматься многопоточным программированием, нужно быть мастером. Чтобы иметь дело с [[atomic|атомарными переменными]] на уровне последовательной согласованности, нужно взойти на более высокую ступень мастерства. Что же можно сказать о семантике захвата и освобождения или об ослабленной семантике? Только одно: нужно подняться ещё выше по лестнице мастерства (или, если угодно, погрузиться ещё глубже в бездну знаний).

![[ParallelProg_11.png]]
Уровни мастерства

Теперь пора погрузиться глубже в модели памяти языка C++ и начать знакомство с безблокировочным программированием. В последующих разделах речь пойдёт об атомарных переменных и операциях. Затем, после знакомства с основами, последуют остальные уровни модели памяти. Отправной точкой послужит вполне простая согласованность временной последовательности операций, затем разберём семантику захвата - освобождения, а завершим уже не столь интуитивно очевидной ослабленной семантикой. 

## Атомарные переменные

Атомарные переменные лежат в основе модели памяти языка C++. По умолчанию к атомарным переменным применяется наиболее сильная модель памяти. Поэтому имеет смысл начать изучение с особенностей сильной мо-
дели памяти.

### Отличие сильной модели памяти от слабой

под сильной моделью памяти понимается последовательная согласованность операций, тогда как наиболее слабой моделью является ослабленная семантика.

#### Сильная модель памяти

Язык Java 5.0 получил свою нынешнюю модель памяти в 2004 году, а язык C++ – в 2011 году. До этого модель памяти языка Java содержала ошибки, а язык C++ её вообще не имел. Однако было бы в корне неверно думать, что история вопроса начинается с указанных дат. Основы многопоточного программирования закладывались 40 или 50 лет назад. Лесли Лэмпорт в 1979 году дал такое определение последовательной согласованности.

Последовательная согласованность состоит из двух гарантий:
* инструкции программы выполняются в том порядке, в котором они записаны в её тексте;
* существует глобальный порядок операций для всех потоков программы.

Прежде чем погружаться в анализ этих гарантий, необходимо подчеркнуть, что эти гарантии в полной мере относятся к атомарным переменным и в некоторой степени затрагивают неатомарные.

На следующем рисунке показаны два потока. Каждый поток присваивает значение своей атомарной переменной (соответственно `x` и `y`), затем читает значение другой переменной (соответственно `y` и `x`), а затем сохраняет полученное значение в переменные `res1` и `res2`.

![[ParallelProg_12.png]]

Поскольку переменные `x` и `y` атомарны, операции над ними выполняются атомарным образом, т. е. не могут быть прерваны на середине. По умолчанию действует модель последовательной согласованности. Попытаемся выяснить, в каком порядке должны выполняться эти операции.

Первая гарантия последовательной согласованности означает, что инструкции каждого потока выполняются в том порядке, в котором записаны в исходном коде. Это понять просто: ни в одном из двух потоков операция `load` не может выполниться раньше, чем операция `store`.

Вторая гарантия, входящая в понятие последовательной согласованности, состоит в том, что инструкции всех потоков вместе взятые должны образовывать глобально упорядоченную последовательность. В данном примере это означает, что `поток 2` видит операции, выполняемые `потоком 1`, в том же порядке, в котором `поток 1` их выполняет. Это обстоятельство исключительно важно. `Поток 2` видит операции `потока 1` в том же порядке, в котором они указаны в исходном коде `потока 1`. Однако это же верно и для `потока 1`, который видит операции `потока 2`. Таким образом, вторую гарантию можно понимать как наличие глобальных часов, ход которых одинаков для всех потоков. Глобальные часы предполагают глобальную упорядоченность операций. Всякий раз, когда глобальные часы продвигаются на один шаг, выполняется одна атомарная операция – хотя невозможно заранее сказать, какая именно.

Головоломка пока не разгадана до конца. Необходимо рассмотреть различные последовательности выполнения операций из двух потоков. Всего существует шесть способов перемежающегося выполнения двух потоков, они показаны на следующем рисунке.

![[ParallelProg_13.png]]
Шесть возможных вариантов перемежающегося выполнения потоков

Теперь всё стало просто. В этом и состоит последовательная согласованность, также известная как сильная модель памяти.

#### Слабая модель памяти

Обратимся ещё раз к понятию контракта между программистом и системой. В этом примере программист использовал атомарные переменные. Тем самым он выполнил свою часть контракта. Система должна гарантировать хорошо определённое поведение программы без гонок данных. Во всём остальном система вольна выполнять четыре операции в любой последовательности. И если программист пользуется ослабленной семантикой, смысл контракта разительно меняется. С одной стороны, программисту становится гораздо труднее понять все возможные способы взаимодействия двух потоков. С другой же – у системы появляется гораздо больше возможностей для оптимизации программы.

В рамках ослабленной семантики, также известной как слабая модель памяти, существует гораздо больше комбинаций, в которые могут складываться эти четыре операции. Так, возможно противоречащее здравому смыслу поведение, когда `поток 1` видит операции `потока 2` не в том порядке, в котором тот их выполняет, – таким образом, система в целом уже не обладает глобальными часами. `Поток 1` вполне может увидеть результат операции `res2= x.load()` раньше, чем результат операции `y.store(1)`. Более того, `поток 1` или `2` может и сам выполнять свои операции не в том порядке, в котором они записаны в исходном коде. Например, `поток 2` может выполнить операцию `res2= x.load()` раньше, чем операцию `y.store(1)`.

Между последовательной согласованностью и ослабленной семантикой находятся ещё другие модели. Важнейшая из них – семантика захвата-освобождения. Семантика захвата-освобождения предоставляет программисту менее жёсткие гарантии, нежели модель последовательной согласованности. Как следствие у системы появляется больше возможностей для оптимизации. Семантика захвата-освобождения служит ключом к глубокому пониманию синхронизации и частичной упорядоченности операций в параллельном программировании. Потоки синхронизируются в особых точках кода. Без этих точек синхронизации невозможным было бы хорошо определённое поведение потоков или работа переменных условия.

В предыдущем разделе говорилось, что последовательная согласованность – это поведение, которым атомарные переменные обладают по умолчанию. Что это значит? Программист может задать способ упорядочения для каждой отдельно взятой атомарной операции. Если же модель памяти не задать явно, будет применена последовательная согласованность – это означает, что флаг `std::memory_order_seq_cst` неявно применяется к каждой операции над атомарной переменной. Таким образом, фрагмент кода

```c++
x.store(1);
res = x.load();
```

эквивалентен следующему:

```c++
x.store(1, std::memory_order_seq_cst);
res = x.load(std::memory_order_seq_cst);
```

## Атомарный флаг

см. [[atomic#std atomic_flag|Атомарный флаг]]

### Циклическая блокировка

см. [[atomic#Циклическая блокировка|Циклическая блокировка]]

### Сравнение циклической блокировки с мьютексом

см. [[atomic#Сравнение циклической блокировки с мьютексом|Сравнение циклической блокировки с мьютексом]]

### Синхронизация потоков

см. [[atomic#Синхронизация потоков|Синхронизация потоков]]

## std::atomic

см. [[atomic#std atomic|std::atomic]]

### Фундаментальный атомарный интерфейс

см. [[atomic#Фундаментальный атомарный интерфейс|Фундаментальный атомарный интерфейс]]

#### Тип `std::atomic<bool>`

см. [[atomic#Тип `std atomic<bool>`|Тип std::atomic<bool>]]

#### Моделирование переменных условия

см. [[atomic#Моделирование переменных условия|Моделирование переменных условия]]

#### Операции compare_exchange_strong и compare_exchange_weak

см. [[atomic#Операции compare_exchange_strong и compare_exchange_weak|Операции compare_exchange_strong и compare_exchange_weak]]

#### Синхронизация потоков с помощью типа `std::atomic<bool>`

см. [[atomic#Синхронизация потоков с помощью типа `std atomic<bool>`|Синхронизация потоков с помощью типа `std::atomic<bool>`]]

#### Атомарные обёртки для пользовательских типов

см. [[atomic#Атомарные обёртки для пользовательских типов|Атомарные обёртки для пользовательских типов]]

#### Атомарные умные указатели в стандарте C++ 20

см. [[atomic#Атомарные умные указатели в стандарте C++ 20|Атомарные умные указатели в стандарте C++ 20]]

#### Потокобезопасный односвязный список

см. [[atomic#Потокобезопасный односвязный список|Потокобезопасный односвязный список]]

### Атомарные типы с плавающей точкой в стандарте C++20

см. [[atomic#Атомарные типы с плавающей точкой в стандарте C++20|Атомарные типы с плавающей точкой в стандарте C++20]]

### Атомарный тип указателя

см. [[atomic#Атомарный тип указателя|Атомарный тип указателя]]

### Атомарные целочисленные типы

см. [[atomic#Атомарные целочисленные типы|Атомарные целочисленные типы]]

### Псевдонимы типов

см. [[atomic#Псевдонимы типов|Псевдонимы типов]]

## Функции-члены атомарных типов

см. [[atomic#Функции-члены атомарных типов|Функции-члены атомарных типов]]

## Свободные функции над атомарными типами

см. [[atomic#Свободные функции над атомарными типами|Свободные функции над атомарными типами]]

### Особенности типа std::shared_ptr (до стандарта C++ 20)

см. [[atomic#Особенности типа std shared_ptr (до стандарта C++ 20)|Особенности типа std::shared_ptr (до стандарта C++ 20)]]

#### Атомарные операции над типом `std::shared_ptr`

см. [[atomic#Атомарные операции над типом std shared_ptr|Атомарные операции над типом std::shared_ptr]]

## Шаблон класса std::atomic_ref в стандарте C++ 20

см. [[atomic#Шаблон класса std atomic_ref в стандарте C++ 20|Шаблон класса std::atomic_ref в стандарте C++ 20]]

### Мотивация

см. [[atomic#Мотивация|Мотивация]]

### Специализации шаблона std atomic_ref

см. [[atomic#Специализации шаблона std atomic_ref|Специализации шаблона std atomic_ref]]

#### Основной вариант шаблона

см. [[atomic#Основной вариант шаблона|Основной вариант шаблона]]

#### Частичные специализации для типов указателей

см. [[atomic#Частичные специализации для типов указателей|Частичные специализации для типов указателей]]

#### Специализации для арифметических типов

см. [[atomic#Специализации для арифметических типов|Специализации для арифметических типов]]

### Полный список атомарных операций

см. [[atomic#Полный список атомарных операций|Полный список атомарных операций]]

### std::atomic`<std::shared_ptr>`

см. [[atomic#std atomic<std shared_ptr>|std::atomic<std::shared_ptr>]]

### std::atomic<std::weak_ptr>

см. [[atomic#std atomic<std weak_ptr>|std::atomic<std::weak_ptr>]]

# Синхронизация и порядок доступа к памяти

см. [[sync and Memory model#Синхронизация и порядок доступа к памяти|Синхронизация и порядок доступа к памяти]]

## Шесть вариантов модели памяти в языке C++

см. [[sync and Memory model#Шесть вариантов модели памяти в языке C++|Шесть вариантов модели памяти в языке C++]]

### Виды атомарных операций

см. [[sync and Memory model#Виды атомарных операций|Виды атомарных операций]]

### Ограничения на синхронизацию и порядок доступа

см. [[sync and Memory model#Ограничения на синхронизацию и порядок доступа|Ограничения на синхронизацию и порядок доступа]]

## Последовательно-согласованное выполнение

см. [[sync and Memory model#Последовательно-согласованное выполнение|Последовательно-согласованное выполнение]]

## Семантика захвата и освобождения

см. [[sync and Memory model#Семантика захвата и освобождения|Семантика захвата и освобождения]]

### Транзитивность

см. [[sync and Memory model#Транзитивность|Транзитивность]]

### Типичное недоразумение

см. [[sync and Memory model#Типичное недоразумение|Типичное недоразумение]]

#### Цикл ожидания присутствует

см. [[sync and Memory model#Цикл ожидания присутствует|Цикл ожидания присутствует]]

#### Решение

см. [[sync and Memory model#Решение|Решение]]

### Последовательность освобождений

см. [[sync and Memory model#Последовательность освобождений|Последовательность освобождений]]

## Модель памяти std::memory_order_consume

см. [[sync and Memory model#Модель памяти std memory_order_consume|Модель памяти std::memory_order_consume]]

### Порядок захвата и освобождения

см. [[sync and Memory model#Порядок захвата и освобождения|Порядок захвата и освобождения]]

### Порядок освобождения и потребления

см. [[sync and Memory model#Порядок освобождения и потребления|Порядок освобождения и потребления]]

### Различие порядков «освобождение-захват» и «освобождение-потребление»

см. [[sync and Memory model#Различие порядков «освобождение-захват» и «освобождение-потребление»|Различие порядков «освобождение-захват» и «освобождение-потребление»]]

### Зависимости данных в модели std::memory_order_consume

см. [[sync and Memory model#Зависимости данных в модели std memory_order_consume|Зависимости данных в модели std::memory_order_consume]]

## Ослабленная семантика

см. [[sync and Memory model#Ослабленная семантика|Ослабленная семантика]]

### Отсутствие ограничений на синхронизацию и порядок операций

см. [[sync and Memory model#Отсутствие ограничений на синхронизацию и порядок операций|Отсутствие ограничений на синхронизацию и порядок операций]]

# Барьеры

см. [[barrier#Барьеры|Барьеры]]

## Барьер `std::atomic_thread_fence`

см. [[barrier#Барьер `std atomic_thread_fence`|Барьер std::atomic_thread_fence]]

### Что такое барьеры памяти

см. [[barrier#Что такое барьеры памяти|Что такое барьеры памяти]] 

#### Полный барьер

см. [[barrier#Полный барьер|Полный барьер]] 

#### Барьер захвата

см. [[barrier#Барьер захвата|Барьер захвата]]

#### Барьер освобождения

см. [[barrier#Барьер освобождения|Барьер освобождения]] 

#### Виды барьеров, вместе взятые

см. [[barrier#Виды барьеров, вместе взятые|Виды барьеров, вместе взятые]]

### Барьеры захвата и освобождения

см. [[barrier#Барьеры захвата и освобождения|Барьеры захвата и освобождения]]

#### Сравнение атомарных операций с барьерами

см. [[barrier#Сравнение атомарных операций с барьерами|Сравнение атомарных операций с барьерами]]

#### Операции захвата

см. [[barrier#Операции захвата|Операции захвата]]

#### Операции освобождения

см. [[barrier#Операции освобождения|Операции освобождения]]

### Синхронизация с использованием атомарных переменных и барьеров

см. [[barrier#Синхронизация с использованием атомарных переменных и барьеров|Синхронизация с использованием атомарных переменных и барьеров]]

#### Реализация на основе атомарных операций

см. [[barrier#Реализация на основе атомарных операций|Реализация на основе атомарных операций]]

#### Барьеры памяти

см. [[barrier#Барьеры памяти|Барьеры памяти]]

## Барьер std::atomic_signal_fence

см. [[barrier#Барьер std atomic_signal_fence|Барьер std::atomic_signal_fence]]





















