
[[#Концептуальная модель|Концептуальная модель]] 5.3
1. [[#Объект-обещание|Объект-обещание]] 5.3.1
2. [[#Дескриптор сопрограммы|Дескриптор сопрограммы]] 5.3.2
3. [[#Кадр сопрограммы|Кадр сопрограммы]] 5.3.3

# Концептуальная модель

Инфраструктуру для создания сопрограмм составляют два десятка функций, некоторые из которых программисту нужно определить самостоятельно, а некоторые можно переопределить при желании, чтобы настроить свои сопрограммы под конкретные требования.

Для работы сопрограммы нужны три составные части: объект-обещание, дескриптор сопрограммы и кадр. Клиент получает дескриптор сопрограммы, чтобы через него взаимодействовать с объектом-обещанием, который хранит своё текущее состояние в кадре.

## Объект-обещание

Работа с объектом-обещанием происходит из кода сопрограммы. Через него клиенту становятся видны результаты работы сопрограммы или исключения. Объект-обещание должен поддерживать следующий интерфейс.

**Интерфейс объекта-обещания:**

| **Функция-член**           | **Описание**                                                                              |
| -------------------------- | ----------------------------------------------------------------------------------------- |
| Конструктор по умолчанию   | Должно поддерживаться создание объектов по умолчанию                                      |
| `initial_suspend()`        | Определяет, находится ли сопрограмма в приостановленном состоянии сразу после запуска     |
| `final_suspend noexcept()` | Определяет, находится ли сопрограмма в приостановленном состоянии сразу перед завершением |
| `unhandled_exception()`    | Вызывается при возникновении исключения                                                   |
| `get_return_object()`      | Возвращает возобновляемый объект, связанный с данным обещанием                            |
| `return_value(val)`        | Вызывается оператором `co_return val`                                                     |
| `return_void()`            | Вызывается оператором `co_return`                                                         |
| `yield_value(val)`         | Вызывается оператором `co_yield val`                                                      |

Компилятор автоматически вставляет вызовы этих функций, когда создаёт исполняемый код сопрограммы. В разделе о процессе функционирования сопрограмм подробно рассказано о том, при каких условиях и в какой последовательности вызываются эти функции.

Функция-член `get_return_object` возвращает объект, которым клиент может пользоваться для взаимодействия с данным обещанием и, следовательно, с сопрограммой, в том числе возобновлять вычисление. Объект-обещание должен обладать по меньшей мере одной из функций-членов `return_value`, `return_void` или `yield_value`. При этом нет нужды определять функции `return_value` и `return_void`, если сопрограмма никогда не завершается.

Функции `yield_value`, `initial_suspend` и `final_suspend` возвращают контроллер ожидания (англ. awaitable). С помощью этих объектов можно управлять приостановкой сопрограммы.

## Дескриптор сопрограммы

Дескриптор сопрограммы – это промежуточный объект, через который клиент может возобновлять выполнение сопрограммы или полностью прекращать её выполнение. Дескриптор сопрограммы является частью возобновляемой функции. Проиллюстрируем это примером. В следующем фрагменте кода показан тип генератора, обладающий своим дескриптором.

**Работа с дескриптором сопрограммы:**
```c++
template<typename T>
struct Generator {
	struct promise_type;

	using handle_type = std::coroutine_handle<promise_type>;
	handle_type coro;

	Generator(handle_type h)
		: coro(h) 
	{}

	~Generator() {
		if (coro) 
			coro.destroy();
	}

	T getValue() {
		return coro.promise().current_value;
	}

	bool next() {
		coro.resume();
	
		return !coro.done();
	}
	
	...
}
```

Конструктор, объявленный в строке `Generator(handle_type h): coro(h) {}`, получает от вызывающей стороны дескриптор, связанный с объектом-обещанием. Функции-члены `next` (строка `bool next() { ... }`) и `getValue` (строка `T getValue() { ... }`) позволяют клиенту возобновить работу обещания или получить его текущее значение, пользуясь для этого дескриптором сопрограммы. Рассмотрим теперь применение этих объектов.

**Вызов сопрограммы:**
```c++
Generator<int> coroutineFactory();    // returns a coroutine object

auto gen = coroutineFactory();
gen.next();
auto result = gen.getValue();
```

Реализация всех функций шаблона `Generator` делегирует работу дескриптору. Так, через дескриптор можно:
- продолжить выполнение сопрограммы;
- получить из сопрограммы очередной результат вычислений;
- узнать, не завершалась ли сопрограмма;
- завершить сопрограмму и удалить связанные с ней данные из памяти.

Отметим, что состояние сопрограммы автоматически разрушается, когда заканчивается выполнение тела её функции. Обращение к переменной `coro` как к логическому значению (строка `if (coro) coro.destroy();`) даёт результат `true` только тогда, когда выполнение тела сопрограммы окончено.

> **Возобновляемые объекты должны обладать вложенным типом обещания**
> 
> Определяя тип данных, который будет представлять возобновляемые вычисления, программист должен объявить в нём тип-член `promise_type`. Возможная альтернатива состоит в том, чтобы создать специализацию шаблона `std::coroutine_traits` для типа `Generator` и определить в ней общедоступный тип-член `promise_type`.

## Кадр сопрограммы

Кадр – это внутреннее состояние сопрограммы, хранящееся обычно в куче. Он включает в себя объект-обещание, о котором уже шла речь, копию параметров, с которыми сопрограмма вызвана, данные о точках приостановки, значения локальных переменных – как тех, чьё время жизни заканчивается до текущей точки приостановки, так и тех, которые продолжают существовать после неё.

Для того чтобы оптимизировать размещение сопрограммы в памяти, нужно соблюдать два обязательных условия:
1)	время жизни сопрограммы должно полностью находиться внутри времени жизни вызывающего контекста;
2) вызывающий контекст знает размер кадра сопрограммы.

Ключевыми для механизма сопрограмм являются понятия прообраза ожидания (англ. awaitable) и контроллера ожидания (awaiter).



