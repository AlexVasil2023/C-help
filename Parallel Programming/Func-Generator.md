
# Функция-генератор

Следующая программа предельно проста. Функция `getNumbers` возвращает по порядку целые числа, начиная со значения `begin`, пока число не превысит значение `end`, с шагом `inc`. Начальное значение `begin` должно быть меньше, чем конечное значение `end`, а шаг `inc` должен быть положительным.

**Жадная функция-генератор:**
```c++
// greedyGenerator.cpp

#include <iostream>
#include <vector>

std::vector<int> getNumbers(int begin, int end, int inc = 1) {
	std::vector<int> numbers;

	for (int i = begin; i < end; i += inc) {
		numbers.push_back(i);
	}

	return numbers;
}

int main() {
	std::cout << ‘\n’;

	const auto numbers= getNumbers(-10, 11);

	for (auto n: numbers) 
		std::cout << n << “ “;

	std::cout << “\n\n”;

	for (auto n: getNumbers(0, 101, 5)) 
		std::cout << n << “ “;

	std::cout << “\n\n”;
}
```

Конечно, писать такую функцию своими руками – значит изобретать велосипед, так как эту задачу решает библиотечная функция `std::iota`. Для полноты изложения на следующем рисунке показан результат работы программы.

![[ParallelProg_109.png]]

Для нашей цели существенны две особенности этой программы. С одной стороны, в вектор `numbers`, всегда помещаются все числа из заданного диапазона – даже если вызывающий контекст обработает, скажем, лишь первые пять из тысячи элементов. С другой стороны, функцию `getNumbers` довольно легко преобразовать в ленивый генератор. Следующая программа намеренно оставлена незавершённой: в ней опущено определение шаблона `generator`.

**Ленивая функция-генератор:**
```c++
// lazyGenerator.cpp

#include <iostream>

generator<int> generatorForNumbers(int begin, int inc = 1) {
	while (true) {
		co_yield i;
	}
}

 int main() {
	std::cout << ‘\n’;

	const auto numbers = generatorForNumbers(-10);

	for (int i= 1; i <= 20; ++i) 
		std::cout << numbers() << “ “;

	std::cout << “\n\n”;

	for (auto n: generatorForNumbers(0, 5)) 
		std::cout << n << “ “;

	std::cout << “\n\n”;
}
```

Сопрограмма `generatorForNumbers` в этой новой программе возвращает генератор. Объект `numbers`, объявленный в строке 
`const auto numbers = generatorForNumbers(-10);`, 
или вызов функции-генератора в строке 
`for (auto n: generatorForNumbers(0, 5))` 
при каждом обращении возвращает очередное число. Так, цикл по диапазону (англ. range-based) запрашивает у сопрограммы результат. Сопрограмма при каждом вызове немедленно возвращает значение числа `i` (счётчика цикла) посредством оператора `co_yield` и приостанавливает своё выполнение. При следующем обращении к сопрограмме она продолжит своё выполнение с этого же места.

Выражение в строке `for (auto n: generatorForNumbers(0, 5))` демонстрирует, что вызов сопрограммы можно объединить с использованием её результата.

Нужно особо подчеркнуть одно обстоятельство. Сопрограмма generator-ForNumbers генерирует бесконечный поток чисел, поскольку цикл никогда не завершается. Это нормально, если пользовательский код запрашивает конечное число значений. Однако ситуация меняется в строке `for (auto n: generatorForNumbers(0, 5))`, поскольку цикл на пользовательской стороне должен получить из потока все данные. В этом случае цикл будет выполняться вечно.



