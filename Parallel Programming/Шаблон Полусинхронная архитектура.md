
[[#Полусинхронная архитектура|Полусинхронная архитектура]] 10.3
1. [[#Преимущества и недостатки|Преимущества и недостатки]] 10.3.1
2. [[#Шаблон «Реактор»|Шаблон «Реактор»]] 10.3.2
	1. [[#Требования|Требования]] 10.3.2.1
	2. [[#Решение|Решение]] 10.3.2.2
	3. [[#Компоненты|Компоненты]] 10.3.2.3
	4. [[#Преимущества и недостатки|Преимущества и недостатки]] 10.3.2.4
3. [[#Проактор|Проактор]] 10.3.3
	1. [[#Требования шаблона проактор|Требования]] 10.3.3.1
	2. [[#Решение шаблона проактор|Решение]] 10.3.3.2
	3. [[#Компоненты шаблона проактор|Компоненты]] 10.3.3.3
	4. [[#Преимущества и недостатки шаблона проактор|Преимущества и недостатки]] 10.3.3.4 

# Полусинхронная архитектура

Этот архитектурный шаблон позволяет разделить части системы, занимающиеся синхронной и асинхронной обработками данных, без чрезмерного удара по её общей производительности. Этот шаблон предполагает появление двух дополнительных слоёв взаимодействия, один из которых служит для синхронной обработки, а другой – для асинхронной.

![[ParallelProg_221.png]]

Шаблон «Полусинхронная архитектура» часто применяется в циклах обработки событий серверных систем и в графических интерфейсах пользователя. Цикл обработки событий обычно состоит в том, чтобы принять событие от пользователя или клиента, поставить соответствующий запрос в очередь и затем обработать этот запрос синхронным образом в отдельном потоке. Асинхронный способ приёма запросов обеспечивает высокую производительность системы, а синхронная их обработка упрощает устройство обработчика. Асинхронная и синхронная части системы разведены по различным уровням её структуры, а очередь связывает их между собой. Асинхронный уровень включает в себя низкоуровневые механизмы наподобие прерываний, тогда как синхронный уровень отвечает за более высокоуровневые операции, такие как запросы к базе данных или манипуляции с файлами. Асинхронный и синхронный уровни могут общаться между собой через промежуточный уровень – диспетчер запросов.

## Преимущества и недостатки

Преимущества полусинхронной обработки несомненны:
>
> чёткое разделение асинхронного и синхронного механизмов обработки. Низкоуровневые операции осуществляются на асинхронном, а высокоуровневые – на синхронном уровне;
> 
> наличие промежуточного слоя ослабляет зацепление между синхронной и асинхронной подсистемами;
> 
> чёткое разделение на уровни упрощает понимание, отладку, поддержку и расширение системы;
> 
> блокировка в синхронном уровне не влияет на производительность асинхронного.
> 

Данному архитектурному шаблону присущи также и некоторые недостатки:
>
> пересечение каждым запросом границ между уровнями влечёт определённые накладные расходы. Более того, это может требовать переключения контекста выполнения между режимами ядра и пользователя, поскольку асинхронные операции часто выполняются в пространстве ядра, а синхронные, как правило, в пространстве пользователя;
> 
> строгое разделение синхронного и асинхронного уровней требует либо неизменяемости данных, либо их дорогостоящего копирования.
> 

Полусинхронный принцип обработки часто применяется в системах демультиплексирования и диспетчеризации событий, подобных шаблонам «Реактор» и «Проактор».

## Шаблон «Реактор»

Шаблон «Реактор» относится к событийно-управляемым архитектурам с демультиплексированием и диспетчеризацией запросов на множество параллельно работающих серверов. Этот шаблон известен также под названиями «Диспетчер» или «Оповещатель».

### Требования

Предполагается, что система должна обрабатывать интенсивный поток запросов от клиентов. Каждый запрос обладает идентификатором типа, который позволяет назначить его определённому сервису-обработчику. При этом реактор должен удовлетворять следующим требованиям:

> не блокировать выполнение;
> 
> обеспечивать максимальную пропускную способность, сводя к минимуму переключения контекстов, копирование данных и синхронизацию;
> 
> быть легко расширяемым за счёт подключения новых или усовершенствованных сервисов-обработчиков;
> 
> не использовать сложные механизмы синхронизации.

### Решение

Для каждого поддерживаемого типа запроса нужно реализовать свой обработчик. Этот обработчик нужно зарегистрировать в реакторе. Реактор ждёт в синхронном режиме прихода очередного запроса от клиента и, когда событие приходит, использует демультиплексор событий, чтобы оповестить нужный сервис-обработчик.

### Компоненты

![[ParallelProg_222.png]]

> Ресурсы:
* соответствуют различным источникам входных данных и потребителям данных с выхода системы, например сетевым соединениям, открытым файлам или элементам графического интерфейса;
* генерируют события, такие как входящее сообщение, чтение или запись, которые ставятся в соответствующую очередь.

> Демультиплексор синхронных событий:
* в цикле ожидает очередное событие и отправляет его диспетчеру, когда его можно обработать на ресурсе без блокировки.

> Обработчик событий (абстрактный):
* определяет интерфейс для обработки событий и, возможно, генерации новых событий;
* определяет перечень функций системы.

> Обработчик событий (конкретный):
* содержит ту или иную реализацию общего интерфейса обработчика событий, отвечая за обработку конкретного вида событий.

> Реактор:
* имеет интерфейс для регистрации и удаления конкретных обработчиков событий;
* использует демультиплексор синхронных событий, а также системные вызовы наподобие `select`, `epoll`, `WaitForMultipleObjects` для ожидания событий;
* ставит в соответствие событиям соответствующие конкретные обработчики;
* управляет временем жизни цикла обработки событий.

Реактор (а не приложение) ожидает событий, чтобы затем демультиплексировать их и отправить на обработку походящему обработчику. Конкретные обработчики регистрируются в реакторе. Тем самым шаблон «Реактор» как бы переворачивает поток управления. Подобную инверсию часто называют «принципом Голливуда».

Следующий фрагмент кода представляет собой цикл обработки событий в каркасе ACE (Adaptive Communication Environment)5.

**Цикл обработки событий в каркасе ACE:**
```c++
// CTRL c
SignalHandler *mutateTimer1= new SignalHandler( timerId1 );

// CTRL z
SignalHandler *mutateTimer2= new SignalHandler( timerId2 );

ACE_Reactor::instance()->register_handler( SIGINT, mutateTimer1);
ACE_Reactor::instance()->register_handler( SIGTSTP, mutateTimer2);

// “run” the timer.
Timer::instance ()->wait_for_event ();
```

Сначала определяются два обработчика сигналов, которые будут использованы для комбинаций клавиш `Ctrl+C` и `Ctrl+Z`, затем они регистрируются в реакторе. Последняя строка запускает цикл обработки событий.

### Преимущества и недостатки

Шаблон «Реактор» имеет ряд сильных сторон:
* чёткое разделение на каркас и прикладную логику;
* модульная структура конкретных обработчиков событий;
* разделение интерфейса и реализации упрощает модификацию и расширение функций системы;
* общая структура системы хорошо подходит для параллельной работы.

К недостаткам шаблона можно отнести следующее.
* демультиплексор событий нуждается в системных вызовах;
* долго выполняющийся обработчик событий может заблокировать реактор;
* инверсия потока управления усложняет тестирование и отладку системы.

Шаблон полусинхронной обработки часто используется совместно с шаблоном «Реактор» для обслуживания запросов в отдельном потоке.

Шаблон «Проактор» представляет собой асинхронный вариант шаблона «Реактор». Если в шаблоне «Реактор» демультиплексирование события и отправка его конкретному обработчику выполняются синхронно, то в шаблоне «Проактор» это делается асинхронно.

## Проактор

Шаблон «Проактор» позволяет событийно-управляемому приложению демультиплексировать и отправлять на обработку запросы, вызванные завершением асинхронных операций.

### Требования шаблона проактор

Производительность событийно-управляемых приложений, таких как серверы, часто удаётся повысить за счёт параллельной обработки нескольких асинхронных запросов. Чтобы добиться этого, приложение должно по возможности избегать синхронизации и переключений контекста. Кроме того, нужно обеспечить простоту подключения новых сервисов-обработчиков, а приложение в целом должно быть защищено от проблем, присущих параллельной и многопоточной обработке.

### Решение шаблона проактор

Приложение разбивается на две части: к одной относятся продолжительные операции, выполняющиеся асинхронно, а к другой – обработчики завершения, которым поступают результаты этих операций. Обработчик завершения работает подобно обработчику события в шаблоне «Реактор». Выполнение асинхронной операции часто возлагается на операционную систему. Подобно шаблону «Реактор», шаблон «Проактор» содержит цикл обработки событий.

Отличие же проактора от реактора состоит в следующем. В ответ на запрос клиента обработка запускается асинхронным образом и выполняется без блокирования вызывающего потока. Когда операция завершается, она помещает соответствующее событие в очередь. Проактор ожидает появления событий в очереди, используя демультиплексор асинхронных событий. Асинхронный демультиплексор удаляет событие завершения операции из очереди, и проактор отправляет его на обработку подходящему обработчику завершения.

### Компоненты шаблона проактор

Шаблон «Проактор» состоит из девяти компонентов.

![[ParallelProg_223.png]]

> Ресурс:
* служит обёрткой над объектом операционной системы – например, сетевым соединением, – способным генерировать сигнал о завершении операции.

> Асинхронная операция:
* обычно продолжительная операция, выполняемая асинхронно. Например, это может быть операция чтения данных из сетевого соединения или отправка данных по сети.

> Исполнитель асинхронных операций:
* запускает асинхронную операцию и ставит событие её завершения в очередь.

> Обработчик завершения:
* общий интерфейс для обработки результатов асинхронной операции.

> Конкретный обработчик завершения:
* реализует конкретный способ обработки результата той или иной асинхронной операции.

> Очередь событий завершения:
* хранит события завершения до тех пор, пока демультиплексор не извлечёт их для дальнейшей обработки.

> Демультиплексор асинхронных событий:
* блокируется, пока в очереди не появится событие завершения асинхронной операции;
* выбирает событие из очереди и отправляет на обработку.

> Проактор:
* вызывает демультиплексор асинхронных событий, чтобы получить из очереди очередное событие завершения операции;
* распознаёт вид события и отправляет его соответствующему обработчику.

> Инициатор:
* вызывает асинхронную операцию;
* взаимодействует с исполнителем асинхронных операций.

### Преимущества и недостатки шаблона проактор

Преимущества шаблона «Проактор» таковы:
* асинхронные операции, не связанные со спецификой приложения, отделены от функциональности, составляющей суть данного конкретного приложения;
* интерфейс проактора можно использовать на различных операционных системах, подставляя лишь различные демультиплексоры асинхронных событий;
* приложениям не нужно запускать новые потоки, так как продолжительные асинхронные операции выполняются в потоке, который их вызывает;
* отсутствуют накладные расходы на переключение контекстов;
* поскольку приложение не запускает потоки, нет нужды в их синхронизации.

Недостатки у шаблона «Проактор» также имеются:
* чтобы извлечь выгоду из применения этого шаблона, операционная система должна обладать встроенной поддержкой асинхронных операций;
* вследствие отделения во времени и пространстве запуска операции от её завершения программу бывает весьма сложно отлаживать;
* вызовы асинхронных операций и хранение результатов их завершения требуют дополнительной памяти.

