
[[#Ожидание отложенного вычисления|Ожидание отложенного вычисления]] 5.4
1. [[#Прообраз ожидания|Прообраз ожидания]] 5.4.1
2. [[#Общие требования к контроллерам ожидания|Общие требования к контроллерам ожидания]] 5.4.2
3. [[#Стандартные контроллеры ожидания|Стандартные контроллеры ожидания]] 5.4.3
4. [[#Функция initial_suspend|Функция initial_suspend]] 5.4.4
5. [[#Функция final_suspend|Функция final_suspend]] 5.4.5
6. [[#Получение контроллера ожидания|Получение контроллера ожидания]] 5.4.6

# Ожидание отложенного вычисления

Функции-члены `yield_value`, `initial_suspend` и `final_suspend` возвращают прообразы ожидания.

## Прообраз ожидания

Прообраз ожидания (англ. awaitable) – это объект, на основе которого создаётся контроллер ожидания (awaiter), а от последнего уже зависит, будет ли сопрограмма делать паузу в своём выполнении. Компилятор автоматически генерирует вызовы функций-членов, которые возвращают прообразы ожидания, в случаях, показанных в следующей таблице.

**Генерируемые компилятором вызовы:**

| **Ситуация**         | **Генерируемый вызов**              |
| -------------------- | ----------------------------------- |
| Начало выполнения    | `co_await prom.initial_suspend()`   |
| `co_yield value`     | `co_await prom.yield_value (value)` |
| `co_return value`    | `co_await prom.yield_value(value)`  |
| Окончание выполнения | `co_await prom.final_suspend()`     |

Аргументом оператора `co_await` должен быть прообраз ожидания. Оператор `co_await` преобразовывает их в контроллеры ожидания.

## Общие требования к контроллерам ожидания

Чтобы считаться контроллером ожидания, объект должен поддерживать три функции-члена:

**Интерфейс контроллера ожидания:**

| **Функция**     | **Описание**                                                                                   |
| --------------- | ---------------------------------------------------------------------------------------------- |
| `await_ready`   | Оповещает о том, что результат вычислений готов                                                |
| `await_suspend` | Вызывается при приостановке сопрограммы и управляет последующим возобновлением её работы       |
| `await_resume`  | Вызывается при возобновлении работы сопрограммы и устанавливает результат оператора `co_await` |

В стандарте C++20 определены два простейших контроллера ожидания: `std::suspend_always` и `std::suspend_never`.

## Стандартные контроллеры ожидания

Как и явствует из названия, контроллер `std::suspend_always` всегда приостанавливает сопрограмму. Для этого его функция `await_ready` всегда возвращает значение `false`.

**Контроллер ожидания `std::suspend_always`:**
```c++
struct suspend_always {
	constexpr bool await_ready() const noexcept { return false; }
	constexpr void await_suspend(std::coroutine_handle<>) const noexcept {}
	constexpr void await_resume() const noexcept {}
};
```

Контроллер ожидания `std::suspend_never` ведёт себя прямо противоположным образом. С ним сопрограмма никогда не приостанавливается, потому что функция `await_ready` всегда возвращает значение `true`.

**Контроллер ожидания `std::suspend_never`:**
```c++
struct suspend_never {
	constexpr bool await_ready() const noexcept { return true; }
	constexpr void await_suspend(std::coroutine_handle<>) const noexcept {}
	constexpr void await_resume() const noexcept {}
};
```

Контроллеры ожидания играют роль строительных блоков при создании таких функций, как `initial_suspend` и `final_suspend`. Эти функции вызываются автоматически на соответствующих этапах жизни сопрограммы: в начале и в конце её выполнения.

## Функция initial_suspend

Если функция `initial_suspend`, член объекта-обещания, возвращает объект `std::suspend_always`, сопрограмма приостанавливается сразу после запуска. Если же она возвращает объект `std::suspend_never`, сопрограмма не делает остановки. Отсюда получаем две следующие реализации.

**Ленивая сопрограмма:**
```c++
std::suspend_always initial_suspend() {
	return {};
}
```

**Жадная сопрограмма**
```c++
std::suspend_never initial_suspend() {
	return {};
}
```

## Функция final_suspend

Если функция `final_suspend`, член объекта-обещания, возвращает объект `std::suspend_always`, сопрограмма приостанавливается непосредственно перед завершением. Если же она возвращает объект `std::suspend_never`, сопрограмма не делает остановки. Отсюда получаем две следующие реализации.

**Ленивая сопрограмма:**
```c++
std::suspend_always final_suspend() noexcept {
	return {};
}
```

**Жадная сопрограмма:**
```c++
std::suspend_never final_suspend() noexcept {
	return {};
}
```

Таким образом, теперь в наших руках есть прообразы ожидания и контроллеры ожидания. Нужно ещё понять, как из прообраза получается контроллер.

## Получение контроллера ожидания

Есть два способа из имеющегося прообраза ожидания получить контроллер ожидания:

- с помощью перегруженного оператора `co_await`, который в качестве аргумента принимает прообраз ожидания и возвращает контроллер ожидания;
- если подходящей перегрузки этого оператора нет, контроллером ожидания становится сам прообраз ожидания.

Вспомним, что в выражениях вида `co_await expression` выражение `expression` является прообразом ожидания. Это выражение обычно представляет собой вызов функции-члена у объекта-обещания: `prom.yield_value(value)`, `prom.initial_suspend()` или `prom.final_suspend()`. Обозначим через `awatiable` этот объект-прообраз. Компилятору предстоит каким-то способом из прообраза построить контроллер ожидания, чтобы затем вызвать его функции-члены `await_ready`, `await_suspend` и `await_resume`.

Для этого компилятор выполняет поиск подходящего преобразования в таком порядке:

1. Сначала он пытается найти перегрузку оператора `co_await` среди функций-членов объекта `awatiable`:
	```c++
	awaiter = awaitable.operator co_await();
	```

2. Также компилятор пытается найти перегрузку оператора `co_await` среди свободно стоящих функций (т. е. не членов класса):
	```c++
	awaiter = operator co_await(awaitable);
	```

3. Если это не удаётся, объект `awatiable` становится контроллером ожидания:
	```c++
	awaiter = awaitable;
	```

> **Прообраз и есть контроллер ожидания**
> 
> Изучая приводимые далее примеры, читатель наверняка заметит, что в них почти всегда имеет место последний случай: прообраз ожидания неявно сам становится контроллером ожидания. Лишь в примере, посвящённом синхронизации потоков, используется перегруженный оператор `co_await`, чтобы в явном виде получить контроллер ожидания.

Теперь, когда статический аспект сопрограмм вполне изучен, пришла пора разобраться с динамическими аспектами.



