
[[#Модификации и обобщения генераторов|Модификации и обобщения генераторов]]
1. [[#Модификации программы|Модификации программы]] 6.6.1
	1. [[#Если сопрограмму не пробуждать|Если сопрограмму не пробуждать]] 6.6.1.1 


# Модификации и обобщения генераторов

Прежде чем видоизменить и обобщить генератор бесконечного потока данных, рассмотрим снова первоначальную реализацию как отправную точку долгого пути. В текст программы добавлен вывод многочисленных диагностических сообщений, а главная функция запрашивает из бесконечного потока только три элемента.

**Генератор бесконечного потока данных:**
```c++
// infiniteDataStreamComments.cpp

#include <coroutine>
#include <memory>
#include <iostream>

template<typename T>
struct Generator {
	struct promise_type;
	using handle_type = std::coroutine_handle<promise_type>;
	handle_type coro;

	Generator(handle_type h): coro(h) {
		std::cout << “Generator::Generator\n”;
	}

	~Generator() {
		std::cout << “Generator::~Generator\n”;
		
		if ( coro ) 
			coro.destroy();
	}

	Generator(const Generator&) = delete;
	Generator& operator = (const Generator&) = delete;

	Generator(Generator&& oth): coro(oth.coro) {
		oth.coro = nullptr;
	}
	
	Generator& operator= (Generator&& oth) {
		coro = oth.coro;
		oth.coro = nullptr;
		return *this;
	}
	
	int getNextValue() {
		std::cout << “Generator::getNextValue\n”;

		coro.resume();
		return coro.promise().current_value;
	}
	
	struct promise_type {
		promise_type() {
			std::cout << “promise_type::promise_type\n”;
		}
		
		~promise_type() {
			std::cout << “promise_type::~promise_type\n”;
		}

		std::suspend_always initial_suspend() {
			std::cout << “promise_type::initial_suspend\n”;
			
			return {};
		}
		
		std::suspend_always final_suspend() noexcept {
			std::cout << “promise_type::final_suspend\n”;
			
			return {};
		}

		auto get_return_object() {
			std::cout <<”promise_type::get_return_object\n”;

			return Generator{handle_type::from_promise(*this)};
		}
		
		std::suspend_always yield_value(int value) {
			std::cout << “promise_type::yield_value\n”;
			
			current_value = value;
			return {};
		}
		
		void return_void() {}

		void unhandled_exception() {
			std::exit(1);
		}
		
		T current_value;
	};
};

Generator<int> getNext(int start = 10, int step = 10) {
	std::cout << “getNext: start\n”;

	auto value = start;
	while (true) {
		std::cout << “getNext: before co_yield\n”;

			co_yield value;
		
		std::cout << “getNext: after co_yield\n”;

		value += step;
	}
}

int main() {
	auto gen = getNext();

	for (int i = 0; i <= 2; ++i) {
		auto val = gen.getNextValue();
		std::cout << “main: “ << val << ‘\n’;
	}
}
```

Если запустить эту программу (например, в среде `Compiler Explorer`), она напечатает текст, делающий процесс её выполнения очевидным.

![[ParallelProg_183.png]]

Рассмотрим процесс выполнения программы подробнее. Вызов функции `getNext` в строке `auto gen = getNext();` приводит к созданию объекта класса `Generator<int>`. Для этого в первую очередь создаётся объект типа `promise_type` (строка `struct promise_type{ ... }`), затем вызов функции `get_return_object` (строка `auto get_return_object() { ... }`) создаёт объект-генератор (строка `return Generator{handle_type::from_promise(*this)};`) и сохраняет объект-обещание, завёрнутый в дескриптор сопрограммы, в переменной-члене `coro` объекта-генератора. Результат этого вызова возвращается клиенту, когда сопрограмма приостанавливается в первый раз. Первоначальная приостановка происходит сразу после создания программы (строка `std::suspend_always initial_suspend()`). Поскольку функция `initial_suspend` возвращает контроллер ожидания типа `std::suspend_always`, выполнение возвращается в функцию `getNext` и продолжается до оператора `co_yield` в строке `co_yield value;`. Этот оператор приводит в функцию `yield_value` (строка `std::suspend_always yield_value(int value)`), которая запоминает очередное значение, которое в дальнейшем будет отдано клиенту. Функция `yield_value` возвращает контроллер ожидания типа `std::suspend_always`, поэтому выполнение сопрограммы приостанавливается, а управление передаётся в главную функцию, которая запускает цикл `for` в строке `for (int i = 0; i <= 2; ++i)`. Вызов функции `getNextValue` объекта-генератора `gen` в строке `auto val = gen.getNextValue();` возобновляет выполнение сопрограммы путём вызова функции `resume` для дескриптора сопрограммы (строка `coro.resume();`). Затем функция `getNextValue` возвращает текущее значение, которое было сохранено в объекте-обещании при предыдущем вызове функции `yield_value` (строка `std::suspend_always yield_value(int value)`). Наконец, сгенерированное сопрограммой значение выводится на печать в строке `std::cout << “main: “ << val << ‘\n’;`, и цикл продолжает свою работу со следующей итерации. В конце работы программы уничтожаются генератор и обещания.

После подробного разбора этой программы можно внести в неё первое изменение.

## Модификации программы

Код и нумерация строк в этом разделе остаются теми же, что и в предыдущем примере. Для краткости здесь будем показывать лишь изменившиеся участки кода.

### Если сопрограмму не пробуждать

Если убрать из кода программы строки, вызывающие пробуждение сопрограммы (вызов функции `getNextValue` в строке `auto val = gen.getNextValue();` и печать значения в строке `std::cout << “main: “ << val << ‘\n’;`), сопрограмма останавливается сразу после создания.























