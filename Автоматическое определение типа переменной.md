# Автоматическое определение типа переменной C++11 #

Возможность определять тип данных в другом типе данных приводит к написанию длинных строчек кода, как это показано в примере ниже:
```c++
template <class Type>
class adapter{
    Type _object;
public:
    typedef Type* pointer_type;
    adapter(Type p): _object(p) {}
    pointer_type pointer() { return &_object; }
    // ...
};
adapter<int> a(5);
adapter<int>::pointer_type p = a.pointer();
```

Цепочка, указанная в последней строчке может быть очень длинной, и её запись затрудняет как написание кода, так и его читаемость. Поэтому, в новом стандарте было предложено компилятору определять автоматически тип переменной (при указании ключевого слова auto), по его значению:
```c++
auto val = 5;
adapter<int> a(val); 
auto p = a.pointer();
```

В указанном примере компилятор автоматически определит, что у переменной val тип int, у переменной p – тип adapter<int>::pointer_type.
