
[[#executor|Исполнители]] 7.1
1. [[#Долгий путь исполнителя|Долгий путь исполнителя]] 7.1.1
2. [[#Что такое исполнитель|Что такое исполнитель]] 7.1.2
	1. [[#Свойства исполнителя|Свойства исполнителя]] 7.1.2.1
	2. 
3. 


# executor

Исполнитель (executor) содержит набор правил касательно того, где, когда и как выполнять вызываемый объект. Они представляют собой основные блоки, из которых строится выполнение программы, и определяют, должен ли тот или иной код выполняться в произвольном потоке, в пуле потоков или даже в едином потоке без распараллеливания. От них зависят расширения [[future|фьючерсов]], расширения для работы с сетью N4734, а также параллельные алгоритмы из стандартной библиотеки; другие средства параллельного программирования из стандартов C++ 20/23, такие как [[Latch_and_Barrier#Класс std latch|защёлки]], [[Latch_and_Barrier#Класс std barrier|барьеры]], [[Особенности сопрограмм|сопрограммы]], транзакционная память и [[task|блоки заданий]], также смогут использовать исполнители. 

Исполнители призваны стать основными блоками, из которых строится процесс выполнения программы; их роль можно сравнить с той, которую в языке C++ уже играют аллокаторы и контейнеры. Предполагается, что исполнителями будут пользоваться функции наподобие [[async#std async|std::async]], [[Parallel programming#Стандарт C++ 17. Параллельные алгоритмы в стандартной библиотеке|параллельные алгоритмы из стандартной библиотеки]], продолжения фьючерсов, функция-член `run` блока заданий, а также функции `post`, `dispatch`, `defer` из предполагаемого будущего модуля для работы с сетью. Да и вообще говоря, исполнение – одно из основополагающих понятий программирования. Однако в нынешнем стандарте нет единого способа управления способом выполнения функции. Рассмотрим пример, с которого начинается предложение к стандарту P07612.

**Различные реализации параллельного цикла:**
```c++
void parallel_for(int facility, int n, function<void(int)> f) {
	if(facility == OPENMP) {
		#pragma omp parallel for
		for(int i = 0; i < n; ++i) {
			f(i);
		}
	}
	else if(facility == GPU) {
		parallel_for_gpu_kernel<<<n>>>(f);
	}
	else if(facility == THREAD_POOL) {
		global_thread_pool_variable.submit(n, f);
	}
}
```

Представленная здесь функция `parallel_for` обладает рядом недостатков.

* Простая, казалось бы, функция оказывается сложной в поддержке, причём сложность поддержки растёт с добавлением новых механизмов параллельного выполнения.
* Ветки условного оператора по-разному ведут себя с точки зрения синхронизации. Механизм `OpenMP` может блокировать выполнение до тех пор, пока не закончат работу дочерние потоки, графический процессор обычно работает асинхронно, а пул потоков может как блокировать выполнение, так и не блокировать. Недостаточная синхронизация потоков может привести к гонке данных или к мёртвой блокировке. В лучшем случае программа может оказаться в состоянии гонки.
* Функция навязывает вызывающему контексту слишком жёсткие ограничения. Например, нет никакого способа передать в неё свой пул потоков взамен глобального.

## Долгий путь исполнителя

В октябре 2018 года было написано несколько предложений касательно исполнителей, принцип их работы до сих пор требует уточнения по ряду аспектов. Эта глава основана главным образом на предложении о принципе устройства исполнителей P07611 и на формальных описаниях P04332 и P12443. У этих предложений есть неплохие шансы войти в стандарт C++ 23. В этой главе также рассмотрим относительно новое предложение P10554 о «скромных» исполнителях.

## Что такое исполнитель

Прежде всего нужно ответить на вопрос, что собой представляет рассматриваемая сущность. Исполнитель – это набор правил, определяющих, где, когда и как запускать вызываемую единицу выполнения.

* Где. Вызываемая единица может выполняться на центральном процессоре, передаваться для выполнения на внешний или вспомогательный процессор – от этого зависит, каким образом можно получить результат вычисления.
* Когда. Вызываемую сущность можно выполнить немедленно или запланировать её выполнение на более позднее время.
* Как. Выполнение может происходить на центральном процессоре, графическом процессоре или посредством векторизации.

Если говорить более формально, исполнитель – это набор свойств, связанных с некоторой функцией выполнения.

### Свойства исполнителя

Следующие свойства можно связать с исполнителем двумя способами: механизм `execution::require` требует непременного выполнения свойства, а механизм `execution::prefer` означает, что в процессе выполнения кода следует предпочесть данное свойство, если это возможно. Перечень свойств приведён ниже.

* Направленность: функция выполнения может работать по принципу «выстрели и забудь» (`execution::oneway`), вернуть фьючерс (`execution::twoway`) или вернуть продолжение (`execution::then`).
* Кардинальность: функция выполнения может создать одного агента выполнения (`execution::single`) или множество таких агентов (`execution::bulk`).
* Блокировка: выполнение функции может блокировать или не блокировать текущий поток. Имеется три стратегии блокирования: `execution::blocking::never` запрещает блокировку, `execution::blocking::possibly` разрешает, а `execution::blocking::always` требует её.

























