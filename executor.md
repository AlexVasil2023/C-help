
[[#executor|Исполнители]] 7.1
1. [[#Долгий путь исполнителя|Долгий путь исполнителя]] 7.1.1
2. [[#Что такое исполнитель|Что такое исполнитель]] 7.1.2
	1. [[#Свойства исполнителя|Свойства исполнителя]] 7.1.2.1
3. [[#Первые примеры|Первые примеры]] 7.1.3
	1. [[#Использование исполнителя|Использование исполнителя]] 7.1.3.1
		1. [[#Асинхронное обещание|Асинхронное обещание]] 7.1.3.1.1
		2. [[#Обход элементов контейнера|Обход элементов контейнера]] 7.1.3.1.2
		3. [[#Сетевое соединение с использованием системного исполнителя|Сетевое соединение с использованием системного исполнителя]] 7.1.3.1.3
		4. [[#Сетевое соединение с использованием явно заданного исполнителя|Сетевое соединение с использованием явно заданного исполнителя]] 7.1.3.1.4
	2. [[#Получение исполнителя|Получение исполнителя]] 7.1.3.2
		1. [[#Получение исполнителя из статического пула потоков|Получение исполнителя из статического пула потоков]] 7.1.3.2.1
		2. [[#Получение исполнителя из параллельной политики выполнения|Получение исполнителя из параллельной политики выполнения]] 7.1.3.2.2
		3. [[#Системный исполнитель по умолчанию|Системный исполнитель по умолчанию]] 7.1.3.2.3
		4. [[#Применение адаптера к существующему исполнителю|Применение адаптера к существующему исполнителю]] 7.1.3.2.4
4. [[#Цели разработки исполнителей|Цели разработки исполнителей]] 7.1.4
5. [[#Терминология|Терминология]] 7.1.5
6. [[#Функции выполнения|Функции выполнения]] 7.1.6
7. 
8. 
9. 
		6. 
		7. 
	4. 
10. 

# executor

Исполнитель (executor) содержит набор правил касательно того, где, когда и как выполнять вызываемый объект. Они представляют собой основные блоки, из которых строится выполнение программы, и определяют, должен ли тот или иной код выполняться в произвольном потоке, в пуле потоков или даже в едином потоке без распараллеливания. От них зависят расширения [[future|фьючерсов]], расширения для работы с сетью N4734, а также параллельные алгоритмы из стандартной библиотеки; другие средства параллельного программирования из стандартов C++ 20/23, такие как [[Latch_and_Barrier#Класс std latch|защёлки]], [[Latch_and_Barrier#Класс std barrier|барьеры]], [[Особенности сопрограмм|сопрограммы]], транзакционная память и [[task|блоки заданий]], также смогут использовать исполнители. 

Исполнители призваны стать основными блоками, из которых строится процесс выполнения программы; их роль можно сравнить с той, которую в языке C++ уже играют аллокаторы и контейнеры. Предполагается, что исполнителями будут пользоваться функции наподобие [[async#std async|std::async]], [[Parallel programming#Стандарт C++ 17. Параллельные алгоритмы в стандартной библиотеке|параллельные алгоритмы из стандартной библиотеки]], продолжения фьючерсов, функция-член `run` блока заданий, а также функции `post`, `dispatch`, `defer` из предполагаемого будущего модуля для работы с сетью. Да и вообще говоря, исполнение – одно из основополагающих понятий программирования. Однако в нынешнем стандарте нет единого способа управления способом выполнения функции. Рассмотрим пример, с которого начинается предложение к стандарту P07612.

**Различные реализации параллельного цикла:**
```c++
void parallel_for(int facility, int n, function<void(int)> f) {
	if(facility == OPENMP) {
		#pragma omp parallel for
		for(int i = 0; i < n; ++i) {
			f(i);
		}
	}
	else if(facility == GPU) {
		parallel_for_gpu_kernel<<<n>>>(f);
	}
	else if(facility == THREAD_POOL) {
		global_thread_pool_variable.submit(n, f);
	}
}
```

Представленная здесь функция `parallel_for` обладает рядом недостатков.

* Простая, казалось бы, функция оказывается сложной в поддержке, причём сложность поддержки растёт с добавлением новых механизмов параллельного выполнения.
* Ветки условного оператора по-разному ведут себя с точки зрения синхронизации. Механизм `OpenMP` может блокировать выполнение до тех пор, пока не закончат работу дочерние потоки, графический процессор обычно работает асинхронно, а пул потоков может как блокировать выполнение, так и не блокировать. Недостаточная синхронизация потоков может привести к гонке данных или к мёртвой блокировке. В лучшем случае программа может оказаться в состоянии гонки.
* Функция навязывает вызывающему контексту слишком жёсткие ограничения. Например, нет никакого способа передать в неё свой пул потоков взамен глобального.

## Долгий путь исполнителя

В октябре 2018 года было написано несколько предложений касательно исполнителей, принцип их работы до сих пор требует уточнения по ряду аспектов. Эта глава основана главным образом на предложении о принципе устройства исполнителей P07611 и на формальных описаниях P04332 и P12443. У этих предложений есть неплохие шансы войти в стандарт C++ 23. В этой главе также рассмотрим относительно новое предложение P10554 о «скромных» исполнителях.

## Что такое исполнитель

Прежде всего нужно ответить на вопрос, что собой представляет рассматриваемая сущность. Исполнитель – это набор правил, определяющих, где, когда и как запускать вызываемую единицу выполнения.

* Где. Вызываемая единица может выполняться на центральном процессоре, передаваться для выполнения на внешний или вспомогательный процессор – от этого зависит, каким образом можно получить результат вычисления.
* Когда. Вызываемую сущность можно выполнить немедленно или запланировать её выполнение на более позднее время.
* Как. Выполнение может происходить на центральном процессоре, графическом процессоре или посредством векторизации.

Если говорить более формально, исполнитель – это набор свойств, связанных с некоторой функцией выполнения.

### Свойства исполнителя

Следующие свойства можно связать с исполнителем двумя способами: механизм `execution::require` требует непременного выполнения свойства, а механизм `execution::prefer` означает, что в процессе выполнения кода следует предпочесть данное свойство, если это возможно. Перечень свойств приведён ниже.

* Направленность: функция выполнения может работать по принципу «выстрели и забудь» (`execution::oneway`), вернуть фьючерс (`execution::twoway`) или вернуть продолжение (`execution::then`).
* Кардинальность: функция выполнения может создать одного агента выполнения (`execution::single`) или множество таких агентов (`execution::bulk`).
* Блокировка: выполнение функции может блокировать или не блокировать текущий поток. Имеется три стратегии блокирования: `execution::blocking::never` запрещает блокировку, `execution::blocking::possibly` разрешает, а `execution::blocking::always` требует её.
* Способ продолжения: задание может выполняться в клиентском вызывающем потоке (`execution::continuation`) или нет (`execution::not_continuation`).
* Вероятность будущего задания: это свойство определяет, насколько вероятно появление задания в будущем (свойство `execution::outstanding_work::tracked` означает, что появление задания в будущем ожидается, а свойство `execution::outstanding_work::untracked` – что это маловероятно).
* Гарантии массового продвижения вперёд: какие имеются гарантии совокупного продвижения вперёд множества создаваемых агентов выполнения: `execution::bulk_sequenced_execution`, `execution::bulk_parallel_execution` и `execution::bulk_unsequenced_execution`.
* Гарантии размещения по потокам: должен ли каждый агент выполнения назначаться на отдельный поток (режим `execution::new_thread_execution_mapping`) или нет (режим `execution::thread_execution_mapping`).
* Аллокатор: к исполнителю может быть привязан объект, ответственный за управление памятью.

Программист может также добавлять собственные свойства.

> **Исполнители как строительные блоки**
> 
> Поскольку исполнители предполагается сделать основными строительными блоками процесса выполнения программы, средства параллельного программирования в будущем стандарте языка C++ должны сильно зависеть от них. Это в первую очередь касается расширенных фьючерсов, сетевых расширений, описанных в документе N47341, параллельных алгоритмов стандартной библиотеки, а также новых средств: защёлок, барьеров, сопрограмм, транзакционной памяти и блоков заданий.

## Первые примеры

### Использование исполнителя

Разберём ряд примеров, иллюстрирующих использование исполнителей.

#### Асинхронное обещание

**Асинхронное выполнение обещания посредством исполнителя:**
```c++
// как-либо получить объект-исполнитель
my_executor_type my_executor = ...

// запустить асинхронное выполнение
auto future = std::async(my_executor, [] {
	std::cout << "Hello world, from a new execution agent!" << '\n';
});
```

#### Обход элементов контейнера

**Обход элементов контейнера с использованием исполнителя:**
```c++
// как-либо получить объект-исполнитель
my_executor_type my_executor = ...

// запустить параллельный обход контейнера
std::for_each(std::execution::par.on(my_executor),
						data.begin(), data.end(), func);
```

#### Сетевое соединение с использованием системного исполнителя

**Использование системного исполнителя для приёма соединения:**
```c++
// как-либо получить объект для приёма входящих соединений
tcp::acceptor my_acceptor = ...

// выполнить асинхронную операцию для приёма соединения
acceptor.async_accept(
		[](std::error_code ec, tcp::socket new_connection)
			{
			...
			});
```

#### Сетевое соединение с использованием явно заданного исполнителя

**Использование системного исполнителя для приёма соединения:**
```c++
// как-либо получить объект для приёма входящих соединений
tcp::acceptor my_acceptor = ...

// получить объект-исполнитель, связанный с пулом потоков
auto my_thread_pool_executor = ...

// выполнить асинхронную операцию для приёма соединения
acceptor.async_accept(
	std::experimental::net::bind_executor(my_thread_pool_executor,
	[](std::error_code ec, tcp::socket new_connection)
	{
	...
	}
	));
```

Функция `bind_executor` из экспериментального модуля для поддержки сети позволяет подставить в асинхронную функцию сетевого взаимодействия пользовательский объект-исполнитель. В данном примере обработчик соединения выполнит [[Lambda|лямбда-функцию]] в пуле потоков.

### Получение исполнителя

Есть различные способы получить объект-исполнитель.

#### Получение исполнителя из статического пула потоков

**Получение исполнителя из статического пула потоков**
```c++
// создать пул на 4 потока
static_thread_pool pool(4);

// получить объект-исполнитель, связанный с пулом потоков
auto exec = pool.executor();

// использовать исполнителя для запуска продолжительного задания
auto task1 = long_running_task(exec);
```

#### Получение исполнителя из параллельной политики выполнения

**Получение исполнителя из параллельной политики выполнения:**
```c++
// получить объект-исполнитель, связанный с параллельной политикой
auto par_exec = std::execution::par.executor();

// использовать исполнителя для запуска продолжительного задания
auto task2 = long_running_task(par_exec);
```

#### Системный исполнитель по умолчанию

Исполнитель по умолчанию обычно предполагает создание нового потока для выполнения задания. Этот исполнитель используется в случае, если никакой другой исполнитель не задан явно.

#### Применение адаптера к существующему исполнителю

**Применение адаптера к существующему исполнителю:**
```c++
// получить объект-исполнитель, связанный с пулом потоков
auto exec = pool.executor();

// обернуть исполнителя в адаптер, выводящий диагностические сообщения
logging_executor<decltype(exec)> logging_exec(exec);

// отсортировать контейнер под управлением исполнителя с адаптером
std::sort(std::execution::par.on(logging_exec),
					my_data.begin(), my_data.end());
```

Исполнитель `logging_executor` в этом примере представляет собой адаптер поверх исполнителя, связанного с пулом потоков.

## Цели разработки исполнителей

Ниже перечислены цели, которыми руководствовались авторы документа P10551, формулируя понятие исполнителя.

1. **Дозируемость** – возможность управлять балансом между затратами на передачу вызываемого объекта и его размером.
2. **Гетерогенность** – возможность запускать вызываемый объект в разнородных средах (таких как графический процессор или внешний процессор) и получать назад результат вычислений.
3. **Упорядочиваемость** – возможность задавать порядок, в котором запускаются вызываемые объекты. Сюда относятся такие гарантии порядка выполнения, как стек (LIFO – last in, first out), очередь (FIFO – first in, first out), очередь с приоритетами, расписание или последовательное выполнение.
4. **Управляемость** – возможность назначить вызываемый объект на определённый вычислительный ресурс, отложить или отменить выполнение.
5. **Продолжаемость** – поддержка сигналов, позволяющих управлять асинхронным выполнением вызываемого объекта. Эти сигналы позволяют оповещать о готовности результата, о возникновении ошибки, а также о желании вызывающего клиента прервать выполнение задания. Также должны быть возможны явный запуск вызываемого объекта и отмена запуска запланированного задания.
6. **Многослойность** – иерархическое строение исполнителей должно поддерживать добавление свойств, не внося лишнюю сложность в прос­тые сценарии использования.
7. **Удобство** как со стороны разработчика исполнителей, так и со стороны автора прикладного кода, пользующегося исполнителями, составляет особенно важную цель.
8. **Комбинируемость** – программисту должна быть предоставлена возможность расширять исполнителей свойствами, не предусмотренными в стандарте.
9. **Минималистичность** – в понятие исполнителя, реализованное в стандарте языка, не должны входить никакие детали, которые можно было бы добавить извне, реализовав в некоторой сторонней библиотеке.

## Терминология

В документе-предложении P0761 определен ряд новых терминов, относящихся к выполнению вызываемого объекта.

* **Выполняющий ресурс** – экземпляр аппаратного или программного ресурса, способный выполнять вызываемый объект. Примерами выполняющего ресурса могут служить векторный модуль процессора или система выполнения, управляющая множеством потоков. Такие выполняющие ресурсы, как центральный или графический процессор, гетерогенны, так как их возможности и ограничения сильно различаются от экземпляра к экземпляру.
* **Контекст выполнения** – программный объект, представляющий определённый набор выполняющих ресурсов и агентов выполнения. Типичными примерами могут служить пул потоков, а также распределённая или гетерогенная вычислительная система.
* **Агент выполнения** – единица выполнения внутри определённого контекста выполнения, связанная с одним вызовом вызываемого объекта на выполняющем ресурсе. Примерами могут быть поток на центральном процессоре или единица выполнения на графическом процессоре.
* **Исполнитель** – программный объект, связанный с определённым контекстом выполнения. Он предоставляет одну или более функций для создания агента выполнения для заданного вызываемого объекта (например, функционального объекта или функции).

## Функции выполнения














