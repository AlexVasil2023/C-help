# Операции копирования и перемещения C++11

Открытый интерфейс каждого класса должен явно указывать, какие операции копирования и/или перемещения он поддерживает. Обычно это делается в секции **public** в виде явных деклараций нужных функций или объявлением их как **delete**.  
  
В частности, копирумый класс должен явно объявлять операции копирования; только перемещаемый класс должен явно объявить операции перемещения; некопируемый/неперемещаемый класс должен явно запретить (**`= delete`**) операции копирования. Явная декларация или удаление всех четырёх функций копирования и перемещения также допустима, хотя это и не требуется. Если вы реализуете оператор копирования и/или перемещения, то необходимо также сделать соответствующий конструктор.
```c++
class Copyable { 
	public:  
		Copyable(const Copyable& other) = default;  
		Copyable& operator=(const Copyable& other) = default;  
		// Неявное определение операций перемещения будет запрещено 
		// (т.к. объявлено копирование)
};

class MoveOnly { 
	public:  
		MoveOnly(MoveOnly&& other);  
		MoveOnly& operator=(MoveOnly&& other);  
		// Неявно определённые операции копирования удаляются. 
		//Но (если хотите) можно это записать явно:  
		MoveOnly(const MoveOnly&) = delete;  
		MoveOnly& operator=(const MoveOnly&) = delete;
};

class NotCopyableOrMovable { 
	public:  // Такое объявление запрещает и копирование и перемещение  
		NotCopyableOrMovable(const NotCopyableOrMovable&) = delete;  
		NotCopyableOrMovable& operator=(const NotCopyableOrMovable&) = delete;  
		// Хотя операции перемещения запрещены (неявно), можно записать это явно:  
		NotCopyableOrMovable(NotCopyableOrMovable&&) = delete;  
		NotCopyableOrMovable& operator=(NotCopyableOrMovable&&) = delete;
};
```

Описываемые объявления или удаления функций можно опустить в очевидных случаях:  
  >- Если класс не содержит секции **private** (например, структура `struct` или класс-интерфейс), то копируемость и перемещаемость можно заявить через аналогичное свойство любого открытого члена.
>- Если базовый класс явно некопируемый и неперемещаемый, наследные классы будут такими же. Однако, если базовый класс не объявляет это операции, то этого будет недостаточно для прояснения свойств наследуемых классов.
>- Заметим, что если (например) конструктор копирования объявлен/удалён, то нужно и явно объявить/удалить оператор копирования (т.к. его статус неочевиден). Аналогично и для объявления/удаления оператора копирования. Аналогично и для операций перемещения.

Тип не следует объявлять копируемым/перемещаемым, если для обычного программиста не понятна необходимость этих операций или если операции очень требовательны к ресурсам и производительности. Операции перемещения для копируемых типов это всегда оптимизация производительности, но с другой стороны — это потенциальный источник багов и усложнений. Поэтому не объявляйте операции перемещения, если они не дают значительного выигрыша по производительности по сравнению с копированием. Вообще желательно (если для класса заявляются операции копирования) всё спроектировать так, чтобы использовались функции копирования по-умолчанию. И обязательно проверьте корректность работы любых операций по-умолчанию.  
  
Из-за риска «слайсинга» предпочтительным будет избегать открытых операторов копирования и перемещения для классов, которые планируется использовать в качестве базовых (и предпочтительно не наследоваться от класса с такими функциями). Если же необходимо сделать базовый класс копируемым, то сделайте открытую виртуальную функцию **Clone()** и защищённый (**protected**) конструктор копий с тем, чтобы производный класс мог их использовать для реализации операций копирования.
