# Структурированные привязки и множественное присваивание #
Структурированные привязки – совершенно новый феномен, и при этом очень полезный. Они обеспечивают множественное присваивание от структурированных типов (например, [[Кортежи|кортежей]], [[Массивы и структуры|массивов и структур]]) – например, присваивание всех членов структуры отдельным переменным в единственной инструкции присваивания. Использование структурных привязок делает код в целом более чистым и понятным. Примеры кода со структурными привязками запускают на Linux при помощи коммпилятора clang++ версии 4 с флагом -std=c++1z, активирующим возможности C++17.  
В C++11 появились [[Кортежи|кортежи]], аналогичные массивам в том, что и те, и другие являются коллекциями фиксированной длины, но могут содержать смесь различных типов. При помощи кортежа можно вернуть от функции более одного значения, вот так:
```c++
#include <tuple> 

auto get() {	
	return std::make_tuple("fred", 42);
}
```
Этот простой код возвращает кортеж с двумя элементами, и, начиная со стандарта C++14, можно использовать auto возвращаемыми типами этой функции, благодаря чему объявление этой функции получается гораздо чище, чем в противном случае. Вызывать функцию просто, но получение значений из кортежа может выглядеть довольно неаккуратно и нелогично, при этом может потребоваться `std::get`:
```c++
auto t = get();
std::cout << std::get<0>(t) << std::endl;
```
Также можно воспользоваться [[tie|std::tie]] для привязки членов кортежа к переменным, которые сначала требуется объявить:
```c++
std::string name;
int age; 

std::tie(name, age) = get();
```
Однако, работая со структурированными привязками в C++17, можно связывать члены кортежей непосредственно с именованными переменными, и тогда необходимость в [[get|std::get]] отпадает, либо сначала объявлять переменные:
```c++
auto [name, age] = get();
std::cout << name << " is " << age << std::endl;
```
Работая таким образом, мы также можем получать ссылки на члены кортежа, а это было невозможно при применении [[tie|std::tie]]. Здесь мы получаем ссылки на члены кортежа и, когда меняем значение одного из них, изменяется значение всего кортежа:
```c++
auto t2 = std::make_tuple(10, 20);
auto& [first, second] = t2;
first += 1;
std::cout << "value is now " << std::get<0>(t2) << std::endl;
```
Вывод покажет, что значение `t2` изменилось с 10 на 11.

# Структурированные привязки для массивов и структур #

Случай с кортежами наиболее очевиден, но структурированные привязки также можно использовать с массивами и структурами, например:
```c++
struct Person {	
	std::string name;	
	uint32_t age;	
	std::string city;
}; 

Person p1{"bill", 60, "New York"};
auto [name, age, city] = p1;

std::cout << name << "(" << age << ") lives in " << city << std::endl;
```
С массивами точно так же:
```c++
std::array<int32_t, 6> arr{10, 11, 12, 13, 14, 15};
auto [i, j, k, l, _dummy1, _dummy2] = arr;
```
В этой реализации прослеживается пара недостатков:  
> - Во-первых — и этот недостаток также актуален для [[tie|std::tie]] — приходится привязывать все элементы. Поэтому невозможно, к примеру, извлечь из массива лишь первые четыре элемента. Если вы хотите частично извлечь cтруктуру или массив, то просто подставьте переменные-заглушки для тех членов, что вам не нужны, как показано в примере с массивом.  
> - Во-вторых (и это разочарует программистов, привыкших использовать такую идею в функциональных языках, например, в Scala и Clojure), деструктуризация действует лишь на один уровень в глубину. Допустим, у меня в структуре Person есть член `Location`:
```c++
struct Location {	
	std::string city;	
	std::string country;
}; 

struct Person {	
	std::string name;	
	uint32_t age;	
	Location loc;
};
```
  Можно сконструировать `Person` и `Location`, воспользовавшись вложенной инициализацией:
```c++
Person2 p2{"mike", 50, {"Newcastle", "UK"}};
```
Можно предположить, что привязка в данном случае пригодится и для доступа к членам, но на практике оказывается, что такая операция недопустима:
```c++
auto [n, a, [c1, c2]] = p2;  // не скомпилируется
```
Извлекать таким образом члены можно лишь из тех классов, в которых нужные вам данные являются общедоступными и нестатическими. Подробнее этот вопрос рассмотрен в следующей статье о [[структурированные привязки|структурированных привязках.]]















## Кортежи
см [[Кортежи|Кортежи C++17]]

## Массивы и структуры
см [[Массивы и структуры|Массивы и структуры C++17]]