# Массивы и структуры C++17 #
Кроме кортежей, структурированные привязки можно применять к массивам и структурам:
```c++
struct Person { 
	std::string name; 
	uint32_t age; 
	std::string city; 
}; 

Person p1{"bill", 60, "New York"}; 
auto [name, age, city] = p1; 

std::cout << name << "(" << age << ") lives in " << city << std::endl;
```

То же с массивами:
```c++
std::array<int32_t, 6> arr{10, 11, 12, 13, 14, 15}; 
auto [i, j, k, l, _dummy1, _dummy2] = arr;
```

Но в этих примерах есть недостатки:
> - Структурированные привязки не применяются к части элементов, только ко всем сразу. Это обусловлено ограничениями **std::tie.** Если какие-то элементы не нужно привязывать, можно использовать подготовленные для этого мусорные переменные, как в примере с массивом (_dummy1, _dummy2).
> - Деструктуризация будет работать только на один уровень вглубь.

К примеру, в Person имеется элемент Location:
```c++
struct Location { 
	std::string city; 
	std::string country; 
}; 

struct Person { 
	std::string name; 
	uint32_t age; 
	Location loc; 
};
```

Соберем Person и Location, используя вложенную инициализацию:
```c++
Person2 p2{"mike", 50, {"Newcastle", "UK"}};
```

все это работает только для классов с публичными и нестатичными данными