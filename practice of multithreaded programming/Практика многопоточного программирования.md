32
Энтони Уильямс. C++. Практика многопоточного программирования.

1. [[#Что такое конкурентность|Что такое конкурентность]] 1.1
	1. [[#Конкурентность в компьютерных системах|Конкурентность в компьютерных системах]] 1.1.1
	2. [[#Подходы к конкурентности|Подходы к конкурентности]] 1.1.2
	3. [[#Сравнение конкурентности и параллелизма|Сравнение конкурентности и параллелизма]] 1.1.3










# Что такое конкурентность

На самом элементарном уровне ***===конкурентность===*** — это одновременное выполнение двух и более отдельных задач. За примерами из обычной жизни далеко ходить не надо: мы можем одновременно идти и разговаривать, а еще выполнять разные действия левой и правой руками; каждый из нас живет своей жизнью независимо от других людей — пока я буду плавать, вы можете смотреть футбол и т. д.

## Конкурентность в компьютерных системах

Когда речь заходит о конкурентности в контексте компьютеров, подразумевается отдельно взятая система, выполняющая несколько независимых задач в параллельном, а не последовательном (одна за другой) режиме. Эта идея не нова. Многозадачные операционные системы, позволяющие настольному компьютеру запускать одновременно несколько приложений с помощью переключения задач были обычным явлением на протяжении многих лет, как и высокопроизводительные серверы с несколькими процессорами, обеспечивавшие действительно параллельные вычисления. Новым является массовое распространение компьютеров, способных по-настоящему выполнять несколько задач в параллельном режиме, а не создавать иллюзию этого процесса.

Исторически сложилось так, что у большинства настольных компьютеров был один процессор с одним вычислительным блоком или ядром, да и сегодня для многих настольных компьютеров ничего в этом смысле не изменилось. Такая машина в конкретный момент времени выполняет только одну задачу, но может переключаться между задачами множество раз в секунду. При выполнении небольшой части одной задачи, затем небольшой части другой и т. д. создается впечатление, что задачи решаются одновременно. Это называется переключением задач. Имея в виду такие системы, мы все же говорим о конкурентности, поскольку переключение задач происходит так быстро, что невозможно сказать, в какой момент задача может быть приостановлена из-за переключения процессора на выполнение другой задачи. Переключение между задачами создает иллюзию конкурентности как для пользователя, так и для самих приложений. Поскольку это всего лишь иллюзия таких вычислений, поведение приложений при выполнении в среде переключения задач с одним процессором может немного отличаться от их поведения при выполнении в среде с истинным параллелизмом. В частности, неверные допущения о модели памяти (рассматриваемой в #главе_5) могут не проявляться в такой среде. Более подробно этот вопрос обсуждается в #главе_10.

Компьютеры c несколькими процессорами в течение многих лет использовались в качестве серверов и для решения вычислительных задач, для которых требуется высокопроизводительное оборудование, а компьютеры на базе процессоров с несколькими ядрами на одном кристалле (многоядерные процессоры) теперь получают все большее распространение в качестве настольных. Независимо от того, имеют компьютеры несколько процессоров или несколько ядер в процессоре (или и то и другое), они способны выполнять несколько задач в параллельном режиме. Это называется ***===аппаратной конкурентностью===***.

На рис. 1.1 схематически показан сценарий работы компьютера с двумя задачами, каждая из которых разделена на десять одинаковых этапов. На двухъядерной машине (имеющей два вычислительных ядра) каждая задача может выполняться в собственном ядре. На одноядерном компьютере, переключающем задачи, этапы задач чередуются. Кроме того, они немного разнесены по времени, что показано серыми разделительными полосами, более толстыми по сравнению с разделительными полосами на схеме для двухъядерной машины. Чтобы выполнить чередование, система при каждом переходе от одной задачи к другой должна переключать контекст, на что требуется время. Чтобы переключить контекст, операционная система должна сохранить состояние центрального процессора и указатель команд для выполняемой в данный момент задачи, определить, на какую задачу переключиться, и перезагрузить состояние центрального процессора для задачи, на которую происходит переключение. В таком случае центральному процессору, возможно, придется загружать в кэш-память инструкции и данные для новой задачи, что может помешать ему выполнять любые другие инструкции и привести к еще большей задержке.

![[practice_multithreaded-1.png]]
Рис. 1.1. Два подхода к конкурентности: параллельное выполнение на компьютере с двумя ядрами и переключение задач на одноядерной машине

Хотя возможности конкурентности нагляднее проявляются в многопроцессорных или многоядерных системах, некоторые процессоры могут выполнять несколько потоков и на одном ядре. Следует учитывать очень важный фактор — количество аппаратных потоков, то есть то количество независимых задач, которое оборудование может выполнить действительно одновременно. В то же время в системе с истинным аппаратным параллелизмом количество задач может превышать количество ядер, и тогда будет применяться механизм переключения задач. Например, на обычном настольном компьютере могут выполняться сотни задач, работающих в фоновом режиме, даже если машина номинально простаивает. Именно благодаря переключению эти задачи могут выполняться параллельно и можно одновременно открыть текстовый процессор, компилятор, редактор и браузер (или любую комбинацию приложений). На **рис. 1.2** показано такое переключение между четырьмя задачами на двухъядерном компьютере, опять же для идеализированного сценария, где задачи делятся на этапы одинаковой длительности. На практике в силу многих причин деление не будет таким равномерным, а переключение — таким распределенным. Некоторые из этих причин рассматриваются в #главе_8 при изучении факторов, влияющих на производительность конкурентного кода.

![[practice_multithreaded-2.png]]

Все технические приемы, функции и классы, рассматриваемые в данной книге, можно задействовать независимо от того, на каком компьютере выполняется ваше приложение — с одним одноядерным процессором или с несколькими многоядерными процессорами. И неважно, как именно реализуется конкурентность — путем переключения задач или за счет настоящего аппаратного параллелизма. Но, наверное, понятно, что способ обеспечения конкурентности в вашем приложении может зависеть от доступного оборудования. Соответствующие вопросы рассматриваются в #главе_8 при изучении задач, связанных с разработкой на C++ конкурентного кода.

## Подходы к конкурентности

Представьте двух программистов, работающих вместе над одним программным проектом. Если они находятся в разных кабинетах, то могут работать спокойно, не мешая друг другу и пользуясь каждый своим набором справочников. Но вот общаться им непросто. Вместо того чтобы развернуться лицом друг к другу и поговорить, они вынуждены звонить по телефону, писать по электронной почте или же вставать и идти в другой кабинет к коллеге. Кроме того, приходится нести затраты на аренду двух помещений и приобретение нескольких экземпляров справочников.

А теперь представьте, что разработчики сидят в одном кабинете. Они могут свободно общаться, обсуждать проект приложения, рисовать схемы на бумаге или доске, обмениваться своими идеями.

Теперь нужно содержать только один кабинет, и зачастую достаточно будет только одного набора ресурсов. В то же время разработчикам может быть труднее сосредоточиться, и вполне реальны проблемы с общими ресурсами («Куда опять подевался справочник?»).

Эти два способа организации труда разработчиков позволяют проиллюстрировать два основных подхода к конкурентности. Каждый разработчик представляет поток, а каждый кабинет — процесс. Первый подход состоит в том, чтобы иметь несколько однопоточных процессов, что похоже на работу каждого разработчика в собственном кабинете, а второй подход предполагает наличие нескольких потоков в одном процессе, что похоже на работу двух разработчиков в одном помещении.

На такой основе можно составлять какие угодно комбинации и иметь несколько процессов, часть которых являются многопоточными, а часть — однопоточными, но действуют по одним и тем же принципам. Теперь кратко рассмотрим эти два подхода к конкурентности в приложении.

***==Конкурентность с использованием нескольких процессов==***

Первый способ применения параллелизма в приложении — разделение приложения на несколько конкурентных процессов с одним потоком. Например, так происходит при одновременном запуске браузера и текстового процессора. В дальнейшем отдельные процессы могут пересылать сообщения по всем обычным каналам межпроцессного обмена данными (используя сигналы, сокеты, файлы, конвейеры и т. д.) (**рис. 1.3**). Один из недостатков способа заключается в том, что либо такую связь между процессами сложно установить, либо она слишком медленно работает, либо наблюдается и то и другое. Так происходит из-за того, что операционные системы при обмене данными между процессами обычно предпринимают множество защитных мер, чтобы один процесс не мог случайно изменить данные, принадлежащие другому процессу. Еще одним недостатком является то, что выполнение нескольких процессов сопряжено с накладными расходами: на запуск процесса требуется время, операционная система для управления им должна выделять внутренние ресурсы и т. д. 

Но не все так плохо: операционные системы с дополнительной защитой обычно обеспечивают взаимодействие процессов и механизмов обмена данными более высокого уровня, а это значит, что конкурентный код может быть проще создавать с процессами, а не с потоками. И действительно, в среде, подобной той, что предусмотрена для языка программирования `Erlang` (www.erlang.org/), в качестве основного механизма конкурентности весьма эффективно используются именно процессы.

У использования отдельных процессов для реализации конкурентности есть и дополнительное преимущество — процессы можно запускать на разных компьютерах, входящих в одну сеть. Хотя это и увеличивает затраты на обмен данными, в качественно спроектированной системе способ может стать экономически эффективным для повышения степени конкурентности и увеличения производительности.

![[practice_multithreaded-3.png]]
Рис. 1.3. Обмен данными между двумя одновременно запущенными процессами.

***===Конкурентность с применением нескольких потоков===***

Альтернативный подход к конкурентности состоит в выполнении нескольких потоков в одном процессе. Потоки очень похожи на облегченные процессы: каждый из них реализуется независимо от других и может выполнять собственную последовательность инструкций. Но все потоки в процессе используют общее адресное пространство, и непосредственный доступ к основной части данных можно получить из всех потоков. При этом глобальные переменные остаются глобальными, а указатели или ссылки на объекты или данные можно передавать между потоками. Для процессов можно организовать доступ к разделяемой памяти, но эта функция трудно поддается настройке и управлению, потому что адреса размещения в памяти одних и тех же элементов не обязательно будут одинаковыми для разных процессов. На **рис. 1.4** показаны два потока внутри процесса, обменивающиеся данными через общую память.

Наличие общего адресного пространства и отсутствие защиты данных между потоками существенно сокращают издержки, связанные с использованием нескольких потоков, по сравнению с издержками при выполнении нескольких процессов, так как снижается нагрузка на операционную систему. Но гибкость, обусловленная применением общей памяти, сопряжена и с затратами: если доступ к данным получают несколько потоков, программист должен убедиться, что представление данных, видимых каждым потоком, согласовано при каждом обращении к этим данным. Вопросы, связанные с обменом данными между потоками, используемые для их решения инструменты, а также рекомендации, которых следует придерживаться во избежание возникновения проблем, рассматриваются в книге повсеместно, особенно в #главах_3-5 и #главе_8 . Проблемы вполне решаемы при условии, что при создании кода вы будете осмотрительны, а это означает, что обмен данными между потоками следует тщательно продумать.

![[practice_multithreaded-4.png]]
Рис. 1.4. Обмен данными между двумя потоками, запущенными одновременно в одном процессе

Низкие издержки на запуск потоков внутри процесса и обмен данными между ними стали причиной популярности этого подхода во всех распространенных языках программирования, включая С++, даже несмотря на потенциальные проблемы, связанные с разделением памяти. Кроме того, стандарт C++ не предусматривает встроенной поддержки обмена данными между процессами, из-за чего приложениям с несколькими процессами придется полагаться на API, зависящие от платформы. Поэтому данная книга посвящена исключительно конкурентности на основе многопоточности, и в дальнейшем при любом упоминании конкурентности предполагается, что она реализуется использованием нескольких потоков.

Для многопоточного кода часто употребляется другое слово — «параллелизм». Давайте уточним, в чем здесь различия.

## Сравнение конкурентности и параллелизма

Для многопоточного кода значения понятий ***==«конкурентность»==*** и ***==«параллелизм»==*** в значительной степени пересекаются. Действительно, для многих они означают одно и то же. Разница в первую очередь заключается в нюансах, фокусе и намерениях. Оба термина относятся к одновременному выполнению нескольких задач с использованием доступного оборудования, но параллелизм более явно ориентирован на производительность. О параллелизме говорят, когда главной заботой становится использование имеющегося оборудования для повышения производительности массовой обработки данных, тогда как при конкурентности основная забота — разделение задач, требующих одновременного решения, или оперативность реагирования. Такая двойственность до сих пор существует, и значения этих двух понятий все еще существенно совпадают, но знать, в чем их различие, полезно при обсуждении рассматриваемых вопросов. В этой книге будут встречаться примеры использования обоих понятий.

Уточнив, что именно подразумевается под конкурентностью и параллелизмом, давайте выясним, зачем нужна конкурентность в приложениях.





































