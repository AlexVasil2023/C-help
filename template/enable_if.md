[[#enable_if|enable_if]]
[[#Отключение шаблонов с помощью enable_if<>|Отключение шаблонов с помощью enable_if<>]] 6.3(template)
[[#Использование enable_if<>|Использование enable_if<>]] 6.4(template)
[[#Применение концептов для упрощения выражений enable_if<>|Применение концептов для упрощения выражений enable_if<>]] 6.5(template)
[[#enable_if_t<>|enable_if_t<>]]


# enable_if
#std_enable_if

# Отключение шаблонов с помощью enable_if<>

Начиная с С++11, в стандартной библиотеке C++ имеется вспомогательный шаблон [[enable_if|std::enable_if<>]], позволяющий игнорировать шаблоны функций при определенных условиях времени компиляции.

Например, если шаблон функции `fоо<>()` определен следующим образом:
```c++
template<typename Т>
typename std::enable_if < (sizeof(Т) > 4) >::type
foo ()
{  }
```

то это определение `foo<>()` игнорируется, если условие `sizeof(Т) > 4` дает `false`. Если `sizeof(Т) > 4` дает `true`, то шаблон функции раскрывается до
```c++
foo ()
{  }
```

То есть [[enable_if|std::enable_if<>]] представляет собой свойство типа, которое вычисляет заданное выражение времени компиляции, переданное в качестве его (первого) аргумента шаблона, и ведет себя следующим образом.

> Если выражение вычисляется как `true`, член-тип `type` дает тип:
* `void`, если второй аргумент не передан;
* в противном случае — второй аргумент шаблона.

> Если выражение вычисляется как `false`, член-тип `type` не определен. Благодаря возможности шаблонов, которая называется [[SFINAE#SFINAE|SFINAE (substitution failure is not an error — ошибка подстановки ошибкой не является)]], шаблон функции с выражением [[enable_if#enable_if|enable_if]] в этом случае игнорируется.

Как и для всех свойств типов, которые представляют собой тип, начиная с С++14, имеется соответствующий шаблон псевдонима [[enable_if#enable_if_t<>|std::enable_if_t<>]], который [[Шаблоны классов#Псевдонимы типов|позволяет опустить typename и ::type]].

Таким образом, начиная с C++14, можно написать
```c++
template<typename Т>
std::enable_if_t < (sizeof(T) > 4) >
foo ()
{  }
```

Если передать в [[enable_if#enable_if|enable_if<>]] или [[enable_if#enable_if_t<>|enable_if_t<>]] второй аргумент:
```c++
template<typename Т>
std::enable_if_t < (sizeof(T) > 4), Т >
foo()
{
	return Т();
}
```

то конструкция [[enable_if|enable_if]] раскроется до этого второго аргумента, если значение выражения будет вычислено как `true`. Так что, если `МуТуре` представляет собой конкретный тип, переданный или выведенный как `Т`, и его размер окажется больше 4, результатом будет
```c++
МуТуре foo();
```

Обратите внимание на то, что выражение [[enable_if|enable_if]] в середине объявления является довольно неуклюжей конструкцией. По этой причине наиболее распространенным способом использования [[enable_if#enable_if|std: :enable_if<>]] является использование дополнительного аргумента шаблона функции со значением по умолчанию:
```c++
template<typename Т, typename = std::enable_if_t<(sizeof(T)> 4)
void foo()
{  }
```

Такая запись при `sizeof (Т) > 4` раскрывается в
```c++
template<typename Т, typename = void>
void foo()
{  }
```

Если и это все еще выглядит слишком неуклюжим, и вы хотите сделать требование/ограничение более явно выраженным, с помощью шаблона псевдонима можно определить для него собственное имя:
```c++
template<typename Т>
using EnableIfSizeGreater4 = std::enable_if_t <(sizeof(T) > 4)>;
template<typename T, typename = EnableIfSizeGreater4<T>>
void foo()
{  }
```

Вопросы реализации [[enable_if|std::enable_if]] рассмотрены в [[Перегрузка свойств типов#Включение/отключение шаблонов функций|Включение/отключение шаблонов функций]].

# Использование enable_if<>

Мы можем использовать [[enable_if#enable_if|enable_if<>]] для решения нашей проблемы с шаблоном конструктора [[Семантика перемещения - Шаблоны специальных функций-членов - template|см. тут]].

Задача, которую мы должны решить, — это отключение объявления шаблонного конструктора
```c++
template<typename STR>
Person(STR&& n);
```

если переданный аргумент `STR` имеет правильный тип (является [[string|std::string]] или типом, преобразуемым в [[string|std::string]]).

Для этого мы воспользуемся еще одним стандартным свойством типа [[is_convertible#std is_convertible|std::is_convertible<FROM, ТО>]]. Начиная с С++17, соответствующее объявление имеет следующий вид:
```c++
template<typename STR, 
		typename = std::enable_if__t<
				std::is_convertible_v<STR, std::string>>>
Person(STR&& n) ;
```

Если тип `STR` может быть преобразован в тип [[string|std::string]], полное объявление раскрывается в
```c++
template<typename STR, typename = void>
Person(STR&& n);
```

Если тип `STR` не может быть преобразован в [[string|std::string]], весь шаблон функции игнорируется.

И вновь для ограничения с помощью шаблона псевдонима можно определить собственное имя:
```c++
template<typename Т>
using EnableifString = std::enable_if_t <
	std::is_convertible_v<T, std::string>>;
template<typename STR, typename = EnableifString<STR>>
Person(STR && n);
```

Таким образом, весь класс `Person` должен имеет следующий вид:
```c++
#include <utility>
#include <string>
#include <iostream>
#include <type_traits>

template<typename T>
using EnableIfString = std::enable_if_t <
			std::is_convertible_v<T, std::string >>;
class Person
{
	private:
		std::string name;
		
	public:
		// Обобщенный конструктор для передачи начального имени:
		template<typename STR, typename = EnableIfString<STR>>
		explicit Person(STR && n)
			: name(std::forward<STR>(n))
		{
			std::cout << "Шаблонный конструктор для '" << name << "'\n";
		}
		
		// Копирующий и перемещающий конструкторы:
		Person(Person const& p) : name(p.name)
		{
			std::cout << "Копирующий конструктор Person '"
					<< name << "'\n";
		}
		
		Person(Person&& p) : name(std::move(p.name))
		{
			std::cout << "Перемещающий конструктор Person '"
					<< name << "'\n";
		}
};
```

Теперь все ведет себя так, как и ожидалось:
```c++
#include "specialmemtmpl3.hpp"

int main()
{
	std::string s = "sname";
	
	Person p1(s);               // Инициализация строковым объектом =>
								// вызов шаблонного конструктора
	Person p2("tmp");           // Инициализация строковым литералом =>
								// вызов шаблонного конструктора
	Person p3(p1);              // ОК, вызов копирующего конструктора
	Person p4(std::move(pi));   // ОК, вызов перемещающего конструктора
)
```

И вновь заметим, что в C++14 из-за отсутствия версии `_v` для свойств типов, возвращающих значения, мы должны объявить шаблон псевдонима следующим образом:
```c++
template<typename Т>
using EnableIfString = std::enable_if_t <
						std::is_convertible<T, std::string>::value >;
```

А в C++11 из-за отсутствия версии `_t` для свойств типов, возвращающих типы, мы должны объявить шаблон специальной функции следующим образом:
```c++
template<typename Т>
using EnableIfString = typename std::enable_if<
		std::is_convertible<T, std::string>::value>::type;
```

Но все это теперь скрыто в определении `EnableIfString<>`.

Заметим также, что имеется альтернатива использованию [[is_convertible|std::is_convertible<>]], потому эта конструкция требует, чтобы типы были неявно преобразуемы. С помощью [[is_constructible|std::is_constructible<>]] мы также позволяем использовать для инициализации явные преобразования. Однако в этом случае порядок аргументов является противоположным:
```c++
template<typename Т>
using EnableIfString = std::enable_if_t <
						std::is_constructible_v<std::string, T >>;
```

> **Отключение специальных функций-членов**

Обратите внимание: как правило, мы не можем использовать [[enable_if|enable_if<>]] для отключения стандартных копирующих/перемещающих конструкторов и операторов присваивания. Причина заключается в том, что шаблоны функций-членов никогда не учитываются как специальные функции-члены и игнорируются, когда, например, требуется копирующий конструктор. Таким образом, при наличии объявления
```c++
class С
{
	public:
		template<typename Т>
		С(Т const&)
		{
			std::cout << "Шаблонный копирующий конструктор \п";
		}
	...
};
```

при необходимости получения копии `С` используется предопределенный копирующий конструктор:
```c++
С х;
С у{х};         // Используется предопределенный копирующий конструктор
				// (не шаблон функции-члена)
```

(В действительности нет способа использования шаблона члена, потому что нет никакого способа указать или вывести его параметр шаблона `Т`.)

Удаление предопределенного копирующего конструктора решением не является, потому что попытка скопировать `С` приводит к ошибке.

Тем не менее имеется одно хитрое решение. Можно объявить копирующий конструктор для аргументов `const volatile` и пометить его как удаленный (т.е. определить его с `=delete`). Это предотвращает неявное объявление другого копирующего конструктора. При этом можно определить шаблон конструктора, который для типов, не являющихся [[volatile|volatile]], будет предпочтительнее (удаленного) копирующего конструктора:
```c++
class С
{
	public:

	...
	
			// Определяем предопределенный копирующий конструктор как
			// удаленный (с преобразованием в volatile для того, чтобы
			// обеспечить лучшее совпадение)
		С (С const volatiles) = delete;
		
			// Реализация шаблона копирующего конструктора
			// с лучшим соответствием:
		template<typename Т>
		С(Т const&)
		{
			std::cout << "Шаблонный копирующий конструктор\п";
		}
	
	...
	
};
```

Теперь шаблонный конструктор используется даже для “нормального” копирования:
```c++
С х;
С у{х};    // Используется шаблон члена
```

В таком шаблонном конструкторе можно использовать дополнительные ограничения с помощью [[enable_if|enable_if<>]]. Например, чтобы предотвратить возможность копирования объектов шаблона класса `С<>`, если параметр шаблона — целочисленный тип, можно написать следующий исходный текст:
```c++
template<typename Т>
class С
{
	public:

	...

		// Реализация шаблона копирующего конструктора
		//с лучшим соответствием:
		С(С const volatile&) = delete;

		// Если Т - не целочисленный тип, предоставляем шаблон
		// копирующего конструктора с лучшим соответствием:
		template<typename U,
				typename = std::enable_if_t<!std::is_integral<U>::value>>
		C(C<U> const&)
		{
			...
		}

	...

};
```

# Применение концептов для упрощения выражений enable_if<>

Даже при использовании шаблонов псевдонимов синтаксис [[enable_if|enable_if]] довольно неуклюж, поскольку использует обходной путь: для получения желаемого результата мы добавляем дополнительный параметр шаблона и “злоупотребляем” этим параметром для предоставления определенных требований к [[Шаблоны функций|шаблонам функций]], чтобы последние были в принципе доступны. Код, подобный получающемуся, трудно читать, и он делает остальные части [[Шаблоны функций|шаблона функции]] трудными для понимания.

В принципе нам нужна просто возможность языка, которая бы позволяла формулировать требования или ограничения для функции таким образом, чтобы функция игнорировалась, если она не соответствует указанным требованиям/ограничениям.

Этот вопрос должен был быть решен долгожданной возможностью языка под названием концепты (concepts), которая позволяет формулировать требования/условия для шаблонов с использованием собственного простого синтаксиса. К сожалению, несмотря на долгое обсуждение, концепты пока еще не стали частью стандарта C++17. Однако некоторые компиляторы предоставляют экспериментальную поддержку такой возможности, и, вероятно, концепты станут частью очередного, следующего после C++17, стандарта.

При наличии концептов в том виде, в котором они были предложены, нам было бы достаточно просто написать:
```c++
template<typename STR>
requires std::is_convertible_v<STR, std::string>
Person(STR&& n) : name(std::forward<STR>(n))
{
	...
}
```

Можно даже указать требование как обобщенный концепт
```c++
template<typename Т>
concept ConvertibleToString = std::is_convertible_v<T, std::string>;
```

и сформулировать этот концепт в виде требования:
```c++
template<typename STR>
requires ConvertibleToString<STR>
Person(STR&& n)
	: name(std::forward<STR>(n))
{
	...
}
```

Оно может быть сформулировано и следующим образом:
```c++
template<ConvertibleToString STR>
Person(STR&& n) : name(std::forward<STR>(n))
{
	...
}
```

Более подробно концепты C++ рассматриваются в [[Concepts#Концепты|“Концепты”]].

# enable_if_t<>
#std_enable_if_t


















