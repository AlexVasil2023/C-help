
[[#Категории значений]] Б
1. [[#Традиционные l- и r-значения|Традиционные l- и r-значения]] Б.1
2. [[rvalue|Традиционные lvalue и rvalue]]
	1. [[#Преобразования l-значений в r-значения|Преобразования l-значений в r-значения]] Б.1.1
3. [[#Категории значений, начиная с C++11|Категории значений, начиная с C++11]] Б.2
	1. [[#Временная материализация|Временная материализация]]  Б.2.1
4. [[#Проверка категорий значений с помощью decltype|Проверка категорий значений с помощью decltype]] Б.3
5. [[#Ссылочные типы|Ссылочные типы]] Б.4
6. [[#gl-значение|gl-значение]]
7. [[#pr-значения]]
8. [[#x-значения]]
9. [[#l-значение]]
10. [[#r-значения]]

# Категории значений

Выражения являются краеугольным камнем языка C++, предоставляя основной механизм, позволяющий выразить необходимые вычисления. Каждое выражение имеет тип, который описывает статический тип значения, производимого при вычислении. Так, выражение `7` имеет тип `int`, как и выражение `5+2` или выражение `х`, если `х` является переменной типа `int`. Каждое выражение имеет также категорию значения (value category), которая описывает то, как было сформировано значение, и влияет на поведение выражения.

## Традиционные l- и r-значения

Исторически изначально имелись только две категории значений: `l-значения` и `r-значения`. `L-значениями` являются выражения, ссылающиеся на фактические значения, хранящиеся в памяти или в регистре компьютера, такие как выражение `х`, где `х` — имя переменной. Эти выражения могут быть изменяемыми, позволяя обновлять сохраненное значение. Например, если `х` является переменной типа `int`, то следующее присваивание заменит значение `х` на `7`:
```c++
х = 7;
```


Термин `l-значение` ([[rvalue|lvalue]]) является производным от роли, которую это выражение могло бы играть в рамках присваивания: буква / означает “левый” потому что (исторически в языке программирования С) слева от знака присваивания могут находиться только `l-значения`. И наоборот, `r-значения` ( [[rvalue|rvalues]], где `r` означает “справа”) может находиться только в правой части выражения присваивания.

Однако после стандартизации языка С в 1989 году все изменилось: хотя по-прежнему значение `int const` хранится в памяти, оно не может находиться в левой части присваивания:
```c++
int const х;        // х - неизменяемое значение
х = 7;              // Ошибка: слева должно быть изменяемое значение
```

Изменения в C++ пошли еще дальше: класс `r-значений` может находиться слева в присваиваниях. Такие присваивания на самом деле являются вызовами функций операторов присваивания соответствующих классов, а не “простыми” присваиваниями скалярных типов, так что они управляются (отдельными) правилами вызовов функций-членов.

Учитывая все эти изменения, термин `l-значение` теперь иногда трактуется как локализуемое значение. Выражения, которые ссылаются на переменную, являются не единственными выражениями `l-значений`. Еще один класс выражений, которые являются `l-значениями`, включает операцию разыменования указателя (например, `*р`), и ссылается на значения, хранящиеся по адресу, на который указывает указатель, а также выражения, которые ссылаются на члены объектов классов (например, `p->data`). Даже вызовы функций, возвращающих значения “традиционных” ссылочных на `l-значения` типов, объявленных с использованием `&`, являются `l-значениями`. Например (см. подробности в [[r-значение#Ссылочные типы|Ссылочные типы]]):
```c++
std::vector<int> v;
v.front();                  // l-значение, так как возвращаемый тип
							// является ссылкой на l-значение
```

Возможно, это покажется удивительным, но строковые литералы также являются (неизменяемыми) l-значениями.

R-значения являются чисто математическими значениями (например, `7` или символ `' а '` ), которые не обязательно имеют связанное с ними место хранения; они существуют только для вычислений, но после того, как они были использованы, на них нельзя ссылаться. В частности, любые литеральные значения, за исключением строковых литералов (например, `7`, `' а'`, `true`, [[nullptr_t|nullptr]]), являются r-значениями, как и результаты многих встроенных арифметических вычислений (например, `х+5` для `х` целочисленного типа) и вызовов функций, возвращающих результат по значению. То есть все временные значения являются г-значениями. (Хотя это не относится к именованным ссылкам, которые ссылаются на них.)

### Преобразования l-значений в r-значения

В силу своей эфемерной природы `r-значения` ограничены присутствием только с правой стороны (“простых”) присваиваний: присваивание `7=8` не имеет смысла, потому что математическое значение `7` не может быть переопределено. С другой стороны, `l-значения` подобного ограничения не имеют: безусловно можно вычислить присваивание `х=у`, когда и `х`, и `у` являются переменными совместимого типа, даже если оба выражения `х` и `у` являются `l-значениями`.

Присваивание `х=у` работает благодаря тому, что выражение справа, `у`, подвергается неявному преобразованию, которое называется преобразованием `l-значения` в `r-значение` (`lvalue-to-rvalue conversion`). Как предполагает название, это преобразование принимает `l-значение` и выполняет чтение из памяти или регистра, связанных с `r-значением`, `r-значения` того же типа. Таким образом, это преобразование выполняет два действия: во-первых, оно гарантирует, что `l-значения` могут использоваться везде, где ожидается `г-значение` (например, в правой части присваивания или в математическом выражении наподобие `х+у`). Во-вторых, оно определяет, где в программе компилятор может включать (до оптимизации) инструкцию “загрузка” для чтения значения из памяти.

## Категории значений, начиная с C++11

Когда в C++11 для поддержки семантики перемещения были введены ссылки на `г-значение`, традиционного деления выражений на `l-значения` и `r-значения` стало недостаточно, чтобы описать все поведение C++11. Поэтому комитет по стандартизации C++ изменил систему категорий значений, основав ее на трех основных и двух составных категориях (см. рис. ). Основными категориями являются: [[#l-значение|l-значение]], [[#pr-значения|pr-значение]] (pure rvalue — чистое `r-значение`) и [[#x-значения|х-значение]]. Составными категориями являются [[#gl-значение|gl-значение]] (generalized lvalue — обобщенное `l-значение`, которое является объединением `l-значения` и `х-значения`) и [[#r-значения|r-значение]] (объединение `х-значения` и `рr-значения`).

Обратите внимание на то, что все выражения по-прежнему являются `l-значениями` или `r-значениями`, но теперь категория `r-значения` разделяется.
![[Template_B_1.png]]

Эта категоризация С++11 остается в силе, но в С++17 характеристики категорий были пересмотрены следующим образом.

> **`gl-значение`** представляет собой выражение, вычисление которого определяет идентичность объекта, битового поля или функции (сущности, имеющей место хранения).
> 
> **`pr-значение`** представляет собой выражение, вычисление которого инициализирует объект или битовое поле, или вычисляет значение операнда оператора.
> 
> **`х-значение`** представляет собой `gl-значение`, обозначающее объект или битовое поле, ресурсы которого могут быть повторно использованы (обычно из-за того, что вскоре истечет его время жизни — так что “x” в `xvalue` означает “eXpiring value” — завершающееся значение).
> 
> **`l-значение`** представляет собой `gl-значение`, не являющееся `х-значением`.
> 
> **`r-значение`** представляет собой выражение, являющееся либо `рr-значением`, либо `х-значением`.

Обратите внимание на то, что в С++17 (и в некоторой степени в С++11 и С++14) разделение `gl-значений` и `pr-значений`, возможно, более фундаментальное, чем традиционное отличие `l-значений` от `r-значений`.

Хотя это описание характеристик введено в C++17, оно применимо и в C++11 и C++14 (более ранние описания эквивалентны по смыслу, но с ними трудно работать).

За исключением битовых полей, `gl-значения` производят сущности с адресами. Этот адрес может быть адресом подобъектов большего охватывающего объекта. В случае подобъекта базового класса тип `gl-значения` (выражения) называется статическим типом, а тип наиболее производного объекта, частью которого является базовый класс, называется динамическим типом `gl-значения`. Если `gl-значение` не производит подобъект базового класса, статические и динамические типы являются идентичными (типом выражения).

Примеры **`l-значений`** таковы:
>
> Выражения, обозначающие переменные или функции.
> 
> Применения встроенного унарного оператора `*` (разыменование указателя).
> 
>Выражение, являющееся простым строковым литералом.
>
>Вызов функции с возвращаемым типом, являющимся ссылкой на l-значение.

Примеры **`pr-значений`** таковы:
>
> Выражения, которые состоят из литерала, не являющегося строковым литералом или литералом, определяемым пользователем.
> 
> Применения встроенного унарного оператора `&` (взятие адреса выражения).
> 
> Применение встроенных арифметических операторов.
> 
> Вызов функции с возвращаемым типом, который не является ссылочным типом.
> 
> Лямбда-выражения.

Примеры **`х-значений`** таковы:
>
> Вызов функции с возвращаемым типом, который представляет собой ссылку на `r-значение` на тип объекта (например, [[move|std::move()]]).
> 
> Приведение к `r-значению` ссылки на тип объекта.

Обратите внимание на то, что ссылки на `r-значение` на типы функций производят `l-значения`, а не `х-значения`.

Стоит подчеркнуть, что `gl-значения`, `pr-значения`, `х-значения` и так далее являются выражениями, а не значениями или сущностями. Например, переменная не является `l-значением`, несмотря на то, что выражение, описывающее переменную, является таковым:
```c++
int х = 3;      // Здесь х — переменная, но не l-значение. 3 является
				// pr-значением, инициализирующим переменную х.
int у = х;      // Здесь х — l-значение. Вычисление этого выражения
				// l-значения не дает значения 3, но обозначает объект,
				// содержащий значение 3. Такое l-значение затем
				// преобразуется в рr-значение, которое инициализирует у.
```

### Временная материализация

Ранее мы упоминали, что `l-значения` часто проходят преобразования `l-значения` в `r-значение`, потому что `pr-значения` представляют собой разновидность выражений, которые инициализируют объекты (или предоставляют операнды для большинства встроенных операторов).

В C++17 существует дуальное преобразование к данному, известное как временная материализация (но его можно было бы также назвать преобразованием `pr-значения` в `х-значение`): в любой момент, когда `pr-значение` корректно появляется там, где ожидается `gl-значение` (которое включает `х-значение`), создается временный объект, который инициализируется `рг-значением` (вспомните, что `pr-значения` являются главным образом инициализирующими значениями), и `pr-значение` заменяется временным `х-значением`. Например:
```c++
int f(int const&);
int r = f(3);
```

Поскольку `f()` в этом примере имеет ссылочный параметр, ожидается аргумент, являющийся `gl-значением`. Однако выражение `3` является `рr-значением`. Поэтому вступает в дело правило временной материализации, и выражение 3 “преобразуется” в `х-значение`, обозначающее временный объект, инициализированный значением 3.

В целом временное значение материализуется с инициализацией `рг-значением` в следующих ситуациях.
>
> `pr-значение` связано со ссылкой (например, как в вызове f` (3)` выше).
> 
> Доступ к члену `pr-значения` классового типа.
> 
> Индексация массива `рг-значений`.
> 
> Массив `рr-значений` преобразуется в указатель на его первый элемент {низведение массива).
> 
> `pr-значение` находится в списке инициализации в фигурных скобках, который для некоторого типа `X` инициализирует объект типа [[initializer_list|std::initializer_list<X>]].
>
> Применение операторов [[sizeof|sizeof]] или [[typeid|typeid]] к `рr-значению`.
> 
  `pr-значение` представляет собой выражение верхнего уровня в инструкции вида `“ехрг; ”` или выражение, приводимое к void.

Таким образом, в C++17 объект, инициализированный `рг-значением`, всегда определяется контекстом, и в результате временные значения создаются только тогда, когда они действительно необходимы. До С++17 `pr-значения` (в частности, классового типа) всегда подразумевали временные объекты. Копии этих временных объектов позже могли (необязательно) быть устранены, но компилятор попрежнему должен был обеспечивать большинство семантических ограничений операции копирования (например, мог требоваться вызываемый копирующий конструктор). В следующем примере показано следствие пересмотра правил в С++17:
```c++
class N
{
	public:
		N();
		N(N const&) = delete; // Этот класс некопируемый ...
		N(N&&) = delete;      // ... и не перемещаемый
};

N make_N()
{
	return N{};     // До C++17 всегда создавался концептуальный
}                   // временный объект. В С++17 временный объект
					//в этой точке не создается.
auto n = make_N();  //До С++17 - ошибка, так как pr-значение требует
					// концептуального копирования. Начиная с С++17,
					// все в порядке, так как п инициализируется
					// непосредственно рг-значением.
```

До С++17 pr-значение N{} создавало временный объект типа N, но компилято­
рам разрешалось устранять копирования и перемещения этого временного объ­
екта (что всегда делалось на практике). В данном случае это означает, что времен­
ный результат вызова make_N () может быть сконструирован непосредственно
в хранилище п; при этом не требуется никаких операций копирования или пере­
мещения. К сожалению, компиляторы, соответствующие стандартам до C++17,
по-прежнему должны проверять, что в этом примере могут быть выполнены опе­
рации копирования или перемещения; это не представляется возможным, пото­
му что копирующий и перемещающий конструкторы N удалены. Таким образом,
компиляторы с поддержкой стандарта С++11 и C++14 должны выдавать для это­
го примера сообщение об ошибке.

В случае C++17 рг-значение N само по себе не создает временный объект.
Вместо этого оно инициализирует объект, определяемый контекстом. В нашем
примере этим объектом является объект, обозначаемый как п. Никакие опера­
ции копирования или перемещения не рассматриваются (и это не оптимизация,
а гарантия языка), так что приведенный код является корректным кодом C++17.

В заключение приведем пример, который показывает различные ситуации
с категориями значений:
```c++
class X
{   }

X v;
X const с;

void f(X const&);   // Принимает выражение любой категории значений
void f(X&&);        // Принимает только рг- и х-значения, но
			        // демонстрирует для них лучшее соответствие,
			        // чем предыдущее объявление

f(v);               // Передача модифицируемого l-значения в первую f()
f(с);               // Передача неизменяемого 1-значения в первую f()
f(X());             // Передача pr-значения (начиная с С++17
					// материализуется как х-значение) во вторую f()
f(std::move(v));    // Передача х-значения во вторую f()
```

## Проверка категорий значений с помощью decltype

С помощью ключевого слова [[decltуре|decltуре]] (введенного в С++11) можно проверить категорию значения любого выражения C++. Для любого `выражения х`
**`decltype((х))`** (обратите внимание на двойные скобки!) дает:
>
> **`type`**, если `х` представляет собой `pr-значение`;
> 
> **`type &`**, если `х` представляет собой l-значение;
> 
> **`type&&`**, если `х` представляет собой `х-значение`.

Двойные скобки в **`decltype((х))`** необходимы во избежание получения объявленного типа именованной сущности в случае, когда выражение `х` представляет собой имя сущности (в других случаях скобки не производят никакого действия). Например, если выражение `х` представляет собой просто имя переменной `v`, то конструкция без скобок `decltype(v)` вернет тип переменной `v`, а не тип, отражающий категорию значения выражения `х`, ссылающегося на эту переменную.

Таким образом, используя свойства типов для выражения `е`, мы можем проверить его категорию следующим образом:
```c++
if constexpr(std::is_lvalue_reference<decltype((e))>::value)
{
	std::cout << "Выражение является l-значением \n";
}
else if constexpr(std::is_rvalue_reference<decltype((e))>::value)
{
	std::cout << "Выражение является х-значением \n";
)
else
{
	std::cout << "Выражение является pr-значением \n";
}
```

[[decltуре#Запись типа выражения с помощью decltype|Подробнее этот вопрос рассматривается]].

## Ссылочные типы

Ссылочные типы в C++ — такие как `int&` — взаимодействуют с категориями значений двумя важными способами. Во-первых, ссылка может ограничить категорию значения выражения, с которым она связана. Например, неконстантная ссылка на `l-значение` типа `int&` может быть инициализирована только выражением, которое является `l-значением` типа `int`. Аналогично ссылка на `r-значение` типа `int&&` может быть инициализирована только выражением, которое представляет собой `r-значение` типа `int`.

Во-вторых, значение категории взаимодействует со ссылками в возвращаемых типах функций, где использование ссылочного типа в качестве возвращаемого типа влияет на категорию значения вызова этой функции. В частности:
>
> вызов функции, чей возвращаемый тип представляет собой ссылку на `l-значение`, дает l-значение;
> 
> вызов функции, чей возвращаемый тип представляет собой ссылку на `r-значение` на тип объекта, дает `х-значение` (ссылки на `r-значение` на типы функций всегда дают `l-значения`);
>
> вызов функции, которая возвращает не ссылочный тип, дает `pr-значение`.

Проиллюстрируем взаимодействия между ссылочными типами и категориями значений в следующем примере. Пусть имеются следующие объявления:
```c++
int& lvalue();
int&& xvalue();
int prvalue();
```

[[decltуре|decltype]] может определять как категорию значения, так и тип данного выражения. Как [[decltуре#Запись типа выражения с помощью decltype|показано]], для описания ситуаций, когда выражение является `l-` или `х-значением`, используются ссылочные типы:
```c++
// true, так как результат - l-значение:
std::is_same_v<decltype(lvalue()), int&>

// true, так как результат - х-значение:
std::is_same_v<decltype(xvalue()), int&&>

// true, так как результат - pr-значение:
std::is_same_v<decltype(prvalue()), int>
```

Таким образом, возможны следующие вызовы:
```c++
// ОК: ссылка на l-значение связана с l-значением:
int& lref1 = lvalue();

// Ошибка: ссылка на l-значение не может быть связана с рг-значением
int& lref3 = prvalue();

// Ошибка: ссылка на l-значение не может быть связана с х-значением:
int& lref2 = xvalue();

// Ошибка: ссылка на r-значение не может быть связана с l-значением:
int&& rref1 = lvalue();

// OK: ссылка на r-значение может быть связана с pr-значением:
int&& rref2 = prvalue();

// ОК: ссылка на r-значение может быть связана с х-значением:
int&& rref3 = xvalue();
```

# gl-значение
#gl-значение

**`gl-значение`** представляет собой выражение, вычисление которого определяет идентичность объекта, битового поля или функции (сущности, имеющей место хранения).


# pr-значения
#pr-значения

**`pr-значение`** представляет собой выражение, вычисление которого инициализирует объект или битовое поле, или вычисляет значение операнда оператора.

Примеры **`pr-значений`** таковы:
>
> Выражения, которые состоят из литерала, не являющегося строковым литералом или литералом, определяемым пользователем.
> 
> Применения встроенного унарного оператора `&` (взятие адреса выражения).
> 
> Применение встроенных арифметических операторов.
> 
> Вызов функции с возвращаемым типом, который не является ссылочным типом.
> 
> Лямбда-выражения.

# x-значения
#x-значения

**`х-значение`** представляет собой `gl-значение`, обозначающее объект или битовое поле, ресурсы которого могут быть повторно использованы (обычно из-за того, что вскоре истечет его время жизни — так что “x” в `xvalue` означает “eXpiring value” — завершающееся значение).

Примеры **`х-значений`** таковы:
>
> Вызов функции с возвращаемым типом, который представляет собой ссылку на `r-значение` на тип объекта (например, [[move|std::move()]]).
> 
> Приведение к `r-значению` ссылки на тип объекта.

# l-значение
#l-значение

**`l-значение`** представляет собой `gl-значение`, не являющееся `х-значением`.

Примеры **`l-значений`** таковы:
>
> Выражения, обозначающие переменные или функции.
> 
> Применения встроенного унарного оператора `*` (разыменование указателя).
> 
>Выражение, являющееся простым строковым литералом.
>
>Вызов функции с возвращаемым типом, являющимся ссылкой на l-значение.

# r-значения
#r-значения

**`r-значение`** представляет собой выражение, являющееся либо `рr-значением`, либо `х-значением`.

