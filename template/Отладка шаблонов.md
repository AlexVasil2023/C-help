
[[#Отладка шаблонов|Отладка шаблонов]] 28
1. [[#Поверхностное инстанцирование|Поверхностное инстанцирование]] 28.1
2. [[#Статические утверждения|Статические утверждения]] 28.2
3. [[#Архетипы|Архетипы]] 28.3
4. [[#Трассировщики|Трассировщики]] 28.4
5. [[#Оракулы|Оракулы]] 28.5





# Отладка шаблонов

Когда дело доходит до отладки шаблонов, возникают два класса проблем. Первый класс проблем — проблемы авторов шаблонов: как можно гарантировать, что написанные шаблоны будут функционировать для любых аргументов шаблонов, удовлетворяющих задокументированным автором условиям? Второй класс проблем по сути обратный: как пользователь шаблона может узнать, какие требования к параметрам шаблона он нарушил, когда шаблон ведет себя не так, как документировано?

Прежде чем приступить к серьезному обсуждению этих вопросов, полезно рассмотреть виды ограничений, которые могут быть наложены на параметры шаблона. В этой главе мы в основном имеем дело с ограничениями, которые при нарушении приводят к ошибкам компиляции, и называем эти ограничения синтаксическими ограничениями. Синтаксические ограничения могут включать необходимость наличия конструкторов определенного вида, однозначность некоторого вызова функции и так далее. Прочие виды ограничений мы называем семантическими ограничениями. Эти ограничения гораздо труднее проверить механически. В общем случае это даже может быть нецелесообразным. Например, мы можем потребовать, чтобы для типового параметра шаблона был определен оператор `<` (что является синтаксическим ограничением), но обычно мы также требуем, чтобы этот оператор фактически определял некоторое упорядочение в своей области определения (что является семантическим ограничением).

Для обозначения набора ограничений, которые многократно требуются в библиотеке шаблонов, часто используется термин концепт. Например, стандартная библиотека C++ опирается на такие [[Concepts|концепты]], как итератор с произвольным доступом или имеющий конструктор по умолчанию. С учетом данной терминологии можно сказать, что отладка кода шаблонов включает значительное количество работы по выявлению того, как в реализациях шаблонов и их использованиях нарушаются [[Concepts|концепты]]. Эта глава посвящена как проектированию, так и методам отладки, которые облегчают работу с шаблонами как для их авторов, так и для пользователей.

# Поверхностное инстанцирование

Когда происходит ошибка в шаблоне, проблема часто выявляется после длинной цепочки инстанцирований, что приводит к [[Применение шаблонов на практике#Расшифровка романов об ошибках|длинным сообщениям об ошибках]]. Для иллюстрации этого рассмотрим следующий надуманный код:
```c++
template<typename Т>
void clear(Т& р)
{
	*р =0; //В предположении, что Т - тип указателя
}

template<typename Т>
void соге(Т& р)
{
	clear(р);
}

template<typename Т>
void middle(typename Т::Index р)
{
	core(р);
}

template<typename Т>
void shell(Т const& env)
{
	typename T::Index i;
	middle<T>(i);
}
```

Этот пример иллюстрирует типичную слоистую структуру разработки программного обеспечения: шаблоны функций высокого уровня, такие как `shell()`, основаны на таких компонентах, как `middle()`, которые сами используют фундаментальные средства наподобие `core()`. Когда инстанцируется `shell()`, должны инстанцироваться и все слои ниже. В данном примере проблема проявляется в наиболее глубоком слое: `core()` создается с типом `int` (получаемым из использования `Client::Index` в `middle()` ), и выполняется попытка разыменования значения этого типа, что является ошибкой.

Эта ошибка обнаруживается только во время инстанцирования. Например:
```c++
class Client
{
	public:
		using Index = int;
};

int main()
{
	Client mainClient;
	shell(mainClient);
}
```

Хорошая диагностика при обобщенном программировании включает трассировку всех слоев, которые привели к проблемам, но такое большое количество информации может оказаться излишне громоздким.

Отличное обсуждения основных идей, связанных с этой проблемой, можно найти в #книге[66], где Бьярне Страуструп (Bjarne Stroustrup) определяет два класса подходов к как можно более раннему определению, удовлетворяют ли аргументы шаблона набору ограничений: через расширение языка или с помощью раннего использования параметров. [[Дальнейшее развитие - template#Проверка типов для шаблонов|Первый вариант  рассматривается тут]] и в [[Concepts|“Концепты”]] . Второй вариант состоит в выявлении любых ошибок в поверхностных инстанцированиях (shallow instantiations). Это достигается путем вставки неиспользуемого кода, не имеющего никакой иной цели, кроме как вызвать ошибку, если код создается с аргументами шаблона, которые не отвечают требованиям шаблонов на более глубоких уровнях. В нашем предыдущем примере мы могли бы добавить в `shell()` код, который пытается разыменовать значения типа `Т::Index`. Например:
```c++
template<typename Т>
void ignore(Т const&)
{
}

template<typename Т>
void shell(T const& env)
{
	class ShallowChecks
	{
		void deref(typename T::Index ptr)
		{
			ignore(*ptr);
		}
	};
	
	typename T::Index i;
	middle(i);
)
```

Если `T` является типом, для которого `Т::Index` не может быть разыменован, ошибка диагностируется в локальном классе `ShallowChecks`. Обратите внимание: поскольку этот локальный класс фактически не используется, добавленный код не влияет на время работы функции `shell()`. К сожалению, многие компиляторы будут предупреждать, что класс `ShallowChecks` не используется. Для подавления предупреждений могут использоваться такие трюки, как применение шаблона `ignore()`, но они привносят в код дополнительную сложность.

***===Проверка концепта===***

Очевидно, что разработка фиктивного кода в нашем примере может стать столь же сложной, как и разработка кода, реализующего фактическую функциональность шаблона. Для контроля этой сложности естественно попытаться собрать различные фрагменты фиктивного кода в своего рода библиотеки. Например, такая библиотека может содержать макросы, которые раскрываются в код, который вызывает ошибку, когда подстановка параметров шаблона нарушает [[Concepts|концепт]], лежащий в основе конкретного параметра. Наиболее популярная из таких библиотек, `Concept Check Library`, является частью дистрибутива Boost.

К сожалению, эта методика не особенно переносима (способ диагностики ошибки может значительно отличаться от одного компилятора к другому), а иногда маскировать проблемы, которые не могут быть перехвачены на более высоком уровне.

После того как [[Concepts|концепты]] войдут в C++ (см. [[Concepts|“Концепты”]]), у нас будут другие способы поддержки определения требований и ожидаемого поведения.

# Статические утверждения

Макрос [[assert|assert()]] часто используется в коде C++ для проверки выполнения некоторых определенных условий в некоторый момент выполнения программы. Если утверждение не выполняется, программа прерывается (с выводом соответствующей информации), так что программист может обнаружить и исправить проблему.

Ключевое слово C++ [[static_assert|static_assert]], введенное в С++11, служит той же цели, но вычисляется во время компиляции. Если условие (которое должно быть константным выражением) имеет значение `false`, компилятор выдаст сообщение об ошибке. Это сообщение об ошибке будет включать строку (которая является частью самого [[static_assert|static_assert]]), указывающую программисту, что именно пошло не так. Например, следующее статическое утверждение гарантирует, что мы выполняем компиляцию на платформе с 64-битными указателями:
```c++
static_assert(sizeof(void*)*CHAR_BIT==64 ,"He 64-разрядная платформа");
```

Статические утверждения могут использоваться для предоставления полезных сообщений об ошибках, когда аргумент шаблона не соответствует ограничениям шаблона. Например, с [[[[SFINAE#Свойства на основе SFINAE|помощью методов]], можно создать тип-свойство для выяснения, является ли данный тип разыменуемым:
```c++
#include <utility>          // Для declval()
#include <type_traits>      // Для true_type и false_type

template<typename T>
class HasDereference
{
	private:
		template<typename U> struct Identity;
		template<typename U> static std::true_type
			test(Identity<decltype(*std::declval<U>())>*);
			
		template<typename U> static std::false_type
		test (...);
		
	public:
		static constexpr bool value = decltype(test<T>(nullptr))::value;
};
```

Теперь мы можем ввести в `shell()` статическое утверждение, которое обеспечивает лучшую диагностику, если шаблон `shell()` из предыдущего раздела инстанцируется с типом, который не является разыменовываемым:
```c++
template<typename Т>
void shell(Т const& env)
{
	static_assert(HasDereference<T>::value,
					"T не является разыменовываемым");
	typename T::Index i;
	middle(i);
};
```

При таком изменении компилятор выводит значительно более краткую диагностику, указывающую, что тип `Т` не является разыменуемым.

Статические утверждения могут значительно облегчить жизнь пользователей при работе с шаблонной библиотекой, делая сообщения об ошибках короче и понятнее.

Обратите внимание на то, что их можно также применять к шаблонам классов и использовать все свойства типов, обсуждающиеся в [[Стандартные утилиты для работы с типами#Стандартные утилиты для работы с типами|“Стандартные утилиты для работы с типами”]]:
```c++
template<typename Т>
class С
{
	static_assert(HasDereference<T>::value,
					"Т не является разыменовываемым");
					
	static_assert(std::is_default_constructible<T>::value,
					"T не конструируем по умолчанию");

	...
};
```

# Архетипы

При написании шаблона сложно гарантировать, что его определение будет компилироваться для любых аргументов шаблона, удовлетворяющих указанным ограничениям для этого шаблона. Рассмотрим простой алгоритм [[find|find()]], который ищет значения в массиве, а также его документированные ограничения:
```c++
// Т должен быть EqualityComparable, что означает:
// два объекта типа Т могут сравниваться с использованием
// оператора == и преобразованием результата в bool
template<typename Т>
int find(T const* array, int n, T const& value);
```

Можно представить себе следующую простую реализацию этого шаблона функции:
```c++
template<typename Т>
int find(T const* array, int n, T const& value)
{
	int i = 0;

	while (i != n && array[i] != value)
		++i;

	return i;
}
```

У этого определения шаблона есть две проблемы, причем обе они проявляются как ошибки компиляции для определенных аргументов шаблона, которые технически отвечают требованиям шаблона, но ведут себя несколько иначе, чем ожидает автор шаблона. Мы будем использовать понятие архетипов (`archetype`) для проверки соответствия используемых в нашей реализации параметров шаблонов требованиям, указанным в шаблоне [[find|find()]].

Архетипы представляют собой пользовательские классы, применяемые в качестве аргументов шаблонов для тестирования соблюдения ограничений, которые определение шаблона налагает на соответствующие параметры шаблона. Архетип специально разрабатывается для удовлетворения требованиям шаблона наименьшим возможным способом, без предоставления каких-либо посторонних операций. Если инстанцирование шаблона определения с архетипом в качестве его аргумента шаблона завершается успешно, то мы знаем, что определение шаблона не пытается использовать никакие операции, которые не указаны шаблоном явно.

Далее приводится пример архетипа, предназначенного для проверки соответствия требованиям [[Concepts#концепт equality_comparable|концепта EqualityComparable]], описанного в документации нашего алгоритма [[find|find()]]:
```c++
class EqualityComparableArchetype
{
};

class ConvertibleToBoolArchetype
{
	public:
		operator bool() const;
};

ConvertibleToBoolArchetype
operator==(EqualityComparableArchetype const&,
			EqualityComparableArchetype const&);
```

Тип `EqualityComparableArchetype` не имеет функций-членов и членов-данных, и единственная операция, которую он обеспечивает — это перегруженный `operator==` для удовлетворения требованиям [[find|find()]]. Сам по себе `operator==` минималистичен, возвращая другой архетип, `ConvertibleToBoolArchetype`, единственной определенной операцией которого является пользовательское преобразование в тип `bool`.

Очевидно, что `EqualityComparableArchetype` соответствует указанным требованиям шаблона [[find|find()]], так что мы можем проверить, будет ли реализация [[find|find()]] до конца выполнять свой контракт, пытаясь инстанцировать [[find|find()]] для `EqualityComparableArchetype`:
```c++
template int find(EqualityComparableArchetype const*, int,
					EqualityComparableArchetype const&);
```

Инстанцирование `find<EqualityComparableArchetype>` оказывается неудачным, указывая, что мы встретились с первой проблемой: описание `EqualityComparable` описание наличия только оператора `==`, но реализация [[find|find()]] полагается на сравнение объектов типа `Т` с помощью оператора `!=`. Наша реализация работала бы с большинством определяемых пользователем типов, которые реализуют пару операторов `==` и `!=`, но на самом деле работала бы неправильно. Архетипы предназначены для обнаружения подобных проблем на ранних этапах разработки шаблонных библиотек.

Изменяя реализацию алгоритма [[find|find()]] так, чтобы он использовал равенство вместо неравенства, мы решаем эту первую проблему, и шаблон `find()` теперь успешно компилируется с архетипом:
```c++
template<typename Т>
int find(T const* array, int n, T const& value)
{
	int i = 0;
	while (i != n && !(array[i] == value))
		++i;

	return i;
}
```

Выявление второй проблемы в `find()` с использованием архетипов требует немного больше изобретательности. Обратите внимание на то, что новое определение `find()` применяет оператор `!` непосредственно к результату оператора `==`. В случае нашего архетипа код опирается на пользовательское преобразование в тип `bool` и встроенный оператор логического отрицания `!`. Более тщательная реализация `ConvertibleToBoolArchetype` убирает оператор `!` таким образом, чтобы он не мог использоваться ненадлежащим образом:
```c++
class ConvertibleToBoolArchetype
{
	public:
		operator bool() const;
		bool operator!() = 
					delete; // Логическое отрицание явно не требовалось
};
```

Мы могли бы расширить этот архетип, используя удаление функций для операторов `&&` и `||`, чтобы помочь найти проблемы в других определениях шаблонов. Обычно разработчик шаблона будет хотеть разработать архетип каждого концепта, определенного в библиотеке шаблонов, а затем использовать эти архетипы для тестирования каждого определения шаблона на соответствие заявленным требованиям.

# Трассировщики

До сих пор мы обсуждали ошибки, возникающие при компиляции или компоновке программ, содержащих шаблоны. Однако наиболее сложная задача обеспечения корректной работы программы во время выполнения часто следует за успешным построением программы. Шаблоны могут сделать эту задачу более сложной, потому что поведение обобщенного кода, представленного шаблоном, зависит от клиента этого шаблона в гораздо большей степени, чем для обычных классов и функций. Трассировщик (`tracer`) представляет собой программное обеспечение, которое может облегчить этот аспект отладки путем выявления проблем в определениях шаблонов на ранних этапах цикла разработки.

Трассировщик представляет собой пользовательский класс, который может использоваться в качестве аргумента проверяемого шаблона. Часто трассировщики являются также архетипами, написанными просто для удовлетворения требований шаблона. Однако более важным является то, что трассировщик должен генерировать след (`trace`) операций, которые вызываются для него. Это позволяет, например, экспериментально проверить как эффективность алгоритмов, так и последовательность операций.

Ниже приведен пример трассировщика, который может использоваться для проверки алгоритма сортировки:
```c++
#include <iostream>

class SortTracer
{
	private:
		// Сортируемое значение:
		int value;
		
		// Поколение трассировщика:
		int generation;
		
		// Количество вызовов конструкторов:
		inline static long n_created = 0;
		
		// Количество вызовов деструкторов:
		inline static long n_destroyed = 0;
		
		// Количество присваиваний:
		inline static long n_assigned = 0;
		
		// Количество сравнений:
		inline static long n_compared = 0;
		
		// Максимальное количество существующих объектов:
		inline static long n_max_live = 0;
		
		// Вычисление максимального количества существующих объектов:
		static void update_max_live()
		{
			if(n_created - n_destroyed > n_max_live)
			{
				n_max_live = n_created - n_destroyed;
			}
		}
	
	public:
		static long creations()
		{
			return n_created;
		}
		
		static long destructions()
		{
			return n_destroyed;
		}
	
		static long assignments()
		{
			return n_assigned;
		}
			
		static long comparisons()
		{
			return n_compared;
		)
		
		static long max_live()
		{
			return n max live;
		}
	
	public:
		// Конструктор
		SortTracer(int v = 0) 
			: value(v)
			, generation(1)
		(
			++n_created;
			update_max_live();
			std::cerr << "SortTracer #" << n_created
						<< ", created generation " << generation
						<< " (total: " << n_created - n_destroyed
						<< ")\n";
		}
		
		// Копирующий конструктор
		SortTracer(SortTracer const& b)
			: value(b.value)
			, generation(b.generation + 1)
		{
			++n_created;
			update_max_live();
			std::cerr << "SortTracer #" << n_created
						<< ", copied as generation " << generation
						<< " (total: " << n_created - ndestroyed
						<< ")\n";
		}

		// Деструктор
		~SortTracer()
		{
			++n_destroyed;
			update_max_live() ;
			std::cerr << "SortTracer generation " << generation
						<< " destroyed (total: "
						<< n_created - n_destroyed << ")\n";
		}
		
		// Присваивание
		SortTracers operator= (SortTracer const& b)
		{
			++n_assigned;
			std::cerr << "SortTracer assignment #" << n_assigned
						<< " (generation " << generation
						<< " = " << b.generation
						<< ")\n";
						
			value = b.value;
			return *this;
		}

		// Сравнение
		friend bool operator < (SortTracer const& a,
								SortTracer const& b)
		{
			++n_compared;
			std::cerr << " SortTracer comparison #" << n_compared
						<< " (generation " << a.generation
						<< " < " << b.generation
						<< " ) \n";
			return a.value < b.value;
		}
		
		int val() const
		{
			return value;
		}
};
```

В дополнение к сортируемому значению `value` трассировщик предоставляет несколько членов для отслеживания выполнения сортировки: для каждого объекта `generation` отслеживает количество операций копирования. Исходное значение имеет `generation==1`, у прямой копии оригинала `generation==2`, копия копии имеет `generation==3` и так далее. Другие статические члены отслеживают количество вызовов конструкторов, деструкторов, присваиваний, сравнений и максимальное количество одновременно существовавших объектов.

Этот конкретный трассировщик позволяет нам отслеживать схему создания и уничтожения объектов, а также выполнение присваиваний и сравнений данным шаблоном. Следующая тестовая программа иллюстрирует сказанное для алгоритма [[sort|std::sort ()]] стандартной библиотеки C++:
```c++
#include <iostream>
#include <algorithm>
#include "tracer.hpp"

int main()
{
	// Образец входных данных:
	SortTracer input[] = { 7, 3, 5, 6, 4, 2, 0, 1, 9, 8 };
	
	// Вывод исходных значений:
	for (int i = 0; i < 10; ++i)
	{
		std::cerr << input[i].val() << ' ';
	}

	std::cerr << '\n';
	// Исходные условия:
	long created_at_start  = SortTracer::creations();
	long max_live_at_start = SortTracer::max_live();
	long assigned_at_start = SortTracer::assignments();
	long compared_at_start = SortTracer::comparisons();

	// Работа алгоритма:
	std::cerr << "--- [ Start std::sort() ]----------------------- \n";
	std::sort<>(&input[0], &input[9] + 1);
	std::cerr << "--- [ End std:: sort () ]------------------------- \n";

	// Проверка результатов:
	for (int i - 0; i < 10; ++i)
	{
		std::cerr << input[i].val() << ' ****
		std::cerr << input[i].val() << ' ;
	}

	std::cerr << "\n\n";
	
	// Окончательный отчет:
	std::cerr << "std::sort( ) для 10 SortTracer"
				<<  " выполнен с помощью:\n "
				<< SortTracer::creations() - created_at_start
				<< " временных трассировщиков \n "
				<< "до "
				<< SortTracer::max_live()
				<< " трассировщиков одновременно ("
				<< max_live_at_start << " вначале)\n "
				<< SortTracer::assignments() - assigned at start
				<< " присваивания \n "
				<< SortTracer::comparisons() - compared at start
				<< " сравнений \n\n";
```

Выполнение этой программы генерирует значительный вывод в консоль, но из заключительного отчета можно сделать многие выводы. Для одной из реализаций функции [[sort|std::sort()]] мы получили следующее:
```c++
std::sort() для 10 SortTracer выполнен с помощью:
			9 временных трассировщиков
			до 11 трассировщиков одновременно (10 вначале)
			33 присваивания
			27 сравнений
```

Например, мы видим, что, хотя в процессе сортировки в нашей программе были созданы девять временных трассировщиков, в любой момент времени имеется не более двух дополнительных трассировщиков.

Таким образом, наш трассировщик выполняет две функции: доказывает, что стандартный алгоритм [[sort|sort()]] требует не большую функциональность, чем может предоставить наш трассировщик (например, операторы `==` и `>` не нужны), и дает нам возможность оценить стоимость алгоритма. Однако он не свидетельствует о правильности шаблона сортировки.

# Оракулы

Трассировщики относительно просты и эффективны, но они позволяют нам отслеживать выполнение шаблонов только для определенных входных данных и для определенного поведения связанной с ними функциональности. Например, нас может интересовать, каким требованиям должен отвечать оператор сравнения для корректной сортировки, но в нашем примере мы проверили только оператор сравнения, который ведет себя так же, как оператор “меньше, чем” для целых чисел.

Расширения трассировщиков известны в определенных кругах как оракулы (`oracles`), или как оракулы анализа времени выполнения. Они являются трассировщиками, подключенными к механизмам вывода (`inference engine`) — программам, которые могут запоминать утверждения и их причины и делать на их основе определенные заключения.

Оракулы в ряде случаев позволяют нам проверить шаблоны алгоритмов динамически, без полного указания заменяемых аргументов шаблона (оракулы являются аргументами) или входных данных (механизм вывода может запросить некоторые исходные предположения для работы). Однако реально таким образом могут быть проанализированы только достаточно простые алгоритмы (из-за ограничений механизмов вывода), и такой анализ требует значительного объема работы. По этим причинам мы не вникали глубоко в эту тему, но заинтересовавшийся читатель может изучить публикации, упомянутые в заключительных замечаниях.


