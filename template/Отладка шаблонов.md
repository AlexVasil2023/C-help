
[[#Отладка шаблонов|Отладка шаблонов]] 28
1. [[#Поверхностное инстанцирование|Поверхностное инстанцирование]] 28.1





# Отладка шаблонов

Когда дело доходит до отладки шаблонов, возникают два класса проблем. Первый класс проблем — проблемы авторов шаблонов: как можно гарантировать, что написанные шаблоны будут функционировать для любых аргументов шаблонов, удовлетворяющих задокументированным автором условиям? Второй класс проблем по сути обратный: как пользователь шаблона может узнать, какие требования к параметрам шаблона он нарушил, когда шаблон ведет себя не так, как документировано?

Прежде чем приступить к серьезному обсуждению этих вопросов, полезно рассмотреть виды ограничений, которые могут быть наложены на параметры шаблона. В этой главе мы в основном имеем дело с ограничениями, которые при нарушении приводят к ошибкам компиляции, и называем эти ограничения синтаксическими ограничениями. Синтаксические ограничения могут включать необходимость наличия конструкторов определенного вида, однозначность некоторого вызова функции и так далее. Прочие виды ограничений мы называем семантическими ограничениями. Эти ограничения гораздо труднее проверить механически. В общем случае это даже может быть нецелесообразным. Например, мы можем потребовать, чтобы для типового параметра шаблона был определен оператор `<` (что является синтаксическим ограничением), но обычно мы также требуем, чтобы этот оператор фактически определял некоторое упорядочение в своей области определения (что является семантическим ограничением).

Для обозначения набора ограничений, которые многократно требуются в библиотеке шаблонов, часто используется термин концепт. Например, стандартная библиотека C++ опирается на такие [[Concepts|концепты]], как итератор с произвольным доступом или имеющий конструктор по умолчанию. С учетом данной терминологии можно сказать, что отладка кода шаблонов включает значительное количество работы по выявлению того, как в реализациях шаблонов и их использованиях нарушаются [[Concepts|концепты]]. Эта глава посвящена как проектированию, так и методам отладки, которые облегчают работу с шаблонами как для их авторов, так и для пользователей.

# Поверхностное инстанцирование

Когда происходит ошибка в шаблоне, проблема часто выявляется после длинной цепочки инстанцирований, что приводит к [[Применение шаблонов на практике#Расшифровка романов об ошибках|длинным сообщениям об ошибках]]. Для иллюстрации этого рассмотрим следующий надуманный код:
```c++
template<typename Т>
void clear(Т& р)
{
	*р =0; //В предположении, что Т - тип указателя
}

template<typename Т>
void соге(Т& р)
{
	clear(р);
}

template<typename Т>
void middle(typename Т::Index р)
{
	core(р);
}

template<typename Т>
void shell(Т const& env)
{
	typename T::Index i;
	middle<T>(i);
}
```

Этот пример иллюстрирует типичную слоистую структуру разработки программного обеспечения: шаблоны функций высокого уровня, такие как `shell()`, основаны на таких компонентах, как `middle()`, которые сами используют фундаментальные средства наподобие `core()`. Когда инстанцируется `shell()`, должны инстанцироваться и все слои ниже. В данном примере проблема проявляется в наиболее глубоком слое: `core()` создается с типом `int` (получаемым из использования `Client::Index` в `middle()` ), и выполняется попытка разыменования значения этого типа, что является ошибкой.

Эта ошибка обнаруживается только во время инстанцирования. Например:
```c++
class Client
{
	public:
		using Index = int;
};

int main()
{
	Client mainClient;
	shell(mainClient);
}
```

Хорошая диагностика при обобщенном программировании включает трассировку всех слоев, которые привели к проблемам, но такое большое количество информации может оказаться излишне громоздким.

Отличное обсуждения основных идей, связанных с этой проблемой, можно найти в #книге[66], где Бьярне Страуструп (Bjarne Stroustrup) определяет два класса подходов к как можно более раннему определению, удовлетворяют ли аргументы шаблона набору ограничений: через расширение языка или с помощью раннего использования параметров. [[Дальнейшее развитие - template#Проверка типов для шаблонов|Первый вариант  рассматривается тут]] и в [[Concepts|“Концепты”]] . Второй вариант состоит в выявлении любых ошибок в поверхностных инстанцированиях (shallow instantiations). Это достигается путем вставки неиспользуемого кода, не имеющего никакой иной цели, кроме как вызвать ошибку, если код создается с аргументами шаблона, которые не отвечают требованиям шаблонов на более глубоких уровнях. В нашем предыдущем примере мы могли бы добавить в `shell()` код, который пытается разыменовать значения типа `Т::Index`. Например:
```c++
template<typename Т>
void ignore(Т const&)
{
}

template<typename Т>
void shell(T const& env)
{
	class ShallowChecks
	{
		void deref(typename T::Index ptr)
		{
			ignore(*ptr);
		}
	};
	
	typename T::Index i;
	middle(i);
)
```

































