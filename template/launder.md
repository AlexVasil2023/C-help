
[[#std launder()|std::launder()]] (template)



# std::launder()

В общем случае компиляторы C++ направлены на создание высокопроизводительного кода, и, вероятно, основным механизмом повышения производительности сгенерированного кода является устранение многократного копирования данных из памяти в регистры. Для этого компилятор должен делать определенные предположения, в частности о том, что некоторые виды данных остаются неизменными все время их существования. Сюда включаются константные данные, ссылки (которые могут быть инициализированы, но не могут быть впоследствии изменены) и часть системных данных, хранящихся в полиморфных объектах и используемых для диспетчеризации виртуальных функций, локализации виртуальных базовых классов, а также классы обработки операторов [[typeid|typeid]] и [[dynamic_cast|dynamic_cast]].

Проблема, связанная с рассматривавшейся выше двухэтапной процедурой присваивания, заключается в том, что скрытно заканчивается время существования одного объекта и начинается время жизни другого объекта в том же месте, таким образом, что компилятор может быть не способен это распознать. Следовательно, компилятор может предположить, что значение, полученное из предыдущего состояния объекта [[variant|Variant]] все еще является действительным, в то время как фактически инициализация с размещающим [[new|new]] делает его недействительным. Без решения этой проблемы выполнение программы с использованием типа [[variant|Variant]] с неизменяемыми членами-данными иногда может приводить к некорректным результатам в случае ее оптимизации для достижения высокой производительности. Такие ошибки, как правило, очень трудно отслеживать (отчасти потому, что они встречаются редко, а отчасти потому, что в действительности они не видны в исходном коде).

Начиная с C++17, решением этой проблемы является доступ к адресу нового объекта через вызов `std::launder()`, который просто возвращает свой аргумент, но при этом заставляет компилятор распознать, что полученный адрес указывает на объект, который может отличаться от предположений компилятора об аргументе, передаваемом `std::launder()`. Однако учтите, что `std::launder()` фиксирует только возвращаемый адрес, но не аргумент, передаваемый `std::launder()`, потому что компиляторы “рассуждают” в терминах выражений, а не фактических адресов (так как последние не существуют до времени выполнения). Таким образом, после создания нового значения с помощью размещающего `new` мы должны гарантировать, что каждое следующее обращение будет использовать “очищенные” данные. Вот почему в [[variant|Variant]] мы всегда “отмываем” указатель буфера. Есть возможность поступить немного лучше (например, добавляя дополнительный член-указатель, который указывает на буфер и получает “очищенный” адрес после каждого присваивания нового значения с размещающим `new`), но код при этом усложняется и становится трудным для сопровождения. Наш подход прост и корректен, пока мы обращаемся к буферу исключительно через члены `getBufferAs()`.

Ситуация с `std::launder()` не является полностью удовлетворительной: вопрос это очень тонкий, трудно воспринимаемый (например, мы не заметили его до самой отправки книги в печать) и трудно решаемый (`std::launder()` не очень прост в использовании). Поэтому несколько членов Комитета потребовали проделать дополнительную работу по поиску более удовлетворительного решения. 




