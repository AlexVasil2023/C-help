
[[#Вглубь шаблонов|Вглубь шаблонов]] 12
1. [[#Параметризованные объявления|Параметризованные объявления]] 12.1
	1. [[#Виртуальные функции-члены|Виртуальные функции-члены]] 12.1.1
	2. [[#Связывание шаблонов|Связывание шаблонов]] 12.1.2
	3. [[#Первичные шаблоны|Первичные шаблоны]] 12.1.3
2. [[#Параметры шаблонов|Параметры шаблонов]] 12.2
	1. [[#Параметры типа|Параметры типа]] 12.2.1
	2. [[#Параметры, не являющиеся типами|Параметры, не являющиеся типами]] 12.2.2
	3. [[#Шаблонные параметры шаблонов|Шаблонные параметры шаблонов]] 12.2.3
	4. [[#Пакеты параметров шаблонов|Пакеты параметров шаблонов]] 12.2.4
	5. [[#Аргументы шаблона по умолчанию|Аргументы шаблона по умолчанию]] 12.2.5
3. [[#Аргументы шаблонов|Аргументы шаблонов]] 12.3
	1. [[#Аргументы шаблонов функций|Аргументы шаблонов функций]] 12.3.1
	2. [[#Аргументы типов|Аргументы типов]] 12.3.2
	3. [[#Аргументы, не являющиеся типами|Аргументы, не являющиеся типами]] 12.3.3
	4. [[#Шаблонные аргументы шаблонов|Шаблонные аргументы шаблонов]] 12.3.4
	5. [[#Эквивалентность|Эквивалентность]] 12.3.5
4. [[#Вариативные шаблоны|Вариативные шаблоны]] 12.4
	1. [[#Раскрытие пакета|Раскрытие пакета]] 12.4.1
	2. [[#Где может происходить раскрытие пакета|Где может происходить раскрытие пакета]] 12.4.2
	3. [[#Пакеты параметров функций|Пакеты параметров функций]] 12.4.3
	4. [[#Множественные и вложенные раскрытия пакетов|Множественные и вложенные раскрытия пакетов]] 12.4.4
	5. [[#Раскрытия пакетов нулевой длины|Раскрытия пакетов нулевой длины]] 12.4.5
	6. [[#Выражения свертки|Выражения свертки]] 12.4.6
5. [[#Друзья|Друзья]] 12.5
	1. [[#Дружественные классы шаблонов классов|Дружественные классы шаблонов классов]] 12.5.1
	2. [[#Дружественные функции шаблонов классов|Дружественные функции шаблонов классов]] 12.5.2
	3. [[#Дружественные шаблоны|Дружественные шаблоны]] 12.5.3

# Вглубь шаблонов

В этой главе дается более глубокий обзор основных понятий из области шаблонов, с которыми читатель познакомился в первой части книги. Речь идет об объявлениях шаблонов, ограничениях, накладываемых на параметры и аргументы шаблонов и т.п.

# Параметризованные объявления

В настоящее время в C++ поддерживаются четыре основных типа шаблонов — [[Шаблоны классов|шаблоны классов]], [[Шаблоны функций|шаблоны функций]], [[Шаблоны переменных#Шаблоны переменных|шаблоны переменных]] и #шаблоны_псевдонимов. Шаблоны каждой из этих разновидностей могут находиться как в области видимости пространства имен, так и в области видимости класса. В области видимости класса они становятся вложенными шаблонами классов, шаблонами функций-членов, шаблонами статических данных-членов и шаблонами псевдонимов-членов. Такие шаблоны объявляются почти так же, как и обычные классы, функции, переменные и псевдонимы типов (или их двойники — члены классов), за исключением того, что для шаблонов указывается выражение параметризации (parameterization clause) вида
```c++
template<Параметры>
```

Обратите внимание на наличие в C++17 еще одной конструкции, которая [[Шаблоны классов#Вывод аргументов шаблона класса|вводится с таким же выражением параметризации: правила вывода]] (deduction
guides) ( #раздел_15_12_1). В данной книге мы не называем их шаблонами (например, они не инстанцируются), но их синтаксис напоминает шаблоны функций.

К объявлениям фактических параметров мы вернемся в последующих разделах, а сейчас рассмотрим несколько примеров, в которых проиллюстрированы четыре указанные разновидности шаблонов. Они могут находиться в области видимости пространства имен (глобальной или пространства имен), как показано ниже.
```c++
template<typename T>           // Шаблон класса
class Data
{
	public:
		static constexpr bool copyable = true;
	
	...
};

template<typename T>           // Шаблон функции
void log(T x)
{
	...
}

template<typename Т>           // Шаблон переменной (начиная с С++14)
Т zero = 0;

template<typename Т>           // Шаблон переменной (начиная с С++14)
bool dataCopyable = Data<T>::copyable;

template<typename T>           // Шаблон псевдонима
using DataList = Data<T*>;
```
Обратите внимание на то, что в этом примере статический член `Data<T>::copyable` не является шаблоном переменной, несмотря на то, что он параметризован косвенно через параметризацию шаблона класса `Data`. Однако шаблон переменной может находиться в области видимости класса (как показывает следующий пример), и в этом случае это шаблон статического члена-данного.

В следующем примере показаны четыре разновидности шаблонов в виде членов класса, определенных в своем родительском классе:
```c++
class Collection
{
	public:
		template<typename T>   // Определение шаблона класса-члена
		class Node             // в пределах класса
		{
			...
		};
		
		template<typename Т>   // Определение шаблона функции-члена в
		Т* alloc()             // пределах класса (и потому неявно
		{                      // являющейся inline)
			...
		}
		
		template<typename Т>   // Шаблон переменной-члена (с С++14)
		static Т zero = 0;
		
		template<typename Т>   // Шаблон псевдонима-члена
		using NodePtr = Node<T>*;
};
```

Обратите внимание, что в C++17 переменные (включая статические члены-данные) и шаблоны переменных могут быть “встраиваемыми” ([[inline|inline]]), что означает, что их определение может быть повторено в нескольких единицах трансляции. Это избыточно для шаблонов переменных, которые всегда могут быть определены в нескольких единицах трансляции. Однако в отличие от функций-членов, определение статического члена-данных в его классе не делает его встраиваемым: ключевое слово [[inline|inline]] должно быть указано во всех случаях.

Наконец, в следующем коде показано, как шаблоны членов, которые не являются шаблонами псевдонимов, могут быть определены вне класса.
```c++
template<typename Т>            // Шаблон класса области
class List                      // видимости пространства имен
{
	public:
		List() = default;       // Поскольку определен
								// шаблонный конструктор

		template<typename U>    // Еще один шаблон класса,
		class Handle;           // без определения

		template<typename U>    // Шаблон функции-члена
		List(List<U> const&);   // (конструктор)
		
		template<typename U>    // Шаблон переменной-члена (с С++14)
		static U zero;
};

template<typename Т>    // Определение шаблона класса-члена вне класса
	template<typename U>
class List<T>::Handle
{
	...
};

template<typename T>    // Определение шаблона функции-члена вне класса
	template<typename Т2>
List<T>::List(List<T2> const& b)
{
	...
}

template<typename T>    // Определение шаблона члена-данных вне класса
	template<typename U>
U List<T>::zero = 0;
```

Шаблоны-члены класса, определенные вне пределов охватывающего их класса, могут требовать несколько конструкций параметризации `template<...>`: одну для самого шаблона и по одной для каждого охватывающего шаблона класса. Конструкции перечисляются, начиная с самого внешнего шаблона класса.

Обратите также внимание на то, что шаблон конструктора (особый вид шаблона функции-члена) отключает неявное объявление конструктора по умолчанию (потому что он неявно объявляется только тогда, когда никакой иной конструктор не объявлен). Добавление объявления по умолчанию
```c++
List() = default;
```

гарантирует, что экземпляр `List<T>` конструируется по умолчанию с семантикой неявно объявленного конструктора.

==**Шаблоны объединений**==

***Шаблоны объединений*** (union templates) также возможны (они трактуются как разновидность шаблона класса):
```c++
template<typename Т>
union AllocChunk
{
	Т object;
	unsigned char bytes[sizeof(T)];
};
```

==**Аргументы вызова по умолчанию**==

Шаблоны функций могут иметь аргументы вызова по умолчанию, как и обычные объявления функций:
```c++
template<typename Т>
void report_top(Stack<T> const&, int number = 10);

template<typename T>
void fill(Array<T>&, T const& = T{});       // T{} для встроенных
											// типов равно нулю
```

Последнее объявление показывает, что аргумент вызова по умолчанию может зависеть от параметров шаблона. Он также может быть определен как ( [[Инициализация нулем - template|единственный доступный до C++11 способ]])
```c++
template<typename Т>
void fill(Array<T>&, Т const& = Т());       // Т() для встроенных
											// типов равно нулю
```

При вызове функции `fill()` аргумент по умолчанию не инстанцируется, если указан второй аргумент вызова функции. Это гарантирует, что сообщение об ошибке не будет выдано, если аргумент вызова по умолчанию не может быть инстанцирован для конкретного `Т`. Например:
```c++
class Value
{
	public:
		explicit Value(int);        // Нет конструктора по умолчанию
};

void init(Array<Value>& array)
{
	Value zero(0);
	fill(array, zero);              // OK: конструктор no
									// умолчанию не используется
									
	fill(array);                    // Ошибка: использован не определенный
									// конструктор по умолчанию для Value
};
```

==**Нешаблонные члены шаблонов классов**==

Помимо четырех основных типов шаблонов, объявленных внутри класса, могут также иметься обычные члены класса, параметризованные в силу того, что они являются частью шаблона класса. Иногда их (ошибочно) также называют шаблонами членов. Хотя они могут быть параметризованы, такие определения не являются “шаблонами первого класса”. Их параметры полностью определяются шаблоном, членами которого они являются. Например:
```c++
template<int I>
class CupBoard
{
	class Shelf;                // Обычный класс в шаблоне класса

	void open();                // Обычная функция в шаблоне класса

	enum Wood : unsigned char;  // Обычное перечисление
								// в шаблоне класса
	static double totalWeight;  // Обычный статический
								// член-данные в шаблоне класса
};
```

Соответствующие определения указывают параметризацию только для шаблонов родительского класса, но не для самого члена, поскольку он шаблоном не является (то есть с его именем после последнего `::` не связана никакая конструкция параметризации):
```c++
template<int I>         // Определение обычного класса в шаблоне класса
class CupBoard<I>::Shelf
{
	...
};

template<int I>         // Определение обычной функции в шаблоне класса
void CupBoard<I>::open()
{
	...
}

template<int I>         // Определение обычного перечисления
enum CupBoard<I>::Wood  // в шаблоне класса
{
	Maple, Cherry, Oak
};

template<int I>         // Определение обычного статического
double CupBoard<I>::totalWeight = 0.0; // члена в шаблоне класса
```

Начиная с С++17, статический член `totalWeight` может быть инициализирован внутри шаблона класса с использованием [[inline|inline]]:
```c++
template<int I>
class CupBoard
{	
	...
	
	inline static double totalWeight = 0.0;
};
```

Хотя такие параметризованные определения обычно называются шаблонами, это не совсем верный термин. Для таких сущностей был предложен термин таблоид (temploid). Начиная с C++17, стандарт C++ определяет понятие шаблонной сущности (templated entity), которая включает шаблоны и шаблоиды, а также рекурсивно все сущности, определенные или созданные в шаблонных сущностях (что включает в себя, например, [[Шаблоны классов#Друзья|дружественную функцию, определенную внутри шаблона класса]] или тип замыкания лямбда-выражения, содержащегося в шаблоне). Пока что эти термины не получили широкого распространения, но они могут быть полезны в будущем для более точного обмена информацией о шаблонах в C++.

## Виртуальные функции-члены

Шаблоны функций-членов не могут быть объявлены как виртуальные. Это ограничение накладывается потому, что в обычной реализации механизма вызова виртуальных функций используется таблица фиксированного размера, одна строка которой соответствует одной виртуальной функции. Однако число инстанцированных шаблонов функции-члена не является фиксированным, пока не завершится трансляция всей программы. Следовательно, для того, чтобы поддержка шаблонов виртуальных членов-функций стала возможной, требуется реализация радикально нового вида механизма позднего связывания в компиляторах и компоновщиках C++.

В отличие от функций-членов, обычные члены шаблонов классов могут быть виртуальными, поскольку их количество при инстанцировании класса фиксировано.
```c++
template<typename Т>
class Dynamic
{
	public:
		virtual ~Dynamic();     // OK: один деструктор на
								// экземпляр Dynamic<T>
		
		template<typename T2>
		virtual void copy(T2 const&);
			// Ошибка: неизвестное количество экземпляров сору()
			// у одного экземпляра Dynamic<T>
};
```

## Связывание шаблонов

Каждый шаблон должен иметь имя, и это имя должно быть уникальным в пределах его области видимости, за исключением шаблонов функций, которые могут быть перегружены (см. #главу_16, “Специализация и перегрузка”). Особо отметим, что, в отличие от типов классов, для шаблонов классов не допускается использование имен, совпадающих с именами объектов других сущностей:
```c++
int С;
...
class С;        // ОК: имена классов и не классов в разных "пространствах"

int X;
...
template<typename Т>
class X;        // Ошибка: конфликт с именем переменной X

struct S;
...
template<typename Т>
class S;        // Ошибка: конфликт с именем структуры S
```

Имена шаблонов имеют связывание, но они не могут иметь *связывание С*. Нестандартные связывания могут иметь значения, зависящие от реализации (однако нам неизвестна реализация, которая поддерживала бы нестандартные правила связывания имен для шаблонов).
```c++
extern "C++" template<typename Т>
void normal();          // По умолчанию спецификация
						// связывания может быть опущена
extern "С" template<typename Т>
void invalid();         // Ошибка: шаблоны не могут иметь связывание С

extern "Java" template<typename Т>
void javaLink();        // Нестандартно, но, возможно, когда-то появится
						// какой-то компилятор, поддерживающий связывание,
						// совместимое с дженериками Java
```

Шаблоны обычно имеют внешнее связывание. Исключением являются шаблоны функций в области видимости пространства имен, описанные как [[static|static]], шаблоны, которые являются прямыми или косвенными членами безымянного пространства имен (которое имеет внутреннее связывание) и шаблоны членов безымянных классов (которые не имеют связывания). Например:
```c++
template<typename Т>        // Ссылается на ту же сущность, что и
void external();            // объявление с тем же именем (и областью
							// видимости) в другом файле

template<typename Т>        //Не связано с шаблоном с тем же именем
static void internal();     //в другом файле

template<typename Т>        // Повторное объявление предыдущего шаблона
static void internal();

namespace
{
	template<typename>      // Также не связано с шаблоном с тем же
	void otherlnternal();   // именем в другом файле, даже с тем,
							// который находится в аналогичном
							// безымянном пространстве имен
}

namespace
{
	template<typename>      // Повторное объявление
	void otherlnternal();   // предыдущего шаблона
}

struct
{
	template<typename Т>    // Связывания нет:
	void f(T) {}            //не может быть повторно объявлен
} х;

```

Обратите внимание: поскольку последний шаблон члена не имеет связывания, он должен быть определен в безымянном классе, поскольку нет никакого способа обеспечить его определение вне класса.

В настоящее время шаблоны не могут быть объявлены в области видимости функции или локального класса, но обобщенные лямбда-выражения (см. #раздел_15_10_6), которые имеют связанные типы замыкания, содержащие шаблоны функций-членов, могут находиться в локальных областях видимости, что подразумевает наличие разновидности локальных шаблонов функций-членов.

Связывание экземпляра шаблона такое же, что и у шаблона. Например, функция `internal<void>()`, инстанцированная из объявленного выше шаблона `internal`, будет иметь внутреннее связывание. Это имеет интересные следствия в случае шаблонов переменных. Рассмотрим следующий пример:
```c++
template<typename Т> Т zero = Т{};
```

Все инстанцирования `zero` имеют внешнее связывание, даже такие как `zero<int const>`. Это может показаться парадоксальным, учитывая, что
```c++
template<typename Т> int const max_volume = 11;
```

имеют внешнее связывание, несмотря на то, что все они также имеют тип `int` [[const|const]].

## Первичные шаблоны

С помощью обычных конструкций объявлений шаблонов объявляются так называемые первичные шаблоны (`primary templates`). В таких объявлениях после имени отсутствуют аргументы шаблона в угловых скобках:
```c++
// ОК: первичный шаблон
template<typename Т> class Box;

// Ошибка: не специализируется
template<typename Т> class Вох<T>;

// ОК: первичный шаблон
template<typename Т> void translate(Т);

// Ошибка: не разрешено для функций
template<typename Т> void translat<T>(Т);

// ОК: первичный шаблон
template<typename Т> constexpr Т zero = Т{};

// Ошибка: не специализируется
template<typename Т> constexpr Т zero<T> = Т{};
```

Вторичные (не первичные) шаблоны классов получаются при объявлении частичных специализаций шаблонов классов или переменных, которые рассматриваются в #главе_16, “Специализация и перегрузка”. Шаблоны функций всегда должны быть первичными (см. #раздел_17_3, где рассмотрены возможные изменения в этой области в будущем).

# Параметры шаблонов

Существует три основных вида параметров шаблонов.

1. Параметры типа (типовые параметры) (они на сегодняшний день используются наиболее часто).
2. Параметры, не являющиеся типами (нетиповые параметры).
3. Шаблонные параметры шаблонов.

Любой из этих основных видов параметров шаблона может быть использован в качестве основы пакета параметров шаблона (`template parameter pack`) (см. #раздел_12_2_4).

Параметры шаблона объявлены в начальном операторе параметризации объявления шаблона. Такие объявления не обязательно должны быть именованными:
```c++
template<typename, int>
class X;           // Х<> параметризован типом и целочисленным значением
```

Имя параметра, конечно же, необходимо, если на этот параметр имеется ссылка позже в шаблоне. Обратите также внимание, что на имя параметра шаблона можно ссылаться в объявлении последующего параметра (но не до самого рассматриваемого параметра):
```c++
template<typename Т,             // Первый параметр используется
		Т Root,                  // в объявлениях второго и
		template<T> class Buf>   // третьего параметров
class Structure;
```

## Параметры типа

Параметры типа (типовые параметры) вводятся с помощью ключевых слов [[typename|typename]] либо `class`; оба варианта эквивалентны. За ключевым словом должен следовать простой идентификатор, за которым идет запятая, означающая начало следующего объявления параметра, закрывающая угловая скобка (`>`) для обозначения конца параметризованного выражения или знак равенства (`=`) для обозначения начала заданного по умолчанию аргумента шаблона.

В пределах объявления шаблона параметр типа ведет себя подобно [[Шаблоны классов#Псевдонимы типов|псевдониму типа]]. Например, нельзя использовать имя вида `class Т`, где `Т` является параметром шаблона, даже если вместо `Т` подставляется тип класса.
```c++
template<typename Allocator>
class List
{
	// Ошибка: использование "Allocator* allocptr":
	class Allocator* allocptr;
	
	// Ошибка: использование "friend Allocator"
	friend class Allocator;
};
```

## Параметры, не являющиеся типами

Не являющиеся типами параметры (нетиповые параметры) — это константные значения, которые могут быть определены во время компиляции или при компоновке. Тип такого параметра (другими словами, тип значения, которое он обозначает) должен быть одним из следующих:
>
> целочисленный тип или тип перечисления;
> 
> тип указателя;
> 
> тип указателя на член;
> 
> тип [[значение - template#l-значение|l-ссылки]] (разрешены как ссылка на объект, так и ссылка на функцию);
> 
> [[nullptr_t#std nullptr_t|std::nullptr_t]];
> 
> тип, содержащий [[auto|auto]] или [[decltype(auto)|decltype (auto)]] (только начиная с С++17; см. #раздел_15_10_1).

В данный момент все прочие типы исключены (хотя в будущем возможно добавление типов с плавающей точкой; см. #раздел_17_2).

Возможно, это покажется несколько неожиданным, но объявление параметра шаблона, не являющегося типом, в некоторых случаях также может начинаться с ключевого слова [[typename|typename]]:
```c++
template<typename Т,                        // Параметр типа
		typename Т::Allocator* Allocator>   // Параметр, не
class List;                                 // являющийся типом
```

или с ключевого слова `class`:
```c++
template<class Х*>     // Параметр, не являющийся типом,
class Y;               // и имеющий тип указателя
```

Разницу здесь увидеть легко; в первом случае за ключевым словом следует простой идентификатор, а затем один из небольшого набора лексем (`“=”` для аргумента по умолчанию, `“,”` для указания того, что далее следует другой параметр шаблона, или закрывающая угловая скобка `">"` завершающая список параметров шаблона). В #разделах_13_3_2 объясняется необходимость ключевого слова [[typename|typename]] в первом параметре, не являющемся типом.

Возможно использование типов функции и массивов, но они неявно низводятся к типу указателя:
```c++
template<int buf[5]> class Lexer;       // В действительности int*
template<int* buf> class Lexer;         // OK: повторное объявление
template<int fun()> struct FuncWrap;    // fun представляет собой
										// тип указателя на функцию
template<int (*)()> struct FuncWrap;    // ОК: повторное объявление
```

Параметры, не являющиеся типами, объявляются почти так же, как и переменные, но они не могут включать спецификаторы, не являющиеся типами, такие как [[static|static]], [[mutable|mutable]] и т.д. Возможно использование модификаторов [[const|const]] или [[volatile|volatile]], но если такой модификатор появляется у нетиповых параметров внешнего уровня вложенности, он попросту игнорируется:
```c++
template<int const length> class Buffer; // const здесь бесполезен
template<int length> class Buffer;       // To же самое объявление
```

И наконец, параметры, не являющиеся типами, всегда являются [[значение - template#pr-значения|рr-значениями]]. Их адрес нельзя получить, и им нельзя ничего присвоить. С другой стороны, параметр, не являющийся типом и имеющий тип [[значение - template#l-значение|l-ссылки]], может использоваться для описания [[значение - template#l-значение|l-значения]]:
```c++
template<int& Counter>
struct LocalIncrement
{
	LocalIncrement()
	{
		Counter = Counter+1;         // OK: Ссылка на int
	}
	
	~LocalIncrement()
	{
		Counter = Counter-1;
	}
};
```

[[значение - template#r-значения|R-ссылка]] в качестве параметра не разрешена.

## Шаблонные параметры шаблонов

Шаблонные параметры шаблонов являются символами-заместителями для шаблонов классов или псевдонимов. Они объявляются во многом подобно шаблонам классов, однако при этом нельзя использовать ключевые слова `struct` и [[union|union]]:
```c++
template<template<typename Х> class С>      // ОК
void f(C<int>* р);

template<template<typename Х> struct С>     // Ошибка: struct
void f(C<int>* p);

template<template<typename X> union C       // Ошибка: union
void f(C<int>* p) ;

```

C++17 позволяет использовать ключевое слово [[typename|typename]] вместо `class`: это изменение было мотивировано тем, что шаблонные параметры шаблона можно заменять не только шаблонами класса, но и шаблонами псевдонимов (которые инстанцируются для произвольных типов). Так, в C++17 приведенный выше пример может быть записан как
```c++
template<template<typename Х> typename С> // ОК начиная с С++17
void f(C<int>* р);
```

В области видимости их объявлений шаблонные параметры шаблонов используются так же, как и другие шаблоны классов или псевдонимов.

Параметры шаблонных параметров шаблонов могут иметь аргументы, заданные по умолчанию. Эти аргументы применяются в том случае, когда при использовании шаблонного параметра шаблона соответствующие параметры не указаны:
```c++
template<template<typename Т, typename А = MyAllocator> class Container>
class Adaptation
{
	Container<int> storage; // Неявно эквивалентно
	...                     // Container<int,MyAllocator>
};
```

`T` и `А` являются именами параметров шаблона шаблонного параметра шаблона `Container`. Эти имена используются только в объявлении других параметров этого шаблонного параметра шаблона. Следующий надуманный шаблон иллюстрирует данную концепцию:
```c++
template<template<typename Т, Т*> class Buf>  // OK
class Lexer
{
	static T* storage;      // Ошибка: здесь не может быть использован
	...						// параметр шаблонного параметра шаблона
};
```

Однако обычно имена параметров шаблона шаблонного параметра шаблона не используются, поэтому им зачастую вообще не присваиваются никакие имена. Например, рассмотренный выше шаблон `Adaptation` можно объявить следующим образом:
```c++
template<template<typename, typename = MyAllocator> class Container>
class Adaptation
{
	Container<int> storage; // Неявный эквивалент
	...                     // Container<int,MyAllocator>
};
```

## Пакеты параметров шаблонов

Начиная с C++11, параметр шаблона любого вида может быть превращен в пакет параметров шаблона путем добавления многоточия (`...`) перед именем параметра шаблона или, если параметр шаблона безымянный, там, где должно находиться имя параметра шаблона:
```c++
template<typename... Types> // Объявление пакета параметров
class Tuple;                // шаблона с именем Types
```

Пакет параметров шаблона ведет себя как базовый параметр шаблона, но с важным отличием: в то время как обычный параметр шаблона соответствует ровно одному аргументу шаблона, пакет параметров шаблона может соответствовать любому количеству аргументов шаблона. Это означает, что шаблон класса `Tuple`, объявленный выше, принимает любое количество (возможно различных) типов в качестве аргументов шаблона:
```c++
using IntTuple = Tuple<int>;          // OK: один аргумент шаблона
using IntCharTuple = Tuple<int,char>; // OK: два аргумента шаблона
using IntTriple = Tuple<int,int,int>; // OK: три аргумента шаблона
using EmptyTuple = Tuple<>;           // OK: нет аргументов шаблона
```

Аналогично пакеты параметров шаблонов, не являющиеся типами, и шаблонные параметры шаблонов также могут принимать любое количество соответствующих аргументов шаблона:
```c++
// ОК: объявление пакета параметров шаблонов, не являющихся типами:
template<typename Т, unsigned... Dimensions>
class MultiArray;

// OK: матрица размера 3x3
using TransformMatrix = MultiArray<double, 3, 3>;

// OK: объявление пакета шаблонных параметров шаблонов
template<typename Т, template<typename, typename>... Containers>
void testContainers() ;
```

Пример `MultiArray` требует, чтобы все аргументы шаблона, не являющиеся типами, были одного и того же типа `unsigned`. Начиная с С++17, вводится возможность вывода аргументов шаблона, не являющихся типами, которая позволяет нам в определенной мере обойти это ограничение (подробнее об этом см. #раздел_15_10_1).

Первичные шаблоны классов, шаблоны переменных и шаблоны псевдонимов могут иметь не более одного пакета параметров шаблона, и, если он присутствует, он должен быть последним параметром шаблона. Шаблоны функции имеют более слабые ограничения: разрешены множественные пакеты параметров шаблонов, лишь бы каждый параметр шаблона после пакета параметров шаблона либо имел значение по умолчанию (см. #следующий_раздел), либо мог быть выведен (см. #главу_15, “Вывод аргументов шаблона”):
```c++
// Ошибка: пакет параметров шаблона не является последним
template<typename... Types, typename Last>
class LastType;

// OK: за пакетом параметров шаблона следует
// выводимый параметр шаблона
template<typename... TestTypes, typename Т>
void runTests (Т value);

template<unsigned...> struct Tensor;
template<unsigned... Dims1, unsigned... Dims2>
auto compose(Tensor<Dims1...>, Tensor<Dims2...>);
// OK: размерности тензора могут быть выведены
```

Последний пример представляет собой объявление функции с выводимым возвращаемым типом (возможность, введенная в C++14), см. также #раздел_15_10_1.

Объявления частичных специализаций шаблонов классов и переменных (см. #главу_16, “Специализация и перегрузка”) могут иметь несколько пакетов параметров, в отличие от их прототипа — первичного шаблона. Дело в том, что частичная специализация выбирается с помощью процесса выведения, который практически идентичен используемому для шаблонов функций.
```c++
template<typename...> Typelist;
template<typename X, typename Y> struct Zip;
template<typename... Xs, typename... Ys>
struct Zip<Typelist<Xs...>, Typelist<Ys...>>;
// OK: частичная специализация использует вывод
// для определения подстановок X и Y
```

Вероятно, не будет сюрпризом, что пакет параметров типов не может быть раскрыт в своем же выражении списка параметров. Например:
```c++
template<typename... Ts, Ts... vals> struct StaticValues {};
// Ошибка: Ts не может использоваться в собственном списке параметров
```

Однако вложенные шаблоны могут создавать корректные подобные ситуации:
```c++
template<typename... Ts> struct ArgList
{
	template<Ts... vals> struct Vais {};
};

ArgList<int, char, char>::Vals<3, 'x', 'y'> tada;
```

Шаблон, содержащий пакет параметров шаблона, называется ***вариативным шаблоном*** (`variadic template`), потому что он принимает переменное количество аргументов шаблона. [[Вариативные шаблоны - template#Вариативные шаблоны|Применение вариативных шаблонов описано тут]], и #разделе_12_4.

## Аргументы шаблона по умолчанию

Параметры шаблона любого вида, не являющиеся пакетом параметров шаблона, могут быть снабжены аргументами по умолчанию, но при этом аргумент по умолчанию должен соответствовать разновидности параметра (например, параметр типа не может иметь аргумент по умолчанию, не являющийся типом). Аргумент, заданный по умолчанию, не может зависеть от собственного параметра, поскольку имя параметра становится доступно только после значения по умолчанию. Однако он может зависеть от предшествующих ему параметров:
```c++
template<typename Т, typename Allocator = allocator<T>>
class List;
```

Параметры шаблона для шаблона класса, переменной или псевдонима могут иметь аргументы по умолчанию только в случае, когда аргументами по умолчанию снабжены также и все последующие параметры. (Аналогичное ограничение имеется для значений аргументов вызова функции по умолчанию.) Последующие значения по умолчанию обычно указываются в том же объявлении шаблона, но они могут также быть объявлены и в предыдущих объявлениях этого шаблона. Сказанное поясняет приведенный ниже пример.
```c++
template<typename T1, typename Т2, typename ТЗ,
		 typename Т4 = char, typename T5 = char>
class Quintuple; // OK

template<typename T1, typename T2, typename T3 = char,
		 typename T4, typename T5>
class Quintuple; // OK: T4 и T5 уже имеют значения по умолчанию

template<typename T1 = char, typename T2, typename ТЗ,
		 typename T4, typename T5>
class Quintuple; // Ошибка: T1 не может иметь значение по умолчанию,
				 // так как Т2 значения по умолчанию не имеет
```

Аргументы шаблона по умолчанию для параметров шаблонов функций не требуют, чтобы последующие параметры шаблона имели аргументы шаблона по умолчанию:
```c++
template<typename R = void, typename Т>
R * addressof(Т& value);    // OK: если R не указан явно,
                            // тип R представляет собой void
```

Аргументы шаблона по умолчанию не могут повторяться:
```c++
template<typename Т = void>
class Value;

template<typename T = void>
class Value;       // Ошибка: повторяющийся аргумент по умолчанию
```

Ряд контекстов не допускают аргументов шаблонов по умолчанию.
>
> Частичные специализации:
```c++
template<typename Т>
class С;

...

template<typename Т = int>
class С<Т*>; // Ошибка
```
>
> Пакеты параметров:
```c++
template<typename... Ts = int> struct X;  // Ошибка
```
>
> Определения членов шаблона класса вне класса:
```c++
template<typename Т> struct X
{
	Т f();
};

template<typename Т = int> Т Х<Т>::f()   // Ошибка
{
	...
}
```
>
> Объявление дружественного шаблона класса:
```c++
struct S
{
	template<typename = void> friend struct F;
};
```
>
> Объявление дружественного шаблона функции, если только это не определение, и нет его объявления в другом месте единицы трансляции:
```c++
struct S
{
	// Ошибка: не определение:
	template<typename = void> friend void f();
	
	// Пока что OK
	template<typename = void> friend void g()
	{    }
};

template<typename> void g(); // Ошибка: шаблон g()
						// получил аргумент шаблона по умолчанию при
						// определении; другое его объявление находиться
						// здесь не может
```

# Аргументы шаблонов

***Аргументы шаблонов*** — это значения, которые подставляются вместо параметров шаблона при инстанцировании последнего. Такие значения можно определять с использованием нескольких различных механизмов.
>
> Явные аргументы шаблона: за именем шаблона могут следовать явно указанные значения аргументов шаблона, заключенные в угловые скобки. Полученное в результате имя называется идентификатором шаблона (template-id).
> 
> Внедренное имя класса: в области видимости шаблона класса `X` с параметрами шаблона `P1`, `Р2`, . . . имя этого шаблона (`X`) может быть эквивалентно идентификатору шаблона `X<P1, Р2, ...>`. Более подробно это разъясняется в #разделе_13_2_3.
> 
> Аргументы шаблона по умолчанию: при наличии таких аргументов явно указанные аргументы шаблона в экземплярах шаблонов классов могут быть опущены. Однако для шаблона класса или шаблона псевдонима, даже если все параметры шаблона имеют значения по умолчанию, все равно должны быть указаны (возможно, пустые) угловые скобки.
> 
> Вывод аргументов: аргументы шаблонов функций, не указанные явно, могут быть получены путем вывода из типов аргументов вызова функции в ее вызове. Более подробно это описано в #главе_15, “Вывод аргументов шаблона”. Вывод также осуществляется и в некоторых других ситуациях. Если все аргументы шаблона могут быть получены путем вывода, указывать угловые скобки после имени шаблона функции не требуется. В стандарте C++17 появилась также возможность вывести аргументы шаблона класса из инициализатора объявления переменной или функциональной записи преобразования типа; см. обсуждение этого вопроса в #разделе_15_12.

## Аргументы шаблонов функций

Аргументы шаблона функции могут быть заданы явно, получены путем вывода на основе способа использования шаблона или предоставлены в виде аргументов шаблона по умолчанию. Например:
```c++
template<typename Т>
Т max(T а, Т Ь)
{
	return b < а ? а : Ь;
}

int main ()
{
	::max<double>(1.0,-3.0);    // Явное указание аргумента
	::mах(1.0,-3.0);            // Неявный вывод аргумента как double
	::max<int>(1.0, 3.0);       // Явное указание <int> подавляет
								// вывод; результат имеет тип int
}
```

Некоторые аргументы шаблонов не могут быть выведены потому, что соответствующие им параметры шаблона отсутствуют в типах параметров функции или по некоторой иной причине (см. #раздел_15_2). Соответствующие параметры обычно помещаются в начале списка параметров шаблона, так что они могут быть указаны явно, позволяя при этом выводить прочие аргументы. Например:
```c++
template<typename DstT, typename SrcT>  
DstT implicit_cast(SrcT const& x)      // SrcT можно вывести, DstT - нет
{
	return x;
}

int main()
{
	double value = implicit_cast<double>(-1);
}
```

Если обратить порядок параметров шаблона в приведенном примере (другими словами, если записать `template<typename SrcT, typename DstT>`), то вызов `implicit_cast` будет требовать явного указания обоих аргументов шаблона.

Кроме того, такие параметры бесполезно размещать после пакета параметров шаблона или в частичной специализации, поскольку при этом нет никакой возможности явно их указывать или выводить.
```c++
template<typename ... Ts, int N>
void f(double (&)[N +1], Ts ... ps);    // Бесполезное объявление,
										// так как N не может быть
										// определено или выведено
```

Поскольку шаблоны функций могут быть перегружены, явного указания всех аргументов шаблона функции может оказаться недостаточно для идентификации конкретной функции: в некоторых случаях таким образом задается множество функций. В приведенном ниже примере иллюстрируется следствие из этого обстоятельства.
```c++
template<typename Func, typename Т>
void apply(Func funcPtr, T x)
{
	funcPtr(x);
}

template<typename T> void single(T);

template<typename T> void multi(T);
template<typename T> void multi(T*);

int main()
{
	apply(&single<int>, 3); // OK
	apply(&multi<int>, 7);  // Ошибка: нет единственной multi<int>
}
```

В этом примере первый вызов `apply()` корректен, поскольку тип выражения `&single<int>` является недвусмысленным. В результате значение аргумента шаблона для параметра `Func` легко получается путем вывода. Однако во втором вызове `&multi<int>` тип может быть одним из двух разных типов, а следовательно, в данном случае `Func` вывести невозможно.

Более того, явное указание аргументов шаблона функции может привести к попытке сконструировать неверный тип или выражение C++. Рассмотрим следующий перегруженный шаблон функции (`RT1` и `RT2` являются неопределенными типами):
```c++
template<typename Т> RT1 test(typename Т::Х const*);
template<typename Т> RT2 test (...);
```

Выражение `test<int>` для первого из двух шаблонов функций не имеет смысла, поскольку у типа `int` нет члена-типа `X`. Однако для второго шаблона такая проблема отсутствует. Следовательно, выражение `&test<int>` идентифицирует адрес единственной функции. Тот факт, что подстановка `int` в первом шаблоне невозможна, не делает это выражение некорректным.

[[Программирование времени компиляции - template#SFINAE|Принцип SFINAE]] представляет собой важную составную часть практического применения перегрузки шаблонов функций и рассматривается в #разделах_15_7.

## Аргументы типов

Аргументы типов (типовые аргументы) шаблона являются “значениями”, которые указываются для параметров типов шаблона. В качестве аргументов шаблона в общем случае могут выступать любые типы (включая [[void|void]], типы функций, ссылок и т.д.) но их подстановка вместо параметров шаблонов должна приводить к корректным конструкциям:
```c++
template<typename Т>
void clear(Т р)
(
	*р = 0;     // Требует применимости к Т унарного *
}

int main()
{
	int а;
	clear(а);  // Ошибка: int не поддерживает унарный *
}
```

## Аргументы, не являющиеся типами

Не являющиеся типами (нетиповые) аргументы шаблона представляют собой значения, которые подставляются вместо параметров, не являющихся типами. Такая величина может быть одной из перечисленных ниже.
>
> Другой параметр шаблона, не являющийся типом и имеющий верный тип.
> 
> Константа времени компиляции с целочисленным типом или типом перечисления. Это допустимо только в случае, когда параметр имеет тип, соответствующий типу этого значения (или типу, к которому оно может быть неявно преобразовано без сужения. Например, тип `char` допускается для параметра с типом `int`, но значение 500 не годится для параметра, который представляет собой 8-битный `char`).
> 
> Имя внешней переменной или функции, которой предшествует встроенный унарный оператор `&` (получение адреса). Для переменных функций и массивов `&` можно опускать. Такие аргументы шаблона соответствуют не являющимся типом параметрам с типом указателя. C++17 ослабляет это требование, допуская любые константные выражения, генерирующие указатель на функцию или переменную.
> 
> Аргументы того же вида, но не предваряемые оператором `&`, являются корректными аргументами для не являющихся типом параметров ссылочного типа. Здесь С++17 также ослабляет ограничение, допуская любое константное выражение, дающее [[значение - template#gl-значение|gl-значение]] для функции или переменной.
> 
> Константный указатель на член класса, другими словами, выражение вида `&С::m`, где `C` — тип класса, a `m` — нестатический член класса (данные или функция). Такие значения соответствуют только не являющимся типом параметрам с типом указателей на член класса. И вновь в С++17 ограничения ослаблены: разрешено любое константное выражение, вычисляемое в константу, соответствующую указателю на член.
> 
> Константа нулевого указателя является корректным аргументом для не являющегося типом параметра с типом указателя или указателя на член.

Целочисленные параметры шаблонов, пожалуй, наиболее распространенная разновидность параметров шаблонов, не являющихся типами, могут использовать неявное приведение к типу параметра. С введением [[constexpr|constexpr]] функций преобразования в C++11 это означает, что аргумент перед преобразованием может иметь тип класса.

До C++17 при проверке соответствия аргумента параметру, который является указателем или ссылкой, пользовательские преобразования типа (конструкторы от одного аргумента и операторы приведения типов) и преобразования производных классов в базовые не рассматривались, хотя в других случаях они оказывались корректными неявными преобразованиями. Неявные преобразования, которые добавляют к аргументу [[const|const]] или более [[volatile|volatile]], вполне допустимы.

Вот несколько корректных примеров аргументов шаблонов, не являющихся типами:
```c++
template<typename Т, Т nontypeParam>
class С;

C<int, 33>* c1;         // Целочисленный тип

int а;
C<int*, &а>* с2;        // Адрес внешней переменной

void f();
void f(int);
C<void(*)(int), f>*c3;  // Имя функции: разрешение перегрузки в
						// данном случае выбирает f(int);
						// оператор & подразумевается

template<typename Т> void temp1_func();
C<void(), &temp1_func<double>>* c4; // Инстанцирования шаблона
									// функции являются функциями

struct X
{
	static bool b;
	int n;
	
	constexpr operator int() const
	{
		return 42;
	}
};

C<bool&, X::b>* c5;     // Статические члены класса являются
						// приемлемыми именами переменных/функций
C<int X::*, &Х::n>* с6; // Пример константного указателя на член

С<long, Х{}>* с7;       // OK: X сначала преобразуется в int c
						// constexpr преобразования, а затем в
						// long с помощью стандартного
						// целочисленного преобразования
```

Общим ограничением для аргументов шаблона является следующее: компилятор или компоновщик должны быть способны точно определить их значения при создании исполняемого файла. Значения, которые не известны до начала выполнения программы (например, адреса локальных переменных), не отвечают требованию, состоящему в том, что шаблоны должны быть инстанцированы к моменту завершения построения программы.

Но даже при выполнении данного ограничения существует несколько константных значений, которые (возможно, это покажется странным) в настоящее время некорректны:
>
> числа с плавающей точкой;
> 
> строковые литералы.

(До C++11 были не разрешены также константные нулевые указатели.)

Одна из проблем со строковыми литералами состоит в том, что два идентичных литерала могут храниться по двум разным адресам. Существует альтернативный (но громоздкий) способ определения шаблонов, инстанцирование которых осуществляется через константные строки, включая введение дополнительной переменной для хранения строки:
```c++
template<char const* str>
class Message
{
	...
};

extern char const hello[] = "Hello World!";
char const hello11[]      = "Hello World!";

void foo()
{
	static char const hello17[] = "Hello World!";
	
	Message<hello>   msg03;  // OK во всех версиях
	Message<hello11> msg11;  // OK начиная с C++11
	Message<hello17> msg17;  // OK начиная с C++17
}
```

Требование заключается в том, что параметр шаблона, не являющийся типом, и объявленный как ссылка или указатель, может быть константным выражением с внешним связыванием во всех версиях C++; с внутренним связыванием, начиная с С++11; или с любым связыванием, начиная с С++17.

В #разделе_17_2 обсуждаются возможные будущие изменения в этой области. Вот несколько других (менее неожиданных) некорректных примеров:
```c++
template<typename Т, Т nontypeParam>
class С;

struct Base
{
	int i;
} base;

struct Derived : public Base
{
} derived;

C<Base*, &derived>* errl;   // Ошибка: преобразование производного
							// класса в базовый не рассматривается

C<int&, base.i>* err2;      // Ошибка: поля переменных в качестве
							// переменных не рассматриваются

int а[10];
C<int*, &а[0]>* еггЗ;       // Ошибка: адреса элементов массива
							// также не допускаются
```

## Шаблонные аргументы шаблонов

Шаблонный аргумент шаблона должен в общем случае быть шаблоном класса или псевдонима с параметрами, которые точно соответствуют параметрам шаблонного параметра шаблона, вместо которого он подставляется. До C++17 аргументы шаблона, заданные по умолчанию для шаблонного аргумента шаблона, игнорируются (но если шаблонный параметр шаблона имеет аргументы по умолчанию, они учитываются при инстанцировании). C++17 ослабляет правило соответствия, требуя только лишь, чтобы шаблонный параметр шаблона был как минимум специализирован (см. #раздел_16_2_2), как и соответствующий шаблонный аргумент шаблона.

Таким образом, приведенный ниже пример некорректен до C++17:
```c++
#include <list>

// Объявление в пространстве имен std:
// template<typename Т, typename Allocator = allocator<T>>
// class list;

template<typename T1, typename Т2,
		template<typename> class Cont>  // Cont ожидает один параметр
class Rel
{
	...
};

Rel<int, double, std::list> rel;    // Ошибка до C++17: std::list имеет
									// больше одного параметра шаблона
```

Проблема в этом примере заключается в том, что шаблон [[list|std::list]] стандартной библиотеки имеет более одного параметра. Второй параметр (который описывает так называемый распределитель памяти) имеет значение по умолчанию, но до C++17 оно не учитывается при установлении соответствия [[list|std::list]] параметру `Cont`.

Вариативные шаблонные параметры шаблона являются исключением из описанного выше правила точного совпадения, действовавшего до C++17, и предлагают решение для этого ограничения: они обеспечивают более общее соответствие шаблонным аргументам шаблона. Пакет шаблонных параметров шаблона может соответствовать нулю или большему количеству параметров шаблона того же вида в шаблонном аргументе шаблона:
```c++
#include <list>

template<typename T1, typename T2,
		template<typename...> class Cont> // Cont ожидает любое
class Rel                                 // количество параметров типа
{
	...
};

Rel<int, double, std::list> rel;          // OK: std::list имеет два
// параметра шаблона, но может использоваться с одним параметром
```

Пакеты параметров шаблона могут соответствовать только аргументам шаблона того же вида. Например, следующий шаблон класса может быть инстанцирован с любым шаблоном класса или псевдонима, имеющим только типовые параметры шаблона, потому что пакет типовых параметров шаблона, переданный как `ТТ`, можно сопоставить нулю или большему количеству типовых параметров шаблона:
```c++
#include <list>
#include <map>

// Объявление в пространстве имен std:
// template<typename Key, typename T,
//          typename Compare = less<Key>,
//          typename Allocator = allocator<pair<Key const, T>>>
// class map;

#include <array>

// Объявление в пространстве имен std:
// template<typename T, size_t N>
// class array;
template<template<typename...> class TT>
class AlmostAnyTmp1
{
};

AlmostAnyTmp1<std::vector> withVector; // Два параметра типа
AlmostAnyTmp1<std::map> withMap;       // Четыре параметра типа
AlmostAnyTmp1<std::array> withArray;   // Ошибка: пакет типовых
							// параметров шаблона не соответствует
							// параметру шаблона, не являющемуся типом
```

Тот факт, что до C++17 для объявления шаблонного параметра шаблона могло использоваться только ключевое слово `class`, не говорит о том, что в качестве подставляемых аргументов разрешалось использовать только шаблоны класса, объявленные с помощью ключевого слова `class`. В действительности в качестве шаблонных параметров шаблона могут использоваться также `struct`, [[union|union]] и шаблоны псевдонимов (шаблоны псевдонимов — начиная с C++11, в котором они были введены). Это аналогично наблюдению, что в качестве аргумента для параметра типа шаблона, объявленного с помощью ключевого слова `class`, может использоваться любой тип.

## Эквивалентность

Два набора аргументов шаблона являются эквивалентными, если значения аргументов попарно идентичны друг другу. Для аргументов типа шаблоны типа не имеют значения — в конечном счете сравниваются типы, лежащие в основе объявлений псевдонимов. Для целочисленных аргументов, не являющихся типами, сравнивается значение аргумента; способ получения этого значения роли не играет. Сказанное выше иллюстрируется следующим примером:
```c++
template<typename Т, int I>
class Mix;

using Int = int;

Mix<int, 3*3>* p1;
Mix<Int, 4+5>* p2;    // p2 имеет тот же тип, что и p1
```

(Как видно из этого примера, для установления эквивалентности списков аргументов шаблонов определение шаблона не требуется.)

Однако в контекстах, зависимых от шаблонов, “значение” аргумента шаблона не всегда может быть установлено определенно, и правила эквивалентности становятся немного более сложными. Рассмотрим следующий пример:
```c++
template<int N> struct I {};

template<int M, int N> void f(I<M+N>);   // #1
template<int N, int M> void f(I<N+M>);   // #2

template<int M, int N> void f(I<N+M>);    // #3 Ошибка
```

Внимательно изучая объявления 1 и 2, вы заметите, что, просто переименовав `М` и `N` в соответственно `N` и `М`, вы получаете то же объявление. Поэтому эти два объявления эквивалентны и объявляют один и тот же шаблон функции `f`. Выражения `M+N` и `N+M` в этих двух объявлениях называются эквивалентными.

Однако объявление 3 немного отличается: в нем порядок операндов оказывается обратным. Это делает выражение `N+M` в объявлении 3 не эквивалентным ни одному из этих двух выражений. Однако, поскольку выражение будет давать один и тот же результат для любых значений параметров шаблона, участвующих в нем, эти выражения называются функционально эквивалентными. Объявлять шаблоны способами, которые только отличаются только потому, что объявления включают функционально эквивалентные выражения, в действительности не являющиеся эквивалентными, считаются ошибкой. Однако такая ошибка не должна быть диагностируема компилятором. Дело в том, что некоторые компиляторы могут, например, внутренне представлять `N+1+1` точно так же, как `N+2`, в то время как другие компиляторы этого не могут. Вместо того чтобы навязывать конкретный вариант реализации, стандарт позволяет любой из вариантов и требует от программистов проявлять осторожность в этой области.

Функция, сгенерированная из шаблона функции, никогда не эквивалентна обычной функции, даже если обе они имеют один и тот же тип и одно и то же имя. Отсюда вытекают два важных следствия для членов классов.

1. Функция, сгенерированная из шаблона функции-члена, никогда не может перекрыть виртуальную функцию.
2.  Конструктор, сгенерированный из шаблона конструктора, никогда не может быть копирующим или перемещающим конструктором. Аналогично оператор присваивания, сгенерированный из шаблона присваивания, никогда не является оператором копирующего или перемещающего присваивания (однако это гораздо меньшая проблема, поскольку неявные вызовы копирующего или перемещающего присваивания гораздо менее распространены).  

Это может быть и хорошо, и плохо. Подробнее эти вопросы рассматриваются [[Семантика перемещения - Шаблоны специальных функций-членов - template|тут]] и [[Семантика перемещения - Использование enable_if - template|тут]].

# Вариативные шаблоны

[[Вариативные шаблоны - template#Шаблоны с переменным количеством аргументов|Вариативные шаблоны]], представляют собой шаблоны, которые содержат по крайней мере один пакет [[Вглубь шаблонов - template#Пакеты параметров шаблонов|параметров шаблона]]. Вариативные шаблоны полезны, когда поведение шаблона может быть обобщено на произвольное количество аргументов. [[Вглубь шаблонов - template#Пакеты параметров шаблонов|Шаблон класса]] `Tuple`, является одним из таких типов, потому что кортеж может иметь любое количество элементов, которые обрабатываются одним и тем же образом. Мы также можем представить простую функцию `print()`, которая принимает произвольное количество аргументов и последовательно выводит каждый из них.

Когда для вариативного шаблона определяются аргументы шаблона, каждый пакет параметров шаблона соответствует последовательности из нуля или большего количества аргументов. Мы называем такую последовательность аргументов шаблона пакетом аргументов. В следующем примере показано, как пакет параметров шаблона `Types` соответствует различным пакетам аргументов в зависимости от аргументов шаблона, переданных [[tuple|Tuple]]:  
```c++
template<typename... Types>
class Tuple
{
		// Операции над списком типов в
};

int main()
{
	Tuple<> tO;             // Types содержит пустой список
	Tuple<int> t1;          // Types содержит int
	Tuple<int, float> t2;   // Types содержит int и float
}
```

Поскольку пакет параметров шаблона представляет собой список аргументов шаблона, а не единственный аргумент, он должен использоваться в контексте, где одна и та же языковая конструкция применяется ко всем аргументам пакета. Одной из таких конструкций является операция `sizeof...`, которая подсчитывает количество аргументов в пакете:
```c++
template<typename... Types>
class Tuple
{
	public:
		static constexpr std::size_t length = sizeof...(Types);
};

// Массив из одного целого числа:
int a1[Tuple<int>::length];

// Массив из трех целых чисел:
int аЗ[Tuple<short, int, long>::length];
```

## Раскрытие пакета

Выражение `sizeof...` является примером раскрытий (expansion) пакета. Раскрытие пакета — это конструкция, которая разделяет пакет аргументов на отдельные аргументы. В то время как `sizeof...` просто подсчитывает количество отдельных аргументов, другие виды пакетов параметров могут раскрываться в несколько элементов в этом списке. Такое расширение пакета идентифицируется многоточием (`...`) справа от элемента в списке. Вот простой пример, где мы создаем новый шаблон класса `MyTuple`, производный от [[tuple|Tuple]], с передачей его аргументов:
```c++
template<typename... Types>
class MyTuple : public Tuple<Types...>
{
	// Дополнительные операции, предоставляемые MyTuple
};

MyTuple<int, float> t2; // Наследует Tuple<int, float>
```

Аргумент шаблона `Types...` представляет собой раскрытие пакета, которое создает последовательность аргументов шаблона, по одному для каждого аргумента в пакете аргументов, подставляемом вместо `Types`. Как показано в этом примере, инстанцирование типа `MyTuple<int, float>` подставляет пакет аргументов `int, float` вместо пакета параметров типов шаблона `Types`. Когда это происходит при раскрытии пакета `Types...` мы получаем один аргумент шаблона для `int` и один для `float`, так что `MyTuple<int, float>` наследует `Tuple<int, float>`.

Чтобы интуитивно понять раскрытие пакета, рассматривайте его в терминах синтаксического раскрытия, когда пакет параметров шаблона заменяется точным количеством параметров (не пакетов) шаблона, и раскрытие пакета записывается как отдельные аргументы, по одному разу для каждого из параметров шаблона. Например, вот как будет выглядеть `MyTuple`, если выполнить раскрытие для двух параметров:
```c++
template<typename T1, typename Т2>
class MyTuple : public Tuple<T1, T2>
{
	// Дополнительные операции, предоставляемые MyTuple
};
```

и для трех параметров:
```c++
template<typename T1, typename Т2, typename Т3>
class MyTuple : public Tuple<T1, T2, T3>
{
	// Дополнительные операции, предоставляемые MyTuple
};
```

Обратите, однако, внимание на то, что доступа к отдельным элементам пакета параметров непосредственно по имени нет, потому что такие имена, как `T1`, `Т2` и так далее, не определены в вариативном шаблоне. Если вам нужны типы, единственное, что вы можете сделать — это (рекурсивно) передать их другому классу или функции.

Каждое раскрытие пакета имеет свою схему (pattern), которая представляет собой тип или выражение, которое будет повторяться для каждого аргумента в пакете аргументов, и обычно располагается перед многоточием, обозначающим раскрытие пакета. Наши предыдущие примеры имели только тривиальные схемы — имя пакета параметров, но эти схемы могут быть произвольно сложными. 

Например, можно определить новый тип `PtrTuple`, производный от [[tuple|Tuple]] указателей на типы аргументов:
```c++
template<typename... Types>
class PtrTuple : public Tuple<Types* ...>
{
	// Дополнительные операции, предоставляемые PtrTuple
};

PtrTuple<int, float> t3;  // Наследует Tuple<int*, float*>
```

Схема для раскрытия пакета `Types*...` в приведенном выше примере — это `Types*`. Повторные подстановки в эту схему создают последовательность аргументов типа шаблона, причем все они являются указателями на типы из пакета аргументов, подставляемые вместо `Types`. При синтаксической интерпретации раскрытия пакета `PtrTuple` для раскрытия трех параметров будет иметь следующий вид:
```c++
template<typename T1, typename Т2, typename Т3>
class PtrTuple : public Tuple<T1*, T2*, T3*>
{
		// Дополнительные операции, предоставляемые PtrTuple
};
```

## Где может происходить раскрытие пакета

Наши примеры до настоящего времени были сосредоточены на использовании раскрытия пакета для создания последовательности аргументов шаблона. Раскрытие пакета фактически может использоваться в языке практически везде, где грамматика допускает список, разделенный запятыми, например:
>
> в списке базовых классов;
> 
> в списке инициализаторов базовых классов в конструкторе;
> 
> в списке аргументов вызова (схема представляет собой выражение аргумента);
> 
> в списке инициализаторов (например, в списке инициализации в фигурных скобках);
> 
> в списке параметров шаблонов в шаблоне класса, функции или псевдонима;
> 
> в списке исключений, которые могут генерироваться функцией (не рекомендован в С++11 и С++14 и запрещен в С++17);
> 
> в атрибуте, если сам атрибут поддерживает раскрытие пакета (хотя такого атрибута, определенного в стандарте C++, нет);
> 
> при указании выравнивания в объявлении;
> 
> при указании списка захвата лямбда-выражения;
> 
> в списке параметров типа функции;
> 
> в [[Вариативные шаблоны - template#Вариативные базовые классы и using|объявлениях using (начиная с С++17)]].

Мы уже упоминали о [[sizeof|sizeof...]] как о механизме раскрытия пакета, который на самом деле список не генерирует. В C++17 также добавлены выражения свертки (fold expressions), которые являются еще одним механизмом, не генерирующим разделенного запятыми списка (см. #раздел_12_4_6).

Некоторые из этих контекстов раскрытия пакетов включены лишь для полноты картины, так что мы сосредоточим свое внимание только на тех контекстах раскрытия пакетов, которые могут быть полезны на практике. Поскольку раскрытие пакета во всех контекстах следует одним и тем же принципам и синтаксису, вы должны суметь экстраполировать приведенные здесь примеры на более экзотические контексты раскрытия пакетов, если в них появится необходимость.

Раскрытие пакета в списке базовых классов приводит к некоторому количеству непосредственных базовых классов. Такое раскрытие может быть полезным для агрегации внешних данных и функциональности через объекты “миксины” (mixin), которые представляют собой классы, предназначенные для смешения (mixed in) в одну иерархию классов для предоставления новых вариантов поведения. Например, показанный ниже класс `Point` использует раскрытие пакета в нескольких различных контекстах, чтобы разрешить произвольные миксины:
```c++
template<typename... Mixins>
class Point : public Mixins...  // Раскрытие пакета базовых классов
{
		double x, У, z;
	
	public:
		Point() : Mixins ()... { }  // Раскрытие пакета инициализаторов
									// базового класса
		template<typename Visitor>
		void visitMixins(Visitor visitor)
		{
			// Раскрытие пакета аргументов вызова:
			visitor(static_cast<Mixins&>(*this)...);
		}
};

struct Color
{
	char red, green, blue;
};

struct Label
{
	std::string name;
};

Point<Color, Label> p; // Наследует как Color, так и Label
```

Класс `Point` использует раскрытие пакета для получения каждого из предоставленных миксинов и развертывания его в открытый базовый класс. Затем конструктор по умолчанию класса `Point` применяет раскрытие пакета в списке инициализаторов базовых классов для инициализации каждого из базовых классов, добавленных с помощью механизма миксинов.

Функция-член шаблона `visitMixins` является наиболее интересной в том отношении, что она использует результат раскрытия пакета в качестве аргументов вызова. Путем приведения `*this` к каждому из типов миксина раскрытие пакета создает аргументы вызова, которые относятся к каждому из базовых классов. Вопросы написания функции-посетителя для использования с `visitMixins`, которая может использовать произвольное количество аргументов вызова функции, рассматриваются в #разделе_12_4_3.

Раскрытие пакета может также использоваться внутри списка параметров шаблона для создания пакетов шаблонных параметров шаблонов или параметров шаблонов, не являющихся типами:
```c++
template<typename... Ts>
struct Values
{
	template<Ts... Vs>
	struct Holder
	{
	};
};

int i;
Values<char, int, int*>::Holder<'a', 17, &i> valueHolder;
```

Обратите внимание на то, что, когда аргументы типов для `Values<...>` указаны, список аргументов, не являющихся типами, для `Values<...>::Holder` имеет фиксированную длину; таким образом, пакет параметров `Vs` не является пакетом параметров переменной длины.

`Values` представляет собой пакет параметров шаблона, не являющихся типами, в котором каждый из фактических аргументов шаблона может иметь свой тип, предоставляемый пакетом параметров типа шаблона `Types`. Обратите внимание на двойную роль многоточий в объявлении `Values` — для объявления параметра шаблона как пакета параметров и для объявления типа этого пакета параметров шаблона как раскрытия пакета. Хотя такие пакеты параметров шаблонов на практике встречаются редко, тот же принцип применяется в гораздо более распространенном контексте параметров функций.

## Пакеты параметров функций

Пакет параметров функции является параметром функции, который соответствует нулю или большему количеству аргументов вызова функции. Как и пакет параметров шаблона, пакет параметров функции вводится с помощью многоточия (`...`) до (или вместо) имени параметра функции, и, так же как пакет параметров шаблона, пакет параметров функции должен при использовании раскрываться с помощью процесса раскрытия пакета. Пакеты параметров шаблона и пакеты параметров функции вместе именуются пакетами параметров.

В отличие от пакета параметров шаблонов, пакеты параметров функций всегда являются раскрытиями параметров, так что их объявленные типы должны включать по меньшей мере один пакет параметров. В следующем примере мы вводим новый конструктор `Point`, который выполняет копирующую инициализацию каждого из миксинов из предоставленных аргументов конструктора:
```c++
template<typename... Mixins>
class Point : public Mixins...
{
		double x, y, z;
	
	public:
		// Конструктор по умолчанию, функция-посетитель и т.п. опущены
		Point(Mixins... mixins)     // mixins - пакет параметров функции
			: Mixins(mixins)... { } // Инициализация каждого объекта
};                                  // базового класса предоставленным
									// значением
struct Color
{
	char red, green, blue;
};

struct Label
{
	std::string name;
};

Point<Color, Label> p({0x7F,0,0x7F}, {"center"});
```

Пакет параметров функции для шаблона функции может зависеть от пакетов параметров шаблонов, объявленных в этом шаблоне, что позволяет шаблону функции принимать произвольное количество аргументов вызова без потери информации о типе:
```c++
template<typename... Types>
void print(Types... values);

int main
{
	std::string welcome("Welcome to ");
	print(welcome, "C++ ", 2011, '\n'); // Вызов print<std::string,
}                                       // char const*,int,char>
```

При вызове шаблона функции `print()` с некоторым количеством аргументов типы этих аргументов будут помещены в пакет аргументов для замены пакета параметров типа шаблона `Types`, в то время как фактические значения аргументов будут помещены в пакет аргументов для замены значений пакета параметров функции `values`. Процесс определения аргументов из вызова функции подробно рассматривается в #главе_15, “Вывод аргументов шаблона”. Пока что достаточно отметить, что *i-й* тип в `Types` представляет собой тип *i-го* значения в `values` и что оба эти пакета параметров доступны в теле шаблона функции `print()`.

Фактическая реализация `print()` использует рекурсивное инстанцирование шаблона, [[Программирование времени компиляции - template#Шаблонное метапрограммирование|метод шаблонного метапрограммирования]], описанный в  #главе_23, “Метапрограммирование”.

Между безымянным пакетом параметров функции в конце списка параметров и аргументами в стиле `“vararg”` языка С имеется синтаксическая неоднозначность. Например:
```c++
template<typename Т> void c_style(int, Т...);
template<typename... Т> void pack(int, T...);
```

В первом случае `“Т... `” рассматривается как `“Т, ...”`: неименованный параметр типа `Т`, за которым следует параметр `vararg` в стиле С. Во втором случае конструкция `“Т...”` рассматривается как пакет параметра функции, потому что `Т` является допустимой схемой раскрытия. Неоднозначность можно устранить, добавив запятую перед многоточием (которая заставляет рассматривать многоточие как параметр `vararg` в стиле С), или добавляя после многоточия `...` идентификатор, который делает его именованным пакетом параметров функции. Обратите внимание на то, что в обобщенном лямбда-выражении завершающее многоточие `...` будет рассматриваться как обозначающее пакет параметров, если тип, который непосредственно ему предшествует (без промежуточной запятой), содержит [[auto|auto]].

## Множественные и вложенные раскрытия пакетов

Схема раскрытия пакета может быть произвольно сложной и включать множественные, различные пакеты параметров. При инстанцировании раскрытия пакета, содержащего несколько пакетов параметров, все пакеты параметров должны иметь одинаковую длину. Результирующая последовательность типов или значений будет создаваться поэлементно, подстановкой первого аргумента каждого пакета параметров в схему, за которым будет следовать второй аргумент каждого пакета параметров, и так далее. Например, следующая функция копирует все свои аргументы перед передачей их функциональному объекту `f`:
```c++
template<typename F, typename... Types>
void forwardCopy(F f, Types const&... values)
{
	f(Types(values)...);
}
```

Раскрытие пакета аргумента вызова именует два пакета параметров, `Types`
и `values`. При инстанцировании этого шаблона поэлементное раскрытие пакетов параметров `Types` и `values` выполняет ряд конструирований объектов, при котором копия *i-го* значения в `values` создается путем приведения его к *i-му* типу в `Types`. С использованием синтаксической интерпретации раскрытия пакета трехаргументный шаблон `forwardCopy` будет выглядеть следующим образом:
```c++
template<typename F, typename T1, typename T2, typename T3>
void forwardCopy(F f, T1 const& v1, T2 const& v2, T3 const& v3)
{
	f(T1(v1), T2(v2), T3(v3));
}
```

Раскрытия пакетов сами могут быть вложенными. В таких случаях каждый встреченный пакет параметров “раскрывается” ближайшим охватывающим раскрытием пакета (и только им). Приведенный далее пример иллюстрирует вложенное раскрытие пакета, включающее три различных пакета параметров:
```c++
template<typename... OuterTypes>
class Nested
{
	template<typename... InnerTypes>
	void f(InnerTypes const& ... innerValues)
	{
		g(OuterTypes(InnerTypes(innerValues) ...) ...);
	}
};
```

В вызове `g()` раскрытие пакета со схемой `InnerTypes (innerValues)` является наиболее глубоко вложенным раскрытием пакета, которое раскрывает `InnerTypes` и `innerValues` и создает последовательность аргументов вызова функции для инициализации объекта, обозначаемого `OuterTypes`. Схема внешнего раскрытия пакета включает внутреннее раскрытие, производит набор аргументов вызова для функции `g()`, созданный на основании инициализации каждого из типов в `OuterTypes` из последовательности аргументов вызова функции, сгенерированных внутренним раскрытием. В синтаксической интерпретации этого раскрытия пакета, где `OuterTypes` имеет два аргумента, a `InnerTypes` и `innerValues` — по три аргумента, вложенность становится более очевидной:
```c++
template<typename O1, typename O2>
class Nested
{
	template<typename I1, typename I2, typename I3>
	void f(I1 const& iv1, I2 const& iv2, I3 const& iv3)
	{
		g (O1 (I1 (iv1), I2(iv2), I3(iv3)),
			O2(I1(iv1), I2(iv2), I3(iv3)));
	}
};
```

Множественные и вложенные раскрытия пакетов являются весьма мощным инструментарием (см., например, #раздел_26_2).

## Раскрытия пакетов нулевой длины

Синтаксическая интерпретация раскрытия пакета может быть полезным инструментом для понимания того, как будет себя вести инстанцирование вариативного шаблона с различным количеством аргументов. Однако синтаксические интерпретации часто не работают при наличии пакетов аргументов нулевой длины. Чтобы проиллюстрировать это, рассмотрим [[Вглубь шаблонов - template#Где может происходить раскрытие пакета|шаблон класса Point]] с синтаксической подстановкой нуля аргументов:
```c++
template<>
class Point:
{
	Point():{}
};
```

Записанный код некорректен, поскольку список параметров шаблона пуст, так что пустые списки базовых классов и их инициализаторов вырождаются в паразитные двоеточия.

Пакет расширения на самом деле является семантической конструкцией, и подстановка пакета аргументов любого размера не влияет на то, как выполняется синтаксический анализ раскрытия пакета (или охватывающего его вариативного шаблона). Когда раскрытие пакета приводит к пустому списку, программа (семантически) ведет себя так, как если бы этот список отсутствовал. Инстанцирование `Point<>` выполняется с отсутствием базовых классов, а его конструктор по умолчанию не имеет инициализаторов базовых классов и является корректно сформированным. Эти семантические правила выполняются даже тогда, когда синтаксическая интерпретация раскрытия пакета нулевой длины дает точно определенный (но иной) код. Например:
```c++
template<typename Т, typename... Types>
void g(Types... values)
{
	T v(values...);
}
```

Вариативный шаблон функции `g()` создает значение `v`, которое инициализируется непосредственно заданной последовательностью значений. Если эта последовательность значений пуста, объявление `v` синтаксически выглядит как `Т v()`. Однако, поскольку подстановка в раскрытие пакета является семантической и не влияет на тип сущности, получающейся при синтаксическом анализе, `v` инициализируется с нулевым количеством аргументов, то есть является инициализацией значения.

## Выражения свертки

Рекуррентная схема в программировании именуется ***сверткой*** (fold) операции над последовательностью значений. Например, ***правая свертка*** (right fold) функции `fn` над последовательностью `х[1], х[2], ..., х[n-1], х[n]` задается выражением:
```c++
fn(x[1], fn(x[2], fn(..., fn(x[n-1], x[n])...)))
```

При изучении новых возможностей языка Комитет по стандартизации С++ столкнулся с необходимостью работы с такими конструкциями для частного случая логического бинарного оператора (например, `&&` или `||` ), примененного к раскрытию пакета. Без такой дополнительной возможности мы могли бы написать следующий код для получения нужной функциональности для оператора `&&` следующим образом:
```c++
bool and_all()
{
	return true;
}

template<typename T>
bool and_all(T cond)
{
	return cond;
}

template<typename Т, typename... Ts>
bool and_all(T cond, Ts... conds)
{
	return cond && and_all(conds...);
}
```

В C++17 была добавлена новая возможность, именуемая [[Вариативные шаблоны - template#Выражения свертки|выражениями свертки (fold expressions)]]. Она применима ко всем бинарным операторам за исключением `.`, `->` и `[ ]`.

Для данной нераскрытой схемы выражения `pack` и выражения `value`, не являющегося схемой, С++17 позволяет записать для любого такого оператора `ор` либо
```c++
(pack ор ... op value)
```

для правой свертки оператора (именуемой ***бинарной правой сверткой***), либо
```c++
(value ор ... op pack)
```

для левой свертки (именуемой ***бинарной левой сверткой***). Обратите внимание на то, что в данном случае наличие скобок обязательно. [[Вариативные шаблоны - template#Выражения свертки|Некоторые соответствующие примеры]].

Наличие такой возможности позволяет записать код, вызывающий свойство для каждого переданного типа `Т`, наподобие
```c++
template<typename... Т> bool g()
{
	return and_all(trait<T>()...);
}
```

(где `and_all` определено выше) как
```c++
template<typename... Т> bool g()
{
	return (trait<T>() && ... && true);
}
```

Как и следует ожидать, выражения свертки являются раскрытиями пакета. Обратите внимание: если пакет пуст, то тип выражения свертки по-прежнему может быть определен из операнда, не являющегося пакетом (`value` в приведенном псевдокоде).

Однако разработчики данной возможности хотели позволить обходиться без операнда `value`. Поэтому в C++17 доступны две другие формы: ***унарная правая свертка***
```c++
(pack ор ...)
```

и унарная левая свертка
```c++
( ... op pack)
```

Здесь также необходимо наличие скобок. Очевидно, что в данном случае мы сталкиваемся с проблемой пустого раскрытия: как определить его тип и значение? Ответ заключается в том, что пустое раскрытие унарной свертки в общем случае является ошибкой, с тремя исключениями.
>
> Пустое раскрытие унарной свертки `&&` дает значение `true`.
> 
> Пустое раскрытие унарной свертки `||` дает значение `false`.
> 
> Пустое раскрытие унарной свертки оператора запятой (`,`) дает выражение типа [[void|void]].

Обратите внимание, что если вы перегрузите один из этих специальных операторов необычным способом, возможны сюрпризы. Например:
```c++
struct BooleanSymbol
{	
	...   
};

BooleanSymbol operator||(BooleanSymbol, BooleanSymbol);

template<typename... BTs> 
void symbolic(BTs... ps)
{
	BooleanSymbol result = (ps || ...);

	...
}
```

Предположим, что мы вызываем `symbolic` с типами, производными от `BooleanSymbol`. Для всех раскрытий результат будет производить значение `BooleanSymbol`, за исключением пустого раскрытия, которое будет давать значение типа `bool`. Поэтому обычно рекомендуется не использовать ***унарные выражения свертки***, прибегая вместо них к ***бинарным выражениям свертки*** (с явно указанным значением для пустого раскрытия).

# Друзья

Основная идея объявления друзей проста: определить классы или функции, которые имеют привилегированную связь с классом, в котором находится `friend`-объявление. Однако все осложняется следующими двумя фактами.
>
> Объявление дружбы может быть только объявлением сущности.
> 
>  Объявление дружественной функции может быть определением.

## Дружественные классы шаблонов классов

Объявления дружественных классов не могут быть определениями, а потому редко проблематичны. В контексте шаблонов единственным новым аспектом объявления дружественного класса является возможность объявить другом конкретный экземпляр шаблона класса:
```c++
template<typename Т>
class Node;
template<typename Т>
class Tree
{
	friend class Node<T>;

	...
};
```

Обратите внимание на то, что шаблон класса должен быть видимым в точке, где один из его экземпляров становится другом класса или шаблона класса. В случае обычного класса такое требование не предусмотрено:
```c++
template<typename Т>
class Tree
{
	friend class Factory;   // OK, даже если это первое
							// объявление Factory
	friend class Node<T>;   // Ошибка, если Node
							//не является видимым
);
```

Более подробно этот вопрос рассматривается в #разделе_13_2_2.

[[Шаблоны-члены|Одно из приложений]], является объявлением в качестве дружественных инстанцирований другого шаблона класса:
```c++
template<typename Т>
class Stack
{
	public:
		...
	// Присваивание стека элементов типа Т2
	template<typename Т2>
	Stack<T>& operator= (Stack<T2> const&);
	// Для получения доступа к закрытым членам
	// Stack<T2> для любого типа Т2:
	template<typename> friend class Stack;
	
	...
};
```

Стандарт C++11 добавляет синтаксис, позволяющий сделать другом параметр шаблона:
```c++
template<typename Т>
class Wrap
{
	friend Т;

	...
};
```

Этот код корректен для любого типа `Т`, но игнорируется, если `Т` на самом деле не является типом класса.

## Дружественные функции шаблонов классов

Экземпляр шаблона функции можно сделать другом, добавив после имени функции-друга угловые скобки. Угловые скобки могут содержать аргументы шаблона, но если аргументы могут быть выведены, то угловые скобки можно оставить пустыми:
```c++
templatе<typename T1, typename T2>
void combine(T1, T2);

class Mixer
{
	friend void combine<> (int&, int&);
	// OK: T1 = int&, T2 = int&
	
	friend void combine<int, int>(int, int);
	// OK: T1 = int, T2 = int
	
	friend void combine<char>(char, int);
	// OK: T1 = char T2 = int
	
	friend void combine<char>(char&, int);
	// Ошибка: нет соответствующего шаблона combine<>
	
	friend void combine<> (long, long)
	{
		...
	}
	// Ошибка: определение не разрешено!
};
```

Обратите внимание на то, что мы не можем определить экземпляр шаблона (в лучшем случае мы можем определить специализацию),0 а следовательно, объявление друга, именующее экземпляр, не может быть определением.

Если после имени нет угловых скобок, то у нас есть две возможности.
>
> Если имя не квалифицированное (иными словами, не содержит `::`), оно никогда не ссылается на экземпляр шаблона. Если нет подходящей видимой нешаблонной функции при объявлении друга, это объявление является первым объявлением данной функции. Это объявление может быть также и определением.
> 
> Если имя является квалифицированным (содержит `::`), это имя должно ссылаться на ранее объявленную функцию или шаблон функции. Функции с соответствием аргументов предпочтительнее, чем соответствующий аргументам шаблон функции. Однако такое объявление друга не может быть определением.

Приведенный ниже пример может пояснить разные возможности.
```c++
void multiply(void*);          // Обычная функция

template<typename Т>
void multiply(Т);              // Шаблон функции 

class Comrades
{
	friend void multiply(int) { }
	// Определение новой функции :imultiply(int)

	friend void ::multiply(void*);
	// Ссыпка на приведенную выше обычную функцию,
	// но не на экземпляр multiply<void*>
	
	friend void ::multiply(int);
	// Ссылка на экземпляр шаблона
	
	friend void ::multiply<double*>(double*);
	// Квалифицированные имена также могут иметь
	// угловые скобки, но шаблон должен быть видимым
	
	friend void ::error() { }
	// Ошибка: квалифицированный друг не может быть определением
}
```

В наших предыдущих примерах мы объявляли дружественные функции в обычном классе. Те же правила применяются и когда мы объявляем их в шаблонах классов, но в определении того, какая функция является другом, могут участвовать параметры шаблона:
```c++
template<typename Т>
class Node
{
	Node<T>* allocated;

	...
};

template<typename T>
class List
{
	friend Node<T>* Node<T>::allocate();

	...
};
```

Дружественная функция может быть также определена в шаблоне класса; в этом случае она инстанцируется только когда на самом деле используется. Это обычно требует от дружественной функции, чтобы она использовала сам шаблон класса в типе дружественной функции, что позволяет легче выражать функции в шаблоне класса, которые могут быть вызваны, как если бы они были видимы в области видимости пространства имен:
```c++
template<typename Т>
class Creator
{
	friend void feed(Creator<T>)  // Каждый T инстанцирует
	{                             // другую функцию ::feed()
		...
	}

int main()
(
	Creator<void> one;
	feed(one);              // Инстанцирует ::feed(Creator<void>)
	
	Creator<double> two;
	feed(two);              // Инстанцирует ::feed(Creator<double>)
```

В этом примере каждое инстанцирование `Creator` создает другую функцию. Обратите внимание: даже несмотря на то, что эти функции генерируются как часть инстанцирования шаблона, сами функции являются обычными функциями, а не экземплярами шаблона. Однако они рассматриваются как [[Вглубь шаблонов - template#Параметризованные объявления|шаблонные сущности]], и их определение инстанцируется только при использовании. Учтите также, что, поскольку тела этих функций определяются внутри определения класса, они неявно являются встраиваемыми. Следовательно, не является ошибкой генерация одной и той же функции в двух разных единицах трансляции. Более подробно эта тема рассматривается в #разделах_13_2_2 и #21_2_1.

## Дружественные шаблоны

Обычно при объявлении друга, который является экземпляром шаблона функции или класса, мы можем точно указать, какая именно сущность должна быть другом. Иногда, тем не менее, полезно указать, что все экземпляры шаблона являются друзьями класса. Для этого нужен дружественный шаблон. Например:
```c++
class Manager
{
	template<typename Т>
	friend class Task;

	template<typename T>
	friend void Schedule<T>::dispatch(Task<T>*);

	template<typename T>
	friend int ticket()
	{
		return ++Manager::counter;
	}
	
	static int counter;
};
```

Так же, как и в случае объявлений обычных друзей, дружественный шаблон может быть определением, только если он использует неквалифицированное имя функции, не сопровождающееся угловыми скобками.

Дружественный шаблон может объявлять только первичные шаблоны и их члены. Любые частичные и явные специализации, связанные с первичным шаблоном, также автоматически рассматриваются как друзья.

