
[[#Специализация и перегрузка|Специализация и перегрузка]] 16
1. [[#Когда обобщенный код недостаточно хорош|Когда обобщенный код недостаточно хорош]] 16.1
	1. [[#Прозрачная настройка|Прозрачная настройка]] 16.1.1
	2. [[#Семантическая прозрачность|Семантическая прозрачность]] 16.1.2
2. [[#Перегрузка шаблонов функций|Перегрузка шаблонов функций]] 16.2
	1. [[#Сигнатуры|Сигнатуры]] 16.2.1
	2. [[#Частичное упорядочение перегруженных шаблонов функций|Частичное упорядочение перегруженных шаблонов функций]] 16.2.2
	3. [[#Правила формального упорядочения|Правила формального упорядочения]] 16.2.3
3. [[#Шаблоны и нешаблоны|Шаблоны и нешаблоны]] 16.2.4


# Специализация и перегрузка

Сейчас вы уже знаете, как шаблоны C++ обеспечивают расширение обобщенного определения в семейство связанных классов, функций или переменных. Хотя это и мощный механизм, существует много ситуаций, в которых при замене параметров шаблона обобщенная форма работы далека от оптимальной.

Язык C++ в определенной мере уникален среди прочих популярных языков программирования с поддержкой обобщенного программирования, поскольку обладает богатым набором возможностей, позволяющих осуществлять прозрачную подмену обобщенного определения более специализированными. В этой главе представлены два механизма языка C++, которые позволяют реализовать полезные отступления от обобщенного подхода: специализация шаблона и перегрузка шаблонов функций.

## Когда обобщенный код недостаточно хорош

Рассмотрим следующий пример:
```c++
template<typename Т>
class Array
{
	private:
		Т* data;

		...
	public:
		Array(Array<T> const&);
		Array<T>& operator= (Array<T> const&);
		
		void exchangeWith(Array<T>* b)
		{
			T* tmp = data;
			data = b->data;
			b->data = tmp;
		}
		
		T& operator[](std::size_t k)
		{
			return data[k];
		}
	
		...
};

template<typename T> inline
void exchange(T* a, T* b)
{
	T tmp(*a);
	*a = *b;
	*b = tmp;
}
```

Для простых типов обобщенная реализация функции `exchange()` работает хорошо. Однако для типов с дорогостоящими операциями копирования обобщенная реализация может быть значительно более ресурсоемкой (как в плане использования машинного времени, так и памяти), чем реализация, настроенная под конкретную структуру данных. В нашем примере обобщенная реализация требует одного вызова конструктора копирования шаблона `Аrrау<Т>` и двух вызовов оператора копирующего присваивания. Для больших структур данных создание таких копий часто сопровождается копированием относительно больших объемов памяти. Однако функциональность `exchange()` часто может заменяться простым обменом указателями, подобно тому, как это делается в функции-члене `exchangeWith()`.

## Прозрачная настройка

В предыдущем примере функция-член `exchangeWith()` обеспечивала эффективную альтернативу обобщенной функции `exchange()`. Тем не менее по ряду причин использование другой функции неудобно.
>
> Пользователи класса [[Array|Array]] должны помнить о дополнительном интерфейсе и по возможности аккуратно им пользоваться.
> 
> Обобщенные алгоритмы в общем случае не могут различать различные возможные варианты. Например:
```c++
template<typename Т>
void genericAlgorithm(T* х, Т* у)
{
	...
	
	exchange(х, у); // Как выбрать правильный алгоритм?

	...
}
```

По этим соображениям шаблоны C++ обеспечивают прозрачные способы настройки шаблонов функций и классов. Для шаблонов функций это достигается через механизм перегрузки. Например, можно написать перегруженный набор
шаблонов функций `quickExchange()`, как показано ниже.
```c++
template<typename Т>
void quickExchange(Т* а, Т* Ь)      // #1
{
	Т tmp(*а);
	*а = *Ь;
	*b = tmp;
}

template<typename Т>               // #2
void quickExchange(Аггау<T>* a, Array<T>* b)
{
	a->exchangeWith(b);
}

void demo(Array<int>* p1, Array<int>* p2)
{
	int x = 42, у = -7;
	quickExchange(&x, &y);         // Используется #1 
	quickExchange(p1, p2);         // Используется #2
}
```

Первый вызов `quickExchange()` имеет два аргумента типа `int*`, поэтому вывод аргументов выполняется успешно только для первого шаблона, объявленного в строке `#1`, когда тип `Т` заменяется типом `int`. Поэтому не возникает сомнений относительно того, какую функцию нужно вызвать. Второй же вызов соответствует обоим шаблонам: подходящие функции для вызова `quickExchange (p1, р2)` получаются как подстановкой `Array<int>` вместо `Т` в первом шаблоне, так и подстановкой `int` во втором шаблоне. Кроме того, обе подстановки дают функции с типами параметров, которые точно соответствуют типам аргументов во втором вызове. Обычно это позволяет заключить, что вызов неоднозначен, однако (как выяснится позже) язык C++ считает второй шаблон “более специализированным”, чем первый. При прочих равных условиях разрешение перегрузки отдает предпочтение более специализированному шаблону, и поэтому выбирается шаблон из строки `#2`.

## Семантическая прозрачность

Использование перегрузки, как было показано в предыдущем разделе, очень полезно при достижении прозрачной настройки процесса инстанцирования. При этом важно понимать, что такая “прозрачность” существенно зависит от деталей реализации. Чтобы проиллюстрировать это, рассмотрим наше решение `quickExchange()`. Хотя и обобщенный алгоритм, и алгоритм, настроенный для типов `Аггау<Т>`, заканчиваются обменом значений, на которые указывают указатели, побочные эффекты этих операций существенно отличаются. Яркой иллюстрацией тому может служить код, который сравнивает обмен структурных объектов с обменом шаблонов `Аггау<Т>`.
```c++
struct S
{
	int х;
} s1, s2;

void distinguish(Array<int> a1, Array<int> a2)
{
	int* p = &a1[0];
	int* q = &s1.x;
	
	a1[0] = s1.x = 1;
	a2[0] = s2.x = 2;

	quickExchange(&a1, &a2); // После этого *p == 1  (все еще)
	quickExchange(&s1, &s2); // После этого *q == 2
}
```

Этот пример показывает, что после вызова `quickExchange()` указатель `р` на первый массив [[Array|Array]] становится указателем на второй массив. Однако указатель на поле объекта `s1`, не являющегося массивом, продолжает указывать на поле структуры `s1` даже после выполнения операции обмена. Единственное изменение — поменялись местами значения, на которые указывают указатели. Это весьма существенное отличие, которое может сбивать с толку пользователей шаблона. Применение префикса `quick` позволяет привлечь внимание к тому, что данная реализация представляет собой сокращенный вариант нужной операции. Однако первоначальный обобщенный шаблон `exchange()` может при этом содержать оптимизацию для шаблонов `Аггау<Т>`:
```c++
template<typename Т>
void exchange(Array<T>* a, Array<T>* b)
{
	T* p = &(*a)[0];
	T* q = &(*b)[0];

	for(std::size_t k = a->size(); k--!= 0;)
	{
		exchange(p++, q++);
	}
}
```

Преимущество этой версии обобщенного кода заключается в том, что при этом не требуется создавать (потенциально) большой временный массив `Аггау<Т>`. Шаблон `exchange()` вызывается рекурсивно, чем достигается хорошая производительность даже для таких типов, как `Array<Array<char>>`. Отметим также, что более специализированная версия шаблона не объявлена как [[inline|inline]], поскольку выполняет значительный объем работы. В то же время первоначальная обобщенная реализация является встроенной, поскольку выполняет только несколько операций (каждая из которых потенциально является дорогостоящей).

# Перегрузка шаблонов функций

В предыдущем разделе было показано, что возможно сосуществование двух шаблонов функций с одним и тем же именем, даже если они могут быть инстанцированы с параметрами идентичных типов. Приведем еще один простой пример этого.
```c++
template<typename T>
int f (T)
{
	return 1;
}

template<typename T>
int f(T*)
{
	return 2;
}
```

Когда тип `T` заменяется типом `int*` в первом шаблоне, получается функция, у которой есть точно такие же типы параметров (и возвращаемых значений), что и у функции, получаемой при замене типа `int` типом `Т` во втором шаблоне. Сосуществовать могут не только эти шаблоны, но и их инстанцирования, даже если у них идентичны типы параметров и возвращаемых значений.

Приведенный ниже пример демонстрирует, как можно вызвать две такие сгенерированные функции с помощью синтаксиса явного аргумента шаблона (в предположении предыдущих объявлений шаблона):
```c++
#include <iostream>
#include "funcoverload1.hpp"

int main()
{
	std::cout << f<int*>((int*)nullptr);   // Вызов f<T>(T)
	std::cout << f<int> ((int*)nullptr);   // Вызов f<T>(T*)
}
```

Результатом выполнения этой программы будет следующий вывод:
```
12
```

Чтобы объяснить работу программы, подробно проанализируем вызов `f<int*>((int*)nullptr)`. Синтаксис `f<int*>` обозначает, что первый параметр шаблона `f` нужно заменить значением типа `int*` без использования вывода аргумента шаблона. В этом случае существует более одного шаблона `f` и поэтому создается набор перегрузки, содержащий две функции, сгенерированные из шаблонов: `f<int*> (int*)` (сгенерированная из первого шаблона) и `f<int*> (int**)` (сгенерированная из второго шаблона). Аргумент вызова `(int*) nullptr` имеет тип `int*`, который соответствует только функции, сгенерированной из первого шаблона. Следовательно, это и есть функция, которая будет вызвана в конечном итоге.

С другой стороны, для второго вызова множество перегрузки содержит функции `f<int> (int)` (генерируется из первого шаблона) и `f<int> (int*)` (генерируется из второго шаблона), так что соответствует аргументу только второй шаблон.

## Сигнатуры

Две функции могут сосуществовать в программе, если у них разные сигнатуры. Определим сигнатуру как приведенную ниже информацию.
1. Неквалифицированное имя функции (или имя шаблона функции, из которого она генерируется).
2. Область видимости класса или пространства имен и, если это имя имеет внутреннее связывание, единица трансляции, в которой объявлено имя.
3. Классификация функции как [[const|const]], [[volatile|volatile]] или `const volatile` (если это функция-член с данным квалификатором).
4. Квалификаторы `&` или `&&` функции (если она является функцией-членом с таким квалификатором).
5. Типы параметров функции (перед подстановкой параметров шаблона, если функция генерируется из шаблона функции).
6. Если функция генерируется из шаблона функции, то тип ее возвращаемого значения.
7. Параметры и аргументы шаблона, если функция генерируется из шаблона функции.

Это означает, что в одной и той же программе могут сосуществовать следующие шаблоны и их инстанцирования:
```c++
template<typename T1, typename Т2>
void f1(T1, T2);

template<typename T1, typename T2>
void f1(T2, T1);

template<typename T>
long f2(T);

template<typename T>
char f2(T);
```

Однако их не всегда можно использовать, если они объявлены в одной и той же области видимости, поскольку при их инстанцировании возникает неоднозначность перегрузки. Например, очевидно, что вызов `f2(42)` приводит к неоднозначности, если объявлены оба соответствующих шаблона, приведенных выше. 

Еще один пример показан ниже:
```c++
#include <iostream>
template<typename T1, typename T2>
void f1(T1, T2)
{
	std::cout << "f1(T1, T2)\n";
}

template<typename T1, typename T2>
void f1(T2, T1)
{
	std::cout << "f1(T2, T1)\n";
}

// Пока все в порядке
int main()
{
	f1<char, char>('a', 'b');     // Ошибка: неоднозначность
}
```

Здесь функция
```c++
f1<T1 = char, T2 = char>(T1, T2)
```

может сосуществовать с функцией
```c++
f1<T1 = char, Т2 = char>(T2, T1)
```

однако разрешение перегрузки никогда не отдаст предпочтения одной из них. Если эти шаблоны появляются в различных единицах трансляции, эти два экземпляра действительно могут существовать в одной и той же программе (при этом компоновщик не должен жаловаться на двойное определение, поскольку сигнатуры инстанцирований различны):
```c++
// ===== Единица трансляции 1:
#include <iostream>

template<typename T1, typename T2>
void f1(T1, T2)
{
	std::cout << "f1(T1, T2)\n";
}

void g()
{
	f1<char, char>('a', 'b');
}

// ===== Единица трансляции 2:
#include <iostream>

template<typename T1, typename T2>
void f1(T2, T1)
{
	std::cout << "f1(T2, T1)\n";
}

extern void g(); // Определена в единице трансляции 1

int main()
{
	f1<char, char>('a', 'b');
	g();
}
```

Эта программа корректна и выдает следующее:
```c++
f1(T2, T1)
f1(T1, Т2)
```

## Частичное упорядочение перегруженных шаблонов функций

Вернемся к рассмотренному ранее примеру. Мы обнаружили, что после подстановки данных списков аргументов (`<int*>` и `<int>`), разрешение перегрузки в конечном итоге выбирает для вызова нужную функцию:
```c++
std::cout << f<int*>((int*)nullptr); // Вызов f<T>(T)
std::cout << f<int>((int*)nullptr);  // Вызов f<T>(T*)
```

Однако выбор функции происходит даже тогда, когда явные аргументы шаблона не указаны. В этом случае вступает в игру вывод аргумента шаблона. Чтобы обсудить этот механизм, давайте немного модифицируем функцию `main()` из предыдущего примера.
```c++
#include <iostream>

template<typename T>
int f(T)
{
	return 1;
}

template<typename T>
int f(T*)
{
	return 2;
}

int main()
{
	std::cout << f(0);               // Вызов f<T>(T)
	std::cout << f(nullptr);         // Вызов f<T>(T)
	std::cout << f((int*)nullptr);   // Вызов f<T>(T*)
}
```

Рассмотрим первый вызов, `f(0)`: здесь тип аргумента — `int`, который соответствует типу параметра первого шаблона, если заменить `Т` на `int`. Однако тип параметра второго шаблона — это всегда указатель, и, следовательно, после вывода кандидатом для вызова будет только экземпляр, сгенерированный из первого шаблона. В этом случае разрешение перегрузки тривиально.

То же самое можно сказать и о втором вызове, `f(nullptr)`. Тип аргумента в этом случае [[nullptr_t|std::nullptr_t]], который опять же соответствует только первому шаблону.

Третий вызов `(f((int*)nullptr))` более интересен: осуществить вывод аргумента удается для обоих шаблонов, что дает функции `f<int*>(int*)` и `f<int> (int*)`. С точки зрения традиционного разрешения перегрузки обе функции одинаково хороши для вызова с аргументом `int*`, что соответствует неоднозначности вызова (см. #приложение_В, “Разрешение перегрузки”). Однако в таких случаях вступает в игру дополнительный критерий перегрузки: выбирается функция, сгенерированная из более специализированного шаблона. Здесь, как вы скоро увидите, второй шаблон считается более специализированным, а потому результатом работы этой программы будет
```
112
```

## Правила формального упорядочения

В нашем последнем примере интуитивно вполне понятно, что второй шаблон “более специальный”, чем первый, поскольку первый может быть подстроен почти под любой тип аргумента, тогда как второй разрешает только типы-указатели. Однако другие примеры могут оказаться не столь очевидными. Далее описана точная процедура определения того, является ли один шаблон, участвующий в наборе перегрузки, более специализированным, чем другой. Отметим, однако, что это правила лишь частичного упорядочения: возможна ситуация, когда ни один из шаблонов не будет считаться более специализированным, чем другой. Если разрешение перегрузки должно выбирать между такими шаблонами, решение принято не будет и в программе возникнет ошибка неоднозначности.

Предположим, сравниваются два идентично именованных шаблона, которые кажутся подходящими для данного вызова функции. Разрешение перегрузки принимает решение следующим образом.
>
> Параметры вызова функции, которые используют аргументы по умолчанию или многоточия, игнорируются.
> 
> Создаются два искусственных списка типов аргументов (а для шаблона функции преобразования типов — возвращаемого типа) путем подстановки каждого параметра шаблона следующим образом.
> 	1. Заменим каждый типовой параметр шаблона уникальным искусственным типом.
> 	2. Заменим каждый шаблонный параметр шаблона уникальным искусственным шаблоном класса.
> 	3. Заменим каждый шаблонный параметр, не являющийся типом, уникальным искусственным значением соответствующего типа. (Искусственные типы, шаблоны и значения в этом контексте отличаются от любых прочих типов, шаблонов или значений, как используемых программистом, так и создаваемых компилятором в других контекстах.)
>
> Если вывод аргументов второго шаблона из первого синтезированного списка типов аргументов происходит успешно при точном соответствии, но не наоборот, то говорят, что первый шаблон является более, специализированным, чем второй. Если вывод аргументов первого шаблона для второго синтезированного списка типов аргументов происходит успешно при точном соответствии, но не наоборот, то говорят, что второй шаблон является более специализированным, чем первый. В ином случае (если нет ни одного успешного вывода или же оба вывода успешны) упорядочения шаблонов не происходит.

Попробуем применить этот подход к двум шаблонам в предыдущем примере. Для этих шаблонов синтезируются два списка типов аргументов путем замены шаблонных параметров описанным выше способом: (`А1`) и (`А2*`), где `А1` и `А2` — уникальные искусственные типы. Очевидно, что вывод первого шаблона для второго списка типов аргументов происходит успешно при замене `А2*` на `Т`. Однако тип `Т*` из второго шаблона невозможно сделать соответствующим типу `А1` из первого списка, который не является типом указателя. Следовательно, формально можно заключить, что второй шаблон более специализирован, чем первый.

Рассмотрим более сложный пример с использованием нескольких параметров функций.
```c++
template<typename Т>
void t(T*, Т const* = nullptr, ...);

template<typename T>
void t(T const*, T*, T* = nullptr);

void example(int* p)
{
	t(p, p);
}
```

Прежде всего, поскольку реальный вызов не использует параметр многоточия для первого шаблона, а последний параметр второго шаблона покрывается аргументом по умолчанию, эти аргументы при частичном упорядочении игнорируются. Отметим, что аргумент первого шаблона по умолчанию не используется. Поэтому соответствующий параметр участвует в упорядочении.

Созданные списки типов аргументов — это (`А1*`, `A1 const*`) и (`А2 const*`, `А2*`). Вывод аргументов шаблона (`A1*`, `A1 const*`) для второго шаблона успешен при замене `Т` на `A1 const`, однако результирующее соответствие не точное, поскольку для вызова `t<A1 const>(A1 const*,A1 const*, A1 const*=0)` с аргументами типов (`A1*`, `A1 const*`) требуется дополнительное уточнение типов. Точно так же нельзя найти точное соответствие при выводе аргументов шаблона для первого шаблона из списка типов аргументов `(А2 const*, А2*)`. Следовательно, между двумя шаблонами нет отношения упорядочения и вызов неоднозначен.

Формальные правила упорядочения обычно обеспечивают возможность интуитивно очевидного выбора шаблонов функций. Тем не менее можно привести множество примеров, когда интуитивно очевидный выбор оказывается невозможным. Вероятно, данные правила упорядочения в будущем могут быть пересмотрены, чтобы такие ситуации стали разрешимыми.

## Шаблоны и нешаблоны














