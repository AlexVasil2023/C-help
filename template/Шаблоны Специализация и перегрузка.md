
[[#Специализация и перегрузка|Специализация и перегрузка]] 16
1. [[#Когда обобщенный код недостаточно хорош|Когда обобщенный код недостаточно хорош]] 16.1
	1. [[#Прозрачная настройка|Прозрачная настройка]] 16.1.1
	2. [[#Семантическая прозрачность|Семантическая прозрачность]] 16.1.2
2. [[#Перегрузка шаблонов функций|Перегрузка шаблонов функций]] 16.2
	1. [[#Сигнатуры|Сигнатуры]] 16.2.1
	2. [[#Частичное упорядочение перегруженных шаблонов функций|Частичное упорядочение перегруженных шаблонов функций]] 16.2.2
	3. [[#Правила формального упорядочения|Правила формального упорядочения]] 16.2.3
	4. [[#Шаблоны и нешаблоны|Шаблоны и нешаблоны]] 16.2.4
	5. [[#Вариативные шаблоны функций|Вариативные шаблоны функций]] 16.2.5
3. [[#Явная специализация|Явная специализация]] 16.3
	1. [[#Полная специализация шаблона класса|Полная специализация шаблона класса]] 16.3.1


# Специализация и перегрузка

Сейчас вы уже знаете, как шаблоны C++ обеспечивают расширение обобщенного определения в семейство связанных классов, функций или переменных. Хотя это и мощный механизм, существует много ситуаций, в которых при замене параметров шаблона обобщенная форма работы далека от оптимальной.

Язык C++ в определенной мере уникален среди прочих популярных языков программирования с поддержкой обобщенного программирования, поскольку обладает богатым набором возможностей, позволяющих осуществлять прозрачную подмену обобщенного определения более специализированными. В этой главе представлены два механизма языка C++, которые позволяют реализовать полезные отступления от обобщенного подхода: специализация шаблона и перегрузка шаблонов функций.

## Когда обобщенный код недостаточно хорош

Рассмотрим следующий пример:
```c++
template<typename Т>
class Array
{
	private:
		Т* data;

		...
	public:
		Array(Array<T> const&);
		Array<T>& operator= (Array<T> const&);
		
		void exchangeWith(Array<T>* b)
		{
			T* tmp = data;
			data = b->data;
			b->data = tmp;
		}
		
		T& operator[](std::size_t k)
		{
			return data[k];
		}
	
		...
};

template<typename T> inline
void exchange(T* a, T* b)
{
	T tmp(*a);
	*a = *b;
	*b = tmp;
}
```

Для простых типов обобщенная реализация функции `exchange()` работает хорошо. Однако для типов с дорогостоящими операциями копирования обобщенная реализация может быть значительно более ресурсоемкой (как в плане использования машинного времени, так и памяти), чем реализация, настроенная под конкретную структуру данных. В нашем примере обобщенная реализация требует одного вызова конструктора копирования шаблона `Аrrау<Т>` и двух вызовов оператора копирующего присваивания. Для больших структур данных создание таких копий часто сопровождается копированием относительно больших объемов памяти. Однако функциональность `exchange()` часто может заменяться простым обменом указателями, подобно тому, как это делается в функции-члене `exchangeWith()`.

## Прозрачная настройка

В предыдущем примере функция-член `exchangeWith()` обеспечивала эффективную альтернативу обобщенной функции `exchange()`. Тем не менее по ряду причин использование другой функции неудобно.
>
> Пользователи класса [[Array|Array]] должны помнить о дополнительном интерфейсе и по возможности аккуратно им пользоваться.
> 
> Обобщенные алгоритмы в общем случае не могут различать различные возможные варианты. Например:
```c++
template<typename Т>
void genericAlgorithm(T* х, Т* у)
{
	...
	
	exchange(х, у); // Как выбрать правильный алгоритм?

	...
}
```

По этим соображениям шаблоны C++ обеспечивают прозрачные способы настройки шаблонов функций и классов. Для шаблонов функций это достигается через механизм перегрузки. Например, можно написать перегруженный набор
шаблонов функций `quickExchange()`, как показано ниже.
```c++
template<typename Т>
void quickExchange(Т* а, Т* Ь)      // #1
{
	Т tmp(*а);
	*а = *Ь;
	*b = tmp;
}

template<typename Т>               // #2
void quickExchange(Аггау<T>* a, Array<T>* b)
{
	a->exchangeWith(b);
}

void demo(Array<int>* p1, Array<int>* p2)
{
	int x = 42, у = -7;
	quickExchange(&x, &y);         // Используется #1 
	quickExchange(p1, p2);         // Используется #2
}
```

Первый вызов `quickExchange()` имеет два аргумента типа `int*`, поэтому вывод аргументов выполняется успешно только для первого шаблона, объявленного в строке `#1`, когда тип `Т` заменяется типом `int`. Поэтому не возникает сомнений относительно того, какую функцию нужно вызвать. Второй же вызов соответствует обоим шаблонам: подходящие функции для вызова `quickExchange (p1, р2)` получаются как подстановкой `Array<int>` вместо `Т` в первом шаблоне, так и подстановкой `int` во втором шаблоне. Кроме того, обе подстановки дают функции с типами параметров, которые точно соответствуют типам аргументов во втором вызове. Обычно это позволяет заключить, что вызов неоднозначен, однако (как выяснится позже) язык C++ считает второй шаблон “более специализированным”, чем первый. При прочих равных условиях разрешение перегрузки отдает предпочтение более специализированному шаблону, и поэтому выбирается шаблон из строки `#2`.

## Семантическая прозрачность

Использование перегрузки, как было показано в предыдущем разделе, очень полезно при достижении прозрачной настройки процесса инстанцирования. При этом важно понимать, что такая “прозрачность” существенно зависит от деталей реализации. Чтобы проиллюстрировать это, рассмотрим наше решение `quickExchange()`. Хотя и обобщенный алгоритм, и алгоритм, настроенный для типов `Аггау<Т>`, заканчиваются обменом значений, на которые указывают указатели, побочные эффекты этих операций существенно отличаются. Яркой иллюстрацией тому может служить код, который сравнивает обмен структурных объектов с обменом шаблонов `Аггау<Т>`.
```c++
struct S
{
	int х;
} s1, s2;

void distinguish(Array<int> a1, Array<int> a2)
{
	int* p = &a1[0];
	int* q = &s1.x;
	
	a1[0] = s1.x = 1;
	a2[0] = s2.x = 2;

	quickExchange(&a1, &a2); // После этого *p == 1  (все еще)
	quickExchange(&s1, &s2); // После этого *q == 2
}
```

Этот пример показывает, что после вызова `quickExchange()` указатель `р` на первый массив [[Array|Array]] становится указателем на второй массив. Однако указатель на поле объекта `s1`, не являющегося массивом, продолжает указывать на поле структуры `s1` даже после выполнения операции обмена. Единственное изменение — поменялись местами значения, на которые указывают указатели. Это весьма существенное отличие, которое может сбивать с толку пользователей шаблона. Применение префикса `quick` позволяет привлечь внимание к тому, что данная реализация представляет собой сокращенный вариант нужной операции. Однако первоначальный обобщенный шаблон `exchange()` может при этом содержать оптимизацию для шаблонов `Аггау<Т>`:
```c++
template<typename Т>
void exchange(Array<T>* a, Array<T>* b)
{
	T* p = &(*a)[0];
	T* q = &(*b)[0];

	for(std::size_t k = a->size(); k--!= 0;)
	{
		exchange(p++, q++);
	}
}
```

Преимущество этой версии обобщенного кода заключается в том, что при этом не требуется создавать (потенциально) большой временный массив `Аггау<Т>`. Шаблон `exchange()` вызывается рекурсивно, чем достигается хорошая производительность даже для таких типов, как `Array<Array<char>>`. Отметим также, что более специализированная версия шаблона не объявлена как [[inline|inline]], поскольку выполняет значительный объем работы. В то же время первоначальная обобщенная реализация является встроенной, поскольку выполняет только несколько операций (каждая из которых потенциально является дорогостоящей).

# Перегрузка шаблонов функций

В предыдущем разделе было показано, что возможно сосуществование двух шаблонов функций с одним и тем же именем, даже если они могут быть инстанцированы с параметрами идентичных типов. Приведем еще один простой пример этого.
```c++
template<typename T>
int f (T)
{
	return 1;
}

template<typename T>
int f(T*)
{
	return 2;
}
```

Когда тип `T` заменяется типом `int*` в первом шаблоне, получается функция, у которой есть точно такие же типы параметров (и возвращаемых значений), что и у функции, получаемой при замене типа `int` типом `Т` во втором шаблоне. Сосуществовать могут не только эти шаблоны, но и их инстанцирования, даже если у них идентичны типы параметров и возвращаемых значений.

Приведенный ниже пример демонстрирует, как можно вызвать две такие сгенерированные функции с помощью синтаксиса явного аргумента шаблона (в предположении предыдущих объявлений шаблона):
```c++
#include <iostream>
#include "funcoverload1.hpp"

int main()
{
	std::cout << f<int*>((int*)nullptr);   // Вызов f<T>(T)
	std::cout << f<int> ((int*)nullptr);   // Вызов f<T>(T*)
}
```

Результатом выполнения этой программы будет следующий вывод:
```
12
```

Чтобы объяснить работу программы, подробно проанализируем вызов `f<int*>((int*)nullptr)`. Синтаксис `f<int*>` обозначает, что первый параметр шаблона `f` нужно заменить значением типа `int*` без использования вывода аргумента шаблона. В этом случае существует более одного шаблона `f` и поэтому создается набор перегрузки, содержащий две функции, сгенерированные из шаблонов: `f<int*> (int*)` (сгенерированная из первого шаблона) и `f<int*> (int**)` (сгенерированная из второго шаблона). Аргумент вызова `(int*) nullptr` имеет тип `int*`, который соответствует только функции, сгенерированной из первого шаблона. Следовательно, это и есть функция, которая будет вызвана в конечном итоге.

С другой стороны, для второго вызова множество перегрузки содержит функции `f<int> (int)` (генерируется из первого шаблона) и `f<int> (int*)` (генерируется из второго шаблона), так что соответствует аргументу только второй шаблон.

## Сигнатуры

Две функции могут сосуществовать в программе, если у них разные сигнатуры. Определим сигнатуру как приведенную ниже информацию.
1. Неквалифицированное имя функции (или имя шаблона функции, из которого она генерируется).
2. Область видимости класса или пространства имен и, если это имя имеет внутреннее связывание, единица трансляции, в которой объявлено имя.
3. Классификация функции как [[const|const]], [[volatile|volatile]] или `const volatile` (если это функция-член с данным квалификатором).
4. Квалификаторы `&` или `&&` функции (если она является функцией-членом с таким квалификатором).
5. Типы параметров функции (перед подстановкой параметров шаблона, если функция генерируется из шаблона функции).
6. Если функция генерируется из шаблона функции, то тип ее возвращаемого значения.
7. Параметры и аргументы шаблона, если функция генерируется из шаблона функции.

Это означает, что в одной и той же программе могут сосуществовать следующие шаблоны и их инстанцирования:
```c++
template<typename T1, typename Т2>
void f1(T1, T2);

template<typename T1, typename T2>
void f1(T2, T1);

template<typename T>
long f2(T);

template<typename T>
char f2(T);
```

Однако их не всегда можно использовать, если они объявлены в одной и той же области видимости, поскольку при их инстанцировании возникает неоднозначность перегрузки. Например, очевидно, что вызов `f2(42)` приводит к неоднозначности, если объявлены оба соответствующих шаблона, приведенных выше. 

Еще один пример показан ниже:
```c++
#include <iostream>
template<typename T1, typename T2>
void f1(T1, T2)
{
	std::cout << "f1(T1, T2)\n";
}

template<typename T1, typename T2>
void f1(T2, T1)
{
	std::cout << "f1(T2, T1)\n";
}

// Пока все в порядке
int main()
{
	f1<char, char>('a', 'b');     // Ошибка: неоднозначность
}
```

Здесь функция
```c++
f1<T1 = char, T2 = char>(T1, T2)
```

может сосуществовать с функцией
```c++
f1<T1 = char, Т2 = char>(T2, T1)
```

однако разрешение перегрузки никогда не отдаст предпочтения одной из них. Если эти шаблоны появляются в различных единицах трансляции, эти два экземпляра действительно могут существовать в одной и той же программе (при этом компоновщик не должен жаловаться на двойное определение, поскольку сигнатуры инстанцирований различны):
```c++
// ===== Единица трансляции 1:
#include <iostream>

template<typename T1, typename T2>
void f1(T1, T2)
{
	std::cout << "f1(T1, T2)\n";
}

void g()
{
	f1<char, char>('a', 'b');
}

// ===== Единица трансляции 2:
#include <iostream>

template<typename T1, typename T2>
void f1(T2, T1)
{
	std::cout << "f1(T2, T1)\n";
}

extern void g(); // Определена в единице трансляции 1

int main()
{
	f1<char, char>('a', 'b');
	g();
}
```

Эта программа корректна и выдает следующее:
```c++
f1(T2, T1)
f1(T1, Т2)
```

## Частичное упорядочение перегруженных шаблонов функций

Вернемся к рассмотренному ранее примеру. Мы обнаружили, что после подстановки данных списков аргументов (`<int*>` и `<int>`), разрешение перегрузки в конечном итоге выбирает для вызова нужную функцию:
```c++
std::cout << f<int*>((int*)nullptr); // Вызов f<T>(T)
std::cout << f<int>((int*)nullptr);  // Вызов f<T>(T*)
```

Однако выбор функции происходит даже тогда, когда явные аргументы шаблона не указаны. В этом случае вступает в игру вывод аргумента шаблона. Чтобы обсудить этот механизм, давайте немного модифицируем функцию `main()` из предыдущего примера.
```c++
#include <iostream>

template<typename T>
int f(T)
{
	return 1;
}

template<typename T>
int f(T*)
{
	return 2;
}

int main()
{
	std::cout << f(0);               // Вызов f<T>(T)
	std::cout << f(nullptr);         // Вызов f<T>(T)
	std::cout << f((int*)nullptr);   // Вызов f<T>(T*)
}
```

Рассмотрим первый вызов, `f(0)`: здесь тип аргумента — `int`, который соответствует типу параметра первого шаблона, если заменить `Т` на `int`. Однако тип параметра второго шаблона — это всегда указатель, и, следовательно, после вывода кандидатом для вызова будет только экземпляр, сгенерированный из первого шаблона. В этом случае разрешение перегрузки тривиально.

То же самое можно сказать и о втором вызове, `f(nullptr)`. Тип аргумента в этом случае [[nullptr_t|std::nullptr_t]], который опять же соответствует только первому шаблону.

Третий вызов `(f((int*)nullptr))` более интересен: осуществить вывод аргумента удается для обоих шаблонов, что дает функции `f<int*>(int*)` и `f<int> (int*)`. С точки зрения традиционного разрешения перегрузки обе функции одинаково хороши для вызова с аргументом `int*`, что соответствует неоднозначности вызова (см. #приложение_В, “Разрешение перегрузки”). Однако в таких случаях вступает в игру дополнительный критерий перегрузки: выбирается функция, сгенерированная из более специализированного шаблона. Здесь, как вы скоро увидите, второй шаблон считается более специализированным, а потому результатом работы этой программы будет
```
112
```

## Правила формального упорядочения

В нашем последнем примере интуитивно вполне понятно, что второй шаблон “более специальный”, чем первый, поскольку первый может быть подстроен почти под любой тип аргумента, тогда как второй разрешает только типы-указатели. Однако другие примеры могут оказаться не столь очевидными. Далее описана точная процедура определения того, является ли один шаблон, участвующий в наборе перегрузки, более специализированным, чем другой. Отметим, однако, что это правила лишь частичного упорядочения: возможна ситуация, когда ни один из шаблонов не будет считаться более специализированным, чем другой. Если разрешение перегрузки должно выбирать между такими шаблонами, решение принято не будет и в программе возникнет ошибка неоднозначности.

Предположим, сравниваются два идентично именованных шаблона, которые кажутся подходящими для данного вызова функции. Разрешение перегрузки принимает решение следующим образом.
>
> Параметры вызова функции, которые используют аргументы по умолчанию или многоточия, игнорируются.
> 
> Создаются два искусственных списка типов аргументов (а для шаблона функции преобразования типов — возвращаемого типа) путем подстановки каждого параметра шаблона следующим образом.
> 	1. Заменим каждый типовой параметр шаблона уникальным искусственным типом.
> 	2. Заменим каждый шаблонный параметр шаблона уникальным искусственным шаблоном класса.
> 	3. Заменим каждый шаблонный параметр, не являющийся типом, уникальным искусственным значением соответствующего типа. (Искусственные типы, шаблоны и значения в этом контексте отличаются от любых прочих типов, шаблонов или значений, как используемых программистом, так и создаваемых компилятором в других контекстах.)
>
> Если вывод аргументов второго шаблона из первого синтезированного списка типов аргументов происходит успешно при точном соответствии, но не наоборот, то говорят, что первый шаблон является более, специализированным, чем второй. Если вывод аргументов первого шаблона для второго синтезированного списка типов аргументов происходит успешно при точном соответствии, но не наоборот, то говорят, что второй шаблон является более специализированным, чем первый. В ином случае (если нет ни одного успешного вывода или же оба вывода успешны) упорядочения шаблонов не происходит.

Попробуем применить этот подход к двум шаблонам в предыдущем примере. Для этих шаблонов синтезируются два списка типов аргументов путем замены шаблонных параметров описанным выше способом: (`А1`) и (`А2*`), где `А1` и `А2` — уникальные искусственные типы. Очевидно, что вывод первого шаблона для второго списка типов аргументов происходит успешно при замене `А2*` на `Т`. Однако тип `Т*` из второго шаблона невозможно сделать соответствующим типу `А1` из первого списка, который не является типом указателя. Следовательно, формально можно заключить, что второй шаблон более специализирован, чем первый.

Рассмотрим более сложный пример с использованием нескольких параметров функций.
```c++
template<typename Т>
void t(T*, Т const* = nullptr, ...);

template<typename T>
void t(T const*, T*, T* = nullptr);

void example(int* p)
{
	t(p, p);
}
```

Прежде всего, поскольку реальный вызов не использует параметр многоточия для первого шаблона, а последний параметр второго шаблона покрывается аргументом по умолчанию, эти аргументы при частичном упорядочении игнорируются. Отметим, что аргумент первого шаблона по умолчанию не используется. Поэтому соответствующий параметр участвует в упорядочении.

Созданные списки типов аргументов — это (`А1*`, `A1 const*`) и (`А2 const*`, `А2*`). Вывод аргументов шаблона (`A1*`, `A1 const*`) для второго шаблона успешен при замене `Т` на `A1 const`, однако результирующее соответствие не точное, поскольку для вызова `t<A1 const>(A1 const*,A1 const*, A1 const*=0)` с аргументами типов (`A1*`, `A1 const*`) требуется дополнительное уточнение типов. Точно так же нельзя найти точное соответствие при выводе аргументов шаблона для первого шаблона из списка типов аргументов `(А2 const*, А2*)`. Следовательно, между двумя шаблонами нет отношения упорядочения и вызов неоднозначен.

Формальные правила упорядочения обычно обеспечивают возможность интуитивно очевидного выбора шаблонов функций. Тем не менее можно привести множество примеров, когда интуитивно очевидный выбор оказывается невозможным. Вероятно, данные правила упорядочения в будущем могут быть пересмотрены, чтобы такие ситуации стали разрешимыми.

## Шаблоны и нешаблоны

Шаблоны функций можно перегружать нешаблонными функциями. При прочих равных условиях при выборе реальной функции вызова нешаблонная функция предпочтительнее. Приведенный ниже пример иллюстрирует это.
```c++
#include <string>
#include <iostream>

template<typename T>
std::string f(T)
{
	return "Template";
}

std::string f(int&)
{
	return "Nontemplate";
}

int main()
{
	int x = 7;
	std::cout << f (x) << '\n'     // Выводит: Nontemplate
}
```

Результат выполнения программы:
```
Nontemplate
```

Однако при различных ссылочных квалификаторах и [[const|const]] приоритеты разрешения перегрузки могут измениться. Например:
```c++
#include <string>
#include <iostream>

template<typename T>
std::string f(T&)
{
	return "Template";
}

std::string f(int const&)
{
	return "Nontemplate";
}

int main()
{
	int x = 7;
	std::cout << f (x) << '\n';       // Выводит: Template

	int const c = 7;
	std::cout << f(c) << '\n';        // Выводит: Nontemplate
}
```

Результат выполнения программы:
```
Template
Nontemplate
```

Теперь шаблон функции f<>(T&) демонстрирует лучшее соответствие при передаче неконстантного `int`. Дело в том, что для `int` инстанцированная функция `f<>(int&)` демонстрирует лучшее соответствие, чем `f(int const&)`. Таким образом, разница не только в том, что одна функция является шаблоном, а другая — нет. В этом случае применяются общие правила разрешения перегрузки (см. #раздел_В_2). И только при вызове `f()` для `const int` обе сигнатуры имеют один и тот же тип `int const&`, так что предпочтительным оказывается нешаблонный вариант.

По этой причине хорошая идея объявлять шаблон функции-члена как
```c++
template<typename Т>
std::string f(Т const&)
{
	return "Template";
I
```

Тем не менее этот эффект легко может оказаться случайным и привести к удивительному поведению, когда функции-члены определены так, что принимают теже аргументы, что и копирующие или перемещающие конструкторы. Например:
```c++
#include <string>
#include <iostream>

class C
{
	public:
		C () = default;
		C(C const&)
		{
			std::cout << "copy constructor\n";
		}
		
		C (C&&)
		{
			std::cout << "move constructor\n";
		}
		
		template<typename T>
		C (T&&)
		{
			std::cout << "template constructor\n";
		}
};

int main()
{
	C x;
	C x2{x};                // Выводит: template constructor	
	C x3{std::move(x)};     // Выводит: move constructor

	C const c;
	C x4{c};                // Выводит: copy constructor
	C x5{std::move(c)};     // Выводит: template constructor
```

Результат выполнения программы:
```
template constructor
move constructor
copy constructor
template constructor
```

Таким образом, шаблон функции-члена лучше подходит для копирования `С`, чем копирующий конструктор. И для `std: :move(c)`, который дает тип `С const &&` (возможный, но обычно не имеющий значимой семантики тип), шаблон функции-члена также демонстрирует лучшее соответствие, чем перемещающий конструктор.

По этой причине обычно [[Семантика перемещения - Использование enable_if|следует частично отключать такие шаблоны функций-членов, когда они могут скрывать копирующие или перемещающие конструкторы]].

## Вариативные шаблоны функций

[[Вглубь шаблонов#Вариативные шаблоны|Вариативные шаблоны функций]] требуют при частичном упорядочении особого подхода, потому что при [[Вывод аргументов шаблона#Пакеты параметров|выводе для пакета параметров]] один параметр соответствует нескольким аргументам.

Это поведение приводит к нескольким интересным ситуациям при упорядочении шаблонов функций, иллюстрируемым в следующем примере:
```c++
#include <iostream>

template<typename T>
int f(T*)
{
	return 1;
}

template<typename... Ts>
int f(Ts...)
{
	return 2;
}

template<typename... Ts>
int f (Ts* ...)
{
	return 3;
}

int main()
{
	std::cout << f(0, 0.0);            // Вызов f<>(TS...)
	std::cout << f((int*)nullptr,
					(double*)nullptr); // Вызов fo(Ts* ...)
	std::cout << f((int*)nullptr);     // Вызов f<> (T*)
}
```

Вывод этой программы, которую мы сейчас детально разберем, имеет вид
```
231
```

В первом вызове, `f(0,0,0)`, рассматриваются все шаблоны функций с именем `f`. Для первого шаблона функции, `f(Т*)`, вывод оказывается неудачен, как потому, что параметр шаблона `Т` не может быть выведен, так и потому, что аргументов функции больше, чем параметров в этом невариативном шаблоне функции. Второй шаблон функции, `f(Ts. . .)`, является вариативным: вывод в этом случае сравнивает схему пакета параметров функции (`Ts`) с типами двух аргументов (`int` и `double`, соответственно), выводя `Ts` как последовательность (`int`, `double`). Для третьего шаблона функции, `f(Ts*...)`, вывод сравнивает схему пакета параметров функции `Ts*` с каждым из типов аргументов. Этот вывод оказывается неудачным (Ts не может быть выведен), оставляя в результате в качестве кандидата только один второй шаблон функции. Упорядочение шаблонов функции не требуется.

Второй вызов, `f((int*)nullptr, (double*)nullptr)`, более интересен: вывод неудачен для первого шаблона функции, потому что аргументов функции больше, чем параметров, но успешен для второго и третьего шаблонов. Будучи записанными явно, результирующие вызовы имеют вид
```c++
f<int,double*>((int*)nullptr, (double*)nullptr) // Второй шаблон
```

и
```c++
f<int,double>((int*)nullptr, (double*)nullptr)  // Третий шаблон
```

Затем частичное упорядочение рассматривает второй и третий шаблоны (оба они являются вариативными) следующим образом: при применении [[Шаблоны Специализация и перегрузка#Правила формального упорядочения|формальных правил упорядочения]] к вариативному шаблону каждый пакет параметров шаблона заменяется одним искусственным типом, шаблоном класса или значением. Например, это означает, что сгенерированные типы аргументов для второго и третьего шаблонов функций представляют собой `A1` и `A2*`, соответственно, где `A1` и `A2` — уникальные, искусственно введенные типы. Вывод для второго шаблона для третьего списка типов аргументов успешен при подстановке однозначной последовательности (`A2*`) вместо пакета параметров `Ts`. Однако не существует способа сделать схему `Ts*` пакета параметров третьего шаблона соответствующей типу `A1`, не являющемуся типом указателя; поэтому третий шаблон функции (принимающий аргументы-указатели), считается более специализированным, чем второй шаблон функции (который принимает любые аргументы).

Третий вызов, `f((int*)nullptr)`, вводит новые сложности: вывод успешен для всех трех шаблонов функций, что требует частичного упорядочения для сравнения вариативных и непараметризованных шаблонов. Для иллюстрации сравним первый и третий шаблоны функций. Синтезированные типы аргументов представляют собой `A1*` и `A2*`, где `A1` и `A2` являются уникальными искусственными типами. Вывод первого шаблона для третьего списка синтезированных аргументов успешен при подстановке `A2` вместо `T`. В другом направлении вывод третьего шаблона для первого списка синтезированных аргументов также успешен при подстановке однозначной последовательности (`A1`) вместо пакета параметров `Ts`. Частичное упорядочение между первым и третьим шаблонами должно быть вести к неоднозначности. Однако имеется специальное правило, которое запрещает сопоставление аргумента, изначально пришедшего из пакета параметров функции (например, пакет параметров третьего шаблона `Ts*...`), параметру, который не является пакетом параметров (параметр первого шаблона `T*`). Следовательно, вывод первого шаблона для третьего списка синтезированных аргументов неудачен, и первый шаблон рассматривается как более специализированный, чем третий. Это специальное правило рассматривает невариативные шаблоны (т.е. шаблоны с фиксированным количеством параметров) как более специализированные, чем вариативные шаблоны (с переменным количеством параметров).

Описанные выше правила точно так же применяются к раскрытиям пакетов, происходящим в типах в сигнатуре функции. Например, мы можем “обернуть” параметры и аргументы каждого из шаблонов функций в нашем предыдущем примере в вариативный шаблон класса [[tuple|Tuple]] для получения аналогичного примера, не связанного с пакетами параметров функции:
```c++
#include <iostream>

template<typename... Ts> class Tuple
{
};

template<typename T>
int f(Tuple<T*>)
{
	return 1;
}

template<typename... Ts>
int f(Tuple<Ts...>)
{
	return 2;
}

template<typename... Ts>
int f(Tuple<Ts* ...>)
{
	return 3;
}

int main()
{
	std::cout << f(Tuple<int,double>());    // Вызов f<>(Tuple<Ts...>)
	std::cout << f(Tuple<int*,double*>());  // Вызов f<>(Tuple<Ts*...>)
	std::cout << f(Tuple<int*>());          // Вызов f<>(Tuple<T*>)
}
```

Упорядочение шаблонов функций рассматривает раскрытие пакета в аргументах шаблона в [[tuple|Tuple]] аналогично пакетам параметров функций в нашем предыдущем примере, что приводит к такому же, как и выше, результату:
```
231
```

# Явная специализация

Возможность перегружать шаблоны функций в сочетании с правилами частичного упорядочения при выборе обеспечивающего наилучшее соответствие шаблона функции позволяет добавлять к обобщенной реализации специализированные шаблоны для повышения эффективности кода. Однако перегружать шаблоны классов и шаблоны переменных нельзя. Вместо этого для обеспечения прозрачной настройки шаблонов классов выбран другой механизм — явная специализация (explicit specialization). Стандартный термин явная специализация ссылается на возможность языка, которую мы называем полной специализацией (full specialization). Она обеспечивает реализацию шаблона с полностью замененными параметрами шаблонов, когда никаких неизвестных шаблонных параметров не остается. Шаблоны классов, шаблоны функций и шаблоны переменных могут быть полностью специализированными.

Члены шаблонов классов (т.е. функции-члены, вложенные классы, статические члены-данные и члены с типами перечислений) могут быть определены за пределами тела определения класса.

В одном из следующих разделов рассматривается частичная специализация (partial specialization). Она напоминает полную специализацию, но вместо полной замены шаблонных параметров в ней остается некоторая параметризация. Полная и частичная специализации одинаково “явно” присутствуют в нашем исходном коде, поэтому при обсуждении мы избегаем термина явная специализация. Ни полная, ни частичная специализация не вводят полностью новый шаблон или его экземпляр. Вместо этого данные конструкции предоставляют возможность альтернативного определения для экземпляров, которые уже неявно определены в обобщенном (неспециализированном) шаблоне. Это довольно важное концептуальное отличие от перегруженных шаблонов.

## Полная специализация шаблона класса


































