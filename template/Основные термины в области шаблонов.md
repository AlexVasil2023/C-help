
[[#Основные термины в области шаблонов|Основные термины в области шаблонов]] 10
1. [[#“Шаблон класса” или “шаблонный класс”|“Шаблон класса” или “шаблонный класс”]] 10.1
2. [[#Подстановка, инстанцирование и специализация|Подстановка, инстанцирование и специализация]] 10.2
3. [[#Объявления и определения|Объявления и определения]] 10.3


# Основные термины в области шаблонов

Предыдущие главы книги были посвящены знакомству с основами концепции шаблонов в C++. Теперь, прежде чем перейти к более подробному рассмотрению шаблонов, хотелось бы уделить внимание терминам, которые используются при изложении материала. В этом есть необходимость, поскольку в сообществе C++ (и даже в ранних версиях стандарта) иногда отсутствует четкое понимание концепций и терминологии.

# “Шаблон класса” или “шаблонный класс”

В C++ структуры, классы и объединения имеют общее название типы классов, или классовые типы (`class types`). Без дополнительного уточнения слово “класс” обычно служит для обозначения типов класса, заданных с помощью ключевых слов `class` или struct. Особо следует отметить, что понятие “тип класса” включает объединения, а “класс” — нет.

Имеется определенная некоторая путаница в отношении того, как следует именовать класс, являющийся шаблоном.
>
> Термин ***шаблон класса*** (class template) означает, что класс является шаблоном. Другими словами, это параметризованное описание семейства классов.
> 
> С другой стороны, термин ***шаблонный класс*** (template class) используется
> 	> как синоним для шаблона класса;
> 	> для обозначения классов, сгенерированных из шаблона;
> 	> для обозначения классов с именем, которое является идентификатором шаблона (комбинацией имени шаблона, за которым следуют аргументы шаблона между < и >).

Разница между вторым и третьим значениями весьма незначительна и в остальной части книги не играет сколько-нибудь заметной роли.

Из-за упомянутой неточности в данной книге мы старались избегать термина шаблонный класс.

Аналогично мы используем термины ***шаблон функции*** (function template), ***шаблон члена*** (member template), ***шаблон функции-члена*** (member function template) и ***шаблон переменной*** (variable template), но стараемся избегать терминов ***шаблонная функция*** (template function), ***шаблонный член*** (template member), ***шаблонная функция-член*** (template member function) и ***шаблонная переменная*** (template variable).

# Подстановка, инстанцирование и специализация

При обработке исходного текста, в котором используются шаблоны, компилятор C++ должен в разные моменты времени выполнять подстановку (substitute) конкретных аргументов шаблона вместо параметров шаблона в шаблоне. Иногда эта замена только предварительная: компилятору может потребоваться проверить, [[Программирование времени компиляции#SFINAE|является ли допустимым такое замещение]] (см. #раздел_15_7).

Процесс создания определения (definition) для обычного класса, псевдонима типа, функции, функции-члена или переменной из шаблона путем подстановки конкретных аргументов в качестве параметров шаблона называется инстанцированием шаблона (template instantiation).

Удивительно, но в настоящее время нет стандартного или хотя бы в целом согласованного термина для обозначения процесса создания объявления (declaration), которое не является определением, путем подстановки параметров шаблона. Мы встречались с такими терминами, используемыми разными группами, как частичное инстанцирование (partial instantiation) или инстанцирование объявления (instantiation of a declaration), но они ни в коем случае не являются универсальными. Возможно, более интуитивным является термин неполное инстанцирование (incomplete instantiation) (которое в случае шаблона класса производит неполный класс).

Сущности, появляющиеся в результате инстанцирования или неполного инстанцирования (т.е. класс, функция, функция-член или переменная) в общем случае называются специализациями (specialization).

Однако в C++ процесс инстанцирования является не единственным способом получить специализацию. Существуют альтернативные механизмы, позволяющие программисту явно задавать объявление, привязанное к определенной подстановке параметров шаблона. [[Шаблоны классов#Специализации шаблонов классов|Как упоминалось]], такая специализация вводится с помощью префикса `template<>`:
```c++
template<typename T1, typename T2> // Первичный шаблон класса
class MyClass
{
	...
};

template<>                         // Явная специализация
class MyClass<std::string, float>
{
	...
};
```

Строго говоря, это так называемая явная специализация (explicit specialization) (в отличие от инстанцируемой, или генерируемой специализации (instantiated specialization, generated specialization)).

[[Шаблоны классов#Частичная специализация|Как отмечалось]], специализации, в которых остаются параметры шаблона, называются частичными специализациями (partial specialization).
```c++
template<typename Т>          // Частичная специализация
class MyClass<T, Т>
{
	...
};

template<typename Т>          // Частичная специализация
class MyClass<bool, Т>
{
	...
};
```

Если речь идет о специализации (явной или частичной), то общий шаблон называется первичным шаблоном (primary template).

# Объявления и определения

До сих пор понятия ***объявление*** (declaration) и ***определение*** (definition) встречались не слишком часто. Однако оба понятия достаточно точно определены в стандарте C++, и именно эти значения данных понятий используются в нашей книге.

***Объявление*** (declaration) является конструкцией C++, которая вводит или повторно задает имя в области видимости C++. Такое задание всегда включает частичную классификацию имени, но для корректности объявления указание всех деталей не требуется, например:
```c++
class С;                        // Объявление С как класса

void f(int р);                  // Объявление f () как функции,
								// а р- как именованного параметра
extern int v;                   // Объявление V как переменной
```

Отметим, что макроопределения и метки [[goto|goto]], несмотря на то, что они имеют “имена”, в C++ объявлениями не считаются.

Объявления становятся ***определениями*** (definition), когда делается известной информация об их структуре или, в случае переменных, когда для них должна быть выделена память. Для определений типов классов это означает, что должно быть предоставлено заключенное в фигурные скобки тело. Для определений функций это означает, что должно быть предоставлено заключенное в фигурные скобки тело (в общем случае) или функция должна быть определена как `=default` или `=delete`. В случае переменных для того, чтобы объявление стало определением, достаточно инициализации или отсутствия спецификатора [[extern|extern]]. Далее приведены примеры, которые дополняют представленные выше объявления, не являющиеся определениями.
```c++
class С {};         // Определение (и объявление) класса С

void f(int р)       // Определение (и объявление) функции f ()
{
	std::cout << р << '\n';
}

extern int v = 1;   // Инициализатор делает этот код определением v
int w;              // Объявления глобальных переменных, не
					// предшествуемые ключевым словом extern,
					// также являются определениями
```

Распространение этого принципа на шаблоны приводит к тому, что объявление шаблона класса или шаблона функции называется определением, если оно имеет тело. Следовательно,
```c++
template<typename Т>
void func(T);
```

является объявлением, но не определением, в то время как
```c++
template<typename Т>
class S {};
```

фактически является определением.



















