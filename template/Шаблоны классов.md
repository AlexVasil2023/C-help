
[[#Шаблоны классов|Шаблоны классов]] 2
1. [[#Реализация шаблона класса Stack|Реализация шаблона класса Stack]] 2.1
	1. [[#Объявление шаблона класса|Объявление шаблона класса]] 2.1.1
	2. [[#Реализация функций-членов|Реализация функций-членов]] 2.1.2
2. [[#Использование шаблона класса Stack|Использование шаблона класса Stack]] 2.2
3. [[#Частичное использование шаблонов классов|Частичное использование шаблонов классов]] 2.3
	1. [[Concepts|Концепты]] 2.3.1
4. [[#Друзья|Друзья]] 2.4
5. [[#Специализации шаблонов классов|Специализации шаблонов классов]] 2.5
6. [[#Частичная специализация|Частичная специализация]] 2.6
7. [[#Аргументы шаблона класса по умолчанию|Аргументы шаблона класса по умолчанию]] 2.7
8. [[#Псевдонимы типов|Псевдонимы типов]] 2.8
9. [[#Вывод аргументов шаблона класса|Вывод аргументов шаблона класса]] 2.9
10. [[#Вывод типов шаблонных параметров для классов|Вывод типов шаблонных параметров для классов]] 2.10
11. [[#Шаблонизированные агрегаты|Шаблонизированные агрегаты]] 2.11

# Шаблоны классов

Подобно функциям, классы могут также быть параметризованы одним или несколькими типами. Классы контейнеров, которые используются для управления элементами определенного типа, являются типичным примером этой возможности. Такие классы контейнеров можно реализовать с помощью шаблонов классов; тип элементов при этом остается открытым. В этой главе мы используем в качестве примера шаблона класса стек.

# Реализация шаблона класса Stack

Как и в случае шаблонов функций, мы объявляем и определяем класс `Stack<>`
в заголовочном файле следующим образом:
```c++
#include <vector>
#include <cassert>

template<typename T>
class Stack
{
	private:
		std::vector<T> elems;      // Элементы

	public:
		void push(T const& elem);  // Внесение в стек
		void pop();                // Снятие со стека
		
		T const& top() const;      // Верхний элемент стека
		
		bool empty() const         // Пуст ли стек
		{
			return elems.empty();
		}
};
		
template<typename Т>
void Stack<T>::push(T const& elem)
{
	elems.push_back(elem);        // Добавление копии переданного элемента
}

template<typename Т>
void Stack<T>::рор()
{
	assert(!elems.empty());
	elems.pop_back();             // Удаление последнего элемента
}

template<typename T>
T const& Stack<T>::top() const
{
	assert(!elems.empty());
	return elems.back();          // Возврат последнего элемента
}
```

Как видите, шаблон класса реализован с использованием шаблона класса [[vector#std vector|vector<>]] из стандартной библиотеки C++. В результате нам не нужно реализовывать управление памятью, копирующий конструктор и оператор присваивания, так что мы можем сосредоточиться на интерфейсе данного шаблона класса.

## Объявление шаблона класса

Объявление шаблона класса подобно объявлению шаблона функции: перед объявлением следует объявить один или несколько идентификаторов в качестве параметров типов. Обычно в качестве идентификатора используется `Т`:
```c++
template<typename Т>
class Stack
{
	...
};
```

Здесь также ключевое слово class может быть использовано вместо ключевого слова [[typename|typename]]:
```c++
template<class Т>
class Stack
{
	...
};
```

Внутри шаблона класса имя `Т` может использоваться так же, как и любой другой тип, для объявления членов-данных и функций-членов. В приведенном далее примере `Т` используется для объявления типа элементов как вектора, в объявлении метода `push()` как функции, которая получает `Т` в качестве аргумента, и для объявления `top()` как функции, возвращающей `Т`:
```c++
template<typename Т>
class Stack
{
	private:
		std::vector<T> elems;             // Элементы
		
	public:
		void push(T const& elem);         // Внесение в стек
		void pop();                       // Снятие со стека
		T const & top() const;            // Верхний элемент стека
		bool empty() const                // Пуст ли стек
		{
			return elems.empty();
		}
};
```

Типом этого класса является `Stack<T>`, где `Т` представляет собой параметр шаблона. Таким образом, `Stack<T>` придется использовать всякий раз, когда тип этого класса применяется в объявлении, за исключением тех случаев, когда аргументы шаблона могут быть выведены. Однако внутри шаблона класса имя класса, за которым не следуют аргументы шаблона, представляет класс с параметрами шаблона в качестве аргументов (подробности см. в [[Имена в шаблонах#Внесение имен классов|Внесение имен классов]]).

Если, например, вам нужно объявить свой собственный копирующий конструктор и оператор присваивания, обычно это выглядит так:
```c++
template<typename Т>
class Stack
{
	...
	
	Stack(Stack const&);                // Копирующий конструктор
	Stack& operator= (Stack const &);   // Оператор присваивания

	...
};
```

что формально эквивалентно следующему коду:
```c++
template<typename Т>
class Stack
{
	...
	
	Stack(Stack<T> const &);               // Копирующий конструктор
	Stack<T>& operator=(Stack<T> const &); // Оператор присваивания

	...
};
```

Однако обычно `<Т>` сигнализирует об особой обработке параметров шаблона, поэтому лучше использовать первую форму записи.

Однако вне структуры класса такое указание является необходимым:
```c++
template<typename Т>
bool operator == (Stack<T> const& lhs, Stack<T> const& rhs);
```

Обратите внимание на то, что в местах, где требуется имя, а не тип класса, можно использовать только `Stack`. Это, в частности, относится к указанию имен конструкторов (но не их аргументов) и деструкторов.

Заметим также, что в отличие от нешаблонных классов нельзя объявлять или определять шаблоны классов внутри функций или в области видимости блока. В общем случае шаблоны могут быть определены только в глобальной области видимости, области видимости пространства имен или внутри объявлений классов (подробнее см. в [[Вглубь шаблонов#Параметризованные объявления|Параметризованные объявления]]).

## Реализация функций-членов

Для того чтобы определить функцию-член шаблона класса, нужно указать, что это шаблон функции; при этом необходимо использовать полностью квалифицированный тип шаблона класса. Таким образом, реализация функции-члена `push()` типа `Stack<T>` имеет следующий вид:
```c++
template<typename Т>
void Stack<T>::push(Т const& elem)
{
	elems.push_back(elem);     // Добавление копии переданного элемента
}
```

В этом случае вызывается функция `push_back()` вектора элементов, которая добавляет элемент в конец вектора.

Заметим, что функция `pop_back()` вектора удаляет последний элемент, но не возвращает его, что связано с вопросами безопасности исключений. Реализовать полностью безопасную в плане исключений функцию `pop()`, возвращающую удаленный элемент, невозможно (этот вопрос впервые был рассмотрен Томом Каргиллом (Tom Cargill) в [#31]; кроме того, этот вопрос детально рассматривается в [#68]). Однако если игнорировать небезопасность данной функции в плане исключений, то можно реализовать функцию `pop()`, возвращающую только что удаленный элемент. Для этого мы просто используем `Т` для объявления локальной переменной соответствующего типа.
```c++
template<typename Т>
Т Stack<T>::рор()
{
	assert(!elems.empty());
	
	Т elem = elems.back();      // Сохранение копии последнего элемента
	elems.pop_back();           // Удаление последнего элемента
	
	return elem;                // Возврат копии сохраненного элемента
}
```

Поскольку поведение функций вектора `back()` (возвращающей последний элемент) и `pop_back()` (удаляющей последний элемент) не определено для случая, когда вектор не содержит ни одного элемента, требуется проверка, не является ли стек пустым. Если он пуст, мы завершаем программу с использованием `assert`, так как вызов `pop()` для пустого стека является ошибкой. Так же мы поступаем и в функции `top()`, которая возвращает (но не удаляет) элемент, находящийся на вершине стека:
```c++
template<typename Т>
Т const& Stack<T>::top() const
{
	assert(!elems.empty());
	
	return elems.back();         // Возврат последнего элемента
}
```

Конечно, точно так же, как и в случае любых других функций-членов, функции-члены шаблонов классов можно реализовать как встраиваемые функции, располагающиеся внутри объявления класса, например:
```c++
template<typename Т>
class Stack
{
	... 
	
	void push(T const& elem)
	{
		elems.push_back(elem);	// Добавление копии переданного элемента
	}
	
	...
}
```

# Использование шаблона класса Stack

Для того чтобы использовать объект шаблона класса, до C++17 требовалось явно указать аргументы шаблона. В приведенном ниже примере показано, как используется шаблон класса `Stack<>`.
```c++
#include "stack1.hpp"
#include <iostream>
#include <string>

int main()
{
	Stack<int> intstack;                 // Стек элементов int
	Stack<std::string> stringStack;      // Стек элементов string

	// Работа co стеком целых чисел
	intstack.push(7);
	std::cout << intstack.top() << ' \n';  //top-возвращение верхнего э-та
	
	// Работа co стеком строк
	stringStack.push("hello");
	std::cout << stringStack.top() << '\n';
	stringStack.pop();
}
```

Объявление `Stack<int>` указывает, что внутри шаблона класса в качестве типа `Т` будет использоваться `int`. Таким образом, `intstack` создается как объект на базе вектора с элементами типа `int`, и для всех вызываемых функций-членов инстанцируется код для этого типа. Аналогично путем объявления и использования `Stack<std::string>` создается объект на базе вектора, элементами которого являются строки, и для каждой из вызываемых функций-элементов инстанцируется код для этого типа.

Заметим, что инстанцирование происходит только для вызываемых функций (членов) шаблона. Для шаблонов классов функции-члены инстанцируются только при их использовании. Очевидно, что такой подход позволяет сэкономить время, память и [[#Частичное использование шаблонов классов|использовать шаблоны классов только частично]].

В данном примере инстанцируются конструктор по умолчанию, а также функции `push()` и `top()` как для значений типа `int`, так и для значений типа [[string|string]]. Однако функция `pop()` инстанцируется только для строк. Если шаблон класса имеет статические члены, то они инстанцируются однократно для каждого типа, для которого используется шаблон класса.

Тип инстанцированного шаблона класса можно использовать так же, как и любой другой тип. Вы можете квалифицировать его с помощью ключевых слов [[const|const]] или [[volatile|volatile]], а также создавать на его основе массивы или ссылки. Его также можно использовать как часть определения типа с помощью [[typedef|typedef]] или `using` (об определениях типов рассказывается в [[Шаблоны классов#Псевдонимы типов|Псевдонимы типов]]) или в качестве параметра типа при создании другого шаблонного типа, например:
```c++
void foo(Stack<int> const& s)    // Параметр s представляет собой стек
{
	using IntStack = Stack<int>; // IntStack - псевдоним для Stack<int>
	Stack<int> istack[1O];       // istack — массив из 10 стеков
	IntStack istack2[10];        // istack2 — такой же массив того же типа
```

Аргументы шаблона могут быть любого типа, такими как указатели на `float` или даже стеками элементов типа `int`:
```c++
Stack<float*> floatPtrStack;       // Стек указателей на float
Stack<Stack<int>> intStackStack;   // Стек стеков элементов int
```

Единственным требованием является то, что любая вызываемая операция должна быть возможна для этого типа.

До принятия стандарта C++11 между двумя закрывающими угловыми скобками требовалось помещать пробел:
```c++
Stack<Stack<int> > intStackStack;  // Работает для всех версий C++
```

Если этого не сделать, получался оператор `>>`, что приводило к синтаксической ошибке:
```c++
Stack<Stack<int>> intStackStack;   // Ошибка до С++11
```

Причиной такого поведения в старых версиях C++ было то, что при первом проходе компилятора C++ выполнялось разделение исходного кода на лексемы независимо от семантики кода. Однако, поскольку отсутствие пробела стало распространенной ошибкой, требовавшей соответствующего сообщения об ошибках, было принято решение учитывать семантику кода в любом случае, и в стандарте C++11 требование ставить пробел между двумя закрывающими угловыми скобками в шаблонах было убрано (см. [[Имена в шаблонах#Зависимость от контекста в нешаблонных конструкциях|Зависимость от контекста в нешаблонных конструкциях]]).

# Частичное использование шаблонов классов

Шаблон класса обычно выполняет несколько операций над аргументами шаблона, для которых он инстанцируется (в том числе конструирование и уничтожение). Это может привести к впечатлению, что аргументы шаблона должны предоставлять все операции, необходимые для всех функций-членов шаблона класса. Но это не так: аргументы шаблона обязаны предоставлять только те операции, которые необходимы (а не те, которые могут потребоваться).

Пусть, например, класс `Stack<>` предоставляет функцию-член `printOn()` для вывода содержимого стека, вызывающую `operator <<` для каждого элемента:
```c++
template<typename Т>
class Stack
{
	...
	
	void printOn(std::ostream& strm)
	{
		for (T const& elem : elems)
		{
			strm << elem << '  ';    // Вызов << для каждого элемента
		}
	}
};
```

При этом вы все равно можете использовать этот класс для элементов, для которых не определен `operator <<`:
```c++
Stack<std::pair<int, int>> ps; // std::pair<> не имеет operator <<
ps.push({4, 5});               //OK
ps.push({6, 7});               //OK

std::cout << ps.top().first << ' \n'; // OK
std::cout << ps.top().second << '\n'; // OK
```

И только если вы вызовете `printOn()` для такого стека, то получите ошибку времени компиляции, потому что компилятор не сможет инстанцировать вызов `operator <<` для этого конкретного типа элемента:
```c++
ps.printOn(std::cout);  // Ошибка: operator << не поддерживается
						// для данного типа элементов
```

## Концепты

[[Concepts#Концепт|см. тут]]

# Друзья

Вместо печати содержимого стека с помощью функции `printOn()` лучше реализовать `operator <<` для стека. Однако, как обычно, `operator <<` должен быть реализован как свободная функция, которая затем может вызывать функцию-член `printOn()`:
```c++
template<typename Т>
class Stack
{
	...

	void printOn(std::ostream& strm) const
	{
		...
	}
	
	friend std::ostream& operator << (std::ostream& strm,
					Stack<T> const& s)
	{
		s.printOn(strm);
		return strm;
	}
};
```

Обратите внимание: это означает, что `operator <<` для класса `Stack<>` является не шаблоном функции, а “обычной” функцией, инстанцируемой при необходимости с использованием шаблона класса.

Однако при попытках объявить дружественную функцию и определить ее позже все оказывается более сложным. Фактически у нас есть два варианта.

12. Мы можем неявно объявить новый шаблон функции, который должен использовать отличный параметр шаблона, скажем, `U`:
```c++
template<typename Т>
class Stack
{
	...
	
	template<typename U>
	friend std::ostream& operator << (std::ostream&,
					Stack<U> const&);
};
```

He будет работать ни повторное применение `Т`, ни отбрасывание объявления параметра шаблона (либо внутреннее `Т` скрывает внешнее `Т`, либо мы объявляем нешаблонную функцию в области видимости пространства имен).

13. Мы можем предварительно объявить оператор вывода для `Stack<T>` как шаблон, что означает, что сначала мы должны предварительно объявить `Stack<T>`:
```c++
template<typename Т>
class Stack;

template<typename T>
std::ostream& operator << (std::ostream&, Stack<T> const&);
```

Затем мы можем объявить эту функцию другом:
```c++
template<typename Т>
class Stack
{
	...
	
	friend std::ostream& operator << <T> (std::ostream&, Stack<T> const&);
};
```

Обратите внимание на `<T>` после “имени функции” `operator <<`. Таким образом, мы объявляем специализацию шаблона функции, не являющейся членом, как друга. Без `<Т>` мы бы объявили новую [[Вглубь шаблонов#Дружественные функции шаблонов классов|нешаблонную функцию]].

В любом случае этот класс все еще можно использовать для элементов, для которых не определен `operator <<`. К ошибке приводит только вызов `operator <<`:
```c++
Stack<std::pair<int, int>> ps;       // std::pair<> не имеет оператора <<
ps.push({4, 5});                     //OK
ps.push({6, 7});                     //OK

std::cout << ps.top().first << '\n'; //OK
std::cout << ps.top().second << '\n';// OK
std::cout << ps << '\n';          // Ошибка: operator << не поддерживается
									// для типа элемента
```

# Специализации шаблонов классов

Шаблон класса можно специализировать для конкретных аргументов шаблона. Так же, как и в случае [[Шаблоны функций#Перегрузка шаблонов функций|перегрузки шаблонов функций]], специализированные шаблоны классов позволяют оптимизировать реализации для конкретных типов или корректировать неверное поведение определенных типов при инстанцировании шаблона класса. Однако при специализации шаблона класса необходимо специализировать все его функции-члены. Хотя можно специализировать и отдельную функцию-член шаблона класса, но если сделать это, то потом нельзя будет специализировать целый шаблон класса, которому принадлежит специализированный член.

Чтобы специализировать шаблон класса, следует объявить класс с предваряющей конструкцией `template<>` и указать типы, для которых специализируется шаблон класса. Типы используются в качестве аргументов шаблона и должны задаваться непосредственно после имени класса:
```c++
template<>
class Stack<std::string>
{
	...
};
```

Для таких специализаций любая функция-член должна определяться как “обычная” функция-член с заменой каждого включения `Т` специализированным типом:
```c++
void Stack<std::string>::push(std::string const& elem)
{
	elems.push_back(elem); // Добавление копии переданного элемента
}
```

Ниже приведен завершенный пример специализации `Stack<>` для типа [[string|std::string]].
```c++
#include "stackl.hpp"
#include <deque>
#include <string>
#include <cassert>

template<>
class Stack<std::string>
{
	private:
		std::deque<std::string> elems;    // Элементы
	
	public:
		void push(std::string const&);    // Внесение элемента в стек
		void pop();                       // Удаление элемента из стека
		std::string const& top() const;   // Возврат последнего элемента

		bool empty() const                // Проверка пустоты стека
		{
			return elems.empty();
		}
};

void Stack<std::string>::push(std::string const& elem)
{
	elems.push_back(elem);      // Добавление копии переданного элемента
}

void Stack<std::string>::рор()
{
	assert(!elems.empty());
	elems.pop_back();           // Удаление последнего элемента
)

std::string const& Stack<std::string>::top() const
{
	assert(!elems.empty()) ;
	return elems.back();       // Возврат последнего элемента
}
```

В этом примере специализация использует семантику ссылок для передачи строкового аргумента функции `push()`, которая имеет больше смысла для данного конкретного типа (еще лучше передавать универсальную ссылку; этот вопрос рассматривается в [[Семантика перемещения - Прямая передача - template|Прямая передача]]).

Еще одним отличием является применение дека вместо вектора для управления элементами в стеке. Хотя здесь такая замена не дает особых преимуществ, это сделано, чтобы продемонстрировать, что реализация специализации может значительно отличаться от реализации первичного шаблона.

# Частичная специализация

Шаблоны классов могут быть специализированы частично. Можно определить частные реализации для определенных условий, но при этом некоторые параметры шаблона все еще остаются задаваемыми пользователем. Например, можно определить отдельную специализацию `Stack<>` для указателей:
```c++
#include "stack1.hpp"

// Частичная специализация класса Stack<> для указателей:
template<typename Т>
class Stack<T*>
{
	private:
		std::vector<T*> elems; // Элементы

	public:
		void push(T*);         // Добавление элемента в стек
		T* pop();              // Удаление элемента из стека
		T* top() const;        // Возврат последнего элемента
		bool empty() const     // Проверка пустоты стека
		{
			return elems.empty();
		}
};

template<typename T>
void Stack<T*>::push(T* elem)
{
	elems.push_back(elem); // Добавление копии переданного элемента
};

template<typename Т>
Т* Stack<T*>::pop()
(
	assert(!elems.empty());
	T* p = elems.back();
	elems.pop_back();      // Удаление последнего элемента и его
	return р;              // возврат (в отличие от общего случая)
}

template<typename Т>
Т* Stack<T*>::top() const
{
	assert(!elems.empty());
	return elems.back();   // Возврат копии последнего элемента
}
```

С помощью
```c++
template<typename Т>
class Stack<T*>
{
};
```

мы определяем шаблон класса, все еще параметризованный с использованием `Т`, но специализированный для указателей (`Stack<T*>`).

Еще раз обратите внимание на то, что специализация может предоставлять (несколько) иной интерфейс. Например, в приведенном коде функция `pop()` возвращает хранимый указатель, так что пользователь шаблона класса может вызвать `delete` для удаляемого значения, если оно было создано с помощью оператора `new`:
```c++
Stack<int*> ptrStack;              // Стек указателей
ptrStack.push(new int{42});

std::cout << *ptrStack.top() << '\n';
delete ptrStack.pop();
```

> **Частичная специализация с несколькими параметрами**

Шаблоны классов могут также специализировать взаимоотношения между несколькими параметрами шаблона. Например, для следующего шаблона класса:
```c++
template<typename T1, typename Т2>
class MyClass
{
	...
}
```

возможны такие частичные специализации:
```c++
// Частичная специализация: оба параметра имеют один тип
template<typename Т>
class MyClass<T, Т>
{
	...
};

// Частичная специализация: второй параметр - int
template<typename Т>
class MyClass<T, int>
{
	...
};

// Частичная специализация: оба параметра - указатели
template<typename T1, typename Т2>
class MyClass<T1*, T2*>
{
	...
};
```

В приведенных ниже примерах показано, какие шаблоны используются в тех или иных объявлениях:
```c++
MyClass<int, float> mif;      // Используется MyClass<T1,Т2>
MyClass<float, float> mff;    // Используется MyClass<T,T>
MyClass<float, int> mfi;      // Используется MyClass<T,int>
MyClass<int*, float*> mp;     // Используется MyClass<T1*,T2*>
```

Если одинаково хорошо подходят две специализации, объявление является неоднозначным:
```c++
MyClass<int,int> m;  // Ошибка: годятся MyClass<T,Т> и MyClass<T,int>
MyClass<int*,int*> m;// Ошибка: годятся MyClass<T,T> и MyClass<T1*,Т2*>
```

Для разрешения второй неоднозначности можно воспользоваться специализацией для указателей одного и того же типа:
```c++
template<typename Т>
class MyClass<T*, Т*>
{
	...
};
```

Детально частичная специализация рассматривается в [[Шаблоны Специализация и перегрузка#Частичная специализация шаблона класса|Частичная специализация шаблона класса]].

# Аргументы шаблона класса по умолчанию

Как и для шаблонов функций, для параметров шаблона класса можно определять значения по умолчанию. Например, в класс `Stack<>` можно добавить второй параметр, определяющий контейнер, который используется для хранения элементов, и в качестве значения по умолчанию указать тип [[vector|std::vector<>]].
```c++
#include <vector>
#include <cassert>

template<typename T, typename Cont = std::vector<T>>
class Stack
{
	private:
		Cont elems;               // Элементы

	public:
		void push(T const& elem); // Добавление элемента в стек
		void рор();               // Снятие элемента со стека
		Т const& top() const;     // Возврат элемента с вершины стека
		bool empty() const        // Проверка пустоты стека
		{
			return elems.empty();
		}
};

template<typename T, typename Cont>
void Stack<T, Cont>::push(T const& elem)
{
	elems.push_back(elem);        // Добавление копии переданного элемента
}

template<typename Т, typename Cont>
void Stack<T, Cont>::pop()
{
	assert(!elems.empty());
	elems.pop_back();             // Удаление последнего элемента
}

template<typename T, typename Cont>
T const& Stack<T, Cont>::top() const
{
	assert(ielems.empty() );
	return elems.back();          // Возврат последнего элемента
}
```

Заметим, что теперь, когда у нас имеются два параметра шаблона, каждое определение функции-члена должно иметь эти два параметра.
```c++
template<typename Т, typename Cont>
void Stack<T, Cont>::push(T const& elem)
{
	elems.push_back(elem);       // Добавление копии переданного элемента
}
```

Этот стек можно использовать точно так же, как и раньше. Если шаблону передается только первый аргумент, представляющий тип элементов в стеке, то для хранения элементов этого типа используется вектор.
```c++
template<typename Т, typename Cont = std::vector<T>>
class Stack
{
	private:
		Cont elems; // Элементы

	...
};
```

При объявлении объекта `Stack` в своей программе можно явно указать, какой именно контейнер должен использоваться для хранения элементов.
```c++
#include "stack3.hpp"
#include <iostream>
#include <deque>

int main()
{
	// Стек элементов типа int:
	Stack<int> intStack;
	
	// Стек элементов типа double с контейнером std::deque<>
	Stack<double, std::deque<double>> dblStack;
	
	// Работа co стеком элементов типа int
	intStack.push(7);
	std::cout << intStack.top() << '\n';
	intStack.pop();
	
	// Работа co стеком элементов типа double
	dblStack.push(42.42);
	std::cout << dblStack.top() << '\n';
	dblStack.pop();
}
```

С помощью выражения
```c++
Stack<double, std::deque<double>>
```

мы объявляем стек элементов типа `double`, который для работы с элементами использует контейнер [[deque|std: :deque<>]].

# Псевдонимы типов

Применение шаблонов классов можно сделать более удобным, определив новое имя для типа.

> **Применение [[typedef|typedef]] и using**

Просто определить новое имя полного типа можно двумя способами.

14. С помощью ключевого слова [[typedef|typedef]]:
```c++
typedef Stack<int> IntStack; // typedef

void foo(IntStack const& s); // s - стек для int

IntStack istack[10];         // istack - массив из 10 стеков
```

Будем называть такое объявление ***typedef-объявлением***, а получающееся в результате имя — ***typedef-именем***.

15. С помощью ключевого слова `using` (начиная с C++11):
```c++
using IntStack = Stack<int>; // Объявление псевдонима

void foo(IntStack const& s); // s - стек для int

IntStack istack[10];         // istack - массив из 10 стеков
```

Обратите внимание: в обоих случаях новое имя определяется для уже существующего типа, а не для создаваемого нового типа. Таким образом, после
```c++
typedef Stack<int> IntStack;
```
или
```c++
using IntStack = Stack<int>;
```

`IntStack` и `Stack<int>` представляют собой две взаимозаменяемые записи одного и того же типа.

В качестве общего термина для обоих вариантов определения нового имени для существующего типа мы используем термин объявление псевдонима типа, а для этого нового имени — псевдоним типа.

В силу большей удобочитаемости (определяемое имя типа находится слева от знака `=`) в оставшейся части книги при объявлении псевдонима типа мы предпочитаем синтаксис объявления псевдонима.

> **Шаблоны псевдонимов**

В отличие от [[typedef|typedef]], объявление псевдонима может быть шаблонизировано для того, чтобы предоставить удобное имя для семейства типов. Эта возможность также доступна, начиная с С++11, и называется шаблонным псевдонимом, или, для единообразности именования, шаблоном псевдонима.

Приведенный ниже шаблон псевдонима `DequeStack`, параметризованный типом элементов `Т`, раскрывается в `Stack`, который хранит свои элементы в контейнере [[deque|std::deque]]:
```c++
template<typename Т>
using DequeStack = Stack<T, std::deque<T>>;
```

Следовательно, как шаблоны классов, так и шаблоны псевдонимов могут использоваться в качестве параметризованных типов. Но шаблон псевдонима просто дает новое имя существующему типу, который может использоваться и сам по себе. И `DequeStack<int>`, и `Stack<int, std::deque<int>>` представляют собой один и тот же тип.

Еще раз обратите внимание на то, что в общем случае шаблоны могут быть объявлены и определены только в глобальной области видимости и области видимости пространства имен или внутри объявления класса.

> **Шаблоны псевдонимов для типов-членов**

Шаблоны псевдонимов особенно полезны для определения сокращений для типов, являющихся членами шаблонов классов. После
```c++
template <typename Т> struct МуТуре
{
	typedef ... iterator;

	...
};
```
или
```c++
template <typename T> struct МуТуре
{
	using iterator = ...;

	...
}
```

определение наподобие
```c++
template<typename T>
using MyTypelterator = typename MyType<T>::iterator;
```

позволяет использовать
```c++
MyTypeIterator<int> pos;
```

вместо
```c++
typename MyType<T>::iterator pos;
```

> **Суффикс `_t` свойств типов**

Начиная с C++14, стандартная библиотека использует этот метод для определения сокращений для всех свойств типов в стандартной библиотеке, которые представляют собой тип. Например, чтобы иметь возможность записать
```c++
std::add_const_t<T>             // Начиная с С++14
```

вместо
```c++
typename std::add_const<T>::type // начиная с C++11
```

стандартная библиотека определяет:
```c++
namespace std
{
	template<typename Т> using add_const_t = typename add_const<T>::type;
}
```

# Вывод аргументов шаблона класса

До C++17 было необходимо всегда указывать все типы параметров шаблона класса (если только они не имели значения по умолчанию). Начиная с C++17, это ограничение ослаблено. Теперь вы можете не определять аргументы шаблона явно, если конструктор способен вывести все параметры шаблона (которые не имеют значений по умолчанию).

Так, во всех предыдущих примерах кода можно использовать копирующий конструктор без указания аргументов шаблона:
```c++
Stack<int> intStack1;               // Стек целых чисел
Stack<int> intStack2 = intStack1;   // Работает во всех версиях
Stack intStack3 = intStack1;        // Работает, начиная с С++17
```

Предоставляя конструкторы, которые получают некоторые исходные аргументы, можно поддержать вывод типа элементов стека. Например, рассмотрим стек, который может быть инициализирован одним элементом:
```c++
template<typename Т>
class Stack
{
	private:
		std::vector<T> elems; // Элементы

	public:
		Stack() = default;
		Stack(T const& elem)  // Инициализация стека одним элементом
			: elems({elem})
		{  }
	...
};
```

Это определение позволяет объявить стек следующим образом:
```c++
Stack intStack = 0;          // Stack<int> выводится в С++17
```

Инициализация стека целым числом 0 приводит к тому, что параметр `Т` шаблона выводится как `int`, так что инстанцируется `Stack<int>`.

Обратите внимание на следующее.
* Из-за определения конструктора с одним элементом необходимо явное создание конструктора по умолчанию (с поведением по умолчанию), потому что конструктор по умолчанию доступен только в том случае, если ни один другой конструктор не определен:
```c++
Stack() = default;
```

* Аргумент `elem` передается в `elems` с использованием фигурных скобок для инициализации вектора `elems` с помощью списка инициализации с единственным элементом `elem`:
```c++
: elems({elem})
```

Иного конструктора для явного создания вектора с единственным параметром в качестве единственного элемента не существует.

Обратите внимание: в отличие от шаблонов функций аргументы шаблона класса не могут быть выведены только частично (с явным указанием только некоторых из аргументов шаблона). Подробнее об этом рассказывается в [[Вывод аргументов шаблона#Вывод аргументов шаблонов классов|Вывод аргументов шаблонов классов]].

> **Вывод аргументов шаблона класса с использованием строковых литералов**

В принципе можно инициализировать стек с помощью строкового литерала:
```c++
Stack stringStack = "bottom";     // Будет выведен Stack<char const[7]>
```

Но это вызывает много проблем: в общем случае при передаче аргументов типа шаблона `T` по ссылке, не выполняется низведение параметра (т.е. не работает механизм преобразования типа массива в соответствующий тип указателя). Это означает, что мы выполнили инициализацию
```c++
Stack<char const[7]>
```

и используем тип `char const[7]` везде, где встречается `Т`. Например, мы не можем вносить в стек строки другого размера, поскольку это будет другой тип. Подробнее этот вопрос рассматривается в [[По значению или по ссылке#Работа со строковыми литералами и массивами|Работа со строковыми литералами и массивами]].

Однако при передаче аргументов типа шаблона `Т` по значению выполняется низведение, так что тип массива превращается в соответствующий тип указателя. Таким образом, параметр вызова `Т` конструктора выводится как `char const*`, так что тип самого класса выводится как `Stack<char const*>`.

По этой причине было бы целесообразно объявить конструктор так, чтобы аргумент в него передавался по значению:
```c++
template<typename Т>
class Stack
{
	private:
		std::vector<T> elems;// Элементы

	public:
		Stack(T elem)        // Инициализация одним элементом по значению
			: elems({elem})  // для низведения при выводе типа
		{  	}

		....
};
```

В таком случае приведенная ниже инициализация отлично работает:
```c++
Stack stringStack = "bottom"; // Вывод типа Stack<char const*>
```

Однако в данном случае лучше выполнить перемещение временного значения `elem` в стек, чтобы избежать излишнего копирования:
```c++
template<typename Т>
class Stack
{
	private:
		std::vector<T> elems;// Элементы

	public:
		Stack(T elem)        // Инициализация одним элементом по значению
			: elems({std::move(elem)})
		{    }

	...
};
```

> **Правила вывода**

Вместо объявления конструктора с передачей по значению существует и другое решение: поскольку обработка обычных указателей в контейнерах является источником неприятностей, мы должны запретить автоматическое выведение таких указателей для классов контейнеров.

Можно сформулировать определенные правила вывода (deduction guides) для предоставления дополнительных или исправления существующих выводов аргументов шаблона класса. Например, можно указать, что всякий раз, когда передается строковый литерал или строка в стиле С, создается стек для элементов типа [[string|std::string]]:
```c++
Stack(char const*) -> Stack<std::string>;
```

Это правило должно находиться в той же области видимости (пространстве имен), что и определение класса. Обычно оно следует за определением класса. Мы называем тип, следующий за `->`, типом, управляемым данным правилом.

Теперь объявление
```c++
Stack stringStack{"bottom");     // OK: Stack<std::string> в C++17
```

выводит стек как `Stack<std::string>`. Однако приведенный ниже код по-прежнему неработоспособен:
```c++
Stack stringStack = "bottom";   // Выведен Stack<std::string>,
								// но не работает
```

Мы выводим [[string|std::string]], так что выполняется инстанцирование `Stack<std::string>`:
```c++
class Stack
{
	private:
		std::vector<std::string> elems;     // Элементы

	public:
		Stack<std::string const& elem)
			: elems({elem})
		{   }

	...
};
```

Однако в соответствии с правилами языка при копирующей инициализации (инициализации с использованием `=`) объекта передача строкового литерала в конструктор, ожидающий [[string|std::string]], невозможна. Поэтому инициализировать стек необходимо следующим образом:
```c++
Stack stringStack{"bottom"};   // Выведен Stack<std::string>, работает
```

Обратите внимание на то, что при сомнениях вывод аргумента шаблона класса выполняет копирование. После объявления `stringStack` как `Stack<std::string>` приведенные ниже инициализации объявляют тот же тип (вызывая, таким образом, копирующий конструктор) вместо инициализации стека элементом, который представляет собой стек строк:
```c++
Stack stack2{stringStack};     // Выводится Stack<std::string>
Stack stack3(stringStack);     // Выводится Stack<std::string>
Stack stack4 = {stringStack};  // Выводится Stack<std::string>
```

Дополнительную информацию о выводе аргументов шаблонов классов можно найти в [[Вывод аргументов шаблона#Вывод аргументов шаблонов классов|Вывод аргументов шаблонов классов]].

# Вывод типов шаблонных параметров для классов

До C++17 вывод типов шаблонных параметров работал только для функций, из-за чего при конструировании шаблонного класса всегда было нужно в явном виде указывать шаблонные параметры:
```c++
// C++14

auto p = std::pair<int, char>(10, 'c');
```

либо использовать специализированные функции вроде [[make_pair|std::make_pair]], для неявного вывода типов:
```c++
// C++14

auto p = std::make_pair(10, 'c');
```

Связано это было с тем, что достаточно сложно осуществить такой вывод при наличии нескольких конструкторов в классе. В новом стандарте эта проблема была решена:
```c++
#include <tuple>
#include <array>

template<typename T, typename U>
struct S
{  
	T m_first;  
	U m_second;  
	
	S(T first, U second) : m_first(first), m_second(second) {}
};

int main(){  
	// C++14  
	std::pair<char, int> p1 = { 'c', 42 };  
	std::tuple<char, int, double> t1 = { 'c', 42, 3.14 };  
	S<int, char> s1 = { 10, 'c' };  
	
	// C++17  
	std::pair p2 = { 'c', 42 };  
	std::tuple t2 = { 'c', 42, 3.14 };  
	S s2 = { 10, 'c' };  
	
	return 0;
}
```

Стандартом было определено множество правил вывода типов ([[ALL_IN_ONE#Deduction Guides|deduction guides]]). Также предоставляется возможность самим писать эти правила, например:
```c++
// C++17

#include <iostream>

template<typename T, typename U>
struct S{  
	T m_first;  
	U m_second;
};

// Мой deduction guide
template<typename T, typename U>
S(const T &first, const U &second) -> S<T, U>;

int main(){  
	S s = { 42, "hello" };  
	
	std::cout << s.m_first << s.m_second << '\n';  
	
	return 0;
}
```

Большинство стандартных контейнеров работают без необходимости вручную указывать [[ALL_IN_ONE#Deduction Guides|deduction guides]].  

Примечание: компилятор может вывести _deduction guide_ автоматически из конструктора, но в данном примере у структуры _S_ нет ни одного конструктора, поэтому и определяем _deduction guide вручную._    

Таким образом, вывод типов для классов позволяет значительно сократить код и забыть о таких функциях как [[make_pair|std::make_pair]], [[make_tuple|std::make_tuple]] и использовать вместо них конструктор.

# Шаблонизированные агрегаты

Шаблонами могут быть и агрегатные классы (классы/структуры без пользовательских, явных или унаследованных конструкторов, без закрытых или защищенных нестатических членов-данных, без виртуальных функций и без виртуальных, закрытых или защищенных базовых классов). Например:
```c++
template<typename Т>
struct ValueWithComment
{
	Т value;
	std::string comment;
};
```

определяет агрегат, параметризованный типом хранимого значения `val`. Как и для любых других шаблонов классов, можно объявлять соответствующие объекты и продолжать использовать их как агрегаты:
```c++
ValueWithComment<int> vc;
vc.value = 42;
vc.comment = "начальное значение";
```

Начиная с С++17, можно даже определять правила вывода для шаблонов агрегатных классов:
```c++
ValueWithComment(char const*, char const*)
					-> ValueWithComment<std::string>;
					
ValueWithComment vc2 = {"hello", "начальное значение"};
```

Без правила вывода инициализация невозможна, так как `ValueWithComment` не имеет конструктора, для которого можно было бы выполнить вывод.

Класс стандартной библиотеки [[Array|std::array<>]] также является агрегатом, параметризованным типом элемента и размером. Стандартная библиотека C++17 определяет для него правило вывода, которое будет рассмотрено в [[Вариативные шаблоны#Вариативные правила вывода|Вариативные правила вывода]].
