
[[#Шаблоны классов|Шаблоны классов]] 2
1. [[#Реализация шаблона класса Stack|Реализация шаблона класса Stack]] 2.1


# Шаблоны классов

Подобно функциям, классы могут также быть параметризованы одним или несколькими типами. Классы контейнеров, которые используются для управления элементами определенного типа, являются типичным примером этой возможности. Такие классы контейнеров можно реализовать с помощью шаблонов классов; тип элементов при этом остается открытым. В этой главе мы используем в качестве примера шаблона класса стек.

# Реализация шаблона класса Stack


















































# Вывод типов шаблонных параметров для классов

До C++17 вывод типов шаблонных параметров работал только для функций, из-за чего при конструировании шаблонного класса всегда было нужно в явном виде указывать шаблонные параметры:
```c++
// C++14

auto p = std::pair<int, char>(10, 'c');
```

либо использовать специализированные функции вроде [[make_pair|std::make_pair]], для неявного вывода типов:
```c++
// C++14

auto p = std::make_pair(10, 'c');
```

Связано это было с тем, что достаточно сложно осуществить такой вывод при наличии нескольких конструкторов в классе. В новом стандарте эта проблема была решена:
```c++
#include <tuple>
#include <array>

template<typename T, typename U>
struct S
{  
	T m_first;  
	U m_second;  
	
	S(T first, U second) : m_first(first), m_second(second) {}
};

int main(){  
	// C++14  
	std::pair<char, int> p1 = { 'c', 42 };  
	std::tuple<char, int, double> t1 = { 'c', 42, 3.14 };  
	S<int, char> s1 = { 10, 'c' };  
	
	// C++17  
	std::pair p2 = { 'c', 42 };  
	std::tuple t2 = { 'c', 42, 3.14 };  
	S s2 = { 10, 'c' };  
	
	return 0;
}
```

Стандартом было определено множество правил вывода типов ([[ALL_IN_ONE#Deduction Guides|deduction guides]]). Также предоставляется возможность самим писать эти правила, например:
```c++
// C++17

#include <iostream>

template<typename T, typename U>
struct S{  
	T m_first;  
	U m_second;
};

// Мой deduction guide
template<typename T, typename U>
S(const T &first, const U &second) -> S<T, U>;

int main(){  
	S s = { 42, "hello" };  
	
	std::cout << s.m_first << s.m_second << '\n';  
	
	return 0;
}
```

Большинство стандартных контейнеров работают без необходимости вручную указывать [[ALL_IN_ONE#Deduction Guides|deduction guides]].  

Примечание: компилятор может вывести _deduction guide_ автоматически из конструктора, но в данном примере у структуры _S_ нет ни одного конструктора, поэтому и определяем _deduction guide вручную._    

Таким образом, вывод типов для классов позволяет значительно сократить код и забыть о таких функциях как [[make_pair|std::make_pair]], [[make_tuple|std::make_tuple]] и использовать вместо них конструктор.

# Вывод аргументов для шаблонов классов C++17

Теперь аргументы шаблонов автоматически выводятся не только для функций, но и для классов.

```c++
template <typename T = float> 
struct MyContainer { 
	T val; 
	MyContainer() 
		: val() 
	{} 
	
	MyContainer(T val) 
		: val(val) 
	{} 
	// ... 
}; 

MyContainer c1{ 1 }; // OK MyContainer<int> 
MyContainer c2; // OK MyContainer<float>
```

