
[[#Шаблоны классов|Шаблоны классов]] 2
1. [[#Реализация шаблона класса Stack|Реализация шаблона класса Stack]] 2.1
	1. [[#Объявление шаблона класса|Объявление шаблона класса]] 2.1.1
	2. [[#Реализация функций-членов|Реализация функций-членов]] 2.1.2
2. [[#Использование шаблона класса Stack|Использование шаблона класса Stack]] 2.2
3. [[#Частичное использование шаблонов классов|Частичное использование шаблонов классов]] 2.3
	1. [[#Концепты|Концепты]] 2.3.1
4. [[#Друзья|Друзья]] 2.4
5. [[#Специализации шаблонов классов|Специализации шаблонов классов]] 2.5
6. [[#Частичная специализация|Частичная специализация]] 2.6
7. [[#Аргументы шаблона класса по умолчанию|Аргументы шаблона класса по умолчанию]] 2.7
8. [[#Псевдонимы типов|Псевдонимы типов]] 2.8
9. [[#Вывод аргументов шаблона класса|Вывод аргументов шаблона класса]] 2.9


# Шаблоны классов

Подобно функциям, классы могут также быть параметризованы одним или несколькими типами. Классы контейнеров, которые используются для управления элементами определенного типа, являются типичным примером этой возможности. Такие классы контейнеров можно реализовать с помощью шаблонов классов; тип элементов при этом остается открытым. В этой главе мы используем в качестве примера шаблона класса стек.

# Реализация шаблона класса Stack

Как и в случае шаблонов функций, мы объявляем и определяем класс `Stack<>`
в заголовочном файле следующим образом:
```c++
#include <vector>
#include <cassert>

template<typename T>
class Stack
{
	private:
		std::vector<T> elems;      // Элементы

	public:
		void push(T const& elem);  // Внесение в стек
		void pop();                // Снятие со стека
		
		T const& top() const;      // Верхний элемент стека
		
		bool empty() const         // Пуст ли стек
		{
			return elems.empty();
		}
};
		
template<typename Т>
void Stack<T>::push(T const& elem)
{
	elems.push_back(elem);        // Добавление копии переданного элемента
}

template<typename Т>
void Stack<T>::рор()
{
	assert(!elems.empty());
	elems.pop_back();             // Удаление последнего элемента
}

template<typename T>
T const& Stack<T>::top() const
{
	assert(!elems.empty());
	return elems.back();          // Возврат последнего элемента
}
```

Как видите, шаблон класса реализован с использованием шаблона класса [[vector#std vector|vector<>]] из стандартной библиотеки C++. В результате нам не нужно реализовывать управление памятью, копирующий конструктор и оператор присваивания, так что мы можем сосредоточиться на интерфейсе данного шаблона класса.

## Объявление шаблона класса

Объявление шаблона класса подобно объявлению шаблона функции: перед объявлением следует объявить один или несколько идентификаторов в качестве параметров типов. Обычно в качестве идентификатора используется `Т`:
```c++
template<typename Т>
class Stack
{
	...
};
```

Здесь также ключевое слово class может быть использовано вместо ключевого слова [[typename|typename]]:
```c++
template<class Т>
class Stack
{
	...
};
```

Внутри шаблона класса имя `Т` может использоваться так же, как и любой другой тип, для объявления членов-данных и функций-членов. В приведенном далее примере `Т` используется для объявления типа элементов как вектора, в объявлении метода `push()` как функции, которая получает `Т` в качестве аргумента, и для объявления `top()` как функции, возвращающей `Т`:
```c++
template<typename Т>
class Stack
{
	private:
		std::vector<T> elems;             // Элементы
		
	public:
		void push(T const& elem);         // Внесение в стек
		void pop();                       // Снятие со стека
		T const & top() const;            // Верхний элемент стека
		bool empty() const                // Пуст ли стек
		{
			return elems.empty();
		}
};
```

Типом этого класса является `Stack<T>`, где `Т` представляет собой параметр шаблона. Таким образом, `Stack<T>` придется использовать всякий раз, когда тип этого класса применяется в объявлении, за исключением тех случаев, когда аргументы шаблона могут быть выведены. Однако внутри шаблона класса имя класса, за которым не следуют аргументы шаблона, представляет класс с параметрами шаблона в качестве аргументов (подробности см. в #разделе_13_2_3).

Если, например, вам нужно объявить свой собственный копирующий конструктор и оператор присваивания, обычно это выглядит так:
```c++
template<typename Т>
class Stack
{
	...
	
	Stack(Stack const&);                // Копирующий конструктор
	Stack& operator= (Stack const &);   // Оператор присваивания

	...
};
```

что формально эквивалентно следующему коду:
```c++
template<typename Т>
class Stack
{
	...
	
	Stack(Stack<T> const &);               // Копирующий конструктор
	Stack<T>& operator=(Stack<T> const &); // Оператор присваивания

	...
};
```

Однако обычно `<Т>` сигнализирует об особой обработке параметров шаблона, поэтому лучше использовать первую форму записи.

Однако вне структуры класса такое указание является необходимым:
```c++
template<typename Т>
bool operator == (Stack<T> const& lhs, Stack<T> const& rhs);
```

Обратите внимание на то, что в местах, где требуется имя, а не тип класса, можно использовать только `Stack`. Это, в частности, относится к указанию имен конструкторов (но не их аргументов) и деструкторов.

Заметим также, что в отличие от нешаблонных классов нельзя объявлять или определять шаблоны классов внутри функций или в области видимости блока. В общем случае шаблоны могут быть определены только в глобальной области видимости, области видимости пространства имен или внутри объявлений классов (подробнее см. в #разделе_12_1).

## Реализация функций-членов

Для того чтобы определить функцию-член шаблона класса, нужно указать, что это шаблон функции; при этом необходимо использовать полностью квалифицированный тип шаблона класса. Таким образом, реализация функции-члена `push()` типа `Stack<T>` имеет следующий вид:
```c++
template<typename Т>
void Stack<T>::push(Т const& elem)
{
	elems.push_back(elem);     // Добавление копии переданного элемента
}
```

В этом случае вызывается функция `push_back()` вектора элементов, которая добавляет элемент в конец вектора.

Заметим, что функция `pop_back()` вектора удаляет последний элемент, но не возвращает его, что связано с вопросами безопасности исключений. Реализовать полностью безопасную в плане исключений функцию `pop()`, возвращающую удаленный элемент, невозможно (этот вопрос впервые был рассмотрен Томом Каргиллом (Tom Cargill) в [#31]; кроме того, этот вопрос детально рассматривается в [#68]). Однако если игнорировать небезопасность данной функции в плане исключений, то можно реализовать функцию `pop()`, возвращающую только что удаленный элемент. Для этого мы просто используем `Т` для объявления локальной переменной соответствующего типа.
```c++
template<typename Т>
Т Stack<T>::рор()
{
	assert(!elems.empty());
	
	Т elem = elems.back();      // Сохранение копии последнего элемента
	elems.pop_back();           // Удаление последнего элемента
	
	return elem;                // Возврат копии сохраненного элемента
}
```

Поскольку поведение функций вектора `back()` (возвращающей последний элемент) и `pop_back()` (удаляющей последний элемент) не определено для случая, когда вектор не содержит ни одного элемента, требуется проверка, не является ли стек пустым. Если он пуст, мы завершаем программу с использованием `assert`, так как вызов `pop()` для пустого стека является ошибкой. Так же мы поступаем и в функции `top()`, которая возвращает (но не удаляет) элемент, находящийся на вершине стека:
```c++
template<typename Т>
Т const& Stack<T>::top() const
{
	assert(!elems.empty());
	
	return elems.back();         // Возврат последнего элемента
}
```

Конечно, точно так же, как и в случае любых других функций-членов, функции-члены шаблонов классов можно реализовать как встраиваемые функции, располагающиеся внутри объявления класса, например:
```c++
template<typename Т>
class Stack
{
	... 
	
	void push(T const& elem)
	{
		elems.push_back(elem);	// Добавление копии переданного элемента
	}
	
	...
}
```

# Использование шаблона класса Stack

Для того чтобы использовать объект шаблона класса, до C++17 требовалось явно указать аргументы шаблона. В приведенном ниже примере показано, как используется шаблон класса `Stack<>`.
```c++
#include "stack1.hpp"
#include <iostream>
#include <string>

int main()
{
	Stack<int> intstack;                 // Стек элементов int
	Stack<std::string> stringStack;      // Стек элементов string

	// Работа co стеком целых чисел
	intstack.push(7);
	std::cout << intstack.top() << ' \n';  //top-возвращение верхнего э-та
	
	// Работа co стеком строк
	stringStack.push("hello");
	std::cout << stringStack.top() << '\n';
	stringStack.pop();
}
```

Объявление `Stack<int>` указывает, что внутри шаблона класса в качестве типа `Т` будет использоваться `int`. Таким образом, `intstack` создается как объект на базе вектора с элементами типа `int`, и для всех вызываемых функций-членов инстанцируется код для этого типа. Аналогично путем объявления и использования `Stack<std::string>` создается объект на базе вектора, элементами которого являются строки, и для каждой из вызываемых функций-элементов инстанцируется код для этого типа.

Заметим, что инстанцирование происходит только для вызываемых функций (членов) шаблона. Для шаблонов классов функции-члены инстанцируются только при их использовании. Очевидно, что такой подход позволяет сэкономить время, память и [[#Частичное использование шаблонов классов|использовать шаблоны классов только частично]].

В данном примере инстанцируются конструктор по умолчанию, а также функции `push()` и `top()` как для значений типа `int`, так и для значений типа [[string|string]]. Однако функция `pop()` инстанцируется только для строк. Если шаблон класса имеет статические члены, то они инстанцируются однократно для каждого типа, для которого используется шаблон класса.

Тип инстанцированного шаблона класса можно использовать так же, как и любой другой тип. Вы можете квалифицировать его с помощью ключевых слов [[const|const]] или [[volatile|volatile]], а также создавать на его основе массивы или ссылки. Его также можно использовать как часть определения типа с помощью [[typedef|typedef]] или `using` (об определениях типов рассказывается в #разделе_2_8) или в качестве параметра типа при создании другого шаблонного типа, например:
```c++
void foo(Stack<int> const& s)    // Параметр s представляет собой стек
{
	using IntStack = Stack<int>; // IntStack - псевдоним для Stack<int>
	Stack<int> istack[1O];       // istack — массив из 10 стеков
	IntStack istack2[10];        // istack2 — такой же массив того же типа
```

Аргументы шаблона могут быть любого типа, такими как указатели на `float` или даже стеками элементов типа `int`:
```c++
Stack<float*> floatPtrStack;       // Стек указателей на float
Stack<Stack<int>> intStackStack;   // Стек стеков элементов int
```

Единственным требованием является то, что любая вызываемая операция должна быть возможна для этого типа.

До принятия стандарта C++11 между двумя закрывающими угловыми скобками требовалось помещать пробел:
```c++
Stack<Stack<int> > intStackStack;  // Работает для всех версий C++
```

Если этого не сделать, получался оператор `>>`, что приводило к синтаксической ошибке:
```c++
Stack<Stack<int>> intStackStack;   // Ошибка до С++11
```

Причиной такого поведения в старых версиях C++ было то, что при первом проходе компилятора C++ выполнялось разделение исходного кода на лексемы независимо от семантики кода. Однако, поскольку отсутствие пробела стало распространенной ошибкой, требовавшей соответствующего сообщения об ошибках, было принято решение учитывать семантику кода в любом случае, и в стандарте C++11 требование ставить пробел между двумя закрывающими угловыми скобками в шаблонах было убрано (см. #раздел_13_3_1).

# Частичное использование шаблонов классов

Шаблон класса обычно выполняет несколько операций над аргументами шаблона, для которых он инстанцируется (в том числе конструирование и уничтожение). Это может привести к впечатлению, что аргументы шаблона должны предоставлять все операции, необходимые для всех функций-членов шаблона класса. Но это не так: аргументы шаблона обязаны предоставлять только те операции, которые необходимы (а не те, которые могут потребоваться).

Пусть, например, класс `Stack<>` предоставляет функцию-член `printOn()` для вывода содержимого стека, вызывающую `operator <<` для каждого элемента:
```c++
template<typename Т>
class Stack
{
	...
	
	void printOn(std::ostream& strm)
	{
		for (T const& elem : elems)
		{
			strm << elem << '  ';    // Вызов << для каждого элемента
		}
	}
};
```

При этом вы все равно можете использовать этот класс для элементов, для которых не определен `operator <<`:
```c++
Stack<std::pair<int, int>> ps; // std::pair<> не имеет operator <<
ps.push({4, 5});               //OK
ps.push({6, 7});               //OK

std::cout << ps.top().first << ' \n'; // OK
std::cout << ps.top().second << '\n'; // OK
```

И только если вы вызовете `printOn()` для такого стека, то получите ошибку времени компиляции, потому что компилятор не сможет инстанцировать вызов `operator <<` для этого конкретного типа элемента:
```c++
ps.printOn(std::cout);  // Ошибка: operator << не поддерживается
						// для данного типа элементов
```

## Концепты

Это приводит к вопросу: как нам узнать, какие операции необходимы, чтобы шаблон мог быть инстанцирован? Термин **концепт** (concept) часто используется для обозначения множества ограничений, которые многократно требуются в библиотеке шаблонов. Например, стандартная библиотека C++ опирается на такие ограничения, как итератор с произвольным доступом и конструируемостъ по умолчанию.

В настоящее время (т.е. по стандарту C++17) концепты могут быть более или менее выражены только в документации (например, с помощью комментариев в коде). Это может стать серьезной проблемой из-за того, что нарушение ограничений может привести к жутким сообщениям об ошибках (см. #раздел_9_4).

В течение многих лет были неоднократные попытки ввести определения и проверки концептов в качестве возможности языка. Однако до стандарта C++17 включительно этот подход так и не был стандартизован.

Начиная с С++11, существует возможность выполнения по крайней мере некоторых проверок основных ограничений с использованием ключевого слова [[static_assert|static_assert]] и некоторых предопределенных свойств типов, например:
```c++
template<typename Т>
class С
{
	static_assert(std::is_default_constructible<T>::value,
		"Класс С требует элементы, "
		"конструируемые по умолчанию");
	
	...
};
```

Без этого статического утверждения, если требуется конструктор по умолчанию, все равно произойдет ошибка компиляции. Однако в таком случае сообщение об ошибке может содержать всю историю инстанцирования шаблона - от исходной причины неудачного инстанцирования до определения шаблона, в котором была обнаружена ошибка (см. #раздел_9_4).

Однако для проверки, например, того, что объекты типа `Т` предоставляют определенную функцию-член или что их можно сравнивать с помощью оператора `<`, требуется куда более сложный код. Подробный пример такого кода приведен в #разделе_19_6_3.

Детальное обсуждение концептов в C++ содержится в #приложении_Д, “Концепты”.

# Друзья

Вместо печати содержимого стека с помощью функции `printOn()` лучше реализовать `operator <<` для стека. Однако, как обычно, `operator <<` должен быть реализован как свободная функция, которая затем может вызывать функцию-член `printOn()`:
```c++
template<typename Т>
class Stack
{
	...

	void printOn(std::ostream& strm) const
	{
		...
	}
	
	friend std::ostream& operator << (std::ostream& strm,
					Stack<T> const& s)
	{
		s.printOn(strm);
		return strm;
	}
};
```

Обратите внимание: это означает, что `operator <<` для класса `Stack<>` является не шаблоном функции, а “обычной” функцией, инстанцируемой при необходимости с использованием шаблона класса.

Однако при попытках объявить дружественную функцию и определить ее позже все оказывается более сложным. Фактически у нас есть два варианта.

10. Мы можем неявно объявить новый шаблон функции, который должен использовать отличный параметр шаблона, скажем, `U`:
```c++
template<typename Т>
class Stack
{
	...
	
	template<typename U>
	friend std::ostream& operator << (std::ostream&,
					Stack<U> const&);
};
```

He будет работать ни повторное применение `Т`, ни отбрасывание объявления параметра шаблона (либо внутреннее `Т` скрывает внешнее `Т`, либо мы объявляем нешаблонную функцию в области видимости пространства имен).

11. Мы можем предварительно объявить оператор вывода для `Stack<T>` как шаблон, что означает, что сначала мы должны предварительно объявить `Stack<T>`:
```c++
template<typename Т>
class Stack;

template<typename T>
std::ostream& operator << (std::ostream&, Stack<T> const&);
```

Затем мы можем объявить эту функцию другом:
```c++
template<typename Т>
class Stack
{
	...
	
	friend std::ostream& operator << <T> (std::ostream&, Stack<T> const&);
};
```

Обратите внимание на `<T>` после “имени функции” `operator <<`. Таким образом, мы объявляем специализацию шаблона функции, не являющейся членом, как друга. Без `<Т>` мы бы объявили новую нешаблонную функцию (см. #раздел_12_5_2).

В любом случае этот класс все еще можно использовать для элементов, для которых не определен `operator <<`. К ошибке приводит только вызов `operator <<`:
```c++
Stack<std::pair<int, int>> ps;       // std::pair<> не имеет оператора <<
ps.push({4, 5});                     //OK
ps.push({6, 7});                     //OK

std::cout << ps.top().first << '\n'; //OK
std::cout << ps.top().second << '\n';// OK
std::cout << ps << '\n';          // Ошибка: operator << не поддерживается
									// для типа элемента
```

# Специализации шаблонов классов

Шаблон класса можно специализировать для конкретных аргументов шаблона. Так же, как и в случае [[Шаблоны функций#Перегрузка шаблонов функций|перегрузки шаблонов функций]], специализированные шаблоны классов позволяют оптимизировать реализации для конкретных типов или корректировать неверное поведение определенных типов при инстанцировании шаблона класса. Однако при специализации шаблона класса необходимо специализировать все его функции-члены. Хотя можно специализировать и отдельную функцию-член шаблона класса, но если сделать это, то потом нельзя будет специализировать целый шаблон класса, которому принадлежит специализированный член.

Чтобы специализировать шаблон класса, следует объявить класс с предваряющей конструкцией `template<>` и указать типы, для которых специализируется шаблон класса. Типы используются в качестве аргументов шаблона и должны задаваться непосредственно после имени класса:
```c++
template<>
class Stack<std::string>
{
	...
};
```

Для таких специализаций любая функция-член должна определяться как “обычная” функция-член с заменой каждого включения `Т` специализированным типом:
```c++
void Stack<std::string>::push(std::string const& elem)
{
	elems.push_back(elem); // Добавление копии переданного элемента
}
```

Ниже приведен завершенный пример специализации `Stack<>` для типа [[string|std::string]].
```c++
#include "stackl.hpp"
#include <deque>
#include <string>
#include <cassert>

template<>
class Stack<std::string>
{
	private:
		std::deque<std::string> elems;    // Элементы
	
	public:
		void push(std::string const&);    // Внесение элемента в стек
		void pop();                       // Удаление элемента из стека
		std::string const& top() const;   // Возврат последнего элемента

		bool empty() const                // Проверка пустоты стека
		{
			return elems.empty();
		}
};

void Stack<std::string>::push(std::string const& elem)
{
	elems.push_back(elem);      // Добавление копии переданного элемента
}

void Stack<std::string>::рор()
{
	assert(!elems.empty());
	elems.pop_back();           // Удаление последнего элемента
)

std::string const& Stack<std::string>::top() const
{
	assert(!elems.empty()) ;
	return elems.back();       // Возврат последнего элемента
}
```

В этом примере специализация использует семантику ссылок для передачи строкового аргумента функции `push()`, которая имеет больше смысла для данного конкретного типа (еще лучше передавать универсальную ссылку; этот вопрос рассматривается в #разделе_6_1).

Еще одним отличием является применение дека вместо вектора для управления элементами в стеке. Хотя здесь такая замена не дает особых преимуществ, это сделано, чтобы продемонстрировать, что реализация специализации может значительно отличаться от реализации первичного шаблона.

# Частичная специализация

Шаблоны классов могут быть специализированы частично. Можно определить частные реализации для определенных условий, но при этом некоторые параметры шаблона все еще остаются задаваемыми пользователем. Например, можно определить отдельную специализацию `Stack<>` для указателей:
```c++
#include "stack1.hpp"

// Частичная специализация класса Stack<> для указателей:
template<typename Т>
class Stack<T*>
{
	private:
		std::vector<T*> elems; // Элементы

	public:
		void push(T*);         // Добавление элемента в стек
		T* pop();              // Удаление элемента из стека
		T* top() const;        // Возврат последнего элемента
		bool empty() const     // Проверка пустоты стека
		{
			return elems.empty();
		}
};

template<typename T>
void Stack<T*>::push(T* elem)
{
	elems.push_back(elem); // Добавление копии переданного элемента
};

template<typename Т>
Т* Stack<T*>::pop()
(
	assert(!elems.empty());
	T* p = elems.back();
	elems.pop_back();      // Удаление последнего элемента и его
	return р;              // возврат (в отличие от общего случая)
}

template<typename Т>
Т* Stack<T*>::top() const
{
	assert(!elems.empty());
	return elems.back();   // Возврат копии последнего элемента
}
```

С помощью
```c++
template<typename Т>
class Stack<T*>
{
};
```

мы определяем шаблон класса, все еще параметризованный с использованием `Т`, но специализированный для указателей (`Stack<T*>`).

Еще раз обратите внимание на то, что специализация может предоставлять (несколько) иной интерфейс. Например, в приведенном коде функция `pop()` возвращает хранимый указатель, так что пользователь шаблона класса может вызвать `delete` для удаляемого значения, если оно было создано с помощью оператора `new`:
```c++
Stack<int*> ptrStack;              // Стек указателей
ptrStack.push(new int{42});

std::cout << *ptrStack.top() << '\n';
delete ptrStack.pop();
```

> **Частичная специализация с несколькими параметрами**

Шаблоны классов могут также специализировать взаимоотношения между несколькими параметрами шаблона. Например, для следующего шаблона класса:
```c++
template<typename T1, typename Т2>
class MyClass
{
	...
}
```

возможны такие частичные специализации:
```c++
// Частичная специализация: оба параметра имеют один тип
template<typename Т>
class MyClass<T, Т>
{
	...
};

// Частичная специализация: второй параметр - int
template<typename Т>
class MyClass<T, int>
{
	...
};

// Частичная специализация: оба параметра - указатели
template<typename T1, typename Т2>
class MyClass<T1*, T2*>
{
	...
};
```

В приведенных ниже примерах показано, какие шаблоны используются в тех или иных объявлениях:
```c++
MyClass<int, float> mif;      // Используется MyClass<T1,Т2>
MyClass<float, float> mff;    // Используется MyClass<T,T>
MyClass<float, int> mfi;      // Используется MyClass<T,int>
MyClass<int*, float*> mp;     // Используется MyClass<T1*,T2*>
```

Если одинаково хорошо подходят две специализации, объявление является неоднозначным:
```c++
MyClass<int,int> m;  // Ошибка: годятся MyClass<T,Т> и MyClass<T,int>
MyClass<int*,int*> m;// Ошибка: годятся MyClass<T,T> и MyClass<T1*,Т2*>
```

Для разрешения второй неоднозначности можно воспользоваться специализацией для указателей одного и того же типа:
```c++
template<typename Т>
class MyClass<T*, Т*>
{
	...
};
```

Детально частичная специализация рассматривается в #разделе_16_4.

# Аргументы шаблона класса по умолчанию

Как и для шаблонов функций, для параметров шаблона класса можно определять значения по умолчанию. Например, в класс `Stack<>` можно добавить второй параметр, определяющий контейнер, который используется для хранения элементов, и в качестве значения по умолчанию указать тип [[vector|std::vector<>]].
```c++
#include <vector>
#include <cassert>

template<typename T, typename Cont = std::vector<T>>
class Stack
{
	private:
		Cont elems;               // Элементы

	public:
		void push(T const& elem); // Добавление элемента в стек
		void рор();               // Снятие элемента со стека
		Т const& top() const;     // Возврат элемента с вершины стека
		bool empty() const        // Проверка пустоты стека
		{
			return elems.empty();
		}
};

template<typename T, typename Cont>
void Stack<T, Cont>::push(T const& elem)
{
	elems.push_back(elem);        // Добавление копии переданного элемента
}

template<typename Т, typename Cont>
void Stack<T, Cont>::pop()
{
	assert(!elems.empty());
	elems.pop_back();             // Удаление последнего элемента
}

template<typename T, typename Cont>
T const& Stack<T, Cont>::top() const
{
	assert(ielems.empty() );
	return elems.back();          // Возврат последнего элемента
}
```

Заметим, что теперь, когда у нас имеются два параметра шаблона, каждое определение функции-члена должно иметь эти два параметра.
```c++
template<typename Т, typename Cont>
void Stack<T, Cont>::push(T const& elem)
{
	elems.push_back(elem);       // Добавление копии переданного элемента
}
```

Этот стек можно использовать точно так же, как и раньше. Если шаблону передается только первый аргумент, представляющий тип элементов в стеке, то для хранения элементов этого типа используется вектор.
```c++
template<typename Т, typename Cont = std::vector<T>>
class Stack
{
	private:
		Cont elems; // Элементы

	...
};
```

При объявлении объекта `Stack` в своей программе можно явно указать, какой именно контейнер должен использоваться для хранения элементов.
```c++
#include "stack3.hpp"
#include <iostream>
#include <deque>

int main()
{
	// Стек элементов типа int:
	Stack<int> intStack;
	
	// Стек элементов типа double с контейнером std::deque<>
	Stack<double, std::deque<double>> dblStack;
	
	// Работа co стеком элементов типа int
	intStack.push(7);
	std::cout << intStack.top() << '\n';
	intStack.pop();
	
	// Работа co стеком элементов типа double
	dblStack.push(42.42);
	std::cout << dblStack.top() << '\n';
	dblStack.pop();
}
```

С помощью выражения
```c++
Stack<double, std::deque<double>>
```

мы объявляем стек элементов типа `double`, который для работы с элементами использует контейнер [[deque|std: :deque<>]].

# Псевдонимы типов

Применение шаблонов классов можно сделать более удобным, определив новое имя для типа.

> **Применение [[typedef|typedef]] и using**

Просто определить новое имя полного типа можно двумя способами.

12. С помощью ключевого слова [[typedef|typedef]]:
```c++
typedef Stack<int> IntStack; // typedef

void foo(IntStack const& s); // s - стек для int

IntStack istack[10];         // istack - массив из 10 стеков
```

Будем называть такое объявление ***typedef-объявлением***, а получающееся в результате имя — ***typedef-именем***.

13. С помощью ключевого слова `using` (начиная с C++11):
```c++
using IntStack = Stack<int>; // Объявление псевдонима

void foo(IntStack const& s); // s - стек для int

IntStack istack[10];         // istack - массив из 10 стеков
```

Обратите внимание: в обоих случаях новое имя определяется для уже существующего типа, а не для создаваемого нового типа. Таким образом, после
```c++
typedef Stack<int> IntStack;
```
или
```c++
using IntStack = Stack<int>;
```

`IntStack` и `Stack<int>` представляют собой две взаимозаменяемые записи одного и того же типа.

В качестве общего термина для обоих вариантов определения нового имени для существующего типа мы используем термин объявление псевдонима типа, а для этого нового имени — псевдоним типа.

В силу большей удобочитаемости (определяемое имя типа находится слева от знака `=`) в оставшейся части книги при объявлении псевдонима типа мы предпочитаем синтаксис объявления псевдонима.

> **Шаблоны псевдонимов**

В отличие от [[typedef|typedef]], объявление псевдонима может быть шаблонизировано для того, чтобы предоставить удобное имя для семейства типов. Эта возможность также доступна, начиная с С++11, и называется шаблонным псевдонимом, или, для единообразности именования, шаблоном псевдонима.

Приведенный ниже шаблон псевдонима `DequeStack`, параметризованный типом элементов `Т`, раскрывается в `Stack`, который хранит свои элементы в контейнере [[deque|std::deque]]:
```c++
template<typename Т>
using DequeStack = Stack<T, std::deque<T>>;
```

Следовательно, как шаблоны классов, так и шаблоны псевдонимов могут использоваться в качестве параметризованных типов. Но шаблон псевдонима просто дает новое имя существующему типу, который может использоваться и сам по себе. И `DequeStack<int>`, и `Stack<int, std::deque<int>>` представляют собой один и тот же тип.

Еще раз обратите внимание на то, что в общем случае шаблоны могут быть объявлены и определены только в глобальной области видимости и области видимости пространства имен или внутри объявления класса.

> **Шаблоны псевдонимов для типов-членов**

Шаблоны псевдонимов особенно полезны для определения сокращений для типов, являющихся членами шаблонов классов. После
```c++
template <typename Т> struct МуТуре
{
	typedef ... iterator;

	...
};
```
или
```c++
template <typename T> struct МуТуре
{
	using iterator = ...;

	...
}
```

определение наподобие
```c++
template<typename T>
using MyTypelterator = typename MyType<T>::iterator;
```

позволяет использовать
```c++
MyTypeIterator<int> pos;
```

вместо
```c++
typename MyType<T>::iterator pos;
```

> **Суффикс `_t` свойств типов**

Начиная с C++14, стандартная библиотека использует этот метод для определения сокращений для всех свойств типов в стандартной библиотеке, которые представляют собой тип. Например, чтобы иметь возможность записать
```c++
std::add_const_t<T>             // Начиная с С++14
```

вместо
```c++
typename std::add_const<T>::type // начиная с C++11
```

стандартная библиотека определяет:
```c++
namespace std
{
	template<typename Т> using add_const_t = typename add_const<T>::type;
}
```

# Вывод аргументов шаблона класса





















# Вывод типов шаблонных параметров для классов

До C++17 вывод типов шаблонных параметров работал только для функций, из-за чего при конструировании шаблонного класса всегда было нужно в явном виде указывать шаблонные параметры:
```c++
// C++14

auto p = std::pair<int, char>(10, 'c');
```

либо использовать специализированные функции вроде [[make_pair|std::make_pair]], для неявного вывода типов:
```c++
// C++14

auto p = std::make_pair(10, 'c');
```

Связано это было с тем, что достаточно сложно осуществить такой вывод при наличии нескольких конструкторов в классе. В новом стандарте эта проблема была решена:
```c++
#include <tuple>
#include <array>

template<typename T, typename U>
struct S
{  
	T m_first;  
	U m_second;  
	
	S(T first, U second) : m_first(first), m_second(second) {}
};

int main(){  
	// C++14  
	std::pair<char, int> p1 = { 'c', 42 };  
	std::tuple<char, int, double> t1 = { 'c', 42, 3.14 };  
	S<int, char> s1 = { 10, 'c' };  
	
	// C++17  
	std::pair p2 = { 'c', 42 };  
	std::tuple t2 = { 'c', 42, 3.14 };  
	S s2 = { 10, 'c' };  
	
	return 0;
}
```

Стандартом было определено множество правил вывода типов ([[ALL_IN_ONE#Deduction Guides|deduction guides]]). Также предоставляется возможность самим писать эти правила, например:
```c++
// C++17

#include <iostream>

template<typename T, typename U>
struct S{  
	T m_first;  
	U m_second;
};

// Мой deduction guide
template<typename T, typename U>
S(const T &first, const U &second) -> S<T, U>;

int main(){  
	S s = { 42, "hello" };  
	
	std::cout << s.m_first << s.m_second << '\n';  
	
	return 0;
}
```

Большинство стандартных контейнеров работают без необходимости вручную указывать [[ALL_IN_ONE#Deduction Guides|deduction guides]].  

Примечание: компилятор может вывести _deduction guide_ автоматически из конструктора, но в данном примере у структуры _S_ нет ни одного конструктора, поэтому и определяем _deduction guide вручную._    

Таким образом, вывод типов для классов позволяет значительно сократить код и забыть о таких функциях как [[make_pair|std::make_pair]], [[make_tuple|std::make_tuple]] и использовать вместо них конструктор.

# Вывод аргументов для шаблонов классов C++17

Теперь аргументы шаблонов автоматически выводятся не только для функций, но и для классов.

```c++
template <typename T = float> 
struct MyContainer { 
	T val; 
	MyContainer() 
		: val() 
	{} 
	
	MyContainer(T val) 
		: val(val) 
	{} 
	// ... 
}; 

MyContainer c1{ 1 }; // OK MyContainer<int> 
MyContainer c2; // OK MyContainer<float>
```

