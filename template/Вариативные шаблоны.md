
[[Вариативные шаблоны|Вариативные шаблоны]] 4
1. [[#Шаблоны с переменным количеством аргументов|Шаблоны с переменным количеством аргументов]] 4.1
	1. [[#Примеры вариативных шаблонов|Примеры вариативных шаблонов]] 4.1.1
	2. [[#Перегрузка вариативных и невариативных шаблонов|Перегрузка вариативных и невариативных шаблонов]] 4.1.2
	3. [[#Оператор sizeof. . .|Оператор sizeof. . .]] 4.1.3
	4. [[#Шаблоны с переменным числом аргументов C++11|Шаблоны с переменным числом аргументов C++11]]
	5. [[#Пример вычисление факториала C++11|Пример: вычисление факториала  C++11]]
	6. [[#Пример числа Фиббоначчи C++11|Пример: числа Фиббоначчи C++11]]
2. [[#Выражения свертки|Выражения свертки]] 4.2
3. [[#Свертка параметров шаблона (Fold expressions)|Свертка параметров шаблона (Fold expressions)]]
4. [[#Применения шаблонов с переменным количеством аргументов|Применения шаблонов с переменным количеством аргументов]] 4.3


# Вариативные шаблоны

Начиная с C++11, параметрам шаблонов можно сопоставлять переменное количество аргументов шаблона. Это дает возможность использовать шаблоны в местах, где требуется передать произвольное количество аргументов произвольных типов. Типичное приложение этой возможности — передача произвольного количества параметров различных типов в класс. Еще одно применение — предоставить обобщенный код для обработки любого количества параметров произвольных типов.

# Шаблоны с переменным количеством аргументов

Параметры шаблона могут быть определены таким образом, чтобы принимать неограниченное количество аргументов шаблона. Такие шаблоны называются вариативными (variadic templates).

## Примеры вариативных шаблонов

Например, можно использовать приведенный ниже код для вызова функции `print()` для переменного количества аргументов разных типов:
```c++
#include <iostream>

void print()
{
}

template<typename T, typename... Types>
void print(T firstArg, Types... args)
{
	std::cout << firstArg << '\n';  // Печать первого аргумента
	print(args...);                 // Вызов print() для остальных
									// аргументов
}
```

Если передаются один или несколько аргументов, используется шаблон функции, который, указывая отдельно первый аргумент, позволяет выводить в консоль первый аргумент, перед тем как рекурсивно применить `print()` для остальных аргументов. Остальные аргументы, представленные именем `args`, являются пакетом параметров функции (function parameter pack):
```c++
void print(T firstArg, Types... args)
```

`Types` указывается в пакете параметров шаблона (template parameter pack):
```c++
template<typename T, typename... Types>
```

Для завершения рекурсии предоставляется нешаблонная перегрузка `print()`, которая вызывается при пустом пакете параметров.

Например, вызов
```c++
std::string s("world");
print(7.5, "hello", s) ;
```

приведет к следующему выводу в консоль:
```
7.5
hello
world
```

Первый вызов расширяется до
```c++
print<double, char const*, std::string>(7.5, "hello", s);
```

где:
* `firstArg` имеет значение 7.5, так что тип `Т` представляет собой `double`, а
* `args` является вариативным аргументом шаблона, который содержит значения `"hello"` типа `char const*` и `"world"` типа [[string|std::string]].

После вывода в консоль `"hello"` в качестве `firstArg` вновь вызывается `print()` для оставшихся аргументов. Этот вызов расширяется до
```c++
print<char const*, std::string> ("hello", s);
```

где:
* `firstArg` имеет значение `"hello"`, так что тип `Т` представляет собой `char const*`, а
* `args` является вариативным аргументом шаблона, который содержит значение типа [[string|std::string]].

После вывода в консоль `"hello"` в качестве `firstArg` вновь вызывается `print()` для оставшихся аргументов. Этот вызов расширяется до
```c++
print<std::string> (s);
```

где:
* `firstArg` имеет значение `"world"`, так что тип `Т` представляет собой [[string|std::string]], а
* `args` является пустым вариативным аргументом шаблона, который не содержит значений.

Таким образом, после вывода в консоль `"world"` в качестве `firstArg` вновь вызывается `print()` — без аргументов, что приводит к вызову нешаблонной перегрузки `print()`, не выполняющей никаких действий.

## Перегрузка вариативных и невариативных шаблонов

Заметим, что приведенный выше пример можно также реализовать следующим образом:
```c++
#include <iostream>

template<typename T>
void print(T arg)
{
	std::cout << arg << '\n';   // Вывод переданного аргумента
}

template<typename T, typename... Types>
void print(T firstArg, Types... args)
{
	print(firstArg);            // Вызов print() для первого аргумента
	print(args...);             // Вызов print() для прочих аргументов
}
```

Если два шаблона функций отличаются только завершающим пакетом параметров, шаблон функции без такого пакета является предпочтительным. Правила разрешения перегрузки, применяемые в этом случае, более подробно рассматриваются в #разделе_В_3_1.

## Оператор sizeof. . .

С++11 вводит новую версию оператора `sizeof` для вариативных шаблонов: `sizeof. . .`. Он раскрывается до количества элементов, содержащихся в пакете параметров. Таким образом, исходный текст
```c++
template<typename Т, typename... Types>
void print(Т firstArg, Types... args)
{
	std::cout << sizeof...(Types)
				<< ' \n';           // Количество оставшихся типов
	std::cout << sizeof...(args)
				<< ' \n' ;          // Количество оставшихся аргументов

	...
}
```

дважды выводит в консоль количество аргументов, остающихся после первого аргумента функции `print()`. Как видите, `sizeof...` можно вызывать как для пакета параметров шаблона, так и для пакета параметров функции.

Это может навести нас на мысль, что для завершения рекурсии можно опустить вызов функции, когда больше нет необработанных аргументов:
```c++
template<typename Т, typename... Types>
void print(Т firstArg, Types... args)
{
	std::cout << firstArg << '\n';

	if(sizeof...(args) > 0)         // Ошибка при sizeof...(args)==0
	{
		print(args...);             // Функции print() без аргументов нет
	}
}
```

Однако этот подход не сработает, потому что в общем случае инстанцируются обе ветви инструкции `if`. Будет ли инстанцированный код нужен — выясняется во время выполнения, в то время как инстанцирование вызова происходит во время компиляции. По этой причине, если вы вызываете шаблон функции `print()` для одного (последнего) аргумента, то инструкция с вызовом `print (args...)` все равно инстанцируется — на этот раз без аргументов, и если такой функции `print()` без аргументов нет, мы получаем ошибку.

Заметим, однако, что, начиная с C++17, доступна инструкция `if` времени компиляции, которая позволяет достичь ожидаемых результатов с помощью немного иного синтаксиса. Этот вопрос будет рассмотрен в #разделе_8_5.
## Шаблоны с переменным числом аргументов C++11

Синтаксис `...` создает пакет параметров или расширяет его. Шаблон с хотя бы одним пакетом параметров называется вариативным шаблоном.
```c++
template <typename... T>
struct arity {
  constexpr static int value = sizeof...(T);
};

static_assert(arity<>::value == 0);
static_assert(arity<char, short, int>::value == 3);
```

## Пример: вычисление факториала  C++11

> **Задача:** Вычислить произведение чисел от 1 до N во время компилляции.

Решение этой задачи сводится к факту, что каждое последующее значение зависит от предыдущего: **P(N) = N * P(N-1)**. Исключение составляет только начальное значение, то есть для **N = 1 => P(N) = 1.** Шаблоны позволяют реализовать рекурсивное инстанциирование (определение) типов при помощи специализации шаблонов.

При помощи шаблонов задача решается следующим образом:
```c++
#include <iostream>

template<size_t value>
struct factorial {
	enum {
		RESULT = value * factorial<value - 1>::RESULT
	};
};

template<>
struct factorial<0> {
	enum { RESULT = 1 };
};

int main() {
	std::cout << "factorial = " << factorial<10>::RESULT;
	return 0;
}
```

Использование рекурсии в шаблонах ограничено, так как компилятор при специализации опускается до определенного уровня (зависит от настроек компилятора). Таким образом, произведение 100 первых чисел вычислить уже не удастся.

## Пример: числа Фиббоначчи C++11

> **Задача:** Вычислить N-й член последовательности Фиббоначчи во время компилляции.

Последовательность Фиббоначчи определяется рекурентной формулой `F(n) = F(n - 1) + F(n - 2), F(0) = 0, F(1) = 1`

Данное определение можно описать в шаблонах следующим образом:
```c++
#include <iostream>

template<size_t Value>
struct fibbonacci {
    enum {
        RESULT = fibbonacci<Value - 1>::RESULT + fibbonacci<Value - 2>::RESULT
    };
};

template<>
struct fibbonacci<0> { enum { RESULT = 0 }; };

template<>
struct fibbonacci<1> { enum { RESULT = 1 }; };

int main(){
    std::cout << fibbonacci<20>::RESULT << std::endl;
    return 0;
}
```

# Выражения свертки

Начиная с C++17 в языке имеется возможность вычисления результата с применением бинарного оператора ко всем аргументам пакета параметров (с необязательным начальным значением).

Например, следующая функция возвращает сумму всех переданных аргументов:
```c++
template<typename... Т>
auto foldSum(Т... s)
{
	return (... + s); // ((si + s2) + s3) ...
}
```

Если пакет параметров пуст, выражение обычно считается некорректным (за исключением того, что для оператора `&&` оно имеет значение `true`, для оператора `||` — значение `false`, и для оператора-запятой значение для пустого пакета параметров представляет собой `void()` ).

В табл. перечислены возможные выражения свертки.

| **Выражение свертки**   | **Вычисляет**                                    |
| ----------------------- | ------------------------------------------------ |
| ( ... op pack)          | ( ( ( pack1 op pack2 ) op pack3 ) ... op packN ) |
| ( pack op ... )         | ( pack1 op ( ... ( packN-1 op packN ) ) )        |
| ( init op ... op pack ) | ( ( ( init op pack1 ) op pack2 ) ... op packN)   |
| ( pack op ... op init ) | ( pack1 op ( . . . ( packN op init ) ) )         |

В выражениях свертки можно использовать почти все бинарные операторы (подробнее см. #раздел_12_4_6). Например, можно использовать выражение свертки для обхода бинарного дерева с использованием оператора `->*`:
```c++
// Определение структуры бинарного дерева:

struct Node
{
	int value;
	Node* left;
	Node* right;
	Node(int i = 0) : value(i), left(nullptr), right(nullptr)
	{ 	}
	
	...
};

auto left  = &Node::left;
auto right = &Node::right;

// Обход дерева с использованием выражения свертки:
template<typename Т, typename... ТР>
Node* traverse(T np, TP... paths)
{
	return (np ->* ... ->* paths); // пр ->* paths1 ->* paths2 ...
}

int main()
{
	// Инициализация структуры бинарного дерева:
	Node* root = new Node{0};
	root->left = new Node{1};
	root->left->right = new Node{2};
	
	// Обход бинарного дерева:
	Node* node = traverse(root, left, right);
}
```

Здесь конструкция
```c++
(nр ->* ... ->* paths)
```

использует выражение свертки для обхода вариативных элементов `paths` из `nр`.

С помощью такого выражения и с использованием инициализатора можно существенно упростить рассматривавшийся ранее вариативный шаблон для вывода на консоль всех аргументов:
```c++
template<typename... Types>
void print(Types const& ... args)
{
	(std::cout << ... << args) << '\n';
}
```

Заметим, однако, что в этом случае нет пробелов, разделяющих аргументы из пакета параметров. Чтобы добиться этого, нужен дополнительный шаблон класса, который гарантирует, что любой вывод любого аргумента сопровождается пробелом:
```c++
template<typename T>
class AddSpace
{
	private:
		T const& ref;   // Ссылка на аргумент, переданный в конструкторе

	public:
		AddSpace(Т const& r): ref(r)
		{   }
		
		friend std::ostream& operator<< (std::ostream& os, AddSpace<T> s)
		{
			return os << s.ref << ' '; // Вывод аргумента и пробела
		}
};

template<typename... Args>
void print(Args... args)
{
	(std::cout << ... << AddSpace(args)) << '\n';
}
```

Обратите внимание на то, что выражение `AddSpace(args)` использует [[Шаблоны классов#Вывод аргументов шаблона класса|вывод аргумента шаблона класса]], чтобы получить `AddSpace<Args>(args)` для того, чтобы для каждого аргумента был создан объект `AddSpace`, ссылающийся на переданный аргумент и добавляющий пробел при использовании в выражениях вывода.

Подробнее о выражениях свертки рассказывается в #разделе_12_4_6.


# Свертка параметров шаблона (Fold expressions)

Для начала несколько слов о том, что вообще такое свертка списка (также известна  как #fold, #reduce или #accumulate).  

Свертка – это функция, которая применяет заданную комбинирующую функцию к последовательным парам элементов в списке и возвращает результат. Простейшим примером может служить суммирование элементов списка при помощи свертки:  

Пример:
```c++
std::vector<int> lst = { 1, 3, 5, 7 };

int res = std::accumulate(lst.begin(), lst.end(), 0, [](int a, int b)  { 
	return a + b; 
});

std::cout << res << '\n'; // 16
```

Если комбинирующая функция применяется к первому элементу списка и результату рекурсивной обработки хвоста списка, то свертка называется **правоассоциативной.** В нашем примере получим:
```c++
1 + (3 + (5 + (7 + 0)))
```

Если комбинирующая функция применяется к результату рекурсивной обработки начала списка _(весь список без последнего элемента)_ и последнему элементу, то свертка называется **левоассоциативной**. В нашем примере получим:
```c++
(((0 + 1) + 3) + 5) + 7
```

Таким образом, тип свертки определяет порядок вычислений.  

В C++17 появилась поддержка свертки для списка параметров шаблонов. Она имеет следующий синтаксис:

| (pack op ...)      | Унарная правоассоциативная свертка  |
| ------------------ | ----------------------------------- |
| (… op pack)        | Унарная левоассоциативная свертка   |
| (pack op… op init) | Бинарная правоассоциативная свертка |
| (init op… op pack) | Бинарная левоассоциативная свертка  |
_op_ – один из следующих бинарных операторов:
```c++
+ - * / % ^ & | ~ = < > << >> += -= *= /= %=^= &= |= <<= >>= == != <= >= && || , .* ->*
```

_pack_ – выражение, содержащее нераскрытую группу параметров (parameter pack)  
_init_ – начальное значение  
  
Вот, например, шаблонная функция, принимающая переменное число параметров и вычисляющая их сумму:
```c++
// C++17
#include <iostream>

template<typename... Args>
auto Sum(Args... args)
{
	return (args + ...);
}

int main(){  
	std::cout << Sum(1, 2, 3, 4, 5) << '\n'; // 15  
	return 0;
}
```

Примечание: В данном примере функцию _Sum_ можно было бы объявить как [[constexpr|constexpr]].  

Если мы хотим указать начальное значение, то используем бинарную свертку:
```c++
// C++17
#include <iostream>

template<typename... Args>
auto Func(Args... args)
{  
	return (args + ... + 100);
}

int main(){  
	std::cout << Func(1, 2, 3, 4, 5) << '\n'; //115  
	return 0;
}
```

До C++17 чтобы реализовать подобную функцию, пришлось бы явно указывать правила для рекурсии:
```c++
// C++14
#include <iostream>

auto Sum(){  
	return 0;
}

template<typename Arg, typename... Args>
auto Sum(Arg first, Args... rest)
{  
	return first + Sum(rest...);
}

int main(){  
	std::cout << Sum(1, 2, 3, 4); // 10  
	return 0;
}
```

Отдельно хочется отметить оператор ',' (запятая), который раскроет **_pack_** в последовательность действий, перечисленных через запятую. Пример:
```c++
// C++17
#include <iostream>

template<typename T, typename... Args>
void PushToVector(std::vector<T>& v, Args&&... args)
{  
	(v.push_back(std::forward<Args>(args)), ...);  //Раскрывается в
					// последовательность выражений через запятую вида:  
					//v.push_back(std::forward<Args_1>(arg1)),  
					//v.push_back(std::forward<Args_2>(arg2)),  
					//....
}

int main(){  
	std::vector<int> vct;  
	PushToVector(vct, 1, 4, 5, 8);  
	
	return 0;
}
```

Таким образом, свертка сильно упрощает работу с **variadic templates**.

# Применения шаблонов с переменным количеством аргументов


















