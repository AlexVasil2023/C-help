
[[Вариативные шаблоны|Вариативные шаблоны]] 4
1. [[#Шаблоны с переменным количеством аргументов|Шаблоны с переменным количеством аргументов]] 4.1
	1. [[#Примеры вариативных шаблонов|Примеры вариативных шаблонов]] 4.1.1
	2. [[#Перегрузка вариативных и невариативных шаблонов|Перегрузка вариативных и невариативных шаблонов]] 4.1.2
	3. [[#Оператор sizeof. . .|Оператор sizeof. . .]] 4.1.3
	4. [[#Шаблоны с переменным числом аргументов C++11|Шаблоны с переменным числом аргументов C++11]]
	5. [[#Пример вычисление факториала C++11|Пример: вычисление факториала  C++11]]
	6. [[#Пример числа Фиббоначчи C++11|Пример: числа Фиббоначчи C++11]]
2. [[#Выражения свертки|Выражения свертки]] 4.2
3. [[#Свертка параметров шаблона (Fold expressions)|Свертка параметров шаблона (Fold expressions)]]
4. [[#Применения шаблонов с переменным количеством аргументов|Применения шаблонов с переменным количеством аргументов]] 4.3
5. [[#Вариативные шаблоны классов и вариативные выражения|Вариативные шаблоны классов и вариативные выражения]] 4.4
	1. [[#Вариативные выражения|Вариативные выражения]] 4.4.1
	2. [[#Вариативные индексы|Вариативные индексы]] 4.4.2
	3. [[#Вариативные шаблоны класса|Вариативные шаблоны класса]] 4.4.3
	4. [[#Вариативные правила вывода|Вариативные правила вывода]] 4.4.4
	5. [[#Вариативные базовые классы и using|Вариативные базовые классы и using]] 4.4.5
	6. 


# Вариативные шаблоны

Начиная с C++11, параметрам шаблонов можно сопоставлять переменное количество аргументов шаблона. Это дает возможность использовать шаблоны в местах, где требуется передать произвольное количество аргументов произвольных типов. Типичное приложение этой возможности — передача произвольного количества параметров различных типов в класс. Еще одно применение — предоставить обобщенный код для обработки любого количества параметров произвольных типов.

# Шаблоны с переменным количеством аргументов

Параметры шаблона могут быть определены таким образом, чтобы принимать неограниченное количество аргументов шаблона. Такие шаблоны называются вариативными (variadic templates).

## Примеры вариативных шаблонов

Например, можно использовать приведенный ниже код для вызова функции `print()` для переменного количества аргументов разных типов:
```c++
#include <iostream>

void print()
{
}

template<typename T, typename... Types>
void print(T firstArg, Types... args)
{
	std::cout << firstArg << '\n';  // Печать первого аргумента
	print(args...);                 // Вызов print() для остальных
									// аргументов
}
```

Если передаются один или несколько аргументов, используется шаблон функции, который, указывая отдельно первый аргумент, позволяет выводить в консоль первый аргумент, перед тем как рекурсивно применить `print()` для остальных аргументов. Остальные аргументы, представленные именем `args`, являются пакетом параметров функции (function parameter pack):
```c++
void print(T firstArg, Types... args)
```

`Types` указывается в пакете параметров шаблона (template parameter pack):
```c++
template<typename T, typename... Types>
```

Для завершения рекурсии предоставляется нешаблонная перегрузка `print()`, которая вызывается при пустом пакете параметров.

Например, вызов
```c++
std::string s("world");
print(7.5, "hello", s) ;
```

приведет к следующему выводу в консоль:
```
7.5
hello
world
```

Первый вызов расширяется до
```c++
print<double, char const*, std::string>(7.5, "hello", s);
```

где:
* `firstArg` имеет значение 7.5, так что тип `Т` представляет собой `double`, а
* `args` является вариативным аргументом шаблона, который содержит значения `"hello"` типа `char const*` и `"world"` типа [[string|std::string]].

После вывода в консоль `"hello"` в качестве `firstArg` вновь вызывается `print()` для оставшихся аргументов. Этот вызов расширяется до
```c++
print<char const*, std::string> ("hello", s);
```

где:
* `firstArg` имеет значение `"hello"`, так что тип `Т` представляет собой `char const*`, а
* `args` является вариативным аргументом шаблона, который содержит значение типа [[string|std::string]].

После вывода в консоль `"hello"` в качестве `firstArg` вновь вызывается `print()` для оставшихся аргументов. Этот вызов расширяется до
```c++
print<std::string> (s);
```

где:
* `firstArg` имеет значение `"world"`, так что тип `Т` представляет собой [[string|std::string]], а
* `args` является пустым вариативным аргументом шаблона, который не содержит значений.

Таким образом, после вывода в консоль `"world"` в качестве `firstArg` вновь вызывается `print()` — без аргументов, что приводит к вызову нешаблонной перегрузки `print()`, не выполняющей никаких действий.

## Перегрузка вариативных и невариативных шаблонов

Заметим, что приведенный выше пример можно также реализовать следующим образом:
```c++
#include <iostream>

template<typename T>
void print(T arg)
{
	std::cout << arg << '\n';   // Вывод переданного аргумента
}

template<typename T, typename... Types>
void print(T firstArg, Types... args)
{
	print(firstArg);            // Вызов print() для первого аргумента
	print(args...);             // Вызов print() для прочих аргументов
}
```

Если два шаблона функций отличаются только завершающим пакетом параметров, шаблон функции без такого пакета является предпочтительным. Правила разрешения перегрузки, применяемые в этом случае, более подробно рассматриваются в #разделе_В_3_1.

## Оператор sizeof. . .

С++11 вводит новую версию оператора `sizeof` для вариативных шаблонов: `sizeof. . .`. Он раскрывается до количества элементов, содержащихся в пакете параметров. Таким образом, исходный текст
```c++
template<typename Т, typename... Types>
void print(Т firstArg, Types... args)
{
	std::cout << sizeof...(Types)
				<< ' \n';           // Количество оставшихся типов
	std::cout << sizeof...(args)
				<< ' \n' ;          // Количество оставшихся аргументов

	...
}
```

дважды выводит в консоль количество аргументов, остающихся после первого аргумента функции `print()`. Как видите, `sizeof...` можно вызывать как для пакета параметров шаблона, так и для пакета параметров функции.

Это может навести нас на мысль, что для завершения рекурсии можно опустить вызов функции, когда больше нет необработанных аргументов:
```c++
template<typename Т, typename... Types>
void print(Т firstArg, Types... args)
{
	std::cout << firstArg << '\n';

	if(sizeof...(args) > 0)         // Ошибка при sizeof...(args)==0
	{
		print(args...);             // Функции print() без аргументов нет
	}
}
```

Однако этот подход не сработает, потому что в общем случае инстанцируются обе ветви инструкции `if`. Будет ли инстанцированный код нужен — выясняется во время выполнения, в то время как инстанцирование вызова происходит во время компиляции. По этой причине, если вы вызываете шаблон функции `print()` для одного (последнего) аргумента, то инструкция с вызовом `print (args...)` все равно инстанцируется — на этот раз без аргументов, и если такой функции `print()` без аргументов нет, мы получаем ошибку.

Заметим, однако, что, начиная с C++17, доступна инструкция `if` времени компиляции, которая позволяет достичь ожидаемых результатов с помощью немного иного синтаксиса. Этот вопрос будет рассмотрен в #разделе_8_5.
## Шаблоны с переменным числом аргументов C++11

Синтаксис `...` создает пакет параметров или расширяет его. Шаблон с хотя бы одним пакетом параметров называется вариативным шаблоном.
```c++
template <typename... T>
struct arity {
  constexpr static int value = sizeof...(T);
};

static_assert(arity<>::value == 0);
static_assert(arity<char, short, int>::value == 3);
```

## Пример: вычисление факториала  C++11

> **Задача:** Вычислить произведение чисел от 1 до N во время компилляции.

Решение этой задачи сводится к факту, что каждое последующее значение зависит от предыдущего: **P(N) = N * P(N-1)**. Исключение составляет только начальное значение, то есть для **N = 1 => P(N) = 1.** Шаблоны позволяют реализовать рекурсивное инстанциирование (определение) типов при помощи специализации шаблонов.

При помощи шаблонов задача решается следующим образом:
```c++
#include <iostream>

template<size_t value>
struct factorial {
	enum {
		RESULT = value * factorial<value - 1>::RESULT
	};
};

template<>
struct factorial<0> {
	enum { RESULT = 1 };
};

int main() {
	std::cout << "factorial = " << factorial<10>::RESULT;
	return 0;
}
```

Использование рекурсии в шаблонах ограничено, так как компилятор при специализации опускается до определенного уровня (зависит от настроек компилятора). Таким образом, произведение 100 первых чисел вычислить уже не удастся.

## Пример: числа Фиббоначчи C++11

> **Задача:** Вычислить N-й член последовательности Фиббоначчи во время компилляции.

Последовательность Фиббоначчи определяется рекурентной формулой `F(n) = F(n - 1) + F(n - 2), F(0) = 0, F(1) = 1`

Данное определение можно описать в шаблонах следующим образом:
```c++
#include <iostream>

template<size_t Value>
struct fibbonacci {
    enum {
        RESULT = fibbonacci<Value - 1>::RESULT + fibbonacci<Value - 2>::RESULT
    };
};

template<>
struct fibbonacci<0> { enum { RESULT = 0 }; };

template<>
struct fibbonacci<1> { enum { RESULT = 1 }; };

int main(){
    std::cout << fibbonacci<20>::RESULT << std::endl;
    return 0;
}
```

# Выражения свертки

Начиная с C++17 в языке имеется возможность вычисления результата с применением бинарного оператора ко всем аргументам пакета параметров (с необязательным начальным значением).

Например, следующая функция возвращает сумму всех переданных аргументов:
```c++
template<typename... Т>
auto foldSum(Т... s)
{
	return (... + s); // ((si + s2) + s3) ...
}
```

Если пакет параметров пуст, выражение обычно считается некорректным (за исключением того, что для оператора `&&` оно имеет значение `true`, для оператора `||` — значение `false`, и для оператора-запятой значение для пустого пакета параметров представляет собой `void()` ).

В табл. перечислены возможные выражения свертки.

| **Выражение свертки**   | **Вычисляет**                                    |
| ----------------------- | ------------------------------------------------ |
| ( ... op pack)          | ( ( ( pack1 op pack2 ) op pack3 ) ... op packN ) |
| ( pack op ... )         | ( pack1 op ( ... ( packN-1 op packN ) ) )        |
| ( init op ... op pack ) | ( ( ( init op pack1 ) op pack2 ) ... op packN)   |
| ( pack op ... op init ) | ( pack1 op ( . . . ( packN op init ) ) )         |

В выражениях свертки можно использовать почти все бинарные операторы (подробнее см. #раздел_12_4_6). Например, можно использовать выражение свертки для обхода бинарного дерева с использованием оператора `->*`:
```c++
// Определение структуры бинарного дерева:

struct Node
{
	int value;
	Node* left;
	Node* right;
	Node(int i = 0) : value(i), left(nullptr), right(nullptr)
	{ 	}
	
	...
};

auto left  = &Node::left;
auto right = &Node::right;

// Обход дерева с использованием выражения свертки:
template<typename Т, typename... ТР>
Node* traverse(T np, TP... paths)
{
	return (np ->* ... ->* paths); // пр ->* paths1 ->* paths2 ...
}

int main()
{
	// Инициализация структуры бинарного дерева:
	Node* root = new Node{0};
	root->left = new Node{1};
	root->left->right = new Node{2};
	
	// Обход бинарного дерева:
	Node* node = traverse(root, left, right);
}
```

Здесь конструкция
```c++
(nр ->* ... ->* paths)
```

использует выражение свертки для обхода вариативных элементов `paths` из `nр`.

С помощью такого выражения и с использованием инициализатора можно существенно упростить рассматривавшийся ранее вариативный шаблон для вывода на консоль всех аргументов:
```c++
template<typename... Types>
void print(Types const& ... args)
{
	(std::cout << ... << args) << '\n';
}
```

Заметим, однако, что в этом случае нет пробелов, разделяющих аргументы из пакета параметров. Чтобы добиться этого, нужен дополнительный шаблон класса, который гарантирует, что любой вывод любого аргумента сопровождается пробелом:
```c++
template<typename T>
class AddSpace
{
	private:
		T const& ref;   // Ссылка на аргумент, переданный в конструкторе

	public:
		AddSpace(Т const& r): ref(r)
		{   }
		
		friend std::ostream& operator<< (std::ostream& os, AddSpace<T> s)
		{
			return os << s.ref << ' '; // Вывод аргумента и пробела
		}
};

template<typename... Args>
void print(Args... args)
{
	(std::cout << ... << AddSpace(args)) << '\n';
}
```

Обратите внимание на то, что выражение `AddSpace(args)` использует [[Шаблоны классов#Вывод аргументов шаблона класса|вывод аргумента шаблона класса]], чтобы получить `AddSpace<Args>(args)` для того, чтобы для каждого аргумента был создан объект `AddSpace`, ссылающийся на переданный аргумент и добавляющий пробел при использовании в выражениях вывода.

Подробнее о выражениях свертки рассказывается в #разделе_12_4_6.


# Свертка параметров шаблона (Fold expressions)

Для начала несколько слов о том, что вообще такое свертка списка (также известна  как #fold, #reduce или #accumulate).  

Свертка – это функция, которая применяет заданную комбинирующую функцию к последовательным парам элементов в списке и возвращает результат. Простейшим примером может служить суммирование элементов списка при помощи свертки:  

Пример:
```c++
std::vector<int> lst = { 1, 3, 5, 7 };

int res = std::accumulate(lst.begin(), lst.end(), 0, [](int a, int b)  { 
	return a + b; 
});

std::cout << res << '\n'; // 16
```

Если комбинирующая функция применяется к первому элементу списка и результату рекурсивной обработки хвоста списка, то свертка называется **правоассоциативной.** В нашем примере получим:
```c++
1 + (3 + (5 + (7 + 0)))
```

Если комбинирующая функция применяется к результату рекурсивной обработки начала списка _(весь список без последнего элемента)_ и последнему элементу, то свертка называется **левоассоциативной**. В нашем примере получим:
```c++
(((0 + 1) + 3) + 5) + 7
```

Таким образом, тип свертки определяет порядок вычислений.  

В C++17 появилась поддержка свертки для списка параметров шаблонов. Она имеет следующий синтаксис:

| (pack op ...)      | Унарная правоассоциативная свертка  |
| ------------------ | ----------------------------------- |
| (… op pack)        | Унарная левоассоциативная свертка   |
| (pack op… op init) | Бинарная правоассоциативная свертка |
| (init op… op pack) | Бинарная левоассоциативная свертка  |
_op_ – один из следующих бинарных операторов:
```c++
+ - * / % ^ & | ~ = < > << >> += -= *= /= %=^= &= |= <<= >>= == != <= >= && || , .* ->*
```

_pack_ – выражение, содержащее нераскрытую группу параметров (parameter pack)  
_init_ – начальное значение  
  
Вот, например, шаблонная функция, принимающая переменное число параметров и вычисляющая их сумму:
```c++
// C++17
#include <iostream>

template<typename... Args>
auto Sum(Args... args)
{
	return (args + ...);
}

int main(){  
	std::cout << Sum(1, 2, 3, 4, 5) << '\n'; // 15  
	return 0;
}
```

Примечание: В данном примере функцию _Sum_ можно было бы объявить как [[constexpr|constexpr]].  

Если мы хотим указать начальное значение, то используем бинарную свертку:
```c++
// C++17
#include <iostream>

template<typename... Args>
auto Func(Args... args)
{  
	return (args + ... + 100);
}

int main(){  
	std::cout << Func(1, 2, 3, 4, 5) << '\n'; //115  
	return 0;
}
```

До C++17 чтобы реализовать подобную функцию, пришлось бы явно указывать правила для рекурсии:
```c++
// C++14
#include <iostream>

auto Sum(){  
	return 0;
}

template<typename Arg, typename... Args>
auto Sum(Arg first, Args... rest)
{  
	return first + Sum(rest...);
}

int main(){  
	std::cout << Sum(1, 2, 3, 4); // 10  
	return 0;
}
```

Отдельно хочется отметить оператор ',' (запятая), который раскроет **_pack_** в последовательность действий, перечисленных через запятую. Пример:
```c++
// C++17
#include <iostream>

template<typename T, typename... Args>
void PushToVector(std::vector<T>& v, Args&&... args)
{  
	(v.push_back(std::forward<Args>(args)), ...);  //Раскрывается в
					// последовательность выражений через запятую вида:  
					//v.push_back(std::forward<Args_1>(arg1)),  
					//v.push_back(std::forward<Args_2>(arg2)),  
					//....
}

int main(){  
	std::vector<int> vct;  
	PushToVector(vct, 1, 4, 5, 8);  
	
	return 0;
}
```

Таким образом, свертка сильно упрощает работу с **variadic templates**.

# Применения шаблонов с переменным количеством аргументов

Шаблоны с переменным количеством аргументов играют важную роль при реализации обобщенных библиотек, в частности, стандартной библиотеки C++.

Одно из типичных применений — передача переменного количества аргументов произвольного типа. Например, мы используем эту возможность в следующих ситуациях.

> Передача аргументов конструктору нового объекта в динамической памяти, которым владеет интеллектуальный указатель:
```c++
// Создание интеллектуального указателя shared_ptr для
// complex<float>, инициализированного значениями 4.2 и 7.7:

auto sp = std::make_shared<std::complex<float>>(4.2, 7.7);
```

> Передача аргументов в поток выполнения, запускаемый библиотекой:
```c++
std::thread t(foo, 42, "hello");    // Вызов foo(42,"hello")
									// в отдельном потоке
```

> Передача аргументов в конструктор нового элемента, добавляемого к вектору:
```c++
std::vector<Customer> v;
...

// Добавление Customer, инициализированного тремя аргументами:
v.emplace_back("Tim","Jovi",1962) ;
```

Обычно аргументы передаются с семантикой перемещения с использованием “прямой передачи" (“perfect forward”) (см. #раздел_6_1), так что соответствующие объявления имеют примерно следующий вид:
```c++
namespace std
{
	template<typename Т, typename... Args> shared_ptr<T>
	make_shared(Args&& ... args);

	class thread
	{
		public:
			template<typename F, typename... Args>
			explicit thread(F&& f, Args&& ... args);

		...
	};
	
	template<typename T, typename Allocator = allocator<T>>
	class vector
	{
		public:
			template<typename... Args>
			reference emplace_back(Args&&... args);
	
		...
	};
)
```

Обратите внимание на то, что к вариативным параметрам шаблонов функций применимы те же правила, что и к обычным параметрам. Например, при передаче по значению аргументы копируются и низводятся (например, массивы становятся указателями), в то время как при передаче по ссылке параметры ссылаются на исходные параметры и не низводятся:
```c++
// args копируются с низведенными типами:
template<typename... Args> void foo(Args... args);

// args представляют собой ссылки без низведения на переданные объекты:
template<typename... Args> void bar(Args const& ... args);
```

# Вариативные шаблоны классов и вариативные выражения

Помимо приведенных выше примеров пакеты параметров могут появляться в дополнительных местах, включая, например, выражения, шаблоны классов, объявления `using` и даже правила вывода. Полный список приведен в #разделе_12_4_2.

## Вариативные выражения

Вы можете сделать больше, чем просто передать все параметры. Вы можете выполнить с ними вычисления, т.е. вычисления со всеми параметрами в пакете параметров.

Например, следующая функция удваивает каждый параметр из пакета параметров `args` и передает каждый удвоенный аргумент функции `print()`:
```c++
template<typename... Т>
void printDoubled(Т const& ... args)
{
	print(args + args...);
}
```

Если, например, вы вызовете
```c++
printDoubled(7.5, std::string("hello"), std::complex<float>(4,2));
```

то результатом будет следующее (за исключением побочных действий конструкторов):
```c++
print(7.5 + 7.5,
			std::string("hello") + std::string("hello"),
			std::complex<float>(4, 2) + std::complex<float>(4, 2));
```

Если вы хотите просто добавить 1 к каждому аргументу, учтите, что точки многоточия не могут следовать за числовым литералом непосредственно:
```c++
template<typename... Т>
void addOne(T const& ... args)
{
	print(args + 1...);   // Ошибка: 1... является литералом co слишком
						  // большим количеством десятичных точек
	
	print(args + 1 ...);  // ОК

	print((args + 1)...); // ОК
}
```

Выражения времени компиляции могут включать пакеты параметров шаблонов таким же образом. Например, следующий шаблон функции возвращает информацию о том, одинаковы ли типы всех переданных аргументов:
```c++
template<typename T1, typename... TN>
constexpr bool isHomogeneous(T1, TN...)
{
	return (std::is_same<T1, TN>::value && ...);    // Начиная с C++17
);
```

Здесь мы видим применение [[#Выражения свертки|выражений свертки]]. Выражение
```c++
isHomogeneous(43, -1, "hello")
```

разворачивается в
```c++
std::is_same<int,int>::value && std::is_same<int,char const* >::value
```

и дает в качестве результата `false`, в то время как
```c++
isHomogeneous("hello", " ", "world", "!")
```

дает `true`, поскольку тип для всех переданных аргументов вычисляется как `char const*` (обратите внимание на то, что, поскольку аргументы передаются по значению, выполняется низведение их типов).

## Вариативные индексы

В качестве еще одного примера приведенная далее функция использует вариативный список индексов для доступа к соответствующим элементам аргумента, переданного первым:
```c++
template<typename С, typename... Idx>
void printElems{C const& coll, Idx... idx)
{
	print(coll[idx]...);
}
```

Следовательно, при вызове
```c++
std::vector<std::string> coll = {"good", "times", "say", "bye"};

printElems(coll, 2, 0, 3);
```

результатом окажется вызов
```c++
print(coll[2], coll[0], coll[3]);
```

Можно также объявить пакет параметров, не являющихся типами. Например, объявление
```c++
template<std::size_t... Idx, typename C>
void printIdx(C const& coll)
{
	print(coll[Idx]...);
}
```

позволяет выполнить вызов
```c++
std::vector<std::string> coll = {"good", "times", "say", "bye"};

printldx<2, 0, 3>(coll);
```

действие которого совпадает с таковым для предыдущего примера.

## Вариативные шаблоны класса

Вариативные шаблоны могут быть и шаблонами классов. Важным примером является класс, в котором произвольное количество параметров шаблона определяет типы соответствующих членов:
```c++
template<typename... Elements>
class Tuple;

Tuple<int, std::string, char> t;    // t может хранить int, string и char
```

Этот вопрос будет рассматриваться в #главе_25, “Кортежи”.

Еще одним примером может служить указание возможных типов объектов:
```c++
template<typename... Types>
class Variant;

Variant<int, std::string, char> v;  // v может хранить int,
									// string или char
```

Этот вопрос будет рассматриваться в #главе_26, “Контролируемые объединения”.

Можно также определить класс, который представляет собой тип, который можно рассматривать как список индексов:
```c++
// Тип для произвольного количества индексов:
template<std::size_t...>
struct Indices
{    
};
```

Этот класс может быть использован для определения функции, которая вызывает `print()` для элементов [[Array|std::array]] или [[tuple|std::tuple]] с использованием доступа времени компиляции с помощью `get<>()` для указанных индексов:
```c++
template<typename Т, std::size_t... Idx>
void printByldx(T t, Indices<idx...>)
{
	print(std::get<Idx>(t)...);
}
```

Этот шаблон может быть использован так:
```c++
std::array<std::string, 5> arr = {"Hello", "my", "new", "!", "World"};
printByldx(arr, Indices<0, 4, 3>());
```

или так:
```c++
auto t = std::make_tuple(12, "monkeys", 2.0);
printByldx(t, Indices<O, 1, 2>());
```

Это первый шаг на пути к метапрограммированию, которое будет рассматриваться в #разделе_8_1 и в #главе_23, “Метапрограммирование”.

## Вариативные правила вывода

Вариативными могут быть даже [[Шаблоны классов#Вывод аргументов шаблона класса|правила вывода]]. Например, стандартная библиотека C++ определяет следующее правило вывода для [[Array|std::array]]:
```c++
namespace std
{
	template<typename T, typename... U> array(T, U...)
	-> array < enable_if_t < (is_same_v<T, U>&& ...), T >,
	(1 + sizeof...(U)) >;
}
```

Инициализация наподобие
```c++
std::array a{42, 45, 77};
```

в правиле выводит `T` как тип элемента, а различные типы `U...` — как типы последующих элементов. Общее количество элементов, таким образом, равно `1 + sizeof...(U)`:
```c++
std::array<int, 3> а{42,45,77};
```

Выражение [[enable_if|std::enable_if<>]] для первого параметра `array` представляет собой [[Вариативные шаблоны#Вариативные выражения|выражение свертки, которое (как показано в `isHomogeneous()`]] раскрывается до:
```c++
is_same_v<T, U1> && is_same_v<T, U2> && is_same__v<T, U3> ...
```

Если результат не равен `true` (т.е. не все типы элементов одинаковы), правило вывода отвергается и весь вывод оказывается неудачным. Таким образом стандартная библиотека гарантирует, что для успешного вывода все элементы должны быть одного и того же типа.

## Вариативные базовые классы и using














































