
[[Вариативные шаблоны|Вариативные шаблоны]] 4
1. [[#Шаблоны с переменным количеством аргументов|Шаблоны с переменным количеством аргументов]] 4.1
	1. [[#Примеры вариативных шаблонов|Примеры вариативных шаблонов]] 4.1.1
	2. [[#Перегрузка вариативных и невариативных шаблонов|Перегрузка вариативных и невариативных шаблонов]] 4.1.2
	3. [[#Оператор sizeof. . .|Оператор sizeof. . .]] 4.1.3
	4. [[#Шаблоны с переменным числом аргументов C++11|Шаблоны с переменным числом аргументов C++11]]
	5. [[#Пример вычисление факториала C++11|Пример: вычисление факториала  C++11]]
	6. [[#Пример числа Фиббоначчи C++11|Пример: числа Фиббоначчи C++11]]
2. [[#Выражения свертки|Выражения свертки]] 4.2


# Вариативные шаблоны

Начиная с C++11, параметрам шаблонов можно сопоставлять переменное количество аргументов шаблона. Это дает возможность использовать шаблоны в местах, где требуется передать произвольное количество аргументов произвольных типов. Типичное приложение этой возможности — передача произвольного количества параметров различных типов в класс. Еще одно применение — предоставить обобщенный код для обработки любого количества параметров произвольных типов.

# Шаблоны с переменным количеством аргументов

Параметры шаблона могут быть определены таким образом, чтобы принимать неограниченное количество аргументов шаблона. Такие шаблоны называются вариативными (variadic templates).

## Примеры вариативных шаблонов

Например, можно использовать приведенный ниже код для вызова функции `print()` для переменного количества аргументов разных типов:
```c++
#include <iostream>

void print()
{
}

template<typename T, typename... Types>
void print(T firstArg, Types... args)
{
	std::cout << firstArg << '\n';  // Печать первого аргумента
	print(args...);                 // Вызов print() для остальных
									// аргументов
}
```

Если передаются один или несколько аргументов, используется шаблон функции, который, указывая отдельно первый аргумент, позволяет выводить в консоль первый аргумент, перед тем как рекурсивно применить `print()` для остальных аргументов. Остальные аргументы, представленные именем `args`, являются пакетом параметров функции (function parameter pack):
```c++
void print(T firstArg, Types... args)
```

`Types` указывается в пакете параметров шаблона (template parameter pack):
```c++
template<typename T, typename... Types>
```

Для завершения рекурсии предоставляется нешаблонная перегрузка `print()`, которая вызывается при пустом пакете параметров.

Например, вызов
```c++
std::string s("world");
print(7.5, "hello", s) ;
```

приведет к следующему выводу в консоль:
```
7.5
hello
world
```

Первый вызов расширяется до
```c++
print<double, char const*, std::string>(7.5, "hello", s);
```

где:
* `firstArg` имеет значение 7.5, так что тип `Т` представляет собой `double`, а
* `args` является вариативным аргументом шаблона, который содержит значения `"hello"` типа `char const*` и `"world"` типа [[string|std::string]].

После вывода в консоль `"hello"` в качестве `firstArg` вновь вызывается `print()` для оставшихся аргументов. Этот вызов расширяется до
```c++
print<char const*, std::string> ("hello", s);
```

где:
* `firstArg` имеет значение `"hello"`, так что тип `Т` представляет собой `char const*`, а
* `args` является вариативным аргументом шаблона, который содержит значение типа [[string|std::string]].

После вывода в консоль `"hello"` в качестве `firstArg` вновь вызывается `print()` для оставшихся аргументов. Этот вызов расширяется до
```c++
print<std::string> (s);
```

где:
* `firstArg` имеет значение `"world"`, так что тип `Т` представляет собой [[string|std::string]], а
* `args` является пустым вариативным аргументом шаблона, который не содержит значений.

Таким образом, после вывода в консоль `"world"` в качестве `firstArg` вновь вызывается `print()` — без аргументов, что приводит к вызову нешаблонной перегрузки `print()`, не выполняющей никаких действий.

## Перегрузка вариативных и невариативных шаблонов

Заметим, что приведенный выше пример можно также реализовать следующим образом:
```c++
#include <iostream>

template<typename T>
void print(T arg)
{
	std::cout << arg << '\n';   // Вывод переданного аргумента
}

template<typename T, typename... Types>
void print(T firstArg, Types... args)
{
	print(firstArg);            // Вызов print() для первого аргумента
	print(args...);             // Вызов print() для прочих аргументов
}
```

Если два шаблона функций отличаются только завершающим пакетом параметров, шаблон функции без такого пакета является предпочтительным. Правила разрешения перегрузки, применяемые в этом случае, более подробно рассматриваются в #разделе_В_3_1.

## Оператор sizeof. . .

С++11 вводит новую версию оператора `sizeof` для вариативных шаблонов: `sizeof. . .`. Он раскрывается до количества элементов, содержащихся в пакете параметров. Таким образом, исходный текст
```c++
template<typename Т, typename... Types>
void print(Т firstArg, Types... args)
{
	std::cout << sizeof...(Types)
				<< ' \n';           // Количество оставшихся типов
	std::cout << sizeof...(args)
				<< ' \n' ;          // Количество оставшихся аргументов

	...
}
```

дважды выводит в консоль количество аргументов, остающихся после первого аргумента функции `print()`. Как видите, `sizeof...` можно вызывать как для пакета параметров шаблона, так и для пакета параметров функции.

Это может навести нас на мысль, что для завершения рекурсии можно опустить вызов функции, когда больше нет необработанных аргументов:
```c++
template<typename Т, typename... Types>
void print(Т firstArg, Types... args)
{
	std::cout << firstArg << '\n';

	if(sizeof...(args) > 0)         // Ошибка при sizeof...(args)==0
	{
		print(args...);             // Функции print() без аргументов нет
	}
}
```

Однако этот подход не сработает, потому что в общем случае инстанцируются обе ветви инструкции `if`. Будет ли инстанцированный код нужен — выясняется во время выполнения, в то время как инстанцирование вызова происходит во время компиляции. По этой причине, если вы вызываете шаблон функции `print()` для одного (последнего) аргумента, то инструкция с вызовом `print (args...)` все равно инстанцируется — на этот раз без аргументов, и если такой функции `print()` без аргументов нет, мы получаем ошибку.

Заметим, однако, что, начиная с C++17, доступна инструкция `if` времени компиляции, которая позволяет достичь ожидаемых результатов с помощью немного иного синтаксиса. Этот вопрос будет рассмотрен в #разделе_8_5.
## Шаблоны с переменным числом аргументов C++11

Синтаксис `...` создает пакет параметров или расширяет его. Шаблон с хотя бы одним пакетом параметров называется вариативным шаблоном.
```c++
template <typename... T>
struct arity {
  constexpr static int value = sizeof...(T);
};

static_assert(arity<>::value == 0);
static_assert(arity<char, short, int>::value == 3);
```

## Пример: вычисление факториала  C++11

> **Задача:** Вычислить произведение чисел от 1 до N во время компилляции.

Решение этой задачи сводится к факту, что каждое последующее значение зависит от предыдущего: **P(N) = N * P(N-1)**. Исключение составляет только начальное значение, то есть для **N = 1 => P(N) = 1.** Шаблоны позволяют реализовать рекурсивное инстанциирование (определение) типов при помощи специализации шаблонов.

При помощи шаблонов задача решается следующим образом:
```c++
#include <iostream>

template<size_t value>
struct factorial {
	enum {
		RESULT = value * factorial<value - 1>::RESULT
	};
};

template<>
struct factorial<0> {
	enum { RESULT = 1 };
};

int main() {
	std::cout << "factorial = " << factorial<10>::RESULT;
	return 0;
}
```

Использование рекурсии в шаблонах ограничено, так как компилятор при специализации опускается до определенного уровня (зависит от настроек компилятора). Таким образом, произведение 100 первых чисел вычислить уже не удастся.

## Пример: числа Фиббоначчи C++11

> **Задача:** Вычислить N-й член последовательности Фиббоначчи во время компилляции.

Последовательность Фиббоначчи определяется рекурентной формулой `F(n) = F(n - 1) + F(n - 2), F(0) = 0, F(1) = 1`

Данное определение можно описать в шаблонах следующим образом:
```c++
#include <iostream>

template<size_t Value>
struct fibbonacci {
    enum {
        RESULT = fibbonacci<Value - 1>::RESULT + fibbonacci<Value - 2>::RESULT
    };
};

template<>
struct fibbonacci<0> { enum { RESULT = 0 }; };

template<>
struct fibbonacci<1> { enum { RESULT = 1 }; };

int main(){
    std::cout << fibbonacci<20>::RESULT << std::endl;
    return 0;
}
```

# Выражения свертки

Начиная с C++17 в языке имеется возможность вычисления результата с применением бинарного оператора ко всем аргументам пакета параметров (с необязательным начальным значением).

Например, следующая функция возвращает сумму всех переданных аргументов:
```c++
template<typename... Т>
auto foldSum(Т... s)
{
	return (... + s); // ((si + s2) + s3) ...
}
```
































