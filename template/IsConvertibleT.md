
[[#IsConvertibleT|IsConvertibleT]] 19.5


# IsConvertibleT

Детали имеют значение. Поэтому общий подход к свойствам на основе [[SFINAE|SFINAE]] на практике может оказаться существенно более сложным. Проиллюстрируем это путем определения свойства, которое может выяснить, является ли данный тип преобразуемым в другой тип — например, если мы ожидаем определенный базовый класс или один из его производных классов. Свойство `IsConvertibleT` сообщает, можно ли преобразовать переданный первый тип в переданный второй тип:
```c++
#include <type_traits> // Для true_type и false_type
#include <utility>     // Для declval

template<typename FROM, typename T0>
struct IsConvertibleHelper
{
	private:
		// test() пытается вызвать вспомогательную функцию aux(TO)
		// для FROM, переданного как F:
		
		static void aux(TO);
		template<typename F, typename,
				typename = decltype(aux(std::declvalCF>()))>
		static std::true_type test(void*);

		// Резервная функция test():
		template<typename, typename>
		static std::false_type test(...);
		
	public:
		using Type = decltype(test<FROM>(nullptr));
};

template<typename FROM, typename T0>
struct IsConvertibleT : IsConvertibleHelper<FROM, TO>::Type
{
};

template<typename FROM, typename T0>
using IsConvertible = typename IsConvertibleT<FROM, T0>::Type;

template<typename FROM, typename T0>
constexpr bool isconvertible = IsConvertibleT<FROM, TO>::value;
```

Здесь мы используем [[SFINAE#Принцип SFINAE и перегрузки функций|подход с перегрузкой функций]]. То есть внутри вспомогательного класса мы объявляем два перегруженных шаблона функций с именем `test()` и с различными возвращаемыми типами и объявляем член `Туре` в качестве базового класса результирующего свойства:
```c++
template<...> static std::true_type testfvoid*);
template<...> static std::false_type test(...);

...

using Type = decltype(test<FROM>(nullptr));

...

template<typename FROM, typename T0>
struct IsConvertibleT : IsConvertibleHelper<FROM, TO>::Type
{
};
```

Как обычно, первая перегрузка `test()` предназначена для того, чтобы быть соответствующей аргументам только в том случае, если запрашиваемая проверка прошла успешно, в то время как вторая перегрузка является резервной. Таким образом, цель заключается в том, чтобы сделать первую перегрузку `test()` корректной тогда и только тогда, когда тип `FROM` может быть преобразован в тип `ТО`. Для достижения этой цели мы вновь даем первому объявлению `test` фиктивный (безымянный) аргумент шаблона, инициализируемый конструкцией, которая является корректной тогда и только тогда, когда преобразование является допустимым. Этот параметр шаблона не может быть выведен, и мы не будем предоставлять для него явный аргумент шаблона. Таким образом, будет выполнена соответствующая подстановка, и, если эта подстановка окажется некорректной, данное объявление `test()` будут проигнорировано.

Еще раз обратите внимание, что следующий код неработоспособен:
```c++
static void aux(ТО);

template<typename = decltype(aux(std::declval<FROM>()))>
static char test(void*);
```

Здесь `FROM` и `TO` полностью определены при синтаксическом анализе этого шаблона функции-члена, а потому пара типов, для которых это преобразование не является допустимым (например, `double*` и `int*`), приводит к немедленному выводу сообщения об ошибке, до любого вызова `test()` (а следовательно, вне любого контекста [[SFINAE|SFINAE]]).

По этой причине мы вводим `F` как определенный параметр шаблона функции-члена
```c++
static void aux(ТО);

template<typename F, typename = decltype(aux(std::declval<F>()))>
static char test(void*);
```

и предоставляем тип `FROM` как явный аргумент шаблона в вызове `test()` в инициализации `value`:
```c++
static constexpr bool value
		= isSame<decltype(test<FR0M>(nullptr)), char>;
```

Обратите внимание на то, как для генерации значения без вызова какого бы то ни было конструктора используется шаблон [[declval#std declval|std::declval]], [[Реализация свойств типов#Свойства типов результатов|представленный тут]]. Если это значение преобразуемо в `ТО`, вызов `аuх()` является допустимым, и это объявление `test()` соответствует аргументам. В противном случае происходит сбой [[SFINAE|SFINAE]], и соответствовать аргументам будет только резервное объявление.

В результате мы можем использовать это свойство следующим образом:
```c++
IsConvertibleT<int, int>::value                   // Дает true
IsConvertibleT<int, std::string>::value           // Дает false
IsConvertibleT<char const*, std: string>::value   // Дает true
IsConvertibleT<std::string, char const*>::value   // Дает false
```

***===Обработка особых случаев===***

Есть три случая, которые `IsConvertibleT` все еще обрабатывает некорректно.
>
> 1. Преобразование в тип массива всегда должно давать значение `false`, но в нашем коде параметр типа `ТО` в объявлении `aux()` будет просто низведен к типу указателя, и поэтому мы получим результат `true` для некоторых типов FROM.
> 2. Преобразования в типы функций всегда должны давать `false`, но, как и в случае массивов, наша реализация просто рассматривает их как низведенные типы.
> 3. Преобразование в (квалифицированные как [[const|const]]/[[volatile|volatile]]) типы `void` должно давать значение `true`. К сожалению, наша реализация даже не в состоянии выполнить успешное инстанцирование, когда тип `ТО` представляет собой тип `void`, потому что параметры не могут иметь тип `void` (а `aux()` быть объявленной с таким параметром).

Для корректной обработки всех этих случаев нам понадобятся дополнительные частичные специализации. Однако добавление такой специализации для каждой возможной комбинации квалификаторов [[const|const]] и [[volatile|volatile]] быстро становится слишком громоздким. Вместо этого мы можем добавить дополнительный параметр шаблона к шаблону нашего вспомогательного класса следующим образом:
```c++
template<typename FROM, typename TO, bool = IsVoidT<TO>::value
											|| IsArrayT<TO>::value
											|| IsFunctionT<TO>::value>
struct IsConvertibleHelper
{
	using Type = std::integral_constant<bool,
										IsVoidT<TO>::value
										&& IsVoidT<FROM>::value>;
};

template<typename FROM, typename T0>
struct IsConvertibleHelper<FROM, TO, false>
{
	... // Предыдущая реализация IsConvertibleHelper
};
```

Дополнительный логический параметр шаблона гарантирует, что для всех указанных особых случаев используется реализация основного вспомогательного свойства. Он дает `false_type`, если мы преобразуем типы в массивы или функции (потому что тогда `IsVoidT<TO>` имеет значение `false`), либо если `FROM` представляет собой `void`, а `ТО` — нет, но для двух типов `void` он будет давать `true_type`. Все остальные случаи дают аргумент `false` в качестве третьего параметра, а потому выбирается частичная специализация, которая соответствует уже рассмотренной ранее реализации.

Реализация `IsArrayT` обсуждается в #разделе_19_8_2, а реализация `IsFunctionT` — в #разделе_19_8_3.

Стандартная библиотека C++ предоставляет соответствующее свойство типа `std::is_convertible<>`, которое описывается в [[Стандартные утилиты для работы с типами#Взаимоотношения между типами|Взаимоотношения между типами]].

























