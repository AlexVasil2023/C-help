
[[#Шаблоны выражений|Шаблоны выражений]] 27
1. [[#Временные объекты и раздельные циклы|Временные объекты и раздельные циклы]] 27.1
2. [[#Программирование выражений в аргументах шаблонов|Программирование выражений в аргументах шаблонов]] 27.2
	1. [[#Операнды шаблонов выражений|Операнды шаблонов выражений]] 27.2.1
	2. [[#Тип Array|Тип Array]] 27.2.2
	3. [[#Операторы|Операторы]] 27.2.3





# Шаблоны выражений

В этой главе описывается метод шаблонного программирования, известный под названием шаблоны выражений (`expression templates`). Впервые этот метод возник при работе с классами числовых массивов, и именно в таком контексте он рассматривается в данной главе.

Класс числовых массивов поддерживает выполнение числовых операций с массивом как с целостным объектом. Например, к двум массивам можно применить операцию сложения; в результате ее выполнения получим массив, каждый элемент которого будет суммой соответствующих элементов исходных массивов. Аналогично массив можно умножить на скаляр. Это означает, что на скаляр умножается каждый элемент исходного массива. Возникает естественное желание реализовать для массивов операторные обозначения, так знакомые нам по работе со встроенными скалярными типами:
```c++
Array<double> х(1000), у(1000);
...
х=1.2*х + х*у;
```

Для серьезных высокопроизводительных вычислительных комплексов важно, чтобы выражения такого рода вычислялись настолько эффективно, насколько можно ожидать от платформы, на которой выполняется этот код. Добиться того, чтобы такие вычисления можно было выполнять с помощью компактной записи, приведенной в рассмотренном выше примере, — задача далеко не тривиальная, однако при ее решении на помощь приходят шаблоны выражений.

Шаблоны выражений напоминают шаблонное метапрограммирование. Частично это объясняется тем, что иногда они опираются на глубоко вложенное инстанцирование шаблонов, которое не отличается от рекурсивного инстанцирования, встречающегося в шаблонном метапрограммировании. Не исключено, что на сходство этих двух методов также повлияло то, что оба они первоначально разрабатывались для [[Метапрограммирование#Гибридное метапрограммирование|поддержки высокопроизводительных операций с массивами]]. Эти два метода, несомненно, дополняют друг друга. Например, метапрограммирование удобно применять для небольших массивов фиксированного размера, а шаблоны выражений весьма эффективны для выполнения операций со средними и большими массивами, размеры которых задаются во время работы программы.

# Временные объекты и раздельные циклы

Чтобы обосновать применение шаблонов выражений, рассмотрим простейший, прямолинейный (возможно, даже наивный) подход к реализации шаблонов, позволяющих выполнять операции с числовыми массивами. Первичный шаблон массива мог бы выглядеть, как показано ниже (имя `SArray` обозначает простой массив — `simple array`).
```c++
#include <cstddef>
#include <cassert>

template<typename T>
class SArray
{
	public:
		// Создание массива с начальным размером
		explicit SArray(std::size_t s)
			: storage(new T[s]), storage_size(s)
		{
			init () ;
		}
		
		// Копирующий конструктор
		SArray(SArray<T> const& orig)
			: storage(new T[orig.size()]), storage_size(orig.size())
		{
			copy(orig);
		}
		
		// Деструктор: освобождение памяти
		~SArray()
		{
			delete [] storage;
		}
		
		// Оператор присваивания
		SArray<T>& operator= (SArray<T> const& orig)
		{
			if (Sorig != this)
			{
				copy(orig);
			}
			return *this;
		}
		
		// Возврат размера
		std::size_t size() const
		{
			return storage_size;
		}

		// Оператор индекса для констант и переменных
		Т const& operator[](std::size_t idx) const
		{
			return storage[idx];
		}
		
		T& operator[](std::size_t idx)
		{
			return storage[idx];
		}
		
	protected:
		// Инициализация значений конструктором по умолчанию
		void init()
		{
			for(std::size_t idx = 0; idx < size (); ++idx)
			{
				storage[idx] = T();
			}
		}
		
		// Копирование значений другого массива
		void copy(SArray<T> const& orig)
		{
			assert(size () == orig.size());
			for (std::size_t idx = 0; idx < size(); ++idx)
			{
				storage[idx] = orig.storage[idx];
			}
		}

	private:
		T* storage;                  // Память для элементов
		std::size_t storage_size;    // Количество элементов
};
```

Числовые операторы можно закодировать, как показано ниже:
```c++
// Сложение двух SArrays
template<typename Т>
SArray<T> operator+ (SArray<T> const& a, SArray<T> const& b)
{
	assert (a.size () == b.size());
	SArray<T> result(a.size());
	
	for(std::size_t k = 0; k < a.size(); ++k)
	{
		result[k] = a[k] + b[k];
	}
	
	return result;
}

// Умножение двух SArrays
template<typename T>
SArray<T> operator* (SArray<T> const& a, SArray<T> const& b)
{
	assert(a.size() == b.size());
	SArray<T> result(a.size());
	
	for(std::size_t k = 0; k < a.size(); ++k)
	{
		result[k] = a[k] * b[k];
	}
	
	return result;
}

// Перемножение скаляра и SArray
template<typename T>
SArray<T> operator* (T const& s, SArray<T> const& a)
{
	SArray<T> result(а.size());

	for(std::size_t k = 0; k < a.sized; ++k)
	{
		result[k] = s * a[k];
	}

	return result;
}

// Умножение SArray и скаляра
// Сложение скаляра и SArray
// Сложение SArray и скаляра

...
```

Можно было бы написать еще много версий этих и других операторов, однако для нашего примера достаточно того, что есть.
```c++
#include "sarray1.hpp"
#include "sarrayops1.hpp"

int main()
{
	SArray<double> x(1000), у(1000);

	...
	
	x = 1.2 * x + x * у;
}
```

Однако оказывается, что приведенная выше реализация операторов крайне не эффективна. Тому есть две причины.
1. При каждом применении оператора (за исключением оператора присваивания) создается как минимум один временный массив. Это означает, что в нашем примере создается по крайней мере три временных массива, в каждом из которых содержится по 1 000 элементов (это при условии, что компилятор выполняет все допустимые устранения временных копий).
2. При каждом применении оператора компилятору требуется выполнить дополнительный обход массивов-аргументов и результирующих массивов. В нашем примере в предположении генерации только трех временных объектов `SArray` это приводит к необходимости считывания приблизительно `6 000` и записи около `4 000` значений типа `double`.

Оценим количество операций, которые выполняются в циклах, обрабатывающих временные массивы.
```c++
tmp1 = 1.2*х;           // Цикл из 1000 операций
						// плюс создание и удаление массива tmp1
tmp2 = х*у;             // Цикл из 1000 операций
						// плюс создание и удаление массива tmp2
tmp3 = tmp1 + tmp2;     // Цикл из 1000 операций
						// плюс создание и удаление массива tmp3
х = tmp3;               // 1000 операций считывания и
						// 1000 операций записи
```

Если в компиляторе не применяется специальный высокопроизводительный распределитель памяти, то при работе с небольшими массивами основное время тратится на создание ненужных временных массивов. Для выполнения операций с очень большими массивами использование временных массивов абсолютно недопустимо, поскольку может оказаться, что их негде хранить. (Чтобы получить достоверные результаты при численном моделировании реальных систем, часто расходуется вся доступная память. Если же она будет применяться для хранения ненужных временных массивов, это приведет к снижению точности расчетов.)

В ранних реализациях численных библиотек, предназначенных для работы с массивами, эта проблема оставалась нерешенной, и пользователям рекомендовалось применять операторы вычисления с присваиванием (такие как `+=`, `*=` и т.д.). Их преимущество состоит в том, что в них массив является одновременно и аргументом, и целевым массивом, поэтому они не требуют временных массивов. Например, два объекта класса `SArray` можно было бы сложить так, как показано ниже.
```c++
// Сложение SArray с присваиванием
template<typename Т>
SArray<T>& SArray<T>::operator+= (SArray<T> const& b)
{
	assert(size() == orig.size());
	for(std::size_t k = 0; k < sized; ++k)
	{
		(*this)[k] += b[k];
	}

	return *this;
}

// Умножение SArray с присваиванием
template<typename T>
SArray<T>& SArray<T>::operator*= (SArray<T> const& b)
{
	assert(size() == orig.size());
	for(std::size_t k = 0; k < size(); ++k)
	{
		(*this)[k] *= b[k];
	}
	
	return *this;
}

// Скалярное умножение SArray с присваиванием
template<typename T>
SArray<T>& SArray<T>::operator*= (T const& s)
{
	for(std::size_t k = 0; k < size(); ++k)
	{
		(*this)[k] *= s;
	}
	
	return *this;
}
```

С помощью подобных операторов наш вычислительный пример можно было бы переписать следующим образом:
```c++
#include "sarray2.hpp"
#include "sarrayopsl.hpp"
#include "sarrayops2.hpp"

int main()
{
	SArray<double> x(1000), y(1000);

	...
	
	// Вычисление x = 1.2*x + x*y
	SArray<double> tmp(x);
	tmp *= y;
	x *= 1.2;
	x += tmp;
}
```

Понятно, что метод, при котором используются только операторы присваивания с вычислением, тоже не оправдывает наших ожиданий. Он обладает рядом недостатков:
>
> обозначения становятся громоздкими;
> 
> полностью избавиться от ненужных временных массивов не удается;
> 
> в теле цикла выполняется множество операций; в результате для его выполнения требуется выполнить около 6 000 считываний и 4 000 записей значений типа `double`.

На самом деле нам нужен некий единый “идеальный” цикл, в котором бы все выражение вычислялось для каждого индекса.
```c++
int main()
{
	SArray<double> х(1000), у(1000);

	...

	for(int idx = 0; idx < x.sized; ++idx)
	{
		x[idx] = 1.2 * x[idx] + x[idx] * y[idx];
	}
}
```

На этот раз удалось обойтись без временных массивов и ограничиться в каждой итерации цикла всего двумя операциями считывания (элементов массивов `x[idx]` и `y[idx]`) и одной операцией записи в память (`x[idx]`). В результате для выполнения всего цикла требуется выполнить около `2 000` считываний и `1 000` записей в память.

На современных высокопроизводительных компьютерных архитектурах пропускная способность памяти является ограничивающим фактором, снижающим скорость выполнения операций с массивами. Поэтому неудивительно, если на практике окажется, что производительность запрограммированного “вручную” цикла на один-два порядка выше, чем производительность продемонстрированного только что подхода, при котором применяется такая простая перегрузка оператора. Однако желательно добиться такой же производительности более элегантным путем, избегая непонятных обозначений или громоздкого кода, в котором легко допустить ошибку.

# Программирование выражений в аргументах шаблонов

Ключом к решению нашей проблемы является попытка вычислить выражение не по частям, а сразу, откладывая вычисления до момента, пока не будет просмотрено все выражение (в нашем примере — до вызова оператора присваивания). Таким образом, перед вычислением нужно записать, какая операция к какому объекту будет применяться. Эти операции определяются во время компиляции, поэтому они могут быть запрограммированы как аргументы шаблонов.

Для нашего выражения
```c++
1.2*х + х*у;
```

это означает, что результат умножения `1.2*х` — это не новый массив, а объект, в котором каждое значение `х` умножается на `1.2`. Аналогично, в результате операции `х*у` получается объект, в котором каждый элемент массива `х` умножается на соответствующий элемент массива `у`. И наконец, когда нам понадобятся значения результирующего массива, выполняются все упомянутые (и отложенные) вычисления.

Рассмотрим конкретную реализацию сформулированной выше программы действий. Наша реализация вычисляет выражение
```c++
1.2*х + х*у;
```

в объект следующего типа:
```c++
A_Add<A_Mult<A_Scalar<double>, Array<double>>,
	  A_Mult<Array<double>, Array<double>>>
```

В приведенных строках кода новый фундаментальный шаблон класса `Array` комбинируется с шаблонами классов `A_Scalar`, `A_Add` и `A_Mult`. Сопоставьте расположение имен шаблонов с синтаксическим деревом, соответствующим рассматриваемому выражению (рис. 27.1). Этот вложенный идентификатор шаблона представляет типы участвующих в вычислении объектов и операции над ними. Шаблон скалярного типа `A_Scalar` будет приведен ниже; по сути, это просто заместитель для фигурирующего в выражении скаляра.

![[template_10.png]]
Рис. 27.1. Представление выражения `1,2*х+х*у` в виде дерева

## Операнды шаблонов выражений

Чтобы придать завершенный вид приведенному выше представлению выражения, необходимо создать ссылки на каждый из объектов классов `A_Add` и `A_Mult`, а также записать значение в объект класса `A_Scalar` (или ссылку на это значение). Ниже приведен пример определения соответствующих операндов.
```c++
#include <cstddef>
#include <cassert>

// Включение вспомогательного шаблона класса свойств для
// выбора вида обращения к узлу шаблона выражения — по
// ссылке или по значению
#include "expropsla.hpp"

// Класс для объектов, представляющих сложение двух операндов
template<typename Т, typename OР1, typename OР2>
class A_Add
{
	private:
		typename A_Traits<OP1>::ExprRef op1; // Первый операнд
		typename A_Traits<OP2>::ExprRef op2; // Второй операнд
	
	public:
		// Конструктор, инициализирующий ссылки на операнды
		A_Add(OP1 const& а, OР2 const& b)
			: op1(a), op2(b)
		{
		}
		
		// Вычисление суммы по запросу
		Т operator[](std::size_t idx) const
		{
			return op1[idx] + op2[idx];
		}
		
		// size — максимальный размер
		std::size_t sized const
		{
			assert(op1.size() == О || op2.size() == О
					|| op1.size() == op2.size());
					
			return op1.size() != О ? op1.size() : op2.size();
		}
};

// Класс для объектов, представляющих умножение двух операндов
template<typename Т, typename OР1, typename OР2>
class A_Mult
{
	private:
		typename A_Traits<OP1>::ExprRef op1; // Первый операнд
		typename A_Traits<OP2>::ExprRef op2; // Второй операнд
	
	public:
		// Конструктор, инициализирующий ссылки на операнды
		A_Mult(OР1 const& а, OР2 const& b)
			: op1(a), op2(b)
		{
		}
		
		// Вычисление произведения по запросу
		Т operator[](std::size_t idx) const
		{
			return op1[idx] * op2[idx];
		}
		
		// size — максимальный размер
		std::size_t size() const
		{
			assert(op1.size() == 0 || op2.size() == 0
					|| op1.size() == op2.size());
					
			return op1.size() != 0 ? op1.size() : op2.size();
		}
};
```

Как видите, здесь добавлены операция индексации и операция получения размера. Это позволит определять тип массива и значения его элементов, что понадобится в процессе выполнения операций, представленных “узлами” того поддерева, корнем которого является данный объект.

Если в операции принимают участие только массивы, то размер результирующего объекта равен размеру любого из двух операндов. Если же операция выполняется над массивом и скаляром, в результате получим объект, размер которого равен операнду-массиву. Чтобы отличить операнд-массив от скалярного операнда, размер последнего задан равным нулю. Поэтому шаблон `A_Scalar` определяется так, как показано ниже:
```c++
// Класс для объектов, представляющих скаляры:
template<typename Т>
class A_Scalar
{
	private:
		Т const& s; // Значение скаляра
	
	public:
		// Конструктор, инициализирующий значение
		constexpr A_Scalar(T const& v)
			:s(v)
		{
		}
		
		// В индексных операциях скаляр представляет
		// собой значение каждого элемента
		constexpr Т const& operator[](std::size_t) const
		{
			return s;
		}
		
		// Размер скаляра - нулевой
		constexpr std::size_t size() const
		{
			return 0;
		};
};
```

(Мы объявили конструктор и функции-члены как [[constexpr|constexpr]], так что этот класс может быть использован во время компиляции. Однако для наших целей это не является строго необходимым.)

Заметим, что наши скаляры допускают использование операции индексации. Скаляр при этом можно рассматривать как массив с одинаковыми значениями всех элементов, равных значению скаляра.

Вероятно, вы обратили внимание на то, что в классах операторов для определения операндов-членов применяется вспомогательный класс `A_Traits`:
```c++
typename A_Traits<OP1>::ExprRef op1;      // Первый операнд
typename A_Traits<OP2>::ExprRef op2;      // Второй операнд
```

Это необходимо по следующей причине: в общем случае операнды можно объявить как ссылки, поскольку большинство временных узлов иерархической структуры вычисляемого выражения связаны с выражением верхнего уровня и потому остаются в памяти до завершения вычисления всего выражения. Единственным исключением являются узлы `A_Scalar`. Они фигурируют в операторных функциях и могут не оставаться в памяти до завершения вычисления всего выражения. Таким образом, чтобы избежать ссылок на уже не существующие скалярные объекты, скалярные операнды должны быть скопированы по значению.

Другими словами, нужны операнды-члены, обладающие такими свойствами:
>
> в общем случае являются ссылками на константы:
> > 
> > OP1 const& op1; // Обращение к первому операнду по ссылке
> > OP2 const& ор2; // Обращение ко второму операнду по ссылке
>
> но для скаляров это обычные значения:
> > 
> > 0Р1 op2;            // Обращение к первому операнду по значению
> > ОР2 ор2;           // Обращение ко второму операнду по значению
>

Здесь отлично подходят классы свойств. В классе свойств тип в общем случае определяется как ссылка на константу, а в случае скаляра — как обычное значение:
```c++
// Вспомогательный класс свойств, помогающий выбрать способ
// обращения к узловому объекту шаблона выражения
//    - в общем случае - по ссылке;
//    - для скаляров — по значению

template<typename Т> class A_Scalar;

// Первичный шаблон
template<typename Т>
class A_Traits
{
	public:
		using ExprRef = T const&;    // Тип - ссылка на константу
};

// Частичная специализация для скаляров
template<typename Т>
class A_Traits<A_Scalar<T>>
{
	public:
		using ExprRef = A_Scalar<T>; // Тип — обычное значение
};
```

Обратите внимание: поскольку объекты `A_Scalar` в выражении верхнего уровня обращаются к скалярам, эти скаляры могут использовать ссылочные типы, т.е. `A_Scalar<T>::s` представляет собой член-ссылку.

## Тип Array

Теперь, когда мы умеем кодировать выражения с использованием простых шаблонов выражений, необходимо создать тип `Array`, который бы занимался реальным хранением данных и располагал информацией о шаблонах выражений. Конечно, с инженерной точки зрения было бы хорошо, если бы его интерфейс был как можно более похож на интерфейс обычного массива, и чтобы имелся интерфейс для представления выражений, которые определяют результирующие значения массива. Для этого объявим шаблон `Array` следующим образом:
```c++
template<typename Т, typename Rep = SArray<T>>
class Array;
```

Тип `Rep` может быть типом `SArray`, если `Array` представляет собой обычный массив, либо быть вложенным идентификатором шаблона наподобие `A_Add` или `A_Mult`, который кодирует выражение. В любом случае мы имеем дело с инстанцированием класса `Array`, что значительно упрощает дальнейшие действия. Фактически, чтобы различить два этих случая, даже не нужны специализации определений шаблона `Array`, хотя при подстановке вместо `Rep` типов наподобие `A_Mult` некоторые из членов не могут быть инстанцированы.

Ниже приведено определение шаблона `Array`. Его функциональные возможности ограничены и мало отличаются от функциональных возможностей шаблона `SArray`. Однако если принцип работы кода понятен, то расширение возможностей шаблона не представит затруднений.
```c++
#include <cstddef>
#include <cassert>
#include "sarrayl.hpp"

template<typename T, typename Rep = SArray<T>>
class Array
{
	private:
		Rep expr_rep; // (Доступ к) данным массива

	public:
		// Создание массива с начальным размером
		explicit Array(std::size_t s)
			: expr_rep(s)
		{
		}
		
		// Создание массива из возможного представления
		Array(Rep const& rb)
			: expr_rep(rb)
		{
		}
		
		// Оператор присваивания для того же типа
		Array& operator= (Array const& b)
		{
			assert(size() == b.size());
			for(std::size_t idx = 0; idx < b.size(); ++idx)
			{
				expr_rep[idx] = b[idx];
			}
			
			return *this;
		}

		// Оператор присваивания для массивов другого типа
		template<typename Т2, typename Rep2>
		Array& operator= (Array<T2, Rep2> const& b)
		{
			assert(size() == b.size());
			
			for(std::size_t idx = 0; idx < b.size(); ++idx)
			{
				expr_rep[idx] = b[idx];
			}
			
			return *this;
		}
	
		// size — размер представленных данных
		std::size_t size() const
		{
			return expr_rep.size();
		}
		
		// Оператор индекса для констант и переменных
		decltype(auto) operator[](std::size_t idx) const
		{
			assert(idx < size());
			return expr_rep[idx];
		}
		
		T& operator[](std::size_t idx)
		{
			assert(idx < size());
			return expr_rep[idx];
		}
		
		// Возврат текущего представления массива
		Rep const& rep() const
		{
			return expr_rep;
		}
		
		Rep& rep()
		{
			return expr_rep;
		}
};
```

Как видно из представленного фрагмента кода, многие операции просто передаются в лежащий в основе объект класса `Rep`. Однако при копировании другого массива необходимо принимать во внимание, что этот другой массив на самом деле может быть создан на основе шаблона выражения. Таким образом, эта операция копирования параметризуется в терминах представления, лежащего в основе типа `Rep`.

Оператор индекса заслуживает небольшого отдельного обсуждения. Обратите внимание на то, что константная версия этого оператора использует выведенный тип возвращаемого значения вместо более традиционного типа `Т const&`. Мы поступаем так, поскольку, если `Rep` представляет `A_Mult` или `A_Add`, его оператор индекса возвращает временное значение (т.е. `prvalue`), которое не может быть возвращено по ссылке (и [[decltуре#decltype(auto) C++14|decltype (auto)]] в этом случае выведет нессылочный тип). С другой стороны, если `Rep` представляет собой `SArray<T>`, то базовый оператор индекса создает константное [[r-значение#l-значение|l-значение]], и в этом случае выводимый возвращаемый тип будет соответствующей константной ссылкой.

## Операторы

Теперь у нас есть почти все, что необходимо для реализации эффективных числовых операторов при работе с шаблоном `Array`, за исключением самих операторов. Как уже отмечалось, эти операторы только собирают в единое выражение шаблонные объекты, сами результирующие массивы они не вычисляют.

Необходимо реализовать по три версии каждого обычного бинарного оператора для таких пар операндов: массив-массив, массив-скаляр и скаляр-массив. В частности, чтобы получить возможность вычислять выражение, приведенное в качестве примера в начале данной главы, понадобятся такие операторы:
```c++

```














