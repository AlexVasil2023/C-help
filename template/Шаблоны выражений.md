
[[#Шаблоны выражений|Шаблоны выражений]] 27
1. [[#Временные объекты и раздельные циклы|Временные объекты и раздельные циклы]] 27.1
2. [[#Программирование выражений в аргументах шаблонов|Программирование выражений в аргументах шаблонов]] 27.2
	1. [[#Операнды шаблонов выражений|Операнды шаблонов выражений]] 27.2.1
	2. [[#Тип Array|Тип Array]] 27.2.2
	3. [[#Операторы|Операторы]] 27.2.3
	4. [[#Подведем итог|Подведем итог]] 27.2.4
	5. [[#Присваивание шаблонам выражений|Присваивание шаблонам выражений]] 27.2.5
3. [[#Производительность и ограничения шаблонов выражений|Производительность и ограничения шаблонов выражений]] 27.3





# Шаблоны выражений

В этой главе описывается метод шаблонного программирования, известный под названием шаблоны выражений (`expression templates`). Впервые этот метод возник при работе с классами числовых массивов, и именно в таком контексте он рассматривается в данной главе.

Класс числовых массивов поддерживает выполнение числовых операций с массивом как с целостным объектом. Например, к двум массивам можно применить операцию сложения; в результате ее выполнения получим массив, каждый элемент которого будет суммой соответствующих элементов исходных массивов. Аналогично массив можно умножить на скаляр. Это означает, что на скаляр умножается каждый элемент исходного массива. Возникает естественное желание реализовать для массивов операторные обозначения, так знакомые нам по работе со встроенными скалярными типами:
```c++
Array<double> х(1000), у(1000);
...
х=1.2*х + х*у;
```

Для серьезных высокопроизводительных вычислительных комплексов важно, чтобы выражения такого рода вычислялись настолько эффективно, насколько можно ожидать от платформы, на которой выполняется этот код. Добиться того, чтобы такие вычисления можно было выполнять с помощью компактной записи, приведенной в рассмотренном выше примере, — задача далеко не тривиальная, однако при ее решении на помощь приходят шаблоны выражений.

Шаблоны выражений напоминают шаблонное метапрограммирование. Частично это объясняется тем, что иногда они опираются на глубоко вложенное инстанцирование шаблонов, которое не отличается от рекурсивного инстанцирования, встречающегося в шаблонном метапрограммировании. Не исключено, что на сходство этих двух методов также повлияло то, что оба они первоначально разрабатывались для [[Метапрограммирование#Гибридное метапрограммирование|поддержки высокопроизводительных операций с массивами]]. Эти два метода, несомненно, дополняют друг друга. Например, метапрограммирование удобно применять для небольших массивов фиксированного размера, а шаблоны выражений весьма эффективны для выполнения операций со средними и большими массивами, размеры которых задаются во время работы программы.

# Временные объекты и раздельные циклы

Чтобы обосновать применение шаблонов выражений, рассмотрим простейший, прямолинейный (возможно, даже наивный) подход к реализации шаблонов, позволяющих выполнять операции с числовыми массивами. Первичный шаблон массива мог бы выглядеть, как показано ниже (имя `SArray` обозначает простой массив — `simple array`).
```c++
#include <cstddef>
#include <cassert>

template<typename T>
class SArray
{
	public:
		// Создание массива с начальным размером
		explicit SArray(std::size_t s)
			: storage(new T[s]), storage_size(s)
		{
			init () ;
		}
		
		// Копирующий конструктор
		SArray(SArray<T> const& orig)
			: storage(new T[orig.size()]), storage_size(orig.size())
		{
			copy(orig);
		}
		
		// Деструктор: освобождение памяти
		~SArray()
		{
			delete [] storage;
		}
		
		// Оператор присваивания
		SArray<T>& operator= (SArray<T> const& orig)
		{
			if (Sorig != this)
			{
				copy(orig);
			}
			return *this;
		}
		
		// Возврат размера
		std::size_t size() const
		{
			return storage_size;
		}

		// Оператор индекса для констант и переменных
		Т const& operator[](std::size_t idx) const
		{
			return storage[idx];
		}
		
		T& operator[](std::size_t idx)
		{
			return storage[idx];
		}
		
	protected:
		// Инициализация значений конструктором по умолчанию
		void init()
		{
			for(std::size_t idx = 0; idx < size (); ++idx)
			{
				storage[idx] = T();
			}
		}
		
		// Копирование значений другого массива
		void copy(SArray<T> const& orig)
		{
			assert(size () == orig.size());
			for (std::size_t idx = 0; idx < size(); ++idx)
			{
				storage[idx] = orig.storage[idx];
			}
		}

	private:
		T* storage;                  // Память для элементов
		std::size_t storage_size;    // Количество элементов
};
```

Числовые операторы можно закодировать, как показано ниже:
```c++
// Сложение двух SArrays
template<typename Т>
SArray<T> operator+ (SArray<T> const& a, SArray<T> const& b)
{
	assert (a.size () == b.size());
	SArray<T> result(a.size());
	
	for(std::size_t k = 0; k < a.size(); ++k)
	{
		result[k] = a[k] + b[k];
	}
	
	return result;
}

// Умножение двух SArrays
template<typename T>
SArray<T> operator* (SArray<T> const& a, SArray<T> const& b)
{
	assert(a.size() == b.size());
	SArray<T> result(a.size());
	
	for(std::size_t k = 0; k < a.size(); ++k)
	{
		result[k] = a[k] * b[k];
	}
	
	return result;
}

// Перемножение скаляра и SArray
template<typename T>
SArray<T> operator* (T const& s, SArray<T> const& a)
{
	SArray<T> result(а.size());

	for(std::size_t k = 0; k < a.sized; ++k)
	{
		result[k] = s * a[k];
	}

	return result;
}

// Умножение SArray и скаляра
// Сложение скаляра и SArray
// Сложение SArray и скаляра

...
```

Можно было бы написать еще много версий этих и других операторов, однако для нашего примера достаточно того, что есть.
```c++
#include "sarray1.hpp"
#include "sarrayops1.hpp"

int main()
{
	SArray<double> x(1000), у(1000);

	...
	
	x = 1.2 * x + x * у;
}
```

Однако оказывается, что приведенная выше реализация операторов крайне не эффективна. Тому есть две причины.
1. При каждом применении оператора (за исключением оператора присваивания) создается как минимум один временный массив. Это означает, что в нашем примере создается по крайней мере три временных массива, в каждом из которых содержится по 1 000 элементов (это при условии, что компилятор выполняет все допустимые устранения временных копий).
2. При каждом применении оператора компилятору требуется выполнить дополнительный обход массивов-аргументов и результирующих массивов. В нашем примере в предположении генерации только трех временных объектов `SArray` это приводит к необходимости считывания приблизительно `6 000` и записи около `4 000` значений типа `double`.

Оценим количество операций, которые выполняются в циклах, обрабатывающих временные массивы.
```c++
tmp1 = 1.2*х;           // Цикл из 1000 операций
						// плюс создание и удаление массива tmp1
tmp2 = х*у;             // Цикл из 1000 операций
						// плюс создание и удаление массива tmp2
tmp3 = tmp1 + tmp2;     // Цикл из 1000 операций
						// плюс создание и удаление массива tmp3
х = tmp3;               // 1000 операций считывания и
						// 1000 операций записи
```

Если в компиляторе не применяется специальный высокопроизводительный распределитель памяти, то при работе с небольшими массивами основное время тратится на создание ненужных временных массивов. Для выполнения операций с очень большими массивами использование временных массивов абсолютно недопустимо, поскольку может оказаться, что их негде хранить. (Чтобы получить достоверные результаты при численном моделировании реальных систем, часто расходуется вся доступная память. Если же она будет применяться для хранения ненужных временных массивов, это приведет к снижению точности расчетов.)

В ранних реализациях численных библиотек, предназначенных для работы с массивами, эта проблема оставалась нерешенной, и пользователям рекомендовалось применять операторы вычисления с присваиванием (такие как `+=`, `*=` и т.д.). Их преимущество состоит в том, что в них массив является одновременно и аргументом, и целевым массивом, поэтому они не требуют временных массивов. Например, два объекта класса `SArray` можно было бы сложить так, как показано ниже.
```c++
// Сложение SArray с присваиванием
template<typename Т>
SArray<T>& SArray<T>::operator+= (SArray<T> const& b)
{
	assert(size() == orig.size());
	for(std::size_t k = 0; k < sized; ++k)
	{
		(*this)[k] += b[k];
	}

	return *this;
}

// Умножение SArray с присваиванием
template<typename T>
SArray<T>& SArray<T>::operator*= (SArray<T> const& b)
{
	assert(size() == orig.size());
	for(std::size_t k = 0; k < size(); ++k)
	{
		(*this)[k] *= b[k];
	}
	
	return *this;
}

// Скалярное умножение SArray с присваиванием
template<typename T>
SArray<T>& SArray<T>::operator*= (T const& s)
{
	for(std::size_t k = 0; k < size(); ++k)
	{
		(*this)[k] *= s;
	}
	
	return *this;
}
```

С помощью подобных операторов наш вычислительный пример можно было бы переписать следующим образом:
```c++
#include "sarray2.hpp"
#include "sarrayopsl.hpp"
#include "sarrayops2.hpp"

int main()
{
	SArray<double> x(1000), y(1000);

	...
	
	// Вычисление x = 1.2*x + x*y
	SArray<double> tmp(x);
	tmp *= y;
	x *= 1.2;
	x += tmp;
}
```

Понятно, что метод, при котором используются только операторы присваивания с вычислением, тоже не оправдывает наших ожиданий. Он обладает рядом недостатков:
>
> обозначения становятся громоздкими;
> 
> полностью избавиться от ненужных временных массивов не удается;
> 
> в теле цикла выполняется множество операций; в результате для его выполнения требуется выполнить около 6 000 считываний и 4 000 записей значений типа `double`.

На самом деле нам нужен некий единый “идеальный” цикл, в котором бы все выражение вычислялось для каждого индекса.
```c++
int main()
{
	SArray<double> х(1000), у(1000);

	...

	for(int idx = 0; idx < x.sized; ++idx)
	{
		x[idx] = 1.2 * x[idx] + x[idx] * y[idx];
	}
}
```

На этот раз удалось обойтись без временных массивов и ограничиться в каждой итерации цикла всего двумя операциями считывания (элементов массивов `x[idx]` и `y[idx]`) и одной операцией записи в память (`x[idx]`). В результате для выполнения всего цикла требуется выполнить около `2 000` считываний и `1 000` записей в память.

На современных высокопроизводительных компьютерных архитектурах пропускная способность памяти является ограничивающим фактором, снижающим скорость выполнения операций с массивами. Поэтому неудивительно, если на практике окажется, что производительность запрограммированного “вручную” цикла на один-два порядка выше, чем производительность продемонстрированного только что подхода, при котором применяется такая простая перегрузка оператора. Однако желательно добиться такой же производительности более элегантным путем, избегая непонятных обозначений или громоздкого кода, в котором легко допустить ошибку.

# Программирование выражений в аргументах шаблонов

Ключом к решению нашей проблемы является попытка вычислить выражение не по частям, а сразу, откладывая вычисления до момента, пока не будет просмотрено все выражение (в нашем примере — до вызова оператора присваивания). Таким образом, перед вычислением нужно записать, какая операция к какому объекту будет применяться. Эти операции определяются во время компиляции, поэтому они могут быть запрограммированы как аргументы шаблонов.

Для нашего выражения
```c++
1.2*х + х*у;
```

это означает, что результат умножения `1.2*х` — это не новый массив, а объект, в котором каждое значение `х` умножается на `1.2`. Аналогично, в результате операции `х*у` получается объект, в котором каждый элемент массива `х` умножается на соответствующий элемент массива `у`. И наконец, когда нам понадобятся значения результирующего массива, выполняются все упомянутые (и отложенные) вычисления.

Рассмотрим конкретную реализацию сформулированной выше программы действий. Наша реализация вычисляет выражение
```c++
1.2*х + х*у;
```

в объект следующего типа:
```c++
A_Add<A_Mult<A_Scalar<double>, Array<double>>,
	  A_Mult<Array<double>, Array<double>>>
```

В приведенных строках кода новый фундаментальный шаблон класса `Array` комбинируется с шаблонами классов `A_Scalar`, `A_Add` и `A_Mult`. Сопоставьте расположение имен шаблонов с синтаксическим деревом, соответствующим рассматриваемому выражению (рис. 27.1). Этот вложенный идентификатор шаблона представляет типы участвующих в вычислении объектов и операции над ними. Шаблон скалярного типа `A_Scalar` будет приведен ниже; по сути, это просто заместитель для фигурирующего в выражении скаляра.

![[template_10.png]]
Рис. 27.1. Представление выражения `1,2*х+х*у` в виде дерева

## Операнды шаблонов выражений

Чтобы придать завершенный вид приведенному выше представлению выражения, необходимо создать ссылки на каждый из объектов классов `A_Add` и `A_Mult`, а также записать значение в объект класса `A_Scalar` (или ссылку на это значение). Ниже приведен пример определения соответствующих операндов.
```c++
#include <cstddef>
#include <cassert>

// Включение вспомогательного шаблона класса свойств для
// выбора вида обращения к узлу шаблона выражения — по
// ссылке или по значению
#include "expropsla.hpp"

// Класс для объектов, представляющих сложение двух операндов
template<typename Т, typename OР1, typename OР2>
class A_Add
{
	private:
		typename A_Traits<OP1>::ExprRef op1; // Первый операнд
		typename A_Traits<OP2>::ExprRef op2; // Второй операнд
	
	public:
		// Конструктор, инициализирующий ссылки на операнды
		A_Add(OP1 const& а, OР2 const& b)
			: op1(a), op2(b)
		{
		}
		
		// Вычисление суммы по запросу
		Т operator[](std::size_t idx) const
		{
			return op1[idx] + op2[idx];
		}
		
		// size — максимальный размер
		std::size_t sized const
		{
			assert(op1.size() == О || op2.size() == О
					|| op1.size() == op2.size());
					
			return op1.size() != О ? op1.size() : op2.size();
		}
};

// Класс для объектов, представляющих умножение двух операндов
template<typename Т, typename OР1, typename OР2>
class A_Mult
{
	private:
		typename A_Traits<OP1>::ExprRef op1; // Первый операнд
		typename A_Traits<OP2>::ExprRef op2; // Второй операнд
	
	public:
		// Конструктор, инициализирующий ссылки на операнды
		A_Mult(OР1 const& а, OР2 const& b)
			: op1(a), op2(b)
		{
		}
		
		// Вычисление произведения по запросу
		Т operator[](std::size_t idx) const
		{
			return op1[idx] * op2[idx];
		}
		
		// size — максимальный размер
		std::size_t size() const
		{
			assert(op1.size() == 0 || op2.size() == 0
					|| op1.size() == op2.size());
					
			return op1.size() != 0 ? op1.size() : op2.size();
		}
};
```

Как видите, здесь добавлены операция индексации и операция получения размера. Это позволит определять тип массива и значения его элементов, что понадобится в процессе выполнения операций, представленных “узлами” того поддерева, корнем которого является данный объект.

Если в операции принимают участие только массивы, то размер результирующего объекта равен размеру любого из двух операндов. Если же операция выполняется над массивом и скаляром, в результате получим объект, размер которого равен операнду-массиву. Чтобы отличить операнд-массив от скалярного операнда, размер последнего задан равным нулю. Поэтому шаблон `A_Scalar` определяется так, как показано ниже:
```c++
// Класс для объектов, представляющих скаляры:
template<typename Т>
class A_Scalar
{
	private:
		Т const& s; // Значение скаляра
	
	public:
		// Конструктор, инициализирующий значение
		constexpr A_Scalar(T const& v)
			:s(v)
		{
		}
		
		// В индексных операциях скаляр представляет
		// собой значение каждого элемента
		constexpr Т const& operator[](std::size_t) const
		{
			return s;
		}
		
		// Размер скаляра - нулевой
		constexpr std::size_t size() const
		{
			return 0;
		};
};
```

(Мы объявили конструктор и функции-члены как [[constexpr|constexpr]], так что этот класс может быть использован во время компиляции. Однако для наших целей это не является строго необходимым.)

Заметим, что наши скаляры допускают использование операции индексации. Скаляр при этом можно рассматривать как массив с одинаковыми значениями всех элементов, равных значению скаляра.

Вероятно, вы обратили внимание на то, что в классах операторов для определения операндов-членов применяется вспомогательный класс `A_Traits`:
```c++
typename A_Traits<OP1>::ExprRef op1;      // Первый операнд
typename A_Traits<OP2>::ExprRef op2;      // Второй операнд
```

Это необходимо по следующей причине: в общем случае операнды можно объявить как ссылки, поскольку большинство временных узлов иерархической структуры вычисляемого выражения связаны с выражением верхнего уровня и потому остаются в памяти до завершения вычисления всего выражения. Единственным исключением являются узлы `A_Scalar`. Они фигурируют в операторных функциях и могут не оставаться в памяти до завершения вычисления всего выражения. Таким образом, чтобы избежать ссылок на уже не существующие скалярные объекты, скалярные операнды должны быть скопированы по значению.

Другими словами, нужны операнды-члены, обладающие такими свойствами:
>
> в общем случае являются ссылками на константы:
> > 
> > OP1 const& op1; // Обращение к первому операнду по ссылке
> > OP2 const& ор2; // Обращение ко второму операнду по ссылке
>
> но для скаляров это обычные значения:
> > 
> > 0Р1 op2;            // Обращение к первому операнду по значению
> > ОР2 ор2;           // Обращение ко второму операнду по значению
>

Здесь отлично подходят классы свойств. В классе свойств тип в общем случае определяется как ссылка на константу, а в случае скаляра — как обычное значение:
```c++
// Вспомогательный класс свойств, помогающий выбрать способ
// обращения к узловому объекту шаблона выражения
//    - в общем случае - по ссылке;
//    - для скаляров — по значению

template<typename Т> class A_Scalar;

// Первичный шаблон
template<typename Т>
class A_Traits
{
	public:
		using ExprRef = T const&;    // Тип - ссылка на константу
};

// Частичная специализация для скаляров
template<typename Т>
class A_Traits<A_Scalar<T>>
{
	public:
		using ExprRef = A_Scalar<T>; // Тип — обычное значение
};
```

Обратите внимание: поскольку объекты `A_Scalar` в выражении верхнего уровня обращаются к скалярам, эти скаляры могут использовать ссылочные типы, т.е. `A_Scalar<T>::s` представляет собой член-ссылку.

## Тип Array

Теперь, когда мы умеем кодировать выражения с использованием простых шаблонов выражений, необходимо создать тип `Array`, который бы занимался реальным хранением данных и располагал информацией о шаблонах выражений. Конечно, с инженерной точки зрения было бы хорошо, если бы его интерфейс был как можно более похож на интерфейс обычного массива, и чтобы имелся интерфейс для представления выражений, которые определяют результирующие значения массива. Для этого объявим шаблон `Array` следующим образом:
```c++
template<typename Т, typename Rep = SArray<T>>
class Array;
```

Тип `Rep` может быть типом `SArray`, если `Array` представляет собой обычный массив, либо быть вложенным идентификатором шаблона наподобие `A_Add` или `A_Mult`, который кодирует выражение. В любом случае мы имеем дело с инстанцированием класса `Array`, что значительно упрощает дальнейшие действия. Фактически, чтобы различить два этих случая, даже не нужны специализации определений шаблона `Array`, хотя при подстановке вместо `Rep` типов наподобие `A_Mult` некоторые из членов не могут быть инстанцированы.

Ниже приведено определение шаблона `Array`. Его функциональные возможности ограничены и мало отличаются от функциональных возможностей шаблона `SArray`. Однако если принцип работы кода понятен, то расширение возможностей шаблона не представит затруднений.
```c++
#include <cstddef>
#include <cassert>
#include "sarrayl.hpp"

template<typename T, typename Rep = SArray<T>>
class Array
{
	private:
		Rep expr_rep; // (Доступ к) данным массива

	public:
		// Создание массива с начальным размером
		explicit Array(std::size_t s)
			: expr_rep(s)
		{
		}
		
		// Создание массива из возможного представления
		Array(Rep const& rb)
			: expr_rep(rb)
		{
		}
		
		// Оператор присваивания для того же типа
		Array& operator= (Array const& b)
		{
			assert(size() == b.size());
			for(std::size_t idx = 0; idx < b.size(); ++idx)
			{
				expr_rep[idx] = b[idx];
			}
			
			return *this;
		}

		// Оператор присваивания для массивов другого типа
		template<typename Т2, typename Rep2>
		Array& operator= (Array<T2, Rep2> const& b)
		{
			assert(size() == b.size());
			
			for(std::size_t idx = 0; idx < b.size(); ++idx)
			{
				expr_rep[idx] = b[idx];
			}
			
			return *this;
		}
	
		// size — размер представленных данных
		std::size_t size() const
		{
			return expr_rep.size();
		}
		
		// Оператор индекса для констант и переменных
		decltype(auto) operator[](std::size_t idx) const
		{
			assert(idx < size());
			return expr_rep[idx];
		}
		
		T& operator[](std::size_t idx)
		{
			assert(idx < size());
			return expr_rep[idx];
		}
		
		// Возврат текущего представления массива
		Rep const& rep() const
		{
			return expr_rep;
		}
		
		Rep& rep()
		{
			return expr_rep;
		}
};
```

Как видно из представленного фрагмента кода, многие операции просто передаются в лежащий в основе объект класса `Rep`. Однако при копировании другого массива необходимо принимать во внимание, что этот другой массив на самом деле может быть создан на основе шаблона выражения. Таким образом, эта операция копирования параметризуется в терминах представления, лежащего в основе типа `Rep`.

Оператор индекса заслуживает небольшого отдельного обсуждения. Обратите внимание на то, что константная версия этого оператора использует выведенный тип возвращаемого значения вместо более традиционного типа `Т const&`. Мы поступаем так, поскольку, если `Rep` представляет `A_Mult` или `A_Add`, его оператор индекса возвращает временное значение (т.е. `prvalue`), которое не может быть возвращено по ссылке (и [[decltуре#decltype(auto) C++14|decltype (auto)]] в этом случае выведет нессылочный тип). С другой стороны, если `Rep` представляет собой `SArray<T>`, то базовый оператор индекса создает константное [[r-значение#l-значение|l-значение]], и в этом случае выводимый возвращаемый тип будет соответствующей константной ссылкой.

## Операторы

Теперь у нас есть почти все, что необходимо для реализации эффективных числовых операторов при работе с шаблоном `Array`, за исключением самих операторов. Как уже отмечалось, эти операторы только собирают в единое выражение шаблонные объекты, сами результирующие массивы они не вычисляют.

Необходимо реализовать по три версии каждого обычного бинарного оператора для таких пар операндов: массив-массив, массив-скаляр и скаляр-массив. В частности, чтобы получить возможность вычислять выражение, приведенное в качестве примера в начале данной главы, понадобятся такие операторы:
```c++
// Сложение двух Array:
template<typename Т, typename R1, typename R2>
Array<T, A_Add<T, R1, R2>>
operator+ (Array<T, R1> const& a, Array<T, R2> const& b)
{
	return Array<T, A_Add<T, R1, R2>>
			(A_Add<T, R1, R2>(a.rep(), b.rep()));
}

// Умножение двух Array:
template<typename T, typename R1, typename R2>
Array<T, A_Mult<T, R1, R2>>
operator* (Array<T, R1> const& a, Array<T, R2> const& b)
{
	return Array<T, A_Mult<T, R1, R2>>
			(A_Mult<T, R1, R2>(a.rep(), b.rep()));
}

// Умножение скаляра и Array:
template<typename T, typename R2>
Array<T, A_Mult<T, A_Scalar<T>, R2>>
operator* (T const& s, Array<T, R2> const& b)
{
	return Array<T, A_Mult<T, A_Scalar<T>, R2>>
			(A_Mult<T, A_Scalar<T>, R2>(A_Scalar<T>(s), b.rep()));
}
// Умножение Array и скаляра,
// сложение Array и скаляра:
...
```

Как видно из рассмотренных примеров, объявление этих операторов является громоздким, однако нельзя сказать, чтобы в самих функциях выполнялось много действий. Например, в операторе суммирования двух массивов сначала создается объект класса `A_Add<>`, представляющий этот оператор и операнды
```c++
A_Add<T,R1,R2>(a.rep(),b.rep())
```

Затем этот объект помещается в объект класса `Array`. После этого результат можно использовать, как любой другой объект, с помощью которого представляются содержащиеся в массиве данные:
```c++
return Array<T, A_Add<T, R1, R2>> (...);
```

При вычислении скалярного произведения для создания объекта класса `A_Mult` применяется шаблон `A_Scalar`:
```c++
A_Mult<T, A_Scalar<T>, R2>(A_Scalar<T>(s), b.rep())
```

После этого результат снова помещается в объект класса `Array`:
```c++
return Array<T, A_Mult<T, A_Scalar<T>, R2>> (...);
```

Другие бинарные операторы, не являющиеся членами класса, настолько похожи друг на друга, что для большинства из них можно применить макросы с небольшим количеством исходного кода. С помощью других (меньших) макросов можно реализовать унарные операторы, не являющиеся членами.

## Подведем итог

При первом знакомстве с понятием шаблонов выражений сложная взаимосвязь различных объявлений и определений может отпугивать. Поэтому проведем нисходящий обзор процессов, которые происходят при работе рассматриваемого примера. Анализируемый код выглядит следующим образом:
```c++
int main()
{
	Array<double> х(1000), y(1000);

	...

	x=1.2*x + x*y;
}
```

Поскольку в объявлении объектов `х` и `у` аргумент `Rep` опущен, по умолчанию принимается, что это объекты класса `SArray<double>`. Таким образом, `х` и `у` — это массивы, в которых хранятся “реальные” значения, а не записи операций.

При анализе выражения
```c++
1.2*х + х*у
```

компилятор сначала применяет левую операцию `*`, операндами которой являются скаляр и массив. Поэтому в процессе разрешения перегрузки оператора умножения выбирается такая его форма:
```c++
template<typename Т, typename R2>
Array<T, A_Mult<T, A_Scalar<T>, R2>>
operator* (T const& s, Array<T, R2> const& b)
{
	return Array<T, A_Mult<T, A_Scalar<T>, R2>>
			(A_Mult<T, A_Scalar<T>, R2>(A_Scalar<T>(s), b.rep()));
}
```

Типами операндов являются `double` и `Array<double, SArray<double>>`. Таким образом, тип результата представляет собой
```c++
Array<double, A_Mult<double, A_Scalar<double>, SArray<double>>>
```

Результирующее значение использует объект `A_Scalar<double>`, созданный из значения `1.2` типа `double`, и представление `SArray<double>` объекта `х`.

Затем компилятор переходит к обработке операции умножения `х*у`, операндами которой являются два массива. Для этого применяется соответствующая форма перегруженного оператора `operator*`:
```c++
template<typename Т, typename R1, typename R2>
Array<T, A_Mult<T, R1, R2>>
operator* (Array<T, R1> const& a, Array<T, R2> const& b)
{
	return Array<T, A_Mult<T, R1, R2>>
			(A_Mult<T, R1, R2>(a.rep(), b.rep()));
}
```

Оба операнда имеют тип `Array<double, SArray<double>>`, поэтому тип результата следующий:
```c++
Array<double, A_Mult<double, SArray<double>, SArray<double>>>
```

На этот раз объект `A_Mult` использует два представления класса `SArray<double>`: одно для массива `х`, второе для массива `у`.

Наконец, выполняется операция `+`. Ее операндами, как и операндами предыдущей операции, являются два массива, типы которых получены в результате предыдущих операций. Таким образом, к паре массивов применяется оператор `+` такого вида:
```c++
template<typename Т, typename R1, typename R2>
Array<T, A_Add<T, R1, R2>>
operatort (Array<T, R1> const& a, Array<T, R2> const& b)
{
	return Array<T, A_Add<T, R1, R2>>
			(A_Add<T, R1, R2>(a.rep(), b.rep()));
}
```

Вместо параметра `T` подставляется `double`, в то время как вместо `R1` подставляется
```c++
A_Mult<double, A_Scalar<double>, SArray<double>>
```

`R2` заменяется на
```c++
A_Mult<double, SArray<double>, SArray<double>>
```

Таким образом, справа от знака присваивания находится выражение, имеющее такой тип:
```c++
Array<double,
		A_Add<double,
		A_Mult<double, A_Scalar<double>, SArray<double>>,
		A_Mult<double, SArray<double>, SArray<double>>>>
```

Этот тип соответствует шаблону оператора присваивания из шаблона `Array`:
```c++
template<typename Т, typename Rep = SArray<T>>
class Array
{
	public:
		// Оператор присваивания для массивов отличающихся типов
		template<typename Т2, typename Rep2>
		Arrays operator= (Array<T2, Rep2> const& b)
		{
			assert(size() == b.size());
			for(std::size_t idx = 0; idx < b.sizeO; ++idx)
			{
				expr_rep[idx] = b[idx];
			}
			
			return *this;
		}
		
		...
}
```

В результате выполнения оператора присваивания вычисляется каждый элемент целевого массива `х`. При этом оператор индекса применяется к представлению правой части, тип которой следующий:
```c++
A_Add<double,
		A_Mult<double, A_Scalar<double>, SArray<double>>,
		A_Mult<double, SArray<double>, SArray<double>>>>
```

Детальный разбор результатов работы этого оператора показывает, что для данного индекса `idx` он вычисляет выражение
```c++
(1.2*х[idx]) + (х[idx]*у[idx])
```

которое представляет собой именно то, что нам нужно.

## Присваивание шаблонам выражений

Для элемента массива с аргументом `Rep`, который в рассматриваемом примере входит в шаблоны выражений `A_Mult` и `A_Add`, невозможно инстанцировать операции записи (действительно, выражение `а+b = с` не имеет смысла). Однако вполне допустимо написать другие шаблоны выражений, для которых присваивание результату возможно. Например, если массив состоит из целочисленных элементов, то он может играть роль индексов другого массива. Другими словами, выражение
```c++
х[у] = 2*х[у];
```

должно рассматриваться как
```c++
for(std::size_t idx = 0; idx < у.size(); ++idx)
{
	x[y[idx]] = 2 * x[y[idx]];
}
```

Чтобы можно было реализовать подобную операцию, в основании класса `Array` должен находиться шаблон выражения, который ведет себя как [[r-значение#l-значение|l-значение]] (т.е. позволяет выполнить в него запись). Составные части такого шаблона выражения принципиально не отличаются, например, от шаблона `A_Mult`. Единственное важное отличие состоит в том, что для операторов индексации реализуется версия с модификатором [[const|const]] и без него, и что эти операторы возвращают [[r-значение#l-значение|l-значения]] (ссылки):
```c++
template<typename Т, typename A1, typename A2>
class A_Subscript
{
	public:
		// Конструктор инициализирует ссылки на операнды
		A_Subscript(A1 const& а, А2 const& Ь)
			: a1(a), a2(b)
		{
		}
		
		// Выполнение индексации при запросе значения
		decltype(auto) operator[](std::size_t idx) const
		{
			return a1[a2[idx]];
		}
		
		T& operator[](std::size_t idx)
		{
			return a1[a2[idx]];
		}
		
		// size — размер внутреннего массива
		std::size_t sized const
		{
			return a2.size();
		}
		
	private:
		A1 consts a1; // Ссылка на первый операнд
		А2 consts а2; // Ссылка на второй операнд
};
```

Здесь [[decltуре#decltype(auto) C++14|decltype(auto)]] вновь помогает нам обработать индексацию массивов независимо от того, производит базовое представление [[r-значение#pr-значения|prvalue]] или [[rvalue|lvalue]].

Для реализации предложенного ранее расширения оператора, возвращающего элемент массива по индексу, потребуется добавить в шаблон класса `Array` дополнительные операторы индекса. Один из этих операторов можно определить как показано ниже (по-видимому, понадобится также его версия с модификатором [[const|const]]):
```c++
exprtmpl/exprops4.hpp

template<typename T, typename R>
template<typename T2, typename R2>
Array<T, A_Subscript<T, R, R2>>
Array<T, R>::operator[](Array<T2, R2> const& b)
{
	return Array<T, A_Subscript<T, R, R2>>
			(A_Subscript<T, R, R2>(*this, b));
}
```

# Производительность и ограничения шаблонов выражений

Чтобы убедить читателя в оправданности идеи шаблонов выражений, в этой главе доказывалось, что такие шаблоны позволяют значительно повысить производительность выполнения операций с массивами. Если проследить за обработкой шаблонов выражений, то можно обнаружить, что в них множество встроенных функций вызывают друг друга, и что при этом в стеке размещается множество шаблонов объектов. Чтобы получился код, работающий так же хорошо, как написанный вручную, оптимизатор должен выполнять полное встраивание и исключение небольших объектов. Во времена первого издания книги редко встречались компиляторы C++, способные выполнять эти операции. Но с тех пор ситуация существенно изменилась, несомненно, частично и из-за того, что эта методика оказалась популярной.

Метод шаблонных выражений не решает всех проблем, возникающих при выполнении численных операций с массивами. Например, он не работает при умножении матрицы на вектор, записанном в виде
```c++
х = А*х;
```

где `х` — это вектор-столбец, а `А` — квадратная матрица `nхn`. Без временного массива здесь не обойтись, поскольку каждый элемент результирующего массива зависит от каждого элемента исходного массива. К сожалению, в цикле, заданном в шаблоне выражения, первый элемент массива `х` тут же изменится, и в вычислении последующих значений этого массива будет участвовать уже не исходное, а измененное значение `х[0]`, что приведет к неправильному результату. С другой стороны, для вычисления несколько отличающегося выражения
```c++
х = А*у;
```

временный массив не нужен, если только переменные `х` и `у` не являются псевдонимами один для другого. Это означает, что во время выполнения такой операции необходимо знать о том, в каких взаимоотношениях находятся операнды. Для этого создается динамическая структура времени выполнения, представляющая дерево выражения вместо его кодирования в типе шаблона выражения. Впервые такой подход был применен Робертом Дэвисом (Robert Davies) в библиотеке NewMat задолго до того, как были разработаны шаблоны выражений.

