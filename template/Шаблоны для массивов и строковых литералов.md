
# Шаблоны для массивов и строковых литералов

При передаче в шаблоны массивов или строковых литералов требуется принять некоторые меры. Во-первых, если параметры шаблона объявляются как ссылки, к аргументам не применяется низведение типов, так что, например, переданный аргумент `"Hello"` имеет тип `char const[6]`. Это может стать проблемой при передаче массивов или строковых аргументов разной длины, потому что их типы будут различными. Только при передаче аргументов по значению выполняется низведение типов, так что строковые литералы преобразуются в тип `char const*`. Этот вопрос подробно рассмотрен в [[По значению или по ссылке|“По значению или по ссылке?”]].

Обратите внимание на то, что можно также написать шаблоны, которые работают конкретно с массивами или строковыми литералами. Например:
```c++
template<typename T, int N, int M>
bool less(T(&a)[N], T(&b)[M])
{
	for (int i = 0; i < N && i < M; ++i)
	{
		if (a[i] < b[i]) return true;
		if (b[i] < a[i]) return false;
	}
	
	return N < M;
}
```

При вызове
```c++
int x[] = {1, 2, 3};
int y[] = {1, 2, 3, 4, 5};
std::cout << less(x, y) << ' \n';
```

`less<>()` инстанцируется с `T`, представляющим собой `int`, `N`, равным 3, и `M`, равным 5.

Можно также использовать шаблон для строковых литералов:
```c++
	std::cout << less("ab","abc") << '\n';
```

В этом случае `less<>()` инстанцируется с `Т`, представляющим собой `char const`, `N`, равным 3, и `М`, равным 4.

Если вы хотите только предоставить шаблон функции для строковых литералов (и других массивов `char`), то можете сделать это следующим образом:
```c++
template<int N, int М>
bool less(char const(&a[N], char const(&b)[M])
{
	for (int i = 0; i < N && i < M; ++i)
	{
		if (a[i] < b[i]) return true;
		if (b[i] < a[i]) return false;
	}
	
	return N < M;
}
```

Обратите внимание, что можно (а иногда и нужно) выполнять перегрузку или частичную специализацию для массивов с неизвестными границами. Следующая программа иллюстрирует все возможные перегрузки для массивов:
```c++
#include <iostream>

template<typename T>
struct MyClass;         // Первичный шаблон

template<typename T, std::size_t SZ>
struct MyClass<T[SZ]>    // Частичная специализация для
{                        // массивов с известными границами
	static void print()
	{
		std::cout << "print() для T[" << SZ << "]\n";
	}
};

template<typename T, std::size_t SZ>
struct MyClass<T(&)[SZ]>  // Частичная специализация для
{                         // массивов с известными границами
	static void print])
	{
		std::cout << "print]) для T(&)[" << SZ << "]\n";
	}
};

template<typename T>
struct MyClass<T[]>       // Частичная специализация для
{                         // массивов с неизвестными границами
	static void print()
	{
		std::cout << "print() для T[]\n";
	}
};

template<typename T>
struct MyClass<T(&)[]>    // Частичная специализация для ссылок
{                         //на массивы с неизвестными границами
	static void print()
	{
		std::cout << "print() для T(&)[J\n";
	}
};

template<typename T>
struct MyClass<T*>        // Частичная специализация для указателей
{
	static void print()
	{
		std::cout << "print() для T*\n";
	}
};
```

Здесь шаблон класса `MyClass<>` специализирован для различных типов: массивов с известными и неизвестными границами, ссылок на массивы с известными и неизвестными границами и указателей. Каждый случай отличается от других и может встретиться при использовании массивов:
```c++
#include "arrays.hpp"

template<typename T1, typename T2, typename T3>
void foo(
	int a1[7], int a2[],     // Указатели по правилам языка
	int (&a3)[42],           // Ссылка на массив с известными границами
    int (&x0)[],             // Ссылка на массив с неизвестными границами
	T1 x1,                   // Передача по значению с низведением
	T2& x2, T3&& x3)         // Передача по ссылке
{
	MyClass<decltype(a1)>::print(); // Использует MyClass<T*>
	МуСlass<decltype(a2)>::print(); // Использует MyClass<T*>
	MyClass<decltype(a3)>::print(); // Использует MyClass<T(&)[SZ]>
	MyClass<decltype(xO)>::print(); // Использует MyClass<T(&)[]>
	MyClass<decltype(x1)>::print(); // Использует MyClass<T*>
	MyClass<decltype(x2)>::print(); // Использует MyClass<T(&)[]>
	MyClass<decltype(x3)>::print(); // Использует MyClass<T(&)[]>
}

int main()
{
	int a[42];
	MyClass<decltype(a)>::print(); // Использует MyClass<T[SZ]>
	
	extern int x[];                // Предварительное объявление массива
	MyClass<decltype(х)>::print(); // Использует MyClass<T[]>

	foo(a, a, a, x, x, x, x);
}

int x[] = {0, 8, 15};              // Определение предварительно
								   // объявленного массива
```

Обратите внимание на то, что параметр вызова, объявленный как массив (с длиной или без таковой), согласно правилам языка в действительности имеет тип указателя. Учтите также, что шаблоны для массивов с неизвестными границами могут использоваться для неполных типов, таких как
```c++
extern int i[];
```

При передаче по ссылке мы получаем тип `int(&)[]`, который также может использоваться в качестве параметра шаблона.

Еще один пример использования различных типов массивов в обобщенном коде приведен в [[Реализация свойств типов#Типы элементов|Типы элементов]].

