
[[#Статический и динамический полиморфизм|Статический и динамический полиморфизм]] 22
1. [[#Функциональные объекты, указатели и std function<>|Функциональные объекты, указатели и std::function<>]] 22.1
2. [[#Обобщение указателей на функции|Обобщение указателей на функции]] 22.2
3. [[#Интерфейс моста|Интерфейс моста]] 22.3
4. [[#Стирание типа|Стирание типа]] 22.4
5. [[#Условная передача владения|Условная передача владения]] 22.5
6. [[#Вопросы производительности|Вопросы производительности]] 22.6


# Статический и динамический полиморфизм

В главе, [[Полиморфная мощь шаблонов#Полиморфная мощь шаблонов|“Полиморфная мощь шаблонов”]], описана природа статического (через шаблоны) и динамического (через наследование и виртуальные функции) полиморфизма в C++. Оба вида полиморфизма предоставляют мощные абстракции для написания программ, но каждый имеет свои недостатки: статический полиморфизм обеспечивает такую же производительность, как и неполиморфный код, но набор типов, которые могут быть использованы во время выполнения, фиксируется во время компиляции. С другой стороны, динамический полиморфизм посредством наследования позволяет одной версии полиморфной функции работать с типами, не известными во время компиляции, но при этом оказывается менее гибким, потому что типы должны наследоваться от общего базового класса.

В этой главе описывается, как устранить разрыв между [[Полиморфная мощь шаблонов#Сравнение динамического и статического полиморфизма|статическим и динамическим полиморфизмом в C++]], предоставляя некоторые из преимуществ каждой модели: меньший размер выполнимого кода и (почти) полностью компилируемый характер динамического полиморфизма, наряду с гибкостью интерфейса статического полиморфизма, обеспечивающей возможность работы без всякого наследования, например со встроенными типами. В качестве примера построим упрощенную версию шаблона `function<>` стандартной библиотеки.

# Функциональные объекты, указатели и std::function<>

Функциональные объекты полезны для предоставления настраиваемого поведения для шаблонов. Например, приведенный ниже шаблон функции перечисляет целочисленные значения от 0 до некоторого значения, предоставляя каждое значение заданному функциональному объекту `f`:
```c++
#include <vector>
#include <iostream>

template<typename F>
void forUpTo(int n, F f)
{
	for (int i = 0; i != n; ++i)
		f(i);               // Вызов переданной функции f с аргументом i
}

void printInt(int i)
{
	std::cout << i << ' ';
}

int main()
{
	std::vector<int> values;
	
	// Вставка значений от 0 до 4:
	forUpTo(5, [&values](int i)
	{
		values.push_back(i);
	});
	
	// Вывод элементов:
	forUpTo(5, printInt);   // Вывод 0 1 2 3 4
	std::cout << '\n';
}
```

Шаблон функции `forUpTo()` может использоваться с любым функциональным объектом, включая лямбда-выражения, указатели на функции или любой класс, который реализует либо соответствующий `operator()`, либо преобразование в указатель на функцию или ссылку. Каждое использование `forUpTo()`, скорее всего, будет приводить к другому инстанцированию шаблона функции. Наш пример шаблона функции достаточно мал, но при достаточно большом шаблоне вполне возможно, что эти инстанцирования приведут к увеличению размера кода.

Один из способов ограничить увеличение размера кода — превратить шаблон функции в нешаблонную функцию, не требующую инстанцирования. Например, можно попытаться сделать это с помощью указателя на функцию:
```c++
void forUpTo(int n, void (*f)(int))
{
	for (int i = 0; i != n; ++i)
		f(i);               // Вызов переданной функции f для i
}
```

Однако, хотя эта реализация будет работать при передаче функции `printInt()`, при передаче лямбда-выражения мы получим ошибку:
```c++
forUpTo(5, printInt);            // ОК: Вывод 01234

forUpTo(5, [&values](int i) // Ошибка: лямбда-выражение не
			{               // преобразуется в указатель на функцию
				values.push_back(i);
			}
);
```

Шаблон класса стандартной библиотеки [[function|std::function<>]] позволяет записать функцию `forUpTo()` иначе:
```c++
#include <functional>

void forUpTo(int n, std::function<void(int)> f)
{
	for (int i = 0; i != n; ++i)
	{
		f(i);                   // Вызов переданной функции f для i
	}
}
```

Аргументом шаблона [[function|std::function<>]] является тип функции, который описывает типы параметров функционального объекта и тип возвращаемого значения, подобно тому как указатель на функцию описывает типы параметров и результата.

Такая запись `forUpTo()` предоставляет некоторые аспекты статического полиморфизма — способность работать с неограниченным набором типов, включая указатели на функции, лямбда-выражения и произвольные классы с подходящим оператором `operator()` — в то время как сама функция остается нешаблонной, с единственной реализацией. Это достигается с помощью метода под названием стирание типа (`type erasure`), который ликвидирует разрыв между статическим и динамическим полиморфизмом.

# Обобщение указателей на функции

Тип [[function|std::function<>]] по сути представляет собой обобщенный указатель на функцию C++, обеспечивая те же основные операции.
>
> Он используется для вызова функции так, что вызывающий код может не иметь никакой информации о вызываемой функции.
> 
> Он может быть скопирован, перемещен или присвоен.
> 
> Он может быть инициализирован или ему может быть присвоена другая функция (с совместимой сигнатурой).
> 
> Он имеет “нулевое” состояние, которое указывает, что с ним не связана никакая функция.

Однако в отличие от указателей на функции C++ [[function|std::function<>]] может также хранить лямбда-выражения или любой иной функциональный объект с подходящим оператором `operator()`, типы которых могут быть различными.

В оставшейся части этой главы мы будем создавать наш собственный шаблон класса обобщенного указателя на функцию, `FunctionPtr`, обеспечивающий те же основные операции и возможности, и могущий использоваться вместо
[[function|std::function<>]]:
```c++
#include "functionptr.hpp"
#include <vector>
#include <iostream>

void forUpTo(int n, FunctionPtr<void(int)> f)
{
	for (int i = 0; i != n; ++i)
	{
		f(i);                       // Вызов переданной функции f для i
	}
}

void printInt(int i)
{
	std::cout << i << ' ';
}

int main()
{
	std::vector<int> values;

	// Вставка значений от 0 до 4:
	forUpTo(5, [&values](int i)
				{
					values.push_back(i);
				}
	);
	
	// Вывод элементов:
	forUpTo(5, printInt);         // Вывод 0 1 2 3 4
	std::cout << '\n';
}
```

Интерфейс `FunctionPtr` довольно простой, обеспечивающий создание, копирование, перемещение, уничтожение, инициализацию, присваивание произвольных функциональных объектов, а также вызов базового функционального объекта. Наиболее интересной частью интерфейса является то, как все это описано полностью в рамках частичной специализации шаблона класса, служащей для разделения аргумента шаблона (типа функции) на его составные части (типы результата и аргументов):
```c++
// Первичный шаблон:
template<typename Signature>
class FunctionPtr;

// Частичная специализация:
template<typename R, typename... Args>
class FunctionPtr<R(Args...)>
{
	private:
		FunctorBridge<R, Args...>* bridge;
	public:
		// Конструкторы:
		FunctionPtr() : bridge(nullptr)
		{
		}
		
		FunctionPtr(FunctionPtr const& other); // CM.functionptr-cpinv.hpp
		
		Functionptr(FunctionPtr& other)
			: FunctionPtr(static_cast<FunctionPtr const&>(other))
		{
		}
		
		FunctionPtr(FunctionPtr&& other) : bridge(other.bridge)
		{
			other.bridge = nullptr;
		}
		
		// Построение из произвольного функционального объекта:
		// См. functionptr-init.hpp
		template<typename F> FunctionPtr(F&& f);
		
		// Операторы присваивания:
		FunctionPtr& operator=(FunctionPtr const& other)
		{
			FunctionPtr tmp(other);
			swap(*this, tmp);
			return *this;
		}
		
		FunctionPtr& operator=(FunctionPtr&& other)
		{
			delete bridge;
			bridge = other.bridge;
			other.bridge = nullptr;
			return *this;
		}
		
	// Построение и присваивание произвольного функционального объекта:
		template<typename F> FunctionPtr& operator=(F&& f)
		{
			FunctionPtr tmp(std::forward<F>(f));
			swap(*this, tmp);
			return *this;
		}
		
		// Деструктор:
		~FunctionPtr()
		{
			delete bridge;
		)
		
		friend void swap(FunctionPtr& fp1, FunctionPtr& fp2)
		{
			std::swap(fp1.bridge, fp2.bridge);
		}
		
		explicit operator bool() const
		{
			return bridge == nullptr;
		}
		
		// Вызов:
		R operator()(Args... args) const; // Cm. functionptr-cpinv.hpp
};
```

Реализация содержит единственную нестатическую переменную-член `bridge`, которая будет отвечать за хранение и работу с хранимым функциональным объектом. Владение этим указателем передано объекту `FunctionPtr`, поэтому большая часть реализации просто управляет этим указателем. Нереализованные функции содержат интересный код, который будет описан в следующих подразделах.

# Интерфейс моста

Шаблон класса `FunctorBridge` отвечает за владение базовым функциональным объектом и манипуляции с ним. Он реализован как абстрактный базовый класс, формирующий основу для динамического полиморфизма `FunctionPtr`:
```c++
template<typename R, typename... Args>
class FunctorBridge
{
	public:
	virtual ~FunctorBridge()
	{ 	}

	virtual FunctorBridge* clone () const = 0;
	virtual R invoke(Args... args) const = 0;
};
```

`FunctorBridge` предоставляет основные операции, необходимые для работы с хранимым функциональным объектом посредством виртуальных функций: деструктор, операция `clone()` для копирования и `invoke()` для вызова базового функционального объекта. Не забудьте определить `clone()` и `invoke()` как константные функции-члены.

С помощью этих виртуальных функций можно реализовать копирующий конструктор и оператор вызова функции `FunctionPtr`:
```c++
template<typename R, typename... Args>
FunctionPtr<R(Args...)>::FunctionPtr(FunctionPtr const& other)
	: bridge(nullptr)
{
	if (other.bridge)
	{
		bridge = other.bridge->clone();
	}
}

template<typename R, typename... Args>
R FunctionPtr<R(Args...)>::operator()(Args... args) const
{
	return bridge->invoke(std::forward<Args>(args)...);
}
```

# Стирание типа

Каждое инстанцирование `FunctorBridge` является абстрактным классом, поэтому его производные классы ответственны за предоставление фактических реализаций своих виртуальных функций. Для поддержки полного спектра потенциальных функциональных объектов (т.е. неограниченного их множества) нам потребуется неограниченное количество производных классов. К счастью, мы можем достичь этого путем параметризации производного класса типом хранимого функционального объекта:
```c++
template<typename Functor, typename R, typename... Args>
class SpecificFunctorBridge : public FunctorBridge<R, Args...>
{
	Functor functor;
	public:
		template<typename FunctorFwd>
		SpecificFunctorBridge(FunctorFwd&& functor)
			: functor(std::forward<FunctorFwd>(functor))
		{
		}
		
		virtual SpecificFunctorBridge* clone() const override
		{
			return new SpecificFunctorBridge(functor);
		}
		
		virtual R invoke(Args... args) const override
		{
			return functor(std::forwardCArgs>(args)...);
		}
};
```

Каждый экземпляр `SpecificFunctorBridge` хранит копию функционального объекта (типом которого является `Functor`), который может быть вызван, скопирован (путем клонирования `SpecificFunctorBridge`) или уничтожен (неявно в деструкторе). Экземпляры `SpecificFunctorBridge` создаются каждый раз, когда `FunctionPtr` инициализируется новым функциональным объектом (что завершает наш пример `FunctionPtr`):
```c++
template<typename R, typename... Args>
template<typename F>
FunctionPtr<R(Args...)>::FunctionPtr(F&& f)
	: bridge(nullptr)
{
	using Functor = std::decay_t<F>;
	using Bridge = SpecificFunctorBridge<Functor, R, Args...>;
	bridge = new Bridge(std::forward<F>(f));
}
```

Обратите внимание: в то время как сам конструктор `FunctionPtr` шаблонизируется функциональным объектом типа `F`, этот тип известен только определенной специализации `SpecificFunctorBridge` (описанной как псевдоним типа `Bridge`). После того как вновь выделенный экземпляр `Bridge` присваивается члену-данному `bridge`, дополнительная информация о конкретном типе `F` становится потерянной из-за преобразования производного типа в базовый — из `Bridge*` в `FunctorBridge<R, Args. . . >`. Эта потеря информации о типе объясняет, почему для описания методики преодоления пропасти между статическим и динамическим полиморфизмом часто используется термин стирание типа (`type erasure`).

Одной из особенностей реализации является использование [[decay|std::decay]] для получения типа `Functor`, который делает выведенный тип `F` подходящим для хранения, например, преобразуя ссылки на функциональные типы в типы указателей на функции и удаляя [[const|const]], [[volatile|volatile]] и ссылочные
типы верхнего уровня.

# Условная передача владения

Шаблон `FunctionPtr` почти полностью заменяет указатель на функцию. Именно “почти” — он пока что не поддерживает одну операцию, предоставляемую указателями на функции: проверку, будут ли два объекта `FunctionPtr` вызывать одну и ту же функцию. Добавление такой операции требует оснащения `FunctorBridge` операцией equals:
```c++
virtual bool equals(FunctorBridge const* fb) const = 0;
```

вместе с реализацией в `SpecificFunctorBridge`, которая сравнивает хранимые функциональные объекты, если они имеют одинаковые типы:
```c++
virtual bool equals(FunctorBridge<R, Args...> const* fb) const
override
{
	if (auto specFb = dynamic_cast<SpecificFunctorBridge const*>(fb))
	{
		return functor == specFb->functor;
	)
	
	// Функторы с разными типами всегда различны:
	return false;
}
```

Наконец, мы реализуем оператор `operator==` для `FunctionPtr`, который сначала проверяет функторы на нулевое значение, а затем выполняет делегирование в `FunctorBridge`:
```c++
friend bool operator==(FunctionPtr const& f1, FunctionPtr const& f2)
{
	if(!f1 || !f2)
	{
		return !f1 && !f2;
	}

	return f1.bridge->equals(f2.bridge);
}

friend bool
operator!=(FunctionPtr const& f1, FunctionPtr const& f2)
{
	return !(f1 == f2);
}
```

Эта реализация корректна. Однако она имеет достойный сожаления недостаток: если `FunctionPtr` инициализирован функциональным объектом (или этот объект ему присвоен позже), который не имеет подходящего оператора `operator==` (например, сюда входят лямбда-выражения), то программа не будет компилироваться. Это может быть сюрпризом, потому что `operator==` из `FunctionPtr` еще даже не был использован. Многие другие шаблоны классов — например, [[vector|std::vector]] — могут быть созданы с типами, которые не имеют оператора `operator==`, лишь бы этот оператор не был использован в программе для данных типов.

Данная проблема с `operator==` связана со стиранием типа: поскольку мы, по сути, теряем тип функционального объекта, при инициализации или присваивании `FunctionPtr` нужно захватить всю информацию, которую нам необходимо знать о типе, до того, как это присваивание или инициализация завершатся. Эта информация включает вызов `operator==` функционального объекта, потому что мы не можем быть уверены, потребуется ли он.

К счастью, чтобы выяснить, доступен ли `operator==`, перед тем как его вызывать, [[SFINAE#Свойства на основе SFINAE|можно воспользоваться (довольно сложным) свойством (trait) на основе SFINAE]]:
```c++
#include <utility>             // Для declval()
#include <type_traits>         // Для true_type и false_type

template<typename T>
class IsEqualityComparable
{
	private:
		// Проверка преобразуемое == и ! == в bool:
		static void* conv(bool); // Для проверки конвертируемости в bool
		template<typename U>
		static std::true_type test(
				decltype(conv(std::declval<U const&>() ==
								std::declval<U const&>())),
				decltype(conv(!(std::declval<U const&>() ==
								std::declval<U const&>())))
				);

		// Резервный вариант:
		template<typename U>
		static std::false_type test(...);
	
	public:
		static constexpr bool value = decltype(test<T>(nullptr,
													nullptr))::value;
};
```

[[SFINAE#Принцип SFINAE и перегрузки функций|Свойство `IsEqualityComparable` применяет типичный подход для проверки выражений]]: две перегрузки `test()`, одна из которых содержит тестируемое выражение, обернутое в [[decltуре|decltype]], и другая, которая содержит многоточие и потому принимает произвольные аргументы. Первая функция `test()` пытается сравнивать два объекта типа `Т const` с использованием оператора `==`, а затем убеждается, что результат может быть неявно преобразован в `bool` (для первого параметра) и передан оператору логического отрицания `operator!`) с результатом, преобразуемым в `bool`. Если обе операции корректны, оба типа параметров будут `void*`.

С помощью свойства `IsEqualityComparable` можно построить шаблон класса `TryEquals`, который может либо вызывать `==` для данного типа (если он доступен), либо вызвать исключение, если подходящего оператора `==` не существует:
```c++
#include <exception>
#include "isequalitycomparable.hpp"

template<typename T,
			bool EqComparable - IsEqualityComparable<T>::value>
struct TryEquals
{
	static bool equals(T const& x1, T const& x2)
	{
		return x1 == x2;
	)
};

class NotEqualityComparable : public std::exception
{
};

template<typename T>
struct TryEquals<T, false>
{
	static bool equals(T const& x1, T const& x2)
	{
		throw NotEqualityComparable();
	}
};
```

Наконец, c пoмoщью `TryEquals` в нaшeй peaлизaции `SpecificFunctorBridge` мы можем обеспечить поддержку для оператора `==` в `FunctionPtr` всякий раз, когда типы сохраненных функциональных объектов совпадают и функциональный объект поддерживает оператор `==`:
```c++
virtual bool equals(FunctorBridge<R, Args...> const* fb) const
override
{
	if (auto specFb = dynamic_cast<SpecificFunctorBridge const*>(fb))
	{
		return TryEquals<Functor>::equals(functor, specFb->functor);
	}

	// Функторы с разными типами не равны:
	return false;
}
```

# Вопросы производительности

Стирание типа предоставляет некоторые преимущества как статического, так и динамического полиморфизма, но не все. В частности, производительность сгенерированного с помощью стирания типа кода оказывается более близкой к динамическому полиморфизму, потому что они оба используют динамическую диспетчеризацию посредством виртуальных функций. Следовательно, такие традиционные преимущества статического полиморфизма, как способность компилятора к встраиванию вызовов, могут быть потеряны. Будет ли эта потеря производительности существенной — зависит от конкретного приложения, но зачастую ее легко оценить, рассматривая, какая работа выполняется в вызываемой функции по отношению к стоимости вызова виртуальной функции. Если эти два значения близки (например, если с помощью `FunctionPtr` просто суммировать два целых числа), то, вероятно, стирание типа будет гораздо более медленным, чем версия со статическим полиморфизмом. С другой стороны, если вызываемая функция выполняет значительный объем работы — запрос базы данных, сортировку контейнера или обновление пользовательского интерфейса, — то накладные расходы стирания типа вряд ли будут вообще измеримыми.

