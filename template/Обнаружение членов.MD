
[[#Обнаружение членов|Обнаружение членов]] 19.6
1. [[#Обнаружение членов-типов|Обнаружение членов-типов]] 19.1


# Обнаружение членов

Еще один пример свойств на основе [[SFINAE|SFINAE]] включает создание свойства
(или, скорее, набора свойств), позволяющего определить, содержит ли данный
тип Т в качестве члена некоторое имя X (как члена, являющегося типом, так и не
являющегося таковым).

## Обнаружение членов-типов

Давайте сначала определим свойство, которое выясняет, имеет ли данный тип `Т` член-тип `size_type`:
```c++
#include <type_traits> // Определения true_type и false_type

// Вспомогательный шаблон для игнорирования
// любого количества параметров шаблона:
template<typename...> using VoidT = void;

// Первичный шаблон:
template<typename, typename = VoidT<>>
struct HasSizeTypeT : std::false_type
{
};

// Частичная инициализация (может быть отброшена SFINAE):
template<typename Т>
struct HasSizeTypeT<T, VoidT<typename T::size_type>> : std::true__type
{
};
```

Здесь использован подход с отбрасыванием с помощью [[SFINAE#SFINAE и частичные специализации|SFINAE частичных специализаций]].

Как обычно для свойств-предикатов, мы определяем общий случай, производный от `std::false_type`, поскольку по умолчанию тип не имеет члена `size_type`.

В этом случае нам нужна только одна конструкция:
```c++
typename T::size_type
```

Эта конструкция корректна тогда и только тогда, когда тип `Т` имеет член-тип `size_type`, а именно это мы и пытаемся определить. Если для конкретного `Т` конструкция недопустима (т.е. тип `Т` не содержит член-тип `size_type`), [[SFINAE|SFINAE]] приводит к отбрасыванию частичной специализации, и мы возвращаемся к первичному шаблону. В противном случае частичная специализация является корректной и предпочтительной.

Свойство можно использовать следующим образом:
```c++
std::cout << HasSizeTypeT<int>::value; // false
struct CX
{
	using size_type = std::size_t;
};

std::cout << HasSizeType<CX>::value; // true
```

Обратите внимание: если член-тип `size_type` объявлен как `private`, то `HasSizeTypeT` дает значение `false`, потому что наши шаблоны свойств не имеют особого доступа к типам аргументов, так что конструкция `typename Т::size_type` является некорректной (т.е. запускает [[SFINAE|SFINAE]]). Другими словами, свойство проверяет, имеется ли доступный тип-член `size_type`.

***===Работа со ссылочными типами===***

Программисты знают о сюрпризах, которые могут возникать “на стыках” рассматриваемых предметных областей. Что касается шаблона свойства `HasSizeTypeT`, то здесь интересные проблемы возможны при работе со ссылочными типами. Например, в то время как следующий код отлично работает:
```c++
struct CXR
{
	using size_type = char&;           // Обратите внимание:
};                                     // size_type - ссылочный тип
std::cout << HasSizeTypeT<CXR>::value; // OK: выводит true
```

приведенный далее код сбоит:
```c++
std::cout << HasSizeTypeT<CX&>::value;  // Сбой: выводит false
std::cout « HasSizeTypeT<CXR&>::value;  // Сбой: выводит false
```

Это потенциально удивительно. Да, ссылочный тип не имеет членов сам по себе, но когда мы используем ссылки, получающиеся выражения имеют базовый тип, так что, пожалуй, и в этом случае было бы предпочтительнее рассмотреть базовый тип. В данной ситуации этого можно добиться, используя свойство [[remove_reference|RemoveReference]] в частичной специализации `HasSizeTypeT`:
```c++
template<typename Т>
struct HasSizeTypeT<T, VoidT<RemoveReference<T>::size_type>>
				: std::true_type
{
};
```

***===Внедренные имена классов===***








