
[[#Обнаружение членов|Обнаружение членов]] 19.6
1. [[#Обнаружение членов-типов|Обнаружение членов-типов]] 19.6.1
2. [[#Обнаружение произвольных членов-типов|Обнаружение произвольных членов-типов]] 19.6.2
3. [[#Обнаружение членов, не являющихся типами|Обнаружение членов, не являющихся типами]] 19.6.3


# Обнаружение членов

Еще один пример свойств на основе [[SFINAE|SFINAE]] включает создание свойства
(или, скорее, набора свойств), позволяющего определить, содержит ли данный
тип Т в качестве члена некоторое имя X (как члена, являющегося типом, так и не
являющегося таковым).

## Обнаружение членов-типов

Давайте сначала определим свойство, которое выясняет, имеет ли данный тип `Т` член-тип `size_type`:
```c++
#include <type_traits> // Определения true_type и false_type

// Вспомогательный шаблон для игнорирования
// любого количества параметров шаблона:
template<typename...> using VoidT = void;

// Первичный шаблон:
template<typename, typename = VoidT<>>
struct HasSizeTypeT : std::false_type
{
};

// Частичная инициализация (может быть отброшена SFINAE):
template<typename Т>
struct HasSizeTypeT<T, VoidT<typename T::size_type>> : std::true__type
{
};
```

Здесь использован подход с отбрасыванием с помощью [[SFINAE#SFINAE и частичные специализации|SFINAE частичных специализаций]].

Как обычно для свойств-предикатов, мы определяем общий случай, производный от `std::false_type`, поскольку по умолчанию тип не имеет члена `size_type`.

В этом случае нам нужна только одна конструкция:
```c++
typename T::size_type
```

Эта конструкция корректна тогда и только тогда, когда тип `Т` имеет член-тип `size_type`, а именно это мы и пытаемся определить. Если для конкретного `Т` конструкция недопустима (т.е. тип `Т` не содержит член-тип `size_type`), [[SFINAE|SFINAE]] приводит к отбрасыванию частичной специализации, и мы возвращаемся к первичному шаблону. В противном случае частичная специализация является корректной и предпочтительной.

Свойство можно использовать следующим образом:
```c++
std::cout << HasSizeTypeT<int>::value; // false
struct CX
{
	using size_type = std::size_t;
};

std::cout << HasSizeType<CX>::value; // true
```

Обратите внимание: если член-тип `size_type` объявлен как `private`, то `HasSizeTypeT` дает значение `false`, потому что наши шаблоны свойств не имеют особого доступа к типам аргументов, так что конструкция `typename Т::size_type` является некорректной (т.е. запускает [[SFINAE|SFINAE]]). Другими словами, свойство проверяет, имеется ли доступный тип-член `size_type`.

***===Работа со ссылочными типами===***

Программисты знают о сюрпризах, которые могут возникать “на стыках” рассматриваемых предметных областей. Что касается шаблона свойства `HasSizeTypeT`, то здесь интересные проблемы возможны при работе со ссылочными типами. Например, в то время как следующий код отлично работает:
```c++
struct CXR
{
	using size_type = char&;           // Обратите внимание:
};                                     // size_type - ссылочный тип
std::cout << HasSizeTypeT<CXR>::value; // OK: выводит true
```

приведенный далее код сбоит:
```c++
std::cout << HasSizeTypeT<CX&>::value;  // Сбой: выводит false
std::cout « HasSizeTypeT<CXR&>::value;  // Сбой: выводит false
```

Это потенциально удивительно. Да, ссылочный тип не имеет членов сам по себе, но когда мы используем ссылки, получающиеся выражения имеют базовый тип, так что, пожалуй, и в этом случае было бы предпочтительнее рассмотреть базовый тип. В данной ситуации этого можно добиться, используя свойство [[remove_reference|RemoveReference]] в частичной специализации `HasSizeTypeT`:
```c++
template<typename Т>
struct HasSizeTypeT<T, VoidT<RemoveReference<T>::size_type>>
				: std::true_type
{
};
```

***===Внедренные имена классов===***

Стоит также отметить, что наша техника для обнаружения членов-типов также дает значение `true` для [[Имена в шаблонах - template#Внесение имен классов|внедренных имен классов]]. Например:
```c++
struct size_type
{
};
­
struct Sizeable : size_type
{
};

static_assert(HasSizeTypeT<Sizeable>::value,
"Ошибка компилятора: отсутствует внедренное имя класса");
```

[[static_assert|static_assert]] в последней строке проходит успешно, поскольку `size_type` вводит свое собственное имя как член-тип, и это имя наследуется. Неудача означала бы, что мы нашли ошибку в компиляторе.

## Обнаружение произвольных членов-типов

Определение такого свойства, как `HasSizeTypeT`, ставит вопрос о том, как параметризовать свойство, чтобы иметь возможность проверки любого имени члена-типа.

К сожалению, в настоящее время это можно сделать только с помощью макросов, поскольку не существует механизма для описания “потенциального” имени. Лучшее, что мы можем получить в данный момент без использования макросов, — применение обобщенных лямбда-выражений, как показано в #разделе_19_6_4.

Следующий макрос вполне работоспособен:
```c++
#include <type_traits>              // true_type, false_type и void_t

#define DEFINE_HAS_TYPE(MemType)                                    \
	template<typename, typename = std::void_t<>>                    \
	struct HasTypeT_##MemType                                       \
		: std::false_type { };                                      \
	templatectypename T>                                            \
	struct HasTypeT_##MemType<T, std::void_t<typename T::MemType>>  \
				: std::true_type { }         // ; Преднамеренно опущена
```

Каждое применение `DEFINE_HAS_TYPE` (MemberType) определяет новое свойство `HasTypeT_MemberType`. Например, чтобы обнаружить, имеет ли тип члены-типы `value_type` или `char_type`, его можно использовать следующим образом:
```c++
#include "hastype.hpp"
#include <iostream>
#include <vector>

DEFINE_HAS_TYPE(value_type);
DEFINE_HAS_TYPE(char_type);

int main()
{
	std::cout << "int: : value__type : "
				<< HasTypeT_value_type<int>::value << '\n';
				
	std::cout << "std::vector<int>::value_type: "
				<< HasTypeT_value_type<std::vector<int>>::value << '\n';
	
	std::cout << "std::iostream::value_type: "
				<< HasTypeT_value_type<std::iostream>::value << '\n';

	std::cout << "std::iostream::char_type: "
				<< HasTypeT_char_type<std::iostream>::value << '\n';
```

## Обнаружение членов, не являющихся типами

Мы можем изменить свойства так, чтобы они также проверяли наличие членов-данных и (одиночных) функций-членов:
```c++
#include <type_traits>           // true_type, false_type и void_t

#define DEFINE_HAS_MEMBER(Member)                                     \
	template<typename, typename = std::void_t<>>                      \
	struct HasMemberT_##Member                                        \
		: std::false_type { };                                        \
	template<typename T>                                              \
	struct HasMemberT_##Member<T, std::void_t<decltype(&T::Member)>>  \
	: std::true type { }             // ; Преднамеренно опущена
```

Здесь мы используем [[SFINAE|SFINAE]] для отключения частичной специализации, когда выражение `&Т::Member` некорректно. Чтобы эта конструкция была корректной, должны выполняться следующие условия:
>
> Member должен однозначно идентифицировать член `Т` (например, он не может быть именем перегруженной функции или именем нескольких унаследованных членов с одинаковым именем);
> 
> этот член должен быть доступным;
> 
> член не должен быть типом или перечислением (в противном случае префикс `&` будет некорректным);
> 
> если `Т::Member` является статическим членом-данным, его тип не должен предоставлять `operators`, который делает `&Т::Member` некорректным выражением (например потому, что этот оператор недоступен).

Этот шаблон можно использовать следующим образом:
```c++
#include "hasmember.hpp"
#include <iostream>
#include <vector>
#include <utility>

DEFINE_HAS_MEMBER(size);
DEFINE_HAS_MEMBER(first);

int main()
{
	std::cout << "int::size: "
				<< HasMemberT size<int>::value << ' \n';
				
	std::cout << "std::vector<int>::size : "
				<< HasMemberT_size<std::vector<int>>:lvalue << ' \n';

	std::cout << "std::pair<int,int>::first: "
				<< HasMemberT_first<std::pair<int, int>>::value << 1 \n'
```

He должно быть сложным изменение частичной специализации для исключения случаев, когда `&Т::Member` не является типом указателя на член (тем самым исключая статические члены-данные). Аналогично можно исключить указатель на функцию-член либо потребовать ограничения свойства членами-данными или функциями-членами.

***===Обнаружение функций-членов===***

Обратите внимание на то, что свойство `HasMember` лишь проверяет, существует ли единственный элемент с соответствующим именем. Свойство будет не работоспособным при обнаружении двух членов, что возможно во время проверки перегруженных функций-членов. Например:
```c++
DEFINE_HAS_MEMBER(begin);
std::cout << HasMemberT_begin<std::vector<int>>::value;    // false
```

Однако, [[SFINAE#Выражение SFINAE с decltype|принцип SFINAE защищает от попыток создать недопустимые типы и выражения в объявлении шаблона функции, позволяя расширить методику перегрузки для проверки корректности произвольных выражений]].

То есть можно просто проверить, возможно ли вызвать интересующую функцию определенным образом, и будет ли этот вызов успешным, даже если функция перегружена. Как и в случае со свойством [[IsConvertibleT#IsConvertibleT|IsConvertibleT]], трюк заключается в создании выражения, которое проверяет, можно ли вызвать `begin()` внутри выражения [[decltуре|decltype]] для значения по умолчанию дополнительного параметра шаблона функции:
```c++
#include <utility>          // Для declval
#include <type_traits>      // Для true_type, false_type и void_t

// Первичный шаблон:
template<typename, typename = std::void__t<>>
struct HasBeginT : std::false_type
{
};

// Частичная инициализация (может быть отброшена SFINAE):
template<typename Т>
struct HasBeginT<T, std::void_t<decltype(std::declval<T>().begin())>>
			: std::true_type
{
};
```

Здесь мы используем
```c++
decltype(std::declval<T>().begin())
```

чтобы для данного значения/объекта типа `Т` проверить (с помощью `std::declval`, чтобы избежать необходимости наличия любого конструктора) корректность вызова члена `begin()`.

***===Обнаружение других выражений===***















