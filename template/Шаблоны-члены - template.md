
[[#Шаблоны-члены]]
1. [[#Конструкция .template|Конструкция .template]] 5.5.1
2. [[#Обобщенные лямбда-выражения и шаблоны членов|Обобщенные лямбда-выражения и шаблоны членов]] 5.5.2

# Шаблоны-члены

Члены классов тоже могут быть шаблонами. Это справедливо как для вложенных классов, так и для функций-членов. Применение и преимущества такой возможности можно еще раз продемонстрировать на примере шаблона класса `Stack<>`. Обычно стеки можно присваивать друг другу только в том случае, если они имеют одинаковый тип, что предполагает одинаковый тип их элементов. Однако стеку невозможно присвоить стек с элементами любого другого типа, даже если для типов элементов определено неявное преобразование типов:
```c++
Stack<int> intStack1, intStack2;        // Стеки для int
Stack<float> floatStack;                // Стек для float

intStackl = intStack2;                  // OK: стеки имеют одинаковые типы
floatStack = intStack1;                 // Ошибка: разные типы стеков
```

Оператор присваивания по умолчанию требует, чтобы с обеих сторон оператора использовался один и тот же тип, но если типы элементов у стеков различны, то это не так.

Однако если определить оператор присваивания в виде шаблона, то присваивание стеков с элементами, для которых определено соответствующее преобразование типов, станет возможным. Для этого необходимо объявить `Stack<>`, как показано ниже.
```c++
template<typename Т>
class Stack
{
	private:
		std::deque<T> elems;   // Элементы

	public:
		void push(T const&);   // Добавление элементов в стек
		void pop ();           // Снятие со стека
		T consts top() const;  // Возврат верхнего элемента
		
		bool empty() const     // Проверка пустоты стека
		{
			return elems.empty();
		}

		// Присваивание стека с элементами типа Т2
		template<typename Т2>
		Stacks operator= (Stack<T2> const&);
};
```

Были сделаны два изменения.
1. Добавлено объявление оператора присваивания для стеков с элементами другого типа Т2.
2. Теперь в качестве внутреннего контейнера для элементов стека используется дек [[deque|std::deque<>]]. Это следствие реализации нового оператора присваивания.

Реализация нового оператора присваивания показана ниже.
```c++
template<typename T>
template<typename T2>
Stack<T>& Stack<T>::operator= (Stack<T2> const& op2)
{
	Stack<T2> tmp(op2);    // Создание копии присваиваемого стека
	elems.clear();         // Удаление существующих элементов

	while (!tmp.empty()) // Копирование всех элементов
	{
		elems.push_front(tmp.top());
		tmp.pop();
	}
	
	return *this;
}
```

Прежде всего посмотрим на синтаксис определения шаблона-члена. Внутри шаблона с параметром `Т` определяется внутренний шаблон с параметром `Т2`:
```c++
template<typename Т>
template<typename Т2>
```

Казалось бы, в теле функции-члена можно просто обращаться ко всем необходимым данным присваиваемого стека `ор2`. Однако этот стек имеет другой тип (при инстанцировании шаблона класса для двух разных типов данных будут получены стеки двух разных типов), поэтому вы ограничены только использованием открытого интерфейса. Отсюда следует, что единственный способ обращения к элементам стека — это вызов `top()`. Однако для этого каждый элемент должен оказаться в вершине стека. Таким образом, сначала нужно сделать копию `ор2`, чтобы можно было удалять элементы при помощи вызовов `pop()`. Поскольку функция `top()` возвращает последний элемент, помещенный в стек, необходимо использовать контейнер, который поддерживает вставку элементов в противоположный конец коллекции. По этой причине здесь используется [[deque|дек std::deque<>]], у которого имеется функция `push_front()`, помещающая элемент в начало коллекции.

Для доступа ко всем членам `ор2` можно объявить все прочие экземпляры стеков друзьями:
```c++
template<typename Т>
class Stack
{
	private:
		std::deque<T> elems;    // Элементы

	public:
		void push(T consts);    // Добавление элементов в стек
		void pop();             // Снятие co стека
		T const& top() const;   // Возврат верхнего элемента
		
		bool empty() const      // Проверка пустоты стека
		{
			return elems.empty();
		}
		
		// Присваивание стека с элементами типа Т2
		template<typename Т2>
		Stacks operator= (Stack<T2> const&);
		
		// Для доступа к закрытым членам Stack<T2> для любого типа Т2:
		template<typename> friend class Stack;
};
```

Как можно видеть, поскольку имя параметра шаблона не используется, оно может быть опущено:
```c++
template<typename> friend class Stack;
```

После такого объявления возможна следующая реализация шаблонного оператора присваивания:
```c++
template<typename T>
template<typename T2>
Stack<T>& Stack<T>::operator= (Stack<T2> const& op2)
{
	elems.clear();               // Удаление существующих элементов
	elems.insert(elems.begin() , // Вставка в начало
				op2.elems.begin{) , // всех элементов из ор2
				op2.elems.end());
	
	return *this;
```

Независимо от того, какой реализацией вы воспользуетесь, при наличии такого шаблона-члена можно присвоить стек `int` стеку `float`:
```c++
Stack<int> intStack;      // Стек для int
Stack<float> floatStack;  // Стек для float
floatStack = intStack;    // OK: Стеки имеют различные типы,
						  //но int преобразуется в float
```

Разумеется, такое присваивание не изменяет типа стека и его элементов. После присваивания тип элементов `floatStack` остается `float` и, следовательно, функция `pop()` будет по-прежнему возвращать значение типа `float`.

Может показаться, что проверка типов в этой функции отсутствует вообще, так что можно выполнять присваивание стеков с элементами любого типа, но это не так. Необходимая проверка типов происходит, когда элемент (копии) исходного стека помещается в результирующий стек:
```c++
elems.push_front(tmp.top()) ;
```

Если, например, стек строк присвоить стеку значений с плавающей точкой, при компиляции этой строки будет выдано сообщение об ошибке, в котором будет сказано, что строка, возвращаемая функцией `tmp.top()`, не может быть передана как аргумент функции `elems.push_front()` (в зависимости от компилятора сообщения могут быть различными, но смысл их именно такой).
```c++
Stack<std::string> stringStack; // Стек строк
Stack<float> floatStack;        // Стек чисел с плавающей точкой

...

floatStack = stringStack;       // Ошибка: string не преобразуется в float
```

Можно также изменить реализацию так, чтобы параметризовать тип внутреннего контейнера.
```c++
template<typename Т, typename Cont = std::deque<T>>
class Stack
{
	private:
		Cont elems;          // Элементы
		
	public:
		void push(T consts); // Добавление элементов в стек

		void pop();          // Снятие со стека
		T consts top() const;// Возврат верхнего элемента

		bool empty() const   // Проверка пустоты стека
		{
			return elems.empty();
		}
		
	// Присваивание стека с элементами типа Т2
	template<typename Т2, typename Cont2>
	Stacks operator= (Stack<T2, Cont2> const&);
	
	// Для доступа к закрытым членам Stack<T2> для любого типа Т2:
	template<typename, typename> friend class Stack;
```

Шаблон оператора присваивания будет выглядеть, как показано ниже.
```c++
template<typename Т, typename Cont>
template<typename T2, typename Cont2>
Stack<T, Cont>& Stack<T, Cont>::operator= (Stack<T2, Cont2> consts op2)
{
	elems.clear();               // Удаление существующих элементов
	elems.insert(elems.begin(),  // Вставка в начало
				op2.elems.begin()// всех элементов из ор2
				op2.elems.end() ) ;

	return *this;
}
```

Вспомним, что у шаблонов классов инстанцируются только вызываемые функции-члены. Таким образом, если избегать присваивания стеков с элементами разных типов, в качестве внутреннего контейнера вполне можно использовать вектор:
```c++
// Стек для int с использованием вектора в качестве контейнера
Stack<int, std::vector<int>> vStack;
vStack.push(42) ;
vStack.push(7);

std::cout << vStack.top() << '\n';
```

Поскольку необходимости в операторе присваивания нет, сообщение об ошибке отсутствия функции-члена `push_front()` не выдается, и программа работает корректно.

> **Специализация шаблонов функций-членов**

Шаблоны функций-членов также могут быть частично или полностью специализированы. Например, для класса
```c++
class BoolString
{
	private:
		std::string value;
		
	public:
		BoolString(std::string const& s)
		: value(s)
		{    }

	template<typename T = std::string>
	T get() const     // Получение значения (преобразованного в Т)
	{
		return value;
	}
};
```

можно предоставить полную специализацию для шаблона функции-члена следующим образом:
```c++
// Полная специализация BoolString::getValue<>() для bool
template<>
inline bool BoolString::get<bool>() const
{
	return value == "true" || value == "1" || value == "on";
}
```

Учтите, что вам не нужно (и нельзя) объявлять специализации; вы можете только определять их. Поскольку это полная специализация, которая находится в заголовочном файле, необходимо объявить ее как [[inline|inline]], чтобы избежать ошибок при включении определения в различные единицы трансляции.

Класс и полную специализацию можно использовать следующим образом:
```c++
std::cout << std::boolalpha;
BoolString si("hello");
std::cout << s1.get() << '\n';          // Вывод hello
std::cout << s1.get<bool>() << ' \n';>  // Вывод false
BoolString s2 ("on");
std::cout << s2.get<bool>() << '\n';    // Вывод true
```

> **Шаблоны специальных функций-членов**

Шаблоны функций-членов могут использоваться везде, где специальные функции-члены позволяют копирование или перемещение объектов. Подобно операторам присваивания, определенным выше, они могут также быть конструкторами. Однако обратите внимание на то, что шаблоны конструкторов и операторов присваивания не заменяют стандартные предопределенные конструкторы и операторы присваивания. Шаблоны-члены не рассматриваются как специальные функции-члены, которые копируют или перемещают объекты. В рассмотренном примере при присваивании стеков одного и того же типа по-прежнему вызывается оператор присваивания по умолчанию.

Это может быть и хорошо, и плохо.

* Может случиться так, что шаблон конструктора или оператора присваивания обеспечивает лучшее совпадение, чем предопределенный копирующий/перемещающий конструктор или оператор присваивания, хотя шаблонная версия используется только для инициализации других типов (подробности см. в #разделе_6_2).
* Не так просто “шаблонизировать” копирующий/перемещающий конструктор, например, чтобы иметь возможность ограничить его существование (подробности см. в #разделе_6_4).

## Конструкция .template

Иногда необходимо явным образом квалифицировать аргументы шаблона при вызове шаблона-члена. В этом случае вы должны использовать ключевое слово `template`, чтобы гарантировать, что `<` представляет собой начало списка аргументов шаблона. Рассмотрим пример, в котором используется стандартный тип [[bitset|bitset]]:
```c++
template<unsigned long N>
void printBitset(std::bitset<N> const& bs)
{
	std::cout << bs.template to_string<char, std::char_traits<char>,
										std::allocator<char>>();
}
```

Для битового множества `bs` мы вызываем шаблонную функцию-член `to_string()`, явно указывая подробности типа строки. Без дополнительного применения `.template` компилятор не знает, что следующий далее токен `“меньше”` (`<`) на самом деле является не оператором `“меньше”`, а началом списка аргументов шаблона. Обратите внимание: это является проблемой, только если конструкция перед точкой зависит от параметра шаблона. В нашем примере параметр `bs` зависит от параметра шаблона `N`.

Запись `.template` (и аналогичные записи наподобие `->template` и `::template`) должны использоваться только внутри шаблонов и только если они следуют за выражением, которое зависит от параметра шаблона. Более подробно этот вопрос рассматривается в #разделе_13_3_3.

## Обобщенные лямбда-выражения и шаблоны членов

Обратите внимание на то, что обобщенные лямбда-выражения, введенные в C++14, являются сокращениями шаблонов членов. Простое лямбда-выражение, вычисляющее “сумму” двух аргументов произвольного типа
```c++
[] (auto х, auto у)
{
	return х + у;
}
```

представляет собой сокращение для конструируемого по умолчанию объекта следующего класса:
```c++
class SomeCompilerSpecificName
{
	public:
		SomeCompilerSpecificName();     // Конструктор вызывается
										// только компилятором
		template<typename T1, typename T2>
		auto operator()(T1 x, T2 y) const
		{
			return x + y;
		};
};
```

Подробности представлены в #разделе_15_10_6.
