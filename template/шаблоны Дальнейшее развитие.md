
[[#Дальнейшее развитие|Дальнейшее развитие]] 17
1. [[#Ослабленные правила применения typename|Ослабленные правила применения typename]] 17.1
2. [[#Обобщенные параметры шаблонов, не являющиеся типами|Обобщенные параметры шаблонов, не являющиеся типами]] 17.2
3. [[#Частичная специализация шаблонов функций|Частичная специализация шаблонов функций]] 17.3
4. [[#Именованные аргументы шаблонов|Именованные аргументы шаблонов]] 17.4



# Дальнейшее развитие

Шаблоны C++ существенно эволюционировали со времени их первоначального появления в 1988 году, пройдя через различные этапы стандартизации в 1998, 2011, 2014 и 2017 годах. Можно сказать, что большинство добавлений в стандарт после разработки стандарта 1998 было связано с шаблонами.

В первом издании этой книги перечислен ряд расширений, которые мы могли бы увидеть в последующих стандартах; некоторые из них стали реальностью.
>
> Проблема с угловыми скобками: в C++11 убрана необходимость вставки пробела между двумя закрывающими угловыми скобками.
> 
> Аргументы шаблонов функций по умолчанию: C++11 позволяет шаблонам функций иметь аргументы шаблонов по умолчанию.
> 
> Шаблоны [[typedef|typedef]]: в С++11 в стандарт введены подобные по свойствам шаблоны псевдонимов.
> 
> Оператор `typeof`: в C++11 введен оператор [[decltуре|decltype]], который играет туже роль (но использует иное имя во избежание конфликтов с существующим расширением, которое не вполне отвечает нуждам сообщества программистов C++).
> 
> Статические свойства: в первом издании предполагается выбор свойств типов, непосредственно поддерживаемых компиляторами. Это сделано, хотя интерфейс выражается с использованием стандартной библиотеки (которая для многих свойств реализуется с помощью расширений компилятора).
> 
> Пользовательская диагностика инстанцирования: новое ключевое слово [[static#static_assert|static_assert]] реализует идею, изложенную в описании `std::instantiation_error` в первом издании данной книги.
> 
> Параметры-списки: реализованы как ***пакеты параметров*** в C++11.
> 
> Управление размещением в памяти: операторы С++11 [[alignof#alignof|alignof]] и [[alignas#alignas|alignas]] охватывают нужды программистов, описанные в первом издании книги. Кроме того, в стандартную библиотеку C++17 добавлен шаблон [[variant|std::variant]], поддерживающий размеченные объединения.
> 
> Вывод на основе инициализаторов: в C++17 добавлен вывод аргументов шаблонов классов, который решает те же вопросы.
> 
> Функциональные выражения: лямбда-выражения C++11 в точности обеспечивают данную функциональность (с синтаксисом, несколько отличным от обсуждавшегося в первом издании).

Прочие предположительные направления развития, о которых писалось в первом издании, в современном языке отсутствуют, но большинство из них время от времени по-прежнему обсуждаются, так что мы оставим их и в этой книге. Тем временем появляются новые идеи, некоторые из которых также будут представлены далее.

# Ослабленные правила применения typename

В первом издании книги в этом разделе было высказано предположение, что будущее может принести [[Имена в шаблонах#Зависимые имена типов|два вида ослабления правил использования typename]]: разрешить применение `typename` там, где оно не было разрешено ранее, и сделать необязательным использование `typename` там, где компилятор может относительно легко определить, что квалифицированное имя с зависимым квалификатором должно быть именем типа. Первое предположение сбылось (`typename` в C++! 1 может избыточно использоваться во многих местах), а последнее — нет.

Недавно, однако, наблюдалась новая попытка сделать `typename` необязательным в различных распространенных контекстах, где однозначно предполагается спецификатор типа.
>
> Тип возвращаемого значения и типы параметров функций в объявлениях функций и функций-членов в областях видимости пространств имен и классов. То же относится и к шаблонам функций и функций-членов, а также лямбда-выражений в любой области видимости.
> 
> Типы в объявлениях переменных, шаблонов переменных и статических членов-данных. То же самое относится и к шаблонам переменных.
> 
> Тип после токена `=` в объявлении псевдонима или шаблона псевдонима.
> 
> Аргумент по умолчанию параметра типа шаблона.
> 
>  Тип в угловых скобках после конструкций [[static_cast|static_cast]], [[const_cast|const_cast]], [[dynamic_cast|dynamic_cast]] или [[reinterpret_cast|reinterpret_cast]].
>  
> Тип, именованный в выражении [[new|new]].

Хотя это не слишком продуманный список, оказывается, что такие изменения в языке позволили бы устранить большинство применений `typename`, что сделало бы код более компактным и удобочитаемым.

# Обобщенные параметры шаблонов, не являющиеся типами

Пожалуй, и для начинающих, и для опытных программистов, пишущих шаблоны, самое удивительное из всех ограничений на аргументы шаблонов, не являющиеся типами, состоит в том, что строковый литерал невозможно использовать в качестве аргумента шаблона.

Приведенный ниже пример интуитивно понятен:
```c++
template<char const* msg>
class Diagnoser
{
	public:
		void print();
};

int main()
{
	Diagnoser<"Surprise!">().print() ;
}
```

Однако здесь есть ряд потенциальных проблем. В стандарте C++ два экземпляра класса `Diagnoser` будут принадлежать одному и тому же типу тогда и только тогда, когда у них одни и те же аргументы. В данном случае аргумент является указателем, другими словами — адресом. Однако у двух идентичных строковых литералов, расположенных в разных местах исходного кода, не обязательно должен быть один и тот же адрес. Таким образом, можно оказаться в неловкой ситуации, когда классы `Diagnoser<"X">` и `Diagnoser<"X">` будут представлять два разных несовместимых типа! (Обратите внимание на то, что `"X"` имеет тип `char const[2]`, но когда он передается в качестве аргумента шаблона, его тип низводится до `char const*`.)

Исходя из этих (и других, связанных с ними) соображений, в стандарте C++ запрещено использовать строковые литералы в качестве аргументов шаблонов. Однако в некоторых реализациях такая возможность существует в виде расширения. Это обеспечивается использованием содержимого строковых литералов во внутреннем представлении экземпляра шаблона. Хотя это вполне осуществимо, некоторые толкователи языка C++ полагают, что не являющийся типом параметр шаблона, который может замещаться строковым литералом, должен объявляться иначе, чем параметр, который может замещаться адресом. Одной из возможностей является захват строковых литералов в пакет параметров символов, например:
```c++
template<char... msg>
class Diagnoser
{
	public:
		void print();
};

int main()
{
	// Инстанцирует Diagnoser<'S','u1,'r','p','r','i',1s','e', '!'>
	Diagnoser<"Surprise! ">().print();
}
```

Кроме того, следует отметить, что в данном вопросе кроется один дополнительный технический недостаток. Рассмотрим следующие объявления шаблонов и предположим, что язык расширен так, чтобы строковые литералы могли использоваться в качестве аргументов шаблонов:
```c++
template<char const* str>
class Bracket
{
	public:
		static char const* address());
		static char const* bytes());
};

template<char const* str>
char const* Bracket<str>::address()
{
	return str;
}

template<char const* str>
char const* Bracket<str>::bytes()
{
	return str;
}
```

В этом коде две функции-члена идентичны во всем, кроме своих имен, — ситуация не такая уж и редкая. Предположим, что некоторая реализация инстанцирует `Bracket<"X">` с помощью процесса, подобного макрорасширению: тогда, если эти две функции-члена инстанцируются в разных единицах трансляции, они могут возвращать разные значения. Интересно, что тестирование некоторых компиляторов языка C++, имеющих данное расширение, показало, что они обладают таким удивительным поведением.

С этим вопросом связан и вопрос о возможности использования литералов с плавающей точкой (и простых константных выражений с плавающей точкой) в качестве аргументов шаблонов, например:
```c++
template<double Ratio>
class Converter
{
	public:
		static double convert(double val)
		{
			return val * Ratio;
		}
};

using InchToMeter = Converter<0.0254>;
```

Эта возможность также имеется в некоторых реализациях языка C++, и она не представляет собой серьезной технической задачи (в отличие от использования строковых литералов в качестве аргументов).

В C++11 вводится понятие ***литерального типа класса***: тип класса, который может принимать константное значение, вычисляемое во время компиляции (включая нетривиальные вычисления с использованием [[constexpr|constexpr]]-функций). После того как такие типы классов стали доступны, тут же стало желательно позволить им быть параметрами шаблонов, не являющимися типами. Однако при этом возникают проблемы, аналогичные описанным выше проблемам, связанным с использованием в качестве параметров строковых литералов. В частности, “равенство” двух значений типа класса является отнюдь не тривиальным вопросом, потому что в общем случае оно определяется с помощью оператора `operator==`. Это равенство определяет, эквивалентны ли два экземпляра, но на практике такая эквивалентность должна проверяться компоновщиком путем сравнения декорированных имен. Одним из выходов может быть вариант, при котором определенные литеральные классы помечаются как имеющие тривиальный критерий равенства, обеспечивающий попарное сравнение скалярных членов класса, после чего в качестве параметров шаблонов, не являющихся типами, могут использоваться только типы классов с таким тривиальным критерием равенства.

# Частичная специализация шаблонов функций

[[Шаблоны Специализация и перегрузка|отмечалось, что шаблоны классов можно частично специализировать, тогда как шаблоны функций просто перегружают]]. Эти два механизма различаются между собой.

При частичной специализации не создается полностью новый шаблон: это просто расширение существующего (первичного) шаблона. Когда выбирается шаблон класса, сначала рассматриваются только первичные шаблоны. Если после выбора первичного шаблона оказывается, что существует его частичная специализация с аргументами шаблона, соответствующими данному инстанцированию, его определение (или, другими словами, его тело) инстанцируется вместо определения первичного шаблона (при полной специализации шаблона все выполняется точно так же).

Перегруженные шаблоны функций, напротив, являются отдельными шаблонами, полностью независимыми друг от друга. Когда компилятор решает, какой именно шаблон инстанцировать, он рассматривает все перегруженные шаблоны и выбирает наиболее подходящий. На первый взгляд такой подход кажется вполне адекватным, однако на практике имеется ряд ограничений.
>
> Можно специализировать шаблоны — члены класса без изменения определения этого класса. Однако добавление перегруженного члена требует изменения в определении класса. Во многих случаях этот вариант невозможен, так как у программиста может не быть на это прав. Более того, существующий стандарт языка C++ не позволяет программистам добавлять новые шаблоны в пространство имен `std`, но позволяет специализировать шаблоны из этого пространства имен.
> 
> Чтобы перегрузка шаблонов функций была возможна, параметры этих функций должны различаться каким-то существенным образом. Рассмотрим шаблон функции `R convert (T const&)`, где `R` и `T` — параметры шаблона. Этот шаблон вполне можно специализировать для `R = void`, но с помощью перегрузки этого сделать нельзя.
> 
> Код, который корректен для неперегруженной функции, может перестать быть корректным, когда эта функция перегружается. В частности, если есть два шаблона функций `f(Т)` и `g(Т)` (где `Т` — параметр шаблона), выражение `g(&f<int>)` корректно только в случае, если функция `f` не перегружена (в противном случае будет невозможно решить, какая именно функция `f` имеется в виду).
> 
> Дружественные объявления относятся к определенному шаблону функции или инстанцированию определенного шаблона функции. Перегруженная версия шаблона функции не будет автоматически иметь привилегии, которыми обладает исходный шаблон.

В целом этот список представляет собой убедительный аргумент в пользу частичной специализации шаблонов функций.

Естественным синтаксисом частичной специализации шаблонов функций является обобщение записи для шаблона класса.
```c++
template<typename Т>
Т consts max(T const&, Т const&);         // Первичный шаблон

template<typename Т>
Т* const& max <Т*>(Т* const&, Т* const&);// Частичная специализация
```

Некоторых разработчиков языка беспокоит взаимодействие такого подхода к частичной специализации и перегрузки шаблонов функций. Например:
```c++
template<typename Т>
void add(T& х, int i);     // Первичный шаблон

template<typename T1, typename T2>
void add(T1 a, T2 b);      // Другой (перегруженный) первичный шаблон

template<typename Т>
void add<T*>(Т*&,int);     // Какой из первичных шаблонов специализирован?
```

Однако мы ожидаем, что такие ошибки не окажут значительного влияния на полезность данной функциональной возможности.

Это расширение вкратце обсуждалось во время работы над стандартом C++11, но в итоге собрало относительно мало голосов. Тем не менее эта тема время от времени возрождается, потому что такое нововведение могло бы аккуратно решать некоторые общие проблемы программирования. Возможно, к ее рассмотрению вновь вернутся в некоторых будущих версиях стандарта C++.

# Именованные аргументы шаблонов


















