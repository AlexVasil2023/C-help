
[[#Специализация и перегрузка|Специализация и перегрузка]] 16
1. [[#Когда обобщенный код недостаточно хорош|Когда обобщенный код недостаточно хорош]] 16.1
	1. [[#Прозрачная настройка|Прозрачная настройка]] 16.1.1
	2. [[#Семантическая прозрачность|Семантическая прозрачность]] 16.1.2
2. [[#Перегрузка шаблонов функций|Перегрузка шаблонов функций]] 16.2
	1. [[#Сигнатуры|Сигнатуры]] 16.2.1
	2. [[#Частичное упорядочение перегруженных шаблонов функций|Частичное упорядочение перегруженных шаблонов функций]] 16.2.2
	3. [[#Правила формального упорядочения|Правила формального упорядочения]] 16.2.3
	4. [[#Шаблоны и нешаблоны|Шаблоны и нешаблоны]] 16.2.4
	5. [[#Вариативные шаблоны функций|Вариативные шаблоны функций]] 16.2.5
3. [[#Явная специализация|Явная специализация]] 16.3
	1. [[#Полная специализация шаблона класса|Полная специализация шаблона класса]] 16.3.1
	2. [[#Полная специализация шаблона функции|Полная специализация шаблона функции]] 16.3.2
	3. [[#Полная специализация шаблона переменной|Полная специализация шаблона переменной]] 16.3.3
4. [[#Частичная специализация шаблона класса|Частичная специализация шаблона класса]] 16.4
5. [[#Частичная специализация шаблонов переменных|Частичная специализация шаблонов переменных]] 16.5

# Специализация и перегрузка

Сейчас вы уже знаете, как шаблоны C++ обеспечивают расширение обобщенного определения в семейство связанных классов, функций или переменных. Хотя это и мощный механизм, существует много ситуаций, в которых при замене параметров шаблона обобщенная форма работы далека от оптимальной.

Язык C++ в определенной мере уникален среди прочих популярных языков программирования с поддержкой обобщенного программирования, поскольку обладает богатым набором возможностей, позволяющих осуществлять прозрачную подмену обобщенного определения более специализированными. В этой главе представлены два механизма языка C++, которые позволяют реализовать полезные отступления от обобщенного подхода: специализация шаблона и перегрузка шаблонов функций.

## Когда обобщенный код недостаточно хорош

Рассмотрим следующий пример:
```c++
template<typename Т>
class Array
{
	private:
		Т* data;

		...
	public:
		Array(Array<T> const&);
		Array<T>& operator= (Array<T> const&);
		
		void exchangeWith(Array<T>* b)
		{
			T* tmp = data;
			data = b->data;
			b->data = tmp;
		}
		
		T& operator[](std::size_t k)
		{
			return data[k];
		}
	
		...
};

template<typename T> inline
void exchange(T* a, T* b)
{
	T tmp(*a);
	*a = *b;
	*b = tmp;
}
```

Для простых типов обобщенная реализация функции `exchange()` работает хорошо. Однако для типов с дорогостоящими операциями копирования обобщенная реализация может быть значительно более ресурсоемкой (как в плане использования машинного времени, так и памяти), чем реализация, настроенная под конкретную структуру данных. В нашем примере обобщенная реализация требует одного вызова конструктора копирования шаблона `Аrrау<Т>` и двух вызовов оператора копирующего присваивания. Для больших структур данных создание таких копий часто сопровождается копированием относительно больших объемов памяти. Однако функциональность `exchange()` часто может заменяться простым обменом указателями, подобно тому, как это делается в функции-члене `exchangeWith()`.

## Прозрачная настройка

В предыдущем примере функция-член `exchangeWith()` обеспечивала эффективную альтернативу обобщенной функции `exchange()`. Тем не менее по ряду причин использование другой функции неудобно.
>
> Пользователи класса [[Array|Array]] должны помнить о дополнительном интерфейсе и по возможности аккуратно им пользоваться.
> 
> Обобщенные алгоритмы в общем случае не могут различать различные возможные варианты. Например:
```c++
template<typename Т>
void genericAlgorithm(T* х, Т* у)
{
	...
	
	exchange(х, у); // Как выбрать правильный алгоритм?

	...
}
```

По этим соображениям шаблоны C++ обеспечивают прозрачные способы настройки шаблонов функций и классов. Для шаблонов функций это достигается через механизм перегрузки. Например, можно написать перегруженный набор
шаблонов функций `quickExchange()`, как показано ниже.
```c++
template<typename Т>
void quickExchange(Т* а, Т* Ь)      // #1
{
	Т tmp(*а);
	*а = *Ь;
	*b = tmp;
}

template<typename Т>               // #2
void quickExchange(Аггау<T>* a, Array<T>* b)
{
	a->exchangeWith(b);
}

void demo(Array<int>* p1, Array<int>* p2)
{
	int x = 42, у = -7;
	quickExchange(&x, &y);         // Используется #1 
	quickExchange(p1, p2);         // Используется #2
}
```

Первый вызов `quickExchange()` имеет два аргумента типа `int*`, поэтому вывод аргументов выполняется успешно только для первого шаблона, объявленного в строке `#1`, когда тип `Т` заменяется типом `int`. Поэтому не возникает сомнений относительно того, какую функцию нужно вызвать. Второй же вызов соответствует обоим шаблонам: подходящие функции для вызова `quickExchange (p1, р2)` получаются как подстановкой `Array<int>` вместо `Т` в первом шаблоне, так и подстановкой `int` во втором шаблоне. Кроме того, обе подстановки дают функции с типами параметров, которые точно соответствуют типам аргументов во втором вызове. Обычно это позволяет заключить, что вызов неоднозначен, однако (как выяснится позже) язык C++ считает второй шаблон “более специализированным”, чем первый. При прочих равных условиях разрешение перегрузки отдает предпочтение более специализированному шаблону, и поэтому выбирается шаблон из строки `#2`.

## Семантическая прозрачность

Использование перегрузки, как было показано в предыдущем разделе, очень полезно при достижении прозрачной настройки процесса инстанцирования. При этом важно понимать, что такая “прозрачность” существенно зависит от деталей реализации. Чтобы проиллюстрировать это, рассмотрим наше решение `quickExchange()`. Хотя и обобщенный алгоритм, и алгоритм, настроенный для типов `Аггау<Т>`, заканчиваются обменом значений, на которые указывают указатели, побочные эффекты этих операций существенно отличаются. Яркой иллюстрацией тому может служить код, который сравнивает обмен структурных объектов с обменом шаблонов `Аггау<Т>`.
```c++
struct S
{
	int х;
} s1, s2;

void distinguish(Array<int> a1, Array<int> a2)
{
	int* p = &a1[0];
	int* q = &s1.x;
	
	a1[0] = s1.x = 1;
	a2[0] = s2.x = 2;

	quickExchange(&a1, &a2); // После этого *p == 1  (все еще)
	quickExchange(&s1, &s2); // После этого *q == 2
}
```

Этот пример показывает, что после вызова `quickExchange()` указатель `р` на первый массив [[Array|Array]] становится указателем на второй массив. Однако указатель на поле объекта `s1`, не являющегося массивом, продолжает указывать на поле структуры `s1` даже после выполнения операции обмена. Единственное изменение — поменялись местами значения, на которые указывают указатели. Это весьма существенное отличие, которое может сбивать с толку пользователей шаблона. Применение префикса `quick` позволяет привлечь внимание к тому, что данная реализация представляет собой сокращенный вариант нужной операции. Однако первоначальный обобщенный шаблон `exchange()` может при этом содержать оптимизацию для шаблонов `Аггау<Т>`:
```c++
template<typename Т>
void exchange(Array<T>* a, Array<T>* b)
{
	T* p = &(*a)[0];
	T* q = &(*b)[0];

	for(std::size_t k = a->size(); k--!= 0;)
	{
		exchange(p++, q++);
	}
}
```

Преимущество этой версии обобщенного кода заключается в том, что при этом не требуется создавать (потенциально) большой временный массив `Аггау<Т>`. Шаблон `exchange()` вызывается рекурсивно, чем достигается хорошая производительность даже для таких типов, как `Array<Array<char>>`. Отметим также, что более специализированная версия шаблона не объявлена как [[inline|inline]], поскольку выполняет значительный объем работы. В то же время первоначальная обобщенная реализация является встроенной, поскольку выполняет только несколько операций (каждая из которых потенциально является дорогостоящей).

# Перегрузка шаблонов функций

В предыдущем разделе было показано, что возможно сосуществование двух шаблонов функций с одним и тем же именем, даже если они могут быть инстанцированы с параметрами идентичных типов. Приведем еще один простой пример этого.
```c++
template<typename T>
int f (T)
{
	return 1;
}

template<typename T>
int f(T*)
{
	return 2;
}
```

Когда тип `T` заменяется типом `int*` в первом шаблоне, получается функция, у которой есть точно такие же типы параметров (и возвращаемых значений), что и у функции, получаемой при замене типа `int` типом `Т` во втором шаблоне. Сосуществовать могут не только эти шаблоны, но и их инстанцирования, даже если у них идентичны типы параметров и возвращаемых значений.

Приведенный ниже пример демонстрирует, как можно вызвать две такие сгенерированные функции с помощью синтаксиса явного аргумента шаблона (в предположении предыдущих объявлений шаблона):
```c++
#include <iostream>
#include "funcoverload1.hpp"

int main()
{
	std::cout << f<int*>((int*)nullptr);   // Вызов f<T>(T)
	std::cout << f<int> ((int*)nullptr);   // Вызов f<T>(T*)
}
```

Результатом выполнения этой программы будет следующий вывод:
```
12
```

Чтобы объяснить работу программы, подробно проанализируем вызов `f<int*>((int*)nullptr)`. Синтаксис `f<int*>` обозначает, что первый параметр шаблона `f` нужно заменить значением типа `int*` без использования вывода аргумента шаблона. В этом случае существует более одного шаблона `f` и поэтому создается набор перегрузки, содержащий две функции, сгенерированные из шаблонов: `f<int*> (int*)` (сгенерированная из первого шаблона) и `f<int*> (int**)` (сгенерированная из второго шаблона). Аргумент вызова `(int*) nullptr` имеет тип `int*`, который соответствует только функции, сгенерированной из первого шаблона. Следовательно, это и есть функция, которая будет вызвана в конечном итоге.

С другой стороны, для второго вызова множество перегрузки содержит функции `f<int> (int)` (генерируется из первого шаблона) и `f<int> (int*)` (генерируется из второго шаблона), так что соответствует аргументу только второй шаблон.

## Сигнатуры

Две функции могут сосуществовать в программе, если у них разные сигнатуры. Определим сигнатуру как приведенную ниже информацию.
1. Неквалифицированное имя функции (или имя шаблона функции, из которого она генерируется).
2. Область видимости класса или пространства имен и, если это имя имеет внутреннее связывание, единица трансляции, в которой объявлено имя.
3. Классификация функции как [[const|const]], [[volatile|volatile]] или `const volatile` (если это функция-член с данным квалификатором).
4. Квалификаторы `&` или `&&` функции (если она является функцией-членом с таким квалификатором).
5. Типы параметров функции (перед подстановкой параметров шаблона, если функция генерируется из шаблона функции).
6. Если функция генерируется из шаблона функции, то тип ее возвращаемого значения.
7. Параметры и аргументы шаблона, если функция генерируется из шаблона функции.

Это означает, что в одной и той же программе могут сосуществовать следующие шаблоны и их инстанцирования:
```c++
template<typename T1, typename Т2>
void f1(T1, T2);

template<typename T1, typename T2>
void f1(T2, T1);

template<typename T>
long f2(T);

template<typename T>
char f2(T);
```

Однако их не всегда можно использовать, если они объявлены в одной и той же области видимости, поскольку при их инстанцировании возникает неоднозначность перегрузки. Например, очевидно, что вызов `f2(42)` приводит к неоднозначности, если объявлены оба соответствующих шаблона, приведенных выше. 

Еще один пример показан ниже:
```c++
#include <iostream>
template<typename T1, typename T2>
void f1(T1, T2)
{
	std::cout << "f1(T1, T2)\n";
}

template<typename T1, typename T2>
void f1(T2, T1)
{
	std::cout << "f1(T2, T1)\n";
}

// Пока все в порядке
int main()
{
	f1<char, char>('a', 'b');     // Ошибка: неоднозначность
}
```

Здесь функция
```c++
f1<T1 = char, T2 = char>(T1, T2)
```

может сосуществовать с функцией
```c++
f1<T1 = char, Т2 = char>(T2, T1)
```

однако разрешение перегрузки никогда не отдаст предпочтения одной из них. Если эти шаблоны появляются в различных единицах трансляции, эти два экземпляра действительно могут существовать в одной и той же программе (при этом компоновщик не должен жаловаться на двойное определение, поскольку сигнатуры инстанцирований различны):
```c++
// ===== Единица трансляции 1:
#include <iostream>

template<typename T1, typename T2>
void f1(T1, T2)
{
	std::cout << "f1(T1, T2)\n";
}

void g()
{
	f1<char, char>('a', 'b');
}

// ===== Единица трансляции 2:
#include <iostream>

template<typename T1, typename T2>
void f1(T2, T1)
{
	std::cout << "f1(T2, T1)\n";
}

extern void g(); // Определена в единице трансляции 1

int main()
{
	f1<char, char>('a', 'b');
	g();
}
```

Эта программа корректна и выдает следующее:
```c++
f1(T2, T1)
f1(T1, Т2)
```

## Частичное упорядочение перегруженных шаблонов функций

Вернемся к рассмотренному ранее примеру. Мы обнаружили, что после подстановки данных списков аргументов (`<int*>` и `<int>`), разрешение перегрузки в конечном итоге выбирает для вызова нужную функцию:
```c++
std::cout << f<int*>((int*)nullptr); // Вызов f<T>(T)
std::cout << f<int>((int*)nullptr);  // Вызов f<T>(T*)
```

Однако выбор функции происходит даже тогда, когда явные аргументы шаблона не указаны. В этом случае вступает в игру вывод аргумента шаблона. Чтобы обсудить этот механизм, давайте немного модифицируем функцию `main()` из предыдущего примера.
```c++
#include <iostream>

template<typename T>
int f(T)
{
	return 1;
}

template<typename T>
int f(T*)
{
	return 2;
}

int main()
{
	std::cout << f(0);               // Вызов f<T>(T)
	std::cout << f(nullptr);         // Вызов f<T>(T)
	std::cout << f((int*)nullptr);   // Вызов f<T>(T*)
}
```

Рассмотрим первый вызов, `f(0)`: здесь тип аргумента — `int`, который соответствует типу параметра первого шаблона, если заменить `Т` на `int`. Однако тип параметра второго шаблона — это всегда указатель, и, следовательно, после вывода кандидатом для вызова будет только экземпляр, сгенерированный из первого шаблона. В этом случае разрешение перегрузки тривиально.

То же самое можно сказать и о втором вызове, `f(nullptr)`. Тип аргумента в этом случае [[nullptr_t|std::nullptr_t]], который опять же соответствует только первому шаблону.

Третий вызов `(f((int*)nullptr))` более интересен: осуществить вывод аргумента удается для обоих шаблонов, что дает функции `f<int*>(int*)` и `f<int> (int*)`. С точки зрения традиционного разрешения перегрузки обе функции одинаково хороши для вызова с аргументом `int*`, что соответствует неоднозначности вызова (см. #приложение_В, “Разрешение перегрузки”). Однако в таких случаях вступает в игру дополнительный критерий перегрузки: выбирается функция, сгенерированная из более специализированного шаблона. Здесь, как вы скоро увидите, второй шаблон считается более специализированным, а потому результатом работы этой программы будет
```
112
```

## Правила формального упорядочения

В нашем последнем примере интуитивно вполне понятно, что второй шаблон “более специальный”, чем первый, поскольку первый может быть подстроен почти под любой тип аргумента, тогда как второй разрешает только типы-указатели. Однако другие примеры могут оказаться не столь очевидными. Далее описана точная процедура определения того, является ли один шаблон, участвующий в наборе перегрузки, более специализированным, чем другой. Отметим, однако, что это правила лишь частичного упорядочения: возможна ситуация, когда ни один из шаблонов не будет считаться более специализированным, чем другой. Если разрешение перегрузки должно выбирать между такими шаблонами, решение принято не будет и в программе возникнет ошибка неоднозначности.

Предположим, сравниваются два идентично именованных шаблона, которые кажутся подходящими для данного вызова функции. Разрешение перегрузки принимает решение следующим образом.
>
> Параметры вызова функции, которые используют аргументы по умолчанию или многоточия, игнорируются.
> 
> Создаются два искусственных списка типов аргументов (а для шаблона функции преобразования типов — возвращаемого типа) путем подстановки каждого параметра шаблона следующим образом.
> 	1. Заменим каждый типовой параметр шаблона уникальным искусственным типом.
> 	2. Заменим каждый шаблонный параметр шаблона уникальным искусственным шаблоном класса.
> 	3. Заменим каждый шаблонный параметр, не являющийся типом, уникальным искусственным значением соответствующего типа. (Искусственные типы, шаблоны и значения в этом контексте отличаются от любых прочих типов, шаблонов или значений, как используемых программистом, так и создаваемых компилятором в других контекстах.)
>
> Если вывод аргументов второго шаблона из первого синтезированного списка типов аргументов происходит успешно при точном соответствии, но не наоборот, то говорят, что первый шаблон является более, специализированным, чем второй. Если вывод аргументов первого шаблона для второго синтезированного списка типов аргументов происходит успешно при точном соответствии, но не наоборот, то говорят, что второй шаблон является более специализированным, чем первый. В ином случае (если нет ни одного успешного вывода или же оба вывода успешны) упорядочения шаблонов не происходит.

Попробуем применить этот подход к двум шаблонам в предыдущем примере. Для этих шаблонов синтезируются два списка типов аргументов путем замены шаблонных параметров описанным выше способом: (`А1`) и (`А2*`), где `А1` и `А2` — уникальные искусственные типы. Очевидно, что вывод первого шаблона для второго списка типов аргументов происходит успешно при замене `А2*` на `Т`. Однако тип `Т*` из второго шаблона невозможно сделать соответствующим типу `А1` из первого списка, который не является типом указателя. Следовательно, формально можно заключить, что второй шаблон более специализирован, чем первый.

Рассмотрим более сложный пример с использованием нескольких параметров функций.
```c++
template<typename Т>
void t(T*, Т const* = nullptr, ...);

template<typename T>
void t(T const*, T*, T* = nullptr);

void example(int* p)
{
	t(p, p);
}
```

Прежде всего, поскольку реальный вызов не использует параметр многоточия для первого шаблона, а последний параметр второго шаблона покрывается аргументом по умолчанию, эти аргументы при частичном упорядочении игнорируются. Отметим, что аргумент первого шаблона по умолчанию не используется. Поэтому соответствующий параметр участвует в упорядочении.

Созданные списки типов аргументов — это (`А1*`, `A1 const*`) и (`А2 const*`, `А2*`). Вывод аргументов шаблона (`A1*`, `A1 const*`) для второго шаблона успешен при замене `Т` на `A1 const`, однако результирующее соответствие не точное, поскольку для вызова `t<A1 const>(A1 const*,A1 const*, A1 const*=0)` с аргументами типов (`A1*`, `A1 const*`) требуется дополнительное уточнение типов. Точно так же нельзя найти точное соответствие при выводе аргументов шаблона для первого шаблона из списка типов аргументов `(А2 const*, А2*)`. Следовательно, между двумя шаблонами нет отношения упорядочения и вызов неоднозначен.

Формальные правила упорядочения обычно обеспечивают возможность интуитивно очевидного выбора шаблонов функций. Тем не менее можно привести множество примеров, когда интуитивно очевидный выбор оказывается невозможным. Вероятно, данные правила упорядочения в будущем могут быть пересмотрены, чтобы такие ситуации стали разрешимыми.

## Шаблоны и нешаблоны

Шаблоны функций можно перегружать нешаблонными функциями. При прочих равных условиях при выборе реальной функции вызова нешаблонная функция предпочтительнее. Приведенный ниже пример иллюстрирует это.
```c++
#include <string>
#include <iostream>

template<typename T>
std::string f(T)
{
	return "Template";
}

std::string f(int&)
{
	return "Nontemplate";
}

int main()
{
	int x = 7;
	std::cout << f (x) << '\n'     // Выводит: Nontemplate
}
```

Результат выполнения программы:
```
Nontemplate
```

Однако при различных ссылочных квалификаторах и [[const|const]] приоритеты разрешения перегрузки могут измениться. Например:
```c++
#include <string>
#include <iostream>

template<typename T>
std::string f(T&)
{
	return "Template";
}

std::string f(int const&)
{
	return "Nontemplate";
}

int main()
{
	int x = 7;
	std::cout << f (x) << '\n';       // Выводит: Template

	int const c = 7;
	std::cout << f(c) << '\n';        // Выводит: Nontemplate
}
```

Результат выполнения программы:
```
Template
Nontemplate
```

Теперь шаблон функции f<>(T&) демонстрирует лучшее соответствие при передаче неконстантного `int`. Дело в том, что для `int` инстанцированная функция `f<>(int&)` демонстрирует лучшее соответствие, чем `f(int const&)`. Таким образом, разница не только в том, что одна функция является шаблоном, а другая — нет. В этом случае применяются общие правила разрешения перегрузки (см. #раздел_В_2). И только при вызове `f()` для `const int` обе сигнатуры имеют один и тот же тип `int const&`, так что предпочтительным оказывается нешаблонный вариант.

По этой причине хорошая идея объявлять шаблон функции-члена как
```c++
template<typename Т>
std::string f(Т const&)
{
	return "Template";
I
```

Тем не менее этот эффект легко может оказаться случайным и привести к удивительному поведению, когда функции-члены определены так, что принимают теже аргументы, что и копирующие или перемещающие конструкторы. Например:
```c++
#include <string>
#include <iostream>

class C
{
	public:
		C () = default;
		C(C const&)
		{
			std::cout << "copy constructor\n";
		}
		
		C (C&&)
		{
			std::cout << "move constructor\n";
		}
		
		template<typename T>
		C (T&&)
		{
			std::cout << "template constructor\n";
		}
};

int main()
{
	C x;
	C x2{x};                // Выводит: template constructor	
	C x3{std::move(x)};     // Выводит: move constructor

	C const c;
	C x4{c};                // Выводит: copy constructor
	C x5{std::move(c)};     // Выводит: template constructor
```

Результат выполнения программы:
```
template constructor
move constructor
copy constructor
template constructor
```

Таким образом, шаблон функции-члена лучше подходит для копирования `С`, чем копирующий конструктор. И для `std: :move(c)`, который дает тип `С const &&` (возможный, но обычно не имеющий значимой семантики тип), шаблон функции-члена также демонстрирует лучшее соответствие, чем перемещающий конструктор.

По этой причине обычно [[Семантика перемещения - Использование enable_if - template|следует частично отключать такие шаблоны функций-членов, когда они могут скрывать копирующие или перемещающие конструкторы]].

## Вариативные шаблоны функций

[[Вглубь шаблонов - template#Вариативные шаблоны|Вариативные шаблоны функций]] требуют при частичном упорядочении особого подхода, потому что при [[Вывод аргументов шаблона - template#Пакеты параметров|выводе для пакета параметров]] один параметр соответствует нескольким аргументам.

Это поведение приводит к нескольким интересным ситуациям при упорядочении шаблонов функций, иллюстрируемым в следующем примере:
```c++
#include <iostream>

template<typename T>
int f(T*)
{
	return 1;
}

template<typename... Ts>
int f(Ts...)
{
	return 2;
}

template<typename... Ts>
int f (Ts* ...)
{
	return 3;
}

int main()
{
	std::cout << f(0, 0.0);            // Вызов f<>(TS...)
	std::cout << f((int*)nullptr,
					(double*)nullptr); // Вызов fo(Ts* ...)
	std::cout << f((int*)nullptr);     // Вызов f<> (T*)
}
```

Вывод этой программы, которую мы сейчас детально разберем, имеет вид
```
231
```

В первом вызове, `f(0,0,0)`, рассматриваются все шаблоны функций с именем `f`. Для первого шаблона функции, `f(Т*)`, вывод оказывается неудачен, как потому, что параметр шаблона `Т` не может быть выведен, так и потому, что аргументов функции больше, чем параметров в этом невариативном шаблоне функции. Второй шаблон функции, `f(Ts. . .)`, является вариативным: вывод в этом случае сравнивает схему пакета параметров функции (`Ts`) с типами двух аргументов (`int` и `double`, соответственно), выводя `Ts` как последовательность (`int`, `double`). Для третьего шаблона функции, `f(Ts*...)`, вывод сравнивает схему пакета параметров функции `Ts*` с каждым из типов аргументов. Этот вывод оказывается неудачным (Ts не может быть выведен), оставляя в результате в качестве кандидата только один второй шаблон функции. Упорядочение шаблонов функции не требуется.

Второй вызов, `f((int*)nullptr, (double*)nullptr)`, более интересен: вывод неудачен для первого шаблона функции, потому что аргументов функции больше, чем параметров, но успешен для второго и третьего шаблонов. Будучи записанными явно, результирующие вызовы имеют вид
```c++
f<int,double*>((int*)nullptr, (double*)nullptr) // Второй шаблон
```

и
```c++
f<int,double>((int*)nullptr, (double*)nullptr)  // Третий шаблон
```

Затем частичное упорядочение рассматривает второй и третий шаблоны (оба они являются вариативными) следующим образом: при применении [[Шаблоны Специализация и перегрузка - template#Правила формального упорядочения|формальных правил упорядочения]] к вариативному шаблону каждый пакет параметров шаблона заменяется одним искусственным типом, шаблоном класса или значением. Например, это означает, что сгенерированные типы аргументов для второго и третьего шаблонов функций представляют собой `A1` и `A2*`, соответственно, где `A1` и `A2` — уникальные, искусственно введенные типы. Вывод для второго шаблона для третьего списка типов аргументов успешен при подстановке однозначной последовательности (`A2*`) вместо пакета параметров `Ts`. Однако не существует способа сделать схему `Ts*` пакета параметров третьего шаблона соответствующей типу `A1`, не являющемуся типом указателя; поэтому третий шаблон функции (принимающий аргументы-указатели), считается более специализированным, чем второй шаблон функции (который принимает любые аргументы).

Третий вызов, `f((int*)nullptr)`, вводит новые сложности: вывод успешен для всех трех шаблонов функций, что требует частичного упорядочения для сравнения вариативных и непараметризованных шаблонов. Для иллюстрации сравним первый и третий шаблоны функций. Синтезированные типы аргументов представляют собой `A1*` и `A2*`, где `A1` и `A2` являются уникальными искусственными типами. Вывод первого шаблона для третьего списка синтезированных аргументов успешен при подстановке `A2` вместо `T`. В другом направлении вывод третьего шаблона для первого списка синтезированных аргументов также успешен при подстановке однозначной последовательности (`A1`) вместо пакета параметров `Ts`. Частичное упорядочение между первым и третьим шаблонами должно быть вести к неоднозначности. Однако имеется специальное правило, которое запрещает сопоставление аргумента, изначально пришедшего из пакета параметров функции (например, пакет параметров третьего шаблона `Ts*...`), параметру, который не является пакетом параметров (параметр первого шаблона `T*`). Следовательно, вывод первого шаблона для третьего списка синтезированных аргументов неудачен, и первый шаблон рассматривается как более специализированный, чем третий. Это специальное правило рассматривает невариативные шаблоны (т.е. шаблоны с фиксированным количеством параметров) как более специализированные, чем вариативные шаблоны (с переменным количеством параметров).

Описанные выше правила точно так же применяются к раскрытиям пакетов, происходящим в типах в сигнатуре функции. Например, мы можем “обернуть” параметры и аргументы каждого из шаблонов функций в нашем предыдущем примере в вариативный шаблон класса [[tuple|Tuple]] для получения аналогичного примера, не связанного с пакетами параметров функции:
```c++
#include <iostream>

template<typename... Ts> class Tuple
{
};

template<typename T>
int f(Tuple<T*>)
{
	return 1;
}

template<typename... Ts>
int f(Tuple<Ts...>)
{
	return 2;
}

template<typename... Ts>
int f(Tuple<Ts* ...>)
{
	return 3;
}

int main()
{
	std::cout << f(Tuple<int,double>());    // Вызов f<>(Tuple<Ts...>)
	std::cout << f(Tuple<int*,double*>());  // Вызов f<>(Tuple<Ts*...>)
	std::cout << f(Tuple<int*>());          // Вызов f<>(Tuple<T*>)
}
```

Упорядочение шаблонов функций рассматривает раскрытие пакета в аргументах шаблона в [[tuple|Tuple]] аналогично пакетам параметров функций в нашем предыдущем примере, что приводит к такому же, как и выше, результату:
```
231
```

# Явная специализация

Возможность перегружать шаблоны функций в сочетании с правилами частичного упорядочения при выборе обеспечивающего наилучшее соответствие шаблона функции позволяет добавлять к обобщенной реализации специализированные шаблоны для повышения эффективности кода. Однако перегружать шаблоны классов и шаблоны переменных нельзя. Вместо этого для обеспечения прозрачной настройки шаблонов классов выбран другой механизм — явная специализация (explicit specialization). Стандартный термин явная специализация ссылается на возможность языка, которую мы называем полной специализацией (full specialization). Она обеспечивает реализацию шаблона с полностью замененными параметрами шаблонов, когда никаких неизвестных шаблонных параметров не остается. Шаблоны классов, шаблоны функций и шаблоны переменных могут быть полностью специализированными.

Члены шаблонов классов (т.е. функции-члены, вложенные классы, статические члены-данные и члены с типами перечислений) могут быть определены за пределами тела определения класса.

В одном из следующих разделов рассматривается частичная специализация (partial specialization). Она напоминает полную специализацию, но вместо полной замены шаблонных параметров в ней остается некоторая параметризация. Полная и частичная специализации одинаково “явно” присутствуют в нашем исходном коде, поэтому при обсуждении мы избегаем термина явная специализация. Ни полная, ни частичная специализация не вводят полностью новый шаблон или его экземпляр. Вместо этого данные конструкции предоставляют возможность альтернативного определения для экземпляров, которые уже неявно определены в обобщенном (неспециализированном) шаблоне. Это довольно важное концептуальное отличие от перегруженных шаблонов.

## Полная специализация шаблона класса

Полная специализация вводится последовательностью трех лексем: template, `<` и `>`. Кроме того, после имени класса идут аргументы шаблона, для которых объявляется специализация. Это проиллюстрировано ниже.
```c++
template<typename Т>
class S
{
	public:
		void info()
		{
			std::cout << "generic (S<T>::info())\n";
		}
};

template<>
class S<void>
{
	public:
		void msg()
		{
			std::cout << "fully specialized (S<void>::msg())\n";
		}
};
```

Обратите внимание на то, что реализация полной специализации не требует какой-либо связи с обобщенным определением. Это позволяет создавать функции-члены с различными именами (`info` и `msg`). Связь между ними определяется исключительно именем шаблона класса.

Список указываемых аргументов шаблона должен соответствовать списку параметров шаблона. Например, некорректно использовать значение, не являющееся типом, вместо шаблонного параметра типа. Однако указывать аргументы для параметров со значениями по умолчанию необязательно:
```c++
template<typename T>
class Types
{
	public:
	    using I = int;
};

template<typename T, typename U = typename Types<T>::I>
class S;                                                     // #1

template<>
class S<void>                                                // #2
{
	public:
	    void f();
};

template<> class S<char, char>;                              // #3

template<> class S<char, 0>;    // Ошибка: 0 нельзя подставить вместо U

int main()
{
    S<int>* pi;          // OK: использует #1, определение не нужно
    S<int> e1;           // Ошибка: использует #1, но нет определения
    S<void>* pv;         // OK: использует #2
    S<void, int> sv;     // OK: использует #2, определение имеется
    S<void, char> e2;    // Ошибка: использует #1, но нет определения
    S<char, char> e3;    // Ошибка: использует #3, но нет определения
}

template<>
class S<char, char>    // Определение для #3
{
};
```

Данный пример также показывает, что объявления полной специализации (и шаблонов) не обязательно должны быть определениями. Однако, если объявлена полная специализация, для данного набора аргументов шаблона обобщенное определение никогда не используется. Следовательно, если определение необходимо, но его нет, в программе содержится ошибка. Для специализации шаблонов класса иногда полезно предварительное объявление типов, что позволяет создавать взаимно зависимые типы. Объявление полной специализации идентично объявлению обычного класса (это не шаблонное объявление). Все, что их отличает, — это синтаксис и тот факт, что объявление должно соответствовать предыдущему объявлению шаблона. Поскольку это не объявление шаблона, члены полной специализации шаблона класса могут быть определены с помощью обычного синтаксиса определения члена вне класса (иными словами, нельзя указывать префикс `template<>`):
```c++
template<typename Т>
class S;

template<> 
class S<char**>
{
	public:
		void print() const;
};

// Следующее определение не может предваряться template<>
void S<char**>::print() const
{
	std::cout << "pointer to pointer to char\n";
}
```

Ниже приведен более сложный пример этой концепции:
```c++
template<typename Т>
class Outside
{
	public:
		template<typename U>
		class Inside
		{
		};
};

template<>
class Outside<void>
{
			// Нет никакой особой связи между следующим вложенным
			// классом и определенным в обобщенном шаблоне
	template<typename U>
	class Inside
	{
		private:
			static int count;
	};
};

// Следующее определение не может предваряться template<>
template<typename U>
int Outside<void>::Inside<U>::count = 1;
```

Полная специализация — это замена инстанцирования некоторого обобщенного шаблона. При этом некорректно одновременно иметь как явную, так и сгенерированную версии шаблона в одной и той же программе. Попытка использовать их обе в одном и том же файле обычно отслеживается компилятором:
```c++
template<typename Т>
class Invalid
{
};

Invalid<double> x1;        // Вызывает инстанцирование Invalid<double>

template<>
class Invalid<double>;     // Ошибка: Invalid<double> уже инстанцирован
```

К сожалению, при использовании в различных единицах трансляции проблема не отслеживается так легко. Следующий некорректный пример кода на C++ состоит их двух файлов. Этот код компилируется и компонуется многими реализациями, однако он некорректен и опасен.
```c++
// ==== Единица трансляции 1:
template<typename Т>
class Danger
{
	public:
		enum { max =10 };
};

char buffer[Danger<void>::max];   // Использует обобщенное значение

extern void clear(char*);

int main()
{
	clear(buffer);
}

// ==== Единица трансляции 2:
template<typename T>
class Danger;

template<>
class Danger<void>
{
	public:
		enum { max = 100 };
};

void clear(char* buf)
{
	// Несоответствие в границе массива:
	for (int k = 0; k < Danger<void>::max; ++k)
		buf[k] = '\0';
};
```

Этот пример был придуман специально, чтобы как можно более коротко показать, насколько необходимо следить за тем, чтобы объявление специализации было видно всем пользователям обобщенного шаблона. С практической точки зрения это означает, что объявление специализации должно идти после объявления шаблона в его заголовочном файле. Если обобщенная реализация берет начало из внешнего источника (такого, что соответствующие заголовочные файлы не должны изменяться), то стоит, хотя это и не обязательно, создать заголовочный файл, включающий обобщенный шаблон с последующим объявлением специализаций, чтобы избежать таких труднообнаруживаемых ошибок. В целом лучше избегать специализации шаблона, происходящего из внешнего источника, если не указано, что он для этого предназначен.

## Полная специализация шаблона функции

Синтаксис и принципы, лежащие в основе (явной) полной специализации шаблона функции, во многом такие же, как и в случае полной специализации шаблона класса. Однако здесь вступают в игру перегрузка и вывод аргумента.

При объявлении полной специализации можно пропускать явные аргументы шаблона, если этот шаблон можно определить с помощью вывода аргумента (используя в качестве типов аргументов типы параметров, указанные в объявлении) и частичного упорядочения. Например:
```c++
template<typename Т>
int f(Т)
{
	return 1;                               // #1
}

template<typename Т>
int f(T*)
{
	return 2;                              // #2
}

template<> 
int f(int)                                // OK: специализация #1
{
	return 3;
}

template<> 
int f(int*)                               // OK: специализация #2
{
	return 4;
}
```

Полная специализация шаблона функции не может включать значения аргумента по умолчанию. Однако любые аргументы по умолчанию, указанные для шаблона, подвергаемого специализации, остаются применимыми и для явной специализации.

```c++
template<typename Т>
int f(Т, Т х = 42)
{
	return х;
}

template<> 
int f(int, int = 35)  // Ошибка
{
	return 0;
}
```

(Дело в том, что полная специализация обеспечивает альтернативное определение, но не альтернативное объявление. В точке вызова шаблона функции вызов полностью разрешен на основе шаблона функции.)

Полная специализация во многом подобна обычному объявлению (точнее, обычному повторному объявлению). В частности, она не объявляет шаблон и, следовательно, в программе должно быть только одно определение невстраиваемой полной специализации шаблона функции. Однако необходимо следить за тем, чтобы объявление полной специализации следовало после шаблона, что предотвратит попытки использования функции, сгенерированной из шаблона. Поэтому объявления шаблона `g()` и его полной специализации в предыдущем примере лучше размещать в двух файлах следующим образом.
>
> Файл интерфейса содержит определения первичных шаблонов и частичных специализаций, но объявляет только полные специализации:
```c++
#ifndef TEMPLATE_G_HPP
#define TEMPLATE_G_HPP

// Определение шаблона должно находиться в заголовочном файле:
template<typename Т>
int g(Т, Т х = 42)
{
	return х;
}

// Объявление специализации запрещает инстанцирования шаблона;
// определение не должно появляться здесь во избежание ошибок
// многократных определений
template<> 
int g(int, int у);

#endif // TEMPLATE_G_HPP
```

> Соответствующий файл реализации определяет полную специализацию:
```c++
#include "template_g.hpp"

template<> 
int g(int, int y)
{
	return у / 2;
}
```

В качестве альтернативы специализация может быть встраиваемой; в этом случае ее объявление может (и должно) быть помещено в заголовочном файле.

## Полная специализация шаблона переменной

Полностью специализироваться могут не только шаблоны членов, но и обычные статические члены-данные и функции-члены шаблонов класса. Синтаксис требует наличия префикса `template<>` для каждого охватывающего шаблона класса. Если специализируется шаблон члена, то для указания этой специализации необходимо добавить префикс `template<>`. Чтобы проиллюстрировать это, будем считать, что у нас имеются следующие объявления:
```c++
template<typename Т>
class Outer                                   // #1
{
	public:
		template<typename U>
		class Inner                           // #2
		{
			private:
				static int count;             // #3
		};
		
		static int code;                      // #4

		void print() const                    // #5
		{
			std::cout << "generic";
		}
}

template<typename Т>
int Outer<T>::code =6;                        // #6

template<typename T> template<typename U>
int Outer<T>::Inner<U>::count = 7;            // #7

template<>
class Outer<bool>                             // #8
{
	public:
		template<typename U>
		class Inner                           // #9
		{
			private:
				static int count;             // #10
		};

		void print() const                    // #11
		{
		}
};
```

Обычные члены `code` в точке `#4` и `print()` в точке `#5` обобщенного шаблона `Outer #1` имеют единственный охватывающий шаблон класса и, следовательно, требуют одного префикса `template<>` для полной специализации для конкретного набора аргументов шаблона:
```c++
template<>
int Outer<void>::code = 12;

template<>
void Outer<void>::print() const
{
	std::cout << "Outer<void>";
}
```

Эти определения используются поверх обобщенных в точках `#4` и `#5` для класса `Outer<void>`, однако другие члены класса `Outer<void>` все еще генерируются из шаблона в точке `#1`. Заметим, что после этих объявлений он утрачивает силу в плане обеспечения явной специализации для `Outer<void>`.

Как и в случае полной специализации шаблона функции, нам нужен способ объявления специализации обычного члена шаблона класса без указания определения (чтобы избежать многократных определений). Хотя для функций-членов и статических членов-данных обычных классов в C++ не разрешены неопределяющие объявления вне класса, они будут корректными при специализации членов шаблонов классов. Предыдущие определения могут быть объявлены следующим образом:
```c++
template<>
int Outer<void>::code;

template<>
void Outer<void>::print() const;
```

Внимательный читатель может заметить, что неопределяющее объявление полной специализации `Outer<void>::code` имеет точно тот же синтаксис, что и при определении с помощью конструктора по умолчанию. Это действительно так, однако такие объявления всегда интерпретируются как неопределяющие. Для полной специализации статического члена-данных с типом, который может быть инициализирован только с помощью конструктора по умолчанию, мы должны прибегнуть к синтаксису списка инициализаторов. При наличии
```c++
class DefaultlnitOnly
{
	public:
		DefaultlnitOnly() = default;
		DefaultlnitOnly(DefaultlnitOnly const&) = delete;
};

template<typename T>
class Statics
{
	private:
		static T sm;
};
```

следующий код является объявлением:
```c++
template<>
DefaultInitOnly Statics<DefaultInitOnly>::sm;
```

в то время как код, приведенный ниже, является определением, которое вызывает конструктор по умолчанию:
```c++
template<>
DefaultInitOnly Statics<DefaultInitOnly>::sm{};
```

До C++11 это было невозможно. Таким образом, инициализация по умолчанию была для таких специализаций недоступной. Обычно использовался инициализатор, копирующий значение по умолчанию:
```c++
template<>
DefaultInitOnly Statics<DefaultInitOnly>::sm = DefaultlnitOnly));
```

К сожалению, в нашем примере это было невозможно, потому что копирующий конструктор удален. Однако в C++17 введено обязательное к исполнению правило пропуска копирования (copy-elision), которое делает эту альтернативу корректной — вызова копирующего конструктора здесь больше нет.

Шаблон члена `Outer<T>::Inner` также можно специализировать для данного аргумента шаблона без влияния на другие члены `Outer<T>`, для которого специализируется шаблон члена. И вновь наличие охватывающего шаблона приводит к необходимости префикса `template<>`. В результате получается такой код:
```c++
template<>
template<typename Х>
class Outer<wchar_t>::Inner
{
	public:
		static long count;       // Тип члена изменен
};

template<>
template<typename X>
long Outer<wchar_t>::Inner<x>::count;
```

Шаблон `Outer<T>::Inner` также может быть полностью специализированным, однако только для данного экземпляра `Outer<T>`. Теперь нам нужно два префикса `template<>`: один из-за охватывающего класса, и один из-за того, что мы полностью специализируем (внутренний) шаблон.
```c++
template<>
template<>
class Outer<char>::Inner<wchar_t>
{
	public:
		enum { count = 1 };
};

// Приведенный далее код не является корректным кодом C++:
// template<> не может следовать за списком параметров шаблона
template<typename Х>
template<> class Outer<X>::Inner<void>;         // Ошибка
```

Сравните это со специализацией шаблона-члена `Outer<bool>`. Поскольку он уже полностью специализирован, охватывающего шаблона нет и нам нужен только один префикс `template<>`.
```c++
template<>
class Outer<bool>::Inner<wchar_t>
{
	public:
		enum { count = 2 };
};
```

# Частичная специализация шаблона класса

Полная специализация шаблона часто полезна, но иногда естественным оказывается желание специализировать шаблон класса для семейства аргументов шаблона, а не только для конкретного набора аргументов. Например, предположим, что у нас есть шаблон класса, реализующий связанный список:
```c++
template<typename Т>
class List                     // #1
{
	public:
		...
		
		void append(T const&);
		inline std::size_t length() const;

		...
};
```

Большой проект с использованием этого шаблона может инстанцировать свои члены для многих типов. Для невстраиваемых функций-членов (скажем, `List<T>::append()`) это может вызывать заметный рост объектного кода. Однако с низкоуровневой точки зрения код `List<int*>::append()` и код `List<void*>::append()` идентичны. Иными словами, хотелось бы указать, что все списки указателей используют одну и ту же реализацию. Хотя это нельзя выразить кодом C++, можно приблизиться к цели, отметив, что все списки указателей `List` должны инстанцироваться из другого определения шаблона:
```c++
template<typename Т>
class List<T*>                       // #2
{
	private:
		List<void*> imp1;
		...
		
	public:
		...
		
		inline void append(T* p)
		{
			imp1.append(p);
		}

		inline std::size_t length!)
		{
			return imp1.length();
		}
}
```

В этом контексте исходный шаблон в точке `#1` называется первичным шаблоном, а следующее за ним определение — частичной специализацией (поскольку аргументы шаблона, для которых это определение шаблона должно быть использовано, указаны только частично). Синтаксис, который характеризует частичную специализацию, является комбинацией объявления списка параметров шаблона (`template<...>`) и множества явно указанных аргументов шаблона с именем шаблона класса (в нашем примере это `<Т*>`).

Наш код таит в себе проблему, поскольку `List<void*>` рекурсивно содержит член того же типа `List<void*>`. Для прерывания рекурсии перед предыдущей частичной специализацией можно ввести полную специализацию.
```c++
template<>
class List<void*>                    // #3
{
	...
	
	void append(void* p);
	inline std::size_t length() const;

	...
};
```

Этот код вполне корректно работает, поскольку полная специализация предпочтительнее частичной. В результате все функции-члены списков указателей `List` переадресовываются (с помощью легко встраиваемых функций) реализации списка `List<void*>`. Это эффективный способ борьбы с так называемым разбуханием кода (code bloat, в чем часто обвиняют шаблоны C++).

Существует ряд ограничений на объявления списков параметров и аргументов частичной специализации. Приведем некоторые из них.
1. Аргументы частичной специализации должны отвечать виду (параметры, представляющие собой тип, параметры, не являющиеся типом, шаблонные параметры) соответствующих параметров первичного шаблона.
2. Список параметров частичной специализации не может иметь аргументов по умолчанию; вместо них используются аргументы по умолчанию первичного шаблона класса.
3. Аргументы частичной специализации, не являющиеся типами, должны быть либо независимыми значениями, либо простыми параметрами, не являющимися типами. Они не могут быть сложными зависимыми выражениями наподобие `2*N` (где `N` — параметр шаблона).
4. Список аргументов шаблона частичной специализации не должен быть идентичен (без учета переименования) списку параметров первичного шаблона.
5. Если один из аргументов шаблона представляет собой раскрытие пакета, он должен находиться в конце списка аргументов шаблона.

Вот пример, иллюстрирующий описанные ограничения:
```c++
template<typename Т, int I = 3>
class S;                    // Первичный шаблон

template<typename Т>
class S<int, Т>;            // Ошибка : несоответствие вида параметра

template<typename Т = int>
class S<T, 10>;             // Ошибка аргументы по умолчанию
							// не разрешены

template<int I>
class S<int, I * 2>;        // Ошибка: не разрешены выражения,
							// не являющиеся типами
							
template<typename U, int K>
class S<U, K>;              // Ошибка: нет существенных отличий
							// от первичного шаблона

template<typename... Ts>
class Tuple;

template<typename Tail, typename... Ts>
class Tuple<Ts..., Tail>;   // Ошибка; раскрытие пакета не в конце

template<typename Tail, typename... Ts>
class Tuple<Tuple<Ts...>, Tail>;// OK: раскрытие пакета - в конце вло-
								// женного списка аргументов шаблона
```

Любая частичная специализация, как и любая полная специализация, связана с первичным шаблоном. При использовании шаблона сначала всегда ищется первичный шаблон, но затем проверяется соответствие аргументов аргументам связанных специализаций (с использованием [[Вывод аргументов шаблона - template#Вывод аргументов шаблона|вывода аргументов шаблона]]) для определения того, какая реализация шаблона должна быть выбрана. Здесь так же, как и при выводе аргументов шаблона функции, применим принцип [[SFINAE|SFINAE]]: если при попытке сопоставления частичной специализации образуется недопустимая конструкция, такая специализация молча отбрасывается и проверяется другой кандидат (если таковой имеется). Если соответствующие специализации не найдены, выбирается первичный шаблон. Если найдено несколько соответствующих специализаций, из них выбирается наиболее специализированная (в смысле, определенном для перегруженных шаблонов функций). Если ни одну из них нельзя назвать “наиболее специализированной”, в программе имеется ошибка неоднозначности.

Наконец, следует заметить, что частичная специализация шаблона класса вполне может иметь большее или меньшее количество параметров, чем первичный шаблон. Рассмотрим снова наш обобщенный шаблон `List` (объявленный в точке `#1`). Мы уже рассматривали оптимизацию списка указателей, но у нас может возникнуть желание сделать то же самое и с определенными типами “указатель на член”. Ниже приведен код, который оптимизирует список для указателей на указатель на член:
```c++
// Частичная специализация для любого члена-указателя на void*
template<typename С>
class List<void* С::*>             // #4
{
	public:
		using ElementType = void* C::*;

		...
		
		void append(ElementType pm);
		inline std::size_t length() const;

		...
};

// Частичная специализация для любого типа указателя на
// указатель на член, за исключением члена типа указателя
// на void*, который обработан ранее (заметим, что у этой
// частичной специализации два шаблонных параметра, тогда
// как у первичного шаблона - только один).
//
// Эта специализация использует предыдущую для достижения
// желаемой оптимизации

template<typename Т, typename С>
class List<T* С::*>             // #5
{
	private:
		List<void* С;:*> imp1;
		...
	
	public:
		using ElementType = T * C::*;

		...
		
		inline void append(ElementType pm)
		{
			imp1.append(static_cast<void* C::*>(pm));
		}
		
		inline std::size_t length() const
		{
			return impl.length();
		}

		...
}
```

В дополнение к замечаниям относительно числа шаблонных параметров отметим, что общая реализация, определенная в точке `#4`, которую используют все остальные из объявления в точке `#5`, сама является частичной специализацией (для случая простого указателя — это полная специализация). Однако очевидно, что специализация в точке `#4` более специализирована, чем в точке `#5`, так что неоднозначности не возникает.

Кроме того, возможно даже, что количество явно указанных аргументов шаблона может отличаться от количества параметров первичного шаблона. Это может произойти как с аргументами шаблона по умолчанию, так и гораздо более полезным способом с вариативными шаблонами:
```c++
template<typename... Elements>
class Tuple;                     // Первичный шаблон

template<typename T1>
class Tuple<T>;                  // Одноэлементный кортеж

template<typename T1, typename T2, typename... Rest>
class Tuple<T1, T2, Rest...>;    // Кортеж с двумя и более элементов
```

# Частичная специализация шаблонов переменных

Когда в стандарт C++11 были добавлены шаблоны переменных, оказались упущенными из виду некоторые аспекты их спецификации, и ряд этих вопросов до сих пор официально не разрешен. Однако фактические реализации языка обычно согласованы в плане обработки таких вопросов.

Пожалуй, самое удивительное в том, что стандарт ссылается на возможность частичной специализации шаблонов переменных, но не описывает, как ее объявить или что она означает. Таким образом, текст этого раздела основан на практических реализациях C++ (которые разрешают такие частичные специализации), а не на стандарте C++.

Как можно было бы ожидать, синтаксис частичной специализации шаблона переменной похож на полную специализацию переменной шаблона, за исключением того, что `template<>` заменяется на заголовок фактического объявления шаблона, а список аргументов шаблона, следующий за именем шаблона переменной, должен зависеть от параметров шаблона. Например:
```c++
template<typename Т> constexpr std::size_t SZ = sizeof (T);
template<typename T> constexpr std::size_t SZ<T&> = sizeof(void*);
```

Как и в случае полной специализации шаблонов переменных, тип частичной специализации не обязан соответствовать типу первичного шаблона:
```c++
template<typename Т> typename Т::iterator null_iterator;
template<typename Т, std::size_t N> T* null_iteratorcT[N]> = nullptr;
// T* не соответствует T::iterator, но все работает
```

Правила, касающиеся видов аргументов шаблона, которые могут указываться в частичной специализации шаблона переменной, идентичны правилам для специализации шаблона класса. Аналогично правила для выбора специализации для данного списка конкретных аргументов шаблона также идентичны.
