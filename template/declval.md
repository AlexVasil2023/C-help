
# std::declval
#std_declval

Шаблон функции `std::declval<>()` может использоваться в качестве заместителя для ссылки на объект определенного типа. Функция не имеет определения и поэтому не может быть вызвана (и не создает объект). Следовательно, она может использоваться только в невычисляемых операндах (таких как конструкции [[decltуре#Знакомство с decltуре|decltype]] и [[sizeof|sizeof]]). Так что вместо попыток создать объект можно считать, что у вас имеется объект соответствующего типа.

Например, следующее объявление выводит возвращаемый тип по умолчанию `RT` из переданных шаблону параметров `Т1` и `Т2`:
```c++
#include <utility>
template<typename T1, typename T2,
		typename RT = std::decay_t<
				decltype(true ? std::declval<T1>()
								: std::declval<T2>()) >>
RT max(T1 a, T2 b)
{
	return b < a ? a : b;
}
```

Чтобы избежать необходимости вызовов конструкторов (по умолчанию) для типов `Т1` и `Т2` в вызове оператора `? :` в выражении инициализации `RT`, мы используем `std::declval`, “используя” объекты соответствующего типа без их создания. Конечно, это возможно только в невычислимом контексте [[decltуре|decltype]].

Не забывайте использовать свойство типа [[decay#std decay|std: :decay<>]], чтобы гарантировать, что тип возвращаемого значения по умолчанию не может быть ссылкой, так как сам шаблон [[declval|std::declval()]] дает [[значение#r-значения|r-ссылку]]. В противном случае вызовы наподобие `max (1,2)` будут давать возвращаемое значение типа `int&&5`.

Подробности см. в #разделе_19_3_4.
