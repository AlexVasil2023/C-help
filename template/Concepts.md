
1. [[#Концепт|Концепт]]
	1. [[#C++17]]
	2. [[#C++20]]
2. [[#Концепт STL|Концепт STL]] 8.2(STL)
	1. [[#Использование концептов|Использование концептов]] 8.2.1 (STL)
	2. [[#Перегрузка основанная на концептах|Перегрузка основанная на концептах]] 8.2.2 (STL)
	3. [[#Правильный код|Правильный код]] 8.2.3 (STL)
	4. [[#Определение концептов|Определение концептов]] 8.2.4 (STL)
		1. [[#Проверка определения|Проверка определения]] 8.2.4.1 (STL)
	5. [[#Концепты и auto|Концепты и auto]] 8.2.5 (STL)
	6. [[#Концепты и типы|Концепты и типы]] 8.2.6 (STL)
3. [[#Обзор концептов|Обзор концептов]] 14.5 (STL) 
	1. [[#Концепты типов|Концепты типов]] 14.5.1 (STL)
	2. [[#Концепты итераторов|Концепты итераторов]] 14.5.2 (STL)
	3. [[#Концепты диапазонов|Концепты диапазонов]] 14.5.3 (STL)
4. [[#концепт Arithmetic|концепт Arithmetic]]
5. [[#концепт copyable|концепт copyable]]
6. [[#концепт LessThanComparable|концепт LessThanComparable]]
7. [[#концепт random_access_iterator|концепт random_access_iterator]] 
8. [[#концепт forward_iterator|концепт forward_iterator]]
9. [[#концепт equality_comparable|концепт equality_comparable]]
10. [[#концепт Value_type|концепт Value_type]]
11. [[#концепт regular|концепт regular]]
12. [[#Базовые концепты|Базовые концепты]]
	1. [[#концепт DefaultConstructible]]
	2. [[#концепт MoveConstructible]]
	3. [[#концепт CopyConstructible]]
	4. [[#концепт MoveAssignable]]
	5. [[#концепт CopyAssignable]]
	6. [[#концепт Destructible]]
13. [[#Концепции размещения]]
	1. [[#концепт TriviallyCopyable]]
	2. [[#концепт TrivialType]]
	3. [[#концепт StandardLayoutType]]
	4. [[#концепт PODType]]
14. [[#Library-wide]]
	1. [[#концепт EqualityComparable]]
	2. [[#концепт LessThanComparable]]
15. [[#концепт predicate|концепт predicate]]
16. [[#концепт invocable|концепт invocable]]

# Концепт

Термин **концепт** (concept) часто используется для обозначения множества ограничений, которые многократно требуются в библиотеке шаблонов. Например, стандартная библиотека C++ опирается на такие ограничения, как итератор с произвольным доступом и конструируемостъ по умолчанию.

В настоящее время (т.е. по стандарту C++17) концепты могут быть более или менее выражены только в документации (например, с помощью комментариев в коде). Это может стать серьезной проблемой из-за того, что нарушение ограничений может привести к [[Применение шаблонов на практике - template#Расшифровка романов об ошибках|жутким сообщениям об ошибках]].

В течение многих лет были неоднократные попытки ввести определения и проверки концептов в качестве возможности языка. Однако до стандарта C++17 включительно этот подход так и не был стандартизован.

Начиная с С++11, существует возможность выполнения по крайней мере некоторых проверок основных ограничений с использованием ключевого слова [[assert#static_assert()|static_assert]] и некоторых предопределенных свойств типов, например:
```c++
template<typename Т>
class С
{
	static_assert(std::is_default_constructible<T>::value,
		"Класс С требует элементы, "
		"конструируемые по умолчанию");
	
	...
};
```

Без этого статического утверждения, если требуется конструктор по умолчанию, все равно произойдет ошибка компиляции. Однако в таком случае [[Применение шаблонов на практике - template#Расшифровка романов об ошибках|сообщение об ошибке может содержать всю историю инстанцирования шаблона - от исходной причины неудачного инстанцирования до определения шаблона, в котором была обнаружена ошибка]].

Однако для проверки, например, того, что объекты типа `Т` предоставляют определенную функцию-член или что их можно сравнивать с помощью оператора `<`, требуется куда более сложный код. Подробный пример такого кода приведен в #разделе_19_6_3.

## C++17
```c++
#include <vector>
#include <list>
#include <algorithm>

template <typename Container>
void sort(Container & c)
{
    std::sort(c.begin(), c.end());
}

void test()
{
    std::list ls = {3, 2, 1, 5, 4};
    sortContainer(ls);
}
```
## C++20
```c++
#include <vector>
#include <list>
#include <algorithm>
#include <ranges>

void sort(std::ranges::random_access_range auto & c)
{
    std::sort(c.begin(), c.end());
}

void test()
{
    std::list  ls = { 1, 2, 3, 4, 5, 6 };
    sortContainer(ls);
}
```

# Концепт STL

Рассмотрим функцию `sum()`  [[Template_STL#Шаблоны функций|из]]:
```c++
template<typename Seq, typename Value>
Value sum(Seq s, Value v)
{
	for (const auto& x : s)
		v+=x;
	
	return v;
}
```

Функция `sum()` подразумевает что
>
>  его первым аргументом шаблона является некоторая последовательность элементов, и
>  
> его вторым аргументом шаблона является какое-то число.

Чтобы быть более конкретным, `sum()` может быть вызван для пары аргументов:
>
> Последовательность `Seq`, которая поддерживает [[begin|begin()]] и [[end|end()]], для работы диапазонного [[for|for]] .
> 
> Арифметический тип `Value`, который поддерживает `+=`, чтобы можно было суммировать элементы последовательности.

Мы называем такие требования ***концептами***.

Типы, удовлетворяющие этому упрощенному требованию (и многим другим) и считающиеся последовательностью (также называемой диапазоном), это, например, [[vector|vector]], [[list|list]] и [[map|map]] стандартной библиотеки. Типы, удовлетворяющие этому упрощенному требованию (и многим другим) и считающиеся арифметическим типом, включают `int`, `double` и `Matrix` (для любого разумного определения `Matrix`). Мы могли бы сказать, что алгоритм `sum()` является обобщенным в двух измерениях: типе структуры данных, используемой для хранения элементов (“последовательность”), и типе элементов.

## Использование концептов

Большинство аргументов шаблонов должны соответствовать определенным требованиям для правильной компиляции шаблона и правильной работы сгенерированного кода. То есть большинство шаблонов должны быть [[Template_STL#Ограниченные аргументы шаблона|шаблонами с ограничениями]]. Ключевое слово [[typename|typename]] является наименее ограничивающим, требующим только, чтобы аргумент был типом. Обычно мы можем сделать лучше. Рассмотрим функцию `sum()` еще раз:
```c++
template<Sequence Seq, Number Num>
Num sum(Seq s, Num v)
{
	for (const auto& x : s)
		v+=x;
	
	return v;
}
```

Так гораздо понятнее. Как только мы определим, что означают понятия `Sequence` и `Number`, компилятор сможет отклонять некорректные вызовы, просматривая только интерфейс `sum()`, а не его реализацию. Это улучшает представление отчетов об ошибках.

Однако спецификация интерфейса `sum()` не является полной: я “забыл” сказать, что мы должны иметь возможность добавлять элементы `Sequence` к `Number`. Мы можем это сделать:
```c++
template<Sequence Seq, Number Num>
requires Arithmetic<range_value_t<Seq>,Num>
Num sum(Seq s, Num n);
```

[[range#range_value_t|range_value_t]] последовательности - это тип элементов в этой последовательности; он взят из стандартной библиотеки, где он называет тип элементов диапазона [[range#range|range]]. `Arithmetic<X,Y>` - это концепт, указывающий, что мы можем выполнять арифметику с числами типов `X` и `Y`. Это избавляет нас от случайной попытки вычислить `sum()` для `vector<string>` или `vector<int*>`, все еще принимая `vector<int>` и  `ector<complex<double>>`. Как правило, когда алгоритму требуются аргументы разных типов, между этими типами существует взаимосвязь, которую желательно сделать явной.

В этом примере нам понадобился только оператор `+=`, но для простоты и гибкости мы не должны слишком сильно ограничивать наш аргумент шаблона. В частности, возможно, когда-нибудь мы захотим выразить `sum()` в терминах `+` и `=`, а не `+=`, и тогда мы будем счастливы, что использовали общий концепт (здесь, ), а не узкое требование `”наличие +="`.

Частичные спецификации, как и в первом `sum()` использующем концепты, могут быть очень полезны. Если спецификация не полная, некоторые ошибки не будут обнаружены до момента создания экземпляра. Однако даже частичные спецификации выражают намерение и необходимы для плавной поэтапной разработки там, где мы изначально не осознаем всех необходимых нам требований. При наличии зрелых библиотек концептов первоначальные спецификации будут близки к идеальным.

Неудивительно, что `requires Arithmetic<range_value_t<Seq>,Num>` называется пунктом требований `requirements`. Обозначение `template<Sequence Seq>` - это просто сокращение для явного использования `requires Sequence<Seq>`. Если бы мне нравилось многословие, я мог бы с таким же успехом написать
```c++
template<typename Seq, typename Num>
requires Sequence<Seq> && Number<Num> && Arithmetic<range_value_t<Seq>,Num>
Num sum(Seq s, Num n);
```
С другой стороны, мы могли бы также использовать эквивалентность между двумя обозначениями для записи:
```c++
template<Sequence Seq, Arithmetic<range_value_t<Seq>> Num>
Num sum(Seq s, Num n);
```

В кодовых базах, где мы еще не можем использовать `concept`, нам приходится обходиться соглашениями об именовании и комментариями, такими как:
```c++
template<typename Sequence, typename Number>
// requires Arithmetic<range_value_t<Sequence>,Number>
Number sum(Sequence s, Number n);
```

Какую бы форму записи мы ни выбрали, важно разработать шаблон с семантически значимыми ограничениями на его аргументы ( #§8_2_4).

## Перегрузка основанная на концептах

Как только мы правильно определим шаблоны с их интерфейсами, мы сможем выполнять перегрузку на основе их свойств, так же, как мы это делаем для функций. Рассмотрим слегка упрощенную функцию стандартной библиотеки advance(), которая дополняет итератор ( #§13_3):
```c++
template<forward_iterator Iter>
void advance(Iter p, int n) // move p n elements forward
{
	while (n--)
		++p;                // a forward iterator has ++, but not + or +=
}

template<random_access_iterator Iter>
void advance(Iter p, int n) // move p n elements forward
{
	p+=n;                   // a random-access iterator has +=
}
```

Компилятор выберет шаблон с наиболее строгими требованиями, которым удовлетворяют аргументы. В этом случае [[list|list]] предоставляет только прямые итераторы, но [[vector|vector]] предлагает итераторы с произвольным доступом, поэтому мы получаем:
```c++
void user(vector<int>::iterator vip, list<string>::iterator lsp)
{
	advance(vip, 10); // uses the fast advance()
	advance(lsp, 10); // uses the slow advance()
}
```

Как и другие перегрузки, это механизм времени компиляции, не предполагающий затрат времени выполнения, и там, где компилятор не находит наилучшего выбора, он выдает ошибку двусмысленности. Правила для перегрузки, основанной на концептах, намного проще, чем [[#Функции|правила для общей перегрузки]]. Рассмотрим сначала один аргумент для нескольких альтернативных функций:
>
> Если аргумент не соответствует концепту, этот вариант не может быть выбран.
> 
> Если аргумент соответствует концепту только для одного варианта, выбирается этот вариант.
> 
> Если аргументы из двух вариантов соответствуют концепту, и один из вариантов более строгий, чем другой (соответствует всем требованиям другого и более), выбирается этот вариант.
> 
> Если аргументы из двух вариантов одинаково хорошо соответствуют концепту, это двусмысленность.

Чтобы был выбран вариант, он должен
>
> соответствовать требованиям ко всем его аргументам и
> 
> по крайней мере, одинаково хорошо согласоваться со всеми аргументами, как и другие варианты, и
> 
> лучше соответствовать по крайней мере одному аргументу.

## Правильный код

Вопрос о том, предлагает ли набор аргументов шаблона то, что шаблон требует от своих параметров шаблона, в конечном счете сводится к тому, являются ли некоторые выражения допустимыми.

Используя выражения `requires`, мы можем проверить, является ли набор выражений допустимым. Например, мы могли бы попытаться написать `advance()` без использования [[Concepts#концепт random_access_iterator|концептов стандартной библиотеки random_access_iterator]]:
```c++
template<forward_iterator Iter>
requires requires(Iter p, int i) { p[i]; p+i; } // Iter has subscripting and
												// integer addition
												
void advance(Iter p, int n)                     // move p n elements forward
{
	p+=n;
}
```

Нет, [[requires#requires requires|requires requires]] - это не опечатка. Первое [[requires#requires|requires]] означает начало пункта `requirements`, а второе [[requires#requires|requires]] означает начало выражения `requires`
```c++
requires(Iter p, int i) { p[i]; p+i; }
```

***requires-выражение*** - это предикат, который является `true`, если выражение в нем являются допустимым кодом, и `false` - если нет.

Я считаю `requires-выражения` ассемблерным кодом обобщённого программирования. Как и обычный ассемблерный код, `requires-выражения` чрезвычайно гибки и не налагают никакой дисциплины программирования. В той или иной форме они находятся в низкоуровневой части наиболее интересного обобщённого кода, точно так же, как ассемблерный код находится в низкоуровневой части наиболее интересного обычного кода. Как и в ассемблерном коде, `requires-выражения` не должны быть видны в обычном коде. Они относятся к реализации абстракций. Если вы видите [[requires#requires requires|requires requires]] в своем коде, это, вероятно, слишком низкий уровень и в конечном итоге это станет проблемой.

Намеренное использование [[requires#requires requires|requires requires]] в `advance()` неэлегантно и халтурно. Обратите внимание, что я “забыл” указать `+=` и требуемые возвращаемые типы для операций. Следовательно, некоторые варианты использования версии `advance()` пройдут проверку концепта и все равно не будут компилироваться. Вы были предупреждены! Надлежащая версия `advance()` с произвольным доступом проще и удобочитаемее:
```c++
template<random_access_iterator Iter>
void advance(Iter p, int n) // move p n elements forward
{
	p+=n; // a random-access iterator has +=
}
```

Предпочтительнее использовать правильно названные концепты с четко определенной семантикой и в первую очередь используйте requires-выражения в их определении.

# Определение концептов

Мы находим полезные концепты, такие как [[#концепт forward_iterator|forward_iterator]], в библиотеках, включая стандартную библиотеку ( #§14_5). Что касается классов и функций, обычно проще использовать концепт из хорошей библиотеки, чем писать новый, но определить простые концепты несложно. Имена из стандартной библиотеки, такие как [[#концепт random_access_iterator|random_access_iterator]] и [[vector|vector]], написаны строчными буквами. Здесь я использую соглашение для написания с заглавной буквы названий понятий, которые я определил сам, таких как `Sequence` и `Vector`.

Концепт - это предикат времени компиляции, определяющий, как можно использовать один или несколько типов. Рассмотрим сначала один из простейших примеров:
```c++
template<typename T>
concept Equality_comparable =
	requires (T a, T b) {
		{ a == b } -> Boolean; // compare Ts with ==
		{ a != b } -> Boolean; // compare Ts with !=
	};
```

`Equality_comparable` - это концепт, который мы используем, чтобы гарантировать, что мы можем сравнивать значения типа на равенство и неравенство. Мы просто говорим, что, два значения одного типа, должны быть сопоставимы с помощью `==` и `!=`, и результат этих операций должен быть логическим. Например:
```c++
static_assert(Equality_comparable<int>);     // succeeds

struct S { int a; };
static_assert(Equality_comparable<S>); // fails because structs don't 
										// automatically get == and !=
```

Определение концепта `Equality_comparable` в точности эквивалентно английскому описанию и не более того. Значение `concept` всегда имеет тип `bool`.

Результат действия { `...` }, указанный после `->`, должен быть концептом. К сожалению, `boolean` концепта стандартной библиотеки не существует, поэтому я определил ее ( #§14_5). `Boolean` просто означает тип, который может быть использован в качестве условия.

Определить `Equality_comparable` для обработки сравнений разных типов почти так же просто:
```c++
template<typename T, typename T2 = T>
concept Equality_comparable =
	requires (T a, T2 b) {
		{ a == b } -> Boolean; // compare a T to a T2 with ==
		{ a != b } -> Boolean; // compare a T to a T2 with !=
		{ b == a } -> Boolean; // compare a T2 to a T with ==
		{ b != a } -> Boolean; // compare a T2 to a T with !=
};
```

`typename T2 = T` говорит о том, что если мы не укажем второй аргумент шаблона, `T2` будет таким же, как `T`; `T` - аргумент шаблона по умолчанию. Мы можем протестировать `Equality_comparable` следующим образом:
```c++
static_assert(Equality_comparable<int, double>); // succeeds
static_assert(Equality_comparable<int>); // succeeds (T2 is defaulted to int)
static_assert(Equality_comparable<int,string>); // fails
```

`Equality_comparable` почти идентично [[#концепт equality_comparable|equality_comparable]] стандартной библиотеки.

Теперь мы можем определить концепт, который требует, чтобы между числами были допустимы арифметические операции. Сначала нам нужно определить `Number`:
```c++
template<typename T, typename U = T>
concept Number =
requires(T x, U y) { // Something with arithmetic operations and a zero
	x+y; x-y; x*y; x/y;
	x+=y; x-=y; x*=y; x/=y;
	x=x;             // copy
	x=0;
};
```

Это не делает никаких предположений о типах результатов, но этого достаточно для простого использования. Принимая один тип аргумента, `Number<X>` проверяет, обладает ли `X` желаемыми свойствами числа `Number`. Принимая два аргумента, `Number<X,Y>` проверяет, что эти два типа могут использоваться вместе с требуемыми операциями. Исходя из этого, мы можем определить наш концепт `Arithmetic`:
```c++
template<typename T, typename U = T>
concept Arithmetic = Number<T,U> && Number<U,T>;
```

В качестве более сложного примера рассмотрим `Sequence`:
```c++
template<typename S>
concept Sequence = requires (S a) {
	typename range_value_t<S>; // S must have a value type
	typename iterator_t<S>;    // S must have an iterator type

	{ a.begin() } -> same_as<iterator_t<S>>; // S must have a begin() 
											 //that returns an iterator
											 
	{ a.end() } -> same_as<iterator_t<S>>;
	
	requires input_iterator<iterator_t<S>>; // S's iterator must be an
											// input_iterator
	
	requires same_as<range_value_t<S>, iter_value_t<S>>;
};
```

Чтобы тип `S` был `Sequence`, он должен предоставлять тип значение (тип его элементов; см. #§13_1) и тип итератор (тип его итераторов). Здесь я использовал соответствующие типы стандартной библиотеки [[range#range_value_t|range_value_t<S>]] и [[iterator#iterator_t|iterator_t<S>]], чтобы выразить это. Он также должен гарантировать, что существуют функции `begin()` и `end()`, которые возвращают итераторы `S`, что является идиоматичным для контейнеров стандартной библиотеки ( #§12_3). Наконец, тип итератора `S` должен быть, по крайней мере, [[iterator#input_iterator|input_iterator]], а типы значений элементов и итератора должны совпадать.

Самые трудные для определения понятия - это те, которые представляют фундаментальные языковые концепции. Следовательно, лучше всего использовать набор из установленной библиотеки. В частности, существует концепт стандартной библиотеки, который позволяет нам обойти сложность определения `Sequence`:
```c++
template<typename S>
concept Sequence = input_range<S>; // simple to write and general
```

Если бы я ограничил свое описание “ S является типом значения для `S::value_type`, я мог бы использовать простой [[#концепт Value_type|Value_type]]:
```c++
template<class S>
using Value_type = typename S::value_type;
```

Это полезный прием для краткого выражения простых понятий и сокрытия сложности. Определение стандартного [[value_type_t#value_type_t|value_type_t]] в принципе аналогично, но немного сложнее, поскольку оно обрабатывает последовательности, у которых нет элемента с именем [[value_type_t#value_type|value_type]] (например, встроенные массивы).

### Проверка определения

Концепты, указанные для шаблона, используются для проверки аргументов в момент использования шаблона. Они не используются для проверки использования параметров в определении шаблона. Например:
```c++
template<equality_comparable T>
bool cmp(T a, T b)
{
	return a<b;
}
```

Здесь концепт гарантирует наличие `==`, но не `<`:
```c++
bool b0 = cmp(cout,cerr); // error: ostream doesn't support ==
bool b1 = cmp(2,3); // OK: returns true
bool b2 = cmp(2+3i,3+4i); // error: complex<double> doesn't support <
```

Проверка концептов отлавливает попытку передачи `ostream`, но принимает `int` и `complex<double>`, потому что эти два типа поддерживают `==`. Однако `int` поддерживает `<`, поэтому `cmp(2,3)` компилируется, тогда как `cmp(2+3i,3+4i)` отклоняется, когда тело `cmp()` проверяется и создается экземпляр для `complex<double>`, который не поддерживает `<`.

Отсрочка окончательной проверки определения шаблона до момента создания экземпляра дает два преимущества:
>
> Мы можем использовать неполные концепты во время разработки. Это позволяет нам набираться опыта при разработке концептов, типов и алгоритмов, а также постепенно совершенствовать проверку.
> 
> Мы можем вставить код отладки, трассировки, телеметрии и т.д. в шаблон, не затрагивая его интерфейс. Изменение интерфейса может привести к массовой перекомпиляции.

И то, и другое важно при разработке и обслуживании больших баз кода. Цена, которую мы платим за это важное преимущество, которое заключается в том, что некоторые ошибки, такие как использование `<`, там где гарантируется только `==`, обнаруживаются очень поздно в процессе компиляции.

## Концепты и auto

Ключевое слово [[auto|auto]] может использоваться для указания того, что объект должен иметь [[Инициализация#Инициализация|тип своего инициализатора]]:
```c++
auto x = 1; // x is an int
auto z = complex<double>{1,2}; // z is a complex<double>
```

Однако инициализация происходит не только в простых определениях переменных:
```c++
auto g() { return 99; } // g() returns an int
int f(auto x) { /* ... */ } // take an argument of any type
int x = f(1); // this f() takes an int
int z = f(complex<double>{1,2}); // this f() takes a complex<double>
```

Ключевое слово [[auto|auto]] обозначает наименее ограниченную концепцию для значения: оно просто требует, чтобы это было значение некоторого типа. Использование [[auto|auto]] параметра превращает функцию в шаблон функции.

Учитывая концепции, мы можем усилить требования ко всем таким инициализациям, предваряя [[auto|auto]] концептом. Например:
```c++
auto twice(Arithmetic auto x) { return x+x; } // just for numbers
auto thrice(auto x) { return x+x+x; } // for anything with a +

auto x1 = twice(7);           // OK: x1==14
string s "Hello ";
auto x2 = twice(s);           // error: a string is not Arithmetic
auto x3 = thrice(s);          // OK x3=="Hello Hello Hello "
```

В дополнение к их использованию для ограничения аргументов функций, концепты могут ограничивать инициализацию переменных:
```c++
auto ch1 = open_channel("foo"); // works with whatever open_channel() 
								// returns
Arithmetic auto ch2 = open_channel("foo"); // error: a channel is not 
										   // Arithmetic
Channel auto ch3 = open_channel("foo"); // OK: assuming Channel is an 
				// appropriate concept and that open_channel() returns one
```

Это очень удобно для противодействия чрезмерному использованию [[auto|auto]] и документирования требований к коду с использованием универсальных функций.

Для удобства чтения и отладки часто важно, чтобы ошибка типа была обнаружена как можно ближе к ее источнику. Ограничение возвращаемого типа может помочь:
```c++
Number auto some_function(int x)
{
	...
	
	return fct(x); // an error unless fct(x) returns a Number
	
	...
}
```

Естественно, мы могли бы достичь этого, введя локальную переменную:
```c++
auto some_function(int x)
{
	...
	
	Number auto y = fct(x); // an error unless fct(x) returns a Number
	return y;
	
	...
}
```

Однако это немного многословно, и не все типы можно дешево скопировать.

## Концепты и типы

Тип:
>
> Определяет набор операций, которые могут быть применены к объекту явно и неявно
> 
> Опирается на объявления функций и языковые правила
>  
> Определяет, как объект размещается в памяти

Концепт с одним аргументом:
>
> Определяет набор операций, которые могут быть применены к объекту явно и неявно
> 
> Опирается на шаблоны использования, отражающие объявления функций и языковые правила
> 
> Ничего не говорит о расположении объекта
> 
> Позволяет использовать набор типов

Таким образом, ограничение кода концептами дает большую гибкость, чем ограничение типами. Кроме того, концепты могут определять взаимосвязь между несколькими аргументами. Мой идеал заключается в том, что в конечном итоге большинство функций будут определены как шаблонные функции с их аргументами, ограниченными концептами. К сожалению, нотационная поддержка для этого еще не идеальна: мы должны использовать концепт как прилагательное, а не как существительное. Например:
```c++
void sort(Sortable auto&); // 'auto' required
void sort(Sortable&); // error: 'auto' required after concept name
```

# Обзор концептов

Стандартная библиотека предлагает множество полезных концептов:
>
> Концепты определяющие свойства типов;
> 
> Концепты определяющие итераторы.

## Концепты типов

Концепты, связанные со свойствами типов и отношениями между типами, отражают разнообразие типов. Эти концепты помогают упростить большинство шаблонов.

Основные языковые концепты `<concepts>` `T` и `U` это типы

| `same_as<T,U>`               | `T` такой же как и `U`                             |
| ---------------------------- | -------------------------------------------------- |
| `derived_from<T,U>`          | `T` является производным от `U`                    |
| `convertible_to<T,U>`        | `T` может быть преобразован в `U`                  |
| `common_reference_with<T,U>` | `T` и `U` совместно используют общий ссылочный тип |
| `common_with<T,U>`           | `T` и `U` имеют общий тип                          |
| `integral<T>`                | `T` является целочисленным типом                   |
| `signed_integral<T>`         | `T` является целочисленным типом со знаком         |
| `unsigned_integral<T>`       | `T` является целочисленным типом без знака         |
| `floating_point<T>`          | `T` является типом число с плавающей точкой        |
| `assignable_from<T,U>`       | `U` может быть присвоен `T`                        |
| `swappable_with<T,U>`        | `T` может обменяться значениями с `U`              |
| `swappable<T>`               | `swappable_with<T,T>`                              |

Многие алгоритмы должны работать с комбинациями связанных типов, например, выражениями со смесью `int` и `double`. Мы используем `common_with`, чтобы сказать, является ли такое сочетание математически обоснованным. Если `common_with<X,Y>` возвращает `true`, мы можем использовать `common_type_t<X,Y>` для сравнения `X` с `Y`, сначала преобразовав оба в `common_type_t<X,Y>`. Например:
```c++
common_type<string, const char*> s1 = some_fct()
common_type<string, const char*> s2 = some_other_fct();
if (s1<s2) {
// ...
}
```

Чтобы указать общий тип для пары типов, мы специализируем `common_type_t`, используемый в определении `common`. Например:
```c++
using common_type_t<Bigint,long> = Bigint;
```

К счастью, нам не нужно определять специализацию `common_type_t`, если только мы не хотим использовать операции со смесями типов, для которых в библиотеке (пока)
нет подходящих определений.

Концепты для сравнений `<concepts>`

| `equality_comparable_with<T,U>`  | `T` и `U` могут проверяться на равенство при помощи `==`                               |
| -------------------------------- | -------------------------------------------------------------------------------------- |
| `equality_comparable<T>`         | `equality_comparablewith<T,T>`                                                         |
| `totally_ordered_with<T,U>`      | `T` и `U` могут сравниваться при помощи `<`, `<=`, `>` и `>=` возвращает общий порядок |
| `totally_ordered<T>`             | `strict_totally_ordered_with<T,T>`                                                     |
| `three_way_comparable_with<T,U>` | `T` и `U` могут сравниваться при помощи `<=>` возвращает стабильный результат          |
| `three_way_comparable<T>`        | `three_way_comparable_with<T,T>`                                                       |

Использование как `equality_comparable_with`, так и `equality_comparable` показывает (пока) упущенную возможность перегрузки концептов.

Любопытно, что стандартного концепта `boolean` не существует. Мне это часто нужно, так что вот версия:
```c++
template<typename B>
concept Boolean =
	requires(B x, B y) {
		{ x = true };
		{ x = false };
		{ x = (x == y) };
		{ x = (x != y) };
		{ x = !x };
		{ x = (x = y) };
	};
```

При написании шаблонов нам часто необходимо классифицировать типы.

Концепты объектов `<concepts>`

| `destructible<T>`          | T может быть уничтожен, и его адрес можно записать с помощью унарного `&` |
| -------------------------- | ------------------------------------------------------------------------- |
| constructible_from<T,Args> | `T` может быть сконструирован из списка аргументов типа `Args`            |
| `default_initializable<T>` | `T` имеет конструктор по умолчанию                                        |
| `move_constructible<T>`    | `T` имеет `move`-конструктор                                              |
| `copy_constructible<T>`    | `T` имеет `copy`-конструктор и `move`-конструктор                         |
| `movable<T>`               | `move_constructable<T>, assignable<T&,T> и swapable<T>`                   |
| `copyable<T>`              | `copy_constructable<T>, moveable<T> и assignable<T, const T&>`            |
| `semiregular<T>`           | `copyable<T> и default_constructable<T>`                                  |
| `regular<T>`               | `semiregular<T> и equality_comparable<T>`                                 |

Идеальный вариант для типов это `regular`. Тип соответствующий `regular` работает примерно так же, как `int`, и упрощает большую часть наших размышлений о том, как использовать этот тип ( [[Concepts#Концепт STL|см]]). Отсутствие по умолчанию `==` для классов означает, что большинство классов относятся к `semiregular`, хотя большинство из них могли бы и должны быть `regular`.

Всякий раз, когда мы передаем операцию в качестве аргумента ограниченного шаблона, нам нужно указать, как она может быть вызвана, а иногда и какие предположения мы делаем об их семантике.

Концепты вызовов `<concepts>`

| `invocable<F, Args>`            | `F` может быть вызван со списком аргументов типа `Args`          |
| ------------------------------- | ---------------------------------------------------------------- |
| `regular_invocable<F, Args>`    | `invocable<F, Args>` и сохраняется ли равенство                  |
| `predicate<F, Args>`            | `regular_invocable<F, Args>` возвращающий `bool`                 |
| `relation<F, T, U>`             | `predicate<F, T, U>`                                             |
| `equivalence_relation<F, T, U>` | `relation<F, T, U>` это обеспечивает отношение эквивалентности   |
| `strict_weak_order<F, T, U>`    | `relation<F, T, U>` это обеспечивает строгое слабое упорядочение |

Функция `f()` сохраняет равенство, если `x==y` подразумевает, что `f(x)==f(y). invocable` и `regular_invocable` отличаются только семантически. Мы не можем (в настоящее время) представить это в коде, поэтому имена просто выражают наши намерения.

Аналогично, `relation` и `equivalence_relation` отличаются только семантически. Отношение эквивалентности является рефлексивным, симметричным и транзитивным.

`relation` и `strict_weak_order` отличаются только семантически. Строгий слабый порядок - это то, что стандартная библиотека обычно предполагает для сравнений, таких как `<`.

## Концепты итераторов

Традиционные стандартные алгоритмы получают доступ к своим данным через итераторы, поэтому нам нужны концепты для классификации свойств типов итераторов.

|                               | Концепты итераторов `<iterators>`                                                                                         |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| `input_or_output_iterator<I>` | `I` может быть инкрементирован (`++`) и разименован (`*`)                                                                 |
| `sentinel_for<S, I>`          | `S` является стражем для типа `Iterator`; это значит, `S` это предикат для значения типа `I`                              |
| `sized_sentinel_for<S, I>`    | Страж `S` где оператор – может быть применён к `I`                                                                        |
| `input_iterator<I>`           | `I` это итератор ввода; разыменование `*` может быть использовано только для чтения                                       |
| `output_iterator<I>`          | `I` это итератор вывода; разыменование `*` может быть использовано только для записи                                      |
| `forward_iterator<I>`         | `I` однонаправленный итератор, поддерживающий многопроходность и `==`                                                     |
| `bidirectional_iterator<I>`   | `forward_iterator<I>` поддерживающий `--`                                                                                 |
| `random_access_iterator<I>`   | `bidirectional_iterator<I>` поддерживающий `+`, `-`, `+=`, `-=` и `[]`                                                    |
| `contiguous_iterator<I>`      | `random_access_iterator<I>` для элементов в непрерывной памяти                                                            |
| `permutable<I>`               | `forward_iterator<I>` с поддержкой перемещения и замены                                                                   |
| `mergeable<I1, I2, R, O>`     | Может ли объединять отсортированные последовательности, определенные с помощью `I1` и `I2` в `O` используя `relation<R>`? |
| `sortable<I>`                 | Может ли сортировать последовательности, определенные с помощью `I` используя `less`?                                     |
| `sortable<I, R>`              | Может ли сортировать последовательности, определенные с помощью `I` используя `relation<R>`?                              |

`mergeable` и `sortable` упрощены по сравнению с их определением в C++20.

Различные виды (типы) итераторов используются для выбора наилучшего алгоритма для заданного набора аргументов; [[Concepts#Перегрузка основанная на концептах|см.]] и #§16_4_1. Пример `input_iterator` приведен в #§13_3_1.

Основная идея стража заключается в том, что мы можем выполнять итерацию по диапазону, начиная с итератора, до тех пор, пока предикат не станет истинным для элемента. Таким образом, итератор `p` и страж `s` определяют диапазон `[p:s(*p))`. Например, мы могли бы определить предикат для стража для обхода строки в стиле `C`, используя указатель в качестве итератора. К сожалению, для этого требуется некоторый излишний код, потому что идея состоит в том, чтобы представить предикат как нечто, что нельзя спутать с обычным итератором, но что вы можете сравнить с итератором, используемым для перебора элементов диапазона:
```c++
template<class Iter>
class Sentinel {
	public:
		Sentinel(int ee) : end(ee) { }
		Sentinel() :end(0) {}   // Concept sentinel_for requires a 
								//default constructor
		friend bool operator==(const Iter& p, Sentinel s) 
			{ return (*p == s.end); }
		friend bool operator!=(const Iter& p, Sentinel s) 
			{ return !(p == s); }

	private:
		iter_value_t<const char*> end; // the sentinel value
};
```

Объявление [[friend|friend]] позволяет нам определить бинарные операторы `==` и `!=` для сравнения итератора со стражем в рамках класса.

Мы можем проверить, что этот `Sentinel` соответствует требованиям `sentinel_for` для `const char*`:
```c++
static_assert(sentinel_for<Sentinel<const char*>, const char*>); 
//check the Sentinel for C-style strings
```

Наконец, мы можем написать довольно своеобразную версию программы “Привет, мир!”:
```c++
const char aa[] = "Hello, World!\nBye for now\n";

ranges::for_each(aa, Sentinel<const char*>('\n'), [](const char x) 
	{ cout << x; });
```

Да, это действительно выведет Hello, World! без перехода на новую строку

## Концепты диапазонов

Концепты диапазонов определяют свойства диапазонов.

|                          | Концепты диапазонов `<ranges>`                                                           |
| ------------------------ | ---------------------------------------------------------------------------------------- |
| `range<R>`               | `R` это диапазон с начальным итератором и стражем                                        |
| `sized_range<R>`         | `R` это диапазон, который всегда знает свой размер                                       |
| `view<R>`                | `R` это диапазон с постоянным временем копирования, перемещения и присвоения             |
| `common_range<R>`        | `R` это диапазон с идентичными типами итератора и стража                                 |
| `input_range<R>`         | `R` это диапазон, тип итератора которого удовлетворяет концепту `input_iterator`         |
| `output_range<R>`        | `R` это диапазон, тип итератора которого удовлетворяет  концепту `output_iterator`       |
| `forward_range<R>`       | `R` это диапазон, тип итератора которого удовлетворяет концепту `forward_iterator`       |
| `bidirectional_range<R>` | `R` это диапазон, тип итератора которого удовлетворяет концепту `bidirectional_iterator` |
| `random_access_range<R>` | `R` это диапазон, тип итератора которого удовлетворяет концепту `random_access_iterator` |
| `contiguous_range<R>`    | `R` это диапазон, тип итератора которого удовлетворяет концепту `contiguous_iterator`    |

В `<ranges>` есть еще больше концептов, но этот набор - хорошее начало. Основное использование этих концептов заключается в том, чтобы [[Concepts#Перегрузка основанная на концептах|разрешить перегрузку реализаций на основе свойств типа их входных данных]].

# концепт Arithmetic
#Arithmetic

# концепт copyable
#концепт_copyable

# концепт LessThanComparable
#LessThanComparable

# концепт random_access_iterator
#random_access_iterator

# концепт forward_iterator
#концепт_forward_iterator

# концепт equality_comparable
#концепт_equality_comparable


# концепт Value_type
#концепт_Value_type


# концепт regular
#концепт_regular
К данному концепту относятся строки???


# Базовые концепты

## концепт DefaultConstructible
#концепт_DefaultConstructible
> определяет наличие конструктора по умолчанию.

## концепт MoveConstructible
#концепт_MoveConstructible
> объект строится передачей владения. (конструктор перемещения X(X&&) C++11 )

## концепт CopyConstructible
#концепт_CopyConstructible
> определяет наличие конструктора копирования.

## концепт MoveAssignable
#концепт_MoveAssignable
> определяет наличие операции перемещения ( X& operator=(X&&) C++11 )

## концепт CopyAssignable
#концепт_CopyAssignable
> определяет наличие оператора копирования

## концепт Destructible
#концепт_Destructible
> требует наличие деструктора


# Концепции размещения

## концепт TriviallyCopyable
#концепт_TriviallyCopyable


## концепт TrivialType
#концепт_TrivialType


## концепт StandardLayoutType
#концепт_StandardLayoutType


## концепт PODType
#концепт_PODType



# Library-wide

## концепт EqualityComparable
#концепт_EqualityComparable
> оператор равенства

## концепт LessThanComparable
#концепт_LessThanComparable
> оператор упорядочения


# концепт predicate
#концепт_predicate

# концепт floating_point
#концепт_floating_point


# концепт invocable
#концепт_invocable












