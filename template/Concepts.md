
1. [[#Концепт|Концепт]]
	1. [[#C++17]]
	2. [[#C++20]]
2. [[#Концепт STL|Концепт STL]] 8.2(STL)
	1. [[#Использование концептов|Использование концептов]] 8.2.1 (STL)
	2. [[#Перегрузка основанная на концептах|Перегрузка основанная на концептах]] 8.2.2 (STL)
	3. [[#Правильный код|Правильный код]] 8.2.3 (STL)
	4. [[#Определение концептов|Определение концептов]] 8.2.4 (STL)
		1. [[#Проверка определения|Проверка определения]] 8.2.4.1 (STL)
	5. [[#Концепты и auto|Концепты и auto]] 8.2.5 (STL)
	6. [[#Концепты и типы|Концепты и типы]] 8.2.6 (STL)
3. [[#Обзор концептов|Обзор концептов]] 14.5 (STL) 
	1. [[#Концепты типов|Концепты типов]] 14.5.1 (STL)
	2. [[#Концепты итераторов|Концепты итераторов]] 14.5.2 (STL)
	3. [[#Концепты диапазонов|Концепты диапазонов]] 14.5.3 (STL)
4. [[#Концепты template|Концепты]] Д (Template)
	1. [[#Использование концептов (template)|Использование концептов]] Д.1
	2. [[#Определение концептов (template)|Определение концептов]] Д.2
	3. [[#Перегрузка ограничений (template)|Перегрузка ограничений]] Д.3
		1. [[#Поглощение ограничений (template)|Поглощение ограничений]] Д.3.1
		2. [[#Ограничения и диспетчеризация дескрипторов (template)|Ограничения и диспетчеризация дескрипторов]] Д.3.2
	4. [[#Советы (template)|Советы]] Д.4
		1. [[#Проверка концептов (template)|Проверка концептов]] Д.4.1
		2. [[#Гранулированность концептов (template)|Гранулированность концептов]] Д.4.2
		3. [[#Бинарная совместимость (template)|Бинарная совместимость]] Д.4.3
5. 
6. 
7. [[#концепт Arithmetic|концепт Arithmetic]]
8. [[#концепт copyable|концепт copyable]]
9. [[#концепт random_access_iterator|концепт random_access_iterator]] 
10. [[#концепт forward_iterator|концепт forward_iterator]]
11. [[#концепт equality_comparable|концепт equality_comparable]]
12. [[#концепт Value_type|концепт Value_type]]
13. [[#концепт regular|концепт regular]]
14. [[#Базовые концепты|Базовые концепты]]
	1. [[#концепт DefaultConstructible]]
	2. [[#концепт MoveConstructible]]
	3. [[#концепт CopyConstructible]]
	4. [[#концепт MoveAssignable]]
	5. [[#концепт CopyAssignable]]
	6. [[#концепт Destructible]]
15. [[#Концепции размещения]]
	1. [[#концепт TriviallyCopyable]]
	2. [[#концепт TrivialType]]
	3. [[#концепт StandardLayoutType]]
	4. [[#концепт PODType]]
16. [[#Library-wide]]
	1. [[#концепт EqualityComparable]]
	2. [[#концепт LessThanComparable]]
17. [[#концепт predicate|концепт predicate]]
18. [[#концепт invocable|концепт invocable]]
19. [[#концепт Sequence|концепт Sequence]]

# Концепт

Термин **концепт** (concept) часто используется для обозначения множества ограничений, которые многократно требуются в библиотеке шаблонов. Например, стандартная библиотека C++ опирается на такие ограничения, как итератор с произвольным доступом и конструируемостъ по умолчанию.

В настоящее время (т.е. по стандарту C++17) концепты могут быть более или менее выражены только в документации (например, с помощью комментариев в коде). Это может стать серьезной проблемой из-за того, что нарушение ограничений может привести к [[Применение шаблонов на практике#Расшифровка романов об ошибках|жутким сообщениям об ошибках]].

В течение многих лет были неоднократные попытки ввести определения и проверки концептов в качестве возможности языка. Однако до стандарта C++17 включительно этот подход так и не был стандартизован.

Начиная с С++11, существует возможность выполнения по крайней мере некоторых проверок основных ограничений с использованием ключевого слова [[assert#static_assert()|static_assert]] и некоторых предопределенных свойств типов, например:
```c++
template<typename Т>
class С
{
	static_assert(std::is_default_constructible<T>::value,
		"Класс С требует элементы, "
		"конструируемые по умолчанию");
	
	...
};
```

Без этого статического утверждения, если требуется конструктор по умолчанию, все равно произойдет ошибка компиляции. Однако в таком случае [[Применение шаблонов на практике#Расшифровка романов об ошибках|сообщение об ошибке может содержать всю историю инстанцирования шаблона - от исходной причины неудачного инстанцирования до определения шаблона, в котором была обнаружена ошибка]].

Однако для проверки, например, того, что объекты типа `Т` предоставляют определенную функцию-член или что их можно сравнивать с помощью оператора `<`, требуется куда более сложный код. Подробный пример такого кода приведен в [[Обнаружение членов#Обнаружение членов, не являющихся типами|Обнаружение членов, не являющихся типами]].

## C++17
```c++
#include <vector>
#include <list>
#include <algorithm>

template <typename Container>
void sort(Container & c)
{
    std::sort(c.begin(), c.end());
}

void test()
{
    std::list ls = {3, 2, 1, 5, 4};
    sortContainer(ls);
}
```
## C++20
```c++
#include <vector>
#include <list>
#include <algorithm>
#include <ranges>

void sort(std::ranges::random_access_range auto & c)
{
    std::sort(c.begin(), c.end());
}

void test()
{
    std::list  ls = { 1, 2, 3, 4, 5, 6 };
    sortContainer(ls);
}
```

# Концепт STL

Рассмотрим функцию `sum()`  [[Template_STL#Шаблоны функций|из]]:
```c++
template<typename Seq, typename Value>
Value sum(Seq s, Value v)
{
	for (const auto& x : s)
		v+=x;
	
	return v;
}
```

Функция `sum()` подразумевает что
>
>  его первым аргументом шаблона является некоторая последовательность элементов, и
>  
> его вторым аргументом шаблона является какое-то число.

Чтобы быть более конкретным, `sum()` может быть вызван для пары аргументов:
>
> Последовательность `Seq`, которая поддерживает [[begin|begin()]] и [[end|end()]], для работы диапазонного [[for|for]] .
> 
> Арифметический тип `Value`, который поддерживает `+=`, чтобы можно было суммировать элементы последовательности.

Мы называем такие требования ***концептами***.

Типы, удовлетворяющие этому упрощенному требованию (и многим другим) и считающиеся последовательностью (также называемой диапазоном), это, например, [[vector|vector]], [[list|list]] и [[map|map]] стандартной библиотеки. Типы, удовлетворяющие этому упрощенному требованию (и многим другим) и считающиеся арифметическим типом, включают `int`, `double` и `Matrix` (для любого разумного определения `Matrix`). Мы могли бы сказать, что алгоритм `sum()` является обобщенным в двух измерениях: типе структуры данных, используемой для хранения элементов (“последовательность”), и типе элементов.

## Использование концептов

Большинство аргументов шаблонов должны соответствовать определенным требованиям для правильной компиляции шаблона и правильной работы сгенерированного кода. То есть большинство шаблонов должны быть [[Template_STL#Ограниченные аргументы шаблона|шаблонами с ограничениями]]. Ключевое слово [[typename|typename]] является наименее ограничивающим, требующим только, чтобы аргумент был типом. Обычно мы можем сделать лучше. Рассмотрим функцию `sum()` еще раз:
```c++
template<Sequence Seq, Number Num>
Num sum(Seq s, Num v)
{
	for (const auto& x : s)
		v+=x;
	
	return v;
}
```

Так гораздо понятнее. Как только мы определим, что означают понятия `Sequence` и `Number`, компилятор сможет отклонять некорректные вызовы, просматривая только интерфейс `sum()`, а не его реализацию. Это улучшает представление отчетов об ошибках.

Однако спецификация интерфейса `sum()` не является полной: я “забыл” сказать, что мы должны иметь возможность добавлять элементы `Sequence` к `Number`. Мы можем это сделать:
```c++
template<Sequence Seq, Number Num>
requires Arithmetic<range_value_t<Seq>,Num>
Num sum(Seq s, Num n);
```

[[range#range_value_t|range_value_t]] последовательности - это тип элементов в этой последовательности; он взят из стандартной библиотеки, где он называет тип элементов диапазона [[range#range|range]]. `Arithmetic<X,Y>` - это концепт, указывающий, что мы можем выполнять арифметику с числами типов `X` и `Y`. Это избавляет нас от случайной попытки вычислить `sum()` для `vector<string>` или `vector<int*>`, все еще принимая `vector<int>` и  `ector<complex<double>>`. Как правило, когда алгоритму требуются аргументы разных типов, между этими типами существует взаимосвязь, которую желательно сделать явной.

В этом примере нам понадобился только оператор `+=`, но для простоты и гибкости мы не должны слишком сильно ограничивать наш аргумент шаблона. В частности, возможно, когда-нибудь мы захотим выразить `sum()` в терминах `+` и `=`, а не `+=`, и тогда мы будем счастливы, что использовали общий концепт (здесь, ), а не узкое требование `”наличие +="`.

Частичные спецификации, как и в первом `sum()` использующем концепты, могут быть очень полезны. Если спецификация не полная, некоторые ошибки не будут обнаружены до момента создания экземпляра. Однако даже частичные спецификации выражают намерение и необходимы для плавной поэтапной разработки там, где мы изначально не осознаем всех необходимых нам требований. При наличии зрелых библиотек концептов первоначальные спецификации будут близки к идеальным.

Неудивительно, что `requires Arithmetic<range_value_t<Seq>,Num>` называется пунктом требований `requirements`. Обозначение `template<Sequence Seq>` - это просто сокращение для явного использования `requires Sequence<Seq>`. Если бы мне нравилось многословие, я мог бы с таким же успехом написать
```c++
template<typename Seq, typename Num>
requires Sequence<Seq> && Number<Num> && Arithmetic<range_value_t<Seq>,Num>
Num sum(Seq s, Num n);
```
С другой стороны, мы могли бы также использовать эквивалентность между двумя обозначениями для записи:
```c++
template<Sequence Seq, Arithmetic<range_value_t<Seq>> Num>
Num sum(Seq s, Num n);
```

В кодовых базах, где мы еще не можем использовать `concept`, нам приходится обходиться соглашениями об именовании и комментариями, такими как:
```c++
template<typename Sequence, typename Number>
// requires Arithmetic<range_value_t<Sequence>,Number>
Number sum(Sequence s, Number n);
```

Какую бы форму записи мы ни выбрали, важно разработать [[Concepts#Определение концептов|шаблон с семантически значимыми ограничениями на его аргументы]].

## Перегрузка основанная на концептах

Как только мы правильно определим шаблоны с их интерфейсами, мы сможем выполнять перегрузку на основе их свойств, так же, как мы это делаем для функций. Рассмотрим слегка упрощенную функцию стандартной библиотеки advance(), которая [[iterator#Типы итераторов|дополняет итератор]]:
```c++
template<forward_iterator Iter>
void advance(Iter p, int n) // move p n elements forward
{
	while (n--)
		++p;                // a forward iterator has ++, but not + or +=
}

template<random_access_iterator Iter>
void advance(Iter p, int n) // move p n elements forward
{
	p+=n;                   // a random-access iterator has +=
}
```

Компилятор выберет шаблон с наиболее строгими требованиями, которым удовлетворяют аргументы. В этом случае [[list|list]] предоставляет только прямые итераторы, но [[vector|vector]] предлагает итераторы с произвольным доступом, поэтому мы получаем:
```c++
void user(vector<int>::iterator vip, list<string>::iterator lsp)
{
	advance(vip, 10); // uses the fast advance()
	advance(lsp, 10); // uses the slow advance()
}
```

Как и другие перегрузки, это механизм времени компиляции, не предполагающий затрат времени выполнения, и там, где компилятор не находит наилучшего выбора, он выдает ошибку двусмысленности. Правила для перегрузки, основанной на концептах, намного проще, чем [[#Функции|правила для общей перегрузки]]. Рассмотрим сначала один аргумент для нескольких альтернативных функций:
>
> Если аргумент не соответствует концепту, этот вариант не может быть выбран.
> 
> Если аргумент соответствует концепту только для одного варианта, выбирается этот вариант.
> 
> Если аргументы из двух вариантов соответствуют концепту, и один из вариантов более строгий, чем другой (соответствует всем требованиям другого и более), выбирается этот вариант.
> 
> Если аргументы из двух вариантов одинаково хорошо соответствуют концепту, это двусмысленность.

Чтобы был выбран вариант, он должен
>
> соответствовать требованиям ко всем его аргументам и
> 
> по крайней мере, одинаково хорошо согласоваться со всеми аргументами, как и другие варианты, и
> 
> лучше соответствовать по крайней мере одному аргументу.

## Правильный код

Вопрос о том, предлагает ли набор аргументов шаблона то, что шаблон требует от своих параметров шаблона, в конечном счете сводится к тому, являются ли некоторые выражения допустимыми.

Используя выражения `requires`, мы можем проверить, является ли набор выражений допустимым. Например, мы могли бы попытаться написать `advance()` без использования [[Concepts#концепт random_access_iterator|концептов стандартной библиотеки random_access_iterator]]:
```c++
template<forward_iterator Iter>
requires requires(Iter p, int i) { p[i]; p+i; } // Iter has subscripting and
												// integer addition
												
void advance(Iter p, int n)                     // move p n elements forward
{
	p+=n;
}
```

Нет, [[requires#requires requires|requires requires]] - это не опечатка. Первое [[requires#requires|requires]] означает начало пункта `requirements`, а второе [[requires#requires|requires]] означает начало выражения `requires`
```c++
requires(Iter p, int i) { p[i]; p+i; }
```

***requires-выражение*** - это предикат, который является `true`, если выражение в нем являются допустимым кодом, и `false` - если нет.

Я считаю `requires-выражения` ассемблерным кодом обобщённого программирования. Как и обычный ассемблерный код, `requires-выражения` чрезвычайно гибки и не налагают никакой дисциплины программирования. В той или иной форме они находятся в низкоуровневой части наиболее интересного обобщённого кода, точно так же, как ассемблерный код находится в низкоуровневой части наиболее интересного обычного кода. Как и в ассемблерном коде, `requires-выражения` не должны быть видны в обычном коде. Они относятся к реализации абстракций. Если вы видите [[requires#requires requires|requires requires]] в своем коде, это, вероятно, слишком низкий уровень и в конечном итоге это станет проблемой.

Намеренное использование [[requires#requires requires|requires requires]] в `advance()` неэлегантно и халтурно. Обратите внимание, что я “забыл” указать `+=` и требуемые возвращаемые типы для операций. Следовательно, некоторые варианты использования версии `advance()` пройдут проверку концепта и все равно не будут компилироваться. Вы были предупреждены! Надлежащая версия `advance()` с произвольным доступом проще и удобочитаемее:
```c++
template<random_access_iterator Iter>
void advance(Iter p, int n) // move p n elements forward
{
	p+=n; // a random-access iterator has +=
}
```

Предпочтительнее использовать правильно названные концепты с четко определенной семантикой и в первую очередь используйте requires-выражения в их определении.

# Определение концептов

Мы находим [[Concepts#Обзор концептов|полезные концепты]], такие как [[#концепт forward_iterator|forward_iterator]], в библиотеках, включая стандартную библиотеку. Что касается классов и функций, обычно проще использовать концепт из хорошей библиотеки, чем писать новый, но определить простые концепты несложно. Имена из стандартной библиотеки, такие как [[#концепт random_access_iterator|random_access_iterator]] и [[vector|vector]], написаны строчными буквами. Здесь я использую соглашение для написания с заглавной буквы названий понятий, которые я определил сам, таких как `Sequence` и `Vector`.

Концепт - это предикат времени компиляции, определяющий, как можно использовать один или несколько типов. Рассмотрим сначала один из простейших примеров:
```c++
template<typename T>
concept Equality_comparable =
	requires (T a, T b) {
		{ a == b } -> Boolean; // compare Ts with ==
		{ a != b } -> Boolean; // compare Ts with !=
	};
```

`Equality_comparable` - это концепт, который мы используем, чтобы гарантировать, что мы можем сравнивать значения типа на равенство и неравенство. Мы просто говорим, что, два значения одного типа, должны быть сопоставимы с помощью `==` и `!=`, и результат этих операций должен быть логическим. Например:
```c++
static_assert(Equality_comparable<int>);     // succeeds

struct S { int a; };
static_assert(Equality_comparable<S>); // fails because structs don't 
										// automatically get == and !=
```

Определение концепта `Equality_comparable` в точности эквивалентно английскому описанию и не более того. Значение `concept` всегда имеет тип `bool`.

Результат действия { `...` }, указанный после `->`, должен быть концептом. К сожалению, [[Concepts#Обзор концептов|`boolean` концепта стандартной библиотеки не существует]], поэтому я определил ее. `Boolean` просто означает тип, который может быть использован в качестве условия.

Определить `Equality_comparable` для обработки сравнений разных типов почти так же просто:
```c++
template<typename T, typename T2 = T>
concept Equality_comparable =
	requires (T a, T2 b) {
		{ a == b } -> Boolean; // compare a T to a T2 with ==
		{ a != b } -> Boolean; // compare a T to a T2 with !=
		{ b == a } -> Boolean; // compare a T2 to a T with ==
		{ b != a } -> Boolean; // compare a T2 to a T with !=
};
```

`typename T2 = T` говорит о том, что если мы не укажем второй аргумент шаблона, `T2` будет таким же, как `T`; `T` - аргумент шаблона по умолчанию. Мы можем протестировать `Equality_comparable` следующим образом:
```c++
static_assert(Equality_comparable<int, double>); // succeeds
static_assert(Equality_comparable<int>); // succeeds (T2 is defaulted to int)
static_assert(Equality_comparable<int,string>); // fails
```

`Equality_comparable` почти идентично [[#концепт equality_comparable|equality_comparable]] стандартной библиотеки.

Теперь мы можем определить концепт, который требует, чтобы между числами были допустимы арифметические операции. Сначала нам нужно определить `Number`:
```c++
template<typename T, typename U = T>
concept Number =
requires(T x, U y) { // Something with arithmetic operations and a zero
	x+y; x-y; x*y; x/y;
	x+=y; x-=y; x*=y; x/=y;
	x=x;             // copy
	x=0;
};
```

Это не делает никаких предположений о типах результатов, но этого достаточно для простого использования. Принимая один тип аргумента, `Number<X>` проверяет, обладает ли `X` желаемыми свойствами числа `Number`. Принимая два аргумента, `Number<X,Y>` проверяет, что эти два типа могут использоваться вместе с требуемыми операциями. Исходя из этого, мы можем определить наш концепт `Arithmetic`:
```c++
template<typename T, typename U = T>
concept Arithmetic = Number<T,U> && Number<U,T>;
```

В качестве более сложного примера рассмотрим `Sequence`:
```c++
template<typename S>
concept Sequence = requires (S a) {
	typename range_value_t<S>; // S must have a value type
	typename iterator_t<S>;    // S must have an iterator type

	{ a.begin() } -> same_as<iterator_t<S>>; // S must have a begin() 
											 //that returns an iterator
											 
	{ a.end() } -> same_as<iterator_t<S>>;
	
	requires input_iterator<iterator_t<S>>; // S's iterator must be an
											// input_iterator
	
	requires same_as<range_value_t<S>, iter_value_t<S>>;
};
```

Чтобы тип `S` был `Sequence`, он должен предоставлять тип значение ([[Алгоритмы - STL#Введение|тип его элементов]]) и тип итератор (тип его итераторов). Здесь я использовал соответствующие типы стандартной библиотеки [[range#range_value_t|range_value_t<S>]] и [[iterator#iterator_t|iterator_t<S>]], чтобы выразить это. Он также должен гарантировать, что существуют функции `begin()` и `end()`, которые возвращают итераторы `S`, что является идиоматичным для [[list#std list|контейнеров стандартной библиотеки]]. Наконец, тип итератора `S` должен быть, по крайней мере, [[iterator#input_iterator|input_iterator]], а типы значений элементов и итератора должны совпадать.

Самые трудные для определения понятия - это те, которые представляют фундаментальные языковые концепции. Следовательно, лучше всего использовать набор из установленной библиотеки. В частности, существует концепт стандартной библиотеки, который позволяет нам обойти сложность определения `Sequence`:
```c++
template<typename S>
concept Sequence = input_range<S>; // simple to write and general
```

Если бы я ограничил свое описание “ S является типом значения для `S::value_type`, я мог бы использовать простой [[#концепт Value_type|Value_type]]:
```c++
template<class S>
using Value_type = typename S::value_type;
```

Это полезный прием для краткого выражения простых понятий и сокрытия сложности. Определение стандартного [[value_type_t#value_type_t|value_type_t]] в принципе аналогично, но немного сложнее, поскольку оно обрабатывает последовательности, у которых нет элемента с именем [[value_type_t#value_type|value_type]] (например, встроенные массивы).

### Проверка определения

Концепты, указанные для шаблона, используются для проверки аргументов в момент использования шаблона. Они не используются для проверки использования параметров в определении шаблона. Например:
```c++
template<equality_comparable T>
bool cmp(T a, T b)
{
	return a<b;
}
```

Здесь концепт гарантирует наличие `==`, но не `<`:
```c++
bool b0 = cmp(cout,cerr); // error: ostream doesn't support ==
bool b1 = cmp(2,3); // OK: returns true
bool b2 = cmp(2+3i,3+4i); // error: complex<double> doesn't support <
```

Проверка концептов отлавливает попытку передачи `ostream`, но принимает `int` и `complex<double>`, потому что эти два типа поддерживают `==`. Однако `int` поддерживает `<`, поэтому `cmp(2,3)` компилируется, тогда как `cmp(2+3i,3+4i)` отклоняется, когда тело `cmp()` проверяется и создается экземпляр для `complex<double>`, который не поддерживает `<`.

Отсрочка окончательной проверки определения шаблона до момента создания экземпляра дает два преимущества:
>
> Мы можем использовать неполные концепты во время разработки. Это позволяет нам набираться опыта при разработке концептов, типов и алгоритмов, а также постепенно совершенствовать проверку.
> 
> Мы можем вставить код отладки, трассировки, телеметрии и т.д. в шаблон, не затрагивая его интерфейс. Изменение интерфейса может привести к массовой перекомпиляции.

И то, и другое важно при разработке и обслуживании больших баз кода. Цена, которую мы платим за это важное преимущество, которое заключается в том, что некоторые ошибки, такие как использование `<`, там где гарантируется только `==`, обнаруживаются очень поздно в процессе компиляции.

## Концепты и auto

Ключевое слово [[auto|auto]] может использоваться для указания того, что объект должен иметь [[Инициализация#Инициализация|тип своего инициализатора]]:
```c++
auto x = 1; // x is an int
auto z = complex<double>{1,2}; // z is a complex<double>
```

Однако инициализация происходит не только в простых определениях переменных:
```c++
auto g() { return 99; } // g() returns an int
int f(auto x) { /* ... */ } // take an argument of any type
int x = f(1); // this f() takes an int
int z = f(complex<double>{1,2}); // this f() takes a complex<double>
```

Ключевое слово [[auto|auto]] обозначает наименее ограниченную концепцию для значения: оно просто требует, чтобы это было значение некоторого типа. Использование [[auto|auto]] параметра превращает функцию в шаблон функции.

Учитывая концепции, мы можем усилить требования ко всем таким инициализациям, предваряя [[auto|auto]] концептом. Например:
```c++
auto twice(Arithmetic auto x) { return x+x; } // just for numbers
auto thrice(auto x) { return x+x+x; } // for anything with a +

auto x1 = twice(7);           // OK: x1==14
string s "Hello ";
auto x2 = twice(s);           // error: a string is not Arithmetic
auto x3 = thrice(s);          // OK x3=="Hello Hello Hello "
```

В дополнение к их использованию для ограничения аргументов функций, концепты могут ограничивать инициализацию переменных:
```c++
auto ch1 = open_channel("foo"); // works with whatever open_channel() 
								// returns
Arithmetic auto ch2 = open_channel("foo"); // error: a channel is not 
										   // Arithmetic
Channel auto ch3 = open_channel("foo"); // OK: assuming Channel is an 
				// appropriate concept and that open_channel() returns one
```

Это очень удобно для противодействия чрезмерному использованию [[auto|auto]] и документирования требований к коду с использованием универсальных функций.

Для удобства чтения и отладки часто важно, чтобы ошибка типа была обнаружена как можно ближе к ее источнику. Ограничение возвращаемого типа может помочь:
```c++
Number auto some_function(int x)
{
	...
	
	return fct(x); // an error unless fct(x) returns a Number
	
	...
}
```

Естественно, мы могли бы достичь этого, введя локальную переменную:
```c++
auto some_function(int x)
{
	...
	
	Number auto y = fct(x); // an error unless fct(x) returns a Number
	return y;
	
	...
}
```

Однако это немного многословно, и не все типы можно дешево скопировать.

## Концепты и типы

Тип:
>
> Определяет набор операций, которые могут быть применены к объекту явно и неявно
> 
> Опирается на объявления функций и языковые правила
>  
> Определяет, как объект размещается в памяти

Концепт с одним аргументом:
>
> Определяет набор операций, которые могут быть применены к объекту явно и неявно
> 
> Опирается на шаблоны использования, отражающие объявления функций и языковые правила
> 
> Ничего не говорит о расположении объекта
> 
> Позволяет использовать набор типов

Таким образом, ограничение кода концептами дает большую гибкость, чем ограничение типами. Кроме того, концепты могут определять взаимосвязь между несколькими аргументами. Мой идеал заключается в том, что в конечном итоге большинство функций будут определены как шаблонные функции с их аргументами, ограниченными концептами. К сожалению, нотационная поддержка для этого еще не идеальна: мы должны использовать концепт как прилагательное, а не как существительное. Например:
```c++
void sort(Sortable auto&); // 'auto' required
void sort(Sortable&); // error: 'auto' required after concept name
```

# Обзор концептов

Стандартная библиотека предлагает множество полезных концептов:
>
> Концепты определяющие свойства типов;
> 
> Концепты определяющие итераторы.

## Концепты типов

Концепты, связанные со свойствами типов и отношениями между типами, отражают разнообразие типов. Эти концепты помогают упростить большинство шаблонов.

Основные языковые концепты `<concepts>` `T` и `U` это типы

| `same_as<T,U>`               | `T` такой же как и `U`                             |
| ---------------------------- | -------------------------------------------------- |
| `derived_from<T,U>`          | `T` является производным от `U`                    |
| `convertible_to<T,U>`        | `T` может быть преобразован в `U`                  |
| `common_reference_with<T,U>` | `T` и `U` совместно используют общий ссылочный тип |
| `common_with<T,U>`           | `T` и `U` имеют общий тип                          |
| `integral<T>`                | `T` является целочисленным типом                   |
| `signed_integral<T>`         | `T` является целочисленным типом со знаком         |
| `unsigned_integral<T>`       | `T` является целочисленным типом без знака         |
| `floating_point<T>`          | `T` является типом число с плавающей точкой        |
| `assignable_from<T,U>`       | `U` может быть присвоен `T`                        |
| `swappable_with<T,U>`        | `T` может обменяться значениями с `U`              |
| `swappable<T>`               | `swappable_with<T,T>`                              |

Многие алгоритмы должны работать с комбинациями связанных типов, например, выражениями со смесью `int` и `double`. Мы используем `common_with`, чтобы сказать, является ли такое сочетание математически обоснованным. Если `common_with<X,Y>` возвращает `true`, мы можем использовать `common_type_t<X,Y>` для сравнения `X` с `Y`, сначала преобразовав оба в `common_type_t<X,Y>`. Например:
```c++
common_type<string, const char*> s1 = some_fct()
common_type<string, const char*> s2 = some_other_fct();
if (s1<s2) {
// ...
}
```

Чтобы указать общий тип для пары типов, мы специализируем `common_type_t`, используемый в определении `common`. Например:
```c++
using common_type_t<Bigint,long> = Bigint;
```

К счастью, нам не нужно определять специализацию `common_type_t`, если только мы не хотим использовать операции со смесями типов, для которых в библиотеке (пока)
нет подходящих определений.

Концепты для сравнений `<concepts>`

| `equality_comparable_with<T,U>`  | `T` и `U` могут проверяться на равенство при помощи `==`                               |
| -------------------------------- | -------------------------------------------------------------------------------------- |
| `equality_comparable<T>`         | `equality_comparablewith<T,T>`                                                         |
| `totally_ordered_with<T,U>`      | `T` и `U` могут сравниваться при помощи `<`, `<=`, `>` и `>=` возвращает общий порядок |
| `totally_ordered<T>`             | `strict_totally_ordered_with<T,T>`                                                     |
| `three_way_comparable_with<T,U>` | `T` и `U` могут сравниваться при помощи `<=>` возвращает стабильный результат          |
| `three_way_comparable<T>`        | `three_way_comparable_with<T,T>`                                                       |

Использование как `equality_comparable_with`, так и `equality_comparable` показывает (пока) упущенную возможность перегрузки концептов.

Любопытно, что стандартного концепта `boolean` не существует. Мне это часто нужно, так что вот версия:
```c++
template<typename B>
concept Boolean =
	requires(B x, B y) {
		{ x = true };
		{ x = false };
		{ x = (x == y) };
		{ x = (x != y) };
		{ x = !x };
		{ x = (x = y) };
	};
```

При написании шаблонов нам часто необходимо классифицировать типы.

Концепты объектов `<concepts>`

| `destructible<T>`          | T может быть уничтожен, и его адрес можно записать с помощью унарного `&` |
| -------------------------- | ------------------------------------------------------------------------- |
| constructible_from<T,Args> | `T` может быть сконструирован из списка аргументов типа `Args`            |
| `default_initializable<T>` | `T` имеет конструктор по умолчанию                                        |
| `move_constructible<T>`    | `T` имеет `move`-конструктор                                              |
| `copy_constructible<T>`    | `T` имеет `copy`-конструктор и `move`-конструктор                         |
| `movable<T>`               | `move_constructable<T>, assignable<T&,T> и swapable<T>`                   |
| `copyable<T>`              | `copy_constructable<T>, moveable<T> и assignable<T, const T&>`            |
| `semiregular<T>`           | `copyable<T> и default_constructable<T>`                                  |
| `regular<T>`               | `semiregular<T> и equality_comparable<T>`                                 |

Идеальный вариант для типов это `regular`. Тип соответствующий `regular` работает примерно так же, как `int`, и упрощает большую часть наших размышлений о том, как использовать этот тип ( [[Concepts#Концепт STL|см]]). Отсутствие по умолчанию `==` для классов означает, что большинство классов относятся к `semiregular`, хотя большинство из них могли бы и должны быть `regular`.

Всякий раз, когда мы передаем операцию в качестве аргумента ограниченного шаблона, нам нужно указать, как она может быть вызвана, а иногда и какие предположения мы делаем об их семантике.

Концепты вызовов `<concepts>`

| `invocable<F, Args>`            | `F` может быть вызван со списком аргументов типа `Args`          |
| ------------------------------- | ---------------------------------------------------------------- |
| `regular_invocable<F, Args>`    | `invocable<F, Args>` и сохраняется ли равенство                  |
| `predicate<F, Args>`            | `regular_invocable<F, Args>` возвращающий `bool`                 |
| `relation<F, T, U>`             | `predicate<F, T, U>`                                             |
| `equivalence_relation<F, T, U>` | `relation<F, T, U>` это обеспечивает отношение эквивалентности   |
| `strict_weak_order<F, T, U>`    | `relation<F, T, U>` это обеспечивает строгое слабое упорядочение |

Функция `f()` сохраняет равенство, если `x==y` подразумевает, что `f(x)==f(y). invocable` и `regular_invocable` отличаются только семантически. Мы не можем (в настоящее время) представить это в коде, поэтому имена просто выражают наши намерения.

Аналогично, `relation` и `equivalence_relation` отличаются только семантически. Отношение эквивалентности является рефлексивным, симметричным и транзитивным.

`relation` и `strict_weak_order` отличаются только семантически. Строгий слабый порядок - это то, что стандартная библиотека обычно предполагает для сравнений, таких как `<`.

## Концепты итераторов

Традиционные стандартные алгоритмы получают доступ к своим данным через итераторы, поэтому нам нужны концепты для классификации свойств типов итераторов.

|                               | Концепты итераторов `<iterators>`                                                                                         |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| `input_or_output_iterator<I>` | `I` может быть инкрементирован (`++`) и разименован (`*`)                                                                 |
| `sentinel_for<S, I>`          | `S` является стражем для типа `Iterator`; это значит, `S` это предикат для значения типа `I`                              |
| `sized_sentinel_for<S, I>`    | Страж `S` где оператор – может быть применён к `I`                                                                        |
| `input_iterator<I>`           | `I` это итератор ввода; разыменование `*` может быть использовано только для чтения                                       |
| `output_iterator<I>`          | `I` это итератор вывода; разыменование `*` может быть использовано только для записи                                      |
| `forward_iterator<I>`         | `I` однонаправленный итератор, поддерживающий многопроходность и `==`                                                     |
| `bidirectional_iterator<I>`   | `forward_iterator<I>` поддерживающий `--`                                                                                 |
| `random_access_iterator<I>`   | `bidirectional_iterator<I>` поддерживающий `+`, `-`, `+=`, `-=` и `[]`                                                    |
| `contiguous_iterator<I>`      | `random_access_iterator<I>` для элементов в непрерывной памяти                                                            |
| `permutable<I>`               | `forward_iterator<I>` с поддержкой перемещения и замены                                                                   |
| `mergeable<I1, I2, R, O>`     | Может ли объединять отсортированные последовательности, определенные с помощью `I1` и `I2` в `O` используя `relation<R>`? |
| `sortable<I>`                 | Может ли сортировать последовательности, определенные с помощью `I` используя `less`?                                     |
| `sortable<I, R>`              | Может ли сортировать последовательности, определенные с помощью `I` используя `relation<R>`?                              |

`mergeable` и `sortable` упрощены по сравнению с их определением в C++20.

Различные виды (типы) итераторов используются для выбора наилучшего алгоритма для заданного набора аргументов; [[Concepts#Перегрузка основанная на концептах|Перегрузка основанная на концептах]] и [[Утилиты-STL#Предикаты типа|Предикаты типа]]. Пример `input_iterator` приведен в [[iterator#ostream_iterator и istream_iterator|Потоковые итераторы]].

Основная идея стража заключается в том, что мы можем выполнять итерацию по диапазону, начиная с итератора, до тех пор, пока предикат не станет истинным для элемента. Таким образом, итератор `p` и страж `s` определяют диапазон `[p:s(*p))`. Например, мы могли бы определить предикат для стража для обхода строки в стиле `C`, используя указатель в качестве итератора. К сожалению, для этого требуется некоторый излишний код, потому что идея состоит в том, чтобы представить предикат как нечто, что нельзя спутать с обычным итератором, но что вы можете сравнить с итератором, используемым для перебора элементов диапазона:
```c++
template<class Iter>
class Sentinel {
	public:
		Sentinel(int ee) : end(ee) { }
		Sentinel() :end(0) {}   // Concept sentinel_for requires a 
								//default constructor
		friend bool operator==(const Iter& p, Sentinel s) 
			{ return (*p == s.end); }
		friend bool operator!=(const Iter& p, Sentinel s) 
			{ return !(p == s); }

	private:
		iter_value_t<const char*> end; // the sentinel value
};
```

Объявление [[friend|friend]] позволяет нам определить бинарные операторы `==` и `!=` для сравнения итератора со стражем в рамках класса.

Мы можем проверить, что этот `Sentinel` соответствует требованиям `sentinel_for` для `const char*`:
```c++
static_assert(sentinel_for<Sentinel<const char*>, const char*>); 
//check the Sentinel for C-style strings
```

Наконец, мы можем написать довольно своеобразную версию программы “Привет, мир!”:
```c++
const char aa[] = "Hello, World!\nBye for now\n";

ranges::for_each(aa, Sentinel<const char*>('\n'), [](const char x) 
	{ cout << x; });
```

Да, это действительно выведет Hello, World! без перехода на новую строку

## Концепты диапазонов

Концепты диапазонов определяют свойства диапазонов.

|                          | Концепты диапазонов `<ranges>`                                                           |
| ------------------------ | ---------------------------------------------------------------------------------------- |
| `range<R>`               | `R` это диапазон с начальным итератором и стражем                                        |
| `sized_range<R>`         | `R` это диапазон, который всегда знает свой размер                                       |
| `view<R>`                | `R` это диапазон с постоянным временем копирования, перемещения и присвоения             |
| `common_range<R>`        | `R` это диапазон с идентичными типами итератора и стража                                 |
| `input_range<R>`         | `R` это диапазон, тип итератора которого удовлетворяет концепту `input_iterator`         |
| `output_range<R>`        | `R` это диапазон, тип итератора которого удовлетворяет  концепту `output_iterator`       |
| `forward_range<R>`       | `R` это диапазон, тип итератора которого удовлетворяет концепту `forward_iterator`       |
| `bidirectional_range<R>` | `R` это диапазон, тип итератора которого удовлетворяет концепту `bidirectional_iterator` |
| `random_access_range<R>` | `R` это диапазон, тип итератора которого удовлетворяет концепту `random_access_iterator` |
| `contiguous_range<R>`    | `R` это диапазон, тип итератора которого удовлетворяет концепту `contiguous_iterator`    |

В `<ranges>` есть еще больше концептов, но этот набор - хорошее начало. Основное использование этих концептов заключается в том, чтобы [[Concepts#Перегрузка основанная на концептах|разрешить перегрузку реализаций на основе свойств типа их входных данных]].

# Концепты  template

На протяжении многих лет разработчики языка C++ изучали способы ограничения параметров шаблонов. Например, в нашем шаблоне функции `max()` мы хотели бы с самого начала объявить, что он не должен вызываться для типов, которые не сопоставимы с использованием оператора “меньше”. Для других шаблонов может потребоваться, чтобы они инстанцировались с типами, которые представляют собой корректные типы итераторов (для некоторого официального определения этого термина) или для корректных “арифметических” типов (понятие, которое может быть более широким, чем просто множество встроенных арифметических типов).

Концепт представляет собой именованный набор ограничений на один или несколько параметров шаблона. При разработке C++11 для него была создана богатая система концептов, но интеграция этой возможности в спецификации языка в конечном итоге потребовала слишком много ресурсов Комитета, так что концепты в конечном итоге были исключены из C++11. Некоторое время спустя ыл предложен иной их дизайн, и похоже, что именно он в конечном итоге войдет в язык в той или иной форме. Непосредственно перед тем, как оригинал этой книги отправился в печать, Комитет по стандартизации проголосовал за интегра­ цию нового дизайна в проект С++20. В этом приложении мы опишем основные элементы этого нового дизайна.

Мы уже говорили о концептах и показали некоторые их применения в основном тексте этой книги.
>
> [[enable_if#Применение концептов для упрощения выражений enable_if<>|показано, как использовать требования и концепты для того, чтобы разрешить конструктор только в том случае, когда параметр шаблона преобразуем в строку (чтобы избежать случайного использования конструктора в качестве копирующего конструктора)]].
> 
> [[Полиморфная мощь шаблонов#Применение концептов|показано, как использовать концепты для указания и обеспечения выполнения ограничений на типы, используемые для представления геометрических объектов.]]

# Использование концептов (template)

Сначала рассмотрим использование концептов в коде клиента (т.е. коде, который определяет шаблоны без обязательного определения концептов, применимых к параметрам шаблона).

***===Работа с требованиями===***

Вот как выглядит наш привычный шаблон `max()` с двумя параметрами при использовании ограничения:
```c++
template<typename Т> requires LessThanComparable<T>
Т max(Т а, Т Ь)
{
	return b < а ? а : b;
}
```

Единственным добавлением к нему является конструкция требования (`requires clause`)
```c++
requires LessThanComparable<T>
```

которая полагает, что ранее был объявлен — скорее всего, путем включения заголовочного файла — концепт [[#концепт LessThanComparable|LessThanComparable]]

Такой концепт представляет собой булев предикат (т.е. выражение, которое производит значение тина `bool`), вычисляющий константное выражение. Это важно, потому что ограничения проверяются во время компиляции и поэтому не создают никаких накладных расходов с точки зрения сгенерированного кода: этот шаблон с ограничением будет производить столь же быстрый код, как и для рассматривавшейся ранее версии без ограничений.

При попытках использовать этот шаблон он не будет инстанцироваться до тех пор, пока не будет вычислена конструкция требования и не выяснится, что она дает значение `true`. Если она дает значение `false`, может быть выведено сообщение об ошибке, объясняющее, какая часть требования оказалась не выполненной (или может быть выбран перегруженный шаблон, не приводящий к нарушениям требований).

Конструкции требований не обязаны выражаться в терминах концептов (хотя это хорошая практика, имеющая тенденцию к производству лучшей диагностики): может использоваться любое булево константное выражение. [[enable_if#Применение концептов для упрощения выражений enable_if<>|Например]], приведенный ниже пример кода гарантирует, что шаблонный конструктор нельзя использовать в качестве копирующего конструктора:
```c++
class Person
{
	private:
		std::string name;
	public:
		template<typename STR>
		requires std::is_convertible_v<STR, std::string>
		explicit Person(STR&& n)
			: name(std::forward<STR>(n))
		{
			std::cout << "Шаблонный конструктор для '" << name << "'\n";
		}
	...
};
```

Здесь именованный концепт не используется, что может оказаться вполне приемлемым решением, поскольку тут применено соответствующее булево выражение (в данном случае с использованием свойства типа)
```c++
std::is_convertible_v<STR, std::string>
```

позволяющее решить проблему с помощью шаблонного конструктора в качестве копирующего конструктора. Подробности организации концептов и ограничений по-прежнему активно исследуются сообществом C++ и, скорее всего, будут развиваться с течением времени, но представляется, что достигнуто общее согласие о том, что концепты должны отражать смысл кода, а не то, компилируется ли он.

***===Работа с множественными требованиями===***

В приведенном выше примере есть только одно требование, но не редкость случаи, когда имеется несколько требований. Например, можно представить [[#концепт Sequence|концепт Sequence]], который описывает последовательность значений элементов (соответствуя тому же понятию в стандарте) и шаблон find(), который для данной последовательности и значения возвращает итератор, указывающий на первое вхождение значения в последовательность (если таковые имеются). Этот шаблон может быть определен следующим образом:
```c++
template<typename Seq>
requires Sequence<Seq>&&
EqualityComparable<typename Seq::value_type>
typename Seq::iterator find(Seq const& seq,
							typename Seq::value_type const& val)
{
	return std::find(seq.begin(), seq.end(), val);
)
```

Здесь любой вызов данного шаблона будет сначала проверять поочередно каждое требование, и, только если все требования будут давать значение `true`, шаблон может быть выбран для вызова и инстанцирования (конечно, при условии, что разрешение перегрузки не отбросит шаблон по другим причинам, таким как наличие другого, лучше подходящего шаблона).

Можно также выразить “альтернативные” требования с помощью `||`. Это редко необходимо, и обращаться к этому способу следует с осторожностью, так как чрезмерное использование оператора `||` в конструкциях требований может потенциально потреблять ресурсы компилятора (и заметно замедлять компиляцию). Однако в некоторых ситуациях это может быть очень удобно. Например:
```c++
template<typename Т>
requires Integral<T>
FloatingPoint<T>
Т power(Т b, Т р);
```

Одно требование может включать несколько параметров шаблона, и один концепт может выразить предикат над несколькими параметрами шаблона. Например:
```c++
template<typename Т, typename U>
requires SomeConcept<T, U>
auto f(T x, U y) -> decltype(x + y)
```

Таким образом, концепт может устанавливать связь между параметрами типов.

***===Сокращенная запись единственного требования===***

Чтобы уменьшить накладные расходы конструкций требований, доступно синтаксическое сокращение, когда ограничение включает только один параметр. Пожалуй, его наиболее легко проиллюстрировать в объявлении нашего шаблона `max()` с ограничениями:
```c++
template<LessThanComparable Т>
Т max (Т а, Т Ь)
{
	return b < а ? а : Ь;
}
```

Функционально это определение эквивалентно предыдущему определению `max()`. Однако при повторном объявлении шаблона с ограничениями должна использоваться та же форма, что и в исходном объявлении (в этом смысле объявления разного вида эквивалентны только функционально).

Мы можем использовать такое сокращение для одного из двух требований в шаблоне `find()`:
```c++
template<Sequence Seq>
requires EqualityComparable<typename Seq::value_type>
typename Seq::iterator find(Seq const& seq,
							typename Seq::value_type const& val)
{
	return std::find(seq.begin(), seq.end(), val);
}
```

Это определение эквивалентно приведенному выше определению шаблона `find()` для типов последовательностей.

# Определение концептов (template)

Концепты очень похожи на шаблоны [[constexpr|constexpr]]-переменных типа `bool`, но тип явно не указывается:
```c++
tempiate<typename Т> concept LessThanComparable = ... ;
```

Многоточие здесь заменяется выражением, которое использует различные свойства типов, чтобы установить, является ли тип `Т` действительно сравнимым с помощью оператора `<`. Предложение о концептах в стандарт предоставляет средство для упрощения этой задачи: выражение требования (которое отличается от конструкции требования, описанной выше). Вот как может выглядеть полное определение концепта:
```c++
template<typename Т>
concept LessThanComparable = requires(Т х, Т у)
{
	{ х < у } -> bool;
};
```

Обратите внимание на то, что выражение требования может включать необязательный список параметров: эти параметры никогда не заменяются аргументами, а вместо этого рассматриваются как “фиктивные переменные” для выражений требований. В нашем случае есть только одно такое требование, выражаемое как
```c++
{ х < у } -> bool;
```

Этот синтаксис означает, что 1) выражение `х< у` должно быть корректным в смысле [[SFINAE|SFINAE]], и 2) результат этого выражения должен быть преобразуем в `bool`. Перед токеном `->` может быть добавлено ключевое слово [[noexcept|noexcept]] для указания того факта, что выражение в скобках должно гарантированно не генерировать исключения (т.е. [[noexcept|noexcept (...)]], примененное к этому выражению, должно быть `true`). Часть неявного преобразования (т.е. `-> type`) может быть полностью опущена, если такое ограничение не требуется, и, если должна проверяться только корректность выражения, могут быть опущены фигурные скобки, так что все сводится к одному выражению. Например:
```c++
template<typename Т>
concept Swappable = requires(Т х, Т у)
{
	swap(х, у);
};
```

Выражения требований могут также указывать требования к связанным типам. Рассмотрим [[#концепт Sequence|концепт Sequence]], о котором мы говорили ранее: помимо требования корректности таких выражений, как `seq.begin()`, требуется также наличие соответствующих типов итераторов последовательности, что можно выразить следующим образом:
```c++
template<typename Seq>
concept Sequence = requires(Seq seq)
{
	typename Seq::iterator;
	{ seq.begin() } -> Seq::iterator;
	...
};
```

Здесь выражение `typename type`; выражает требование существования типа (и называется требованием типа). В этом примере тип, который должен существовать, является членом параметра шаблона концепта, но это не обязательно. Мы могли бы, например, потребовать, чтобы существовал тип `IteratorFor<Seq>`, и это можно было бы достичь с помощью выражения
```c++
...
typename IteratorFor<Seq>;
...
```

Определение [[#концепт Sequence|концепта Sequence]] выше показывает, как можно объединять требования, просто перечисляя их одно за другим. Существует третий класс требований, которые состоят в простом вызове другого концепта. Например, предположим, что у нас есть концепт для понятия итератора. Мы хотели бы, чтобы наш [[#концепт Sequence|концепт Sequence]] не только требовал, чтобы `Seq::iterator` был типом, но и чтобы этот тип удовлетворял ограничениям `концепта Iterator`. Это выражается следующим образом:
```c++
template<typename Seq>
concept Sequence = requires(Seq seq)
{
	typename Seq::iterator;
	requires Iterator<typename Seq::iterator>;
	{ seq.begin() } -> Seq::iterator;

	...
};
```

Т.е. мы просто добавляем конструкцию требования в выражение требования (и получаем вложенное требование).

# Перегрузка ограничений (template)

Предположим на минуту, что мы определили `концепты IntegerLike<T>`
и `StringLike<T>` и решили написать шаблоны для вывода значения типов каждого концепта. Мы могли бы сделать это следующим образом:
```c++
template<integerLike Т> void print(Т val); // #1
template<StringLike Т> void print(Т val);  // #2
```

Если бы не различие в ограничениях, эти два объявления объявляли бы один и тот же шаблон. Однако ограничения являются частью сигнатуры шаблона, что позволяет шаблонам быть различимыми во время разрешения перегрузки. В частности, если оба шаблона оказываются жизнеспособными кандидатами, но ограничения оказываются удовлетворены только для шаблона `#1`, то перегрузка выберет именно этот шаблон. Например, предполагая, что `int` удовлетворяет требованию `IntegerLike`, a [[string|std::string]] удовлетворяет требованию `StringLike`, но не наоборот:
```c++
int main()
{
	printf(1);         // Выбран шаблон #1
	printf("1"s);      // Выбран шаблон #2
}
```

Можно представить строковый тип, поддерживающий вычисления с целыми числами. Например, если `"6"_NS` и `"7"_NS` представляют собой два литерала для этого типа, то умножение этих литералов будет давать значение `"42"_NS`. Такой тип может удовлетворять как требованиям `IntegerLike`, так и `StringLike`, и, таким образом, вызов `print ( "42"_NS)` будет неоднозначным.

## Поглощение ограничений (template)

Наше обсуждение перегруженных шаблонов функций, отличающихся ограничениями, включает ограничения, которые в общем случае могут быть взаимоисключающими. Например, в нашем примере с `IntegerLike` и `StringLike` мы могли бы представить типы, удовлетворяющие обеим концептам, но мы ожидаем, что такое может быть достаточно редко, так что наши перегруженные шаблоны `print` остаются полезными.

Существуют, однако, множества концептов, которые не являются взаимоисключающими, в которых один концепт “включает” другой. Классическими примерами этого являются категории итераторов стандартной библиотеки: входного итератора, однонаправленного итератора, двунаправленного итератора, итератора с произвольным доступом (и в C++17 — непрерывного итератора (`contiguous iterator`)). Предположим, у нас есть определение для [[#концепт forward_iterator|Forwardlterator]]:
```c++
template<typename Т>
concept Forwardlterator = ...;
```

Тогда “уточненный” `концепт BidirectionalIterator` может быть определен следующим образом:
```c++
template<typename Т>
concept Bidirectionlterator =
	ForwardIterator<T> &&
	requires(Т it)
{
	{ --it } -> T&
};
```

Следовательно, к возможностям, предоставляемым однонаправленными итераторами, мы добавляем возможность применения префиксного оператора
`operator--`.

Рассмотрим теперь алгоритм [[advance|std::advance()]] (который мы назовем `advanceIter()`), перегруженный для однонаправленных и двунаправленных итераторов с использованием шаблонов с ограничениями:
```c++
template<Forwardlterator Т, typename D>
void advancelter(Т& it, D n)
{
	assert(n >= 0);
	
	for (; n != 0; —n)
	{
		++it;
	}
}

template<Bidirectionallterator T, typename D>
void advanceIter(T& it, D n)
{
	if (n > 0)
	{
		for(; n != 0; —n)
		{
			++it;
		}
	}
	else if (n < 0)
	{
		for(; n != 0; ++n)
		{
			-- it;
		}
	}
}
```

При вызове `advancelter()` с простым однонаправленным итератором (который не обладает свойствами двунаправленного итератора) будут удовлетворяться только ограничения первого шаблона, так что разрешение перегрузки очень простое: выбирается первый шаблон. Однако двунаправленный итератор будет удовлетворять ограничениям обоих шаблонов. В таких случаях, когда разрешение перегрузки не в состоянии предпочесть одного кандидата другому, оно предпочитает кандидата, ограничения которого поглощают (`subsume`) ограничения другого кандидата, в то время как обратное неверно. Точное определение поглощения выходит за рамки этого ознакомительного приложения, но достаточно знать, что если ограничение `C2<Ts...>` определяется как требующее ограничения `C1<Ts...>` и дополнительных ограничений (т.е. использует `&&`), то ограничение `С2` включает `С1`. Очевидно, что в нашем примере `BidirectionalIterator<T>` включает `ForwardIterator<T>`, а потому второй шаблон `advancelter()` предпочтительнее при вызове с двунаправленным итератором.

## Ограничения и диспетчеризация дескрипторов (template)

Напомним, что [[Перегрузка свойств типов#Диспетчеризация дескрипторов|решили вопрос перегрузки advancelter() с помощью диспетчеризации дескрипторов]]. Этот метод может быть интегрирован в шаблоны с ограничениями довольно элегантным способом. Например, входные и однонаправленные итераторы не различимы по их синтаксическим интерфейсам. Так что вместо этого мы можем перейти к дескрипторам, определяя один в терминах другого:
```c++
template<typename Т>
concept Forwardlterator =
	InputIterator<T> &&
	requires
	{
		typename std::iterator_traits<T>:;iterator_category;
		is_convertible_v<std::iterator_traits<T>::iterator_category,
		std::forward_iterator_tag>;
	};
```

Теперь [[#концепт forward_iterator|ForwardIterator<T>]] поглощает `InputIterator<T>`, и мы можем перегружать шаблоны с ограничениями для обеих категорий итераторов.

# Советы (template)

Хотя над концептами C++ работа продолжалась на протяжении многих лет, и в той или иной форме более десяти лет доступны различные экспериментальные реализации, широкий опыт работы с ними только начинает появляться. Мы надеемся, что будущее издание этой книги будет в состоянии предоставить гораздо более практичное руководство по вопросу разработки библиотек на базе шаблонов с ограничениями. Пока что мы предлагаем вашему вниманию три наблюдения.

## Проверка концептов (template)

Концепты являются логическими предикатами, которые представляют собой корректные константные выражения. Поэтому для заданного концепта `С` и некоторых типов `T1`, `Т2`, `...`, моделирующих концепт, мы можем использовать статические проверки:
```c++
static_assert(С<Т1, Т2, ...>, "Модель не работает");
```

Поэтому при разработке концептов рекомендуется также разрабатывать простые типы для проверки концептов этим способом. Сюда входят типы, которые расширяют рамки концептов, отвечая на следующие вопросы.
> 
> Должны ли интерфейсы и/или алгоритмы копировать или перемещать объекты моделируемых типов?
> 
> Какие соглашения приемлемы? Какие необходимы?
> 
> Каков базовый набор операций предполагается в наличии у шаблона? Например, можно ли использовать операцию `*=` или только `*` и `=?`

[[Отладка шаблонов#Архетипы|Здесь также может пригодиться понятие архетипов]].

## Гранулированность концептов (template)

Когда концепты станут частью языка C++, вполне естественно, возникнет желание создавать “библиотеки концептов”, так же, как мы создаем библиотеки классов и библиотеки шаблонов. Как и в случае с другими библиотеками, естественным будет желание разделения концептов на слои различными способами. Мы кратко обсудили пример категорий итераторов, и не такой уж большой скачок следует сделать, чтобы перейти к “категориям диапазонов”, затем, возможно, к “концептам последовательностей” на их основе, и так далее.

С другой стороны, соблазнительно построить все эти концепты поверх некоторых элементарных синтаксических концептов. Например, можно представить:
```c++
template<typename Т, typename 0>
concept Addable =
	requires(Т х, U у)
{
	х + у;
}
```

Однако такой подход не рекомендуется, потому что этот концепт не имеет четкого семантического оттенка, и ей будут удовлетворять самые разные типы. Например, она будет удовлетворена, когда `Т` и `U` представляют собой [[string|std::string]], или когда один тип является указателем, а другой — целочисленным типом, и, конечно же, когда они являются арифметическими типами. Тем не менее во всех этих трех случаях понятие `Addable` означает нечто принципиально иное (соответственно конкатенацию, перемещение итератора и варианты арифметического сложения). Введение такого концепта поэтому является рецептом для библиотек с нечеткими интерфейсами и, вероятно, приводящим к странным неоднозначностям.

Похоже, что концепты лучше всего использовать для моделирования реальных семантических понятий, которые возникают в предметной области задачи. Дисциплинированно поступая таким образом, мы улучшим общий дизайн наших библиотек, так как он будет добавлять последовательность и ясность в интерфейсы, представляемые клиентам. Например, когда стандартная библиотека шаблонов (`STL`) была включена в стандартную библиотеку C++, это было большим шагом вперед. Она, хотя и не основана на концептах, была спроектирована с учетом этого понятия (например, итераторы и иерархия итераторов).

## Бинарная совместимость (template)

Опытным программистам на C++ известно, что при компиляции некоторых сущностей (в частности, функций и функций-членов) до машинного кода связанные с ними имена включают имя объявленного типа и области видимости. Такое имя, обычно именуемое декорированным (`mangled`) именем сущности, используется компоновщиком объектного кода для разрешения ссылок на сущности (например, из других объектных файлов). Так, декорированное имя функции, определенной как
```c++
namespace X
{
	void f() {}
}
```

в Itanium C++ ABI имеет вид `_ZNlXlfEv` (буквы `X` и `f` указывают имя пространства имен и имя функции соответственно).

Декорированные имена в рамках программы не должны приводить к коллизиям. Таким образом, если две функции потенциально могут сосуществовать в программе, они должны иметь собственные декорированные имена. Это, в свою очередь, означает, что в имени функции должны быть закодированы ограничения (поскольку специализации шаблонов, идентичные во всех отношениях, за исключением их ограничений и тел функций, могут находиться в различных единицах трансляции). Рассмотрим две следующие единицы трансляции:
```c++
#include <iostream>
template<typename Т>
concept HasPlus = requires(T x, T y)
{
	x + y;
};

template<typename Т> int f(Т р) requires HasPlus<T>
{
	std::cout << "TU1\n";
}

void g();
int main()
{
	f(1);
	g();
}
```

и
```c++
#include <iostream>

template<typename T>
concept HasMult = requires(T x, T y)
{
	x* y;
};

template<typename T> int f(T p) requires HasMult<T>
{
	std::cout << "TU2\n";
}

template int f(int);
void g()
{
	f(2);
}
```

Эта программа должна выводить
```c++
TU1
TU2
```

т.е. имена двух определений `f()` должны быть декорированы по-разному.

# концепт Arithmetic
#Arithmetic

# концепт copyable
#концепт_copyable



# концепт random_access_iterator
#random_access_iterator

# концепт forward_iterator
#концепт_forward_iterator

# концепт equality_comparable
#концепт_equality_comparable


# концепт Value_type
#концепт_Value_type


# концепт regular
#концепт_regular
К данному концепту относятся строки???


# Базовые концепты

## концепт DefaultConstructible
#концепт_DefaultConstructible
> определяет наличие конструктора по умолчанию.

## концепт MoveConstructible
#концепт_MoveConstructible
> объект строится передачей владения. (конструктор перемещения X(X&&) C++11 )

## концепт CopyConstructible
#концепт_CopyConstructible
> определяет наличие конструктора копирования.

## концепт MoveAssignable
#концепт_MoveAssignable
> определяет наличие операции перемещения ( X& operator=(X&&) C++11 )

## концепт CopyAssignable
#концепт_CopyAssignable
> определяет наличие оператора копирования

## концепт Destructible
#концепт_Destructible
> требует наличие деструктора


# Концепции размещения

## концепт TriviallyCopyable
#концепт_TriviallyCopyable


## концепт TrivialType
#концепт_TrivialType


## концепт StandardLayoutType
#концепт_StandardLayoutType


## концепт PODType
#концепт_PODType



# Library-wide

## концепт EqualityComparable
#концепт_EqualityComparable
> оператор равенства

## концепт LessThanComparable
#концепт_LessThanComparable
> оператор упорядочения


# концепт predicate
#концепт_predicate

# концепт floating_point
#концепт_floating_point


# концепт invocable
#концепт_invocable



# концепт Sequence
#концепт_Sequence







