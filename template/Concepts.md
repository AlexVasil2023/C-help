
[[#Концепт|Концепт]]
[[#Концепт STL|Концепт STL]] 8.2(STL)
1. [[#концепт copyable|концепт copyable]]

# Концепт

Термин **концепт** (concept) часто используется для обозначения множества ограничений, которые многократно требуются в библиотеке шаблонов. Например, стандартная библиотека C++ опирается на такие ограничения, как итератор с произвольным доступом и конструируемостъ по умолчанию.

В настоящее время (т.е. по стандарту C++17) концепты могут быть более или менее выражены только в документации (например, с помощью комментариев в коде). Это может стать серьезной проблемой из-за того, что нарушение ограничений может привести к [[Применение шаблонов на практике#Расшифровка романов об ошибках|жутким сообщениям об ошибках]].

В течение многих лет были неоднократные попытки ввести определения и проверки концептов в качестве возможности языка. Однако до стандарта C++17 включительно этот подход так и не был стандартизован.

Начиная с С++11, существует возможность выполнения по крайней мере некоторых проверок основных ограничений с использованием ключевого слова [[assert#static_assert()|static_assert]] и некоторых предопределенных свойств типов, например:
```c++
template<typename Т>
class С
{
	static_assert(std::is_default_constructible<T>::value,
		"Класс С требует элементы, "
		"конструируемые по умолчанию");
	
	...
};
```

Без этого статического утверждения, если требуется конструктор по умолчанию, все равно произойдет ошибка компиляции. Однако в таком случае [[Применение шаблонов на практике#Расшифровка романов об ошибках|сообщение об ошибке может содержать всю историю инстанцирования шаблона - от исходной причины неудачного инстанцирования до определения шаблона, в котором была обнаружена ошибка]].

Однако для проверки, например, того, что объекты типа `Т` предоставляют определенную функцию-член или что их можно сравнивать с помощью оператора `<`, требуется куда более сложный код. Подробный пример такого кода приведен в #разделе_19_6_3.

Детальное обсуждение концептов в C++ содержится в #приложении_Д, “Концепты”.

# Концепт STL

Рассмотрим функцию `sum()`  [[Template_STL#Шаблоны функций|из]]:
```c++
template<typename Seq, typename Value>
Value sum(Seq s, Value v)
{
	for (const auto& x : s)
		v+=x;
	
	return v;
}
```

Функция `sum()` подразумевает что
>
>  его первым аргументом шаблона является некоторая последовательность элементов, и
>  
> его вторым аргументом шаблона является какое-то число.

Чтобы быть более конкретным, `sum()` может быть вызван для пары аргументов:
>
> Последовательность `Seq`, которая поддерживает [[begin|begin()]] и [[end|end()]], для работы диапазонного [[for|for]] .
> 
> Арифметический тип `Value`, который поддерживает `+=`, чтобы можно было суммировать элементы последовательности.

Мы называем такие требования ***концептами***.

Типы, удовлетворяющие этому упрощенному требованию (и многим другим) и считающиеся последовательностью (также называемой диапазоном), это, например, [[vector|vector]], [[list|list]] и [[map|map]] стандартной библиотеки. Типы, удовлетворяющие этому упрощенному требованию (и многим другим) и считающиеся арифметическим типом, включают `int`, `double` и `Matrix` (для любого разумного определения `Matrix`). Мы могли бы сказать, что алгоритм `sum()` является обобщенным в двух измерениях: типе структуры данных, используемой для хранения элементов (“последовательность”), и типе элементов.



## концепт copyable
#концепт_copyable




