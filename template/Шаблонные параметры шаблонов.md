
# Шаблонные параметры шаблонов

Было бы полезно иметь возможность использовать шаблон класса в качестве параметра шаблона. В качестве примера мы вновь воспользуемся нашим шаблоном класса стека.

При использовании в стеках различных внутренних контейнеров прикладной программист вынужден указывать тип элементов стека дважды: чтобы указать тип внутреннего контейнера, необходимо указать как тип этого контейнера, так и (еще раз) тип его элементов.
```c++
Stack<int, std::vector<int>> vStack;       // Стек, использующий вектор
```

Шаблонные параметры шаблонов позволяют объявлять шаблон класса `Stack` путем указания типа контейнера без повторного указания типа его элементов:
```c++
Stack<int, std::vector> vStack;           // Стек, использующий вектор
```

Для этого нужно указать второй параметр шаблона как шаблонный параметр шаблона. В принципе это будет выглядеть следующим образом:
```c++
template<typename Т, template<typename Elem> class Cont = std::deque>
class Stack
{
	private:
		Cont<T> elems;          // Элементы

	public:
		void push(T const&);    // Добавление элементов в стек
		void pop();             // Снятие со стека
		T const& top() const;   // Возврат верхнего элемента

		bool empty() const      // Проверка пустоты стека
		{
			return elems.empty();
		}
};
```

Отличие заключается в том, что второй параметр шаблона объявляется как шаблон класса:
```c++
template<typename Elem> class Cont
```

Значение по умолчанию изменяется и вместо `std::deque<T>` становится [[deque|std::deque]]. Параметр представляет собой шаблон класса, инстанцируемый для типа, передаваемого в качестве первого параметра шаблона:
```c++
Cont<T> elems;
```

То, что в приведенном выше коде первый параметр шаблона использован для инстанцирования второго параметра шаблона, — особенность данного примера, но отнюдь не правило. В общем случае можно инстанцировать шаблонный параметр шаблона любым типом из шаблона класса.

Как обычно, вместо ключевого слова [[typename|typename]] для параметров шаблона можно использовать ключевое слово `class`. До С++11 имя `Cont` могло заменяться именем шаблона класса
```c++
template<typename Т, template<class Elem> class Cont = std::deque>
class Stack     //OK
{
	...
};
```

Начиная с C++11, можно также заменять `Cont` именем шаблона псевдонима, но до C++17 в стандарт не было внесено соответствующее изменение, разрешающее использование ключевого слова [[typename|typename]] вместо `class` для объявления шаблонного параметра шаблона:
```c++
template<typename Т, template<typename Elem> typename Cont = std::deque>
class Stack             // Ошибка до C++17
{
	...
};
```

Эти два варианта означают в точности одно и то же: использование `class` вместо [[typename|typename]] не мешает использовать шаблон псевдонима в качестве аргумента, соответствующего параметру `Cont`.

Поскольку параметр шаблона шаблонного параметра шаблона не используется, можно просто опустить его имя (если только оно не обеспечивает полезное самодокументирование исходного текста):
```c++
template<typename Т, template<typename> class Cont = std::deque>
class Stack
{
	...
};
```
Соответственно должны быть модифицированы и функции-члены. Так, вы должны указать второй параметр шаблона как шаблонный параметр шаблона. Тоже самое относится и к реализации функций-членов. Функция-член `push()`, например, реализуется следующим образом:
```c++
template<typename Т, template<typename> class Cont>
void Stack<T, Cont>::push(T const& elem)
(
	elems.push_back(elem);    // Добавление копии переданного элемента
}
```

Обратите внимание: в то время как шаблонные параметры шаблона представляют собой заместители для шаблона класса или псевдонима, соответствующего заместителя для шаблонов функции или переменных не существует.

> **Соответствие шаблонных аргументов шаблонов**

Если попытаться использовать новую версию `Stack`, то будет выдано сообщение об ошибке, информирующее, что значение по умолчанию [[deque|std::deque]] несовместимо с шаблонным параметром шаблона `Cont`. Проблема заключается в том, что до C++17 шаблонный аргумент шаблона должен был быть шаблоном с параметрами, точно соответствующими параметрам шаблонного параметра шаблона, который этот аргумент замещает, с некоторыми исключениями, относящимися к параметрам вариативных шаблонов (см. #раздел_12_3_4). Аргументы шаблона по умолчанию для шаблонных аргументов шаблона не рассматриваются, так что добиться точного соответствия, просто опустив аргументы, которые имеют значения по умолчанию, нельзя (в C++17 значения аргументов по умолчанию рассматриваются).

Имеющаяся до С++17 проблема в этом примере связана с тем, что шаблон [[deque|std::deque]] стандартной библиотеки имеет более чем один параметр шаблона: второй параметр (который описывает распределитель памяти) имеет значение по умолчанию, но до C++17 оно не учитывалось при сопоставлении [[deque|std::deque]] параметру `Cont`.

Обходной путь заключается в том, чтобы переписать объявление класса так, чтобы параметр `Cont` ожидал контейнеры с двумя параметрами шаблона:
```c++
template<typename Т, 
		template<typename Elem,
				typename Alloc = std::allocator<Elem>>
		class Cont = std::deque>
class Stack
{
	private:
		Cont<T> elems; // Элементы

	...
};
```

И вновь можно опустить имя `Alloc`, поскольку оно не используется.

Итак, последняя версия нашего шаблона `Stack` (включая шаблоны-члены для присваиваний стеков с отличающимися типами элементов) теперь выглядит следующим образом:
```c++
#include <deque>
#include <cassert>
#include <memory>

template<typename T,
		template<typename Elem,
				typename = std::allocator<Elem>>
		class Cont = std::deque>
class Stack
{
	private:
		Cont<T> elems;          // Элементы

	public:
		void push(T const&);    // Добавление элементов в стек
		void pop();             // Снятие со стека
		Т const& top() const;   // Возврат верхнего элемента

		bool empty() const      // Проверка пустоты стека
		{
			return elems.empty();
		}

		// Присваивание стека с элементами типа Т2
		template<typename Т2,
				template<typename Elem2,
						typename = std::allocator<Elem2>
                        >class Cont2>
		Stack<T, Cont>& operator= (Stack<T2, Cont2> const&);
		
		// Для доступа к закрытым членам Stack<T2> для любого типа Т2:
		template<typename, template<typename, typename>class>
		friend class Stack;
};

template<typename T, template<typename, typename> class Cont>
void Stack<T, Cont>::push(T const& elem)
{
	elems.push_back(elem);  // Добавление копии переданного элемента
}

template<typename Т, template<typename, typename> class Cont>
void Stack<T, Cont>::pop()
{
	assert(!elems.empty());
	elems.pop_back();            // Удаление последнего элемента
}

template<typename T, template<typename, typename> class Cont>
T const& Stack<T, Cont>::top() const
{
	assert(!elems.empty());
	return elems.back();         // Возврат последнего элемента
}

template<typename T, template<typename, typename> class Cont>
template<typename T2, template<typename, typename> class Cont2>
Stack<T, Cont>& Stack<T, Cont>::operator= (Stack<T2, Cont2> const& op2)
{
	elems.clear();                // Удаление существующих элементов
	
	elems.insert(elems.begin(),   // Вставка в начало
				ор2.elems.begin(),// всех элементов из ор2
				ор2.elems.end());

	return *this;
}
```

Обратите внимание на то, что для получения доступа ко всем членам `ор2` мы объявляем, что все прочие экземпляры стека являются друзьями (опуская имена параметров шаблонов):
```c++
template<typename, template<typename, typename>class>
friend class Stack;
```

Тем не менее не все шаблоны стандартных контейнеров могут использоваться в качестве параметра `Cont`. Например, [[Array|std::array]] работать не будет, потому что он включает в качестве длины массива параметр шаблона, не являющийся типом, который не имеет соответствия в нашем объявлении шаблонного параметра шаблона.

Приведенная ниже программа использует все возможности этой окончательной версии стека:
```c++
#include "stack9.hpp"
#include ciostream>
#include Cvector>

int main()
{
	Stack<int> iStack;       // Стек элементов типа int
	Stack<float> fStack;     // Стек элементов типа float

	// Работа co стеком элементов типа int
	iStack.push(1);
	iStack.push(2);
	std::cout << "iStack.top(): " << iStack.top() << '\n';
	
	// Работа co стеком элементов типа float
	fStack.push(3.3);
	std::cout << "fStack.top(): " << fStack.top() << '\n';

	// Присваивание стека с отличающимся типом
	// элементов и дальнейшая работа
	fStack = iStack;
	fStack.push(4.4);
	std::cout << "fStack.top(): " << fStack.top() << '\n';
	
	// Стек для элементов типа double с использованием
	// вектора в качестве внутреннего контейнера
	Stack<double, std::vector> vStack;
	vStack.push(5.5);
	vStack.push(6.6) ;
	std::cout << "vStack.top(): " << vStack.top() << '\n’;

	vStack = fStack;
	std::cout << "vStack: ";

	while(!vStack.empty())
	{
		std::cout << vStack.top() << '  ';
		vStack.pop();
	}

	std::cout << '\n';
}
```

Вывод программы имеет следующий вид:
```c++
iStack.top(): 2
fStack.top(): 3.3
fStack.top(): 4.4
vStack.top(): 6.6
vStack: 4.4 2 1
```

Продолжение обсуждения данной темы и примеры шаблонных параметров шаблонов вы найдете в #разделах_12_2_3, #12_3_4 и #19_2_2.

