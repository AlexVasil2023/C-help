
[[#Метапрограммирование|Метапрограммирование]] 23
1. [[#Состояние современного метапрограммирования|Состояние современного метапрограммирования]] 23.1
	1. [[#Метапрограммирование значений|Метапрограммирование значений]] 23.1.1
	2. [[#Метапрограммирование типов|Метапрограммирование типов]] 23.1.2
	3. [[#Гибридное метапрограммирование|Гибридное метапрограммирование]] 23.1.3
	4. [[#Гибридное метапрограммирование с типами единиц|Гибридное метапрограммирование с типами единиц]] 23.1.4
2. [[#Размерности рефлексивного метапрограммирования|Размерности рефлексивного метапрограммирования]] 23.2
3. [[#Стоимость рекурсивного инстанцирования|Стоимость рекурсивного инстанцирования]] 23.3
4. 

# Метапрограммирование

***Метапрограммирование*** — это “программирование программ”. Другими словами, в процессе метапрограммирования создается код, который, будучи выполнен системой программирования, в свою очередь генерирует новый код, реализующий необходимую функциональность. Обычно понятие метапрограммирование подразумевает рефлексивность: метапрограммный компонент — это часть программы, для которой он генерирует фрагмент программного кода (дополнительный или отличающийся от кода программы).

Зачем нужно метапрограммирование? Как и большинство других технологий программирования, оно применяется, чтобы достичь больших функциональных возможностей ценой меньших затрат, измеряемых объемом кода, усилиями на сопровождение и т.п. Характерной особенностью метапрограммирования является го, что определенная часть необходимых пользователю вычислений выполняется на этапе трансляции программы. Его применение нередко объясняется повышением производительности (вычисление, которое выполняется во время трансляции, зачастую может быть полностью удалено из программы) или упрощением интерфейса (в общем случае метапрограмма короче, чем программа, в которую она раскрывается), а иногда и обеими этими причинами.

Нередко метапрограммирование основано на [[Реализация свойств типов#Реализация свойств типов|концепции свойств и функций типов,  “Реализация свойств типов”]]. Поэтому рекомендуется ознакомиться с указанной главой до изучения материала настоящей главы.

# Состояние современного метапрограммирования

Метапрограммирование на C++ существенно эволюционировало со временем (заключительные замечания в конце этой главы рассказывают о некоторых вехах в данной области). Давайте рассмотрим и классифицируем различные подходы к метапрограммированию, широко используемые в современном C++.

## Метапрограммирование значений

В первом издании этой книги мы были ограничены возможностями языка из исходного стандарта C++ (опубликован в 1998 году, с незначительными исправлениями в 2003 году). В том мире написание простых вычислений времени компиляции (“мета-”) было проблематично. Поэтому ему была посвящена значительная часть главы, включая довольно сложный пример вычисления квадратного корня из целочисленного значения во время компиляции с помощью рекурсивного инстанцирования. [[Программирование времени компиляции#Вычисления с использованием constexpr|стандарт C++ 11 и, в особенности, С++14, устранил массу сложностей, введя в язык constexpr-функции]]. Например, начиная с C++14, функция времени компиляции для вычисления квадратного корня легко записывается следующим образом:
```c++
template<typename Т>
constexpr Т sqrt(Т х)
{
	// Обработка случаев, когда х и его квадратный корень
	// равны — как частный случай для упрощения критерия
	// прекращения итераций для больших х:
	if (х <= 1)
		return х;
	
	// Многократное определение, в какой половине интервала
	// [lo, hi] находится квадратный корень из х, пока интервал
	// не уменьшится до единственного значения:
	Т lо = 0, hi = х;
	for(;;)
	{
		auto mid = (hi + lo) / 2, midSquared = mid * mid;
		if (lo + 1 >= hi || midSquared == x)
		{
			// Значение mid должно быть квадратным корнем:
			return mid;
		}
		
		// Продолжение с соответствующим полуинтервалом:
		if (midSquared < х)
			lo = mid;
		else
			hi = mid;
	}
}
```

Этот алгоритм ищет ответ, многократно деля пополам интервал, который содержат квадратный корень из `х` (корни `0` и `1` рассматриваются как особые случаи для упрощения критерия сходимости). Эта функция sqrt() может быть вычислена как во время компиляции, так и во время выполнения:
```c++
static_assert(sqrt(25) == 5, "");   // OK (вычисление времени компиляции)
static_assert (sqrt (40) == 6, ""); // OK (вычисление времени компиляции)

std::array<int,sqrt(40)+1> arr;     // Объявление массива из 7 элементов
									// (вычисление времени компиляции)
long long l = 53478;
std::cout << sqrt(l) << '\n';       // Вывод 231
									// (вычисление времени выполнения)
```

Реализация этой функции может не быть наиболее эффективным способом вычисления квадратного корня во время выполнения (где часто используются особенности целевой машины), но, поскольку она предназначена для выполнения вычислений во время компиляции, абсолютная эффективность важна меньше, чем переносимость. Обратите внимание на то, что в этом примере нет никакой “шаблонной магии” для вычисления квадратного корня, только вывод аргумента шаблона, обычный для шаблона функции. Это “простой код C++”, который к тому же не является особенно сложным для чтения.

Метапрограммирование значений (т.е. программирование вычисления значений во время компиляции), пример которого показан выше, иногда очень полезно, но есть еще две дополнительные разновидности метапрограммирования, которые могут быть выполнены с использованием современного C++ (скажем, С++14 и C++17), — метапрограммирование типов и гибридное метапрограммирование.

## Метапрограммирование типов

Мы уже сталкивались с [[Реализация свойств типов#Реализация свойств типов|вычислениями типов]], которые принимают в качестве входных данных тип и производят из него новый тип. Например, наш шаблон класса `RemoveReferenceT` вычисляет базовый тип для входного ссылочного типа. Однако примеры, которые мы разработали в упомянутой главе, выполняют только самые элементарные операции над типами. С помощью рекурсивного инстанцирования шаблона — основы метапрограммирования шаблонов — мы можем выполнить значительно более сложные вычисления типов. 

Рассмотрим следующий небольшой пример:
```c++
// Первичный шаблон: в общем случае дает переданный тип:
template<typename Т>
struct RemoveAllExtentsT
{
	using Type = T;
};

// Частичная специализация для типов массивов
// (с границами и без таковых):
template<typename Т, std::size_t SZ>
struct RemoveAllExtentsT<T[SZ]>
{
	using Туре = typename RemoveAllExtentsT<T>::Type;
};

template<typename T>
struct RemoveAllExtentsT<T[]>
{
	using Type = typename RemoveAllExtentsT<T>::Type;
};

template<typename T>
using RemoveAllExtents = typename RemoveAllExtentsT<T>::Type;
```

Здесь `RemoveAllExtents` представляет собой метафункцию типа (т.е. вычислительное устройство, производящее тип результата), которая будет удалять из типа произвольное количество “слоев массива”. Его можно использовать следующим образом:
```c++
RemoveAllExtents<int[]>                 // Дает int
RemoveAllExtents<int[5][10]>            // Дает int
RemoveAllExtents<int[][10]>             // Дает int
RemoveAllExtents<int(*)[5]>             // Дает int(*)[5]
```

Эта метафункция выполняет свою задачу путем частичной специализации, которая соответствует случаю массива верхнего уровня и рекурсивно вызывает саму эту метафункцию.

Вычисления со значениями будут весьма ограниченными, если все, что нам доступно — это скалярные значения. К счастью, почти любой язык программирования имеет по крайней мере одну конструкцию контейнера значений, что значительно увеличивает мощность этого языка (а большинство языков имеют целый ряд разных контейнеров, таких как массивы/векторы, хеш-таблицы и т.д.). То же верно и для метапрограммирования типов: добавление конструкции “контейнер типов” значительно увеличивает применимость метапрограммирования. К счастью, современный C++ включает в себя механизмы, позволяющие разработать такой контейнер. В #главе_24, “Списки типов”, подробно рассматривается разработка шаблона класса `Typelist<...>`, который представляет собой именно такой контейнер типов.

## Гибридное метапрограммирование

Метапрограммирование значений и метапрограммирование типов позволяет вычислять значения и типы во время компиляции. Однако в конечном счете мы заинтересованы в результатах во время выполнения, поэтому используем эти метапрограммы в коде времени выполнения в местах, где ожидаются типы и константы. Но метапрограммирование способно на большее: во время компиляции можно программно собрать фрагменты кода с результатом, получаемым во время выполнения. Мы называем эту деятельность гибридным метапрограммированием.

Чтобы проиллюстрировать этот принцип, начнем с простого примера: скалярного произведения двух значений [[Array|std::array]]. Вспомним, что [[Array|std::array]] является шаблоном контейнера фиксированной длины, объявленным следующим образом:
```c++
namespace std
{
	template<typename Т, size_t N> struct array;
}
```

где `N` — количество элементов (типа `Т`) в массиве. Для двух объектов одного и того же типа массива их скалярное произведение можно вычислить следующим образом:
```c++
template<typename Т, std::size_t N>
auto dotProduct(std::аггау<T, N> const& x, std::array<T, N> const& y)
{
	T result{};

	for (std::size_t k = 0; k < N; ++k)
	{
		result += x[k] * y[k];
	}
	
	return result;
}
```

Прямая компиляция цикла for будет генерировать инструкции ветвления, ко­
торые на некоторых машинах могут привести к определенным накладным рас­
ходам по сравнению с линейным вычислением:
```c++
result += х[0] * у[0];
result += х[1] * у[1];
result += х[2] * у[2];
result += х[3] * у[3];

...
```

К счастью, современные компиляторы оптимизируют циклы в ту форму вычислений, которая оказывается наиболее эффективной для целевой платформы. Однако с дидактическими целями перепишем реализацию нашего шаблона `dotProduct()` так, чтобы избежать цикла:
```c++
template<typename Т, std::size__t N>
struct DotProductT
{
	static inline T result(T* a, T* b)
	{
		return *a * *b + DotProduct<T, N-1>::result(a+1, b+1);
	}
};

// Частичная специализация в качестве критерия остановки
template<typename Т>
struct DotProductT<T, 0>
{
	static inline Т result(Т*, Т*)
	{
		return Т{};
	}
};

template<typename Т, std::size_t N>
auto dotProduct(std::array<T, N> const& x, std::array<T, N> const& y)
{
	return DotProductT<T, N>::result(x.begin(), y.begin)));
}
```

Новая реализация делегирует работу шаблону класса `DotProductT`. Это позволяет нам использовать рекурсивное инстанцирование шаблона с частичной специализацией шаблона класса для прекращения рекурсии. Обратите внимание на то, как каждый экземпляр `DotProductT` выполняет суммирование одного члена скалярного произведения и скалярное произведение остальных компонентов массива. Поэтому для значений типа `std::array<T, N>` будет существовать `N` экземпляров первичного шаблона и один экземпляр завершающей частичной специализации. Это решение будет эффективным, если компилятор будет встраивать каждый вызов статической функции-члена `result()`. К счастью, обычно это так и происходит даже при включенном умеренном уровне оптимизации компилятора.

Главным в этом коде является то, что он смешивает вычисления времени компиляции (достигнутые здесь с помощью рекурсивного инстанцирования шаблона), определяющие общую структуру кода, с вычислениями времени выполнения (вызов `result()`), которые и определяют конкретный результат вычислений времени выполнения.

Ранее мы упоминали, что возможности метапрограммирования типов значительно усиливаются при наличии “контейнеров типов”. Мы уже видели, что в гибридном метапрограммировании может быть полезен тип массива фиксированной длины. Тем не менее истинным “героем” гибридного метапрограммирования является кортеж. Кортеж — это последовательность значений, каждое с выбираемым типом. Стандартная библиотека языка C++ содержит шаблон класса [[tuple|std::tuple]], который поддерживает это понятие. Например, код
```c++
std::tuple<int, std::string, bool> tVal{42, "Answer", true};
```

определяет переменную `tVal`, которая объединяет три значения с типами `int`, [[string|std::string]] и `bool` (в этом определенном порядке). Ввиду огромной важности таких контейнеров, как кортежи, для современного программирования C++, мы подробно рассматриваем один из них в #главе_25, “Кортежи”. Тип `tVal` выше очень похож на простой тип `struct`:
```c++
struct MyTriple
{
	int v1;
	std::string v2;
	bool v3;
};
```

При наличии [[Array|std::array]] и [[tuple|std::tuple]], которые обеспечивают нас гибкими двойниками типов массивов и (простых) `struct`, естественно задуматься над аналогом простых типов объединений [[union|union]], которые также могут быть полезными для гибридных вычислений. Для этой цели стандартная библиотека C++ в стандарте С++17 представляет шаблон [[variant|std::variant]] (мы разработаем аналогичный компонент в #главе_26, “Контролируемые объединения”).

Поскольку [[tuple|std::tuple]] и [[variant|std::variant]], как и типы `struct`, представляют собой гетерогенные типы, гибридное метапрограммирование, использующее такие типы, иногда называют *гетерогенным метапрограммированием*.

## Гибридное метапрограммирование с типами единиц

Еще один пример, демонстрирующий возможности гибридных вычислений, — это библиотеки, которые в состоянии вычислять результаты значений типов различных единиц. Вычисление значений происходит во время выполнения, а результирующие единицы вычисляются во время компиляции.

Проиллюстрируем сказанное на весьма упрощенном примере. Мы хотим отслеживать единицы в терминах долей основной единицы. Например, если основная единица времени — секунда, то миллисекунда может быть представлена с помощью соотношения 1/1000, а минута — с помощью соотношения 60/1. Ключевым моментом является определение типа отношения, в котором каждое значение имеет свой собственный тип:
```c++
template<unsigned N, unsigned D = 1>
struct Ratio
{
	static constexpr unsigned num = N; // Числитель
	static constexpr unsigned den = D; // Знаменатель
	using Type = Ratio<num, den>;
};
```

Теперь мы можем определить вычисления времени компиляции, такие как сложение двух единиц:
```c++
// Реализация сложения двух дробей:
template<typename R1, typename R2>
struct RatioAddImpl
{
	private:
		static constexpr unsigned den = R1::den*R2::den;
		static constexpr unsigned num = R1::num*R2::den+R2::num*R1::den;
	public:
		typedef Ratio<num, den> Type;
};

// Используем объявление для удобства работы:
template<typename R1, typename R2>
using RatioAdd = typename RatioAddImp<R1, R2>::Type;
```

Это позволяет нам вычислять сумму двух рациональных значений (дробей) во время компиляции:
```c++
using R1 = Ratio<1, 1000>;
using R2 = Ratio<2, 3>;
using R3 = RatioAdd<R1, R2>;   // RS имеет тип Ratio<2003, 3000>

std::cout << RS::num << '/' << RS::den << '\n'; // Выводит 2003/3000

			// RA имеет тип type Ratio<29,21>
using RA = RatioAdd<Ratio<2,3>, Ratio<5,7>>; 
std::cout << RA::num << '/' << RA: :den « '\n';  // Выводит 29/21
```

Теперь можно определить шаблон класса для единицы измерения длительностей, параметризованный произвольным типом значения и типом единицы, который является экземпляром `Ratio<>`:
```c++
// Тип длительности для значений типа Т и типа единиц U:
template<typename Т, typename U = Ratio<1>>
class Duration
{
	public:
		using ValueType = T;
		using UnitType = typename U::Type;
	private:
		ValueType val;
	public:
		constexpr Duration(ValueType v = 0)
			: val(v)
		{  }
		
		constexpr ValueType value() const
		{
			return val;
		}
};
```

Наиболее интересной частью является определение оператора `operator+` для сложения двух `Duration`:
```c++
// Сложение двух длительностей, единицы которых могут быть различны:
template<typename T1, typename U1, typename T2, typename U2>
auto constexpr operator+   (Duration<T1, U1> const& lhs,
							Duration<T2, U2> const& rhs)
{
	// Результирующий тип представляет собой единицу с l в качестве
	// числителя и результирующим знаменателем суммы двух дробей
	// с типами единиц
	using VT = Ratio<l, RatioAdd<U1, U2>::den>;

	// Результирующее значение представляет собой сумму обоих
	// значений, преобразованных в тип результирующих единиц:
	auto val =  lhs.value() * VT::den / U1::den * U1::num +
				rhs.value() * VT::den / U2::den * U2::num;

	return Duration<decltype(val), VT>(val);
}
```

Мы разрешаем аргументам иметь различные типы единиц измерения, `U1` и `U2`. И мы используем эти типы единиц для вычисления результирующей длительности, имеющей тип единиц, который представляет собой соответствующую единичную дробь (дробь, у которой числитель равен `1`). С учетом всего сказанного можно скомпилировать следующий код:
```c++
int х = 42;
int у = 77;

auto а = Duration<int, Ratio<1, 1000>>(х); // х миллисекунд
auto b = Duration<int, Ratio<2, 3>>(у);    // у 2/3 секунд
auto с = а + b; // Вычисление результирующего типа единиц измерения,
				// как 1/3000 секунды, и генерация кода для вычис-
				// ления времени выполнения с = а*3 + Ь*2000
```

Ключевым “гибридным” результатом является то, что для суммы `с` результирующий тип определяется компилятором как тип единицы `Ratio<1,3000>` во время компиляции, и генерируется код для вычисления во время выполнения результирующего значения, которое измеряется в соответствующих типах единиц.

Поскольку тип значения представляет собой параметр шаблона, мы можем использовать класс `Duration` с типами значений, отличными от `int`, или даже применить гетерогенные типы значений (лишь бы была определена операция суммирования значений этих типов):
```c++
auto d = Duration<double, Ratio<1,3>>(7.5); // 7.5 раз по 1/3 секунды
auto е = Duration<int, Ratio<1>>(4);        // 4 секунды
auto f = d + е;
				// Результирующий тип единицы вычисляется как
				// 1/3 секунды, и генерируется код для вычисления
				// f = d + е*3
```

Кроме того, компилятор может даже вычислить значения во время компиляции, если, конечно, они известны ему на этом этапе, поскольку `operator+` для длительностей является [[constexpr|constexpr]]-оператором.

Этот подход использован в шаблоне класса [[Chrono|std::chrono]] стандартной библиотеки C++ (с рядом усовершенствований, таких как применение предопределенных единиц (например, `std::chrono::milliseconds`), поддержка литералов, представляющих длительность (например, `10ms`) и обработка переполнений).

# Размерности рефлексивного метапрограммирования

Ранее мы описывали метапрограммирование значений, основанное на вычислениях [[constexpr|constexpr]], и метапрограммирование типов, использующее рекурсивные инстанцирования шаблона. Очевидно, что оба эти варианта, доступные в современном C++, используют различные методы управления вычислениями. Однако оказывается, что метапрограммирование значений также может управляться с использованием рекурсивных инстанцирований шаблона (а до введения [[constexpr|constexpr]]-функций в стандарте C++11 это был единственный доступный механизм управления). Например, приведенный ниже код вычисляет квадратный корень из целого числа с использованием рекурсивных инстанцирований:
```c++
// Первичный шаблон для вычисления sqrt(N)
template<int N, int LO = 1, int HI = N>
struct Sqrt
{
	// Вычисление округленного вверх значения средней точки
	static constexpr auto mid = (LO + HI + 1) / 2;
	
	// Поиск не слишком большого значения в половине интервала
	static constexpr auto value = (N < mid* mid)
									? Sqrt<N, LO, mid-1>::value
									: Sqrt<N, mid, HI>::value;
};

// Частичная специализация для LO, равного HI
template<int N, int M>
struct Sqrt<N, M, M>
{
	static constexpr auto value = M;
};
```

Эта метапрограмма использует, по сути, тот же [[Метапрограммирование#Метапрограммирование значений|алгоритм, что и наше вычисление целого квадратного корня в constexpr-функции]], последовательно деля пополам интервал, который содержит квадратный корень. Входными данными для метафункции служат нетиповые аргументы шаблона; таковыми же оказываются и “локальные переменные”, отслеживающие границы интервала. Очевидно, что это гораздо менее дружественный подход, чем использование [[constexpr|constexpr]]-функции. Позже мы проанализируем этот код, чтобы понять, насколько сильно он потребляет ресурсы компилятора.

В любом случае, мы видим, что вычислительный механизм метапрограммирования потенциально может предлагать много вариантов выбора. Кроме того, эти варианты могут рассматриваться не в единственном измерении — мы предпочитаем думать, что всеобъемлющее метапрограммное решение в C++ должно делать выбор в трех измерениях:
>
> вычисления;
> 
> рефлексия;
> 
> генерация.

Рефлексия представляет собой возможность программно проверять функциональные возможности программы. Генерация относится к возможности создания дополнительного кода программы.

Мы уже видели два возможных варианта для выполнения вычислений: рекурсивное инстанцирование и [[constexpr|constexpr]]-вычисление. Для рефлексии мы нашли частичное решение в [[Обнаружение членов#Обнаружение членов-типов|свойствах типов]]. Хотя имеющиеся признаки делают доступными некоторое количество расширенных методов работы с шаблонами, они далеки от того, чтобы охватить все, что требуется в языке программирования от рефлексии. Например, для данного классового типа многие приложения хотели бы иметь возможность программно изучить члены этого класса. Имеющиеся свойства (`traits`) основаны на инстанцировании шаблонов, и C++, по-видимому, мог бы обеспечить дополнительные языковые средства или "встроенные" библиотечные компоненты для создания экземпляров шаблонов классов, которые содержат рефлексивную информацию времени компиляции. Такой подход хорошо использовать для вычислений, основанных на рекурсивном инстанцировании шаблонов. Но, к сожалению, экземпляры шаблонов классов потребляют много памяти компилятора, которая не может быть освобождена до конца компиляции (в противном случае потребуется значительно больше времени на компиляцию). Альтернативный вариант заключается в том, чтобы ввести новый стандартный тип для [[Дальнейшее развитие - template#Рефлективное метапрограммирование|представления рефлексивной информации]].

[[Дальнейшее развитие - template#Рефлективное метапрограммирование|В разделе]] также показан потенциальный подход к генерации кода, который может стать актуальным в будущем. Создание гибкого, общего и дружественного к программисту механизма генерации кода в рамках существующего языка C++ остается активно исследуемой проблемой. Однако верно и то, что инстанцирование шаблонов всегда было разновидностью механизма генерации кода. Кроме того, компиляторы стали достаточно надежными в плане встраивания небольших функций в код вместо их вызовов для того, чтобы этот механизм мог использоваться как средство генерации кода. Эти наблюдения лежат в основе рассмотренного выше примера `DotProductT`. Таким образом, существующие методы, будучи скомбинированы с более мощными возможностями рефлексии, позволяют добиться замечательных успехов в метапрограммировании.

# Стоимость рекурсивного инстанцирования

Проанализируем шаблон [[Метапрограммирование#Размерности рефлексивного метапрограммирования|Sqrt<>]]. Первичный шаблон представляет собой общее рекурсивное вычисление, вызываемое с параметром шаблона `N` (значение, для которого вычисляется квадратный корень) и двумя другими необязательными параметрами. Эти необязательные параметры представляют собой минимальное и максимальное значения, которые может иметь результат. Если шаблон вызывается только с одним аргументом, мы знаем, что квадратный корень лежит между 1 и самим значением `N`.

Затем выполняется рекурсия с использованием метода бинарного поиска (часто именуемого методом бисекции). Внутри шаблона мы выясняем, находится ли значение в первой или второй половине диапазона между `L0` и `HI`. Это делается с помощью условного оператора `?:`. Если значение `mid2` больше, чем `N`, мы продолжаем поиск в первой половине. Если же значение `mid2` меньше или равно `N`, мы используем тот же шаблон для второй половины.

Частичная специализация завершает рекурсивный процесс, когда `HI` и `L0` имеют одинаковое значение `М`, которое и является нашим окончательным значением квадратного корня `value`.

Инстанцирование шаблона — процесс не из дешевых: даже сравнительно скромные шаблоны класса могут потребовать более килобайта памяти для каждого инстанцирования, и эта память не может быть освобождена до завершения компиляции. Рассмотрим детали простой программы, которая использует наш шаблон `Sqrt`:
```c++
#include <iostream>
#include "sqrtl.hpp"

int main()
{
	std::cout << "Sqrt<16>::value = " << Sqrt<16>::value << '\n';
	std::cout << "Sqrt<25>::value = " << Sqrt<25>::value << '\n';
	std::cout << "Sqrt<42>::value = " << Sqrt<42>::value << '\n';
	std::cout << "Sqrt<1>::value = " << Sqrt<1>::value << '\n';
}
```

Выражение
```c++
Sqrt<16>::value
```

раскрывается в
```c++
Sqrt<16,1,16>::value
```

Внутри шаблона метапрограмма вычисляет `Sqrt<16,1,16>::value` следующим образом:
```
mid = (1+16+1)/2 = 9

value   = (16<9*9) ? Sqrt<16,1,8>::value
				   : Sqrt<16,9,16>::value
		= (16<81)  ? Sqrt<16,1,8>::value
				   : Sqrt<16,9,16>::value
		= Sqrt<16,1,8>::value
```

Таким образом, результат вычисляется как значение `Sqrt<16,1,8>::value`, которое раскрывается следующим образом:





