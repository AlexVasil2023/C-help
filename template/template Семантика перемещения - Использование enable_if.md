
# Использование enable_if<>

Мы можем использовать [[enable_if#enable_if|enable_if<>]] для решения нашей проблемы с шаблоном конструктора [[template Семантика перемещения - Шаблоны специальных функций-членов|см. тут]].

Задача, которую мы должны решить, — это отключение объявления шаблонного конструктора
```c++
template<typename STR>
Person(STR&& n);
```

если переданный аргумент `STR` имеет правильный тип (является [[string|std::string]] или типом, преобразуемым в [[string|std::string]]).

Для этого мы воспользуемся еще одним стандартным свойством типа [[is_convertible#std is_convertible|std::is_convertible<FROM, ТО>]]. Начиная с С++17, соответствующее объявление имеет следующий вид:
```c++
template<typename STR, 
		typename = std::enable_if__t<
				std::is_convertible_v<STR, std::string>>>
Person(STR&& n) ;
```

Если тип `STR` может быть преобразован в тип [[string|std::string]], полное объявление раскрывается в
```c++
template<typename STR, typename = void>
Person(STR&& n);
```

Если тип `STR` не может быть преобразован в [[string|std::string]], весь шаблон функции игнорируется.

И вновь для ограничения с помощью шаблона псевдонима можно определить собственное имя:
```c++
template<typename Т>
using EnableifString = std::enable_if_t <
	std::is_convertible_v<T, std::string>>;
template<typename STR, typename = EnableifString<STR>>
Person(STR && n);
```

Таким образом, весь класс `Person` должен имеет следующий вид:
```c++
#include <utility>
#include <string>
#include <iostream>
#include <type_traits>

template<typename T>
using EnableIfString = std::enable_if_t <
			std::is_convertible_v<T, std::string >>;
class Person
{
	private:
		std::string name;
		
	public:
		// Обобщенный конструктор для передачи начального имени:
		template<typename STR, typename = EnableIfString<STR>>
		explicit Person(STR && n)
			: name(std::forward<STR>(n))
		{
			std::cout << "Шаблонный конструктор для '" << name << "'\n";
		}
		
		// Копирующий и перемещающий конструкторы:
		Person(Person const& p) : name(p.name)
		{
			std::cout << "Копирующий конструктор Person '"
					<< name << "'\n";
		}
		
		Person(Person&& p) : name(std::move(p.name))
		{
			std::cout << "Перемещающий конструктор Person '"
					<< name << "'\n";
		}
};
```

Теперь все ведет себя так, как и ожидалось:
```c++
#include "specialmemtmpl3.hpp"

int main()
{
	std::string s = "sname";
	
	Person p1(s);               // Инициализация строковым объектом =>
								// вызов шаблонного конструктора
	Person p2("tmp");           // Инициализация строковым литералом =>
								// вызов шаблонного конструктора
	Person p3(p1);              // ОК, вызов копирующего конструктора
	Person p4(std::move(pi));   // ОК, вызов перемещающего конструктора
)
```

И вновь заметим, что в C++14 из-за отсутствия версии `_v` для свойств типов, возвращающих значения, мы должны объявить шаблон псевдонима следующим образом:
```c++
template<typename Т>
using EnableIfString = std::enable_if_t <
						std::is_convertible<T, std::string>::value >;
```

А в C++11 из-за отсутствия версии `_t` для свойств типов, возвращающих типы, мы должны объявить шаблон специальной функции следующим образом:
```c++
template<typename Т>
using EnableIfString = typename std::enable_if<
		std::is_convertible<T, std::string>::value>::type;
```

Но все это теперь скрыто в определении `EnableIfString<>`.

Заметим также, что имеется альтернатива использованию [[is_convertible|std::is_convertible<>]], потому эта конструкция требует, чтобы типы были неявно преобразуемы. С помощью [[is_constructible|std::is_constructible<>]] мы также позволяем использовать для инициализации явные преобразования. Однако в этом случае порядок аргументов является противоположным:
```c++
template<typename Т>
using EnableIfString = std::enable_if_t <
						std::is_constructible_v<std::string, T >>;
```

> **Отключение специальных функций-членов**

Обратите внимание: как правило, мы не можем использовать [[enable_if|enable_if<>]] для отключения стандартных копирующих/перемещающих конструкторов и операторов присваивания. Причина заключается в том, что шаблоны функций-членов никогда не учитываются как специальные функции-члены и игнорируются, когда, например, требуется копирующий конструктор. Таким образом, при наличии объявления
```c++
class С
{
	public:
		template<typename Т>
		С(Т const&)
		{
			std::cout << "Шаблонный копирующий конструктор \п";
		}
	...
};
```

при необходимости получения копии `С` используется предопределенный копирующий конструктор:
```c++
С х;
С у{х};         // Используется предопределенный копирующий конструктор
				// (не шаблон функции-члена)
```

(В действительности нет способа использования шаблона члена, потому что нет никакого способа указать или вывести его параметр шаблона `Т`.)

Удаление предопределенного копирующего конструктора решением не является, потому что попытка скопировать `С` приводит к ошибке.

Тем не менее имеется одно хитрое решение. Можно объявить копирующий конструктор для аргументов `const volatile` и пометить его как удаленный (т.е. определить его с `=delete`). Это предотвращает неявное объявление другого копирующего конструктора. При этом можно определить шаблон конструктора, который для типов, не являющихся [[volatile|volatile]], будет предпочтительнее (удаленного) копирующего конструктора:
```c++
class С
{
	public:

	...
	
			// Определяем предопределенный копирующий конструктор как
			// удаленный (с преобразованием в volatile для того, чтобы
			// обеспечить лучшее совпадение)
		С (С const volatiles) = delete;
		
			// Реализация шаблона копирующего конструктора
			// с лучшим соответствием:
		template<typename Т>
		С(Т const&)
		{
			std::cout << "Шаблонный копирующий конструктор\п";
		}
	
	...
	
};
```

Теперь шаблонный конструктор используется даже для “нормального” копирования:
```c++
С х;
С у{х};    // Используется шаблон члена
```

В таком шаблонном конструкторе можно использовать дополнительные ограничения с помощью [[enable_if|enable_if<>]]. Например, чтобы предотвратить возможность копирования объектов шаблона класса `С<>`, если параметр шаблона — целочисленный тип, можно написать следующий исходный текст:
```c++
template<typename Т>
class С
{
	public:

	...

		// Реализация шаблона копирующего конструктора
		//с лучшим соответствием:
		С(С const volatile&) = delete;

		// Если Т - не целочисленный тип, предоставляем шаблон
		// копирующего конструктора с лучшим соответствием:
		template<typename U,
				typename = std::enable_if_t<!std::is_integral<U>::value>>
		C(C<U> const&)
		{
			...
		}

	...

};
```

