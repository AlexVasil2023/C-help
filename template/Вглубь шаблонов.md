
[[#Вглубь шаблонов|Вглубь шаблонов]] 12
1. [[#Параметризованные объявления|Параметризованные объявления]] 12.1
	1. [[#Виртуальные функции-члены|Виртуальные функции-члены]] 12.1.1
	2. [[#Связывание шаблонов|Связывание шаблонов]] 12.1.2


# Вглубь шаблонов

В этой главе дается более глубокий обзор основных понятий из области шаблонов, с которыми читатель познакомился в первой части книги. Речь идет об объявлениях шаблонов, ограничениях, накладываемых на параметры и аргументы шаблонов и т.п.

# Параметризованные объявления

В настоящее время в C++ поддерживаются четыре основных типа шаблонов — [[Шаблоны классов|шаблоны классов]], [[Шаблоны функций|шаблоны функций]], [[Шаблоны переменных#Шаблоны переменных|шаблоны переменных]] и #шаблоны_псевдонимов. Шаблоны каждой из этих разновидностей могут находиться как в области видимости пространства имен, так и в области видимости класса. В области видимости класса они становятся вложенными шаблонами классов, шаблонами функций-членов, шаблонами статических данных-членов и шаблонами псевдонимов-членов. Такие шаблоны объявляются почти так же, как и обычные классы, функции, переменные и псевдонимы типов (или их двойники — члены классов), за исключением того, что для шаблонов указывается выражение параметризации (parameterization clause) вида
```c++
template<Параметры>
```

Обратите внимание на наличие в C++17 еще одной конструкции, которая [[Шаблоны классов#Вывод аргументов шаблона класса|вводится с таким же выражением параметризации: правила вывода]] (deduction
guides) ( #раздел_15_12_1). В данной книге мы не называем их шаблонами (например, они не инстанцируются), но их синтаксис напоминает шаблоны функций.

К объявлениям фактических параметров мы вернемся в последующих разделах, а сейчас рассмотрим несколько примеров, в которых проиллюстрированы четыре указанные разновидности шаблонов. Они могут находиться в области видимости пространства имен (глобальной или пространства имен), как показано ниже.
```c++
template<typename T>           // Шаблон класса
class Data
{
	public:
		static constexpr bool copyable = true;
	
	...
};

template<typename T>           // Шаблон функции
void log(T x)
{
	...
}

template<typename Т>           // Шаблон переменной (начиная с С++14)
Т zero = 0;

template<typename Т>           // Шаблон переменной (начиная с С++14)
bool dataCopyable = Data<T>::copyable;

template<typename T>           // Шаблон псевдонима
using DataList = Data<T*>;
```
Обратите внимание на то, что в этом примере статический член `Data<T>::copyable` не является шаблоном переменной, несмотря на то, что он параметризован косвенно через параметризацию шаблона класса `Data`. Однако шаблон переменной может находиться в области видимости класса (как показывает следующий пример), и в этом случае это шаблон статического члена-данного.

В следующем примере показаны четыре разновидности шаблонов в виде членов класса, определенных в своем родительском классе:
```c++
class Collection
{
	public:
		template<typename T>   // Определение шаблона класса-члена
		class Node             // в пределах класса
		{
			...
		};
		
		template<typename Т>   // Определение шаблона функции-члена в
		Т* alloc()             // пределах класса (и потому неявно
		{                      // являющейся inline)
			...
		}
		
		template<typename Т>   // Шаблон переменной-члена (с С++14)
		static Т zero = 0;
		
		template<typename Т>   // Шаблон псевдонима-члена
		using NodePtr = Node<T>*;
};
```

Обратите внимание, что в C++17 переменные (включая статические члены-данные) и шаблоны переменных могут быть “встраиваемыми” ([[inline|inline]]), что означает, что их определение может быть повторено в нескольких единицах трансляции. Это избыточно для шаблонов переменных, которые всегда могут быть определены в нескольких единицах трансляции. Однако в отличие от функций-членов, определение статического члена-данных в его классе не делает его встраиваемым: ключевое слово [[inline|inline]] должно быть указано во всех случаях.

Наконец, в следующем коде показано, как шаблоны членов, которые не являются шаблонами псевдонимов, могут быть определены вне класса.
```c++
template<typename Т>            // Шаблон класса области
class List                      // видимости пространства имен
{
	public:
		List() = default;       // Поскольку определен
								// шаблонный конструктор

		template<typename U>    // Еще один шаблон класса,
		class Handle;           // без определения

		template<typename U>    // Шаблон функции-члена
		List(List<U> const&);   // (конструктор)
		
		template<typename U>    // Шаблон переменной-члена (с С++14)
		static U zero;
};

template<typename Т>    // Определение шаблона класса-члена вне класса
	template<typename U>
class List<T>::Handle
{
	...
};

template<typename T>    // Определение шаблона функции-члена вне класса
	template<typename Т2>
List<T>::List(List<T2> const& b)
{
	...
}

template<typename T>    // Определение шаблона члена-данных вне класса
	template<typename U>
U List<T>::zero = 0;
```

Шаблоны-члены класса, определенные вне пределов охватывающего их класса, могут требовать несколько конструкций параметризации `template<...>`: одну для самого шаблона и по одной для каждого охватывающего шаблона класса. Конструкции перечисляются, начиная с самого внешнего шаблона класса.

Обратите также внимание на то, что шаблон конструктора (особый вид шаблона функции-члена) отключает неявное объявление конструктора по умолчанию (потому что он неявно объявляется только тогда, когда никакой иной конструктор не объявлен). Добавление объявления по умолчанию
```c++
List() = default;
```

гарантирует, что экземпляр `List<T>` конструируется по умолчанию с семантикой неявно объявленного конструктора.

==**Шаблоны объединений**==

***Шаблоны объединений*** (union templates) также возможны (они трактуются как разновидность шаблона класса):
```c++
template<typename Т>
union AllocChunk
{
	Т object;
	unsigned char bytes[sizeof(T)];
};
```

==**Аргументы вызова по умолчанию**==

Шаблоны функций могут иметь аргументы вызова по умолчанию, как и обычные объявления функций:
```c++
template<typename Т>
void report_top(Stack<T> const&, int number = 10);

template<typename T>
void fill(Array<T>&, T const& = T{});       // T{} для встроенных
											// типов равно нулю
```

Последнее объявление показывает, что аргумент вызова по умолчанию может зависеть от параметров шаблона. Он также может быть определен как ( [[Инициализация нулем|единственный доступный до C++11 способ]])
```c++
template<typename Т>
void fill(Array<T>&, Т const& = Т());       // Т() для встроенных
											// типов равно нулю
```

При вызове функции `fill()` аргумент по умолчанию не инстанцируется, если указан второй аргумент вызова функции. Это гарантирует, что сообщение об ошибке не будет выдано, если аргумент вызова по умолчанию не может быть инстанцирован для конкретного `Т`. Например:
```c++
class Value
{
	public:
		explicit Value(int);        // Нет конструктора по умолчанию
};

void init(Array<Value>& array)
{
	Value zero(0);
	fill(array, zero);              // OK: конструктор no
									// умолчанию не используется
									
	fill(array);                    // Ошибка: использован не определенный
									// конструктор по умолчанию для Value
};
```

==**Нешаблонные члены шаблонов классов**==

Помимо четырех основных типов шаблонов, объявленных внутри класса, могут также иметься обычные члены класса, параметризованные в силу того, что они являются частью шаблона класса. Иногда их (ошибочно) также называют шаблонами членов. Хотя они могут быть параметризованы, такие определения не являются “шаблонами первого класса”. Их параметры полностью определяются шаблоном, членами которого они являются. Например:
```c++
template<int I>
class CupBoard
{
	class Shelf;                // Обычный класс в шаблоне класса

	void open();                // Обычная функция в шаблоне класса

	enum Wood : unsigned char;  // Обычное перечисление
								// в шаблоне класса
	static double totalWeight;  // Обычный статический
								// член-данные в шаблоне класса
};
```

Соответствующие определения указывают параметризацию только для шаблонов родительского класса, но не для самого члена, поскольку он шаблоном не является (то есть с его именем после последнего `::` не связана никакая конструкция параметризации):
```c++
template<int I>         // Определение обычного класса в шаблоне класса
class CupBoard<I>::Shelf
{
	...
};

template<int I>         // Определение обычной функции в шаблоне класса
void CupBoard<I>::open()
{
	...
}

template<int I>         // Определение обычного перечисления
enum CupBoard<I>::Wood  // в шаблоне класса
{
	Maple, Cherry, Oak
};

template<int I>         // Определение обычного статического
double CupBoard<I>::totalWeight = 0.0; // члена в шаблоне класса
```

Начиная с С++17, статический член `totalWeight` может быть инициализирован внутри шаблона класса с использованием [[inline|inline]]:
```c++
template<int I>
class CupBoard
{	
	...
	
	inline static double totalWeight = 0.0;
};
```

Хотя такие параметризованные определения обычно называются шаблонами, это не совсем верный термин. Для таких сущностей был предложен термин таблоид (temploid). Начиная с C++17, стандарт C++ определяет понятие шаблонной сущности (templated entity), которая включает шаблоны и шаблоиды, а также рекурсивно все сущности, определенные или созданные в шаблонных сущностях (что включает в себя, например, [[Шаблоны классов#Друзья|дружественную функцию, определенную внутри шаблона класса]] или тип замыкания лямбда-выражения, содержащегося в шаблоне). Пока что эти термины не получили широкого распространения, но они могут быть полезны в будущем для более точного обмена информацией о шаблонах в C++.

## Виртуальные функции-члены

Шаблоны функций-членов не могут быть объявлены как виртуальные. Это ограничение накладывается потому, что в обычной реализации механизма вызова виртуальных функций используется таблица фиксированного размера, одна строка которой соответствует одной виртуальной функции. Однако число инстанцированных шаблонов функции-члена не является фиксированным, пока не завершится трансляция всей программы. Следовательно, для того, чтобы поддержка шаблонов виртуальных членов-функций стала возможной, требуется реализация радикально нового вида механизма позднего связывания в компиляторах и компоновщиках C++.

В отличие от функций-членов, обычные члены шаблонов классов могут быть виртуальными, поскольку их количество при инстанцировании класса фиксировано.
```c++
template<typename Т>
class Dynamic
{
	public:
		virtual ~Dynamic();     // OK: один деструктор на
								// экземпляр Dynamic<T>
		
		template<typename T2>
		virtual void copy(T2 const&);
			// Ошибка: неизвестное количество экземпляров сору()
			// у одного экземпляра Dynamic<T>
};
```

## Связывание шаблонов

Каждый шаблон должен иметь имя, и это имя должно быть уникальным в пределах его области видимости, за исключением шаблонов функций, которые могут быть перегружены (см. #главу_16, “Специализация и перегрузка”). Особо отметим, что, в отличие от типов классов, для шаблонов классов не допускается использование имен, совпадающих с именами объектов других сущностей:
```c++
int С;
...
class С;        // ОК: имена классов и не классов в разных "пространствах"

int X;
...
template<typename Т>
class X;        // Ошибка: конфликт с именем переменной X

struct S;
...
template<typename Т>
class S;        // Ошибка: конфликт с именем структуры S
```









