
[[#Вглубь шаблонов|Вглубь шаблонов]] 12
1. [[#Параметризованные объявления|Параметризованные объявления]] 12.1
	1. [[#Виртуальные функции-члены|Виртуальные функции-члены]] 12.1.1
	2. [[#Связывание шаблонов|Связывание шаблонов]] 12.1.2
	3. [[#Первичные шаблоны|Первичные шаблоны]] 12.1.3
2. [[#Параметры шаблонов|Параметры шаблонов]] 12.2
	1. [[#Параметры типа|Параметры типа]] 12.2.1
	2. [[#Параметры, не являющиеся типами|Параметры, не являющиеся типами]] 12.2.2
	3. [[#Шаблонные параметры шаблонов|Шаблонные параметры шаблонов]] 12.2.3


# Вглубь шаблонов

В этой главе дается более глубокий обзор основных понятий из области шаблонов, с которыми читатель познакомился в первой части книги. Речь идет об объявлениях шаблонов, ограничениях, накладываемых на параметры и аргументы шаблонов и т.п.

# Параметризованные объявления

В настоящее время в C++ поддерживаются четыре основных типа шаблонов — [[Шаблоны классов|шаблоны классов]], [[Шаблоны функций|шаблоны функций]], [[Шаблоны переменных#Шаблоны переменных|шаблоны переменных]] и #шаблоны_псевдонимов. Шаблоны каждой из этих разновидностей могут находиться как в области видимости пространства имен, так и в области видимости класса. В области видимости класса они становятся вложенными шаблонами классов, шаблонами функций-членов, шаблонами статических данных-членов и шаблонами псевдонимов-членов. Такие шаблоны объявляются почти так же, как и обычные классы, функции, переменные и псевдонимы типов (или их двойники — члены классов), за исключением того, что для шаблонов указывается выражение параметризации (parameterization clause) вида
```c++
template<Параметры>
```

Обратите внимание на наличие в C++17 еще одной конструкции, которая [[Шаблоны классов#Вывод аргументов шаблона класса|вводится с таким же выражением параметризации: правила вывода]] (deduction
guides) ( #раздел_15_12_1). В данной книге мы не называем их шаблонами (например, они не инстанцируются), но их синтаксис напоминает шаблоны функций.

К объявлениям фактических параметров мы вернемся в последующих разделах, а сейчас рассмотрим несколько примеров, в которых проиллюстрированы четыре указанные разновидности шаблонов. Они могут находиться в области видимости пространства имен (глобальной или пространства имен), как показано ниже.
```c++
template<typename T>           // Шаблон класса
class Data
{
	public:
		static constexpr bool copyable = true;
	
	...
};

template<typename T>           // Шаблон функции
void log(T x)
{
	...
}

template<typename Т>           // Шаблон переменной (начиная с С++14)
Т zero = 0;

template<typename Т>           // Шаблон переменной (начиная с С++14)
bool dataCopyable = Data<T>::copyable;

template<typename T>           // Шаблон псевдонима
using DataList = Data<T*>;
```
Обратите внимание на то, что в этом примере статический член `Data<T>::copyable` не является шаблоном переменной, несмотря на то, что он параметризован косвенно через параметризацию шаблона класса `Data`. Однако шаблон переменной может находиться в области видимости класса (как показывает следующий пример), и в этом случае это шаблон статического члена-данного.

В следующем примере показаны четыре разновидности шаблонов в виде членов класса, определенных в своем родительском классе:
```c++
class Collection
{
	public:
		template<typename T>   // Определение шаблона класса-члена
		class Node             // в пределах класса
		{
			...
		};
		
		template<typename Т>   // Определение шаблона функции-члена в
		Т* alloc()             // пределах класса (и потому неявно
		{                      // являющейся inline)
			...
		}
		
		template<typename Т>   // Шаблон переменной-члена (с С++14)
		static Т zero = 0;
		
		template<typename Т>   // Шаблон псевдонима-члена
		using NodePtr = Node<T>*;
};
```

Обратите внимание, что в C++17 переменные (включая статические члены-данные) и шаблоны переменных могут быть “встраиваемыми” ([[inline|inline]]), что означает, что их определение может быть повторено в нескольких единицах трансляции. Это избыточно для шаблонов переменных, которые всегда могут быть определены в нескольких единицах трансляции. Однако в отличие от функций-членов, определение статического члена-данных в его классе не делает его встраиваемым: ключевое слово [[inline|inline]] должно быть указано во всех случаях.

Наконец, в следующем коде показано, как шаблоны членов, которые не являются шаблонами псевдонимов, могут быть определены вне класса.
```c++
template<typename Т>            // Шаблон класса области
class List                      // видимости пространства имен
{
	public:
		List() = default;       // Поскольку определен
								// шаблонный конструктор

		template<typename U>    // Еще один шаблон класса,
		class Handle;           // без определения

		template<typename U>    // Шаблон функции-члена
		List(List<U> const&);   // (конструктор)
		
		template<typename U>    // Шаблон переменной-члена (с С++14)
		static U zero;
};

template<typename Т>    // Определение шаблона класса-члена вне класса
	template<typename U>
class List<T>::Handle
{
	...
};

template<typename T>    // Определение шаблона функции-члена вне класса
	template<typename Т2>
List<T>::List(List<T2> const& b)
{
	...
}

template<typename T>    // Определение шаблона члена-данных вне класса
	template<typename U>
U List<T>::zero = 0;
```

Шаблоны-члены класса, определенные вне пределов охватывающего их класса, могут требовать несколько конструкций параметризации `template<...>`: одну для самого шаблона и по одной для каждого охватывающего шаблона класса. Конструкции перечисляются, начиная с самого внешнего шаблона класса.

Обратите также внимание на то, что шаблон конструктора (особый вид шаблона функции-члена) отключает неявное объявление конструктора по умолчанию (потому что он неявно объявляется только тогда, когда никакой иной конструктор не объявлен). Добавление объявления по умолчанию
```c++
List() = default;
```

гарантирует, что экземпляр `List<T>` конструируется по умолчанию с семантикой неявно объявленного конструктора.

==**Шаблоны объединений**==

***Шаблоны объединений*** (union templates) также возможны (они трактуются как разновидность шаблона класса):
```c++
template<typename Т>
union AllocChunk
{
	Т object;
	unsigned char bytes[sizeof(T)];
};
```

==**Аргументы вызова по умолчанию**==

Шаблоны функций могут иметь аргументы вызова по умолчанию, как и обычные объявления функций:
```c++
template<typename Т>
void report_top(Stack<T> const&, int number = 10);

template<typename T>
void fill(Array<T>&, T const& = T{});       // T{} для встроенных
											// типов равно нулю
```

Последнее объявление показывает, что аргумент вызова по умолчанию может зависеть от параметров шаблона. Он также может быть определен как ( [[Инициализация нулем|единственный доступный до C++11 способ]])
```c++
template<typename Т>
void fill(Array<T>&, Т const& = Т());       // Т() для встроенных
											// типов равно нулю
```

При вызове функции `fill()` аргумент по умолчанию не инстанцируется, если указан второй аргумент вызова функции. Это гарантирует, что сообщение об ошибке не будет выдано, если аргумент вызова по умолчанию не может быть инстанцирован для конкретного `Т`. Например:
```c++
class Value
{
	public:
		explicit Value(int);        // Нет конструктора по умолчанию
};

void init(Array<Value>& array)
{
	Value zero(0);
	fill(array, zero);              // OK: конструктор no
									// умолчанию не используется
									
	fill(array);                    // Ошибка: использован не определенный
									// конструктор по умолчанию для Value
};
```

==**Нешаблонные члены шаблонов классов**==

Помимо четырех основных типов шаблонов, объявленных внутри класса, могут также иметься обычные члены класса, параметризованные в силу того, что они являются частью шаблона класса. Иногда их (ошибочно) также называют шаблонами членов. Хотя они могут быть параметризованы, такие определения не являются “шаблонами первого класса”. Их параметры полностью определяются шаблоном, членами которого они являются. Например:
```c++
template<int I>
class CupBoard
{
	class Shelf;                // Обычный класс в шаблоне класса

	void open();                // Обычная функция в шаблоне класса

	enum Wood : unsigned char;  // Обычное перечисление
								// в шаблоне класса
	static double totalWeight;  // Обычный статический
								// член-данные в шаблоне класса
};
```

Соответствующие определения указывают параметризацию только для шаблонов родительского класса, но не для самого члена, поскольку он шаблоном не является (то есть с его именем после последнего `::` не связана никакая конструкция параметризации):
```c++
template<int I>         // Определение обычного класса в шаблоне класса
class CupBoard<I>::Shelf
{
	...
};

template<int I>         // Определение обычной функции в шаблоне класса
void CupBoard<I>::open()
{
	...
}

template<int I>         // Определение обычного перечисления
enum CupBoard<I>::Wood  // в шаблоне класса
{
	Maple, Cherry, Oak
};

template<int I>         // Определение обычного статического
double CupBoard<I>::totalWeight = 0.0; // члена в шаблоне класса
```

Начиная с С++17, статический член `totalWeight` может быть инициализирован внутри шаблона класса с использованием [[inline|inline]]:
```c++
template<int I>
class CupBoard
{	
	...
	
	inline static double totalWeight = 0.0;
};
```

Хотя такие параметризованные определения обычно называются шаблонами, это не совсем верный термин. Для таких сущностей был предложен термин таблоид (temploid). Начиная с C++17, стандарт C++ определяет понятие шаблонной сущности (templated entity), которая включает шаблоны и шаблоиды, а также рекурсивно все сущности, определенные или созданные в шаблонных сущностях (что включает в себя, например, [[Шаблоны классов#Друзья|дружественную функцию, определенную внутри шаблона класса]] или тип замыкания лямбда-выражения, содержащегося в шаблоне). Пока что эти термины не получили широкого распространения, но они могут быть полезны в будущем для более точного обмена информацией о шаблонах в C++.

## Виртуальные функции-члены

Шаблоны функций-членов не могут быть объявлены как виртуальные. Это ограничение накладывается потому, что в обычной реализации механизма вызова виртуальных функций используется таблица фиксированного размера, одна строка которой соответствует одной виртуальной функции. Однако число инстанцированных шаблонов функции-члена не является фиксированным, пока не завершится трансляция всей программы. Следовательно, для того, чтобы поддержка шаблонов виртуальных членов-функций стала возможной, требуется реализация радикально нового вида механизма позднего связывания в компиляторах и компоновщиках C++.

В отличие от функций-членов, обычные члены шаблонов классов могут быть виртуальными, поскольку их количество при инстанцировании класса фиксировано.
```c++
template<typename Т>
class Dynamic
{
	public:
		virtual ~Dynamic();     // OK: один деструктор на
								// экземпляр Dynamic<T>
		
		template<typename T2>
		virtual void copy(T2 const&);
			// Ошибка: неизвестное количество экземпляров сору()
			// у одного экземпляра Dynamic<T>
};
```

## Связывание шаблонов

Каждый шаблон должен иметь имя, и это имя должно быть уникальным в пределах его области видимости, за исключением шаблонов функций, которые могут быть перегружены (см. #главу_16, “Специализация и перегрузка”). Особо отметим, что, в отличие от типов классов, для шаблонов классов не допускается использование имен, совпадающих с именами объектов других сущностей:
```c++
int С;
...
class С;        // ОК: имена классов и не классов в разных "пространствах"

int X;
...
template<typename Т>
class X;        // Ошибка: конфликт с именем переменной X

struct S;
...
template<typename Т>
class S;        // Ошибка: конфликт с именем структуры S
```

Имена шаблонов имеют связывание, но они не могут иметь *связывание С*. Нестандартные связывания могут иметь значения, зависящие от реализации (однако нам неизвестна реализация, которая поддерживала бы нестандартные правила связывания имен для шаблонов).
```c++
extern "C++" template<typename Т>
void normal();          // По умолчанию спецификация
						// связывания может быть опущена
extern "С" template<typename Т>
void invalid();         // Ошибка: шаблоны не могут иметь связывание С

extern "Java" template<typename Т>
void javaLink();        // Нестандартно, но, возможно, когда-то появится
						// какой-то компилятор, поддерживающий связывание,
						// совместимое с дженериками Java
```

Шаблоны обычно имеют внешнее связывание. Исключением являются шаблоны функций в области видимости пространства имен, описанные как [[static|static]], шаблоны, которые являются прямыми или косвенными членами безымянного пространства имен (которое имеет внутреннее связывание) и шаблоны членов безымянных классов (которые не имеют связывания). Например:
```c++
template<typename Т>        // Ссылается на ту же сущность, что и
void external();            // объявление с тем же именем (и областью
							// видимости) в другом файле

template<typename Т>        //Не связано с шаблоном с тем же именем
static void internal();     //в другом файле

template<typename Т>        // Повторное объявление предыдущего шаблона
static void internal();

namespace
{
	template<typename>      // Также не связано с шаблоном с тем же
	void otherlnternal();   // именем в другом файле, даже с тем,
							// который находится в аналогичном
							// безымянном пространстве имен
}

namespace
{
	template<typename>      // Повторное объявление
	void otherlnternal();   // предыдущего шаблона
}

struct
{
	template<typename Т>    // Связывания нет:
	void f(T) {}            //не может быть повторно объявлен
} х;

```

Обратите внимание: поскольку последний шаблон члена не имеет связывания, он должен быть определен в безымянном классе, поскольку нет никакого способа обеспечить его определение вне класса.

В настоящее время шаблоны не могут быть объявлены в области видимости функции или локального класса, но обобщенные лямбда-выражения (см. #раздел_15_10_6), которые имеют связанные типы замыкания, содержащие шаблоны функций-членов, могут находиться в локальных областях видимости, что подразумевает наличие разновидности локальных шаблонов функций-членов.

Связывание экземпляра шаблона такое же, что и у шаблона. Например, функция `internal<void>()`, инстанцированная из объявленного выше шаблона `internal`, будет иметь внутреннее связывание. Это имеет интересные следствия в случае шаблонов переменных. Рассмотрим следующий пример:
```c++
template<typename Т> Т zero = Т{};
```

Все инстанцирования `zero` имеют внешнее связывание, даже такие как `zero<int const>`. Это может показаться парадоксальным, учитывая, что
```c++
template<typename Т> int const max_volume = 11;
```

имеют внешнее связывание, несмотря на то, что все они также имеют тип `int` [[const|const]].

## Первичные шаблоны

С помощью обычных конструкций объявлений шаблонов объявляются так называемые первичные шаблоны (`primary templates`). В таких объявлениях после имени отсутствуют аргументы шаблона в угловых скобках:
```c++
// ОК: первичный шаблон
template<typename Т> class Box;

// Ошибка: не специализируется
template<typename Т> class Вох<T>;

// ОК: первичный шаблон
template<typename Т> void translate(Т);

// Ошибка: не разрешено для функций
template<typename Т> void translat<T>(Т);

// ОК: первичный шаблон
template<typename Т> constexpr Т zero = Т{};

// Ошибка: не специализируется
template<typename Т> constexpr Т zero<T> = Т{};
```

Вторичные (не первичные) шаблоны классов получаются при объявлении частичных специализаций шаблонов классов или переменных, которые рассматриваются в #главе_16, “Специализация и перегрузка”. Шаблоны функций всегда должны быть первичными (см. #раздел_17_3, где рассмотрены возможные изменения в этой области в будущем).

# Параметры шаблонов

Существует три основных вида параметров шаблонов.

1. Параметры типа (типовые параметры) (они на сегодняшний день используются наиболее часто).
2. Параметры, не являющиеся типами (нетиповые параметры).
3. Шаблонные параметры шаблонов.

Любой из этих основных видов параметров шаблона может быть использован в качестве основы пакета параметров шаблона (`template parameter pack`) (см. #раздел_12_2_4).

Параметры шаблона объявлены в начальном операторе параметризации объявления шаблона. Такие объявления не обязательно должны быть именованными:
```c++
template<typename, int>
class X;           // Х<> параметризован типом и целочисленным значением
```

Имя параметра, конечно же, необходимо, если на этот параметр имеется ссылка позже в шаблоне. Обратите также внимание, что на имя параметра шаблона можно ссылаться в объявлении последующего параметра (но не до самого рассматриваемого параметра):
```c++
template<typename Т,             // Первый параметр используется
		Т Root,                  // в объявлениях второго и
		template<T> class Buf>   // третьего параметров
class Structure;
```

## Параметры типа

Параметры типа (типовые параметры) вводятся с помощью ключевых слов [[typename|typename]] либо `class`; оба варианта эквивалентны. За ключевым словом должен следовать простой идентификатор, за которым идет запятая, означающая начало следующего объявления параметра, закрывающая угловая скобка (`>`) для обозначения конца параметризованного выражения или знак равенства (`=`) для обозначения начала заданного по умолчанию аргумента шаблона.

В пределах объявления шаблона параметр типа ведет себя подобно [[Шаблоны классов#Псевдонимы типов|псевдониму типа]]. Например, нельзя использовать имя вида `class Т`, где `Т` является параметром шаблона, даже если вместо `Т` подставляется тип класса.
```c++
template<typename Allocator>
class List
{
	// Ошибка: использование "Allocator* allocptr":
	class Allocator* allocptr;
	
	// Ошибка: использование "friend Allocator"
	friend class Allocator;
};
```

## Параметры, не являющиеся типами

Не являющиеся типами параметры (нетиповые параметры) — это константные значения, которые могут быть определены во время компиляции или при компоновке. Тип такого параметра (другими словами, тип значения, которое он обозначает) должен быть одним из следующих:
>
> целочисленный тип или тип перечисления;
> 
> тип указателя;
> 
> тип указателя на член;
> 
> тип [[значение#l-значение|l-ссылки]] (разрешены как ссылка на объект, так и ссылка на функцию);
> 
> [[nullptr_t#std nullptr_t|std::nullptr_t]];
> 
> тип, содержащий [[auto|auto]] или [[decltype(auto)|decltype (auto)]] (только начиная с С++17; см. #раздел_15_10_1).

В данный момент все прочие типы исключены (хотя в будущем возможно добавление типов с плавающей точкой; см. #раздел_17_2).

Возможно, это покажется несколько неожиданным, но объявление параметра шаблона, не являющегося типом, в некоторых случаях также может начинаться с ключевого слова [[typename|typename]]:
```c++
template<typename Т,                        // Параметр типа
		typename Т::Allocator* Allocator>   // Параметр, не
class List;                                 // являющийся типом
```

или с ключевого слова `class`:
```c++
template<class Х*>     // Параметр, не являющийся типом,
class Y;               // и имеющий тип указателя
```

Разницу здесь увидеть легко; в первом случае за ключевым словом следует простой идентификатор, а затем один из небольшого набора лексем (`“=”` для аргумента по умолчанию, `“,”` для указания того, что далее следует другой параметр шаблона, или закрывающая угловая скобка `">"` завершающая список параметров шаблона). В #разделах_13_3_2 объясняется необходимость ключевого слова [[typename|typename]] в первом параметре, не являющемся типом.

Возможно использование типов функции и массивов, но они неявно низводятся к типу указателя:
```c++
template<int buf[5]> class Lexer;       // В действительности int*
template<int* buf> class Lexer;         // OK: повторное объявление
template<int fun()> struct FuncWrap;    // fun представляет собой
										// тип указателя на функцию
template<int (*)()> struct FuncWrap;    // ОК: повторное объявление
```

Параметры, не являющиеся типами, объявляются почти так же, как и переменные, но они не могут включать спецификаторы, не являющиеся типами, такие как [[static|static]], [[mutable|mutable]] и т.д. Возможно использование модификаторов [[const|const]] или [[volatile|volatile]], но если такой модификатор появляется у нетиповых параметров внешнего уровня вложенности, он попросту игнорируется:
```c++
template<int const length> class Buffer; // const здесь бесполезен
template<int length> class Buffer;       // To же самое объявление
```

И наконец, параметры, не являющиеся типами, всегда являются [[значение#pr-значения|рr-значениями]]. Их адрес нельзя получить, и им нельзя ничего присвоить. С другой стороны, параметр, не являющийся типом и имеющий тип [[значение#l-значение|l-ссылки]], может использоваться для описания [[значение#l-значение|l-значения]]:
```c++
template<int& Counter>
struct LocalIncrement
{
	LocalIncrement()
	{
		Counter = Counter+1;         // OK: Ссылка на int
	}
	
	~LocalIncrement()
	{
		Counter = Counter-1;
	}
};
```

[[значение#r-значения|R-ссылка]] в качестве параметра не разрешена.

## Шаблонные параметры шаблонов

Шаблонные параметры шаблонов являются символами-заместителями для шаблонов классов или псевдонимов. Они объявляются во многом подобно шаблонам классов, однако при этом нельзя использовать ключевые слова `struct` и [[union|union]]:
```c++
template<template<typename Х> class С>      // ОК
void f(C<int>* р);

template<template<typename Х> struct С>     // Ошибка: struct
void f(C<int>* p);

template<template<typename X> union C       // Ошибка: union
void f(C<int>* p) ;

```

























