
[[#Обобщенные библиотеки|Обобщенные библиотеки]] 11
1. [[#Вызываемые объекты|Вызываемые объекты]] 11.1
	1. [[#Поддержка функциональных объектов|Поддержка функциональных объектов]] 11.1.1
	2. [[#Работа с функциями-членами и дополнительными аргументами|Работа с функциями-членами и дополнительными аргументами]] 11.1.2
	3. [[#Оборачивание вызовов функций|Оборачивание вызовов функций]] 11.1.3
2. [[#Другие утилиты для реализации обобщенных библиотек|Другие утилиты для реализации обобщенных библиотек]] 11.2


# Обобщенные библиотеки

До сих пор наше обсуждение шаблонов было сосредоточено на их специфических особенностях, возможностях и ограничениях, с направленностью на непосредственные задачи и приложения (то, с чем в первую очередь сталкиваются прикладные программисты). Однако наиболее эффективными шаблоны оказываются тогда, когда используются для написания обобщенных библиотек и каркасов, где наши проекты должны рассматривать потенциальные применения априори максимально широко. Хотя к таким конструкциям может быть применим почти весь материал данной книги, здесь рассматриваются некоторые общие вопросы, возникающие при написании переносимых компонентов, которые планируется использовать для типов, не существующих пока что даже в проекте.

Перечень поднятых здесь вопросов не завершен в любом смысле, но он кратко резюмирует некоторые из возможностей, представленных в книге до этого момента, вводит некоторые дополнительные функциональные возможности и ссылается на некоторые особенности шаблонов и языка, рассматриваемые в этой книге позже. Мы надеемся, что данный материал еще сильнее мотивирует читателей на чтение всех последующих глав этой книги.

# Вызываемые объекты

Многие библиотеки включают интерфейсы, которым клиентский код передает некоторые сущности, которые должны быть “вызваны”. Примеры включают операции, планируемые для выполнения в другом потоке; функции, описывающие, как хеш-значения должны храниться в хеш-таблице; объекты, описывающие порядок, в котором следует сортировать элементы в коллекции; и обобщенная оболочка, обеспечивающая некоторые значения аргументов по умолчанию. Стандартная библиотека не является исключением: она определяет многие компоненты, которые принимают такие вызываемые сущности.

Одним из терминов, используемых в этом контексте, является понятие [[callback|обратного вызова (callback)]]. Традиционно этот термин зарезервирован для сущностей, которые передаются в качестве аргументов вызова функции (в отличие от, например, аргументов шаблона), и мы придерживаемся этой традиции. Например, функция сортировки может включать параметр обратного вызова как “критерий сортировки”, который вызывается, чтобы определить, находится ли один элемент по отношению к другому в требуемом порядке сортировки.

В C++ имеется ряд типов, хорошо подходящих для обратных вызовов, потому что они могут как быть переданы в качестве аргументов функции, так и вызываться непосредственно с синтаксисом вызова `f(...)`.
>
> Типы указателей на функции.
> 
> Типы классов с перегруженным оператором `operator()` (которые иногда называются ***функторами*** (`functors`)), включая лямбда-выражения.
> 
> Типы классов с функциями преобразования, дающими указатель на функцию или ссылку на функцию.

Вместе все эти типы называются ***типами функциональных объектов***, а значение такого типа называется функциональным объектом.

Стандартная библиотека C++ вводит несколько более широкое понятие ***вызываемого типа*** (callable type), который представляет собой либо тип функционального объекта, либо указатель на член. Объект вызываемого типа называется вызываемым объектом (callable object).

Обобщенный код часто извлекает выгоду от возможности принять вызываемый объект любого вида, и шаблоны позволяют легко это сделать.

## Поддержка функциональных объектов

Давайте рассмотрим, как реализован алгоритм [[for_each|for_each()]] стандартной библиотеки (воспользуемся для этого именем `“foreach”`, чтобы избежать возможных конфликтов имен, и для упрощения не будем ничего возвращать из этой функции):
```c++
template<typename Iter, typename Callable>
void foreach (Iter current, Iter end, Callable op)
{
	while (current != end)      // Пока не достигнут конец
	{
		op(*current);           // Вызов переданного оператора
								// для текущего элемента
		++current;              // и перемещение итератора к
								// следующему элементу	
	}
}
```

Приведенная ниже программа демонстрирует применение этого шаблона с различными функциональными объектами:
```c++
#include <iostream>
#include <vector>
#include "foreach.hpp"

// Вызываемая функция:
void func(int i)
{
	std::cout << "func() вызывается для: " << i << '\n';
};

// Тип функционального объекта (для объектов, которые могут
// быть использованы как функции):
class FuncObj
{
	public:
		void operator()(int i) const // Примечание: константная
		{                            // функция-член
			std::cout << "FuncObj::op() вызывается для: " << i << ' \n';
		}
};

int main()
{
	std::vector<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19 };
	
	foreach(primes.begin(), primes.end(), // Диапазон
			func);         // Функция (низведение к указателю)

	foreach(primes.begin(), primes.end(), // Диапазон
			&func);        // Указатель на функцию
			
	foreach(primes.begin(), primes.end(), // Диапазон
			FuncObj());    // Функциональный объект
			
	foreach(primes.begin(), primes.end(), // Диапазон
			[](int i){     // Лямбда-выражение
				std::cout << "Лямбда-выражение вызвано для:"
							<< i << '\n';
			});
}
```

Давайте подробнее рассмотрим каждый случай.
>
> Когда мы передаем имя функции в качестве аргумента функции, мы в действительности передаем не саму функцию, а указатель или ссылку на нее. [[По значению или по ссылке#Работа со строковыми литералами и массивами|Как и в случае массивов]], аргумент-функция низводится до указателя при передаче по значению, а в случае параметра, тип которого является параметром шаблона, будет выведен тип указателя на функцию.
> Функции, так же как и массивы, могут передаваться по ссылке без низведения типа. Однако типы функций в действительности не могут квалифицироваться с помощью [[const|const]]. Если мы объявим последний параметр `foreach()` с типом `Callable consts`, этот [[const|const]] будет просто проигнорирован. (Вообще говоря, в коде C++ редко используются ссылки на функции.)
> 
> Наш второй вызов явно принимает указатель на функцию с использованием адреса имени функции. Это эквивалентно первому вызову (в котором имя функции неявно низводилось до значения указателя), но, возможно, выглядит немного яснее.
> 
> При передаче функтора мы передаем объект типа класса в качестве вызываемого объекта. Вызов через тип класса обычно сводится к вызову его `operator()`. Поэтому вызов 
```c++
op(*current);
```
> обычно трансформируется в
```c++
op.operator()(*current);    // Вызов operator() с параметром
							// *current для объекта op
```
> Обратите внимание на то, что при определении `operator()` вы обычно должны определять как константную функцию-член. В противном случае [[Применение шаблонов на практике#Расшифровка романов об ошибках|может произойти тонкая ошибка, когда каркасы или библиотеки ожидают, что такой вызов не изменяет состояние переданного объекта]].
> Возможно также, что объект типа класса будет неявно преобразовываться в указатель или ссылку на функцию суррогатного вызова (surrogate call function) (обсуждается в #разделе_В_3_5). В таком случае вызов
```c++
op(*current);
```
> будет преобразован в
```c++
(op.operator F())(*current);
```
> где `F` представляет собой тип указателя или ссылки на функцию, в которую может быть преобразован объект типа класса. Это относительно нераспространенный подход.
>
> Лямбда-выражения создают функторы (именуемые замыканиями (closure)), и поэтому данный случай не слишком отличается от случая использования функтора. Однако лямбда-выражения являются очень удобной сокращенной записью для представления функторов, потому они часто появляются в коде, начиная с С++11.
> 
> Интересно, что лямбда-выражения, которые начинаются с `[ ]` (без захвата) производят оператор преобразования в тип указателя на функцию. Однако он никогда не будет выбран как функция суррогатного вызова, потому что его соответствие всегда хуже, чем у обычного `operator()` замыкания.

## Работа с функциями-членами и дополнительными аргументами

Одна возможная сущность для вызова в предыдущем примере не использовалась — это функция-член. Дело в том, что вызов нестатической функции-члена обычно включает указание объекта, для которого применяется вызов, с использованием синтаксиса наподобие `object.memfunc (...)` или `ptr->memfunc (...)`, не соответствующий обычной схеме `функциональный_объект (...)`.

К счастью, начиная с C++17, стандартная библиотека C++ предоставляет утилиту [[invoke|std::invoke()]], которая удобно унифицирует этот случай со случаями с синтаксисом вызова обычных функций, тем самым позволяя вызывать любой вызываемый объект с помощью одной формы вызова. Следующая реализация нашего шаблона `foreach()` использует [[invoke|std::invoke()]]:
```c++
#include <utility>
#include <functional>

template<typename Iter, typename Callable, typename... Args>
void foreach (Iter current, Iter end, Callable op, 
				Args const& ... args)
{
	while (current != end)      // Пока не достигнут конец
	{
		std::invoke(op,         // Вызов переданного вызываемого
					args...,    // объекта с любыми аргументами args 
		            *current);  // и текущим элементом current
		++current;
	}
}
```

Здесь кроме параметра вызываемого объекта мы также принимаем произвольное количество дополнительных параметров. Затем шаблон `foreach()` вызывает [[invoke|std::invoke ()]] с данным вызываемым объектом, за которым следуют дополнительные переданные параметры вместе со ссылкой на элемент, [[invoke|std::invoke ()]] обрабатывает этот код следующим образом.
>
> Если вызываемый объект представляет собой указатель на член, он использует первый дополнительный аргумент как этот объект. Все остальные дополнительные параметры просто передаются как аргументы вызываемому объекту.
> 
> В противном случае все дополнительные параметры просто передаются как аргументы вызываемого объекта.

Обратите внимание на то, что мы не можем использовать здесь прямую передачу для вызываемого объекта или дополнительных параметров: первый вызов может “украсть” их значения, что приведет к неожиданному поведению `ор` в последующих итерациях.

Эта реализация позволяет по-прежнему компилировать все наши исходные вызовы `foreach()`, показанные выше. Теперь, кроме того, мы можем также передавать дополнительные аргументы вызываемым объектам, а сам вызываемый объект может быть функцией-членом. Следующий клиентский код иллюстрирует это:
```c++
#include <iostream>
#include <vector>
#include <string>
#include "foreachinvoke.hpp"

// Класс с функцией-членом, который должен быть вызван
class MyClass
{
	public:
		void memfunc(int i) const
		{
			std::cout << "MyClass::memfunc() вызван для: " << i << '\n';
		}
};

int main ()
{
	std::vector<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19 };

	// Передача лямбда-выражения в качестве вызываемого
	// объекта и дополнительный аргумент:
	foreach(primes.begin(),
			primes.end(),       // Элементы второго аргумента
								// лямбда-выражения
			[](std::string const& prefix, int i) // Вызываемое
			{ std::cout << prefix << i << '\n';},// лямбда-выражение
			"- значение: ");     // Первый аргумент лямбда-выражения

	// Вызов obj.memfunc() для/с каждого элемента primes,
	// передаваемого в качестве аргумента
	MyClass obj;
	
	foreach(primes.begin(),    // Элементы, используемые
			primes.end(),      // в качестве аргументов
			&MyClass::memfunc, // Вызываемая функция-член
			obj );             // Объект вызова memfunc()
```

Первый вызов `foreach()` получает четвертый аргумент (строковый литерал
`"- значение: "`), используемый в качестве первого параметра лямбда-выражения, в то время как текущий элемент вектора связывается со вторым параметром лямбда-выражения. Второй вызов передает функцию-член `memfunc()` в качестве третьего аргумента вызова `obj`, передаваемого как четвертый аргумент.

Свойства типов, которые проверяют, может ли вызываемый объект быть использован [[invoke|std::invoke ()]], описываются в #разделе_Г_3_1.

## Оборачивание вызовов функций

Типичное применение [[invoke|std::invoke()]] заключается в том, чтобы получить “обертку” для вызова одной функции (например, для выполнения записи о вызовах в журнал, измерения их продолжительности или подготовки некоторого контекста, как, например, запуск для них новых потоков). Теперь мы можем обеспечить поддержку семантики перемещения с помощью прямой передачи как вызываемого объекта, так и всех передаваемых аргументов:
```c++
#include <utility>            // Для std::invoke()
#include <functional>         // Для std::forward!)

template<typename Callable, typename... Args>
decltype(auto) call(Callable&& op, Args&& ... args)
{
	return std::invoke(
		std::forward<Callable>(op),   // Передача вызываемого объекта
		std::forward<Args>(args)...); // с дополнительными аргументами
}
```

Еще одним интересным аспектом является работа с возвращаемым значением вызываемой функции для его “прямой передачи” назад вызывающему коду. Для поддержки возвращения ссылок (как, например, [[ostream|std::ostream&]]) следует использовать [[decltуре#decltype(auto) C++14|decltype(auto)]] вместо просто [[auto|auto]]:
```c++
template<typename Callable, typename... Args>
decltype(auto) call(Callable&& op, Args&& ... args)
```

[[decltуре#decltype(auto) C++14|decltype (auto)]] (доступно начиная с C++14) является типом-заместителем (placeholder type), который определяет тип переменной, возвращаемый тип или аргумент шаблона из типа связанного выражения (инициализатор, возвращаемое значение или аргумент шаблона). Подробности его использования можно найти в #разделе_15_10_3.

Если вы хотите временно хранить значение, возвращаемое [[invoke|std::invoke()]], в переменной, чтобы вернуть его после того, как будет сделано что-то иное (например, выполнение некоторых действий с возвращаемым значением или журнальная запись о конце вызова), вы также должны объявить эту временную переменную с использованием [[decltуре#decltype(auto) C++14|decltype (auto)]]:
```c++
decltype(auto) ret(std::invoke(std::forward<Callable>(op),
								std::forward<Args>(args)...)};
...

return ret;
```

Обратите внимание на то, что объявлять `ret` с помощью [[auto|auto&&]] некорректно. В качестве ссылки [[auto|auto&&]] продлевает время жизни возвращаемого значения до конца ее области видимости (см. #раздел_11_3), но не за пределы инструкции `return` вызывающему коду.

Однако имеется проблема и при использовании [[decltуре#decltype(auto) C++14|decltype(auto)]]: если вызываемый объект имеет возвращаемый тип `void`, инициализация `ret` как [[decltуре#decltype(auto) C++14|decltype (auto)]] не разрешена, так как `void` является неполным типом. У вас есть следующие варианты.
>
> Объявить в строке до инструкции объект, деструктор которого выполняет наблюдаемое поведение, которое вы хотите реализовать. Например:
```c++
struct cleanup
{
	~cleanup();
	{
		... // Код, выполняемый при возврате
	}
} dummy;

return std::invoke(std::forward<Callable>(op),
					std::forward<Args>(args)...);
```
>
> По-разному реализовать случаи для `void` и для не-`void`:
```c++
#include <utility>         // Для std::Invoke ()
#include <functional>      // Для std::forward ()
#include <type_traits>     // Для std::is_same<> и invoke_result<>

template<typename Callable, typename... Args>
decltype(auto) call(Callable&& op, Args&& ... args)
{
	if constexpr (std::is_same_v<std::invoke_result_t<
									Callable, Args...>,
									void>)
	{
		// Возвращаемый тип - void:
		std::invoke(std::forward<Callable>(op),
					std::forward<Args>(args) ... );
		...
		
		return;
	}
	else
	{
		// Возвращаемый тип - не void:
		decltype(auto) ret{std::invoke(std::forward<Callable>(op),
									std::forward<Args>(args)...)};
		...
		
		return ret;
	}
};
```
>
> Имея
```c++
if constexpr(std::is_same_v<std::invoke_result_t<Callable, Args...>,
				void>)
```
>
> мы выполняем проверку времени компиляции, является ли `void` возвращаемым типом вызываемого объекта `callable` с `Args...` Детальное описание [[invoke#std invoke_result|std::invoke_result<>]] см. в #разделе_Г_3_13.

Будем надеяться, что будущие версии C++ смогут избежать необходимости такой специальной обработки `void` (см. #раздел_17_7).

# Другие утилиты для реализации обобщенных библиотек














