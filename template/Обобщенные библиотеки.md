
[[#Обобщенные библиотеки|Обобщенные библиотеки]] 11
1. [[#Вызываемые объекты|Вызываемые объекты]] 11.1


# Обобщенные библиотеки

До сих пор наше обсуждение шаблонов было сосредоточено на их специфических особенностях, возможностях и ограничениях, с направленностью на непосредственные задачи и приложения (то, с чем в первую очередь сталкиваются прикладные программисты). Однако наиболее эффективными шаблоны оказываются тогда, когда используются для написания обобщенных библиотек и каркасов, где наши проекты должны рассматривать потенциальные применения априори максимально широко. Хотя к таким конструкциям может быть применим почти весь материал данной книги, здесь рассматриваются некоторые общие вопросы, возникающие при написании переносимых компонентов, которые планируется использовать для типов, не существующих пока что даже в проекте.

Перечень поднятых здесь вопросов не завершен в любом смысле, но он кратко резюмирует некоторые из возможностей, представленных в книге до этого момента, вводит некоторые дополнительные функциональные возможности и ссылается на некоторые особенности шаблонов и языка, рассматриваемые в этой книге позже. Мы надеемся, что данный материал еще сильнее мотивирует читателей на чтение всех последующих глав этой книги.

# Вызываемые объекты

Многие библиотеки включают интерфейсы, которым клиентский код передает некоторые сущности, которые должны быть “вызваны”. Примеры включают операции, планируемые для выполнения в другом потоке; функции, описывающие, как хеш-значения должны храниться в хеш-таблице; объекты, описывающие порядок, в котором следует сортировать элементы в коллекции; и обобщенная оболочка, обеспечивающая некоторые значения аргументов по умолчанию. Стандартная библиотека не является исключением: она определяет многие компоненты, которые принимают такие вызываемые сущности.

Одним из терминов, используемых в этом контексте, является понятие [[callback|обратного вызова (callback)]]. Традиционно этот термин зарезервирован для сущностей, которые передаются в качестве аргументов вызова функции (в отличие от, например, аргументов шаблона), и мы придерживаемся этой традиции. Например, функция сортировки может включать параметр обратного вызова как “критерий сортировки”, который вызывается, чтобы определить, находится ли один элемент по отношению к другому в требуемом порядке сортировки.

В C++ имеется ряд типов, хорошо подходящих для обратных вызовов, потому что они могут как быть переданы в качестве аргументов функции, так и вызываться непосредственно с синтаксисом вызова `f(...)`.
>
> Типы указателей на функции.
> 
> Типы классов с перегруженным оператором `operator()` (которые иногда называются ***функторами*** (`functors`)), включая лямбда-выражения.
> 
> Типы классов с функциями преобразования, дающими указатель на функцию или ссылку на функцию.

Вместе все эти типы называются ***типами функциональных объектов***, а значение такого типа называется функциональным объектом.

Стандартная библиотека C++ вводит несколько более широкое понятие ***вызываемого типа*** (callable type), который представляет собой либо тип функционального объекта, либо указатель на член. Объект вызываемого типа называется вызываемым объектом (callable object).

Обобщенный код часто извлекает выгоду от возможности принять вызываемый объект любого вида, и шаблоны позволяют легко это сделать.






































