
[[#Обобщенные библиотеки|Обобщенные библиотеки]] 11
1. [[#Вызываемые объекты|Вызываемые объекты]] 11.1
	1. [[#Поддержка функциональных объектов|Поддержка функциональных объектов]] 11.1.1
	2. [[#Работа с функциями-членами и дополнительными аргументами|Работа с функциями-членами и дополнительными аргументами]] 11.1.2
	3. [[#Оборачивание вызовов функций|Оборачивание вызовов функций]] 11.1.3
2. [[#Другие утилиты для реализации обобщенных библиотек|Другие утилиты для реализации обобщенных библиотек]] 11.2
	1. [[#Свойства типов|Свойства типов]] 11.2.1
	2. [[addressof#std addressof<>()|std: :addressof ()]] 11.2.2
	3. [[#std declval()|std::declval()]] 11.2.3
3. [[#Прямая передача временных значений|Прямая передача временных значений]] 11.3
4. [[#Ссылки в качестве параметров шаблонов|Ссылки в качестве параметров шаблонов]] 11.4


# Обобщенные библиотеки

До сих пор наше обсуждение шаблонов было сосредоточено на их специфических особенностях, возможностях и ограничениях, с направленностью на непосредственные задачи и приложения (то, с чем в первую очередь сталкиваются прикладные программисты). Однако наиболее эффективными шаблоны оказываются тогда, когда используются для написания обобщенных библиотек и каркасов, где наши проекты должны рассматривать потенциальные применения априори максимально широко. Хотя к таким конструкциям может быть применим почти весь материал данной книги, здесь рассматриваются некоторые общие вопросы, возникающие при написании переносимых компонентов, которые планируется использовать для типов, не существующих пока что даже в проекте.

Перечень поднятых здесь вопросов не завершен в любом смысле, но он кратко резюмирует некоторые из возможностей, представленных в книге до этого момента, вводит некоторые дополнительные функциональные возможности и ссылается на некоторые особенности шаблонов и языка, рассматриваемые в этой книге позже. Мы надеемся, что данный материал еще сильнее мотивирует читателей на чтение всех последующих глав этой книги.

# Вызываемые объекты

Многие библиотеки включают интерфейсы, которым клиентский код передает некоторые сущности, которые должны быть “вызваны”. Примеры включают операции, планируемые для выполнения в другом потоке; функции, описывающие, как хеш-значения должны храниться в хеш-таблице; объекты, описывающие порядок, в котором следует сортировать элементы в коллекции; и обобщенная оболочка, обеспечивающая некоторые значения аргументов по умолчанию. Стандартная библиотека не является исключением: она определяет многие компоненты, которые принимают такие вызываемые сущности.

Одним из терминов, используемых в этом контексте, является понятие [[callback|обратного вызова (callback)]]. Традиционно этот термин зарезервирован для сущностей, которые передаются в качестве аргументов вызова функции (в отличие от, например, аргументов шаблона), и мы придерживаемся этой традиции. Например, функция сортировки может включать параметр обратного вызова как “критерий сортировки”, который вызывается, чтобы определить, находится ли один элемент по отношению к другому в требуемом порядке сортировки.

В C++ имеется ряд типов, хорошо подходящих для обратных вызовов, потому что они могут как быть переданы в качестве аргументов функции, так и вызываться непосредственно с синтаксисом вызова `f(...)`.
>
> Типы указателей на функции.
> 
> Типы классов с перегруженным оператором `operator()` (которые иногда называются ***функторами*** (`functors`)), включая лямбда-выражения.
> 
> Типы классов с функциями преобразования, дающими указатель на функцию или ссылку на функцию.

Вместе все эти типы называются ***типами функциональных объектов***, а значение такого типа называется функциональным объектом.

Стандартная библиотека C++ вводит несколько более широкое понятие ***вызываемого типа*** (callable type), который представляет собой либо тип функционального объекта, либо указатель на член. Объект вызываемого типа называется вызываемым объектом (callable object).

Обобщенный код часто извлекает выгоду от возможности принять вызываемый объект любого вида, и шаблоны позволяют легко это сделать.

## Поддержка функциональных объектов

Давайте рассмотрим, как реализован алгоритм [[for_each|for_each()]] стандартной библиотеки (воспользуемся для этого именем `“foreach”`, чтобы избежать возможных конфликтов имен, и для упрощения не будем ничего возвращать из этой функции):
```c++
template<typename Iter, typename Callable>
void foreach (Iter current, Iter end, Callable op)
{
	while (current != end)      // Пока не достигнут конец
	{
		op(*current);           // Вызов переданного оператора
								// для текущего элемента
		++current;              // и перемещение итератора к
								// следующему элементу	
	}
}
```

Приведенная ниже программа демонстрирует применение этого шаблона с различными функциональными объектами:
```c++
#include <iostream>
#include <vector>
#include "foreach.hpp"

// Вызываемая функция:
void func(int i)
{
	std::cout << "func() вызывается для: " << i << '\n';
};

// Тип функционального объекта (для объектов, которые могут
// быть использованы как функции):
class FuncObj
{
	public:
		void operator()(int i) const // Примечание: константная
		{                            // функция-член
			std::cout << "FuncObj::op() вызывается для: " << i << ' \n';
		}
};

int main()
{
	std::vector<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19 };
	
	foreach(primes.begin(), primes.end(), // Диапазон
			func);         // Функция (низведение к указателю)

	foreach(primes.begin(), primes.end(), // Диапазон
			&func);        // Указатель на функцию
			
	foreach(primes.begin(), primes.end(), // Диапазон
			FuncObj());    // Функциональный объект
			
	foreach(primes.begin(), primes.end(), // Диапазон
			[](int i){     // Лямбда-выражение
				std::cout << "Лямбда-выражение вызвано для:"
							<< i << '\n';
			});
}
```

Давайте подробнее рассмотрим каждый случай.
>
> Когда мы передаем имя функции в качестве аргумента функции, мы в действительности передаем не саму функцию, а указатель или ссылку на нее. [[По значению или по ссылке#Работа со строковыми литералами и массивами|Как и в случае массивов]], аргумент-функция низводится до указателя при передаче по значению, а в случае параметра, тип которого является параметром шаблона, будет выведен тип указателя на функцию.
> Функции, так же как и массивы, могут передаваться по ссылке без низведения типа. Однако типы функций в действительности не могут квалифицироваться с помощью [[const|const]]. Если мы объявим последний параметр `foreach()` с типом `Callable consts`, этот [[const|const]] будет просто проигнорирован. (Вообще говоря, в коде C++ редко используются ссылки на функции.)
> 
> Наш второй вызов явно принимает указатель на функцию с использованием адреса имени функции. Это эквивалентно первому вызову (в котором имя функции неявно низводилось до значения указателя), но, возможно, выглядит немного яснее.
> 
> При передаче функтора мы передаем объект типа класса в качестве вызываемого объекта. Вызов через тип класса обычно сводится к вызову его `operator()`. Поэтому вызов 
```c++
op(*current);
```
> обычно трансформируется в
```c++
op.operator()(*current);    // Вызов operator() с параметром
							// *current для объекта op
```
> Обратите внимание на то, что при определении `operator()` вы обычно должны определять как константную функцию-член. В противном случае [[Применение шаблонов на практике#Расшифровка романов об ошибках|может произойти тонкая ошибка, когда каркасы или библиотеки ожидают, что такой вызов не изменяет состояние переданного объекта]].
> Возможно также, что объект типа класса будет неявно преобразовываться в указатель или ссылку на функцию суррогатного вызова (surrogate call function) (обсуждается в #разделе_В_3_5). В таком случае вызов
```c++
op(*current);
```
> будет преобразован в
```c++
(op.operator F())(*current);
```
> где `F` представляет собой тип указателя или ссылки на функцию, в которую может быть преобразован объект типа класса. Это относительно нераспространенный подход.
>
> Лямбда-выражения создают функторы (именуемые замыканиями (closure)), и поэтому данный случай не слишком отличается от случая использования функтора. Однако лямбда-выражения являются очень удобной сокращенной записью для представления функторов, потому они часто появляются в коде, начиная с С++11.
> 
> Интересно, что лямбда-выражения, которые начинаются с `[ ]` (без захвата) производят оператор преобразования в тип указателя на функцию. Однако он никогда не будет выбран как функция суррогатного вызова, потому что его соответствие всегда хуже, чем у обычного `operator()` замыкания.

## Работа с функциями-членами и дополнительными аргументами

Одна возможная сущность для вызова в предыдущем примере не использовалась — это функция-член. Дело в том, что вызов нестатической функции-члена обычно включает указание объекта, для которого применяется вызов, с использованием синтаксиса наподобие `object.memfunc (...)` или `ptr->memfunc (...)`, не соответствующий обычной схеме `функциональный_объект (...)`.

К счастью, начиная с C++17, стандартная библиотека C++ предоставляет утилиту [[invoke|std::invoke()]], которая удобно унифицирует этот случай со случаями с синтаксисом вызова обычных функций, тем самым позволяя вызывать любой вызываемый объект с помощью одной формы вызова. Следующая реализация нашего шаблона `foreach()` использует [[invoke|std::invoke()]]:
```c++
#include <utility>
#include <functional>

template<typename Iter, typename Callable, typename... Args>
void foreach (Iter current, Iter end, Callable op, 
				Args const& ... args)
{
	while (current != end)      // Пока не достигнут конец
	{
		std::invoke(op,         // Вызов переданного вызываемого
					args...,    // объекта с любыми аргументами args 
		            *current);  // и текущим элементом current
		++current;
	}
}
```

Здесь кроме параметра вызываемого объекта мы также принимаем произвольное количество дополнительных параметров. Затем шаблон `foreach()` вызывает [[invoke|std::invoke ()]] с данным вызываемым объектом, за которым следуют дополнительные переданные параметры вместе со ссылкой на элемент, [[invoke|std::invoke ()]] обрабатывает этот код следующим образом.
>
> Если вызываемый объект представляет собой указатель на член, он использует первый дополнительный аргумент как этот объект. Все остальные дополнительные параметры просто передаются как аргументы вызываемому объекту.
> 
> В противном случае все дополнительные параметры просто передаются как аргументы вызываемого объекта.

Обратите внимание на то, что мы не можем использовать здесь прямую передачу для вызываемого объекта или дополнительных параметров: первый вызов может “украсть” их значения, что приведет к неожиданному поведению `ор` в последующих итерациях.

Эта реализация позволяет по-прежнему компилировать все наши исходные вызовы `foreach()`, показанные выше. Теперь, кроме того, мы можем также передавать дополнительные аргументы вызываемым объектам, а сам вызываемый объект может быть функцией-членом. Следующий клиентский код иллюстрирует это:
```c++
#include <iostream>
#include <vector>
#include <string>
#include "foreachinvoke.hpp"

// Класс с функцией-членом, который должен быть вызван
class MyClass
{
	public:
		void memfunc(int i) const
		{
			std::cout << "MyClass::memfunc() вызван для: " << i << '\n';
		}
};

int main ()
{
	std::vector<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19 };

	// Передача лямбда-выражения в качестве вызываемого
	// объекта и дополнительный аргумент:
	foreach(primes.begin(),
			primes.end(),       // Элементы второго аргумента
								// лямбда-выражения
			[](std::string const& prefix, int i) // Вызываемое
			{ std::cout << prefix << i << '\n';},// лямбда-выражение
			"- значение: ");     // Первый аргумент лямбда-выражения

	// Вызов obj.memfunc() для/с каждого элемента primes,
	// передаваемого в качестве аргумента
	MyClass obj;
	
	foreach(primes.begin(),    // Элементы, используемые
			primes.end(),      // в качестве аргументов
			&MyClass::memfunc, // Вызываемая функция-член
			obj );             // Объект вызова memfunc()
```

Первый вызов `foreach()` получает четвертый аргумент (строковый литерал
`"- значение: "`), используемый в качестве первого параметра лямбда-выражения, в то время как текущий элемент вектора связывается со вторым параметром лямбда-выражения. Второй вызов передает функцию-член `memfunc()` в качестве третьего аргумента вызова `obj`, передаваемого как четвертый аргумент.

Свойства типов, которые проверяют, может ли вызываемый объект быть использован [[invoke|std::invoke ()]], описываются в #разделе_Г_3_1.

## Оборачивание вызовов функций

Типичное применение [[invoke|std::invoke()]] заключается в том, чтобы получить “обертку” для вызова одной функции (например, для выполнения записи о вызовах в журнал, измерения их продолжительности или подготовки некоторого контекста, как, например, запуск для них новых потоков). Теперь мы можем обеспечить поддержку семантики перемещения с помощью прямой передачи как вызываемого объекта, так и всех передаваемых аргументов:
```c++
#include <utility>            // Для std::invoke()
#include <functional>         // Для std::forward!)

template<typename Callable, typename... Args>
decltype(auto) call(Callable&& op, Args&& ... args)
{
	return std::invoke(
		std::forward<Callable>(op),   // Передача вызываемого объекта
		std::forward<Args>(args)...); // с дополнительными аргументами
}
```

Еще одним интересным аспектом является работа с возвращаемым значением вызываемой функции для его “прямой передачи” назад вызывающему коду. Для поддержки возвращения ссылок (как, например, [[ostream|std::ostream&]]) следует использовать [[decltуре#decltype(auto) C++14|decltype(auto)]] вместо просто [[auto|auto]]:
```c++
template<typename Callable, typename... Args>
decltype(auto) call(Callable&& op, Args&& ... args)
```

[[decltуре#decltype(auto) C++14|decltype (auto)]] (доступно начиная с C++14) является типом-заместителем (placeholder type), который определяет тип переменной, возвращаемый тип или аргумент шаблона из типа связанного выражения (инициализатор, возвращаемое значение или аргумент шаблона). Подробности его использования можно найти в #разделе_15_10_3.

Если вы хотите временно хранить значение, возвращаемое [[invoke|std::invoke()]], в переменной, чтобы вернуть его после того, как будет сделано что-то иное (например, выполнение некоторых действий с возвращаемым значением или журнальная запись о конце вызова), вы также должны объявить эту временную переменную с использованием [[decltуре#decltype(auto) C++14|decltype (auto)]]:
```c++
decltype(auto) ret(std::invoke(std::forward<Callable>(op),
								std::forward<Args>(args)...)};
...

return ret;
```

Обратите внимание на то, что объявлять `ret` с помощью [[auto|auto&&]] некорректно. В качестве ссылки [[auto|auto&&]] продлевает время жизни возвращаемого значения до конца ее области видимости (см. #раздел_11_3), но не за пределы инструкции `return` вызывающему коду.

Однако имеется проблема и при использовании [[decltуре#decltype(auto) C++14|decltype(auto)]]: если вызываемый объект имеет возвращаемый тип `void`, инициализация `ret` как [[decltуре#decltype(auto) C++14|decltype (auto)]] не разрешена, так как `void` является неполным типом. У вас есть следующие варианты.
>
> Объявить в строке до инструкции объект, деструктор которого выполняет наблюдаемое поведение, которое вы хотите реализовать. Например:
```c++
struct cleanup
{
	~cleanup();
	{
		... // Код, выполняемый при возврате
	}
} dummy;

return std::invoke(std::forward<Callable>(op),
					std::forward<Args>(args)...);
```
>
> По-разному реализовать случаи для `void` и для не-`void`:
```c++
#include <utility>         // Для std::Invoke ()
#include <functional>      // Для std::forward ()
#include <type_traits>     // Для std::is_same<> и invoke_result<>

template<typename Callable, typename... Args>
decltype(auto) call(Callable&& op, Args&& ... args)
{
	if constexpr (std::is_same_v<std::invoke_result_t<
									Callable, Args...>,
									void>)
	{
		// Возвращаемый тип - void:
		std::invoke(std::forward<Callable>(op),
					std::forward<Args>(args) ... );
		...
		
		return;
	}
	else
	{
		// Возвращаемый тип - не void:
		decltype(auto) ret{std::invoke(std::forward<Callable>(op),
									std::forward<Args>(args)...)};
		...
		
		return ret;
	}
};
```
>
> Имея
```c++
if constexpr(std::is_same_v<std::invoke_result_t<Callable, Args...>,
				void>)
```
>
> мы выполняем проверку времени компиляции, является ли `void` возвращаемым типом вызываемого объекта `callable` с `Args...` Детальное описание [[invoke#std invoke_result|std::invoke_result<>]] см. в #разделе_Г_3_13.

Будем надеяться, что будущие версии C++ смогут избежать необходимости такой специальной обработки `void` (см. #раздел_17_7).

# Другие утилиты для реализации обобщенных библиотек

[[invoke#std invoke|std::invoke()]] — лишь один из примеров полезных утилит, предоставляемых стандартной библиотекой C++ для реализации обобщенных библиотек. Ниже мы бегло рассмотрим некоторые другие важные утилиты.

## Свойства типов

Стандартная библиотека предоставляет различные утилиты, именуемые ***свойствами типов*** (type traits), которые позволяют нам вычислять и изменять типы. Они обеспечивают поддержку различных случаев, когда обобщенный код должен адаптироваться к различным типам, или реагировать на возможности типов, для которых он инстанцируется. Например:
```c++
#include <type_traits>

template<typename Т>
class С
{
	// Гарантируем, что Т не является void
	// (игнорируя const или volatile):
		static_assert(!std::is_same_v<std::remove_cv_t<T>, void>,
						"Неверное инстанцирование класса С для void");
	public:
		template<typename V>
		void f(V&& v)
		{
			if constexpr(std::is_reference_v<T>)
			{
				... // Специальный код, если T — ссылочный тип
			)
			
			if constexpr(std::is_convertible_v<std::decay_t<V>, T>)
			{
				... // Специальный код, если V преобразуемый в Т
			}
			
			if constexpr(std::has_virtual_destructor_v<V>)
			{
				... // Специальный код, если у V виртуальный деструктор
			}
		}
};
```

Как показывает этот пример, путем проверки некоторых условий мы можем выбирать между различными реализациями шаблона. Здесь мы используем [[Программирование времени компиляции#Инструкция if времени компиляции|функциональную возможность if времени компиляции, которая появилась в C++17]], но вместо нее могли бы [[Программирование времени компиляции#Программирование времени компиляции|использовать std::enable_if, частичную специализацию или SFINAE для включения или отключения вспомогательных шаблонов]].

Обратите, однако, внимание на то, что свойства типов должны использоваться с особой осторожностью: они могут вести себя иначе, чем может ожидать простодушный программист. Например:
```c++
std::remove_const_t<int const&>          // Дает int const&
```

Здесь, поскольку ссылка не является [[const#const|const]] (хотя вы не можете ее изменять), вызов не действует и дает переданный тип.

Как следствие, порядок удаления ссылочности и [[const|const]] имеет значение:
```c++
std::remove_const_t<std::remove_reference_t<int const&>> // int
std::remove_reference_t<std::remove_const_t<int const&>> // int const
```

Вместо этого можно просто вызвать
```c++
std::decay_t<int const&> // Дает int
```

Однако этот код будет также преобразовывать массивы и функции в соответствующие типы указателей.

Кроме того, есть случаи, когда свойства типов имеют определенные требования, невыполнение которых ведет к неопределенному поведению. Например:
```c++
make_unsigned_t<int>            // unsigned int
make_unsigned_t<int const&>     // Неопределенное поведение
								// (надеемся, ошибка)
```

Иногда результат может оказаться удивительным. Например:
```c++
add_rvalue_reference_t<int>         // int&&
add_rvalue_reference_t<int const>   // int const&&
add_rvalue_reference_t<int const&>  // int const& (l-ссылка
									// остается 1-ссылкой)
```

Здесь мы могли бы ожидать, что [[add_rvalue_reference|add_rvalue_reference]] всегда дает в результате [[значение#r-значения|r-ссылки]], но правила свертывания ссылок C++ (см. #раздел_15_6_1) приводят к тому, что сочетание [[значение|l-ссылки и r-ссылки дает l-ссылку]]. 

В качестве еще одного примера:
```c++
is_copy_assignable_v<int>       // Дает true (в общем случае можно
								// присваивать int типу int)
is_assignable_v<int, int>       // Дает false (нельзя вызвать 42 = 42)
```

В то время как [[is_copy_assignable|is_copy_assignable]] просто проверяет в общем случае, можно ли присвоить один `int` другому (проверка операции для 1-значений), [[is_assignable|is_assignable]] принимает во внимание [[значение|категорию значения(здесь проверяется, можно ли присвоить pr-значение рr-значению)]]. То есть первое выражение эквивалентно
```c++
is_assignable_v<int&,int&>            // Дает true
```

По той же причине:
```c++
is_swappable_v<int>             // Дает true (подразумевая l-значения)
is_swappable_v<int&,int&>       // Дает true (эквивалент
								// предыдущей проверки)  
is_swappable_with_v<int, int>   // Дает false (учитывает
								// категорию значения)
```

По всем этим причинам тщательно изучайте точное определение свойств типов. Стандартные свойства типов подробно описаны в #приложении_Г, “Стандартные утилиты для работы с типами”.

## std::addressof ()

[[addressof#std addressof<>()|см. ...]]

# std::declval()

[[declval#std declval|см ...]]

# Прямая передача временных значений

[[Семантика перемещения - Прямая передача|Как было показано]], можно использовать передаваемые ссылки и [[forward|std::forward<>]] для “прямой передачи” обобщенных параметров:
```c++
template<typename Т>
void f(T&& t)               // t — передаваемая ссылка
{
	g(std::forward<T>(t));  // Прямая передача переданного
							// аргумента в g()
}
```

Однако иногда нам нужно выполнить в обобщенном коде прямую передачу данных, полученных не через параметр. В этом случае можно использовать [[auto|auto&&]] для создания переменной, которая может быть передана. Например, предположим, что мы связываем в цепочку вызовы функций `get()` и `set()`, где возвращаемое значение метода `get()` должно быть прямо передано в `set()`:
```c++
template<typename Т>
void foo(Т х)
{
	set(get(х));
}
```

Предположим далее, что нам нужно обновить наш код для выполнения некоторой операции над промежуточным значением, полученным путем вызова `get()`. Мы делаем это, сохраняя значение в переменной, объявленной с помощью [[auto|auto&&]]:
```c++
template<typename T>
void foo(T х)
{
	auto&& val = get(x);

	...
	
	// Прямая передача значения, возвращенного
	// методом get(), методу set():
	set(std::forward<decltype(val)>(val));
}
```

Это позволяет избежать излишнего копирования промежуточного значения.

# Ссылки в качестве параметров шаблонов

Хотя это и не слишком распространенная практика, но параметры типов шаблонов могут быть ссылочными типами. Например:
```c++
#include <iostream>

template<typename T>
void tmp1ParamIsReference(T)
{
	std::cout << "T является ссылкой: "
				<< std::is_reference_v<T> << '\n’;
}

int main()
{
	std::cout << std::boolalpha;
	
	int i ;
	int& r = i;
	
	tmp1ParamIsReference(i);         // false
	tmp1ParamIsReference(r);         // false
	
	tmp1ParamIsReference<int&>(i);   // true
	tmp1ParamIsReference<int&>(r);   // true
}
```

Даже если передать в `tmp1ParamIsReference()` ссылочную переменную, параметр шаблона `Т` будет выведен как тип, на который она ссылается (поскольку для ссылочной переменной `v` выражение `v` имеет тип, на который ссылается `v`; тип выражения никогда не является ссылкой). Однако можно обеспечить ссылку, явно указывая тип `Т`:
```c++
tmp1ParamIsReference<int&>(г);
tmp1ParamIsReference<int&>(i);
```

Это действие может коренным образом изменить поведение шаблона, а поскольку, скорее всего, шаблон разрабатывался без учета такой возможности, это может привести к ошибочному или непредвиденному поведению. Рассмотрим следующий пример:
```c++
template < typename Т, Т Z = Т{} >
class RefMem
{
	private:
		Т zero;
	public:
		RefMem() : zero{Z}
		{   }
};

int null = 0;

int main()
{
	RefMem<int> rm1, rm2;
	rm1 = rm2;         // OK
	
	RefMem<int&> rm3;  // Ошибка: неверное значение по умолчанию для N
	RefMem<int&, 0>rm4;// Ошибка: неверное значение по умолчанию для N

	extern int null;

	RefMem<int&, null> rm5, rm6;
	rm5 = rm6;         // Ошибка: operator= удален из-за члена-ссылки
}
```

Здесь у нас есть класс с членом, имеющим тип параметра шаблона `Т`, который инициализируется нетиповым параметром шаблона `Z`, который по умолчанию имеет нулевое значение. Создание экземпляра класса с типом `int` работает, как и ожидалось. Однако при попытке инстанцировать его со ссылкой ситуация усложняется:
>
> инициализация по умолчанию больше не работает;
> 
> вы больше не можете просто передать `0` в качестве инициализатора для `int`;
> 
> и, что, вероятно, самое удивительное, оператор присваивания больше недоступен, поскольку классы с нестатическими членами-ссылками по умолчанию имеют удаленный оператор присваивания.

Кроме того, использование ссылочных типов для параметров шаблонов, не являющихся типами, оказывается сложным и может быть опасным. Рассмотрим следующий пример:
```c++
#include <vector>
#include <iostream>

template<typename T, int& SZ> // Примечание: размер является ссылкой
class Arr
{
	private:
		std::vector<T> elems;
	
	public:
		Arr() : elems(SZ)    // SZ - начальный размер вектора
		{    }

		void print() const
		{
			for (int i = 0; i < SZ; ++i) // Цикл по SZ элементам
			{
				std::cout << elems[i] << ' '.
			}
		}
};

int size = 10;

int main ()
{
	Arr<int&,size> у;   // Ошибка времени компиляции глубоко
						// в коде класса std:: vector<>
	Arr<int, size> x;   // Инициализация внутреннего вектора
						// с 10 элементами	
	x.print();          // ОК
	
	size += 100;        // Ой: изменение SZ в Агг<>
	x.print();          // Ошибка времени выполнения: некорректное
						// обращение к памяти: цикл по 110 элементам
}
```

Здесь попытка инстанцирования `Arr` для элементов ссылочного типа приводит к ошибке глубоко в коде класса [[vector|std::vector<>]], потому что он не может быть создан с ссылками в качестве элементов:
```c++
Arr<int&, size> у;      // Ошибка времени компиляции глубоко
						// в коде класса std::vector<>
```

Такая [[Применение шаблонов на практике#Расшифровка романов об ошибках|ошибка часто приводит к “романам”]], в которых компилятор выводит всю историю инстанцирования шаблона от исходного шаблона до фактического шаблона, в котором была обнаружена ошибка.

Возможно, еще хуже — ошибка времени выполнения, связанная с тем, что параметр размера является ссылкой: он позволяет изменяться записанному значению размера без уведомления об этом контейнера (т.е. значение размера может стать некорректным). Таким образом, операции с использованием размера (такие как член `print()` ) будут демонстрировать неопределенное поведение (приводя программу к аварийному завершению или к чему похуже):
```c++
Arr<int, size> х;       // Инициализация внутреннего вектора
						// с 10 элементами

х.print();              // ОК
size += 100;            // Ой: изменение SZ в Агг<>
х.print();              // Ошибка времени выполнения: некорректное
						// обращение к памяти: цикл по 110 элементам
```

Обратите внимание на то, что изменение параметра шаблона `SZ` на `int const&` проблему не решает, потому что сам `size` остается изменяемым.

Возможно, этот пример надуманный. Однако такие вопросы реально возникают в более сложных ситуациях. Кроме того, в C++17 параметры, не являющиеся типами, можно выводить, например:
```c++
template<typename Т, decltype(auto) SZ>
class Arr;
```

С помощью [[decltуре#decltype(auto) C++14|decltype(auto)]] можно легко создать ссылочные типы и, таким образом, их следует вообще избегать в данном контексте (по умолчанию используя [[auto|auto]]). Подробности представлены в #разделе_15_10_3.

По этой причине стандартная библиотека C++ содержит некоторые удивительные спецификации и ограничения, как, например, приведенные далее.
>
> Для того чтобы оператор присваивания существовал, даже если параметры шаблона инстанцируются для ссылок, классы [[pair|std::pair<>]] и [[tuple|std::tuple<>]] реализуют операторы присваивания вместо использования поведения по умолчанию. Например:
```c++

```






















