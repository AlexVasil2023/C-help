
[[#Стандартные утилиты для работы с типами|Стандартные утилиты для работы с типами]] Г
1. [[#Использование свойств типов|Использование свойств типов]] Г.1
	1. [[#std integral_constant и std bool_constant|std::integral_constant и std::bool_constant]] Г.1.1
	2. [[#Что вы должны знать при использовании свойств|Что вы должны знать при использовании свойств]] Г.1.2









# Стандартные утилиты для работы с типами

Стандартная библиотека C++ в основном состоит из шаблонов, многие из которых опираются на различные методы, представленные и всесторонне рассмотренные в этой книге. По этой причине некоторые методы были “стандартизованы” в том смысле, что стандартная библиотека определяет несколько шаблонов для реализации библиотек с обобщенным кодом. Эти утилиты для работы с типами (свойства типов и другие вспомогательные шаблоны) перечислены и разъясняются здесь, в этом приложении.

Обратите внимание на то, что некоторые [[Реализация свойств типов#Реализация свойств типов|свойства типов требуют поддержки компилятора, в то время как другие могут быть реализованы в библиотеке только с помощью стандартных возможностей языка]].

# Использование свойств типов

В общем случае при использовании свойств типов необходимо включение заголовочного файла `<type_traits>`:
```c++
#include <type_traits>
```

Далее их применение зависит от того, дает свойство тип или значение.
>
> Если свойство дает тип, обратиться к нему можно следующим образом:
```c++
typename std::trait<...>::type
std::trait_t<...>                             // Начиная с C++14
```
>
> Если свойство дает значение, обратиться к нему можно следующим образом:
```c++
std::trait<...>::value
std::trait<...>()          // Неявное преобразование в его тип
std::trait_v<...>          // Начиная с С++17
```

Например:
```c++
#include <type_traits>
#include <iostream>

int main()
{
	int i = 42;
	std::add_const<int>::type c = i; // c — int const
	std::add_const_t<int> cl4 = i;   // Начиная с C++14
	static__assert(std::is_const<decltype(c)>::value,
					"с должна быть const");

	std::cout << std::boolalpha;
	std::cout << std::is_same<decltype(c), int const>::value // true
				<< '\n';
	std::cout << std::is_same_v<decltype(c), int const>
				<< '\n' ;                        // Начиная с C++17

	// Неявное преобразование в bool:
	if (std::is_same<decltype(с), int const> {})
	{
		std::cout << "Одинаковы \n";
	}
};
```

[[Шаблоны классов#Псевдонимы типов|способ определения `_t`-версии свойств]]
[[Шаблоны переменных#Шаблоны переменных|способ определения `_v`-версии свойств]].

## std::integral_constant и std::bool_constant

Все стандартные типы, дающие значение, являются производными от экземпляра вспомогательного шаблона класса `std::integral_constant`:
```c++
namespace std
{
	template<typename T, T val>
	struct integral_constant
	{
		static constexpr T value = val; // Значение свойства
		using value_type = T;           // Тип значения
		using type = integral_constant<T, val>;
		
		constexpr operator value_type() const noexcept
		{
			return value;
		}
		
		// Начиная с C++14:
		constexpr value_type operator()() const noexcept
		{
			return value;
		}
	};
};
```

Из приведенного шаблона видно следующее.
> 
> Можно использовать член `value_type` для запроса типа результата. Поскольку многие свойства, дающие значения, являются предикатами, `value_type` часто является простым `bool`.
> 
> Объекты с типами свойств имеют неявное преобразование типа в тип значения, производимый свойством типа.
> 
> В C++14 (и далее) объекты типа свойств являются также функциональными объектами (функторами), для которых “вызов функции” дает их значения.
> 
> Член `type` просто дает базовый экземпляр `integral constant`.

Если свойства дают булевы значения, то они также используют
```c++
namespace std
{
	template<bool В>
	using bool_constant = integral_constant<bool,B>; // Начиная с C++17
	using true_type = bool_constant<true>;
	using false_type = bool_constant<false>;
}
```

так что эти логические свойства наследуют `std::true_type`, если определенное свойство справедливо, и `std::false_type`, если нет. Это также означает, что соответствующие члены `value` равны `true` или `false`. Наличие различных типов для результирующих значений `true` и `false` позволяет нам прибегать к [[Перегрузка свойств типов#Диспетчеризация дескрипторов|диспетчеризации дескрипторов]], основанной на [[Реализация свойств типов#Свойства-предикаты|результатах свойств типа]].

Например:
```c++
#include <type_traits>
#include <iostream>

int main()
{
	using namespace std;
	cout << boolalpha;
	
	using MyType = int;
	cout << is_const<MyType>::value << ' \n';     // Выводит false
	
	using VT = is_const<MyType>::value_type;      // bool
	
	// integral_constant<bool, false>:
	using Т = is_const<MyType>::type;
	cout << is_same<VT, bool>::value << '\n':     // Выводит true
	cout << is_same<T, integral_constant<bool, false>>::value 
			<< '\n';                              // Выводит true
	cout << is_same<T, bool_constant<false>>::value // Выводит true
			<< '\n';                             // (не работает до C++17)
	
	auto ic = is_const<MyType>();                // Объект типа свойства
	cout << is_some<decltype(ic),
					is_const<int>>::value << '\n'; // true
	cout << ic() << '\n';                // Вызов функции (выводит false)

	static constexpr auto mytypeIsConst = is_const<MyType> {};
	
	if constexpr(mytypeIsConst)          // Проверка времени компиляции
	{                                    // начиная с С++17 => false
		...                              // Отброшенные инструкции
	}
	
	static_assert(!std::is_const<MyType> {},
					"МуТуре не должен быть константой");
}
```

Наличие различных типов для небулевых специализаций `integral_constant` полезно также в ряде контекстов метапрограммирования. [[Списки типов - template#Списки нетиповых параметров|Обсуждение аналогичного типа CTValue]] и его [[tuple (Кортежи)#Индексы кортежа|применение для доступа к элементу кортежа]].

## Что вы должны знать при использовании свойств


















