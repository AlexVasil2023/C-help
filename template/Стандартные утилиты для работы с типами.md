
[[#Стандартные утилиты для работы с типами|Стандартные утилиты для работы с типами]] Г
1. [[#Использование свойств типов|Использование свойств типов]] Г.1
	1. [[#std integral_constant и std bool_constant|std::integral_constant и std::bool_constant]] Г.1.1
	2. [[#Что вы должны знать при использовании свойств|Что вы должны знать при использовании свойств]] Г.1.2
2. [[#Основные и составные категории типов|Основные и составные категории типов]] Г.2
	1. [[#Проверка основных категорий типов|Проверка основных категорий типов]] Г.2.1
	2. [[#Проверка составных категорий типов|Проверка составных категорий типов]] Г.2.2
3. [[#Характеристики и операции над типами|Характеристики и операции над типами]] Г.3
	1. [[#Прочие характеристики типов|Прочие характеристики типов]] Г.3.1
	2. [[#Взаимоотношения между типами|Взаимоотношения между типами]] Г.3.3
4. [[#Построение типов|Построение типов]] Г.4
5. [[#Прочие свойства|Прочие свойства]] Г.5
6. [[#Комбинирование свойств типов|Комбинирование свойств типов]] Г.6
7. [[#Прочие утилиты|Прочие утилиты]] Г.7

# Стандартные утилиты для работы с типами

Стандартная библиотека C++ в основном состоит из шаблонов, многие из которых опираются на различные методы, представленные и всесторонне рассмотренные в этой книге. По этой причине некоторые методы были “стандартизованы” в том смысле, что стандартная библиотека определяет несколько шаблонов для реализации библиотек с обобщенным кодом. Эти утилиты для работы с типами (свойства типов и другие вспомогательные шаблоны) перечислены и разъясняются здесь, в этом приложении.

Обратите внимание на то, что некоторые [[Реализация свойств типов#Реализация свойств типов|свойства типов требуют поддержки компилятора, в то время как другие могут быть реализованы в библиотеке только с помощью стандартных возможностей языка]].

# Использование свойств типов

В общем случае при использовании свойств типов необходимо включение заголовочного файла `<type_traits>`:
```c++
#include <type_traits>
```

Далее их применение зависит от того, дает свойство тип или значение.
>
> Если свойство дает тип, обратиться к нему можно следующим образом:
```c++
typename std::trait<...>::type
std::trait_t<...>                             // Начиная с C++14
```
>
> Если свойство дает значение, обратиться к нему можно следующим образом:
```c++
std::trait<...>::value
std::trait<...>()          // Неявное преобразование в его тип
std::trait_v<...>          // Начиная с С++17
```

Например:
```c++
#include <type_traits>
#include <iostream>

int main()
{
	int i = 42;
	std::add_const<int>::type c = i; // c — int const
	std::add_const_t<int> cl4 = i;   // Начиная с C++14
	static__assert(std::is_const<decltype(c)>::value,
					"с должна быть const");

	std::cout << std::boolalpha;
	std::cout << std::is_same<decltype(c), int const>::value // true
				<< '\n';
	std::cout << std::is_same_v<decltype(c), int const>
				<< '\n' ;                        // Начиная с C++17

	// Неявное преобразование в bool:
	if (std::is_same<decltype(с), int const> {})
	{
		std::cout << "Одинаковы \n";
	}
};
```

[[Шаблоны классов#Псевдонимы типов|способ определения `_t`-версии свойств]]
[[Шаблоны переменных#Шаблоны переменных|способ определения `_v`-версии свойств]].

## std::integral_constant и std::bool_constant

Все стандартные типы, дающие значение, являются производными от экземпляра вспомогательного шаблона класса `std::integral_constant`:
```c++
namespace std
{
	template<typename T, T val>
	struct integral_constant
	{
		static constexpr T value = val; // Значение свойства
		using value_type = T;           // Тип значения
		using type = integral_constant<T, val>;
		
		constexpr operator value_type() const noexcept
		{
			return value;
		}
		
		// Начиная с C++14:
		constexpr value_type operator()() const noexcept
		{
			return value;
		}
	};
};
```

Из приведенного шаблона видно следующее.
> 
> Можно использовать член `value_type` для запроса типа результата. Поскольку многие свойства, дающие значения, являются предикатами, `value_type` часто является простым `bool`.
> 
> Объекты с типами свойств имеют неявное преобразование типа в тип значения, производимый свойством типа.
> 
> В C++14 (и далее) объекты типа свойств являются также функциональными объектами (функторами), для которых “вызов функции” дает их значения.
> 
> Член `type` просто дает базовый экземпляр `integral constant`.

Если свойства дают булевы значения, то они также используют
```c++
namespace std
{
	template<bool В>
	using bool_constant = integral_constant<bool,B>; // Начиная с C++17
	using true_type = bool_constant<true>;
	using false_type = bool_constant<false>;
}
```

так что эти логические свойства наследуют `std::true_type`, если определенное свойство справедливо, и `std::false_type`, если нет. Это также означает, что соответствующие члены `value` равны `true` или `false`. Наличие различных типов для результирующих значений `true` и `false` позволяет нам прибегать к [[Перегрузка свойств типов#Диспетчеризация дескрипторов|диспетчеризации дескрипторов]], основанной на [[Реализация свойств типов#Свойства-предикаты|результатах свойств типа]].

Например:
```c++
#include <type_traits>
#include <iostream>

int main()
{
	using namespace std;
	cout << boolalpha;
	
	using MyType = int;
	cout << is_const<MyType>::value << ' \n';     // Выводит false
	
	using VT = is_const<MyType>::value_type;      // bool
	
	// integral_constant<bool, false>:
	using Т = is_const<MyType>::type;
	cout << is_same<VT, bool>::value << '\n':     // Выводит true
	cout << is_same<T, integral_constant<bool, false>>::value 
			<< '\n';                              // Выводит true
	cout << is_same<T, bool_constant<false>>::value // Выводит true
			<< '\n';                             // (не работает до C++17)
	
	auto ic = is_const<MyType>();                // Объект типа свойства
	cout << is_some<decltype(ic),
					is_const<int>>::value << '\n'; // true
	cout << ic() << '\n';                // Вызов функции (выводит false)

	static constexpr auto mytypeIsConst = is_const<MyType> {};
	
	if constexpr(mytypeIsConst)          // Проверка времени компиляции
	{                                    // начиная с С++17 => false
		...                              // Отброшенные инструкции
	}
	
	static_assert(!std::is_const<MyType> {},
					"МуТуре не должен быть константой");
}
```

Наличие различных типов для небулевых специализаций `integral_constant` полезно также в ряде контекстов метапрограммирования. [[Списки типов - template#Списки нетиповых параметров|Обсуждение аналогичного типа CTValue]] и его [[tuple (Кортежи)#Индексы кортежа|применение для доступа к элементу кортежа]].

## Что вы должны знать при использовании свойств

Говоря о применениях свойств, следует упомянуть о следующем.

> Свойства типов применяются непосредственно к типам, но [[decltуре|decltype]] позволяет нам также проверять свойства выражений, переменных и функций. Напомним, однако, что [[decltуре|decltype]] дает тип переменной или функции, только если сущность именована и не находится в лишних скобках; для любого прочего выражения эта конструкция дает тип, который отражает также категорию типа выражения. Например:
```c++
void foo(std::string&& s)
{
	// Проверка типа s:
	// false:
	std::is_lvalue_reference<decltype(s)>::value

	// true, согласно объявлению:
	std::is_rvalue_reference<decltype(s)>::value
	
	// Проверка категории значения s как выражения:
	// true, s используется как l-значение:
	std::is_lvalue_reference<decltype((s))>::value
	
	// false:
	std::is_rvalue_reference<decltype((s))>::value
}
```
> 
> [[decltуре#Запись типа выражения с помощью decltype|Подробности...]]
>
> Некоторые свойства для начинающего программиста могут демонстрировать [[Обобщенные библиотеки - template#Другие утилиты для реализации обобщенных библиотек|неинтуитивное поведение]].
> 
> Некоторые свойства предъявляют определенные требования или предусловия. Нарушение этих предусловий ведет к неопределенному поведению. [[Обобщенные библиотеки - template#Свойства типов|Некоторые примеры ...]].
>
> Многие свойства требуют [[Основные термины в области шаблонов#Полные и неполные типы|полных типов]]. Чтобы иметь возможность использовать их для неполных типов, мы иногда можем [[Обобщенные библиотеки - template#Откладывание вычислений|ввести шаблоны для того, чтобы отложить их вычисление]].
> 
> Иногда логические операторы `&&`, `||`, и `!` не могут использоваться для определения нового свойства типа, основанного на других свойствах типов.
> 
> Кроме того, работа со свойствами типов, которые могут давать сбои, может стать проблемой или по крайней мере привести к определенным недостаткам. По этой причине предоставляются специальные свойства, которые позволяют нам логически объединять булевы свойства типов. Подробнее об этом рассказывается в [[Стандартные утилиты для работы с типами#Комбинирование свойств типов|Комбинирование свойств типов]].
> 
> Хотя стандартные шаблоны псевдонимов (заканчивающиеся `_t` или `_у`) часто удобны, они также имеют [[Реализация свойств типов#Повышение удобства свойств|недостатки, делающие их непригодными для использования в некоторых контекстах метапрограммирования]].

# Основные и составные категории типов

Начнем со стандартных свойств, которые проверяют основные и составные категории типов (см. рис. Г.1). В общем случае каждый тип принадлежит ровно к одной основной категории типа (белые элементы на рисунке). Составные категории типов объединяют основные категории типов в концепции более высокого уровня.

![[template_11.png]]
рис. Г.1. Основные и составные категории типов

## Проверка основных категорий типов

Этот раздел описывает утилиты, которые проверяют основную категорию данного типа. Для любого заданного типа ровно одна основная категория имеет статический член `value`, который имеет значение `true`. Результат не зависит от того, квалифицирован тип с помощью [[const|const]] или [[volatile]] (cv-квалифицированный).

Обратите внимание на то, что для типов [[size#std size_t|std::size_t]] и [[ptrdiff#std ptrdiff_t|std::ptrdiff_t]] свойство [[is_integral|is_integral<>]] дает значение `true`. Для типа [[max_align#std max_align_t|std::max_align_t]] то, какая из основных категорий типа выдаст `true`, зависит от реализации (т.е. это может быть целочисленный тип, тип с плавающей точкой или классовый тип). Язык определяет, что [[Вывод аргументов шаблона#Обобщенные лямбда-выражения|тип лямбда-выражения — это классовый тип]], поэтому применение [[is_class|is_class]] к этому типу дает значение `true`.

Таблица Г.1. Свойства для проверки основных категорий типов

| Свойство                                                                                       | Эффект                                                                               |
| ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| [[is_void#is_void\|is void<T>]]                                                                | Тип `void`                                                                           |
| [[is_integral#std is_integral\|is integral<T>]]                                                | Целочисленный тип (включая `bool`, `char`, `char16_t`, `char32_t`, `wchar_t`)        |
| [[is_floating_point\|is floating point<T>]]                                                    | Тип с плавающей точкой (`float`, `double`, `long double`)                            |
| [[is_array#std is_array\|is array<T>]]                                                         | Обычный массив (не тип [[Array#std array C++11\|std::array]])                        |
| [[is_pointer\|is pointer<T>]]                                                                  | Тип указателя (включая указатели на функции, но не указатели на нестатические члены) |
| [[is_null_pointer\|is null pointer<T>]]                                                        | Тип [[nullptr_t#nullptr\|nullptr]] (начиная с С++14)                                 |
| [[is_member_object_pointer#std is_member_object_pointer\|is member object pointer<T>]]         | Указатель на нестатический член-данное                                               |
| [[is_member_function_pointer#std is_member_function_pointer<>\|is member function pointer<T>]] | Указатель на нестатическую функцию-член                                              |
| [[is_lvalue_reference#std is_lvalue_reference\|is lvalue reference<T>]]                        | Ссылка на [[r-значение#l-значение\|l-значение]]                                      |
| [[is_rvalue_reference#std is_rvalue_reference\|is rvalue reference<T>]]                        | Ссылка на [[r-значение#r-значения\|r-значение]]                                      |
| [[is_enum#std is_enum\|is enum<T>]]                                                            | Тип перечисления                                                                     |
| [[is_class#std is_class\|is class<T>]]                                                         | Тип класса/структуры или лямбда-выражения, но не объединения                         |
| [[is_union#std is_union\|is union<T>]]                                                         | Тип объединения                                                                      |
| [[is_function#std is_function\|is function<T>]]                                                | Тип функции                                                                          |

[[is_void#is_void|std::is_void<T>::value]] 
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) `void`.
> 
> Например:
> 
```c++
is_void_v<void>                        // Дает true
is_void_v<void const>                  // Дает true
is_void_v<int>                         // Дает false
void f();
is_void_v<decltype(f)>                 // Дает false (f имеет тип функции)
is_void_v<decltype(f())>               // Дает true (возвращаемый тип f())
```

[[is_integral#std is_integral|std::is_integral<T>:rvalue]] 
>
> Дает `true`, если тип `T` представляет собой один из следующих (возможно, `cv`-квалифицированных) типов:
> 
> > `bool`;
> >
> > символьный тип (`char`, `signed char`, `unsigned char`, `char16_t`, `char32_t` или `wchar_t`);
> >
> > целочисленный тип (знаковые или беззнаковые варианты `short`, `int`, `long` или `long long`; включает [[size#std size_t|std::size_t]] и [[ptrdiff#std ptrdiff|std::ptrdiff_t]]).

[[is_floating_point#is_floating_point<T>|std: :is_floating_jpoint<T>: : value]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) `float`, `double` или `long double`.

[[is_array#std is_array|std::is_array<T>::value]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) тип массива.
> 
> Помните, что параметр, объявленный как массив (с длиной или без таковой) по правилам языка в действительности имеет тип указателя.
> 
> Обратите внимание на то, что класс [[Array#std array C++11|std::array<>]] является типом класса, а не массива.
> 
> Например:
```c++
is_array_v<int[]>                // Дает true
is_array_v<int[5]>               // Дает true
is_array_v<int*>                 // Дает false

void foo(int a[], int b[5], int* c)
{
	is_array_v<decltype(a)>      // Дает false (a имеет тип int*)
	is_array_v<decltype(b)>      // Дает false (b имеет тип int*)
	is_array_v<decltype(c)>      // Дает false (c имеет тип int*)
}
```
>
> [[Реализация свойств типов#Определение составных типов|Детали реализации рассмотрены ...]].

[[is_pointer#std is_pointer|std::is_pointer<T>:rvalue]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) указатель.
> 
> Сюда входят:
> 
> > указатели на статические/глобальные функции (и статические функции-члены);
> > параметры, объявленные как массивы (с длиной или без таковой) или типы функций.
>
> Сюда не. входят:
> 
> > типы указателей на члены (например, тип `&Х::m`, где `X` — классовый тип a `m` — нестатическая функция-член или нестатический член-данное);
> > 
> > тип [[nullptr_t#std nullptr_t|nullptr - std: :nullptr_t]].
>
> Например:
```c++
is_pointer_v<int>                          // Дает false
is_pointer_v<int*>                         // Дает true
is_pointer_v<int* const>                   // Дает true
is_pointer_v<int*&>                        // Дает false
is_pointer_v<decltype(nullptr)>            // Дает false

int* foo(int a[5], void(f)())
{
	is_pointer_v<decltype(a)>            // Дает true (тип a — int*)
	is_pointer_v<decltype(f)>            // Дает true (тип f — void(*)())
	is_pointer_v<decltype(foo)>          // Дает false
	is_pointer_v<decltype(&foo)>         // Дает true
	// Дает true (возвращаемый тип — int*):
	is_pointer_v<decltype(foo(a ,f))>
}
```
>
> [[Реализация свойств типов#Определение составных типов|Детали реализации ...]].

[[is_null_pointer#is_null_pointer<T>|std::is_null_pointer<T>::value]] 
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) [[nullptr_t|std::nullptr_t]], являющийся типом [[nullptr_t#nullptr|nullptr]].
> 
> Например:
```c++
is_null_pointer_v<decltype(nullptr)>            // Дает true
void* р = nullptr;
// Дает false (р не имеет тип std::nullptr_t):
is_null_pointer_v<decltype(р)>
```
>
. В стандарте, начиная с C++14.

[[is_member_object_pointer|std::is_member_object_pointer<T>::value]]
[[is_member_function_pointer|std::is_member_function_pointer<T>:rvalue]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) тип указателя на член (например, `int X::*` или `int (X::*) ()` для некоторого классового типа `X`).

[[is_lvalue_reference|std::is_lvalue_reference<T>::value]]
[[is_rvalue_reference|std::is_rvalue_reference<T>::value]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) тип ссылки на [[r-значение#l-значение|l-значение]] или ссылки на [[r-значение#r-значения|r-значение]] соответственно. Например:
```c++
is_lvalue_reference_v<int>           // Дает false
is_lvalue_reference_v<int&>          // Дает true
is_lvalue_reference_v<int&&>         // Дает false
is_lvalue_reference_v<void>          // Дает false

is_rvalue_reference_v<int>           // Дает false
is_rvalue_reference_v<int&>          // Дает false
is_rvalue_reference_v<int&&>         // Дает true
is_rvalue_reference_v<void>          // Дает false
```
>
> [[Реализация свойств типов#Определение составных типов|Детали реализации ... ]]

[[is_enum#std is_enum|std::is_enum<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) тип перечисления. Применим как к перечислениям с областью видимости, так и к перечислениям без области видимости.
> 
> [[Реализация свойств типов#Обнаружение типов перечислений|Детали реализации приведены тут...]].

[[is_class|std::is_class<T>::value]] 
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) классовый тип, объявленный с использованием ключевого слова `class` или `struct`, включая тип, сгенерированный инстанцированием шаблона класса. Обратите внимание — язык гарантирует, что [[Вывод аргументов шаблона#Обобщенные лямбда-выражения|тип лямбда-выражения представляет собой классовый тип]].
> 
> Дает `false` для объединений, типов перечислений с областью видимости (несмотря на объявление `enum class`), [[nullptr_t|std::nullptr_t]] и любых прочих типов.
> 
> Например:
```c++
is_class_v<int>                        // Дает false
is_class_v<std::string>                // Дает true
is_class_v<std::string const>          // Дает true
is_class_v<std::string&>               // Дает false
auto 11 = [] {};
// Дает true (лямбда-выражение является объектом класса)
is_class_v<decltype(11)>
```
>
> [[Реализация свойств типов#Обнаружение типов классов|Детали реализации рассмотрены тут...]]

[[is_union|std::is_union<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) тип объединения [[union|union]], включая объединение, генерируемое из шаблона класса, который является шаблоном объединения.

[[is_function|std::is_function<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) тип функции. Дает `false` для типа указателя на функцию, типа лямбда-выражения или любого другого типа.
> 
> Помните, что параметр, объявленный как тип функции, по правилам языка в действительности имеет тип указателя.
> 
> Например:
```c++
void foo(void(f)())
{
	// Дает false (f имеет тип void(*)()):
	is_function_v<decltype(f)>
	is_function_v<decltype(foo)>         // Дает true
	is_function_v<decltype(&foo)>        // Дает false
	// Дает false (для возвращаемого типа):
	is_function_v<decltype(foo(f))>
}
```
>
> [[Реализация свойств типов#Идентификация типов функций|Детали реализации приведены тут...]]

## Проверка составных категорий типов

Рассматриваемые далее утилиты позволяют определить, принадлежит ли тип к более широкой категории типов, которая является объединением некоторых основных категорий типов. Составные категории типов не образуют строгого деления: тип может принадлежать к нескольким составным категориям одновременно (например, тип указателя является одновременно и скалярным, и составным). И вновь `cv`-квалификация ([[const|const]] и [[volatile|volatile]]) при классификации типа не учитывается.

Таблица Г.2. Свойства для проверки составных категорий типов

| Свойство                                    | Эффект                                                                                                                                                                   |
| ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [[is_reference\|is reference<T>]]           | Ссылка на [[r-значение#l-значение\|l-значение]] или ссылка на [[r-значение#r-значения\|r-значение]]                                                                      |
| [[is_member_pointer\|is_member_pointer<T>]] | Указатель на нестатический член                                                                                                                                          |
| [[is_arithmetic\|is arithmetic<T>]]         | Целочисленный тип (включая `bool` и символьные типы) или тип с плавающей точкой                                                                                          |
| [[is_fundamental\|is_fundamental]]          | `void`, целочисленный тип (включая `bool` и символьные типы), тип с плавающей точкой или [[nullptr_t#std nullptr_t\|std::nullptr_t]]                                     |
| [[is_scalar\|is_scalar<T>]]                 | Целочисленный тип (включая `bool` и символьные типы), тип с плавающей точкой, перечисление, указатель, указатель на член или [[nullptr_t#std nullptr_t\|std::nullptr_t]] |
| [[is_object\|is_object<T>]]                 | Любой тип, за исключением `void`, функции или ссылки                                                                                                                     |
| [[is_compound\|is_compound<T>]]             | Противоположность [[is_fundamental\|is_fundamental<T>]]: массив, перечисление, объединение, класс, функция, ссылка, указатель или указатель на член                      |

[[is_reference|std::is_reference<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой ссылочный тип.
> 
> Тоже, что и [[is_lvalue_reference|is_lvalue_reference_v<T>]] || [[is_rvalue_reference|is_rvalue_reference_v<T>]].
> 
• [[Реализация свойств типов#Определение составных типов|Детали реализации приведены тут...]]

[[is_member_pointer|std::is_member_pointer<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой любой тип указателя на член.
> 
• То же, что и !([[is_member_object_pointer|is_member_object_pointer_v<T>]] ||[[is_member_function_pointer|s_member_function_pointer_v<T>]]).

[[is_arithmetic|std::is_arithmetic<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой арифметический тип (`bool`, символьный тип, целочисленный тип или тип с плавающей точкой).
> 
> То же, что и [[is_integral|is_integral_v<T>]] II [[is_floating_point|is_floating_point_v<T>]].

[[is_fundamental|std::is fundamental<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой фундаментальный тип (арифметический тип, `void` или [[nullptr_t|std::nullptr_t]]).
> 
> То же, что и [[is_arithmetic|is_arithmetic_v<T>]] | | [[is_void|is_void_v<T>]] | | [[is_null_pointer|is_null_pointer_v<T>]].
> 
> То же, что и [[is_compound|is_compound_v<T>]]
>
> [[Реализация свойств типов#Определение фундаментальных типов|Подробности реализации рассмотрены при разработке шаблона IsFundaT]].

[[is_scalar|std::is_scalar<T>::value]]

> Дает `true`, если тип `Т` представляет собой “скалярный” тип.
>
> Тоже, что и [[is_arithmetic#is_arithmetic_v|is_arithmetic_v<T>]] || [[is_enum#is_enum_v|is_enum_v<T>]] || [[is_pointer#std is_pointer_v|is_pointer_v<T>]] || [[is_member_pointer#is_member_pointer_v|is_member_pointer_v<T>]] || [[is_null_pointer#is_null_pointer_v|is_null_pointer_v<T>]]>.

[[is_object|std::is_object<T>::value]]
>
> Дает `true`, если тип `T` описывает тип объекта.
> 
> То же, что и [[is_scalar#is_scalar_v|is_scalar_v<T>]] || [[is_array#std is_array_v|is_array_v<T>]] || [[is_class#std is_class_v|is_class_v<T>]] || [[is_union#std is_union_v|is_union_v<T>]]).
> 
> Тоже, что и ! ([[is_function#std is_function_v|is_function_v<T>]] || [[is_reference#std is_reference_v|is_reference_v<T>]] || [[is_void#is_void_v|is_void_v<T>]]).

[[is_compound|std::is_compound<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой тип, составленный из других типов.
> 
> То же, что и ! [[is_fundamental#std is_fundamental_v|is_fundamental_v<T>]] 
>
> То же, что и [[is_enum#std is_enum_v|is_enum_v<T>]] || [[is_array#std is_array_v|is_array_v<T>]] || [[is_class#std is_class_v|is_class_v<T>]] || [[is_union#std is_union_v|is_union_v<T>]] || [[is_reference#std is_reference_v|is_reference_v<T>]] || [[is_pointer#std is_pointer_v|is_pointer_v<T>]] || [[is_member_pointer#is_member_pointer_v|is_member_pointer_v<T>]] || [[is_function#std is_function_v|is_function_v<T>]].

# Характеристики и операции над типами

Следующая группа свойств проверяет другие характеристики отдельных типов, а также наличие определенных операций (например, обмен значений), которые могут выполняться с ними.

## Прочие характеристики типов

Таблица Г.З. Свойства, проверяющие простые характеристики типов

| Свойство                                                                          | Эффект                                                                                                                                  |
| --------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| [[is_signed\|is_signed<T>]]                                                       | Знаковый арифметический тип                                                                                                             |
| [[is_unsigned\|is unsigned<T>]]                                                   | Беззнаковый арифметический тип                                                                                                          |
| [[is_const\|is const<T>]]                                                         | [[const\|const]]-квалифицированный тип                                                                                                  |
| [[is_volatile\|is volatile<T>]]                                                   | [[volatile\|volatile]] -квалифицированный тип                                                                                           |
| [[is_aggregate\|is_aggregate<T>]]                                                 | Агрегат (начиная с C++17)                                                                                                               |
| [[is_trivial\|is_trivial<T>]]                                                     | Скаляр, тривиальный класс или массивы этих типов                                                                                        |
| [[is_trivially_copyable\|is_trivially_copyable<T>]]                               | Скаляр, тривиально копируемый класс или массивы этих типов                                                                              |
| [[is_standard_layout\|is_standard_layout<T>]]                                     | Скаляр, класс со стандартной схемой размещения или массивы этих типов                                                                   |
| [[is_pod\|is_pod<T>]]                                                             | Простой старый тип данных (в котором можно копировать объекты с помощью `memcpy()`)                                                     |
| [[is_literal_type\|is_literal_type<T>]]                                           | Скаляр, ссылка, класс или массивы этих типов (не рекомендовано, начиная с C++17)                                                        |
| [[is_empty\|is_empty<T>]]                                                         | Класс без членов, виртуальных функций-членов или виртуальных базовых классов                                                            |
| [[is_polymorphic\|is_polymorphic<T>]]                                             | Класс с (производной) виртуальной функцией-членом                                                                                       |
| [[is_abstract\|is_abstract<T>]]                                                   | Абстрактный класс (как минимум одна чисто виртуальная функция)                                                                          |
| [[is_final\|is_final<T>]]                                                         | Финальный класс (класс, который нельзя наследовать; начиная с С++14)                                                                    |
| [[has_virtual_destructor\|std::has_virtual_destructor<T>]]                        | Класс с виртуальным деструктором                                                                                                        |
| [[has_unique_object_representations\|std::has_unique_object_representations <T>]] | Любые два объекта с одним и тем же значением имеют одинаковое представление в памяти (начиная с C++17)                                  |
| [[alignment_of\|alignment_of<T>]]                                                 | Эквивалентно `alignof (Т)`                                                                                                              |
| [[rank\|rank<T>]]                                                                 | Количество размерностей типа массива (или 0)                                                                                            |
| [[extent\|extent<T, I=0>]]                                                        | Длина по размерности I (или 0)                                                                                                          |
| [[underlying_type\|underlying_type<T>]]                                           | Базовый тип для типа перечисления                                                                                                       |
| [[is_invocable\|is_invocable<T,Args...>]]                                         | Может использоваться как вызываемый объект для `Args...` (начиная с С++17)                                                              |
| [[is_nothrow_invocable\|is_nothrow_invocable <T, Args...>]]                       | Может использоваться как вызываемый объект для `Args...` с гарантией отсутствия исключений<br>(начиная с С++17)                         |
| [[is_invocable#std is_invocable_r\|is_invocable_r <RT, T, Args...>]]              | Может использоваться как вызываемый объект для `Args...`, с возвращаемым типом `RT` (начиная с С++17)                                   |
| [[is_nothrow_invocable\|is_nothrow_invocable_r <RT, T, Args.. .>]]                | Может использоваться как вызываемый объект для `Args...`, с возвращаемым типом `RT` с гарантией отсутствия исключений (начиная с С++17) |
| [[invoke_result\|invoke_result <T, Args...>]]                                     | Возвращаемый тип при использовании в качестве вызываемого объекта для `Args...` (начиная с С++17)                                       |
| [[result_of\|result_of <F, ArgTypes>]]                                            | Возвращаемый тип при вызове `F` с типами аргументов `ArgTypes` (не рекомендовано, начиная с C++17)                                      |

[[is_signed|std::is_signed<T>:rvalue]]
>
> Дает `true`, если `Т` представляет собой знаковый арифметический тип (т.е. арифметический тип, который включает представление отрицательных значений: сюда входят такие типы, как (`signed`) `int`, `float`).
> 
> Для типа `bool` дает `false`.
> 
> Для типа char возвращаемое значение — `true` или `false` — зависит от реализации.
> 
> Для всех неарифметических типов (включая типы [[is_signed|is_signed]] дает `false`.

[[is_unsigned|std::is_unsigned<T>:rvalue]]
>
> Дает `true`, если `T` представляет собой беззнаковый арифметический тип (т.е. арифметический тип, который не включает представление отрицательных значений; сюда входят такие типы, как `unsigned int` и `bool`).
> 
> Для типа `char` возвращаемое значение — `true` или `false` — зависит от реализации.
> 
> Для всех неарифметических типов (включая типы [[is_unsigned|is_unsigned]] дает `false`.

[[is_const|std::is_const<T>::value]]
>
> Дает `true`, если тип квалифицирован как [[const|const]].
> 
> Обратите внимание на то, что константный указатель является [[const|const]]-квалифицированным типом, в то время как неконстантный указатель (или ссылка на константный тип) не является [[const|const]]-квалифицированным типом. Например:
```c++
is_const<int* const>::value // true
is_const<int const*>::value // false
is_const<int const&>::value // false
```
>
> Язык определяет массивы как [[const|const]]-квалифицированные, если тип элемента является [[const|const]]-квалифицированным. Например:
```c++
is_const<int[3]>::value            // false
is_const<int const[3]>::value      // true
is_const<int[]>::value             // false
is_const<int const[]>::value       // true
```

[[is_volatile|std::is_volatile<T>::value]]
>
> Дает true, если тип [[volatile|volatile]]-квалифицирован.
> 
> Обратите внимание на то, что [[volatile|volatile]]-указатель имеет [[volatile|volatile]]- квалифицированный тип, в то время как указатель или ссылка на [[volatile|volatile]] тип, но сами не являющиеся [[volatile|volatile]], не являются [[volatile|volatile]]- квалифицированными. Например:
```c++
is_volatile<int* volatile>::value // true
is_volatile<int volatile*>::value // false
is_volatile<int volatile&>::value // false
```
>
> Язык определяет массив как [[volatile|volatile]]-квалифицированный, если тип элементов является [[volatile|volatile]]-квалифицированным. Например:
```c++
is_volatile<int[3]>::value                 // false
is_volatile<int volatile[3]>::value        // true
is_volatile<int[]>::value                  // false
is_volatile<int volatile[]>::value         // true
```

[[is_aggregate|std::is_aggregate<T>::value]]
>
> Дает `true`, если `T` является агрегатным типом (массив либо класс/структура/объединение, у которого нет пользовательского, явного или унаследованного конструктора, нет закрытых или защищенных нестатических членов-данных, нет виртуальных функций, а также нет виртуальных, закрытых или защищенных базовых классов).
> 
> Помогает выяснить, требуется ли список инициализации. Например:
```c++
template<typename Coll, typename... Т>
void insert(Coll& coll, T&& ... val)
{
	if constexpr(!std::is_aggregate_v<typename Coll::value_type>)
	{
		// Для агрегатов не годится:
		coll.emplace_back(std::forward<T>(val)...);
	}
	else
	{
		coll.emplace_back(typename
			Coll::value__type{std::forward<T>(val)...});
	}
}
```
>
> Требует, чтобы данный тип либо [[Основные термины в области шаблонов#Полные и неполные типы|был полным]] либо (`cv`- квалифицированным) `void`.
> 
> Доступно, начиная с C++17.

[[is_trivial|std::is_trivial<T>::value]]
>
> Дает `true`, если тип является “тривиальным” типом:
> > скалярный тип (целочисленный, с плавающей точкой, перечисление, указатель; см. выше свойство [[is_scalar|is_scalar()]] );
> > 
> > тип тривиального класса (класс, не имеющий виртуальных функций, виртуальных базовых классов, (косвенных) пользовательских конструкторов по умолчанию, копирующих/перемещающих конструкторов, копирующих/перемещающих операторов присваивания или деструкторов, инициализаторов для нестатических членов-данных, членов, объявленных как [[volatile|volatile]], а также нетривиальных членов);
> > 
> > массив таких типов;
> > 
> > а также `cv`-квалифицированные версии этих типов.­
> >
> Дает `true`, если [[is_trivially_copyable|is_trivially_copyable_v<T>]] дает `true`, и существует тривиальный конструктор по умолчанию.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], либо (`cv`- квалифицированным) `void`.

[[is_trivially_copyable|std::is_trivially_copyable<T>:rvalue]]
>
> Дает `true`, если тип является “тривиально копируемым” типом:
> >
> > скалярный тип (целочисленный, с плавающей точкой, перечисление, указатель; см. выше свойство [[is_scalar|is_scalar()]] );
> > 
> > тип тривиального класса (класс, не имеющий виртуальных функций, виртуальных базовых классов, (косвенных) пользовательских конструкторов по умолчанию, копирующих/перемещающих конструкторов, копирующих/перемещающих операторов присваивания или деструкторов, инициализаторов для нестатических членов-данных, членов, объявленных как [[volatile|volatile]], а также нетривиальных членов);
> > 
> > массив таких типов;
> > 
> > а также `cv`-квалифицированные версии этих типов.
> >
> Дает то же значение, что и [[is_trivial|is_trivial_v<Т>]], за исключением того, что может дать `true` для типа класса без тривиального конструктора по умолчанию.
> 
> В отличие от [[is_standard_layout|is_standard_layout<>]], [[volatile|volatile]]-члены не допускаются, ссылки разрешены, члены могут иметь различный доступ, а также члены могут быть распределены среди различных (базовых) классов.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], либо (`cv`- квалифицированным) `void`.

[[is_standard_layout|std::is_standard_layout<T>:rvalue]]
>
> Дает `true`, если тип имеет стандартную схему размещения, что, например,упрощает обмен значений данного типа с другими языками:
> > скалярный тип (целочисленный, с плавающей точкой, перечисление, указатель; см. выше свойство [[is_scalar|is_scalar()]] );
> > 
> > тип со стандартной схемой размещения (класс, не имеющий виртуальных функций, виртуальных базовых классов, нестатических членов-ссылок, все нестатические члены находятся в одном и том же (базовом) классе, определенном с тем же доступом, все члены также являются типами со стандартной схемой размещения);
> > 
> > массив таких типов;
> > 
> > а также `cv`-квалифицированные версии этих типов.
> >
> В отличие от [[is_trivial|is_trivial<>]], [[volatile|volatile]]-члены разрешены, ссылки не разрешены, члены не могут иметь различный доступ, а также члены не могут быть распределены среди различных (базовых) классов.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип (для массивов — базовый тип) либо был полным]], либо (`cv`-квалифицированным) `void`.

[[is_pod|std::is_pod<T>::value]]
>
> Дает `true`, если `T` представляет собой простой старый тип данных (plain old datatype — POD).
> 
> Объекты таких типов могут копироваться путем копирования их памяти (например с помощью `memcpy()` ).
> 
> То же, что и [[is_trivial|is_trivial_t<T>]] && [[is_standard_layout|is_standard_layout_v<T>]].
>
> Дает `false` для:
> > 
> > классов, не имеющих тривиального конструктора по умолчанию, копирующего/перемещающего конструктора, копирующего/перемещающего присваивания или деструктора;
> > 
> > классов, имеющих виртуальные члены или виртуальные базовые классы;
> > 
> > классов, имеющих [[volatile|volatile]]-члены или члены-ссылки;
> > 
> > классов, которые имеют члены в различных (базовых) классах или с различным доступом;
> > 
> > типов лямбда-выражений (именуемых типами замыканий);
> > 
> > функций;
> > 
> > void;
> > 
> > типов, составленных из перечисленных выше типов.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], либо (`cv`- квалифицированным) `void`.

[[is_literal_type|std::is_literal_type<T>:rvalue]]
>
> Дает `true`, если данный тип является корректным возвращаемым типом для [[constexpr|constexpr]]-функции (что в особенности исключает любой тип, требующий нетривиального уничтожения).
> 
> Дает `true`, если `T` является литеральным типом:
> >
> > скалярный тип (целочисленный, с плавающей точкой, перечисление, указатель; см. выше свойство [[is_scalar|is_scalar()]]);
> > 
> > ссылка;
> > 
> > тип класса с по меньшей мере одним [[constexpr|constexpr]]-конструктором, который не является копирующим/перемещающим конструктором, в каждом базовом классе, не имеющем пользовательского или виртуального деструктора в любом (базовом) классе или члене, и в котором каждая инициализация нестатического члена-данного является константным выражением;
> > 
> > массив таких типов.
>
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], либо (`cv`- квалифицированным) `void`.
>
> Обратите внимание на то, что, начиная со стандарта C++17, это свойство не рекомендуется к употреблению, поскольку “оно слишком слабое, чтобы содержательно использовать его в обобщенном коде. Что действительно необходимо — это возможность знать, что конкретное конструирование будет приводить к константной инициализации".

[[is_empty|std::is_empty<T>::value]]
>
> Дает `true`, если тип `Т` является типом класса (но не объединения), объекты которого не содержат данных.
> 
> Дает `true`, если `Т` определен как `class` или `struct`, у которого
> >
> > - нет нестатических членов-данных, отличных от битовых полей нулевой длины;
> > - 
> > нет виртуальных функций-членов;
> > 
> > нет виртуальных базовых классов;
> > 
> > нет непустых базовых классов.
>
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], если это `class/struct` (неполный [[union|union]] разрешен).

[[is_polymorphic|std::is_polymorphic<T>::value]]
>
> Дает `true`, если `Т` представляет собой полиморфный тип класса (класс, объявляющий или наследующий виртуальную функцию).
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], либо не был ни` class`, ни `struct`.

[[is_abstract|std::is_abstract<T>::value]]
>
> Дает `true`, если `T` представляет собой абстрактный тип класса (класс, для которого не может быть создан ни один объект, так как он имеет по крайней мере одну чисто виртуальную функцию-член).
>
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], если это `class/struct` (неполный [[union|union]] разрешен).

[[is_final|std::is_final<T>::value]]
>
> Дает `true`, если `Т` — окончательный (`final`) тип класса (класс или объединение, который не может быть использован в качестве базового, так как объявлен как [[final|final]]).
> 
> Для всех типов, не являющихся классами/объединениями, такими как `int`, возвращает `false` (т.е. это не то же, как нечто наподобие `может быть наследован`).
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], либо не был `class/struct` или [[union|union]].
> 
> Доступно, начиная со стандарта C++14.

[[has_virtual_destructor|std::has_virtual_destructor<T>::value]]
>
> Дает `true`, если тип `Т` имеет виртуальный деструктор.
>
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], если это `class/struct` (неполный [[union|union]] разрешен).

[[has_unique_object_representations|std::has_unique_object_representations<T>::value]]
>
> Дает `true`, если любые два объекта типа `Т` имеют одинаковое представление объектов в памяти. Следовательно, два идентичных значения всегда представлены с использованием одинаковых последовательностей значений байтов.
> 
> Объекты с таким свойством могут производить надежное хеш-значение путем хеширования связанной с ними последовательности байтов (отсутствует риск, что некоторые биты, не участвующие в значении объекта, могут отличаться от одного объекта к другому).
> 
> Требует, чтобы данный тип был [[Стандартные утилиты для работы с типами#Прочие характеристики типов|тривиально копируемым]] и либо [[Основные термины в области шаблонов#Полные и неполные типы|полным]], либо (`cv`-квалифицированным) `void` или массивом с неизвестными границами.
> 
> Доступно, начиная со стандарта C++17.

[[alignment_of|std::alignment_of<T>::value]] 
>
> Дает выравнивание объекта типа `Т` как значение типа [[size#std size_t|std::size_t]] (для массивов — типа элемента; для ссылок — типа, на который выполняется ссылка).
>
> То же, что и [[alignof|alignof(Т)]].
> 
> Это свойство было введено в С++11 до конструкции `alignof (...)`. Однако оно все еще востребовано, поскольку свойство может быть передано как тип класса, что может быть полезным для некоторых метапрограмм.
> 
> Требует, чтобы [[alignof|alignof (Т)]] было корректным выражением.
> 
> Используйте `aligned_union<>` для получения общего выравнивания нескольких типов.

[[rank|std::rank<T>::value]]
>
> Дает количество размерностей массива типа `Т` в виде значения типа [[size#std size_t|std::size_t]].
> 
> Дает `0` для всех прочих типов.
> 
> Указатели не имеют связанных с ними размерностей. Неопределенная граница в типе массива указывает размерность. (Как обычно, параметр функции, объявленный как тип массива, в действительности не имеет типа массива, так же как и тип [[Array|std::array]] не является типом массива). Например:
```c++
int а2[5][7];
rank_v<decltype(а2)>; // Дает 2
rank_v<int*>;         // Дает 0 (no array)
extern int p1[];
rank_v<decltype(pi)>; // Дает 1
```

[[extent|std::extent<T>::value]]
[[extent|std::extent<T, IDX>::value]]

> Дает размер первой или `IDX`-й размерности массива типа `Т` в виде значения типа [[size#std size_t|std::size_t]].

> Дает `0`, если `Т` не является массивом, размерность не существует, или размер данной размерности неизвестен.
> 
> [[Реализация свойств типов#Определение составных типов|Подробности реализации]].
```c++
int а2[5][7];
extent_v<decltype(a2)>;          // Дает 5
extent_v<decltype(a2), 0>;       // Дает 5
extent_v<decltype(a2), 1>;       // Дает 7
extent_v<decltype(a2), 2>;       // Дает 0
extent_v<int*>;                  // Дает 0
extern int p1[];
extent v<decltype(p1)>;          // Дает 0
```

[[underlying_type|std: : underlying_type<T>::type]]
>
> Дает базовый тип для типа перечисления `Т`.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был полным типом]] перечисления. Для всех прочих типов имеет неопределенное поведение.

[[is_invocable|std::is_invocable<T, Args...>::value]]
[[is_nothrow_invocable|std::is_nothrow_invocable<T, Args...>::value]]
>
> Дает `true`, если `T` можно использовать для вызова с аргументами `Args...` (с гарантией отсутствия исключений).
> 
> Таким образом, мы можем использовать эти свойства, чтобы проверить, можем ли мы использовать вызов или [[invoke|std::invoke ()]] для данного вызываемого типа `Т` для аргументов `Args....` (Подробная информация о [[Обобщенные библиотеки - template#Вызываемые объекты|вызываемых объектах и std::invoke ()]])
> 
> Требует, чтобы все указанные [[Основные термины в области шаблонов#Полные и неполные типы|типы были полными]] или (`cv`-квалифицированным) `void`, или массивом с неизвестными границами. 
> 
> Например:
```c++
struct С
{
	bool operator()(int) const
	{
		return true;
	}
};

std::is_invocable<C>::value              // false
std::is_invocable<C, int>::value         // true
std::is_invocable<int*>::value           // false
std::is_invocable<int(*)()>::value       // true
```
>
> Доступно, начиная co стандарта C++17

[[is_invocable|std::is_invocable_r<RET_T, Т, Args...>::value]]
[[is_nothrow_invocable|std::is_nothrow_invocable_r<RET_T, T, Args...>::value]]
>
> Дает `true`, если `T` можно использовать для вызова с аргументами `Args...` (с гарантией отсутствия исключений) и возвращаемым значением, преобразуемым к типу `RET_T`.
> 
> Таким образом, эти свойства позволяют проверить, можем ли мы использовать вызов или [[invoke|std::invoke()]] для данного вызываемого типа `Т` для аргументов `Args...` и применить возвращаемое значение как `RET_T`. (Подробная информация о [[Обобщенные библиотеки - template#Вызываемые объекты|вызываемых объектах и std::invoke ()]])
> 
> Требует, чтобы все указанные [[Основные термины в области шаблонов#Полные и неполные типы|типы были полными]] или (`cv`-квалифицированным) `void`, или массивом с неизвестными границами.
> 
> Например:
```c++
struct С
{
	bool operator () (int) const
	{
		return true;
	}
};

std::is_invocable_r<bool, C, int>::value                  // true
std::is_invocable_r<int, C, long>::value                  // true
std::is_invocable_r<void, C, int>::value                  // true
std::is_invocable_r<char* , C, int>::value                // false
std::is_invocable_r<long, int(*)(int)>::value             // false
std::is_invocable_r<long, int (*) (int), int>::value      // true
std::is_invocable_r<long, int(*Hint), double>::value      // true
```
>
> Доступно, начиная co стандарта C++17.

[[invoke_result|std::invoke_result<T, Args...>::value]]
[[result_of|std::result_of<T, Args...>::value]]
>
> Дает возвращаемый тип вызываемого типа `Т`, вызванного с аргументами `Args...`.
>
> Обратите внимание на небольшие отличия в синтаксисе:
> >
> > В [[invoke_result|invoke_result<>]] вы должны передать в качестве параметров как вызываемый тип, так и типы аргументов.
> > 
> > В [[result_of|result_of<>]] вы должны передать “объявление функции” с использованием соответствующих типов.
>
> Если вызов невозможен, член `type` не определен, так что его использование является ошибкой (это позволяет использовать [[SFINAE#SFINAE|принцип SFINAE для отбрасывания шаблона функции с помощью использования свойства в ее объявлении]]).
> 
> Таким образом, мы можем использовать эти свойства для получения возвращаемого типа при использовании вызова или [[invoke|std::invoke()]] для данного вызываемого типа `Т` для аргументов `Args....` ([[Обобщенные библиотеки - template#Вызываемые объекты|Подробная информация о вызываемых объектах и std::invoke()]])
> 
> Требует, чтобы все указанные [[Основные термины в области шаблонов#Полные и неполные типы|типы были полными]] или (`cv`-квалифицированным) `void`, или массивом с неизвестными границами.
> 
> Свойство [[invoke_result|invoke_result<>]] доступно, начиная с С++17, и заменяет свойство [[result_of|result_of<>]], которое не рекомендовано к употреблению, начиная с С++17, поскольку [[invoke_result|invoke_result<>]] предоставляет определенные улучшения, такие как более простой синтаксис и разрешение `Т` быть абстрактным типом.
> 
> Например:
```c++
std::string foo(int);
using R0 = typename
			std::result_of<decltype(&foo)(int)>::type; // C++11
using R1 = std::result_of_t<decltype(&foo)(int)>;      // C++14
using R2 = std::invoke_result_t<decltype(foo), int>;   // C++17 

struct ABC
{
	virtual ~ABC() = 0;
	void operator()(int) const
	{
	}
	
	using T1 = typename
			std::result_of<ABC(int)>::type; // Ошибка: ABC - абстрактный
	using T2 = typename
			std::invoke_result<ABC,int>::type; // OK, начиная с C++17
```

[[Обобщенные библиотеки - template#Оборачивание вызовов функций|Полный пример...]]

Таблица Г.4. Свойства для проверки определенных операций

| Свойства                                                                       | Эффект                                                                                                                                         |
| ------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| [[is_constructible\|is constructible <T,Args...>]]                             | Можно инициализировать тип `Т` типами `Args`                                                                                                   |
| [[is_trivially_constructible\|is_trivially_constructible<T,Args...>]]          | Можно тривиально инициализировать тип `Т` типами Args                                                                                          |
| [[is_nothrow_constructible\|is_nothrow_constructible <T,Args...>]]             | Можно инициализировать тип `Т` типами `Args`, и эта операция не генерирует исключений                                                          |
| [[is_default_constructible\|is_default_constructible <T>]]                     | Можно инициализировать тип `Т` без аргументов                                                                                                  |
| [[is_trivially_default_constructible\|is_trivially_default_constructible <T>]] | Можно тривиально инициализировать тип `Т` без аргументов                                                                                       |
| [[is_nothrow_default_constructible\|is_nothrow_default_constructible <T>]]     | Можно инициализировать тип `Т` без аргументов, и эта операция не генерирует исключений                                                         |
| [[is_copy_constructible\|is_copy_constructible <T>]]                           | Тип `Т` можно копировать                                                                                                                       |
| [[is_trivially_copy_constructible\|is_trivially_copy_constructible <T>]]       | Тип `Т` можно тривиально копировать                                                                                                            |
| [[is_nothrow_copy_constructible\|is_nothrow_copy_constructible ]]              | Тип `Т` можно копировать, и эта операция не генерирует исключений                                                                              |
| [[is_move_constructible\|is_move_constructible <T>]]                           | Тип `T` можно перемещать                                                                                                                       |
| [[is_trivially_move_constructible\|is_trivially_move_constructible <T>]]       | Тип `Т` можно тривиально перемещать                                                                                                            |
| [[is_nothrow_move_constructible\|is_nothrow_move_constructible <T>]]           | Тип `Т` можно перемещать, и эта операция не генерирует исключений                                                                              |
| [[is_assignable\|is_assignable <T, T2>]]                                       | Можно присваивать тип `Т2` типу `Т`                                                                                                            |
| [[is_trivially_assignable\|is_trivially_assignable <T, T2>]]                   | Можно тривиально присваивать тип `Т2` типу `Т`                                                                                                 |
| [[is_nothrow_assignable\|is_nothrow_assignable <T, T2>]]                       | Можно присваивать тип `Т2` типу `Т`, и эта операция не генерирует исключений                                                                   |
| `[[is_copy_assignable\|is_copy_assignable <T>]]                                | Можно выполнять копирующее присваивание `Т`                                                                                                    |
| [[is_trivially_copy_assignable\|is_trivially_copy_assignable <T>]]             | Можно выполнять тривиальное копирующее присваивание `Т`                                                                                        |
| [[is_nothrow_copy_assignable]]                                                 | Можно выполнять копирующее присваивание `Т`, и эта операция не генерирует исключений                                                           |
| [[is_move_assignable\|is_move_assignable <T>]]                                 | Можно выполнять перемещающее присваивание `Т`                                                                                                  |
| [[is_trivially_move_assignable\|is_trivially_move_assignable <T>]]             | Можно выполнять тривиальное перемещающее присваивание `Т`                                                                                      |
| [[is_nothrow_move_assignable\|is_nothrow_move_assignable <T>]]                 | Можно выполнять перемещающее присваивание `Т`, и эта операция не генерирует исключений                                                         |
| [[is_destructible\|is destructible<T>]]                                        | Можно уничтожать `Т`                                                                                                                           |
| [[is_trivially_destructible\|is_trivially_destructible <T>]]                   | Можно тривиально уничтожать `Т`                                                                                                                |
| [[is_nothrow_destructible\|is_nothrow_destructible <T>]]                       | Можно уничтожать `Т`, и эта операция не генерирует исключений                                                                                  |
| [[is_swappable\|is_swappable <T>]]                                             | Для этого типа можно вызывать [[swap\|swap()]] (начиная с С++17)                                                                               |
| [[is_nothrow_swappable\|is_nothrow_swappable <T>]]                             | Для этого типа можно вызывать [[swap\|swap()]], и эта операция не генерирует исключений (начиная с С++17)                                      |
| [[is_swappable_with\|is_swappable_with <T, T2>]]                               | Для этих двух типов с указанной категорией значений можно вызывать [[swap\|swap()]] (начиная с С++17)                                          |
| [[is_nothrow_swappable_with\|is_nothrow_swappable_with <T, T2>]]               | Для этих двух типов с указанной категорией значений можно вызывать [[swap\|swap()]], и эта операция не генерирует исключений (начиная с C++17) |

В таблице Г.4 перечислены свойства типов, которые позволяют нам проверять некоторые определенные операции. Формы с `is_trivially_...` дополнительно проверяют, все ли (суб)операции, вызываемые для объекта, членов или базовых классов, являются тривиальными (не определяемыми пользователем и не виртуальными). Формы с `is_nothrow_...` дополнительно проверяют, гарантируется ли отсутствие генерации исключений данной операцией. Обратите внимание на то, что все проверки `is_..._constructible` неявно выполняют соответствующие проверки `is_..._destructible`. Например:
```c++
#include <iostream>

class С
{
	public:
		С()            // Конструктор по умолчанию не имеет noexcept
		{
		}
		
		virtual ~C () = default; // Делает тип С нетривиальным
};

int main()
{
	using namespace std;
	cout << is_default_constructible_v<C> << '\n';             // true
	cout << is_trivially_default_constructible_v<C> << ' \n';  // false
	cout << is_nothrow_default_constructible_v<C> << '\n';     // false
	cout << is_copy_constructible_v<C> << '\n';                // true
	cout << is_trivially_copy_constructible_v<C> << '\n';      // true
	cout << is_nothrow_copy_constructible_v<C> << ' \n';       // true
	cout << is_destructible_v<C> << '\n';                      // true
	cout << is_trivially_destructible_v<C> << '\n';            // false
	cout << is_nothrow_destructible_v<C> << '\n';              // true
}
```

Из-за определения деструктора как виртуального все операции больше не являются тривиальными. А поскольку мы определяем конструктор по умолчанию без [[noexcept|noexcept]], он может генерировать исключения. Все другие операции по умолчанию гарантируют отсутствие исключений.

[[is_constructible|std::is_constructible<T, Args...>::value]]
[[is_trivially_constructible|std::is_trivially_constructible<T, Args...>::value]]
[[is_nothrow_constructible|std::is_nothrow_constructible<T, Args...>::value]]
>
> Дает `true`, если объект типа `T` может быть инициализирован аргументами типов, задаваемых `Args...` (без использования нетривиальной операции или с гарантией отсутствия генерации исключений). Таким образом, следующий код должен быть корректен:
```c++
Т t(std::declval<Args>()...);
```
>
> Значение `true` подразумевает, что объект может быть соответствующим образом уничтожен (т.е.[[is_destructible| is_destructible_v<T>]], [[is_trivially_destructible|is_trivially_destructible_v<T>]] или соответственно [[is_nothrow_destructible|is_nothrow_destructible_v<T>]] дадут `true`).
> 
> Требует, чтобы все данные [[Основные термины в области шаблонов#Полные и неполные типы|типы были либо полными]], (`cv`-квалифицированным) `void`, либо массивами с неизвестными границами.
> 
> Например:
```c++
is_constructible_v<int>                                // true
is_constructible_v<int, int>                           // true
is_constructible_v<long, int>                          // true
is_constructible_v<int, void*>                         // false
is_constructible_v<void*, int>                         // false
is_constructible_v<char const*, std::string>           // false
is_constructible_v<std::string, char const*>           // true
is_constructible_v<std::string, char const*, int, int> // true
```

Обратите внимание на то, что [[is_convertible|is_convertible]] имеет иной порядок исходного и целевого типов.

[[is_default_constructible|std::is_default_constructible<T>::value]]
[[is_trivially_default_constructible|std::is_trivially_default_constructible<T>::value]]
[[is_nothrow_default_constructible|std::is_nothrow_default_constructible<T>::value]]
>
> Дает `true`, если объект типа `T` может быть инициализирован без аргументов инициализации (без использования нетривиальной операции или с гарантией отсутствия генерации исключений).
> 
> То же, что и [[is_constructible|is_constructible_v<T>]], [[is_trivially_constructible|is_trivially_constructible_v<T>]] или [[is_nothrow_constructible|is_nothrow_constructible_v<T>]] соответственно.
> 
> Значение `true` подразумевает, что объект может быть соответствующим образом уничтожен (т.е. [[is_destructible|is_destructible_v<T>]], [[is_trivially_destructible|is_trivially_destructible_v<T>]] или соответственно [[is_nothrow_destructible|is_nothrow_destructible_v<T>]] дает `true`).
>
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был либо полным]], (`cv`- квалифицированным) `void` или массивом с неизвестными границами.

[[is_copy_constructible|std::is_copy_constructible<T>::value]]
[[is_trivially_copy_constructible|std::is_trivially_copy_constructible<T>::value]]
[[is_nothrow_copy_constructible|std::is_nothrow_copy_constructible<T>::value]]
>
> Дает `true`, если объект типа `T` может быть создан путем копирования другого значения типа `Т` (без использования нетривиальной операции или с гарантией отсутствия генерации исключений).
> 
> Дает `false`, если `Т` не является типом, на который можно ссылаться (`referenceable type`) ((`cv`-квалифицированный) `void` или тип функции, квалифицированный с помощью [[const|const]], [[volatile|volatile]], `&`, `&&`).
> 
> Указывает, является ли тип `Т` типом, накоторый можно ссылаться, так же как и [[is_constructible|is_constructible<T, T const&>::value]], [[is_trivially_constructible|is_trivially_constructible<Т, Т const &>::value]] или [[is_nothrow_constructible|is_nothrow_constructible<T, Т const &>::value]] соответственно.
>
> Чтобы выяснить, может ли объект типа `Т` быть сконструирован копированием [[r-значение#r-значения|r-значения]] типа `Т`, используйте [[is_constructible|is_constructible<T, Т &&>]] (и т.д.).
> 
> Значение `true` подразумевает, что объект может быть соответствующим образом уничтожен (т.е. [[is_destructible|is_destructible_v<T>]], [[is_trivially_destructible|is_trivially_destructible_v<T>]] или соответственно [[is_nothrow_destructible|is_nothrow_destructible_v<T>]] дает `true`).
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был полным]], (`cv`-квалифицированным) `void` либо массивом с неизвестной границей.
> 
> Например:
```c++
is_copy_constructible_v<int>                          // true
is_copy_constructible_v<void>                         // false
is_copy_constructible_v<std::unique_ptr<int>>         // false
is_copy_constructible_v<std::string>                  // true
is_copy_constructible_v<std::string&>                 // true
is_copy_constructible_v<std::string&&>                // false

// В отличие от:
is_constructible_v<std::string, std::string>          // true
is_constructible_v<std::string&, std::string&>        // true
is_constructible_v<std::string&&, std::string&&>      // true
```

[[is_move_constructible|std::is_move_constructible<T>::value]]
[[is_trivially_move_constructible|std::is_trivially_move_constructible<T>::value]]
[[is_nothrow_move_constructible|std::is_nothrow_move_constructible<T>::value]]
>
> Дает `true`, если объект типа `T` может быть создан из [[r-значение#r-значения|r-значения]] типа `Т` (без использования нетривиальной операции или с гарантией отсутствия генерации исключений).
> 
> Дает `false`, если `Т` не является типом, на который можно ссылаться (`referenceable type`) ((`cv`-квалифицированный) `void` или тип функции, квалифицированный с помощью [[const|const]], [[volatile|volatile]], `&`, `&&`).
> 
> Указывает, является ли тип `T` типом, на который можно ссылаться, так же как и [[is_constructible|is_constructible<T, Т&&>::value]], [[is_trivially_constructible|is_trivially_constructible<Т,&&>::value]] или [[is_nothrow_constructible|is_nothrow_constructible<T,&&>::value]] соответственно.
> 
> Значение `true` подразумевает, что объект может быть соответствующим образом уничтожен (т.е. [[is_destructible|is_destructible_v<T>]], [[is_trivially_destructible|is_trivially_destructible_v<T>]] или соответственно [[is_nothrow_destructible|is_nothrow_destructible_v<T>]] дает `true`).
> 
> Заметьте, что нет никакого способа проверить, не генерируется ли исключение перемещающим конструктором без возможности вызова его непосредственно для объекта типа `Т`. Для конструктора недостаточно быть открытым и не удаленным; он также требует, чтобы соответствующий тип не являлся абстрактным классом (ссылки или указатели на абстрактные классы работают корректно).
> 
> [[Реализация свойств типов#Обнаружение операций, не генерирующих исключения|Подробности реализации]].
> 
> Например:
```c++
is_move_constructible_v<int>                        // true
is_move__constructible_v<void>                      // false
is_move_constructible_v<std::unique_ptr<int>>       // true
is_move_constructible_v<std::string>                // true
is_move_constructible_v<std::string&>               // true
is_move_constructible_v<std::string&&>              // true

// В отличие от:
is_constructible_v<std::string, std::string>        // true
is_constructible_v<std::string&, std::string&>      // true
is_constructible_v<std::string&&,std::string&&>     // true
```

[[is_assignable|std::is_assignable<TO, FROM>::value]]
[[is_trivially_assignable|std::is_trivially_assignable<TO, FROM>::value]]
[[is_nothrow_assignable|std::is_nothrow_assignable<TO, FROM>::value]]
>
> Дает `true`, если объект типа `FROM` может быть присвоен объекту типа `ТО` (без использования нетривиальной операции или с гарантией отсутствия генерации исключений).
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был полным]], (`cv`-квалифицированным) `void`, или же массивом с неизвестной границей.
> 
> Обратите внимание на то, что [[is_assignable|is_assignable_v<>]] для первого типа, не являющегося ссылкой или классом, всегда дает `false`, поскольку такие типы производят [[r-значение#pr-значения|pr-значения]]. Таким образом, инструкция `42=77`; является некорректной. Однако для типов классов возможно присваивание [[r-значение|r-значениям]] при наличии соответствующего оператора присваивания (благодаря старому правилу о том, что неконстантные функции-члены могут вызываться для [[r-значение|г-значений]] типов классов).
> 
> Обратите внимание: [[is_convertible|is_convertible]] имеет иной порядок исходного и целевого типов.
> 
> Например:
```c++
is_assignable_v<int, int>                               // false
is_assignable_v<int&, int>                              // true
is_assignable_v<int&&, int>                             // false
is_assignable_v<int&, int&>                             // true
is_assignable_v<int&&, int&&>                           // false
is_assignable_v<int&, long&>                            // true
is_assignable_v<int&, void*>                            // false
is_assignable_v<void*, int>                             // false
is_assignable_v<void*, int&>                            // false
is_assignable_v<std::string, std::string>               // true
is_assignable_v<std::string&, std::string&>             // true
is_assignable_v<std::string&&, std::string&&>           // true
```

[[is_copy_assignable|std::is_copy_assignable<T>::value]]
[[is_trivially_copy_assignable|std::is_trivially_copy_assignable<T>::value]]
[[is_nothrow_copy_assignable|std::is_nothrow_copy_assignable<T>::value]]
>
> Дает `true`, если значение типа `T` может быть присвоено (с копированием) объекту типа `Т` (без использования нетривиальной операции или с гарантией отсутствия генерации исключений).
> 
> Дает `false`, если `Т` не является типом, на который можно ссылаться (`referenceable type`) ((`cv`-квалифицированный) `void` или тип функции, квалифицированный с помощью [[const|const]], [[volatile|volatile]], `&`, `&&`).
> 
> Указывает, является ли тип `Т` типом, на который можно ссылаться, так же как и [[is_assignable|is_assignable<T&, Т const &>::value]], [[is_trivially_assignable|is_trivially_assignable<T&,T const&>::value]] или соответственно [[is_nothrow_assignable|is_nothrow_assignable<T&, T const&>::value]].
> 
> Чтобы выяснить, можно ли [[r-значение#r-значения|r-значение]] типа `Т` присвоить копированием другому [[r-значение#r-значения|r-значению]] типа `Т`, используйте [[is_assignable|is_assignable<T&&, Т&&>]] и т.д.
> 
> Обратите внимание на то, что копирующее присваивание неприменимо для типов `void`, встроенных типов массивов и классов с удаленным оператором копирующего присваивания.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был полным]], (`cv`-квалифицированным) `void` или массивом с неизвестной границей.
> 
> Например:
```c++
is_copy_assignable_v<int>                              // true
is_copy_assignable_v<int&>                             // true
is_copy_assignable_v<int&&>                            // true
is_copy_assignable_v<void>                             // false
is_copy_assignable_v<void*>                            // true
is_copy_assignable_v<char[]>                           // false
is_copy_assignable_v<std::string>                      // true
is_copy_assignable_v<std::unique_ptr<int>>             // false
```

[[is_move_assignable|std::is_move_assignable<T>::value]]
[[is_trivially_move_assignable|std::is_trivially_move_assignable<T>::value]]
[[is_nothrow_move_assignable|std::is_nothrow_move_assignable<T>::value]]
>
> Дает `true`, если [[r-значение#r-значения|r-значение]] типа `T` может быть присвоено перемещением объекту типа `Т` (без использования нетривиальной операции или с гарантией отсутствия генерации исключений).
> 
> Дает `false`, если `Т` не является типом, на который можно ссылаться (`referenceable type`) ((`cv`-квалифицированный) `void` или тип функции, квалифицированный с помощью `const`, `volatile`, `&`, `&&`).
>
> Указывает, является ли тип `Т` типом, на который можно ссылаться, так же как и [[is_assignable|is_assignable<T&, Т const&>::value]], [[is_trivially_assignable|is_trivially_assignable<T&,T const&>::value]] или соответственно [[is_nothrow_assignable|is_nothrow_assignable<T&, T const&>::value]].
>
> Обратите внимание на то, что перемещающее присваивание неприменимо для типов `void`, встроенных типов массивов и классов с удаленным оператором перемещающего присваивания.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был полным]], (`cv`-квалифицированным) `void` или массивом с неизвестной границей.
> 
> Например:
```c++
is_move_assignable_v<int>                        // true
is_move_assignable_v<int&>                       // true
is_move_assignable_v<int&&>                      // true
is_move_assignable_v<void>                       // false
is_move_assignable_v<void*>                      // true
is_move_assignable_v<char[]>                     // false
is_move_assignable_v<std::string>                // true
is_move_assignable_v<std::unique_ptr<int>>       // true
```

[[is_destructible|std::is_destructible<T>::value]]
[[is_trivially_destructible|std::is_trivially_destructible<T>::value]]
[[is_nothrow_destructible|std::is_nothrow_destructible<T>::value]]
>
> Дает `true`, если объект типа `T` может быть уничтожен (без использования нетривиальной операции или с гарантией отсутствия генерации исключений).
> 
> Всегда дает `true` для ссылок.
> 
> Всегда дает `false` для `void`, типов массивов с неизвестными границами и типов функций.
> 
> [[is_trivially_destructible|is_trivially_destructible]] дает `true`, если никакой из деструкторов `Т`, любого базового класса или любого нестатического члена-данного не является пользовательским или виртуальным.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был полным]], (`cv`-квалифицированным) `void` или массивом с неизвестной границей.
> 
> Например:
```c++
is_destructible_v<void>                                        // false
is_destructible_v<int>                                         // true
is_destructible_v<std::string>                                 // true
is_destructible_v<std::pair<int,std::string>>                  // true
is_trivially_destructible_v<void>                              // false
is_trivially_destructible_v<int>                               // true
is_trivially_destructible_v<std::string>                       // false
is_trivially_destructible_v<std::pair<int,int>>                // true
is_trivially_destructible_v<std::pair<int, std::string>>       // false
```

[[is_swappable_with|std::is_swappable_with<T1, T2>::value]]
[[is_nothrow_swappable|std::is_nothrow_swappable_with<T1, T2>::value]]
>
> Дает `true`, если выражение типа `T1` может быть обменено (с использованием [[swap|swap()]]) с выражением типа `Т2` с тем исключением, что только ссылочные типы определяют категорию значения выражения (с гарантией отсутствия генерации исключений).
>
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был полным]], (`cv`-квалифицированным) `void` или массивом с неизвестной границей.
> 
> Обратите внимание на то, что [[is_swappable_with|is_swappable_with_v<>]] для типов, не являющихся ссылками или классами, всегда дает `false`, поскольку такие типы производят [[r-значение#pr-значения|pr-значения]]. Таким образом, `swap(42, 77)` является некорректной инструкцией.
> 
> Например:
```c++
is_swappable_with_v<int, int>                              // false 
is_swappable_with_v<int&, int>                             // false
is_swappable_with_v<int&&, int>                            // false
is_swappable_with_v<int&, int&>                            // true
is_swappable_with_v<int&&, int&&>                          // false
is_swappable_with_v<int&, long&>                           // false
is_swappable_with_v<int&, void*>                           // false
is_swappable_with_v<void*, int>                            // false
is_swappable_with_v<void*, int&>                           // false
is_swappable_with_v<std::string, std::string>              // false
is_swappable_with_v<std::string&, std::string&>            // true
is_swappable_with_v<std::string&&, std::string&&>          // false 
```
>
> Доступно, начиная co стандарта C++17.

[[is_swappable|std::is_swappable<T>::value]]
[[is_nothrow_swappable|std::is_nothrow_swappable<T>::value]]
>
> Дает `true`, если [[r-значение#l-значение|l-значение]] типа `T` может быть обменено (с гарантией отсутствия генерации исключений).
> 
> Указывает, является ли тип `Т` типом, на который можно ссылаться, так же как [[is_swappable_with|is_swappable_with<T&, Т&>::value]] или [[is_nothrow_swappable|is_nothrow_swappable_with<T&, Т&>::value]] соответственно.
> 
> Дает `false`, если `Т` не является типом, на который можно ссылаться (`referenceable type`) ((`cv`-квалифицированный) `void` или тип функции, квалифицированный с помощью [[const|const]], [[volatile|volatile]], `&`, `&&`).
> 
> Чтобы выяснить, можно ли [[r-значение#r-значения|r-значение]] типа `Т` обменивать с другим [[r-значение#r-значения|r-значением]] типа `Т`, используйте [[is_swappable_with|is_swappable_with<T&&, Т&&>]].
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был полным]], (`cv`-квалифицированным) `void` или массивом с неизвестной границей.
> 
> Например:
```c++
is_swappable_v<int>                              // true
is_swappable_v<int&>                             // true
is_swappable_v<int&&>                            // true
is_swappable_v<std::string&&>                    // true
is_swappable_v<void>                             // false
is_swappable_v<void*>                            // true
is_swappable_v<char[]>                           // false
is_swappable_v<std::unique_ptr<int>>             // true
```
>
> Доступно, начиная со стандарта C++17.

## Взаимоотношения между типами

В табл. Г.5 перечислены свойства типов, которые позволяют проверять определенные взаимоотношения между типами. Сюда включается проверка, какие конструкторы и операторы присваивания предоставлены для типов классов.

| Свойство                                   | Эффект                                                                                                |
| ------------------------------------------ | ----------------------------------------------------------------------------------------------------- |
| [[is_same\|is::same<T1,T2>]]               | T1 и T2 являются одним и тем же типом (включая квалификаторы [[const\|const]]/[[volatile\|volatile]]) |
| [[is_base_of\|is_base_of<T, D>]]           | Тип `Т` является базовым классом для типа `D`                                                         |
| [[is_convertible\|is_convertible <T, T2>]] | Тип `Т` конвертируем в тип `Т2`                                                                       |

[[is_same|std::is_same<T1, Т2>::value]]
>
> Дает `true`, если `T1` и `Т2` именуют один и тот же тип, включая `cv`-квалификаторы ([[const|const]] и [[volatile|volatile]]).
> 
> Дает `true`, если один тип является псевдонимом другого типа.
> 
> Дает `true`, если два объекта были инициализированы объектами одного и того же типа.
> 
> Дает `false` для типов (замыканий), связанных с двумя различными лямбда-выражениями, даже если они определяют одно и то же поведение.
> 
> Например:
```c++
auto а = nullptr;
auto b = nullptr;

is_same_v<decltype(a), decltype(b)>       // Дает true
using А = int;
is_same_v<A, int>                         // Дает true

auto x = [] (int) {};
auto у = x;
auto z = [] (int) {};

is_same_v<decltype(x), decltype(y)>       // Дает true
is_same_v<decltype(x), decltype(z)>       // Дает false
```
>
> [[Реализация свойств типов#Свойства-предикаты|Подробности реализации]]

[[is_base_of|std::is_base_of<B, D>::value]]
>
> Дает `true`, если `В` является базовым классом для `D` или если `В` — тот же класс, что и `D`.
> 
> Не имеет значения, является ли тип `cv`-квалифицированным, использовано ли закрытое или защищенное наследование, имеет ли `D` несколько базовых классов типа `В`, или `D` имеет `В` в качестве базового класса через множественные пути наследования (через виртуальное наследование).
> 
> Дает `false`, если хотя бы один из типов представляет собой [[union|union]].
>
> Требует, чтобы [[Основные термины в области шаблонов#Полные и неполные типы|тип `D` либо был полным]], имел тот же тип, что и `В` (игнорируя любые квалификаторы [[const|const]]/[[volatile|volatile]]), либо не был ни `struct`, ни `class`.
> 
> Например:
```c++
class В
{
};

class D1 : В
{
};

class D2 : В
{
};

class DD : private D1, private D2
{
};

is_base_of_v<B, D1>                        // Дает true
is_base_of_v<B, DD>                        // Дает true
is_base_of_v<B const, DD>                  // Дает true
is_base_of_v<B, DD const>                  // Дает true
is_base_of_v<B, В const>                   // Дает true
is_base_of_v<B& , DD&>                     // Дает false (не тип класса)
is_base_of_v<B[3], DD[3]>                  // Дает false (не тип класса)
is_base_of_v<int, int>                     // Дает false (не тип класса)
```

[[is_convertible|std::is_convertible<FROM, TO>::value]]
>
> Дает `true`, если выражение типа `FROM` может быть преобразовано в тип `ТО`. Таким образом, должен быть корректен следующий код:
```c++
ТО test()
{
	return std::declval<FROM>();
}
```
>
> Ссылка на тип `FROM` используется только для определения категории значения преобразуемого выражения; типом исходного выражения является базовый тип.
> 
> Обратите внимание на то, что из [[is_constructible|is_constructible]] не всегда следует [[is_convertible|is_convertible]]. Например:
```c++
class С
{
	public:
		explicit С(С const&);      // Неявного копирующего
		...                        // конструктора нет
);

is_constructible_v<C, С>          // true
is_convertible_v<C, С>            // false
```
>
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был полным]], (`cv`- квалифицированным) `void` или массивом с неизвестной границей
>
> Обратите внимание на то, что [[is_constructible|is_constructible]] и [[is_assignable|is_assignable]] имеют различный порядок исходного и целевого типов.
> 
> [[IsConvertibleT#IsConvertibleT|Подробности реализации]].

# Построение типов

Свойства, перечисленные в табл. Г.6, позволяют создавать типы из других типов.

| Свойство                                          | Эффект                                                                                                                                                         |
| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [[remove_const\|remove_const<T>]]                 | Соответствующий тип без [[const\|const]]                                                                                                                       |
| [[remove_volatile\|remove volatile<T>]]           | Соответствующий тип без [[volatile\|volatile]]                                                                                                                 |
| [[remove_cv\|remove cv<T>]]                       | Соответствующий тип без [[const\|const]] и [[volatile\|volatile]]                                                                                              |
| [[add_const\|add_const<T>]]                       | Соответствующий [[const\|const]]-тип                                                                                                                           |
| [[add_volatile\|add_volatile<T>]]                 | Соответствующий [[volatile\|volatile]]-тип                                                                                                                     |
| [[add_cv\|add_cv<T>]]                             | Соответствующий `const volatile`-тип                                                                                                                           |
| [[make_signed\|make_signed<T>]]                   | Соответствующий знаковый нессылочный тип                                                                                                                       |
| [[make_unsigned\|make_unsigned<T>]]               | Соответствующий беззнаковый нессылочный тип                                                                                                                    |
| [[remove_reference\|remove reference<T>]]         | Соответствующий нессылочный тип                                                                                                                                |
| [[add_lvalue_reference\|add_lvalue_reference<T>]] | Соответствующий тип ссылки на [[r-значение#l-значение\|l-значение]] ([[r-значение#r-значения\|r-значения]] становятся [[r-значение#l-значение\|l-значениями]]) |
| [[add_rvalue_reference\|add_rvalue_reference<T>]] | Соответствующий тип ссылки на [[r-значение#r-значения\|r-значение]] ([[r-значение#l-значение\|l-значения]] остаются [[r-значение#l-значение\|l-значениями]])   |
| [[remove_pointer\|remove_pointer <T>]]            | Тип, на который указывает указатель (для не указателей тип остается неизменным)                                                                                |
| [[add_pointer\|add_pointer<T>]]                   | Тип указателя на соответствующий нессылочный тип                                                                                                               |
| [[remove_extent\|remove_extent<T>]]               | Типы элементов массива (для немассивов тип остается неизменным)                                                                                                |
| [[remove_all_extents\|remove_all_extents<T>]]     | Типы элементов многомерных массивов (для немассивов тип остается неизменным)                                                                                   |
| [[decay\|decay<T>]]                               | Преобразование в соответствующий тип “передачи по значению”                                                                                                    |

[[remove_const|std::remove_const<T>::type]]
[[remove_volatile|std::remove_volatile<T>::type]]
[[remove_cv|std::remove_cv<T>::type]]
>
> Дает тип `T` без [[const|const]] или/и [[volatile|volatile]] на верхнем уровне.
> 
> Обратите внимание на то, что [[const|const]]-указатель представляет собой [[const|const]]-квалифицированный тип, в то время как не-[[const|const]] указатель или ссылка на константный тип не являются [[const|const]]-квалифицированными. Например:
```c++
remove_cv_t<int>                           // int
remove_const_t<int const>                  // int
remove_cv_t<int const volatile>            // int
remove_const_t<int const&>                 // int const& (только
										   // ссылается на int const)
```
>
> Очевидно, что порядок применения свойств имеет значение:
```c++
remove_const_t<remove_reference_t<int const&>>    // int
remove_reference_t<remove_const_t<int consts>>    // int const
```
>
> Вместо этого можно использовать свойство [[decay|std::decay<>]], которое, однако, преобразует типы массивов и функций в соответствующие типы указателей:
```c++
decay_t<int const&>                               // int
```
>
> [[Реализация свойств типов#Преобразующие свойства|Подробности реализации]]

[[add_const|std::add_const<T>::type]]
[[add_volatile|std::add_volatile<T>::type]]
[[add_cv|std::add_cv<T>::type]]
>
> Дает тип `T` с квалификатором [[const|const]] или/и [[volatile|volatile]], добавленным на верхнем уровне.
> 
> Применение одного из этих свойств к ссылочному типу или типу функции не выполняет никаких действий. Например:
```c++
add_cv_t<int>                        // int const volatile
add_cv_t<int const>                  // int const volatile
add_cv_t<int const volatile>         // int const volatile
add_const_t<int>                     // int const
add_const_t<int const>               // int const
add_const_t<int&>                    // int&
```

[[make_signed|std::make_signed<T>::type]]
[[make_unsigned|std::make_unsigned<T>::type]]
>
> Дает соответствующий знаковый/беззнаковый тип `Т`.
> 
> Требует, чтобы тип `T` был типом перечисления или (`cv`-квалифицированным) целочисленным типом, отличным от `bool`. Все прочие типы ведут к неопределенному поведению ([[Реализация свойств типов#If-Then-Else|обсуждение вопроса о том, как избежать этого неопределенного поведения]]). Например:
```c++
make_unsigned_t<char>              // Дает unsigned char
make_unsigned_t<int>               // Дает unsigned int
make_unsigned_t<int const&>        // Неопределенное поведение
```

[[remove_reference|std::remove_reference<T>::type]]
>
> Дает тип, на который указывает ссылочный тип `Т` (или сам тип `Т`, если он не является ссылочным типом).
> 
> Например:
```c++
remove_reference_t<int>                      // Дает int
remove_reference_t<int const>                // Дает int const
remove_reference_t<int const&>               // Дает int const
remove_reference_t<int&&>                    // Дает int
```
>
> Обратите внимание на то, что сам по себе ссылочный тип не является константным. По этой причине порядок применения свойств построения типов имеет значение:
```c++
remove_const_t<remove_reference_t<int const&>>    // int
remove_reference_t<remove_const_t<int const&>>    // int const
```
>
> Вместо этого можно использовать свойство [[decay|std::decay<>]], которое, однако, преобразует типы массивов и функций в соответствующие типы указателей:
```c++
decay_t<int const&>                               // Дает int
```
>
> [[Реализация свойств типов#Преобразующие свойства|Подробности реализации]]

[[add_lvalue_reference|std::add_lvalue_reference<T>::type]]
[[add_rvalue_reference|std::add_rvalue_reference<T>::type]]
>
> Дает ссылку на [[r-значение#l-значение|l-значение]] или ссылку на [[r-значение#r-значения|r-значение]] типа `Т`, если тип `Т` позволяет создавать ссылку на него.
> 
> Дает `Т`, если тип `Т` позволяет создавать на него ссылку (является либо (`cv`-квалифицированным) `void`, либо типом функции, квалифицированным с помощью [[const|const]], [[volatile|volatile]], `&` или `&&`).
> 
> Обратите внимание на то, что, если `Т` уже является ссылочным типом, эти свойства используют [[Вывод аргументов шаблона#Правила свертки ссылок|правила свертки ссылок]]: результат является ссылкой на [[r-значение#r-значения|r-значение]] только тогда, когда используется [[add_rvalue_reference|add_rvalue_reference]], а `Т` представляет собой ссылку на [[r-значение|r-значение]].
> 
> Например:
```c++
add_lvalue_reference_t<int>                        // int&
add_rvalue_reference_t<int>                        // int&&
add_rvalue_reference_t<int const>                  // int const &&
add_lvalue_reference_t<int const &>                // int const &
		// (согласно правилам свертки ссылок)
add_rvalue_reference_t<remove_reference_t<int const&>> //int&&
add_lvalue_reference_t<void>                       // void
add_rvalue_reference_t<void>                       // void
```
>
> [[Реализация свойств типов#Преобразующие свойства|Подробности реализации]]

[[remove_pointer|std::remove_pointer<T >::type]]
>
> Дает тип, на который указывает тип указателя `Т` (или сам тип `Т`, если он не является типом указателя).
>
> Например:
```c++
remove_pointer_t<int>                       // int
remove_pointer_t<int const*>                // int const
remove_pointer_t<int const* const* const>   // int const* const
```

[[add_pointer|std::add_pointer<T>::type]]
>
> Дает тип указателя на `Т`, или, в случае ссылочного типа `Т`, тип указателя на базовый тип `Т`.
> 
> Дает `Т`, если такой тип несуществует (применяется k `cv`- квалифицированным типам функции).
> 
> Например:
```c++
add_pointer_t<void>                          // void*
add_pointer_t<int const* const>              // int const* const*
add_pointer_t<int&>                          // int*
add_pointer_t<int[3]>                        // int(*) [3]
add_pointer_t<void(&)(int)>                  // void(*)(int)
add_pointer_t<void(int)>                     // void(*)(int)
add_pointer_t<void(int) const>               // void(int) const
											 // (без изменений)
```

[[remove_extent|std::remove_extent<T>::type]]
[[remove_all_extents|std::remove_all_extents<T>::type]]
>
> Для данного типа массива [[remove_extent|remove_extent]] производит тип элемента (который сам по себе может быть типом массива), a [[remove_all_extents|remove_all_extents]] удаляет все “слои массивов” для того, чтобы получить базовый тип элементов (который, таким образом, больше не может быть массивом). Если `Т` не является типом массива, свойство дает сам тип `Т`.
> 
> Указатели не имеют какого-либо связанного с ними измерения. Неуказанная граница в типе массива не определяет измерения. (Как обычно, параметр функции, объявленный с типом массива, не имеет фактического типа массива, как и std: : array не является типом массива.)
> 
> Например:
```c++
remove_extent_t<int>                                 // int
remove_extent_t<int[10]>                             // int
remove_extent_t<int[5][10]>                          // int [10]
remove_extent_t<int[][10]>                           // int [10]
remove_extent_t<int*>                                // int*
remove_all_extents_t<int>                            // int
remove_all_extents_t<int[10]>                        // int
remove_all_extents_t<int[5][10]>                     // int
remove_all_extents_t<int[][10]>                      // int
remove_all_extents_t<int(*)[5]>                      // int (*) [5]
```
>
> [[Метапрограммирование#Метапрограммирование типов|Подробности реализации]]

[[decay|std::decay<T>::type]]
>
> Дает низведенный тип `Т`.
> 
> Подробнее — для типа `Т` выполняются следующие преобразования:
> >
> > сначала применяется [[remove_reference|remove_reference]];
> > 
> > если результат представляет собой [[По значению или по ссылке#Передача по значению|тип массива, создается указатель на тип элемента]];
> > 
> > в противном случае, если результат представляет собой [[Обобщенные библиотеки - template#Поддержка функциональных объектов|тип функции, создается тип, полученный путем применения add_pointer к этому типу функции]];
> > 
> > в противном случае результат получается без каких бы то ни было квалификаторов [[const|const]]/[[volatile|volatile]] верхнего уровня.
>
> Свойство [[decay|decay<>]] моделирует передачу аргументов в функцию по значению или преобразования типов при инициализации объектов типа [[auto|auto]].
> 
> Свойство [[decay|decay<>]] в особенности полезно для обработки параметров шаблонов, вместо которых могут подставляться ссылочные типы, но использоваться для определения возвращаемого типа или типа параметров другой функции. [[Шаблоны функций#Вывод возвращаемого типа|Применение std::decay<>()]] и [[По значению или по ссылке#Рекомендуемые объявления параметров шаблона|тут]] (в пocлeднeм тaкжe излaгaeтcя иcтopия peaлизaции [[pair#std make_pair|std::make_pair<>()]]).
> 
> Например:
```c++
decay_t<int const&>             // Дает int
decay_t<int const[4]>           // Дает int const*
void foo();
decay_t<decltype(foo)>          // Дает void(*)()
```
>
> [[Реализация свойств типов#Преобразующие свойства|Подробности реализации ...]]

# Прочие свойства

В табл. Г.7 перечислены все остальные свойства типов. Они запрашивают специальные характеристики или обеспечивают более сложные преобразования типов.

| Свойство                                         | Эффект                                                                                      |
| ------------------------------------------------ | ------------------------------------------------------------------------------------------- |
| [[enable_if\|enable if<B, T=void>]]              | Дает тип `T`, только если значение `В` типа `bool` равно `true`                             |
| [[conditional\|conditional <B,Т, F>]]            | Дает тип `Т`, если значение в типа `bool` равно `true`, и тип `F` в противном случае        |
| [[common_type\|common type <T1, ...>]]           | Общий тип для всех переданных типов                                                         |
| [[aligned_storage\|aligned storage <Len>]]       | Тип `Len` байтов с выравниванием по умолчанию                                               |
| [[aligned_storage\|aligned storage <Len,Align>]] | Тип `Len` байтов с выравниванием согласно делителю `Align` типа [[size#std size_t\|size_t]] |
| [[aligned_union\|aligned union <Len,Types...>]]  | Тип `Len` байтов с выравниванием для объединения типов `Types...`                           |

[[enable_if|std::enable__if<cond>::type]]
[[enable_if|std::enable_if<cond,T>::type]]
>
> Дает `void` или `T` в качестве члена `type`, если значение `cond` равно `true`. В противном случае член `type` не определен.
> 
> Поскольку член `type` при `cond`, равном `false`, не определен, это свойство может использоваться (и обычно используется) для отключения (в частности, с использованием принципа [[SFINAE|SFINAE]]) шаблона функции на основании заданного условия.
> 
> [[enable_if#Отключение шаблонов с помощью enable_if<>|подробно обсуждается это свойство и приведен соответствующий пример]]; в [[Стандартные утилиты для работы с типами#Комбинирование свойств типов|Комбинирование свойств типов]] рассмотрен другой пример с использованием пакетов параметров.
> 
> [[Перегрузка свойств типов#Включение/отключение шаблонов функций|Подробности реализации std::enable_if]]

[[conditional|std: :conditional<cond, Т, F>::type]]
>
> Дает `T`, если значение `cond` равно `true`, и `F` в противном случае.
> 
> Это [[Реализация свойств типов#If-Then-Else|стандартная версия свойства `IfThenElseT`]].
> 
> Обратите внимание: в отличие от обычных инструкций [[if|if]] C++ аргументы шаблона вычисляются для обоих ветвей до осуществления выбора, так что ни одна ветвь не может содержать некорректный код, иначе программа становится некорректной. Как следствие, возможно, придется добавить уровень косвенности для того, чтобы избежать вычисления выражений в неиспользуемой ветви. [[Реализация свойств типов#If-Then-Else|Этот способ продемонстрирован для свойства IfThenElseT]], имеющего такое же поведение.
> 
> [[Обобщенные библиотеки - template#Откладывание вычислений|Пример]].
> 
> [[Реализация свойств типов#If-Then-Else|Детали реализации std::conditional]].

[[common_type|std::common_type<T...>::type]] 
>
> Дает “общий тип” для данных типов Т1, Т2,..., Тn.
> 
> Вычисление общего оказывается несколько более сложным, чем мы хотели бы видеть в приложении. Грубо говоря, общий тип двух типов `U` и `V` является типом, который возвращает условный оператор `?:`, когда его второй и третий операнды имеют типы `U` и `V` (с ссылочными типами, используемыми только для выяснения категорий значений двух операндов). Если соответствующее выражение недопустимо, общего типа не существует. К полученному результату применяется [[decay|decay_t]]. Вычисления по умолчанию могут быть перекрыты пользовательской специализацией [[common_type|std::common_type<U, V>]] (в стандартной библиотеке C++ имеется частичная специализация для длительностей и точек времени).
> 
> Если типы не заданы или общего типа не существует, то член `type` не определен, так что его использование является ошибкой (которая может использоваться с принципом [[SFINAE|SFINAE]] для отбрасывания шаблона функции).
> 
> Если задан единственный тип, то результатом является применение к нему свойства [[decay|decay_t]].
>
> Для более чем двух типов [[common_type|common_type]] рекурсивно заменяет первые два типа `Т1`, и `Т2` их общим типом. Если в любой момент процесс оказывается неудачным, общего типа не существует.
> 
> При обработке общего типа переданные типы низводятся, так что свойство [[Стандартные утилиты для работы с типами#Построение типов|всегда дает низведенный тип]].
> 
> Обсуждение этого свойства и [[Шаблоны функций#Возвращаемый тип как общий тип|пример его применения]].
> 
> Первичный шаблон этого свойства обычно реализуется с помощью кода наподобие следующего (здесь использованы только два параметра):
```c++
template<typename T1, typename Т2>
struct common_type<T1, T2>
{
	using type = std::decay_t<decltype(true ?
							std::declval<T1>() :
							std::declval<T2>())>;
};
```

[[aligned_union|std::aligned_union<MIN_SZ, T...>::type]]
>
> Дает простой старый тип данных (POD), используемый как неинициализированное хранилище, имеющее размер как минимум `MIN_SZ` и походящее для хранения любого из заданных типов Т1, Т2, ..., Тn.
> 
> Кроме того, это свойство дает статический член [[alignment_value|alignment_value]], значение которого представляет собой наиболее строгое выравнивание для всех данных типов, которое для результирующего типа `type` эквивалентно следующему:
> >
> > [[alignment_of|std::alignment_of_v< type>::value]];
> > 
> > [[alignof|alignof(type)]].
>
> Требует, чтобы был предоставлен по крайней мере один тип.
> 
> Например:
```c++
using POD_T = std::aligned_union_t<0, char,
					std::pair<std::string, std::string>>;
std::cout << sizeof(POD_T) << '\n';
std::cout << std::aligned_union<0, char,
					std::pair<std::string, std::string>
                    >::alignment_value;
          << ' \n' ;
```

Обратите внимание на то, что применение [[aligned_union|aligned_union]] вместо [[aligned_union|aligned_union_t]] дает вместо типа значение выравнивания.

[[aligned_storage|std::aligned_storage<MAX_TYPE_SZ>::type]]
[[aligned_storage|std::aligned_storage<MAX_TYPE_SZ, DEF_ALIGN>::type]]
>
> Дает простой старый тип данных (`POD`), используемый как неинициализированное хранилище для хранения всех возможных типов с размером до `MAX_TYPE_SZ`, с учетом выравнивания по умолчанию или выравнивания, переданного как `DEF_ALIGN`.
>
> Требует, чтобы значение `MAX_TYPE_SZ` было больше нуля, а на платформе имелся хотя бы один тип со значением выравнивания `DEF_ALIGN`.
> 
> Например:
```c+++
using POD_T = std::aligned_storage_t<5>;
```

# Комбинирование свойств типов

В большинстве контекстов несколько свойств типов, являющихся предикатами, могут быть объединены с помощью логических операторов. Однако в некоторых контекстах шаблонного метапрограммирования этого недостаточно:
> если вы работаете со свойством, которое может сбоить (например, из-за неполноты типов);
> 
> если вы хотите комбинировать определения свойств типов.

Для этой цели предназначены свойства типов [[conjunction|std::conjunction<>]], [[disjunction|std::disjunction<>]] и [[negation|std::negation<>]].

Одним из примеров является применение этих вспомогательных свойств для короткого вычисления логических выражений (прекратить вычисление после первого значения `false` для операции `&&`, или первого значения `true` для операции `||` соответственно). Например, если используются неполные типы
```c++
struct X
{
	X(int);                  // Преобразование из int
};
struct Y;                    // Неполный тип
```

то приведенный ниже код можетне компилироваться, поскольку [[is_constructible|is_constructible]] приведет к неопределенному поведению для неполных типов (хотя некоторые компиляторы могут принять этот код):
```c++
// Неопределенное поведение:
static_assert(std::is_constructible<X, int> {}
				|| std::is_constructible<Y, int> {},
				"нельзя инициализировать X или Y значением int");
```

Однако следующий код гарантированно компилируется, так как вычисление [[is_constructible|is_constructible<X, int>]] всегда дает `true`:
```c++
// ОК:
static_assert(std::disjunction<std::is_constructible<X, int>,
								std::is_constructible<Y, int>> {},
				"нельзя инициализировать X или Y значением int");
```

Еще одним применением является простой способ определить новое свойство типа, логически объединяя существующие свойства. Например, можно легко определить свойство, проверяющее, является ли тип “не указателем” (т.е. не является ни указателем, ни указателем на член, ни нулевым указателем):
```c++
template<typename Т>
struct isNoPtrT :
	std::negation<
		std::disjunction<std::is_null_pointer<T>,
						std::is_member_pointer<T>,
						std::is_pointer<T>
                        >
                 > {};
```

Здесь мы не можем использовать логические операторы, потому что мы объединяем соответствующие классы свойств. Имея такое определение свойства, мы можем написать следующий код:
```c++
std::cout << isNoPtrT<void*>::value << '\n';                // false
std::cout << isNoPtrT<std::string>::value << '\n';          // true
auto nр = nullptr;
std::cout << isNoPtrT<decltype(np)>::value << '\n';         // false
```

А при наличии соответствующего шаблона переменной:
```c++
template<typename Т>
constexpr bool isNoPtr = isNoPtrT<T>::value;
```

можно записать:
```c++
std::cout << isNoPtr<void*> << ' \n';                       // false
std::cout << isNoPtr<int> << '\n';                          // true
```

В качестве последнего примера следующий шаблон функции доступен, только если все его аргументы шаблона не являются ни классами, ни объединениями:
```c++
template<typename... Ts>
std::enable_if_t<std::conjunction_v<
					std::negation<std::is_class<Ts>>...,
					std::negation<std::is_union<Ts>>...
				>>
print(Ts...)
{
	...
}
```

Обратите внимание на троеточие, размещенное после каждого отрицания; таким образом, отрицание применяется к каждому элементу пакета параметров.

Таблица Г.8. Свойства типов для комбинирования других свойств типов

| Свойство                               | Эффект                                                         |
| -------------------------------------- | -------------------------------------------------------------- |
| [[conjunction\|conjunction <B. . . >]] | Логическое И для булевых свойств `В...` (начиная<br>с С++17)   |
| [[disjunction\|disjunction <B... >]]   | Логическое ИЛИ для булевых свойств `В...` (начиная<br>с С++17) |
| [[negation\|negation <B>]]             | Логическое НЕ для булева свойства `В` (начиная с С++17)        |

[[conjunction|std::conjunction<B..:value]]
[[disjunction|std::disjunction<B...>::value]]
>
> Проверяет, все ли (или одно из них) переданные булевы свойства `В...` дают `true`.
> 
> Применяет логические операторы `&&` или `||` соответственно к переданным свойствам.
> 
> Оба свойства используют краткие вычисления (вычисление прекращается после первого `false` (или, соответственно, `true`)).
> 
> Выше представлен соответствующий пример.
> 
> Доступно, начиная со стандарта C++17.

[[negation|std::negation<B>::value]]
>
> Проверяет, дает ли переданное булево свойство `В` значение `false`.
> 
> Применяет логический оператор `!` к переданному свойству.
> 
> Выше приведен соответствующий пример.
> 
> Доступно, начиная со стандарта C++17.

# Прочие утилиты

Стандартная библиотека C++ предоставляет несколько других утилит, полезных при написании переносимого обобщенного кода.

Таблица Г.9. Прочие утилиты для метапрограммирования

| Свойство                    | Эффект                                                                                      |
| --------------------------- | ------------------------------------------------------------------------------------------- |
| [[declval\|declval<T>()]]   | Дает “объект” (ссылку на [[r-значение\|r-значение]]) типа без фактического создания объекта |
| [[addressof\|addressof(r)]] | Дает адрес объекта или функции                                                              |

[[declval|std::declval<T>()]]
>
> Определено в заголовочном файле `<utility>`.
> 
> Дает “объект” или функцию любого типа без вызова каких бы то ни было конструкторов или инициализаций.
> 
> Если `Т` представляет собой `void`, то возвращаемый тип — `void`.
> 
> Это свойство может быть использовано для работы с объектами или функциями любого типа в невычисляемых выражениях.
> 
> Свойство определено как
```c++
template<typename Т>
add_rvalue_reference_t<T> declval() noexcept;
```

так что
> > если `Т` является простым типом или ссылкой на [[r-значение|r-значение]], свойство дает `Т&&`;
> > 
> > если `Т` является ссылкой на [[r-значение#l-значение|l-значение]], свойство дает `Т&`;
> > 
> > если `Т` представляет собой `void`, свойство дает `void`.
>
> [[Реализация свойств типов#Свойства типов результатов|Подробности]], а в описании [[common_type|common_type<>]] — пример применения.

[[addressof|std::addressof(r)]]
>
> Определено в заголовочном файле `<memory>`.
> 
> Дает адрес объекта или функции `r`, даже если `operators` для этого типа перегружен.
>
> [[addressof#std addressof<>()|Подробности представлены ...]]

