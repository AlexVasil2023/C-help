
[[#Стандартные утилиты для работы с типами|Стандартные утилиты для работы с типами]] Г
1. [[#Использование свойств типов|Использование свойств типов]] Г.1
	1. [[#std integral_constant и std bool_constant|std::integral_constant и std::bool_constant]] Г.1.1
	2. [[#Что вы должны знать при использовании свойств|Что вы должны знать при использовании свойств]] Г.1.2
2. [[#Основные и составные категории типов|Основные и составные категории типов]] Г.2
	1. [[#Проверка основных категорий типов|Проверка основных категорий типов]] Г.2.1
	2. [[#Проверка составных категорий типов|Проверка составных категорий типов]] Г.2.2
3. [[#Характеристики и операции над типами|Характеристики и операции над типами]] Г.3
	1. [[#Прочие характеристики типов|Прочие характеристики типов]] Г.3.1









# Стандартные утилиты для работы с типами

Стандартная библиотека C++ в основном состоит из шаблонов, многие из которых опираются на различные методы, представленные и всесторонне рассмотренные в этой книге. По этой причине некоторые методы были “стандартизованы” в том смысле, что стандартная библиотека определяет несколько шаблонов для реализации библиотек с обобщенным кодом. Эти утилиты для работы с типами (свойства типов и другие вспомогательные шаблоны) перечислены и разъясняются здесь, в этом приложении.

Обратите внимание на то, что некоторые [[Реализация свойств типов#Реализация свойств типов|свойства типов требуют поддержки компилятора, в то время как другие могут быть реализованы в библиотеке только с помощью стандартных возможностей языка]].

# Использование свойств типов

В общем случае при использовании свойств типов необходимо включение заголовочного файла `<type_traits>`:
```c++
#include <type_traits>
```

Далее их применение зависит от того, дает свойство тип или значение.
>
> Если свойство дает тип, обратиться к нему можно следующим образом:
```c++
typename std::trait<...>::type
std::trait_t<...>                             // Начиная с C++14
```
>
> Если свойство дает значение, обратиться к нему можно следующим образом:
```c++
std::trait<...>::value
std::trait<...>()          // Неявное преобразование в его тип
std::trait_v<...>          // Начиная с С++17
```

Например:
```c++
#include <type_traits>
#include <iostream>

int main()
{
	int i = 42;
	std::add_const<int>::type c = i; // c — int const
	std::add_const_t<int> cl4 = i;   // Начиная с C++14
	static__assert(std::is_const<decltype(c)>::value,
					"с должна быть const");

	std::cout << std::boolalpha;
	std::cout << std::is_same<decltype(c), int const>::value // true
				<< '\n';
	std::cout << std::is_same_v<decltype(c), int const>
				<< '\n' ;                        // Начиная с C++17

	// Неявное преобразование в bool:
	if (std::is_same<decltype(с), int const> {})
	{
		std::cout << "Одинаковы \n";
	}
};
```

[[Шаблоны классов#Псевдонимы типов|способ определения `_t`-версии свойств]]
[[Шаблоны переменных#Шаблоны переменных|способ определения `_v`-версии свойств]].

## std::integral_constant и std::bool_constant

Все стандартные типы, дающие значение, являются производными от экземпляра вспомогательного шаблона класса `std::integral_constant`:
```c++
namespace std
{
	template<typename T, T val>
	struct integral_constant
	{
		static constexpr T value = val; // Значение свойства
		using value_type = T;           // Тип значения
		using type = integral_constant<T, val>;
		
		constexpr operator value_type() const noexcept
		{
			return value;
		}
		
		// Начиная с C++14:
		constexpr value_type operator()() const noexcept
		{
			return value;
		}
	};
};
```

Из приведенного шаблона видно следующее.
> 
> Можно использовать член `value_type` для запроса типа результата. Поскольку многие свойства, дающие значения, являются предикатами, `value_type` часто является простым `bool`.
> 
> Объекты с типами свойств имеют неявное преобразование типа в тип значения, производимый свойством типа.
> 
> В C++14 (и далее) объекты типа свойств являются также функциональными объектами (функторами), для которых “вызов функции” дает их значения.
> 
> Член `type` просто дает базовый экземпляр `integral constant`.

Если свойства дают булевы значения, то они также используют
```c++
namespace std
{
	template<bool В>
	using bool_constant = integral_constant<bool,B>; // Начиная с C++17
	using true_type = bool_constant<true>;
	using false_type = bool_constant<false>;
}
```

так что эти логические свойства наследуют `std::true_type`, если определенное свойство справедливо, и `std::false_type`, если нет. Это также означает, что соответствующие члены `value` равны `true` или `false`. Наличие различных типов для результирующих значений `true` и `false` позволяет нам прибегать к [[Перегрузка свойств типов#Диспетчеризация дескрипторов|диспетчеризации дескрипторов]], основанной на [[Реализация свойств типов#Свойства-предикаты|результатах свойств типа]].

Например:
```c++
#include <type_traits>
#include <iostream>

int main()
{
	using namespace std;
	cout << boolalpha;
	
	using MyType = int;
	cout << is_const<MyType>::value << ' \n';     // Выводит false
	
	using VT = is_const<MyType>::value_type;      // bool
	
	// integral_constant<bool, false>:
	using Т = is_const<MyType>::type;
	cout << is_same<VT, bool>::value << '\n':     // Выводит true
	cout << is_same<T, integral_constant<bool, false>>::value 
			<< '\n';                              // Выводит true
	cout << is_same<T, bool_constant<false>>::value // Выводит true
			<< '\n';                             // (не работает до C++17)
	
	auto ic = is_const<MyType>();                // Объект типа свойства
	cout << is_some<decltype(ic),
					is_const<int>>::value << '\n'; // true
	cout << ic() << '\n';                // Вызов функции (выводит false)

	static constexpr auto mytypeIsConst = is_const<MyType> {};
	
	if constexpr(mytypeIsConst)          // Проверка времени компиляции
	{                                    // начиная с С++17 => false
		...                              // Отброшенные инструкции
	}
	
	static_assert(!std::is_const<MyType> {},
					"МуТуре не должен быть константой");
}
```

Наличие различных типов для небулевых специализаций `integral_constant` полезно также в ряде контекстов метапрограммирования. [[Списки типов - template#Списки нетиповых параметров|Обсуждение аналогичного типа CTValue]] и его [[tuple (Кортежи)#Индексы кортежа|применение для доступа к элементу кортежа]].

## Что вы должны знать при использовании свойств

Говоря о применениях свойств, следует упомянуть о следующем.

> Свойства типов применяются непосредственно к типам, но [[decltуре|decltype]] позволяет нам также проверять свойства выражений, переменных и функций. Напомним, однако, что [[decltуре|decltype]] дает тип переменной или функции, только если сущность именована и не находится в лишних скобках; для любого прочего выражения эта конструкция дает тип, который отражает также категорию типа выражения. Например:
```c++
void foo(std::string&& s)
{
	// Проверка типа s:
	// false:
	std::is_lvalue_reference<decltype(s)>::value

	// true, согласно объявлению:
	std::is_rvalue_reference<decltype(s)>::value
	
	// Проверка категории значения s как выражения:
	// true, s используется как l-значение:
	std::is_lvalue_reference<decltype((s))>::value
	
	// false:
	std::is_rvalue_reference<decltype((s))>::value
}
```
> 
> [[decltуре#Запись типа выражения с помощью decltype|Подробности...]]
>
> Некоторые свойства для начинающего программиста могут демонстрировать [[Обобщенные библиотеки - template#Другие утилиты для реализации обобщенных библиотек|неинтуитивное поведение]].
> 
> Некоторые свойства предъявляют определенные требования или предусловия. Нарушение этих предусловий ведет к неопределенному поведению. [[Обобщенные библиотеки - template#Свойства типов|Некоторые примеры ...]].
>
> Многие свойства требуют [[Основные термины в области шаблонов#Полные и неполные типы|полных типов]]. Чтобы иметь возможность использовать их для неполных типов, мы иногда можем [[Обобщенные библиотеки - template#Откладывание вычислений|ввести шаблоны для того, чтобы отложить их вычисление]].
> 
> Иногда логические операторы `&&`, `||`, и `!` не могут использоваться для определения нового свойства типа, основанного на других свойствах типов.
> 
> Кроме того, работа со свойствами типов, которые могут давать сбои, может стать проблемой или по крайней мере привести к определенным недостаткам. По этой причине предоставляются специальные свойства, которые позволяют нам логически объединять булевы свойства типов. Подробнее об этом рассказывается в #разделе_Г_6.
> 
> Хотя стандартные шаблоны псевдонимов (заканчивающиеся `_t` или `_у`) часто удобны, они также имеют [[Реализация свойств типов#Повышение удобства свойств|недостатки, делающие их непригодными для использования в некоторых контекстах метапрограммирования]].

# Основные и составные категории типов

Начнем со стандартных свойств, которые проверяют основные и составные категории типов (см. рис. Г.1). В общем случае каждый тип принадлежит ровно к одной основной категории типа (белые элементы на рисунке). Составные категории типов объединяют основные категории типов в концепции более высокого уровня.

![[template_11.png]]
рис. Г.1. Основные и составные категории типов

## Проверка основных категорий типов

Этот раздел описывает утилиты, которые проверяют основную категорию данного типа. Для любого заданного типа ровно одна основная категория имеет статический член `value`, который имеет значение `true`. Результат не зависит от того, квалифицирован тип с помощью [[const|const]] или [[volatile]] (cv-квалифицированный).

Обратите внимание на то, что для типов [[size#std size_t|std::size_t]] и [[ptrdiff#std ptrdiff_t|std::ptrdiff_t]] свойство [[is_integral|is_integral<>]] дает значение `true`. Для типа [[max_align#std max_align_t|std::max_align_t]] то, какая из основных категорий типа выдаст `true`, зависит от реализации (т.е. это может быть целочисленный тип, тип с плавающей точкой или классовый тип). Язык определяет, что [[Вывод аргументов шаблона#Обобщенные лямбда-выражения|тип лямбда-выражения — это классовый тип]], поэтому применение [[is_class|is_class]] к этому типу дает значение `true`.

Таблица Г.1. Свойства для проверки основных категорий типов

| Свойство                                                                                       | Эффект                                                                               |
| ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| [[is_void#is_void\|is void<T>]]                                                                | Тип `void`                                                                           |
| [[is_integral#std is_integral\|is integral<T>]]                                                | Целочисленный тип (включая `bool`, `char`, `char16_t`, `char32_t`, `wchar_t`)        |
| [[is_floating_point\|is floating point<T>]]                                                    | Тип с плавающей точкой (`float`, `double`, `long double`)                            |
| [[is_array#std is_array\|is array<T>]]                                                         | Обычный массив (не тип [[Array#std array C++11\|std::array]])                        |
| [[is_pointer\|is pointer<T>]]                                                                  | Тип указателя (включая указатели на функции, но не указатели на нестатические члены) |
| [[is_null_pointer\|is null pointer<T>]]                                                        | Тип [[nullptr_t#nullptr\|nullptr]] (начиная с С++14)                                 |
| [[is_member_object_pointer#std is_member_object_pointer\|is member object pointer<T>]]         | Указатель на нестатический член-данное                                               |
| [[is_member_function_pointer#std is_member_function_pointer<>\|is member function pointer<T>]] | Указатель на нестатическую функцию-член                                              |
| [[is_lvalue_reference#std is_lvalue_reference\|is lvalue reference<T>]]                        | Ссылка на [[r-значение#l-значение\|l-значение]]                                      |
| [[is_rvalue_reference#std is_rvalue_reference\|is rvalue reference<T>]]                        | Ссылка на [[r-значение#r-значения\|r-значение]]                                      |
| [[is_enum#std is_enum\|is enum<T>]]                                                            | Тип перечисления                                                                     |
| [[is_class#std is_class\|is class<T>]]                                                         | Тип класса/структуры или лямбда-выражения, но не объединения                         |
| [[is_union#std is_union\|is union<T>]]                                                         | Тип объединения                                                                      |
| [[is_function#std is_function\|is function<T>]]                                                | Тип функции                                                                          |

[[is_void#is_void|std::is_void<T>::value]] 
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) `void`.
> 
> Например:
> 
```c++
is_void_v<void>                        // Дает true
is_void_v<void const>                  // Дает true
is_void_v<int>                         // Дает false
void f();
is_void_v<decltype(f)>                 // Дает false (f имеет тип функции)
is_void_v<decltype(f())>               // Дает true (возвращаемый тип f())
```

[[is_integral#std is_integral|std::is_integral<T>:rvalue]] 
>
> Дает `true`, если тип `T` представляет собой один из следующих (возможно, `cv`-квалифицированных) типов:
> 
> > `bool`;
> >
> > символьный тип (`char`, `signed char`, `unsigned char`, `char16_t`, `char32_t` или `wchar_t`);
> >
> > целочисленный тип (знаковые или беззнаковые варианты `short`, `int`, `long` или `long long`; включает [[size#std size_t|std::size_t]] и [[ptrdiff#std ptrdiff|std::ptrdiff_t]]).

[[is_floating_point#is_floating_point<T>|std: :is_floating_jpoint<T>: : value]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) `float`, `double` или `long double`.

[[is_array#std is_array|std::is_array<T>::value]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) тип массива.
> 
> Помните, что параметр, объявленный как массив (с длиной или без таковой) по правилам языка в действительности имеет тип указателя.
> 
> Обратите внимание на то, что класс [[Array#std array C++11|std::array<>]] является типом класса, а не массива.
> 
> Например:
```c++
is_array_v<int[]>                // Дает true
is_array_v<int[5]>               // Дает true
is_array_v<int*>                 // Дает false

void foo(int a[], int b[5], int* c)
{
	is_array_v<decltype(a)>      // Дает false (a имеет тип int*)
	is_array_v<decltype(b)>      // Дает false (b имеет тип int*)
	is_array_v<decltype(c)>      // Дает false (c имеет тип int*)
}
```
>
> [[Реализация свойств типов#Определение составных типов|Детали реализации рассмотрены ...]].

[[is_pointer#std is_pointer|std::is_pointer<T>:rvalue]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) указатель.
> 
> Сюда входят:
> 
> > указатели на статические/глобальные функции (и статические функции-члены);
> > параметры, объявленные как массивы (с длиной или без таковой) или типы функций.
>
> Сюда не. входят:
> 
> > типы указателей на члены (например, тип `&Х::m`, где `X` — классовый тип a `m` — нестатическая функция-член или нестатический член-данное);
> > 
> > тип [[nullptr_t#std nullptr_t|nullptr - std: :nullptr_t]].
>
> Например:
```c++
is_pointer_v<int>                          // Дает false
is_pointer_v<int*>                         // Дает true
is_pointer_v<int* const>                   // Дает true
is_pointer_v<int*&>                        // Дает false
is_pointer_v<decltype(nullptr)>            // Дает false

int* foo(int a[5], void(f)())
{
	is_pointer_v<decltype(a)>            // Дает true (тип a — int*)
	is_pointer_v<decltype(f)>            // Дает true (тип f — void(*)())
	is_pointer_v<decltype(foo)>          // Дает false
	is_pointer_v<decltype(&foo)>         // Дает true
	// Дает true (возвращаемый тип — int*):
	is_pointer_v<decltype(foo(a ,f))>
}
```
>
> [[Реализация свойств типов#Определение составных типов|Детали реализации ...]].

[[is_null_pointer#is_null_pointer<T>|std::is_null_pointer<T>::value]] 
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) [[nullptr_t|std::nullptr_t]], являющийся типом [[nullptr_t#nullptr|nullptr]].
> 
> Например:
```c++
is_null_pointer_v<decltype(nullptr)>            // Дает true
void* р = nullptr;
// Дает false (р не имеет тип std::nullptr_t):
is_null_pointer_v<decltype(р)>
```
>
. В стандарте, начиная с C++14.

[[is_member_object_pointer|std::is_member_object_pointer<T>::value]]
[[is_member_function_pointer|std::is_member_function_pointer<T>:rvalue]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) тип указателя на член (например, `int X::*` или `int (X::*) ()` для некоторого классового типа `X`).

[[is_lvalue_reference|std::is_lvalue_reference<T>::value]]
[[is_rvalue_reference|std::is_rvalue_reference<T>::value]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) тип ссылки на [[r-значение#l-значение|l-значение]] или ссылки на [[r-значение#r-значения|r-значение]] соответственно. Например:
```c++
is_lvalue_reference_v<int>           // Дает false
is_lvalue_reference_v<int&>          // Дает true
is_lvalue_reference_v<int&&>         // Дает false
is_lvalue_reference_v<void>          // Дает false

is_rvalue_reference_v<int>           // Дает false
is_rvalue_reference_v<int&>          // Дает false
is_rvalue_reference_v<int&&>         // Дает true
is_rvalue_reference_v<void>          // Дает false
```
>
> [[Реализация свойств типов#Определение составных типов|Детали реализации ... ]]

[[is_enum#std is_enum|std::is_enum<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) тип перечисления. Применим как к перечислениям с областью видимости, так и к перечислениям без области видимости.
> 
> [[Реализация свойств типов#Обнаружение типов перечислений|Детали реализации приведены тут...]].

[[is_class|std::is_class<T>::value]] 
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) классовый тип, объявленный с использованием ключевого слова `class` или `struct`, включая тип, сгенерированный инстанцированием шаблона класса. Обратите внимание — язык гарантирует, что [[Вывод аргументов шаблона#Обобщенные лямбда-выражения|тип лямбда-выражения представляет собой классовый тип]].
> 
> Дает `false` для объединений, типов перечислений с областью видимости (несмотря на объявление `enum class`), [[nullptr_t|std::nullptr_t]] и любых прочих типов.
> 
> Например:
```c++
is_class_v<int>                        // Дает false
is_class_v<std::string>                // Дает true
is_class_v<std::string const>          // Дает true
is_class_v<std::string&>               // Дает false
auto 11 = [] {};
// Дает true (лямбда-выражение является объектом класса)
is_class_v<decltype(11)>
```
>
> [[Реализация свойств типов#Обнаружение типов классов|Детали реализации рассмотрены тут...]]

[[is_union|std::is_union<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) тип объединения [[union|union]], включая объединение, генерируемое из шаблона класса, который является шаблоном объединения.

[[is_function|std::is_function<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) тип функции. Дает `false` для типа указателя на функцию, типа лямбда-выражения или любого другого типа.
> 
> Помните, что параметр, объявленный как тип функции, по правилам языка в действительности имеет тип указателя.
> 
> Например:
```c++
void foo(void(f)())
{
	// Дает false (f имеет тип void(*)()):
	is_function_v<decltype(f)>
	is_function_v<decltype(foo)>         // Дает true
	is_function_v<decltype(&foo)>        // Дает false
	// Дает false (для возвращаемого типа):
	is_function_v<decltype(foo(f))>
}
```
>
> [[Реализация свойств типов#Идентификация типов функций|Детали реализации приведены тут...]]

## Проверка составных категорий типов

Рассматриваемые далее утилиты позволяют определить, принадлежит ли тип к более широкой категории типов, которая является объединением некоторых основных категорий типов. Составные категории типов не образуют строгого деления: тип может принадлежать к нескольким составным категориям одновременно (например, тип указателя является одновременно и скалярным, и составным). И вновь `cv`-квалификация ([[const|const]] и [[volatile|volatile]]) при классификации типа не учитывается.

Таблица Г.2. Свойства для проверки составных категорий типов

| Свойство                                    | Эффект                                                                                                                                                                   |
| ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [[is_reference\|is reference<T>]]           | Ссылка на [[r-значение#l-значение\|l-значение]] или ссылка на [[r-значение#r-значения\|r-значение]]                                                                      |
| [[is_member_pointer\|is_member_pointer<T>]] | Указатель на нестатический член                                                                                                                                          |
| [[is_arithmetic\|is arithmetic<T>]]         | Целочисленный тип (включая `bool` и символьные типы) или тип с плавающей точкой                                                                                          |
| [[is_fundamental\|is_fundamental]]          | `void`, целочисленный тип (включая `bool` и символьные типы), тип с плавающей точкой или [[nullptr_t#std nullptr_t\|std::nullptr_t]]                                     |
| [[is_scalar\|is_scalar<T>]]                 | Целочисленный тип (включая `bool` и символьные типы), тип с плавающей точкой, перечисление, указатель, указатель на член или [[nullptr_t#std nullptr_t\|std::nullptr_t]] |
| [[is_object\|is_object<T>]]                 | Любой тип, за исключением `void`, функции или ссылки                                                                                                                     |
| [[is_compound\|is_compound<T>]]             | Противоположность [[is_fundamental\|is_fundamental<T>]]: массив, перечисление, объединение, класс, функция, ссылка, указатель или указатель на член                      |

[[is_reference|std::is_reference<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой ссылочный тип.
> 
> Тоже, что и [[is_lvalue_reference|is_lvalue_reference_v<T>]] || [[is_rvalue_reference|is_rvalue_reference_v<T>]].
> 
• [[Реализация свойств типов#Определение составных типов|Детали реализации приведены тут...]]

[[is_member_pointer|std::is_member_pointer<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой любой тип указателя на член.
> 
• То же, что и !([[is_member_object_pointer|is_member_object_pointer_v<T>]] ||[[is_member_function_pointer|s_member_function_pointer_v<T>]]).

[[is_arithmetic|std::is_arithmetic<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой арифметический тип (`bool`, символьный тип, целочисленный тип или тип с плавающей точкой).
> 
> То же, что и [[is_integral|is_integral_v<T>]] II [[is_floating_point|is_floating_point_v<T>]].

[[is_fundamental|std::is fundamental<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой фундаментальный тип (арифметический тип, `void` или [[nullptr_t|std::nullptr_t]]).
> 
> То же, что и [[is_arithmetic|is_arithmetic_v<T>]] | | [[is_void|is_void_v<T>]] | | [[is_null_pointer|is_null_pointer_v<T>]].
> 
> То же, что и [[is_compound|is_compound_v<T>]]
>
> [[Реализация свойств типов#Определение фундаментальных типов|Подробности реализации рассмотрены при разработке шаблона IsFundaT]].

[[is_scalar|std::is_scalar<T>::value]]

> Дает `true`, если тип `Т` представляет собой “скалярный” тип.
>
> Тоже, что и [[is_arithmetic#is_arithmetic_v|is_arithmetic_v<T>]] || [[is_enum#is_enum_v|is_enum_v<T>]] || [[is_pointer#std is_pointer_v|is_pointer_v<T>]] || [[is_member_pointer#is_member_pointer_v|is_member_pointer_v<T>]] || [[is_null_pointer#is_null_pointer_v|is_null_pointer_v<T>]]>.

[[is_object|std::is_object<T>::value]]
>
> Дает `true`, если тип `T` описывает тип объекта.
> 
> То же, что и [[is_scalar#is_scalar_v|is_scalar_v<T>]] || [[is_array#std is_array_v|is_array_v<T>]] || [[is_class#std is_class_v|is_class_v<T>]] || [[is_union#std is_union_v|is_union_v<T>]]).
> 
> Тоже, что и ! ([[is_function#std is_function_v|is_function_v<T>]] || [[is_reference#std is_reference_v|is_reference_v<T>]] || [[is_void#is_void_v|is_void_v<T>]]).

[[is_compound|std::is_compound<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой тип, составленный из других типов.
> 
> То же, что и ! [[is_fundamental#std is_fundamental_v|is_fundamental_v<T>]] 
>
> То же, что и [[is_enum#std is_enum_v|is_enum_v<T>]] || [[is_array#std is_array_v|is_array_v<T>]] || [[is_class#std is_class_v|is_class_v<T>]] || [[is_union#std is_union_v|is_union_v<T>]] || [[is_reference#std is_reference_v|is_reference_v<T>]] || [[is_pointer#std is_pointer_v|is_pointer_v<T>]] || [[is_member_pointer#is_member_pointer_v|is_member_pointer_v<T>]] || [[is_function#std is_function_v|is_function_v<T>]].

# Характеристики и операции над типами

Следующая группа свойств проверяет другие характеристики отдельных типов, а также наличие определенных операций (например, обмен значений), которые могут выполняться с ними.

## Прочие характеристики типов

Таблица Г.З. Свойства, проверяющие простые характеристики типов

| Свойство                                                                          | Эффект                                                                                                                                  |
| --------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| [[is_signed\|is_signed<T>]]                                                       | Знаковый арифметический тип                                                                                                             |
| [[is_unsigned\|is unsigned<T>]]                                                   | Беззнаковый арифметический тип                                                                                                          |
| [[is_const\|is const<T>]]                                                         | [[const\|const]]-квалифицированный тип                                                                                                  |
| [[is_volatile\|is volatile<T>]]                                                   | [[volatile\|volatile]] -квалифицированный тип                                                                                           |
| [[is_aggregate\|is_aggregate<T>]]                                                 | Агрегат (начиная с C++17)                                                                                                               |
| [[is_trivial\|is_trivial<T>]]                                                     | Скаляр, тривиальный класс или массивы этих типов                                                                                        |
| [[is_trivially_copyable\|is_trivially_copyable<T>]]                               | Скаляр, тривиально копируемый класс или массивы этих типов                                                                              |
| [[is_standard_layout\|is_standard_layout<T>]]                                     | Скаляр, класс со стандартной схемой размещения или массивы этих типов                                                                   |
| [[is_pod\|is_pod<T>]]                                                             | Простой старый тип данных (в котором можно копировать объекты с помощью `memcpy()`)                                                     |
| [[is_literal_type\|is_literal_type<T>]]                                           | Скаляр, ссылка, класс или массивы этих типов (не рекомендовано, начиная с C++17)                                                        |
| [[is_empty\|is_empty<T>]]                                                         | Класс без членов, виртуальных функций-членов или виртуальных базовых классов                                                            |
| [[is_polymorphic\|is_polymorphic<T>]]                                             | Класс с (производной) виртуальной функцией-членом                                                                                       |
| [[is_abstract\|is_abstract<T>]]                                                   | Абстрактный класс (как минимум одна чисто виртуальная функция)                                                                          |
| [[is_final\|is_final<T>]]                                                         | Финальный класс (класс, который нельзя наследовать; начиная с С++14)                                                                    |
| [[has_virtual_destructor\|std::has_virtual_destructor<T>]]                        | Класс с виртуальным деструктором                                                                                                        |
| [[has_unique_object_representations\|std::has_unique_object_representations <T>]] | Любые два объекта с одним и тем же значением имеют одинаковое представление в памяти (начиная с C++17)                                  |
| [[alignment_of\|alignment_of<T>]]                                                 | Эквивалентно `alignof (Т)`                                                                                                              |
| [[rank\|rank<T>]]                                                                 | Количество размерностей типа массива (или 0)                                                                                            |
| [[extent\|extent<T, I=0>]]                                                        | Длина по размерности I (или 0)                                                                                                          |
| [[underlying_type\|underlying_type<T>]]                                           | Базовый тип для типа перечисления                                                                                                       |
| [[is_invocable\|is_invocable<T,Args...>]]                                         | Может использоваться как вызываемый объект для `Args...` (начиная с С++17)                                                              |
| [[is_nothrow_invocable\|is_nothrow_invocable <T, Args...>]]                       | Может использоваться как вызываемый объект для `Args...` с гарантией отсутствия исключений<br>(начиная с С++17)                         |
| [[is_invocable#std is_invocable_r\|is_invocable_r <RT, T, Args...>]]              | Может использоваться как вызываемый объект для `Args...`, с возвращаемым типом `RT` (начиная с С++17)                                   |
| [[is_nothrow_invocable\|is_nothrow_invocable_r <RT, T, Args.. .>]]                | Может использоваться как вызываемый объект для `Args...`, с возвращаемым типом `RT` с гарантией отсутствия исключений (начиная с С++17) |
| [[invoke_result\|invoke_result <T, Args...>]]                                     | Возвращаемый тип при использовании в качестве вызываемого объекта для `Args...` (начиная с С++17)                                       |
| [[result_of\|result_of <F, ArgTypes>]]                                            | Возвращаемый тип при вызове `F` с типами аргументов `ArgTypes` (не рекомендовано, начиная с C++17)                                      |




















