
[[#Стандартные утилиты для работы с типами|Стандартные утилиты для работы с типами]] Г
1. [[#Использование свойств типов|Использование свойств типов]] Г.1
	1. [[#std integral_constant и std bool_constant|std::integral_constant и std::bool_constant]] Г.1.1
	2. [[#Что вы должны знать при использовании свойств|Что вы должны знать при использовании свойств]] Г.1.2
2. [[#Основные и составные категории типов|Основные и составные категории типов]] Г.2
	1. [[#Проверка основных категорий типов|Проверка основных категорий типов]] Г.2.1









# Стандартные утилиты для работы с типами

Стандартная библиотека C++ в основном состоит из шаблонов, многие из которых опираются на различные методы, представленные и всесторонне рассмотренные в этой книге. По этой причине некоторые методы были “стандартизованы” в том смысле, что стандартная библиотека определяет несколько шаблонов для реализации библиотек с обобщенным кодом. Эти утилиты для работы с типами (свойства типов и другие вспомогательные шаблоны) перечислены и разъясняются здесь, в этом приложении.

Обратите внимание на то, что некоторые [[Реализация свойств типов#Реализация свойств типов|свойства типов требуют поддержки компилятора, в то время как другие могут быть реализованы в библиотеке только с помощью стандартных возможностей языка]].

# Использование свойств типов

В общем случае при использовании свойств типов необходимо включение заголовочного файла `<type_traits>`:
```c++
#include <type_traits>
```

Далее их применение зависит от того, дает свойство тип или значение.
>
> Если свойство дает тип, обратиться к нему можно следующим образом:
```c++
typename std::trait<...>::type
std::trait_t<...>                             // Начиная с C++14
```
>
> Если свойство дает значение, обратиться к нему можно следующим образом:
```c++
std::trait<...>::value
std::trait<...>()          // Неявное преобразование в его тип
std::trait_v<...>          // Начиная с С++17
```

Например:
```c++
#include <type_traits>
#include <iostream>

int main()
{
	int i = 42;
	std::add_const<int>::type c = i; // c — int const
	std::add_const_t<int> cl4 = i;   // Начиная с C++14
	static__assert(std::is_const<decltype(c)>::value,
					"с должна быть const");

	std::cout << std::boolalpha;
	std::cout << std::is_same<decltype(c), int const>::value // true
				<< '\n';
	std::cout << std::is_same_v<decltype(c), int const>
				<< '\n' ;                        // Начиная с C++17

	// Неявное преобразование в bool:
	if (std::is_same<decltype(с), int const> {})
	{
		std::cout << "Одинаковы \n";
	}
};
```

[[Шаблоны классов#Псевдонимы типов|способ определения `_t`-версии свойств]]
[[Шаблоны переменных#Шаблоны переменных|способ определения `_v`-версии свойств]].

## std::integral_constant и std::bool_constant

Все стандартные типы, дающие значение, являются производными от экземпляра вспомогательного шаблона класса `std::integral_constant`:
```c++
namespace std
{
	template<typename T, T val>
	struct integral_constant
	{
		static constexpr T value = val; // Значение свойства
		using value_type = T;           // Тип значения
		using type = integral_constant<T, val>;
		
		constexpr operator value_type() const noexcept
		{
			return value;
		}
		
		// Начиная с C++14:
		constexpr value_type operator()() const noexcept
		{
			return value;
		}
	};
};
```

Из приведенного шаблона видно следующее.
> 
> Можно использовать член `value_type` для запроса типа результата. Поскольку многие свойства, дающие значения, являются предикатами, `value_type` часто является простым `bool`.
> 
> Объекты с типами свойств имеют неявное преобразование типа в тип значения, производимый свойством типа.
> 
> В C++14 (и далее) объекты типа свойств являются также функциональными объектами (функторами), для которых “вызов функции” дает их значения.
> 
> Член `type` просто дает базовый экземпляр `integral constant`.

Если свойства дают булевы значения, то они также используют
```c++
namespace std
{
	template<bool В>
	using bool_constant = integral_constant<bool,B>; // Начиная с C++17
	using true_type = bool_constant<true>;
	using false_type = bool_constant<false>;
}
```

так что эти логические свойства наследуют `std::true_type`, если определенное свойство справедливо, и `std::false_type`, если нет. Это также означает, что соответствующие члены `value` равны `true` или `false`. Наличие различных типов для результирующих значений `true` и `false` позволяет нам прибегать к [[Перегрузка свойств типов#Диспетчеризация дескрипторов|диспетчеризации дескрипторов]], основанной на [[Реализация свойств типов#Свойства-предикаты|результатах свойств типа]].

Например:
```c++
#include <type_traits>
#include <iostream>

int main()
{
	using namespace std;
	cout << boolalpha;
	
	using MyType = int;
	cout << is_const<MyType>::value << ' \n';     // Выводит false
	
	using VT = is_const<MyType>::value_type;      // bool
	
	// integral_constant<bool, false>:
	using Т = is_const<MyType>::type;
	cout << is_same<VT, bool>::value << '\n':     // Выводит true
	cout << is_same<T, integral_constant<bool, false>>::value 
			<< '\n';                              // Выводит true
	cout << is_same<T, bool_constant<false>>::value // Выводит true
			<< '\n';                             // (не работает до C++17)
	
	auto ic = is_const<MyType>();                // Объект типа свойства
	cout << is_some<decltype(ic),
					is_const<int>>::value << '\n'; // true
	cout << ic() << '\n';                // Вызов функции (выводит false)

	static constexpr auto mytypeIsConst = is_const<MyType> {};
	
	if constexpr(mytypeIsConst)          // Проверка времени компиляции
	{                                    // начиная с С++17 => false
		...                              // Отброшенные инструкции
	}
	
	static_assert(!std::is_const<MyType> {},
					"МуТуре не должен быть константой");
}
```

Наличие различных типов для небулевых специализаций `integral_constant` полезно также в ряде контекстов метапрограммирования. [[Списки типов - template#Списки нетиповых параметров|Обсуждение аналогичного типа CTValue]] и его [[tuple (Кортежи)#Индексы кортежа|применение для доступа к элементу кортежа]].

## Что вы должны знать при использовании свойств

Говоря о применениях свойств, следует упомянуть о следующем.

> Свойства типов применяются непосредственно к типам, но [[decltуре|decltype]] позволяет нам также проверять свойства выражений, переменных и функций. Напомним, однако, что [[decltуре|decltype]] дает тип переменной или функции, только если сущность именована и не находится в лишних скобках; для любого прочего выражения эта конструкция дает тип, который отражает также категорию типа выражения. Например:
```c++
void foo(std::string&& s)
{
	// Проверка типа s:
	// false:
	std::is_lvalue_reference<decltype(s)>::value

	// true, согласно объявлению:
	std::is_rvalue_reference<decltype(s)>::value
	
	// Проверка категории значения s как выражения:
	// true, s используется как l-значение:
	std::is_lvalue_reference<decltype((s))>::value
	
	// false:
	std::is_rvalue_reference<decltype((s))>::value
}
```
> 
> [[decltуре#Запись типа выражения с помощью decltype|Подробности...]]
>
> Некоторые свойства для начинающего программиста могут демонстрировать [[Обобщенные библиотеки - template#Другие утилиты для реализации обобщенных библиотек|неинтуитивное поведение]].
> 
> Некоторые свойства предъявляют определенные требования или предусловия. Нарушение этих предусловий ведет к неопределенному поведению. [[Обобщенные библиотеки - template#Свойства типов|Некоторые примеры ...]].
>
> Многие свойства требуют [[Основные термины в области шаблонов#Полные и неполные типы|полных типов]]. Чтобы иметь возможность использовать их для неполных типов, мы иногда можем [[Обобщенные библиотеки - template#Откладывание вычислений|ввести шаблоны для того, чтобы отложить их вычисление]].
> 
> Иногда логические операторы `&&`, `||`, и `!` не могут использоваться для определения нового свойства типа, основанного на других свойствах типов.
> 
> Кроме того, работа со свойствами типов, которые могут давать сбои, может стать проблемой или по крайней мере привести к определенным недостаткам. По этой причине предоставляются специальные свойства, которые позволяют нам логически объединять булевы свойства типов. Подробнее об этом рассказывается в #разделе_Г_6.
> 
> Хотя стандартные шаблоны псевдонимов (заканчивающиеся `_t` или `_у`) часто удобны, они также имеют [[Реализация свойств типов#Повышение удобства свойств|недостатки, делающие их непригодными для использования в некоторых контекстах метапрограммирования]].

# Основные и составные категории типов

Начнем со стандартных свойств, которые проверяют основные и составные категории типов (см. рис. Г.1). В общем случае каждый тип принадлежит ровно к одной основной категории типа (белые элементы на рисунке). Составные категории типов объединяют основные категории типов в концепции более высокого уровня.

![[template_11.png]]
рис. Г.1. Основные и составные категории типов

## Проверка основных категорий типов

Этот раздел описывает утилиты, которые проверяют основную категорию данного типа. Для любого заданного типа ровно одна основная категория имеет статический член `value`, который имеет значение `true`. Результат не зависит от того, квалифицирован тип с помощью [[const|const]] или [[volatile]] (cv-квалифицированный).

Обратите внимание на то, что для типов [[size#std size_t|std::size_t]] и [[ptrdiff#std ptrdiff_t|std::ptrdiff_t]] свойство [[is_integral|is_integral<>]] дает значение `true`. Для типа [[max_align#std max_align_t|std::max_align_t]] то, какая из основных категорий типа выдаст `true`, зависит от реализации (т.е. это может быть целочисленный тип, тип с плавающей точкой или классовый тип). Язык определяет, что [[Вывод аргументов шаблона#Обобщенные лямбда-выражения|тип лямбда-выражения — это классовый тип]], поэтому применение [[is_class|is_class]] к этому типу дает значение `true`.

Таблица Г.1. Свойства для проверки основных категорий типов

| Свойство                                                                                       | Эффект                                                                               |
| ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| [[is_void#is_void\|is void<T>]]                                                                | Тип `void`                                                                           |
| [[is_integral#std is_integral\|is integral<T>]]                                                | Целочисленный тип (включая `bool`, `char`, `char16_t`, `char32_t`, `wchar_t`)        |
| [[is_floating_point\|is floating point<T>]]                                                    | Тип с плавающей точкой (`float`, `double`, `long double`)                            |
| [[is_array#std is_array\|is array<T>]]                                                         | Обычный массив (не тип [[Array#std array C++11\|std::array]])                        |
| [[is_pointer\|is pointer<T>]]                                                                  | Тип указателя (включая указатели на функции, но не указатели на нестатические члены) |
| [[is_null_pointer\|is null pointer<T>]]                                                        | Тип [[nullptr_t#nullptr\|nullptr]] (начиная с С++14)                                 |
| [[is_member_object_pointer#std is_member_object_pointer\|is member object pointer<T>]]         | Указатель на нестатический член-данное                                               |
| [[is_member_function_pointer#std is_member_function_pointer<>\|is member function pointer<T>]] | Указатель на нестатическую функцию-член                                              |
| [[is_lvalue_reference#std is_lvalue_reference\|is lvalue reference<T>]]                        | Ссылка на [[r-значение#l-значение\|l-значение]]                                      |
| [[is_rvalue_reference#std is_rvalue_reference\|is rvalue reference<T>]]                        | Ссылка на [[r-значение#r-значения\|r-значение]]                                      |
| [[is_enum#std is_enum\|is enum<T>]]                                                            | Тип перечисления                                                                     |
| [[is_class#std is_class\|is class<T>]]                                                         | Тип класса/структуры или лямбда-выражения, но не объединения                         |
| [[is_union#std is_union\|is union<T>]]                                                         | Тип объединения                                                                      |
| [[is_function#std is_function\|is function<T>]]                                                | Тип функции                                                                          |

[[is_void#is_void|std::is_void<T>::value]] 
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) `void`.
> 
> Например:
> 
```c++
is_void_v<void>                        // Дает true
is_void_v<void const>                  // Дает true
is_void_v<int>                         // Дает false
void f();
is_void_v<decltype(f)>                 // Дает false (f имеет тип функции)
is_void_v<decltype(f())>               // Дает true (возвращаемый тип f())
```

[[is_integral#std is_integral|std::is_integral<T>:rvalue]] 
>
> Дает `true`, если тип `T` представляет собой один из следующих (возможно, `cv`-квалифицированных) типов:
> 
> > `bool`;
> >
> > символьный тип (`char`, `signed char`, `unsigned char`, `char16_t`, `char32_t` или `wchar_t`);
> >
> > целочисленный тип (знаковые или беззнаковые варианты `short`, `int`, `long` или `long long`; включает [[size#std size_t|std::size_t]] и [[ptrdiff#std ptrdiff|std::ptrdiff_t]]).

[[is_floating_point#is_floating_point<T>|std: :is_floating_jpoint<T>: : value]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) `float`, `double` или `long double`.

[[is_array#std is_array|std::is_array<T>::value]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) тип массива.
> 
> Помните, что параметр, объявленный как массив (с длиной или без таковой) по правилам языка в действительности имеет тип указателя.
> 
> Обратите внимание на то, что класс [[Array#std array C++11|std::array<>]] является типом класса, а не массива.
> 
> Например:
```c++
is_array_v<int[]>                // Дает true
is_array_v<int[5]>               // Дает true
is_array_v<int*>                 // Дает false

void foo(int a[], int b[5], int* c)
{
	is_array_v<decltype(a)>      // Дает false (a имеет тип int*)
	is_array_v<decltype(b)>      // Дает false (b имеет тип int*)
	is_array_v<decltype(c)>      // Дает false (c имеет тип int*)
}
```
>
> [[Реализация свойств типов#Определение составных типов|Детали реализации рассмотрены ...]].

[[is_pointer#std is_pointer|std::is_pointer<T>:rvalue]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) указатель.
> 
> Сюда входят:
> 
> > указатели на статические/глобальные функции (и статические функции-члены);
> > параметры, объявленные как массивы (с длиной или без таковой) или типы функций.
>
> Сюда не. входят:
> 
> > типы указателей на члены (например, тип `&Х::m`, где `X` — классовый тип a `m` — нестатическая функция-член или нестатический член-данное);
> > 
> > тип [[nullptr_t#std nullptr_t|nullptr - std: :nullptr_t]].
>
> Например:
```c++
is_pointer_v<int>                          // Дает false
is_pointer_v<int*>                         // Дает true
is_pointer_v<int* const>                   // Дает true
is_pointer_v<int*&>                        // Дает false
is_pointer_v<decltype(nullptr)>            // Дает false

int* foo(int a[5], void(f)())
{
	is_pointer_v<decltype(a)>            // Дает true (тип a — int*)
	is_pointer_v<decltype(f)>            // Дает true (тип f — void(*)())
	is_pointer_v<decltype(foo)>          // Дает false
	is_pointer_v<decltype(&foo)>         // Дает true
	// Дает true (возвращаемый тип — int*):
	is_pointer_v<decltype(foo(a ,f))>
}
```
>
> [[Реализация свойств типов#Определение составных типов|Детали реализации ...]].

[[is_null_pointer#is_null_pointer<T>|std::is_null_pointer<T>::value]] 
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) [[nullptr_t|std::nullptr_t]], являющийся типом [[nullptr_t#nullptr|nullptr]].
> 
> Например:
```c++
is_null_pointer_v<decltype(nullptr)>            // Дает true
void* р = nullptr;
// Дает false (р не имеет тип std::nullptr_t):
is_null_pointer_v<decltype(р)>
```
>
. В стандарте, начиная с C++14.

[[is_member_object_pointer|std::is_member_object_pointer<T>::value]]
[[is_member_function_pointer|std::is_member_function_pointer<T>:rvalue]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) тип указателя на член (например, `int X::*` или `int (X::*) ()` для некоторого классового типа `X`).

[[is_lvalue_reference|std::is_lvalue_reference<T>::value]]
[[is_rvalue_reference|std::is_rvalue_reference<T>::value]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) тип ссылки на [[r-значение#l-значение|l-значение]] или ссылки на [[r-значение#r-значения|r-значение]] соответственно. Например:
```c++
is_lvalue_reference_v<int>           // Дает false
is_lvalue_reference_v<int&>          // Дает true
is_lvalue_reference_v<int&&>         // Дает false
is_lvalue_reference_v<void>          // Дает false

is_rvalue_reference_v<int>           // Дает false
is_rvalue_reference_v<int&>          // Дает false
is_rvalue_reference_v<int&&>         // Дает true
is_rvalue_reference_v<void>          // Дает false
```

> [[Реализация свойств типов#Определение составных типов|Детали реализации ... ]]

[[is_enum#std is_enum|std::is_enum<T>::value]]


