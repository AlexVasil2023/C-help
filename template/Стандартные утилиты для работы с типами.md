
[[#Стандартные утилиты для работы с типами|Стандартные утилиты для работы с типами]] Г
1. [[#Использование свойств типов|Использование свойств типов]] Г.1
	1. [[#std integral_constant и std bool_constant|std::integral_constant и std::bool_constant]] Г.1.1
	2. [[#Что вы должны знать при использовании свойств|Что вы должны знать при использовании свойств]] Г.1.2
2. [[#Основные и составные категории типов|Основные и составные категории типов]] Г.2
	1. [[#Проверка основных категорий типов|Проверка основных категорий типов]] Г.2.1
	2. [[#Проверка составных категорий типов|Проверка составных категорий типов]] Г.2.2
3. [[#Характеристики и операции над типами|Характеристики и операции над типами]] Г.3
	1. [[#Прочие характеристики типов|Прочие характеристики типов]] Г.3.1









# Стандартные утилиты для работы с типами

Стандартная библиотека C++ в основном состоит из шаблонов, многие из которых опираются на различные методы, представленные и всесторонне рассмотренные в этой книге. По этой причине некоторые методы были “стандартизованы” в том смысле, что стандартная библиотека определяет несколько шаблонов для реализации библиотек с обобщенным кодом. Эти утилиты для работы с типами (свойства типов и другие вспомогательные шаблоны) перечислены и разъясняются здесь, в этом приложении.

Обратите внимание на то, что некоторые [[Реализация свойств типов#Реализация свойств типов|свойства типов требуют поддержки компилятора, в то время как другие могут быть реализованы в библиотеке только с помощью стандартных возможностей языка]].

# Использование свойств типов

В общем случае при использовании свойств типов необходимо включение заголовочного файла `<type_traits>`:
```c++
#include <type_traits>
```

Далее их применение зависит от того, дает свойство тип или значение.
>
> Если свойство дает тип, обратиться к нему можно следующим образом:
```c++
typename std::trait<...>::type
std::trait_t<...>                             // Начиная с C++14
```
>
> Если свойство дает значение, обратиться к нему можно следующим образом:
```c++
std::trait<...>::value
std::trait<...>()          // Неявное преобразование в его тип
std::trait_v<...>          // Начиная с С++17
```

Например:
```c++
#include <type_traits>
#include <iostream>

int main()
{
	int i = 42;
	std::add_const<int>::type c = i; // c — int const
	std::add_const_t<int> cl4 = i;   // Начиная с C++14
	static__assert(std::is_const<decltype(c)>::value,
					"с должна быть const");

	std::cout << std::boolalpha;
	std::cout << std::is_same<decltype(c), int const>::value // true
				<< '\n';
	std::cout << std::is_same_v<decltype(c), int const>
				<< '\n' ;                        // Начиная с C++17

	// Неявное преобразование в bool:
	if (std::is_same<decltype(с), int const> {})
	{
		std::cout << "Одинаковы \n";
	}
};
```

[[Шаблоны классов#Псевдонимы типов|способ определения `_t`-версии свойств]]
[[Шаблоны переменных#Шаблоны переменных|способ определения `_v`-версии свойств]].

## std::integral_constant и std::bool_constant

Все стандартные типы, дающие значение, являются производными от экземпляра вспомогательного шаблона класса `std::integral_constant`:
```c++
namespace std
{
	template<typename T, T val>
	struct integral_constant
	{
		static constexpr T value = val; // Значение свойства
		using value_type = T;           // Тип значения
		using type = integral_constant<T, val>;
		
		constexpr operator value_type() const noexcept
		{
			return value;
		}
		
		// Начиная с C++14:
		constexpr value_type operator()() const noexcept
		{
			return value;
		}
	};
};
```

Из приведенного шаблона видно следующее.
> 
> Можно использовать член `value_type` для запроса типа результата. Поскольку многие свойства, дающие значения, являются предикатами, `value_type` часто является простым `bool`.
> 
> Объекты с типами свойств имеют неявное преобразование типа в тип значения, производимый свойством типа.
> 
> В C++14 (и далее) объекты типа свойств являются также функциональными объектами (функторами), для которых “вызов функции” дает их значения.
> 
> Член `type` просто дает базовый экземпляр `integral constant`.

Если свойства дают булевы значения, то они также используют
```c++
namespace std
{
	template<bool В>
	using bool_constant = integral_constant<bool,B>; // Начиная с C++17
	using true_type = bool_constant<true>;
	using false_type = bool_constant<false>;
}
```

так что эти логические свойства наследуют `std::true_type`, если определенное свойство справедливо, и `std::false_type`, если нет. Это также означает, что соответствующие члены `value` равны `true` или `false`. Наличие различных типов для результирующих значений `true` и `false` позволяет нам прибегать к [[Перегрузка свойств типов#Диспетчеризация дескрипторов|диспетчеризации дескрипторов]], основанной на [[Реализация свойств типов#Свойства-предикаты|результатах свойств типа]].

Например:
```c++
#include <type_traits>
#include <iostream>

int main()
{
	using namespace std;
	cout << boolalpha;
	
	using MyType = int;
	cout << is_const<MyType>::value << ' \n';     // Выводит false
	
	using VT = is_const<MyType>::value_type;      // bool
	
	// integral_constant<bool, false>:
	using Т = is_const<MyType>::type;
	cout << is_same<VT, bool>::value << '\n':     // Выводит true
	cout << is_same<T, integral_constant<bool, false>>::value 
			<< '\n';                              // Выводит true
	cout << is_same<T, bool_constant<false>>::value // Выводит true
			<< '\n';                             // (не работает до C++17)
	
	auto ic = is_const<MyType>();                // Объект типа свойства
	cout << is_some<decltype(ic),
					is_const<int>>::value << '\n'; // true
	cout << ic() << '\n';                // Вызов функции (выводит false)

	static constexpr auto mytypeIsConst = is_const<MyType> {};
	
	if constexpr(mytypeIsConst)          // Проверка времени компиляции
	{                                    // начиная с С++17 => false
		...                              // Отброшенные инструкции
	}
	
	static_assert(!std::is_const<MyType> {},
					"МуТуре не должен быть константой");
}
```

Наличие различных типов для небулевых специализаций `integral_constant` полезно также в ряде контекстов метапрограммирования. [[Списки типов - template#Списки нетиповых параметров|Обсуждение аналогичного типа CTValue]] и его [[tuple (Кортежи)#Индексы кортежа|применение для доступа к элементу кортежа]].

## Что вы должны знать при использовании свойств

Говоря о применениях свойств, следует упомянуть о следующем.

> Свойства типов применяются непосредственно к типам, но [[decltуре|decltype]] позволяет нам также проверять свойства выражений, переменных и функций. Напомним, однако, что [[decltуре|decltype]] дает тип переменной или функции, только если сущность именована и не находится в лишних скобках; для любого прочего выражения эта конструкция дает тип, который отражает также категорию типа выражения. Например:
```c++
void foo(std::string&& s)
{
	// Проверка типа s:
	// false:
	std::is_lvalue_reference<decltype(s)>::value

	// true, согласно объявлению:
	std::is_rvalue_reference<decltype(s)>::value
	
	// Проверка категории значения s как выражения:
	// true, s используется как l-значение:
	std::is_lvalue_reference<decltype((s))>::value
	
	// false:
	std::is_rvalue_reference<decltype((s))>::value
}
```
> 
> [[decltуре#Запись типа выражения с помощью decltype|Подробности...]]
>
> Некоторые свойства для начинающего программиста могут демонстрировать [[Обобщенные библиотеки - template#Другие утилиты для реализации обобщенных библиотек|неинтуитивное поведение]].
> 
> Некоторые свойства предъявляют определенные требования или предусловия. Нарушение этих предусловий ведет к неопределенному поведению. [[Обобщенные библиотеки - template#Свойства типов|Некоторые примеры ...]].
>
> Многие свойства требуют [[Основные термины в области шаблонов#Полные и неполные типы|полных типов]]. Чтобы иметь возможность использовать их для неполных типов, мы иногда можем [[Обобщенные библиотеки - template#Откладывание вычислений|ввести шаблоны для того, чтобы отложить их вычисление]].
> 
> Иногда логические операторы `&&`, `||`, и `!` не могут использоваться для определения нового свойства типа, основанного на других свойствах типов.
> 
> Кроме того, работа со свойствами типов, которые могут давать сбои, может стать проблемой или по крайней мере привести к определенным недостаткам. По этой причине предоставляются специальные свойства, которые позволяют нам логически объединять булевы свойства типов. Подробнее об этом рассказывается в #разделе_Г_6.
> 
> Хотя стандартные шаблоны псевдонимов (заканчивающиеся `_t` или `_у`) часто удобны, они также имеют [[Реализация свойств типов#Повышение удобства свойств|недостатки, делающие их непригодными для использования в некоторых контекстах метапрограммирования]].

# Основные и составные категории типов

Начнем со стандартных свойств, которые проверяют основные и составные категории типов (см. рис. Г.1). В общем случае каждый тип принадлежит ровно к одной основной категории типа (белые элементы на рисунке). Составные категории типов объединяют основные категории типов в концепции более высокого уровня.

![[template_11.png]]
рис. Г.1. Основные и составные категории типов

## Проверка основных категорий типов

Этот раздел описывает утилиты, которые проверяют основную категорию данного типа. Для любого заданного типа ровно одна основная категория имеет статический член `value`, который имеет значение `true`. Результат не зависит от того, квалифицирован тип с помощью [[const|const]] или [[volatile]] (cv-квалифицированный).

Обратите внимание на то, что для типов [[size#std size_t|std::size_t]] и [[ptrdiff#std ptrdiff_t|std::ptrdiff_t]] свойство [[is_integral|is_integral<>]] дает значение `true`. Для типа [[max_align#std max_align_t|std::max_align_t]] то, какая из основных категорий типа выдаст `true`, зависит от реализации (т.е. это может быть целочисленный тип, тип с плавающей точкой или классовый тип). Язык определяет, что [[Вывод аргументов шаблона#Обобщенные лямбда-выражения|тип лямбда-выражения — это классовый тип]], поэтому применение [[is_class|is_class]] к этому типу дает значение `true`.

Таблица Г.1. Свойства для проверки основных категорий типов

| Свойство                                                                                       | Эффект                                                                               |
| ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| [[is_void#is_void\|is void<T>]]                                                                | Тип `void`                                                                           |
| [[is_integral#std is_integral\|is integral<T>]]                                                | Целочисленный тип (включая `bool`, `char`, `char16_t`, `char32_t`, `wchar_t`)        |
| [[is_floating_point\|is floating point<T>]]                                                    | Тип с плавающей точкой (`float`, `double`, `long double`)                            |
| [[is_array#std is_array\|is array<T>]]                                                         | Обычный массив (не тип [[Array#std array C++11\|std::array]])                        |
| [[is_pointer\|is pointer<T>]]                                                                  | Тип указателя (включая указатели на функции, но не указатели на нестатические члены) |
| [[is_null_pointer\|is null pointer<T>]]                                                        | Тип [[nullptr_t#nullptr\|nullptr]] (начиная с С++14)                                 |
| [[is_member_object_pointer#std is_member_object_pointer\|is member object pointer<T>]]         | Указатель на нестатический член-данное                                               |
| [[is_member_function_pointer#std is_member_function_pointer<>\|is member function pointer<T>]] | Указатель на нестатическую функцию-член                                              |
| [[is_lvalue_reference#std is_lvalue_reference\|is lvalue reference<T>]]                        | Ссылка на [[r-значение#l-значение\|l-значение]]                                      |
| [[is_rvalue_reference#std is_rvalue_reference\|is rvalue reference<T>]]                        | Ссылка на [[r-значение#r-значения\|r-значение]]                                      |
| [[is_enum#std is_enum\|is enum<T>]]                                                            | Тип перечисления                                                                     |
| [[is_class#std is_class\|is class<T>]]                                                         | Тип класса/структуры или лямбда-выражения, но не объединения                         |
| [[is_union#std is_union\|is union<T>]]                                                         | Тип объединения                                                                      |
| [[is_function#std is_function\|is function<T>]]                                                | Тип функции                                                                          |

[[is_void#is_void|std::is_void<T>::value]] 
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) `void`.
> 
> Например:
> 
```c++
is_void_v<void>                        // Дает true
is_void_v<void const>                  // Дает true
is_void_v<int>                         // Дает false
void f();
is_void_v<decltype(f)>                 // Дает false (f имеет тип функции)
is_void_v<decltype(f())>               // Дает true (возвращаемый тип f())
```

[[is_integral#std is_integral|std::is_integral<T>:rvalue]] 
>
> Дает `true`, если тип `T` представляет собой один из следующих (возможно, `cv`-квалифицированных) типов:
> 
> > `bool`;
> >
> > символьный тип (`char`, `signed char`, `unsigned char`, `char16_t`, `char32_t` или `wchar_t`);
> >
> > целочисленный тип (знаковые или беззнаковые варианты `short`, `int`, `long` или `long long`; включает [[size#std size_t|std::size_t]] и [[ptrdiff#std ptrdiff|std::ptrdiff_t]]).

[[is_floating_point#is_floating_point<T>|std: :is_floating_jpoint<T>: : value]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) `float`, `double` или `long double`.

[[is_array#std is_array|std::is_array<T>::value]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) тип массива.
> 
> Помните, что параметр, объявленный как массив (с длиной или без таковой) по правилам языка в действительности имеет тип указателя.
> 
> Обратите внимание на то, что класс [[Array#std array C++11|std::array<>]] является типом класса, а не массива.
> 
> Например:
```c++
is_array_v<int[]>                // Дает true
is_array_v<int[5]>               // Дает true
is_array_v<int*>                 // Дает false

void foo(int a[], int b[5], int* c)
{
	is_array_v<decltype(a)>      // Дает false (a имеет тип int*)
	is_array_v<decltype(b)>      // Дает false (b имеет тип int*)
	is_array_v<decltype(c)>      // Дает false (c имеет тип int*)
}
```
>
> [[Реализация свойств типов#Определение составных типов|Детали реализации рассмотрены ...]].

[[is_pointer#std is_pointer|std::is_pointer<T>:rvalue]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) указатель.
> 
> Сюда входят:
> 
> > указатели на статические/глобальные функции (и статические функции-члены);
> > параметры, объявленные как массивы (с длиной или без таковой) или типы функций.
>
> Сюда не. входят:
> 
> > типы указателей на члены (например, тип `&Х::m`, где `X` — классовый тип a `m` — нестатическая функция-член или нестатический член-данное);
> > 
> > тип [[nullptr_t#std nullptr_t|nullptr - std: :nullptr_t]].
>
> Например:
```c++
is_pointer_v<int>                          // Дает false
is_pointer_v<int*>                         // Дает true
is_pointer_v<int* const>                   // Дает true
is_pointer_v<int*&>                        // Дает false
is_pointer_v<decltype(nullptr)>            // Дает false

int* foo(int a[5], void(f)())
{
	is_pointer_v<decltype(a)>            // Дает true (тип a — int*)
	is_pointer_v<decltype(f)>            // Дает true (тип f — void(*)())
	is_pointer_v<decltype(foo)>          // Дает false
	is_pointer_v<decltype(&foo)>         // Дает true
	// Дает true (возвращаемый тип — int*):
	is_pointer_v<decltype(foo(a ,f))>
}
```
>
> [[Реализация свойств типов#Определение составных типов|Детали реализации ...]].

[[is_null_pointer#is_null_pointer<T>|std::is_null_pointer<T>::value]] 
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) [[nullptr_t|std::nullptr_t]], являющийся типом [[nullptr_t#nullptr|nullptr]].
> 
> Например:
```c++
is_null_pointer_v<decltype(nullptr)>            // Дает true
void* р = nullptr;
// Дает false (р не имеет тип std::nullptr_t):
is_null_pointer_v<decltype(р)>
```
>
. В стандарте, начиная с C++14.

[[is_member_object_pointer|std::is_member_object_pointer<T>::value]]
[[is_member_function_pointer|std::is_member_function_pointer<T>:rvalue]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) тип указателя на член (например, `int X::*` или `int (X::*) ()` для некоторого классового типа `X`).

[[is_lvalue_reference|std::is_lvalue_reference<T>::value]]
[[is_rvalue_reference|std::is_rvalue_reference<T>::value]]
>
> Дает `true`, если тип `T` представляет собой (`cv`-квалифицированный) тип ссылки на [[r-значение#l-значение|l-значение]] или ссылки на [[r-значение#r-значения|r-значение]] соответственно. Например:
```c++
is_lvalue_reference_v<int>           // Дает false
is_lvalue_reference_v<int&>          // Дает true
is_lvalue_reference_v<int&&>         // Дает false
is_lvalue_reference_v<void>          // Дает false

is_rvalue_reference_v<int>           // Дает false
is_rvalue_reference_v<int&>          // Дает false
is_rvalue_reference_v<int&&>         // Дает true
is_rvalue_reference_v<void>          // Дает false
```
>
> [[Реализация свойств типов#Определение составных типов|Детали реализации ... ]]

[[is_enum#std is_enum|std::is_enum<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) тип перечисления. Применим как к перечислениям с областью видимости, так и к перечислениям без области видимости.
> 
> [[Реализация свойств типов#Обнаружение типов перечислений|Детали реализации приведены тут...]].

[[is_class|std::is_class<T>::value]] 
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) классовый тип, объявленный с использованием ключевого слова `class` или `struct`, включая тип, сгенерированный инстанцированием шаблона класса. Обратите внимание — язык гарантирует, что [[Вывод аргументов шаблона#Обобщенные лямбда-выражения|тип лямбда-выражения представляет собой классовый тип]].
> 
> Дает `false` для объединений, типов перечислений с областью видимости (несмотря на объявление `enum class`), [[nullptr_t|std::nullptr_t]] и любых прочих типов.
> 
> Например:
```c++
is_class_v<int>                        // Дает false
is_class_v<std::string>                // Дает true
is_class_v<std::string const>          // Дает true
is_class_v<std::string&>               // Дает false
auto 11 = [] {};
// Дает true (лямбда-выражение является объектом класса)
is_class_v<decltype(11)>
```
>
> [[Реализация свойств типов#Обнаружение типов классов|Детали реализации рассмотрены тут...]]

[[is_union|std::is_union<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) тип объединения [[union|union]], включая объединение, генерируемое из шаблона класса, который является шаблоном объединения.

[[is_function|std::is_function<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой (`cv`-квалифицированный) тип функции. Дает `false` для типа указателя на функцию, типа лямбда-выражения или любого другого типа.
> 
> Помните, что параметр, объявленный как тип функции, по правилам языка в действительности имеет тип указателя.
> 
> Например:
```c++
void foo(void(f)())
{
	// Дает false (f имеет тип void(*)()):
	is_function_v<decltype(f)>
	is_function_v<decltype(foo)>         // Дает true
	is_function_v<decltype(&foo)>        // Дает false
	// Дает false (для возвращаемого типа):
	is_function_v<decltype(foo(f))>
}
```
>
> [[Реализация свойств типов#Идентификация типов функций|Детали реализации приведены тут...]]

## Проверка составных категорий типов

Рассматриваемые далее утилиты позволяют определить, принадлежит ли тип к более широкой категории типов, которая является объединением некоторых основных категорий типов. Составные категории типов не образуют строгого деления: тип может принадлежать к нескольким составным категориям одновременно (например, тип указателя является одновременно и скалярным, и составным). И вновь `cv`-квалификация ([[const|const]] и [[volatile|volatile]]) при классификации типа не учитывается.

Таблица Г.2. Свойства для проверки составных категорий типов

| Свойство                                    | Эффект                                                                                                                                                                   |
| ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [[is_reference\|is reference<T>]]           | Ссылка на [[r-значение#l-значение\|l-значение]] или ссылка на [[r-значение#r-значения\|r-значение]]                                                                      |
| [[is_member_pointer\|is_member_pointer<T>]] | Указатель на нестатический член                                                                                                                                          |
| [[is_arithmetic\|is arithmetic<T>]]         | Целочисленный тип (включая `bool` и символьные типы) или тип с плавающей точкой                                                                                          |
| [[is_fundamental\|is_fundamental]]          | `void`, целочисленный тип (включая `bool` и символьные типы), тип с плавающей точкой или [[nullptr_t#std nullptr_t\|std::nullptr_t]]                                     |
| [[is_scalar\|is_scalar<T>]]                 | Целочисленный тип (включая `bool` и символьные типы), тип с плавающей точкой, перечисление, указатель, указатель на член или [[nullptr_t#std nullptr_t\|std::nullptr_t]] |
| [[is_object\|is_object<T>]]                 | Любой тип, за исключением `void`, функции или ссылки                                                                                                                     |
| [[is_compound\|is_compound<T>]]             | Противоположность [[is_fundamental\|is_fundamental<T>]]: массив, перечисление, объединение, класс, функция, ссылка, указатель или указатель на член                      |

[[is_reference|std::is_reference<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой ссылочный тип.
> 
> Тоже, что и [[is_lvalue_reference|is_lvalue_reference_v<T>]] || [[is_rvalue_reference|is_rvalue_reference_v<T>]].
> 
• [[Реализация свойств типов#Определение составных типов|Детали реализации приведены тут...]]

[[is_member_pointer|std::is_member_pointer<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой любой тип указателя на член.
> 
• То же, что и !([[is_member_object_pointer|is_member_object_pointer_v<T>]] ||[[is_member_function_pointer|s_member_function_pointer_v<T>]]).

[[is_arithmetic|std::is_arithmetic<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой арифметический тип (`bool`, символьный тип, целочисленный тип или тип с плавающей точкой).
> 
> То же, что и [[is_integral|is_integral_v<T>]] II [[is_floating_point|is_floating_point_v<T>]].

[[is_fundamental|std::is fundamental<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой фундаментальный тип (арифметический тип, `void` или [[nullptr_t|std::nullptr_t]]).
> 
> То же, что и [[is_arithmetic|is_arithmetic_v<T>]] | | [[is_void|is_void_v<T>]] | | [[is_null_pointer|is_null_pointer_v<T>]].
> 
> То же, что и [[is_compound|is_compound_v<T>]]
>
> [[Реализация свойств типов#Определение фундаментальных типов|Подробности реализации рассмотрены при разработке шаблона IsFundaT]].

[[is_scalar|std::is_scalar<T>::value]]

> Дает `true`, если тип `Т` представляет собой “скалярный” тип.
>
> Тоже, что и [[is_arithmetic#is_arithmetic_v|is_arithmetic_v<T>]] || [[is_enum#is_enum_v|is_enum_v<T>]] || [[is_pointer#std is_pointer_v|is_pointer_v<T>]] || [[is_member_pointer#is_member_pointer_v|is_member_pointer_v<T>]] || [[is_null_pointer#is_null_pointer_v|is_null_pointer_v<T>]]>.

[[is_object|std::is_object<T>::value]]
>
> Дает `true`, если тип `T` описывает тип объекта.
> 
> То же, что и [[is_scalar#is_scalar_v|is_scalar_v<T>]] || [[is_array#std is_array_v|is_array_v<T>]] || [[is_class#std is_class_v|is_class_v<T>]] || [[is_union#std is_union_v|is_union_v<T>]]).
> 
> Тоже, что и ! ([[is_function#std is_function_v|is_function_v<T>]] || [[is_reference#std is_reference_v|is_reference_v<T>]] || [[is_void#is_void_v|is_void_v<T>]]).

[[is_compound|std::is_compound<T>::value]]
>
> Дает `true`, если тип `Т` представляет собой тип, составленный из других типов.
> 
> То же, что и ! [[is_fundamental#std is_fundamental_v|is_fundamental_v<T>]] 
>
> То же, что и [[is_enum#std is_enum_v|is_enum_v<T>]] || [[is_array#std is_array_v|is_array_v<T>]] || [[is_class#std is_class_v|is_class_v<T>]] || [[is_union#std is_union_v|is_union_v<T>]] || [[is_reference#std is_reference_v|is_reference_v<T>]] || [[is_pointer#std is_pointer_v|is_pointer_v<T>]] || [[is_member_pointer#is_member_pointer_v|is_member_pointer_v<T>]] || [[is_function#std is_function_v|is_function_v<T>]].

# Характеристики и операции над типами

Следующая группа свойств проверяет другие характеристики отдельных типов, а также наличие определенных операций (например, обмен значений), которые могут выполняться с ними.

## Прочие характеристики типов

Таблица Г.З. Свойства, проверяющие простые характеристики типов

| Свойство                                                                          | Эффект                                                                                                                                  |
| --------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| [[is_signed\|is_signed<T>]]                                                       | Знаковый арифметический тип                                                                                                             |
| [[is_unsigned\|is unsigned<T>]]                                                   | Беззнаковый арифметический тип                                                                                                          |
| [[is_const\|is const<T>]]                                                         | [[const\|const]]-квалифицированный тип                                                                                                  |
| [[is_volatile\|is volatile<T>]]                                                   | [[volatile\|volatile]] -квалифицированный тип                                                                                           |
| [[is_aggregate\|is_aggregate<T>]]                                                 | Агрегат (начиная с C++17)                                                                                                               |
| [[is_trivial\|is_trivial<T>]]                                                     | Скаляр, тривиальный класс или массивы этих типов                                                                                        |
| [[is_trivially_copyable\|is_trivially_copyable<T>]]                               | Скаляр, тривиально копируемый класс или массивы этих типов                                                                              |
| [[is_standard_layout\|is_standard_layout<T>]]                                     | Скаляр, класс со стандартной схемой размещения или массивы этих типов                                                                   |
| [[is_pod\|is_pod<T>]]                                                             | Простой старый тип данных (в котором можно копировать объекты с помощью `memcpy()`)                                                     |
| [[is_literal_type\|is_literal_type<T>]]                                           | Скаляр, ссылка, класс или массивы этих типов (не рекомендовано, начиная с C++17)                                                        |
| [[is_empty\|is_empty<T>]]                                                         | Класс без членов, виртуальных функций-членов или виртуальных базовых классов                                                            |
| [[is_polymorphic\|is_polymorphic<T>]]                                             | Класс с (производной) виртуальной функцией-членом                                                                                       |
| [[is_abstract\|is_abstract<T>]]                                                   | Абстрактный класс (как минимум одна чисто виртуальная функция)                                                                          |
| [[is_final\|is_final<T>]]                                                         | Финальный класс (класс, который нельзя наследовать; начиная с С++14)                                                                    |
| [[has_virtual_destructor\|std::has_virtual_destructor<T>]]                        | Класс с виртуальным деструктором                                                                                                        |
| [[has_unique_object_representations\|std::has_unique_object_representations <T>]] | Любые два объекта с одним и тем же значением имеют одинаковое представление в памяти (начиная с C++17)                                  |
| [[alignment_of\|alignment_of<T>]]                                                 | Эквивалентно `alignof (Т)`                                                                                                              |
| [[rank\|rank<T>]]                                                                 | Количество размерностей типа массива (или 0)                                                                                            |
| [[extent\|extent<T, I=0>]]                                                        | Длина по размерности I (или 0)                                                                                                          |
| [[underlying_type\|underlying_type<T>]]                                           | Базовый тип для типа перечисления                                                                                                       |
| [[is_invocable\|is_invocable<T,Args...>]]                                         | Может использоваться как вызываемый объект для `Args...` (начиная с С++17)                                                              |
| [[is_nothrow_invocable\|is_nothrow_invocable <T, Args...>]]                       | Может использоваться как вызываемый объект для `Args...` с гарантией отсутствия исключений<br>(начиная с С++17)                         |
| [[is_invocable#std is_invocable_r\|is_invocable_r <RT, T, Args...>]]              | Может использоваться как вызываемый объект для `Args...`, с возвращаемым типом `RT` (начиная с С++17)                                   |
| [[is_nothrow_invocable\|is_nothrow_invocable_r <RT, T, Args.. .>]]                | Может использоваться как вызываемый объект для `Args...`, с возвращаемым типом `RT` с гарантией отсутствия исключений (начиная с С++17) |
| [[invoke_result\|invoke_result <T, Args...>]]                                     | Возвращаемый тип при использовании в качестве вызываемого объекта для `Args...` (начиная с С++17)                                       |
| [[result_of\|result_of <F, ArgTypes>]]                                            | Возвращаемый тип при вызове `F` с типами аргументов `ArgTypes` (не рекомендовано, начиная с C++17)                                      |

[[is_signed|std::is_signed<T>:rvalue]]
>
> Дает `true`, если `Т` представляет собой знаковый арифметический тип (т.е. арифметический тип, который включает представление отрицательных значений: сюда входят такие типы, как (`signed`) `int`, `float`).
> 
> Для типа `bool` дает `false`.
> 
> Для типа char возвращаемое значение — `true` или `false` — зависит от реализации.
> 
> Для всех неарифметических типов (включая типы [[is_signed|is_signed]] дает `false`.

[[is_unsigned|std::is_unsigned<T>:rvalue]]
>
> Дает `true`, если `T` представляет собой беззнаковый арифметический тип (т.е. арифметический тип, который не включает представление отрицательных значений; сюда входят такие типы, как `unsigned int` и `bool`).
> 
> Для типа `char` возвращаемое значение — `true` или `false` — зависит от реализации.
> 
> Для всех неарифметических типов (включая типы [[is_unsigned|is_unsigned]] дает `false`.

[[is_const|std::is_const<T>::value]]
>
> Дает `true`, если тип квалифицирован как [[const|const]].
> 
> Обратите внимание на то, что константный указатель является [[const|const]]-квалифицированным типом, в то время как неконстантный указатель (или ссылка на константный тип) не является [[const|const]]-квалифицированным типом. Например:
```c++
is_const<int* const>::value // true
is_const<int const*>::value // false
is_const<int const&>::value // false
```
>
> Язык определяет массивы как [[const|const]]-квалифицированные, если тип элемента является [[const|const]]-квалифицированным. Например:
```c++
is_const<int[3]>::value            // false
is_const<int const[3]>::value      // true
is_const<int[]>::value             // false
is_const<int const[]>::value       // true
```

[[is_volatile|std::is_volatile<T>::value]]
>
> Дает true, если тип [[volatile|volatile]]-квалифицирован.
> 
> Обратите внимание на то, что [[volatile|volatile]]-указатель имеет [[volatile|volatile]]- квалифицированный тип, в то время как указатель или ссылка на [[volatile|volatile]] тип, но сами не являющиеся [[volatile|volatile]], не являются [[volatile|volatile]]- квалифицированными. Например:
```c++
is_volatile<int* volatile>::value // true
is_volatile<int volatile*>::value // false
is_volatile<int volatile&>::value // false
```
>
> Язык определяет массив как [[volatile|volatile]]-квалифицированный, если тип элементов является [[volatile|volatile]]-квалифицированным. Например:
```c++
is_volatile<int[3]>::value                 // false
is_volatile<int volatile[3]>::value        // true
is_volatile<int[]>::value                  // false
is_volatile<int volatile[]>::value         // true
```

[[is_aggregate|std::is_aggregate<T>::value]]
>
> Дает `true`, если `T` является агрегатным типом (массив либо класс/структура/объединение, у которого нет пользовательского, явного или унаследованного конструктора, нет закрытых или защищенных нестатических членов-данных, нет виртуальных функций, а также нет виртуальных, закрытых или защищенных базовых классов).
> 
> Помогает выяснить, требуется ли список инициализации. Например:
```c++
template<typename Coll, typename... Т>
void insert(Coll& coll, T&& ... val)
{
	if constexpr(!std::is_aggregate_v<typename Coll::value_type>)
	{
		// Для агрегатов не годится:
		coll.emplace_back(std::forward<T>(val)...);
	}
	else
	{
		coll.emplace_back(typename
			Coll::value__type{std::forward<T>(val)...});
	}
}
```
>
> Требует, чтобы данный тип либо [[Основные термины в области шаблонов#Полные и неполные типы|был полным]] либо (`cv`- квалифицированным) `void`.
> 
> Доступно, начиная с C++17.

[[is_trivial|std::is_trivial<T>::value]]
>
> Дает `true`, если тип является “тривиальным” типом:
> > скалярный тип (целочисленный, с плавающей точкой, перечисление, указатель; см. выше свойство [[is_scalar|is_scalar()]] );
> > 
> > тип тривиального класса (класс, не имеющий виртуальных функций, виртуальных базовых классов, (косвенных) пользовательских конструкторов по умолчанию, копирующих/перемещающих конструкторов, копирующих/перемещающих операторов присваивания или деструкторов, инициализаторов для нестатических членов-данных, членов, объявленных как [[volatile|volatile]], а также нетривиальных членов);
> > 
> > массив таких типов;
> > 
> > а также `cv`-квалифицированные версии этих типов.­
> >
> Дает `true`, если [[is_trivially_copyable|is_trivially_copyable_v<T>]] дает `true`, и существует тривиальный конструктор по умолчанию.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], либо (`cv`- квалифицированным) `void`.

[[is_trivially_copyable|std::is_trivially_copyable<T>:rvalue]]
>
> Дает `true`, если тип является “тривиально копируемым” типом:
> >
> > скалярный тип (целочисленный, с плавающей точкой, перечисление, указатель; см. выше свойство [[is_scalar|is_scalar()]] );
> > 
> > тип тривиального класса (класс, не имеющий виртуальных функций, виртуальных базовых классов, (косвенных) пользовательских конструкторов по умолчанию, копирующих/перемещающих конструкторов, копирующих/перемещающих операторов присваивания или деструкторов, инициализаторов для нестатических членов-данных, членов, объявленных как [[volatile|volatile]], а также нетривиальных членов);
> > 
> > массив таких типов;
> > 
> > а также `cv`-квалифицированные версии этих типов.
> >
> Дает то же значение, что и [[is_trivial|is_trivial_v<Т>]], за исключением того, что может дать `true` для типа класса без тривиального конструктора по умолчанию.
> 
> В отличие от [[is_standard_layout|is_standard_layout<>]], [[volatile|volatile]]-члены не допускаются, ссылки разрешены, члены могут иметь различный доступ, а также члены могут быть распределены среди различных (базовых) классов.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], либо (`cv`- квалифицированным) `void`.

[[is_standard_layout|std::is_standard_layout<T>:rvalue]]
>
> Дает `true`, если тип имеет стандартную схему размещения, что, например,упрощает обмен значений данного типа с другими языками:
> > скалярный тип (целочисленный, с плавающей точкой, перечисление, указатель; см. выше свойство [[is_scalar|is_scalar()]] );
> > 
> > тип со стандартной схемой размещения (класс, не имеющий виртуальных функций, виртуальных базовых классов, нестатических членов-ссылок, все нестатические члены находятся в одном и том же (базовом) классе, определенном с тем же доступом, все члены также являются типами со стандартной схемой размещения);
> > 
> > массив таких типов;
> > 
> > а также `cv`-квалифицированные версии этих типов.
> >
> В отличие от [[is_trivial|is_trivial<>]], [[volatile|volatile]]-члены разрешены, ссылки не разрешены, члены не могут иметь различный доступ, а также члены не могут быть распределены среди различных (базовых) классов.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип (для массивов — базовый тип) либо был полным]], либо (`cv`-квалифицированным) `void`.

[[is_pod|std::is_pod<T>::value]]
>
> Дает `true`, если `T` представляет собой простой старый тип данных (plain old datatype — POD).
> 
> Объекты таких типов могут копироваться путем копирования их памяти (например с помощью `memcpy()` ).
> 
> То же, что и [[is_trivial|is_trivial_t<T>]] && [[is_standard_layout|is_standard_layout_v<T>]].
>
> Дает `false` для:
> > 
> > классов, не имеющих тривиального конструктора по умолчанию, копирующего/перемещающего конструктора, копирующего/перемещающего присваивания или деструктора;
> > 
> > классов, имеющих виртуальные члены или виртуальные базовые классы;
> > 
> > классов, имеющих [[volatile|volatile]]-члены или члены-ссылки;
> > 
> > классов, которые имеют члены в различных (базовых) классах или с различным доступом;
> > 
> > типов лямбда-выражений (именуемых типами замыканий);
> > 
> > функций;
> > 
> > void;
> > 
> > типов, составленных из перечисленных выше типов.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], либо (`cv`- квалифицированным) `void`.

[[is_literal_type|std::is_literal_type<T>:rvalue]]
>
> Дает `true`, если данный тип является корректным возвращаемым типом для [[constexpr|constexpr]]-функции (что в особенности исключает любой тип, требующий нетривиального уничтожения).
> 
> Дает `true`, если `T` является литеральным типом:
> >
> > скалярный тип (целочисленный, с плавающей точкой, перечисление, указатель; см. выше свойство [[is_scalar|is_scalar()]]);
> > 
> > ссылка;
> > 
> > тип класса с по меньшей мере одним [[constexpr|constexpr]]-конструктором, который не является копирующим/перемещающим конструктором, в каждом базовом классе, не имеющем пользовательского или виртуального деструктора в любом (базовом) классе или члене, и в котором каждая инициализация нестатического члена-данного является константным выражением;
> > 
> > массив таких типов.
>
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], либо (`cv`- квалифицированным) `void`.
>
> Обратите внимание на то, что, начиная со стандарта C++17, это свойство не рекомендуется к употреблению, поскольку “оно слишком слабое, чтобы содержательно использовать его в обобщенном коде. Что действительно необходимо — это возможность знать, что конкретное конструирование будет приводить к константной инициализации".

[[is_empty|std::is_empty<T>::value]]
>
> Дает `true`, если тип `Т` является типом класса (но не объединения), объекты которого не содержат данных.
> 
> Дает `true`, если `Т` определен как `class` или `struct`, у которого
> >
> > - нет нестатических членов-данных, отличных от битовых полей нулевой длины;
> > - 
> > нет виртуальных функций-членов;
> > 
> > нет виртуальных базовых классов;
> > 
> > нет непустых базовых классов.
>
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], если это `class/struct` (неполный [[union|union]] разрешен).

[[is_polymorphic|std::is_polymorphic<T>::value]]
>
> Дает `true`, если `Т` представляет собой полиморфный тип класса (класс, объявляющий или наследующий виртуальную функцию).
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], либо не был ни` class`, ни `struct`.

[[is_abstract|std::is_abstract<T>::value]]
>
> Дает `true`, если `T` представляет собой абстрактный тип класса (класс, для которого не может быть создан ни один объект, так как он имеет по крайней мере одну чисто виртуальную функцию-член).
>
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], если это `class/struct` (неполный [[union|union]] разрешен).

[[is_final|std::is_final<T>::value]]
>
> Дает `true`, если `Т` — окончательный (`final`) тип класса (класс или объединение, который не может быть использован в качестве базового, так как объявлен как [[final|final]]).
> 
> Для всех типов, не являющихся классами/объединениями, такими как `int`, возвращает `false` (т.е. это не то же, как нечто наподобие `может быть наследован`).
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], либо не был `class/struct` или [[union|union]].
> 
> Доступно, начиная со стандарта C++14.

[[has_virtual_destructor|std::has_virtual_destructor<T>::value]]
>
> Дает `true`, если тип `Т` имеет виртуальный деструктор.
>
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип либо был полным]], если это `class/struct` (неполный [[union|union]] разрешен).

[[has_unique_object_representations|std::has_unique_object_representations<T>::value]]
>
> Дает `true`, если любые два объекта типа `Т` имеют одинаковое представление объектов в памяти. Следовательно, два идентичных значения всегда представлены с использованием одинаковых последовательностей значений байтов.
> 
> Объекты с таким свойством могут производить надежное хеш-значение путем хеширования связанной с ними последовательности байтов (отсутствует риск, что некоторые биты, не участвующие в значении объекта, могут отличаться от одного объекта к другому).
> 
> Требует, чтобы данный тип был [[Стандартные утилиты для работы с типами#Прочие характеристики типов|тривиально копируемым]] и либо [[Основные термины в области шаблонов#Полные и неполные типы|полным]], либо (`cv`-квалифицированным) `void` или массивом с неизвестными границами.
> 
> Доступно, начиная со стандарта C++17.

[[alignment_of|std::alignment_of<T>::value]] 
>
> Дает выравнивание объекта типа `Т` как значение типа [[size#std size_t|std::size_t]] (для массивов — типа элемента; для ссылок — типа, на который выполняется ссылка).
>
> То же, что и [[alignof|alignof(Т)]].
> 
> Это свойство было введено в С++11 до конструкции `alignof (...)`. Однако оно все еще востребовано, поскольку свойство может быть передано как тип класса, что может быть полезным для некоторых метапрограмм.
> 
> Требует, чтобы [[alignof|alignof (Т)]] было корректным выражением.
> 
> Используйте `aligned_union<>` для получения общего выравнивания нескольких типов.

[[rank|std::rank<T>::value]]
>
> Дает количество размерностей массива типа `Т` в виде значения типа [[size#std size_t|std::size_t]].
> 
> Дает `0` для всех прочих типов.
> 
> Указатели не имеют связанных с ними размерностей. Неопределенная граница в типе массива указывает размерность. (Как обычно, параметр функции, объявленный как тип массива, в действительности не имеет типа массива, так же как и тип [[Array|std::array]] не является типом массива). Например:
```c++
int а2[5][7];
rank_v<decltype(а2)>; // Дает 2
rank_v<int*>;         // Дает 0 (no array)
extern int p1[];
rank_v<decltype(pi)>; // Дает 1
```

[[extent|std::extent<T>::value]]
[[extent|std::extent<T, IDX>::value]]

> Дает размер первой или `IDX`-й размерности массива типа `Т` в виде значения типа [[size#std size_t|std::size_t]].

> Дает `0`, если `Т` не является массивом, размерность не существует, или размер данной размерности неизвестен.
> 
> [[Реализация свойств типов#Определение составных типов|Подробности реализации]].
```c++
int а2[5][7];
extent_v<decltype(a2)>;          // Дает 5
extent_v<decltype(a2), 0>;       // Дает 5
extent_v<decltype(a2), 1>;       // Дает 7
extent_v<decltype(a2), 2>;       // Дает 0
extent_v<int*>;                  // Дает 0
extern int p1[];
extent v<decltype(p1)>;          // Дает 0
```

[[underlying_type|std: : underlying_type<T>::type]]
>
> Дает базовый тип для типа перечисления `Т`.
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был полным типом]] перечисления. Для всех прочих типов имеет неопределенное поведение.

[[is_invocable|std::is_invocable<T, Args...>::value]]
[[is_nothrow_invocable|std::is_nothrow_invocable<T, Args...>::value]]
>
> Дает `true`, если `T` можно использовать для вызова с аргументами `Args...` (с гарантией отсутствия исключений).
> 
> Таким образом, мы можем использовать эти свойства, чтобы проверить, можем ли мы использовать вызов или [[invoke|std::invoke ()]] для данного вызываемого типа `Т` для аргументов `Args....` (Подробная информация о [[Обобщенные библиотеки - template#Вызываемые объекты|вызываемых объектах и std::invoke ()]])
> 
> Требует, чтобы все указанные [[Основные термины в области шаблонов#Полные и неполные типы|типы были полными]] или (`cv`-квалифицированным) `void`, или массивом с неизвестными границами. 
> 
> Например:
```c++
struct С
{
	bool operator()(int) const
	{
		return true;
	}
};

std::is_invocable<C>::value              // false
std::is_invocable<C, int>::value         // true
std::is_invocable<int*>::value           // false
std::is_invocable<int(*)()>::value       // true
```
>
> Доступно, начиная co стандарта C++17

[[is_invocable|std::is_invocable_r<RET_T, Т, Args...>::value]]
[[is_nothrow_invocable|std::is_nothrow_invocable_r<RET_T, T, Args...>::value]]
>
> Дает `true`, если `T` можно использовать для вызова с аргументами `Args...` (с гарантией отсутствия исключений) и возвращаемым значением, преобразуемым к типу `RET_T`.
> 
> Таким образом, эти свойства позволяют проверить, можем ли мы использовать вызов или [[invoke|std::invoke()]] для данного вызываемого типа `Т` для аргументов `Args...` и применить возвращаемое значение как `RET_T`. (Подробная информация о [[Обобщенные библиотеки - template#Вызываемые объекты|вызываемых объектах и std::invoke ()]])
> 
> Требует, чтобы все указанные [[Основные термины в области шаблонов#Полные и неполные типы|типы были полными]] или (`cv`-квалифицированным) `void`, или массивом с неизвестными границами.
> 
> Например:
```c++
struct С
{
	bool operator () (int) const
	{
		return true;
	}
};

std::is_invocable_r<bool, C, int>::value                  // true
std::is_invocable_r<int, C, long>::value                  // true
std::is_invocable_r<void, C, int>::value                  // true
std::is_invocable_r<char* , C, int>::value                // false
std::is_invocable_r<long, int(*)(int)>::value             // false
std::is_invocable_r<long, int (*) (int), int>::value      // true
std::is_invocable_r<long, int(*Hint), double>::value      // true
```
>
> Доступно, начиная co стандарта C++17.

[[invoke_result|std::invoke_result<T, Args...>::value]]
[[result_of|std::result_of<T, Args...>::value]]
>
> Дает возвращаемый тип вызываемого типа `Т`, вызванного с аргументами `Args...`.
>
> Обратите внимание на небольшие отличия в синтаксисе:
> >
> > В [[invoke_result|invoke_result<>]] вы должны передать в качестве параметров как вызываемый тип, так и типы аргументов.
> > 
> > В [[result_of|result_of<>]] вы должны передать “объявление функции” с использованием соответствующих типов.
>
> Если вызов невозможен, член `type` не определен, так что его использование является ошибкой (это позволяет использовать [[SFINAE#SFINAE|принцип SFINAE для отбрасывания шаблона функции с помощью использования свойства в ее объявлении]]).
> 
> Таким образом, мы можем использовать эти свойства для получения возвращаемого типа при использовании вызова или [[invoke|std::invoke()]] для данного вызываемого типа `Т` для аргументов `Args....` ([[Обобщенные библиотеки - template#Вызываемые объекты|Подробная информация о вызываемых объектах и std::invoke()]])
> 
> Требует, чтобы все указанные [[Основные термины в области шаблонов#Полные и неполные типы|типы были полными]] или (`cv`-квалифицированным) `void`, или массивом с неизвестными границами.
> 
> Свойство [[invoke_result|invoke_result<>]] доступно, начиная с С++17, и заменяет свойство [[result_of|result_of<>]], которое не рекомендовано к употреблению, начиная с С++17, поскольку [[invoke_result|invoke_result<>]] предоставляет определенные улучшения, такие как более простой синтаксис и разрешение `Т` быть абстрактным типом.
> 
> Например:
```c++
std::string foo(int);
using R0 = typename
			std::result_of<decltype(&foo)(int)>::type; // C++11
using R1 = std::result_of_t<decltype(&foo)(int)>;      // C++14
using R2 = std::invoke_result_t<decltype(foo), int>;   // C++17 

struct ABC
{
	virtual ~ABC() = 0;
	void operator()(int) const
	{
	}
	
	using T1 = typename
			std::result_of<ABC(int)>::type; // Ошибка: ABC - абстрактный
	using T2 = typename
			std::invoke_result<ABC,int>::type; // OK, начиная с C++17
```

[[Обобщенные библиотеки - template#Оборачивание вызовов функций|Полный пример...]]

Таблица Г.4. Свойства для проверки определенных операций

| Свойства                                                                       | Эффект                                                                                                                                         |
| ------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| [[is_constructible\|is constructible <T,Args...>]]                             | Можно инициализировать тип `Т` типами `Args`                                                                                                   |
| [[is_trivially_constructible\|is_trivially_constructible<T,Args...>]]          | Можно тривиально инициализировать тип `Т` типами Args                                                                                          |
| [[is_nothrow_constructible\|is_nothrow_constructible <T,Args...>]]             | Можно инициализировать тип `Т` типами `Args`, и эта операция не генерирует исключений                                                          |
| [[is_default_constructible\|is_default_constructible <T>]]                     | Можно инициализировать тип `Т` без аргументов                                                                                                  |
| [[is_trivially_default_constructible\|is_trivially_default_constructible <T>]] | Можно тривиально инициализировать тип `Т` без аргументов                                                                                       |
| [[is_nothrow_default_constructible\|is_nothrow_default_constructible <T>]]     | Можно инициализировать тип `Т` без аргументов, и эта операция не генерирует исключений                                                         |
| [[is_copy_constructible\|is_copy_constructible <T>]]                           | Тип `Т` можно копировать                                                                                                                       |
| [[is_trivially_copy_constructible\|is_trivially_copy_constructible <T>]]       | Тип `Т` можно тривиально копировать                                                                                                            |
| [[is_nothrow_copy_constructible\|is_nothrow_copy_constructible ]]              | Тип `Т` можно копировать, и эта операция не генерирует исключений                                                                              |
| [[is_move_constructible\|is_move_constructible <T>]]                           | Тип `T` можно перемещать                                                                                                                       |
| [[is_trivially_move_constructible\|is_trivially_move_constructible <T>]]       | Тип `Т` можно тривиально перемещать                                                                                                            |
| [[is_nothrow_move_constructible\|is_nothrow_move_constructible <T>]]           | Тип `Т` можно перемещать, и эта операция не генерирует исключений                                                                              |
| [[is_assignable\|is_assignable <T, T2>]]                                       | Можно присваивать тип `Т2` типу `Т`                                                                                                            |
| [[is_trivially_assignable\|is_trivially_assignable <T, T2>]]                   | Можно тривиально присваивать тип `Т2` типу `Т`                                                                                                 |
| [[is_nothrow_assignable\|is_nothrow_assignable <T, T2>]]                       | Можно присваивать тип `Т2` типу `Т`, и эта операция не генерирует исключений                                                                   |
| `[[is_copy_assignable\|is_copy_assignable <T>]]                                | Можно выполнять копирующее присваивание `Т`                                                                                                    |
| [[is_trivially_copy_assignable\|is_trivially_copy_assignable <T>]]             | Можно выполнять тривиальное копирующее присваивание `Т`                                                                                        |
| [[is_nothrow_copy_assignable]]                                                 | Можно выполнять копирующее присваивание `Т`, и эта операция не генерирует исключений                                                           |
| [[is_move_assignable\|is_move_assignable <T>]]                                 | Можно выполнять перемещающее присваивание `Т`                                                                                                  |
| [[is_trivially_move_assignable\|is_trivially_move_assignable <T>]]             | Можно выполнять тривиальное перемещающее присваивание `Т`                                                                                      |
| [[is_nothrow_move_assignable\|is_nothrow_move_assignable <T>]]                 | Можно выполнять перемещающее присваивание `Т`, и эта операция не генерирует исключений                                                         |
| [[is_destructible\|is destructible<T>]]                                        | Можно уничтожать `Т`                                                                                                                           |
| [[is_trivially_destructible\|is_trivially_destructible <T>]]                   | Можно тривиально уничтожать `Т`                                                                                                                |
| [[is_nothrow_destructible\|is_nothrow_destructible <T>]]                       | Можно уничтожать `Т`, и эта операция не генерирует исключений                                                                                  |
| [[is_swappable\|is_swappable <T>]]                                             | Для этого типа можно вызывать [[swap\|swap()]] (начиная с С++17)                                                                               |
| [[is_nothrow_swappable\|is_nothrow_swappable <T>]]                             | Для этого типа можно вызывать [[swap\|swap()]], и эта операция не генерирует исключений (начиная с С++17)                                      |
| [[is_swappable_with\|is_swappable_with <T, T2>]]                               | Для этих двух типов с указанной категорией значений можно вызывать [[swap\|swap()]] (начиная с С++17)                                          |
| [[is_nothrow_swappable_with\|is_nothrow_swappable_with <T, T2>]]               | Для этих двух типов с указанной категорией значений можно вызывать [[swap\|swap()]], и эта операция не генерирует исключений (начиная с C++17) |

В таблице Г.4 перечислены свойства типов, которые позволяют нам проверять некоторые определенные операции. Формы с `is_trivially_...` дополнительно проверяют, все ли (суб)операции, вызываемые для объекта, членов или базовых классов, являются тривиальными (не определяемыми пользователем и не виртуальными). Формы с `is_nothrow_...` дополнительно проверяют, гарантируется ли отсутствие генерации исключений данной операцией. Обратите внимание на то, что все проверки `is_..._constructible` неявно выполняют соответствующие проверки `is_..._destructible`. Например:
```c++
#include <iostream>

class С
{
	public:
		С()            // Конструктор по умолчанию не имеет noexcept
		{
		}
		
		virtual ~C () = default; // Делает тип С нетривиальным
};

int main()
{
	using namespace std;
	cout << is_default_constructible_v<C> << '\n';             // true
	cout << is_trivially_default_constructible_v<C> << ' \n';  // false
	cout << is_nothrow_default_constructible_v<C> << '\n';     // false
	cout << is_copy_constructible_v<C> << '\n';                // true
	cout << is_trivially_copy_constructible_v<C> << '\n';      // true
	cout << is_nothrow_copy_constructible_v<C> << ' \n';       // true
	cout << is_destructible_v<C> << '\n';                      // true
	cout << is_trivially_destructible_v<C> << '\n';            // false
	cout << is_nothrow_destructible_v<C> << '\n';              // true
}
```

Из-за определения деструктора как виртуального все операции больше не являются тривиальными. А поскольку мы определяем конструктор по умолчанию без [[noexcept|noexcept]], он может генерировать исключения. Все другие операции по умолчанию гарантируют отсутствие исключений.
```c++
std::is_constructible<T, Args...>::value
std::is_trivially_constructible<T, Args...>::value
std::is_nothrow_constructible<T, Args...>::value
```

> Дает `true`, если объект типа `T` может быть инициализирован аргументами типов, задаваемых `Args...` (без использования нетривиальной операции или с гарантией отсутствия генерации исключений). Таким образом, следующий код должен быть корректен:
```c++
Т t(std::declval<Args>()...);
```
>
> Значение `true` подразумевает, что объект может быть соответствующим образом уничтожен (т.е.[[is_destructible| is_destructible_v<T>]], [[is_trivially_destructible|is_trivially_destructible_v<T>]] или соответственно [[is_nothrow_destructible|is_nothrow_destructible_v<T>]] дадут `true`).
> 
> Требует, чтобы все данные [[Основные термины в области шаблонов#Полные и неполные типы|типы были либо полными]], (`cv`-квалифицированным) `void`, либо массивами с неизвестными границами.
> 
> Например:
```c++
is_constructible_v<int>                                // true
is_constructible_v<int, int>                           // true
is_constructible_v<long, int>                          // true
is_constructible_v<int, void*>                         // false
is_constructible_v<void*, int>                         // false
is_constructible_v<char const*, std::string>           // false
is_constructible_v<std::string, char const*>           // true
is_constructible_v<std::string, char const*, int, int> // true
```

Обратите внимание на то, что [[is_convertible|is_convertible]] имеет иной порядок исходного и целевого типов.

```c++
std::is_default_constructible<T>::value
std::is_trivially_default_constructible<T>::value
std::is_nothrow_default_constructible<T>::value
```

> Дает `true`, если объект типа `T` может быть инициализирован без аргументов инициализации (без использования нетривиальной операции или с гарантией отсутствия генерации исключений).
> 
> То же, что и [[is_constructible|is_constructible_v<T>]], [[is_trivially_constructible|is_trivially_constructible_v<T>]] или [[is_nothrow_constructible|is_nothrow_constructible_v<T>]] соответственно.
> 
> Значение `true` подразумевает, что объект может быть соответствующим образом уничтожен (т.е. [[is_destructible|is_destructible_v<T>]], [[is_trivially_destructible|is_trivially_destructible_v<T>]] или соответственно [[is_nothrow_destructible|is_nothrow_destructible_v<T>]] дает `true`).
>
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был либо полным]], (`cv`- квалифицированным) `void` или массивом с неизвестными границами.

```c++
std::is_copy_constructible<T>::value
std::is_trivially_copy_constructible<T>::value
std::is_nothrow_copy_constructible<T>::value
```
>
> Дает `true`, если объект типа `T` может быть создан путем копирования другого значения типа `Т` (без использования нетривиальной операции или с гарантией отсутствия генерации исключений).
> 
> Дает `false`, если `Т` не является типом, на который можно ссылаться (`referenceable type`) ((`cv`-квалифицированный) `void` или тип функции, квалифицированный с помощью [[const|const]], [[volatile|volatile]], `&`, `&&`).
> 
> Указывает, является ли тип `Т` типом, накоторый можно ссылаться, так же как и [[is_constructible|is_constructible<T, T const&>::value]], [[is_trivially_constructible|is_trivially_constructible<Т, Т const &>::value]] или [[is_nothrow_constructible|is_nothrow_constructible<T, Т const &>::value]] соответственно.
>
> Чтобы выяснить, может ли объект типа `Т` быть сконструирован копированием [[r-значение#r-значения|r-значения]] типа `Т`, используйте [[is_constructible|is_constructible<T, Т &&>]] (и т.д.).
> 
> Значение `true` подразумевает, что объект может быть соответствующим образом уничтожен (т.е. [[is_destructible|is_destructible_v<T>]], [[is_trivially_destructible|is_trivially_destructible_v<T>]] или соответственно [[is_nothrow_destructible|is_nothrow_destructible_v<T>]] дает `true`).
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был полным]], (`cv`-квалифицированным) `void` либо массивом с неизвестной границей.
> 
> Например:
```c++
is_copy_constructible_v<int>                          // true
is_copy_constructible_v<void>                         // false
is_copy_constructible_v<std::unique_ptr<int>>         // false
is_copy_constructible_v<std::string>                  // true
is_copy_constructible_v<std::string&>                 // true
is_copy_constructible_v<std::string&&>                // false

// В отличие от:
is_constructible_v<std::string, std::string>          // true
is_constructible_v<std::string&, std::string&>        // true
is_constructible_v<std::string&&, std::string&&>      // true
```

```c++
std::is_move_constructible<T>::value
std::is_trivially_move_constructible<T>::value
std::is_nothrow_move_constructible<T>::value
```
>
> Дает `true`, если объект типа `T` может быть создан из [[r-значение#r-значения|r-значения]] типа `Т` (без использования нетривиальной операции или с гарантией отсутствия генерации исключений).
> 
> Дает `false`, если `Т` не является типом, на который можно ссылаться (`referenceable type`) ((`cv`-квалифицированный) `void` или тип функции, квалифицированный с помощью [[const|const]], [[volatile|volatile]], `&`, `&&`).
> 
> Указывает, является ли тип `T` типом, на который можно ссылаться, так же как и [[is_constructible|is_constructible<T, Т&&>::value]], [[is_trivially_constructible|is_trivially_constructible<Т,&&>::value]] или [[is_nothrow_constructible|is_nothrow_constructible<T,&&>::value]] соответственно.
> 
> Значение `true` подразумевает, что объект может быть соответствующим образом уничтожен (т.е. [[is_destructible|is_destructible_v<T>]], [[is_trivially_destructible|is_trivially_destructible_v<T>]] или соответственно [[is_nothrow_destructible|is_nothrow_destructible_v<T>]] дает `true`).
> 
> Заметьте, что нет никакого способа проверить, не генерируется ли исключение перемещающим конструктором без возможности вызова его непосредственно для объекта типа `Т`. Для конструктора недостаточно быть открытым и не удаленным; он также требует, чтобы соответствующий тип не являлся абстрактным классом (ссылки или указатели на абстрактные классы работают корректно).
> 
> [[Реализация свойств типов#Обнаружение операций, не генерирующих исключения|Подробности реализации]].
> 
> Например:
```c++
is_move_constructible_v<int>                        // true
is_move__constructible_v<void>                      // false
is_move_constructible_v<std::unique_ptr<int>>       // true
is_move_constructible_v<std::string>                // true
is_move_constructible_v<std::string&>               // true
is_move_constructible_v<std::string&&>              // true

// В отличие от:
is_constructible_v<std::string, std::string>        // true
is_constructible_v<std::string&, std::string&>      // true
is_constructible_v<std::string&&,std::string&&>     // true
```

```c++
std::is_assignable<TO, FROM>::value
std::is_trivially_assignable<TO, FROM>::value
std::is_nothrow_assignable<TO, FROM>::value
```
>
> Дает `true`, если объект типа `FROM` может быть присвоен объекту типа `ТО` (без использования нетривиальной операции или с гарантией отсутствия генерации исключений).
> 
> Требует, чтобы данный [[Основные термины в области шаблонов#Полные и неполные типы|тип был полным]], (`cv`-квалифицированным) `void`, или же массивом с неизвестной границей.
> 
> Обратите внимание на то, что [[is_assignable|is_assignable_v<>]] для первого типа, не являющегося ссылкой или классом, всегда дает `false`, поскольку такие типы производят [[r-значение#pr-значения|pr-значения]]. Таким образом, инструкция `42=77`; является некорректной. Однако для типов классов возможно присваивание [[r-значение|r-значениям]] при наличии соответствующего оператора присваивания (благодаря старому правилу о том, что неконстантные функции-члены могут вызываться для [[r-значение|г-значений]] типов классов).
> 
> Обратите внимание: [[is_convertible|is_convertible]] имеет иной порядок исходного и целевого типов.
> 
> Например:
```c++
is_assignable_v<int, int>                               // false
is_assignable_v<int&, int>                              // true
is_assignable_v<int&&, int>                             // false
is_assignable_v<int&, int&>                             // true
is_assignable_v<int&&, int&&>                           // false
is_assignable_v<int&, long&>                            // true
is_assignable_v<int&, void*>                            // false
is_assignable_v<void*, int>                             // false
is_assignable_v<void*, int&>                            // false
is_assignable_v<std::string, std::string>               // true
is_assignable_v<std::string&, std::string&>             // true
is_assignable_v<std::string&&, std::string&&>           // true
```










