
[[#Реализация свойств типов|Реализация свойств типов]] 19
1. [[#Пример суммирование последовательности|Пример: суммирование последовательности]] 19.1
	1. [[#Фиксированные свойства|Фиксированные свойства]] 19.1.1



# Реализация свойств типов

Шаблоны дают возможность параметризовать классы и функции для различных типов. Кажется весьма заманчивым вводить столько параметров шаблонов, сколько нужно для того, чтобы настроить каждый аспект поведения типа или алгоритма. Таким образом, наши “шаблонизированные” компоненты могли бы быть реализованы так, чтобы удовлетворять любым потребностям пользовательского кода. Однако с практической точки зрения нежелательно вводить большое количество параметров шаблонов для их максимально возможной параметризации. Необходимость указания всех соответствующих аргументов в пользовательском коде чрезмерно утомительна, а каждый дополнительный параметр шаблона усложняет контракт между компонентом и его клиентом.

К счастью, оказывается, что большинству дополнительных параметров можно назначить приемлемые значения по умолчанию. В ряде случаев дополнительные параметры полностью определяются несколькими основными параметрами и по этому могут быть вообще опущены. Для других параметров могут быть заданы значения по умолчанию, зависящие от основных параметров, которые отвечают нуждам большинства ситуаций, но тем не менее в ряде случаев все же должны заменяться реальными значениями. Некоторые параметры оказываются не связанными с основными параметрами, и в этом смысле сами являются основными параметрами.

Свойства (traits), или шаблоны свойств, являются теми программными устройствами C++, которые значительно облегчают управление множеством дополнительных параметров, появляющихся при разработке мощных шаблонов. В этой главе приведен ряд ситуаций, в которых они доказывают свою несомненную эффективность, а также демонстрируются различные методы разработки мощных и надежных компонентов для ваших собственных программ.

Большинство представленных здесь свойств доступны в той или иной форме в стандартной библиотеке C++. Однако для ясности мы часто представляем упрощенные реализации, которые опускают некоторые детали, имеющиеся в реализациях промышленного уровня (как, например, в стандартной библиотеке). По этой причине мы также используем нашу собственную схему именования, которая, однако, легко отображается на стандартные свойства.

# Пример: суммирование последовательности

Вычисление суммы последовательности значений — довольно тривиальная вычислительная задача. Однако эта простая на вид задача может служить прекрасным примером использования классов стратегий и свойств на разных уровнях.

## Фиксированные свойства


















