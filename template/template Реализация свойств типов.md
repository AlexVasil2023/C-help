
[[#Реализация свойств типов|Реализация свойств типов]] 19
1. [[#Пример суммирование последовательности|Пример: суммирование последовательности]] 19.1
	1. [[#Фиксированные свойства|Фиксированные свойства]] 19.1.1
	2. [[#Свойства-значения|Свойства-значения]] 19.1.2
	3. [[#Параметризованные свойства|Параметризованные свойства]] 19.1.3
2. [[#Стратегии и классы стратегий|Стратегии и классы стратегий]] 19.2
	1. [[#Различие между свойствами и стратегиями|Различие между свойствами и стратегиями]] 19.2.1
	2. [[#Шаблоны членов и шаблонные параметры шаблонов|Шаблоны членов и шаблонные параметры шаблонов]] 19.2.2
	3. [[#Комбинирование нескольких стратегий и/или свойств|Комбинирование нескольких стратегий и/или свойств]] 19.2.3
	4. [[#Накопление с обобщенными итераторами|Накопление с обобщенными итераторами]] 19.2.4
3. [[#Функции типов|Функции типов]] 19.3
	1. [[#Типы элементов|Типы элементов]] 19.3.1
	2. [[#Преобразующие свойства|Преобразующие свойства]] 19.3.2



# Реализация свойств типов

Шаблоны дают возможность параметризовать классы и функции для различных типов. Кажется весьма заманчивым вводить столько параметров шаблонов, сколько нужно для того, чтобы настроить каждый аспект поведения типа или алгоритма. Таким образом, наши “шаблонизированные” компоненты могли бы быть реализованы так, чтобы удовлетворять любым потребностям пользовательского кода. Однако с практической точки зрения нежелательно вводить большое количество параметров шаблонов для их максимально возможной параметризации. Необходимость указания всех соответствующих аргументов в пользовательском коде чрезмерно утомительна, а каждый дополнительный параметр шаблона усложняет контракт между компонентом и его клиентом.

К счастью, оказывается, что большинству дополнительных параметров можно назначить приемлемые значения по умолчанию. В ряде случаев дополнительные параметры полностью определяются несколькими основными параметрами и по этому могут быть вообще опущены. Для других параметров могут быть заданы значения по умолчанию, зависящие от основных параметров, которые отвечают нуждам большинства ситуаций, но тем не менее в ряде случаев все же должны заменяться реальными значениями. Некоторые параметры оказываются не связанными с основными параметрами, и в этом смысле сами являются основными параметрами.

Свойства (traits), или шаблоны свойств, являются теми программными устройствами C++, которые значительно облегчают управление множеством дополнительных параметров, появляющихся при разработке мощных шаблонов. В этой главе приведен ряд ситуаций, в которых они доказывают свою несомненную эффективность, а также демонстрируются различные методы разработки мощных и надежных компонентов для ваших собственных программ.

Большинство представленных здесь свойств доступны в той или иной форме в стандартной библиотеке C++. Однако для ясности мы часто представляем упрощенные реализации, которые опускают некоторые детали, имеющиеся в реализациях промышленного уровня (как, например, в стандартной библиотеке). По этой причине мы также используем нашу собственную схему именования, которая, однако, легко отображается на стандартные свойства.

# Пример: суммирование последовательности

Вычисление суммы последовательности значений — довольно тривиальная вычислительная задача. Однако эта простая на вид задача может служить прекрасным примером использования классов стратегий и свойств на разных уровнях.

## Фиксированные свойства

Предположим для начала, что значения, сумму которых необходимо вычислить, хранятся в массиве, и нам заданы указатели на первый суммируемый элемент и на элемент, следующий за последним. Естественно, потребуется написать шаблон, который будет применим для различных типов. Приведенный ниже код может показаться вам очень простым.
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

template<typename T>
T accum(T const* beg, T const* end)
{
	T total{}; // Считаем, что создается нулевое значение
	while (beg != end)
	{
		total += *beg;
		++beg;
	}
	
	return total;
}
#endif // ACCUM_HPP
```

Здесь есть только один тонкий момент: как создать нулевое значение корректного типа для начала процесса суммирования. Мы используем здесь [[template Инициализация нулем|инициализацию значением (с использованием записи с фигурными скобками)]]. Это означает, что объект `total` инициализируется либо с помощью своего конструктора по умолчанию, либо нулем (что означает [[nullptr_t#nullptr|nullptr]] для указателей и `false` для логических значений).

Рассмотрим теперь код, в котором используется наша функция `accum()`.
```c++
#include "accum1.hpp"
#include <iostream>

int main()
{
	// Создание массива из 5 целочисленных значений
	int num[] ={1, 2, 3, 4, 5 };

	// Вывод среднего значения
	std::cout << "Среднее значение для int равно "
				<< accum(num, num + 5) / 5 << '\n';
				
	// Создание массива символов
	char name[] = "templates";
	int length = sizeof(name) - 1;
	
	// (Пытаемся) вывести среднее значение
	std::cout << "Среднее значение для char в \""
				<< name << "\" равно "
				<< accum(name, name + length) / length
				<< '\n';
};
```

В первой половине этой программы `accum()` используется для суммирования пяти целочисленных значений:
```c++
int num[] = { 1, 2, 3, 4, 5 };

...

accum(num, num + 5);
```

После этого полученная сумма просто делится на количество значений в массиве, что дает нам целочисленное среднее значение.

Вторая половина программы пытается сделать то же самое для всех символов в слове `templates` (рассматривая символы от `а` до `z` как непрерывную последовательность в наборе символов, что справедливо для ASCII, но не для EBCDIC). По-видимому, результат вычисления должен находиться между значением `а` и значением `z`. В настоящее время на большинстве платформ эти значения определяются ASCII-кодами: символ `а` имеет код 97, а символ `z` — 122. Следовательно, можно предположить, что результат должен находиться где-то между `97` и `122`. Однако на нашем компьютере программа выводит следующее:
```
Среднее значение для int равно 3
Среднее значение для char в "templates" равно -5
```

Проблема заключается в том, что наш шаблон был инстанцирован для типа `char`, у которого оказался слишком маленький диапазон для накопления даже относительно небольших значений. Ясно, что можно было решить эту проблему, введя дополнительный параметр шаблона `АссТ`, описывающий тип, который используется для переменной `total` (и, соответственно, возвращаемый тип). Однако тем самым мы бы добавили дополнительную работу всем пользователям: они были бы вынуждены указывать этот тип при каждом обращении к шаблону; например, рассмотренный ранее код использовал бы следующий вызов функции:
```c++
accum<int>(name, name+5)
```

Это не столь существенное ограничение, но и его можно избежать.

Альтернативным по отношению к применению дополнительного параметра подходом является создание связи между каждым типом `Т`, для которого вызывается функция `accum()`, и типом, который будет использоваться для хранения накопленного значения. Эта связь может рассматриваться в качестве характеристики типа `Т`, и поэтому тип вычисляемой суммы иногда называется свойством (trait) `Т`. Эта связь может быть закодирована в виде специализации шаблона:
```c++
template<typename Т>
struct AccumulationTraits;

template<>
struct AccumulationTraits<char>
{
	using AccT = int;
};

template<>
struct AccumulationTraits<short>
{
	using AccT = int;
};

template<>
struct AccumulationTraits<int>
{
	using AccT = long;
};

template<>
struct AccumulationTraits<unsigned int>
{
	using AccT = unsigned long;
};

template<>
struct AccumulationTraits<float>
{
	using AccT = double;
};
```

Шаблон `AccumulationTraits` называется ***шаблоном свойств*** (traits template), поскольку он хранит свойство типа своего параметра. (В общем случае в шаблоне свойств может быть как несколько свойств, так и несколько параметров.) В данном случае обобщенного определения шаблона нет, так как нет хорошего способа для выбора подходящего типа накопления в случае неизвестного исходного типа. Однако можно считать, что таким типом может быть сам тип `Т`.

С учетом сказанного можно переписать наш шаблон `accum()`, как показано ниже:
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

#include "accumtraits2.hpp"

template<typename T>
auto accum(T const* beg, T const* end)
{
	// Возвращаемый тип является свойством типа элемента
	using АссТ = typename AccumulationTraits<T>::АссТ;
	АссТ total{); // Считаем, что создается нулевое значение

	while (beg != end)
	{
		total += *beg;
		++beg;
	}
	
	return total;
}

#endif // ACCUM_HPP
```

Вывод нашей программы становится таким, как мы и ожидали:
```
Среднее значение для int равно 3
Среднее значение для char в "templates" равно 108
```

В целом внесенные изменения не очень впечатляющи, хотя добавлен очень полезный механизм настройки нашего алгоритма. Кроме того, если появятся новые типы, предназначенные для использования с `accum()`, соответствующий тип `АссТ` может быть связан с ними посредством простого объявления дополнительной явной специализации класса `AccumulationTraits`. Обратите внимание на то, что эта операция может быть выполнена для любого типа: фундаментальных типов, типов, которые объявлены в других библиотеках, и т.д.

## Свойства-значения

До сих пор речь шла о том, что свойства предоставляют дополнительную информацию о типах, имеющую отношение к данному “основному” типу. В этом разделе показано, что такая дополнительная информация не ограничивается только типами. С типом могут быть связаны константы и другие классы значений.

Наш исходный шаблон `accum()` использует конструктор по умолчанию, возвращающий значение для инициализации переменной-результата значением, аналогичным нулевому:
```c++
АссТ total{}; // Считаем, что создается нулевое значение

...

return total;
```

Разумеется, нет никакой гарантии, что этот код обеспечивает подходящее значение, необходимое для запуска цикла накопления. Ведь тип `АссТ` может даже не иметь конструктора по умолчанию.

Но и в этом случае классы свойств могут спасти ситуацию. В данном примере можно добавить к нашему классу `AccumulationTraits` новое свойство-значение (value trait):
```c++
template<typename T>
struct AccumulationTraits;

template<>
struct AccumulationTraits<char>
{
	using AccT = int;
	static AccT const zero = 0;
};

template<>
struct AccumulationTraits<short>
{
	using AccT = int;
	static AccT const zero = 0;
};

template<>
struct AccumulationTraits<int>
{
	using AccT = long;
	static AccT const zero = 0;
};

...
```

В представленном фрагменте кода нашим новым свойством является константа `zero`, которая может быть вычислена в процессе компиляции. Ниже показано, какой вид принимает при этом функция `асcum()`:
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

#include "accumtraits3.hpp"

template<typename T>
auto accum(T const* beg, T const* end)
{
	// Возвращаемый тип является свойством типа элемента
	using AccT = typename AccumulationTraits<T>::AccT;
	
	// Инициализация total
	AccT total = AccumulationTraits<T>::zero; // значением свойства

	while (beg != end)
	{
		total += *beg;
		++beg;
	)
	
	return total;
}

#endif // ACCDM_HPP
```

В данном коде инициализация переменной для накопления результата остается очень простой:
```c++
АссТ total = AccumulationTraits<T>::zero;
```

Недостаток этого способа состоит в том, что C++ позволяет инициализировать статический константный член-данное внутри класса, только если он имеет целочисленный или перечислимый тип.

Статические [[constexpr|constexpr]] члены-данные являются несколько более обобщенными, допуская значения типов с плавающей точкой, а также иных литеральных типов:
```c++
template<>
struct AccumulationTraits<float>
{
	using Acct = float;
	static constexpr float zero = O.Of;
};
```

Однако ни [[const|const]], ни [[constexpr|constexpr]] не разрешают инициализировать таким путем нелитеральные типы. Например, пользовательский тип для вычислений с произвольной точностью `Biglnt` не может быть литеральным типом, поскольку он обычно должен выделять память для компонентов в динамической памяти, что препятствует литеральности его типа, или просто потому, что требуемый конструктор не является [[constexpr|constexpr]]. Поэтому следующая специализация является ошибкой:
```c++
class Biglnt
{
	Biglnt(long long);

	...
};

template<>
struct AccumulationTraits<BigInt>
{
	using AccT = Biglnt;
	static constexpr Biglnt zero =  // Ошибка:
						Biglnt(0);  // не литеральный тип
};
```

Простейший альтернативный способ состоит в том, чтобы не определять свойство-значение в классе.
```c++
template<>
struct AccumulationTraits<BigInt>
{
	using AccT = Biglnt;
	static Biglnt const zero;      // Только объявление
};
```

Затем инициализатор включается в исходный текст и выглядит примерно так:
```c++
Biglnt const AccumulationTraits<BigInt>::zero = Biglnt{O};
```

Хотя этот способ вполне работоспособен, он является более многословным (код должен быть добавлен в двух местах) и потенциально менее эффективным, поскольку компиляторам обычно ничего не известно об определениях в других файлах.

В C++17 эту проблему можно решить с использованием ***встраиваемых переменных*** (inline variables):
```c++
template<>
struct AccumulationTraits<BigInt>
{
	using AccT = Biglnt;
	inline static Biglnt const zero =
							Biglnt{0};  // OK, начиная с C++17
};
```

Альтернативой, которая работает до C++17, является использование встроенных функций-членов для значений свойств, которые не всегда дают целочисленные значения. Такая функция опять же может быть объявлена как [[constexpr|constexpr]], если она возвращает тип литерала.

Например, можно переписать `AccumulationTraits` следующим образом:
```c++
template<typename Т>
struct AccumulationTraits;

template<>
struct AccumulationTraits<char>
{
	using AccT = int;
	static constexpr AccT zero()
	{
		return 0;
	}
};

template<>
struct AccumulationTraits<short>
{
	using AccT = int;
	static constexpr AccT zero()
	{
		return 0;
	}
};

template<>
struct AccumulationTraits<int>
{
	using АссТ = long;
	static constexpr AccT zero()
	{
		return 0;
	}
};

template<>
struct AccumulationTraits<unsigned int>
{
	using AccT = unsigned long;
	static constexpr AccT zero()
	{
		return 0;
	}
};

template<>
struct AccumulationTraits<float>
{
	using AccT = double;
	static constexpr AccT zero()
	{
		return 0;
	}
};

...
```

После этого данные свойства можно расширить на наши собственные типы:
```c++
traits/accumtraits4bigint. hpp

template<>
struct AccumulationTraits<BigInt>
{
	using AccT = Biglnt;
	static Biglnt zero()
	{
		return Biglnt{0};
	}
};
```

В коде приложения при этом появляется единственное отличие — использование синтаксиса вызова функции вместо несколько более краткого доступа к статической переменной-члену класса:
```c++
АссТ total =                       // Инициализация total
	AccumulationTraits<T>::zero(); // функцией-свойством
```

Ясно, что свойства могут быть чем-то гораздо большим, нежели просто дополнительными типами. В нашем примере они могут быть механизмом, обеспечивающим функцию `accum()` всей необходимой информацией о типе элемента, для которого она вызвана. В этом состоит ключевой момент концепции свойств, а именно: свойства обеспечивают средства настройки конкретных элементов (обычно типов) для обобщенных вычислений.

## Параметризованные свойства

Использование свойств в `accum()`, показанное в предыдущих разделах, называется фиксированным, поскольку, как только будет определен отдельный класс свойств, его будет нельзя заменить в алгоритме; хотя бывают ситуации, когда такое переопределение желательно. Например, может оказаться, что набор значений типа `float` вполне можно суммировать в переменной этого же типа, а не `double`; к тому же это приведет к некоторому повышению эффективности.

Решить эту проблему можно, добавив параметр шаблона `АТ` со значением по умолчанию, определяемым нашим шаблоном свойств.
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

#include "accumtraits4.hpp"

template<typename T, typename AT = AccumulationTraits<T>>
auto accum(T const* beg, T const* end)
{
	typename AT::AccT total = AT::zero();
	
	while (beg != end)
	{
		total += *beg;
		++beg;
	}
	
	return total;
}

#endif // ACCUM_HPP
```

Таким образом, многие пользователи смогут просто опустить дополнительный аргумент шаблона, но те, у кого потребности выходят за стандартные рамки, смогут указать альтернативу предопределенному типу аккумулятора. Вероятно, большинству пользователей этого шаблона никогда не придется явно указывать второй параметр шаблона, поскольку его можно настроить так, чтобы он имел подходящее значение по умолчанию для каждого типа, выводимого из первого аргумента.

# Стратегии и классы стратегий

До сих пор речь шла о накоплении применительно к суммированию. Очевидно, что можно представить и другие виды накопления, а не только суммирование. Например, можно перемножать заданную последовательность значений. Или, если значения представляют собой строки, можно просто конкатенировать эти строки. Даже поиск максимального значения последовательности можно представить как задачу накопления. Во всех этих вариантах единственная операция `accum()`, которая должна измениться, — это `total+=*beg`. Эту операцию можно назвать стратегией (policy) нашего процесса накопления.

Вот пример того, как мы могли бы ввести такую стратегию в наш шаблон функции `accum()`:
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

#include "accumtraits4.hpp"
#include "sumpolicyl.hpp"

template<typename T,
		typename Policy = SumPolicy,
		typename Traits = AccumulationTraits<T>>
auto accum(T const* beg, T const* end)
{
	using AccT = typename Traits::AccT;
	AccT total = Traits::zero ();

	while (beg != end)
	{
		Policy::accumulate(total, *beg);
		++beg;
	}

	return total;
}

#endif // ACCUM_HPP
```

В этой версии функции `accum()` имеется класс `SumPolicy` — класс стратегии, т.е. класс, реализующий одну или несколько стратегий для алгоритма через согласованный интерфейс. `SumPolicy` может быть записан следующим образом:
```c++
#ifndef SUMPOLICY_HPP
#define SUMPOLICY_HPP

class SumPolicy
{
	public:
		template<typename T1, typename T2>
		static void accumulate(T1& total, T2 const& value)
		{
			total += value;
		}
};

#endif // SUMPOLICY_HPP
```

Указывая разные стратегии накопления значений, можно вычислять разные вещи. Рассмотрим, например, программу, с помощью которой предполагается определять результат произведения ряда значений:
```c++
#include "accum6.Ьрр"
#include <iostream>

class MultPolicy
{
	public:
		template<typename T1, typename T2>
		static void accumulate(T1& total, T2 const& value)
		{
			total *= value;
		}
};

int main()
{
	// Создание массива из 5 целочисленных значений
	int num[] = { 1, 2, 3, 4, 5 };
	
	// Вывод произведения всех значений
	std::cout << "Произведение всех значений равно "
				<< accum<int, MultPolicy>(num, num + 5)
				<< '\n';
}
```

Однако вывод программы окажется вовсе не тем, который ожидается:
```
Произведение всех значений равно О
```

Проблема вызвана нашим выбором начального значения: хотя значение 0 вполне пригодно при суммировании, оно не годится для умножения (нулевое начальное значение приводит к нулевому конечному результату). Этот пример иллюстрирует взаимодействие разных свойств и стратегий друг с другом, что еще раз подчеркивает, насколько важно быть аккуратным при проектировании шаблонов.

В данном случае легко понять, что инициализация цикла накопления — это часть стратегии накопления. Данная стратегия может использовать свойство `zero()` (но может и не воспользоваться им). Не следует забывать и о других вариантах решения задачи — далеко не все должно решаться только с помощью свойств и стратегий. Например, функция `accumulate()` стандартной библиотеки C++ получает начальное значение в качестве третьего аргумента функции.

## Различие между свойствами и стратегиями

Вполне логично предположить, что стратегии представляют собой частный случай свойств. И наоборот, можно утверждать, что свойства — просто закодированные стратегии.

Оксфордский словарь дает следующие определения:
>
> свойство — ...отличительная особенность, характеризующая сущность вещи;
> 
> стратегия — ..любой образ действия, принятый как полезный или целесообразный.

На основании этих определений мы вправе ограничить использование термина стратегия классами, которые кодируют определенные действия, слабо связанные с другими аргументами шаблона, с которым это действие связано. 
```
Стратегии имеют много общего со свойствами, но отличаются от них тем, что в них меньше внимания уделяется типам и больше — поведению.
```

```
Класс свойств — это класс, используемый вместо параметров шаблона. В качестве класса он объединяет полезные типы и константы; как шаблон, он является средством для обеспечения того “дополнительного уровня косвенности”, который решает все проблемы программного обеспечения.
```

Таким образом, мы можем использовать следующие (несколько расплывчатые) определения.
>
> Свойства представляют собой естественные дополнительные свойства параметра шаблона.
> 
> Стратегии представляют настраиваемое поведение обобщенных функций и типов (зачастую с некоторыми значениями по умолчанию).

Для дальнейшей конкретизации возможных различий между двумя этими концепциями перечислим ряд замечаний, касающихся свойств.
>
> Свойства могут быть использованы и как фиксированные свойства, т.е. без передачи их шаблону в качестве параметров.
> 
> Параметры свойств обычно имеют естественные значения по умолчанию (которые крайне редко переопределяются или попросту не могут быть переопределены).
> 
> Параметры свойств имеют тенденцию к сильной зависимости от одного или нескольких основных параметров.
> 
> Свойства обычно содержат типы и константы, а не функции-члены.
> 
> Свойства имеют тенденцию к агрегации в шаблоны свойств.

О классах стратегий также можно сделать несколько замечаний.
>
> Классы стратегий практически всегда передаются в качестве параметров шаблона.
> 
> Параметры стратегий не обязательно должны иметь значения по умолчанию и часто явно специализируются (хотя многие обобщенные компоненты обычно настраиваются с использованием стратегий, заданных по умолчанию).
> 
> Параметры стратегий обычно слабо связаны с другими параметрами шаблона.
> 
> Классы стратегий обычно объединяют функции-члены в единое целое.
> 
> Стратегии могут объединяться в обычных классах или в шаблонах классов.

Следует отметить, однако, что грань между обоими терминами весьма нечеткая. Например, свойства символов стандартной библиотеки C++ определяют также функциональное поведение, в частности сравнение символов, их перемещение и поиск. Заменяя эти свойства другими, можно определять строковые классы, которые ведут себя иначе, например нечувствительны к регистру символов при использовании того же символьного типа. Таким образом, называясь свойствами, они имеют ряд характеристик, присущих стратегиям.

## Шаблоны членов и шаблонные параметры шаблонов

Для реализации стратегии накопления был выбран вариант, в котором `SumPolicy` и `MultPolicy` представляли собой обычные классы с шаблонами членов. Другой вариант заключается в конструировании интерфейса класса стратегии с использованием шаблона класса, который затем применяется в качестве [[template Шаблонные параметры шаблонов|шаблонного аргумента шаблона]] ([[template Вглубь шаблонов#Шаблонные параметры шаблонов|см.]]). Например, можно переписать `SumPolicy` в виде шаблона.
```c++
#ifndef SUMPOLICY_HPP
#define SUMPOLICY_HPP

template<typename T1, typename T2>
class SumPolicy
{
	public:
		static void accumulate(T1& total, T2 const& value)
		{
			total += value;
		}
};

#endif // SUMPOLICY_HPP
```

Интерфейс класса `Accum` можно затем адаптировать для использования шаблонного параметра шаблона:
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

#include "accumtraits4.hpp"
#include "sumpolicy2.hpp"

template<typename T,
			template<typename, typename> class Policy = SumPolicy,
			typename Traits = AccumulationTraits<T>>
auto accum(T const* beg, T const* end)
{
	using AccT = typename Traits::AccT;
	AccT total = Traits::zero();
	
	while (beg != end)
	{
		Policy<AccT, T>::accumulate(total, *beg);
		++beg;
	}

	return total;
}

#endif // ACCUM_HPP
```

Такое же преобразование можно применить и к параметру-свойству. (Возможны и другие варианты: например, вместо явной передачи в стратегию типа `АссТ` может оказаться полезной передача свойств накопления, а стратегия при этом определяет тип результата из параметра свойства.)

Главное преимущество использования стратегий посредством шаблонных параметров шаблона — упрощение ситуации, когда класс стратегии содержит некоторую статическую информацию (статический член-данные) с типом, зависящим от параметров шаблона. (В нашем первом подходе статические члены-данные должны быть встроены в шаблон члена класса.)

Слабой стороной подхода с использованием шаблонных параметров шаблона является то, что классы стратегий должны быть написаны как шаблоны, с точным набором параметров шаблона, определяемых нашим интерфейсом. Это может сделать выражение самих свойств более многословным и менее естественным, чем простой нешаблонный класс.

## Комбинирование нескольких стратегий и/или свойств

Как показали наши примеры, и свойства, и стратегии не позволяют полностью избежать применения нескольких параметров шаблона. При этом, однако, они снижают их количество до вполне управляемого. Возникает интересный вопрос: каким образом упорядочить такие множественные параметры?

Простая стратегия состоит в упорядочении параметров согласно возрастанию вероятности выбора значения по умолчанию. Обычно это приводит к тому, что параметры свойств следуют за параметрами стратегий, поскольку они чаще переопределяются пользователями (возможно, вы уже заметили использование этого правила в наших примерах).

Для тех, кто все же склонен прибегать к значительному количеству параметров, тем самым существенно усложняя код, существует альтернатива, состоящая в задании параметров в любом порядке, без использования значений по умолчанию. Более подробно этот вопрос изложен в #разделе_21_4.

## Накопление с обобщенными итераторами

Прежде чем закончить введение в свойства и стратегии, рассмотрим еще одну версию `accum()`, которая позволяет работать с обобщенными итераторами вместо указателей, что и ожидается от обобщенного промышленного компонента. Интересно, что возможность вызова `accum()` с указателями при
этом остается, поскольку стандартная библиотека C++ обеспечивает использование так называемых свойств итераторов (iterator traits). Для этого можно переписать начальную версию `accum()` (опускаем при этом более поздние усовершенствования):
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

#include <iterator>

template<typename Iter>
auto accum(Iter start, Iter end)
{
	using VT = typename std::iterator_traits<Iter>::value_type;
	VT total{}; // Считаем, что создается нулевое значение
	
	while (start != end)
	{
		total += *start;
		++start;
	}
	
	return total;
}

#endif // ACCUM_HPP
```

Структура `iterator_traits` инкапсулирует все существенные свойства итератора. Благодаря наличию частичной специализации для указателей эти свойства могут использоваться для любых обычных указателей. Ниже показано, как стандартная библиотека может реализовать эту поддержку:
```c++
namespace std
{
	template<typename Т>
	struct iterator traits<T*>
	{
		using difference_type = ptrdiff_t;
		using value_type      = T;
		using pointer         = T*;
		using reference       = T&;
		using iterator_category = random_access_iterator_tag;
	};
}
```

Однако типа для накопления значений, к которым обращается итератор, здесь нет, так что нам придется разрабатывать свой собственный класс `AccumulationTraits`.

# Функции типов

В первоначальном примере использования свойств показано, что можно задавать поведение, зависящее от типов. Это отличается от того, что мы обычно делаем в программах. В языках программирования С и C++ функции более точно можно назвать функциями значений (value functions): они принимают одни значения в качестве параметров и возвращают другое значение в качестве результата. При работе с шаблонами мы сталкиваемся с функциями типов (type functions), т.е. функциями, которые принимают некоторые аргументы типа и возвращают тип или константу в качестве результата.

Весьма полезной встроенной функцией типа является [[sizeof|sizeof]], которая возвращает константу, указывающую размер (в байтах) данного аргумента типа. Шаблоны классов также могут играть роль функций типа. Параметры функции типа — это параметры шаблона, а результат получается как тип-член или константа-член. Например, оператор [[sizeof|sizeof]] может быть использован с приведенным ниже интерфейсом:
```c++
#include <cstddef>
#include <iostream>

template<typename T>
struct TypeSize
{
	static std::size_t const value = sizeof (T);
};

int main()
{
	std::cout << "TypeSize<int>::value = "
				<< TypeSize<int>::value << '\n';
}
```

Это может показаться не очень полезным, поскольку у нас есть доступный встроенный оператор [[sizeof#sizeof|sizeof]], но обратите внимание на то, что `TypeSize<T>` является типом, и поэтому он может быть передан в качестве аргумента шаблона класса. Кроме того, `TypeSize<T>` — это шаблон, и он может быть передан в качестве шаблонного аргумента шаблона.

В дальнейшем мы разработаем несколько более универсальных функций типов, которые могут использоваться в качестве свойств.

## Типы элементов

Предположим, что у нас есть ряд шаблонов контейнеров, таких как [[vector|std::vector<>]], [[list|std::list<>]], а также встроенные массивы. Нам нужна функция типа, которая для данного типа контейнера возвращает тип его элементов. Этого можно достичь с помощью частичной специализации:
```c++
#include <vector>
#include <list>

template<typename T>
struct ElementT;                // Первичный шаблон

template<typename T>            // Частичная специализация
struct ElementT<std::vector<T>> // для std::vector
{
	using Type = T;
};

template<typename T>            // Частичная специализация
struct ElementT<std::list<T>>   // для std::list
{
	using Type = T;
};

...

template<typename T, std::size_t N> 
struct ElementT<T[N]>          // Частичная специализация для
{                              // массива с известными границами
	using Type = T;
};

template<typename T>          // Частичная специализация для
struct ElementT<T[]>          // массива с неизвестными границами
{
	using Type = T;
};

...
```

Учтите, что мы должны обеспечить [[template Шаблоны для массивов и строковых литералов|частичную специализацию для всех возможных типов массивов]].

Функцию типа можно использовать следующим образом:
```c++
#include "elementtype.hpp"
#include <vector>
#include <iostream>
#include <typeinfo>

template<typename T>
void printElementType(T const& c)
{
	std::cout << "Контейнер из "
			<< typeid(typename ElementT<T>::Type).name()
			<< " элементов.\n";
}

int main()
{
	std::vector<bool> s;
	printElementType(s);
	
	int arr[42];
	printElementType(arr);
}
```

Использование частичной специализации позволяет реализовать эту функцию, не требуя, чтобы в типы контейнера были заложены сведения о ней. Зачастую, однако, функция типа разрабатывается вместе с соответствующими типами, так что ее реализация может быть существенно упрощена. Например, если типы контейнера определяют тип элемента `value_type` (как это делают стандартные контейнеры), то можно написать следующее:
```c++
template<typename С>
struct ElementT
{
	using Type = typename C::value_type;
);
```

Этот код может быть реализацией по умолчанию, что не исключает наличия специализаций для тех типов контейнеров, для которых не задан соответствующий тип элемента `value_type`.

Тем не менее обычно желательно обеспечить возможность определения типов для параметров шаблонов, чтобы к ним было легче обращаться в обобщенном коде. В следующем фрагменте кода представлен набросок этой идеи:
```c++
template<typename T1, typename Т2, ...>
class X
{
	public:
		using ... = T1;
		using ... = T2;
}
```

В чем заключается польза функции типа? Она позволяет параметризовать шаблон в терминах типа контейнера, не требуя при этом дополнительных параметров для типа элемента и других характеристик. Например, вместо
```c++
template<typename Т, typename С>
Т sumOfElements(С const& с);
```

(где требуется указание типа элемента в явном виде при помощи синтаксиса на подобие `sumOfElements<int> (list)`) можно объявить
```c++
template<typename С>
typename ElementT<C>::Туре sumOfElements(С const& с);
```

(где тип элемента определяется функцией типа).

Обратите внимание на то, что свойства могут быть реализованы как расширения существующих типов. Таким образом, функции типа можно определять даже для фундаментальных типов и типов из закрытых библиотек.

В данном случае тип `ElementТ` назван ***классом свойств*** (traits class), поскольку он используется для обращения к свойствам типа данного контейнера `С` (в общем случае в таком классе может быть собрано несколько свойств). Таким образом, классы свойств не ограничиваются описанием лишь характеристик параметров контейнера, но могут использоваться для описания любого вида “основных параметров”.

Для удобства можно создать шаблон псевдонима для типа функции. Например, можно ввести
```c++
template<typename Т>
using ElementType = typename ElementT<T>::Type;
```

что позволяет нам выполнить дальнейшее упрощение объявления `sumOfElements` до
```c++
template<typename С>
ElementType<C> sumOfElements(С const& с);
```

## Преобразующие свойства

Помимо предоставления доступа к конкретным аспектам типа основного параметра, свойства могут также выполнять преобразования типов, такие как добавление или удаление ссылок или квалификаторов [[const|const]] и [[volatile|volatile]].

***==Удаление ссылок==***

Например, можно реализовать свойство `RemoveReferenceT`, которое превращает ссылочные типы в лежащие в их основе типы объектов или функций, оставляя только типы, не являющиеся ссылочными:
```c++
template<typename T>
struct RemoveReferenceT
{
	using Type = T;
};

template<typename T>
struct RemoveReferenceT<T&>
{
	using Туре = Т;
};

template<typename Т>
struct RemoveReferenceT<T&&>
{
	using Type = T;
};
```

И вновь шаблоны псевдонимов упрощают использование:
```c++
template<typename Т>
using RemoveReference = typename RemoveReferenceT<T>::Type;
```

Удаление ссылки из типа обычно полезно, когда тип получен с помощью конструкции, которая иногда производит ссылочные типы, как, например, [[template Вывод аргументов шаблона#Ссылки на r-значения|специальное правило вывода для параметров функции типа `Т&&`]].

Стандартная библиотека C++ предоставляет соответствующее свойство типа [[remove_reference#std remove_reference|std::remove_reference<>]].

***===Добавление ссылки===***

Аналогичным образом можно взять существующий тип и создать из него ссылку на [[template значение|l-значение или на r-значение]] (вместе с обычным использованием шаблона псевдонима):
```c++
template<typename T>
struct AddLValueReferenceT
{
	using Type = T&;
};

template<typename T>
using AddLValueReference = typename AddLValueReferenceT<T>::Type;

template<typename T>
struct AddRValueReferenceT
{
	using Type = T &&;
};

template<typename T>
using AddRValueReference = typename AddRValueReferenceT<T>::Type;
```

Здесь применяются [[template Вывод аргументов шаблона#Ссылки на r-значения|правила свертки ссылок]]. Например, вызов `AddLValueReference<int&&>` производит тип `int&` (поэтому нет необходимости их реализации вручную с помощью частичной специализации).

Если мы оставим `AddLValueReferenceT` и `AddRValueReferenceT` как есть и не будем вводить их специализации, то псевдонимы, используемые для удобства, на самом деле могут быть упрощены до
```c++
template<typename Т>
using AddLValueReferenceT = Т&;

template<typename Т>
using AddRValueReferenceT = Т&&;
```

которые могут быть инстанцированы без инстанцирования шаблона класса (тем самым облегчая дело). Однако это рискованно, если мы захотим специализировать этот шаблон для особых случаев. Например, при написанном выше коде мы не сможем использовать `void` в качестве аргумента для этих шаблонов. Для обработки такой ситуации требуется явная специализация:
```c++
template<>
struct AddLValueReferenceT<void>
{
	using Type = void;
};

template<>
struct AddLValueReferenceT<void const>
{
	using Type = void const;
};

template<>
struct AddLValueReferenceT<void volatile>
{
	using Type = void volatile;
};

template<>
struct AddLValueReferenceT<void const volatile>
{
	using Type = void const volatile;
};
```

Аналогичный код следует написать для `AddRValueReferenceT`.

При наличии такого кода удобные шаблоны псевдонимов должны быть сформулированы в терминах шаблонов классов для гарантии работоспособности специализаций (поскольку шаблоны псевдонимов не могут быть специализированы).

Стандартная библиотека C++ предоставляет соответствующие свойства типов `std::add_lvalue_reference<>`и `std::add_rvalue_reference<>`, описанные в #разделе_Г_4. Стандартные шаблоны включают специализации для типов `void`.

***===Удаление квалификаторов===***

Преобразующие свойства могут работать с любыми составными типами, а не только со ссылками. Например, можно удалить квалификатор [[const|const]], если таковой имеется в наличии:
```c++
template<typename T>
struct RemoveConstT
{
	using Type = T;
};

template<typename T>
struct RemoveConstT<T const>
{
	using Type = T;
};

template<typename T>
using RemoveConst = typename RemoveConstT<T>::Type;
``` 

Кроме того, преобразующее свойство может быть составным, как, например, свойство `RemoveCVT`, удаляющее и [[const|const]], и [[volatile|volatile]]:
```c++
#include "removeconst.hpp"
#include "removevolatile.hpp"

template<typename T>
struct RemoveCVT : RemoveConstT<typename RemoveVolatileT<T>::Type>
{
};

template<typename T>
using RemoveCV = typename RemoveCVT<T>::Type;
```

Следует отметить пару моментов в определении `RemoveCVT`. Оно использует как `RemoveConstT`, так и связанный с ним `RemoveVolatileT`, сначала удаляя квалификатор [[volatile|volatile]] (при наличии такового) и передавая результирующий тип в `RemoveConstT`. Затем свойство использует метафункционалъную передачу (metafunction forwarding) для наследования члена `Туре` из `RemoveConstT` вместо объявления собственного члена `Туре`, идентичного члену в специализации `RemoveConstT`. Здесь метафункциональная передача используется просто для того, чтобы уменьшить количество вводимого текста в определении `RemoveCVT`. Однако она также полезна, когда метафункция определена не для всех входных данных; эта техника будет рассматриваться в #разделе_19_4.

Используемый для удобства шаблон псевдонима `RemoveCV` можно упростить до
```c++
template<typename Т>
using RemoveCV = RemoveConst<RemoveVolatile<T>>;
```

И вновь, этот способ работает, только если шаблон `RemoveCVT` не специализируется. В отличие от случая `AddLValueRefеrenсе` и `AddRValueReference`, мы не можем придумать ни одной причины для таких специализаций.

Стандартная библиотека C++ предоставляет соответствующие свойства типов `std::remove_volatile<>`, `std::remove_const<>` и `std::remove_cv<>`,
описанные в #разделе_Г_4.

***===Низведение===***

Чтобы завершить нашу дискуссию о преобразующих свойствах, разработаем свойство, имитирующее преобразование типов при передаче аргументов в качестве параметров по значению. Это означает (наследуя `С`), что выполняется низведение аргументов ([[template По значению или по ссылке#Работа со строковыми литералами и массивами|превращение массивов в указатели, а типов функций — в указатели на функции]]; [[template Обобщенные библиотеки#Поддержка функциональных объектов|см.]]) и удаляются любые квалификаторы
const, volatile или ссылки верхнего уровня (поскольку квалификаторы типов
верхнего уровня у типов параметров при разрешении вызова функции игнори­
руются).

Эффект от такой передачи ио значению можно увидеть в следующей програм­
ме, которая выводит тип фактического параметра, полученного после того, как
компилятор низводит указанный тип:
















