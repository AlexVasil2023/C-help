
[[Программирование времени компиляции|Программирование времени компиляции]] 8
1. [[#Шаблонное метапрограммирование|Шаблонное метапрограммирование]] 8.1
2. [[#Вычисления с использованием constexpr|Вычисления с использованием constexpr]] 8.2
3. [[#Выбор пути выполнения с помощью частичной специализации|Выбор пути выполнения с помощью частичной специализации]] 8.3
4. [[#SFINAE|SFINAE]] 8.4
	1. [[#Выражение SFINAE с decltype|Выражение SFINAE с decltype]] 8.4.1
5. [[#Инструкция if времени компиляции|Инструкция if времени компиляции]] 8.5



# Программирование времени компиляции

C++ всегда включал несколько простых способов вычисления значений во время компиляции. Шаблоны значительно расширяют возможности в этой области, а дальнейшая эволюции языка только добавляет новые инструменты в этот набор.

В простом случае можно решить, следует использовать тот или иной код либо выбрать один из нескольких вариантов шаблонного кода. Но компилятор во время компиляции способен даже вычислить итоговый результат всей работы потока управления при условии, что все необходимые входные данные ему доступны.

Фактически C++ имеет несколько вариантов поддержки программирования времени компиляции.
>
> Еще до С++98 шаблоны предоставляли возможность вычисления во время компиляции, включая применение циклов и выбор пути выполнения. (Однако некоторые рассматривают эти действия как “злоупотребления” возможностями шаблонов, например потому, что это требует применения неинтуитивного синтаксиса.)
> 
> С помощью частичной специализации можно выполнять выбор времени компиляции между различными реализациями шаблонов классов, в зависимости от конкретных ограничений или требований.
> 
> Принцип SFINAE обеспечивает возможность выбора между различными реализациями шаблона функции для разных типов или разных ограничений.
> 
> В С++11 и С++14 вычисления времени компиляции получили большую поддержку с использованием возможностей [[constexpr|constexpr]], с применением “интуитивного” пути выполнения и, начиная с C++14, с использованием большинства разновидностей инструкций (в том числе цикла [[for|for]], инструкции [[switch|switch]] и т.п.).
> 
> В C++17 вводится `“if времени компиляции”` для отбрасывания инструкций, зависящих от условий или ограничений времени компиляции. Эта возможность применима даже вне шаблонов.

Все упомянутые возможности рассматриваются в данной главе с особым вниманием к роли и контексту шаблонов.

# Шаблонное метапрограммирование

Шаблоны инстанцируются во время компиляции (в отличие от динамических языков, где обобщенность обрабатывается во время выполнения). Оказывается, что некоторые из возможностей шаблонов C++ могут быть объединены с процессом инстанцирования для создания своего рода примитивного рекурсивного “языка программирования” в рамках самого языка программирования C++. По этой причине шаблоны могут быть использованы для “вычисления программы”. В #главе_23, “Метапрограммирование”, этот вопрос будет рассматриваться существенно подробнее, а пока продемонстрируем на коротком примере, что это действительно возможно.

Приведенный ниже код во время компиляции выясняет, является ли данное число простым.
```c++
template<unsigned р,            // р: проверяемое значение,
		unsigned d>             // d: текущий делитель
struct DoIsPrime
{
	static constexpr bool value = (p % d != 0) &&
					DoIsPrime <p, d - 1>::value;
};

template<unsigned p>            // Завершение рекурсии при делителе 2
struct DoIsPrime<p, 2>
{
	static constexpr bool value = (p%2 != 0);
};

template<unsigned p>            // Шаблон простого числа
struct IsPrime
{
	// Начинаем рекурсию с делителя р/2:
	static constexpr bool value = DoIsPrime<p, p/2>::value;
};

// Частные случаи (для недопустимости бесконечной рекурсии):
template<>
struct IsPrime<0> { static constexpr bool value = false;};

template<>
struct IsPrime<1> { static constexpr bool value = false;};

template<>
struct IsPrime<2> { static constexpr bool value = true;};

template<>
struct IsPrime<3> { static constexpr bool value = true;};
```

Шаблон `IsPrime<>` возвращает в члене `value` значение, указывающее, является ли переданный шаблону параметр `р` простым числом. Для этой цели инстанцируется `DoIsPrime<>`, который рекурсивно развертывает выражение проверки для каждого делителя `d` от `р/2` до 2, делит ли этот делитель `р` без остатка.

Например, выражение
```c++
IsPrime<9>::value
```

разворачивается в
```c++
DoIsPrime<9,4>::value
```

которое разворачивается в
```c++
9%4!=0 && DoIsPrime<9,3>::value
```

которое разворачивается в
```c++
9%4!=0 && 9%3!=0 && DoIsPrime<9,2>::value
```

которое разворачивается в
```c++
9%4!=О && 9%3!=0 && 9%2!=0
```

вычисление которого дает значение `false`, поскольку `9%3` равно 0.

Как показывает эта цепочка инстанцирований:
>
> мы используем рекурсивное разворачивание `DoIsPrime<>` для выполнения итераций по всем делителям от `р/2` до `2` для выяснения, нет ли такого делителя, на который исходное число делится нацело (без остатка);
> 
> частичная специализация `DoIsPrime<>` для `d`, равного `2`, служит в качестве критерия завершения рекурсии.

Обратите внимание на то, что все это делается во время компиляции, так что
```c++
IsPrime<9>::value
```

становится равным `false` во время компиляции.

Возможно, синтаксис шаблонов и неуклюж, но код, подобный показанному, работает, начиная с С++98 (и даже ранее), и оказался достаточно полезным при разработке ряда библиотек.

Более подробно эти вопросы рассматриваются в #главе_23, “Метапрограммирование”.

# Вычисления с использованием constexpr

В С++11 в язык введена новая функциональная возможность — [[constexpr|constexpr]], которая значительно упрощает различные виды вычислений времени компиляции. В частности, при наличии корректных входных данных constexpr-функции могут быть вычислены во время компиляции. В то время как в С++11 на constexpr-функции были наложены строгие ограничения (например, каждое определение constexpr-функции, по существу, могло состоять только из оператора `return`), большинство этих ограничений были удалены в C++14. Конечно, успешное вычисление constexpr-функции по-прежнему требует, чтобы все вычислительные действия были возможны и корректны во время компиляции, что исключает такие вещи, как, например, динамическое выделение памяти или генерацию исключений.

Наш пример с проверкой числа на простоту в C++11 мог быть реализован следующим образом:
```c++
constexpr bool
doIsPrime(unsigned p,                    // p: проверяемое значение,
unsigned d)                              // d: текущий делитель
{
	return d!=2 ? (p%d!=0)               // Проверка текущего
					&& doIsPrime(p,d-1)  // и меньшего делителей
				: (p % 2 != 0);          // Завершение рекурсии при 2
}

constexpr bool isPrime(unsigned p)
(
	return p<4 ? !(p<2)                  // Обработка особых случаев
				: doIsPrime(p,р/2);      // Начало рекурсии от р/2
}
```

Из-за ограничения на одну инструкцию мы можем использовать как механизм отбора только условный оператор, и нам все еще нужна рекурсия для итерации по элементам. Но синтаксис обычной С++-функции делает этот код более доступным и понятным, чем первая версия, основанная на инстанцировании шаблона.

Начиная с С++14, constexpr-функции могут использовать большинство управляющих структур, доступных в общем коде C++. Так, вместо написания громоздкого кода с шаблонами или загадочного однострочного кода, теперь можно просто воспользоваться обычным циклом [[for|for]]:
```c++
constexpr bool isPrime(unsigned int p)
{
	for (unsigned int d = 2; d <= p/2; ++d)
	{
		if (p%d == 0)
		{
			return false;               // Найден делитель без остатка
		}
	}

	return р > 1;                       // Такого делителя нет
J
```

Как в версии C++11, так и в версии С++14 нашей реализации `constexpr isPrime()`, мы можем просто вызвать
```c++
isPrime(9)
```

чтобы узнать, является ли простым число `9`. Обратите внимание: это может быть сделано во время компиляции, но из этого не следует, что это обязательно будет сделано во время компиляции. В контексте, который требует значение времени компиляции (например, длина массива или аргумент шаблона, не являющийся типом), компилятор попытается вычислить значение constexpr-функции во время компиляции, и, если это не представляется возможным (поскольку в конечном итоге должна быть получена константа), мы получим сообщение об ошибке. В других контекстах компилятор может попытаться выполнить вычисление во время компиляции, но если это невозможно, то сообщения об ошибке не будет, а вызов функции останется вызовом времени выполнения.

Например, код
```c++
constexpr bool b1 = isPrime(9); // Вычисляется во время компиляции
```

приведет к вычислению во время компиляции. То же самое верно и для кода
```c++
const bool Ь2 = isPrime(9);     // Вычисляется во время компиляции
								// для области видимости пространства имен
```

если `b2` определена глобально или в пространстве имен. В области видимости блока компилятор может сам решить, следует выполнять вычисления во время компиляции или во время выполнения. То же самое верно и для кода
```c++
bool fiftySevenIsPrime()
{
	return isPrime(57);         // Вычисляется во время компиляции
}                               // или во время выполнения
```

где компилятор может вычислить значение, возвращаемое `isPrime`, во время компиляции, но может этого и не делать.

С другой стороны, исходный текст
```c++
int х;

... 

std::cout << isPrime(х);       // Вычисляется во время выполнения
```

будет генерировать код, который будет проверять простоту значения `х` во время выполнения.

# Выбор пути выполнения с помощью частичной специализации

Интересным применением проверок времени компиляции, таких как `isPrime()`, является использование частичной специализации для выбора различных реализаций во время компиляции.

Например, мы можем выбирать ту или иную реализацию в зависимости от того, является ли аргумент шаблона простым числом:
```c++
// Вспомогательный шаблон:
template<int SZ, bool = isPrime(SZ)>
struct Helper;

// Реализация для составного SZ:
template<int SZ>
struct Helper<SZ, false>
{
	...
};

// Реализация для простого SZ:
template<int SZ>
struct Helper<SZ, true>
{
	...
};

template<typename T, std::size_t SZ>
long foo(std::array<T, SZ> const& coll)
{
	Helper<SZ> h;            // Реализация зависит от того, простое
	...                      // ли число элементов в массиве
}
```

Здесь, в зависимости от того, является ли аргумент размера [[Array|std::array<>]] простым числом, мы используем две различные реализации класса `Helper<>`. Этот способ применения частичной специализации широко применяется для выбора между различными реализациями шаблона функции в зависимости от свойств аргументов, для которых он вызывается.

Выше мы использовали две частичные специализации для реализации двух возможных альтернатив. Вместо этого можно также использовать первичный шаблон для одной из альтернатив (по умолчанию) и частичные специализации для любого частного случая:
```c++
// Первичный вспомогательный шаблон:
template<int SZ, bool = isPrime(SZ)>
struct Helper
{
	...
};

// Специальная реализация для простого SZ:
template<int SZ>
struct Helper<SZ, true>
{
	...
};
```

Поскольку шаблоны функций не поддерживают частичную специализацию, вы должны использовать другие механизмы для изменения реализации функции на основе определенных ограничений. Наши варианты включают следующее:
>
> использование классов со статическими функциями;
> 
> использование [[enable_if|std::enable_if]];
> 
> использование SFINAE (об этом будет рассказано далее);
> 
> применение конструкции if времени компиляции, доступной начиная с С++17 (см. #раздел_8_5).

# SFINAE

В C++ перегрузка функций для различных типов аргументов — распространенная практика. Когда компилятор видит вызов перегруженной функции, он должен рассмотреть каждого кандидата отдельно, оценивая аргументы вызова и выбирая кандидата, который наилучшим образом соответствует передаваемым аргументам (см. дополнительную информацию в #приложении_В, “Разрешение перегрузки”).

В тех случаях, когда набор кандидатов для вызова включает шаблоны функций, компилятор сначала должен определить, какие аргументы шаблона должны использоваться для этого кандидата, затем подставить эти аргументы в список параметров функции и возвращаемый тип, а потом оценить, насколько хорошо она соответствует аргументам (так же, как это делается в случае обычной функции). Однако процесс подстановки может столкнуться с проблемами: он может давать конструкции, которые не имеют никакого смысла. Вместо того, чтобы считать такую бессмысленную подстановку ошибкой, правила языка требуют просто игнорировать кандидатов с такими проблемами.

Этот принцип именуется **`SFINAE`**, что представляет собой аббревиатуру для **“substitution failure is not an error”** (ошибка подстановки ошибкой не является).

Обратите внимание на то, что описанный здесь процесс подстановки отличается от [[Шаблоны классов#Использование шаблона класса Stack|процесса инстанцирования по требованию]]: подстановка может быть выполнена даже для потенциальных инстанцирований, которые на самом деле не нужны (так что компилятор может выяснить, действительно ли они не нужны). Эта подстановка выполняется непосредственно в объявлении функции (но не в ее теле).

Рассмотрим следующий пример:
```c++
// Количество элементов в массиве:
template<typename Т, unsigned N>
std::size_t len(T(&)[N])
{
	return N;
}

// Количество элементов для типа, имеющего член size_type:
template<typename Т>
typename T::size_type len(T const& t)
{
	return t.size();
}
```

Здесь мы определяем два шаблона функций `lеn()`, получающих один обобщенный аргумент.

1. Первый шаблон функции объявляет параметр как `Т(&)[N]`, что означает, что параметр должен быть массивом из `N` элементов типа `Т`.
2. Шаблон второй функции объявляет параметр просто как `Т`, что снимает все ограничения на сам параметр, но имеет возвращаемый тип `Т::size_type`, что требует от передаваемого типа аргумента наличия соответствующего члена `size_type`.

При передаче простого массива или строкового литерала соответствие наблюдается только в случае шаблона функции для простых массивов:
```c++
int а[10];

std::cout << len(a);       // ОК: соответствует только 1еn() для массива
std::cout << len("Hi");    // ОК: соответствует только 1еn() для массива
```

Согласно сигнатуре для второго шаблона функции также наблюдается соответствие при замене `Т` соответственно на `int[10]` и `char const [3]`, но эти подстановки ведут к потенциальным ошибкам в возвращаемом типе `Т: : size_type`. Поэтому второй шаблон при рассмотрении этих вызовов игнорируется.

При передаче [[vector|std::vector<>]] соответствие наблюдается только для второго шаблона:
```c++
std::vector<int> v;
std::cout << len(v);       // OK: годится только len() с типом size_type
```

При передаче простого указателя не подходит ни один из шаблонов функций (без сообщения об ошибке). В результате компилятор сообщает о том, что не может найти ни одной функции `lеn()`, соответствующей переданным аргументам:
```c++
int* р;
std::cout << len(p);       // Ошибка: подходящая 1еn() не найдена
```

Обратите внимание: эта ситуация отличается от передачи объекта с типом, имеющим тип-член `size_type`, но не имеющим функции-члена `size()`, как, например, для [[allocator|std::allocator<>]]:
```c++
std::allocator<int> x;
std::cout << len(x);      // Ошибка: len() найдена, но нет члена size()
```

При передаче объекта такого типа компилятор находит второй шаблон функции как соответствующий вызову. Поэтому вместо сообщения об ошибке, гласящего, что не найдена соответствующая функция `lеn()`, мы получаем сообщение об ошибке времени компиляции, говорящей о том, что невозможен вызов `size()` для `std::allocator<int>`. На этот раз второй шаблон функции не игнорируется.

Игнорирование кандидата при бессмысленности подстановки возвращаемого типа может заставить компилятор выбрать другого кандидата, параметры которого подходят хуже. Например:
```c++
// Количество элементов в простом массиве:
template<typename Т, unsigned N>
std::size_t len(T(&)[N])
{
	return N;
}

// Количество элементов для типа, имеющего тип-член size_type:
template<typename Т>
typename T::size_type len(T const& t)
{
	return t.size ();
}

// Запасной вариант для всех прочих типов:
std::size_t len(...)
{
	return 0;
}
```

Здесь мы также предоставляем общую функцию `len()`, которая соответствует всегда, но имеет наихудшее соответствие (с многоточием `(...)`) в разрешении перегрузки (см. #раздел_В_2).

Итак, для обычных массивов и векторов у нас есть два варианта, причем лучше подходит вариант с конкретными типами. Для указателей годится только запасной вариант, так что компилятор больше не жалуется на отсутствие `len()` для этого вызова. Но для распределителя памяти подходят второй и третий варианты функции, при этом второй шаблон обеспечивает лучшее соответствие. Так что это все еще приводит к сообщению об ошибке о том, что функция-член `size()` не может быть вызвана:
```c++
int а[10];
std::cout << len(a);         // OK: лучше подходит len() для массива
std::cout << len("Hi");      // OK: лучше подходит len() для массива

std::vector<int> v;
std::cout << len(v);         // OK: лучше подходит len() для типа с
							 // типом-членом size_type	
int* р;
std::cout << len(p);         // OK: годится только запасной вариант

std::allocator<int> х;
std::cout << len(x);         // Ошибка: вторая функция len() подходит
							 // лучше, но не может вызвать size() для х
```

Подробнее `SFINAE` рассматривается в #разделе_15_7, а некоторые приложения `SFINAE` — в #разделе_19_4.

==**SFINAE и разрешение перегрузки**==

Со временем принцип `SFINAE` стал столь важным и настолько превалирующим среди разработчиков шаблонов, что эта аббревиатура стала глаголом. Иногда говорят *“мы SFINAE’им функцию"*, имея в виду применение механизма `SFINAE` для обеспечения игнорирования шаблонов функции для определенных ограничений; код шаблонов при этих ограничениях становится недопустимым. Всякий раз, когда вы читаете в стандарте C++, что “шаблон функции не должен участвовать в разрешении перегрузки, если..”, это означает, что для того, чтобы шаблон функции игнорировался для определенных случаев, используется `SFINAE`.

Например, [[thread|std::thread]] объявляет конструктор:
```c++
namespace std
{
	class thread
	{
		public:
			template<typename F, typename... Args>
			explicit thread(F&& f, Args&& ... args);

			...
	};
};
```

co следующим примечанием:

Примечание: этот конструктор не должен участвовать в разрешении перегрузки, если `decay_t<F>` представляет собой тот же тип, что и [[thread|std::thread]].

Это означает, что шаблонный конструктор игнорируется, если он вызывается с [[thread|std::thread]] в качестве первого и единственного аргумента. Причина в том, что в противном случае шаблон-член наподобие показанного иногда может демонстрировать лучшее соответствие, чем любой предопределенный копирующий или [[Семантика перемещения - Шаблоны специальных функций-членов|перемещающий конструктор]] (см. подробности в #16_2_4). Применяя принцип `SFINAE` для игнорирования шаблона конструктора при вызове для потока, мы гарантируем, что, если поток строится из другого потока, всегда используется предопределенный копирующий или перемещающий конструктор.

Применение такой методики на индивидуальной основе может оказаться громоздким. К счастью, стандартная библиотека предоставляет инструменты для более легкого отключения шаблонов. [[Семантика перемещения - Отключение шаблонов с помощью enable_if|Наиболее известным средством является шаблон std::enable_if<>]]. Он позволяет отключить шаблон, просто заменив тип конструкцией с условием отключения шаблона.

В результате реальное объявление [[thread|std::thread]] обычно имеет следующий вид:
```c++
namespace std
{
	class thread
	{
		public:
			template<typename F, typename... Args,
					typename = enable_if_t<!is_same_v<
											decay_t<F>, thread>>>
				explicit thread(F&& f, Args&&... args);
				...
	};
};
```

Подробности реализации [[enable_if|std::enable_if<>]] и описание применения частичной специализации и `SFINAE` приведены в #разделе_20_3.

### Выражение SFINAE с decltype

Не всегда легко найти и сформулировать правильное выражение для того, чтобы воспользоваться принципом `SFINAE` для обеспечения игнорирования шаблона функции при определенных условиях.

Предположим, например, что мы хотим гарантировать, что шаблон функции `len()` игнорируется для аргументов типа, который имеет тип-член `size_type`, но не имеет функции-члена `size()`. Без каких-либо требований к функции-члену `size()` в объявлении функции шаблон будет выбран, после чего его инстанцирование приведет к ошибке:
```c++
template<typename Т>
typename T::size_type len(T const& t)
{
	return t.size ();
}

std::allocator<int> x;
std::cout << len(x)         // Ошибка: выбрана len(), но x
			<< '\n';        // не имеет функции-члена size()
```

Вот как выглядят обычные действия в такой ситуации.
>
> Указываем возвращаемый тип с помощью синтаксиса завершающего возвращаемого типа (trailing return type syntax), с использованием [[auto|auto]] в начале объявления и `->` перед возвращаемым типом в конце.
> 
> Определяем возвращаемый тип с использованием [[decltуре|decltype]] и оператора “запятая”.
> 
> Формулируем все выражения, которые должны быть корректны, в начале оператора “запятая” (преобразуя в `void`, если оператор “запятая” перегружен).
> 
> Определяем объект реального возвращаемого типа в конце оператора запятой.

Например:
```c++
template<typename Т>
auto len(T const& t) -> decltype((void) (t.size()), T::size type())
{
	return t.size();
}
```

Здесь возвращаемый тип задается выражением
```c++
decitype((void) (t.size()), T::size_type())
```

Операнд конструкции [[decltуре|decltype]] представляет собой список выражений, разделенных запятыми, так что последнее выражение `Т::size_type()` дает значение желаемого типа возвращаемого значения (который конструкция [[decltуре|decltype]] использует для преобразования в возвращаемый тип). Перед (последней) запятой находится выражение, которые должно быть корректным (и которое в данном случае представляет собой просто `t.size<>`). Приведение выражения к `void` используется для того, чтобы избежать возможной перегрузки оператора запятой для типа данного выражения.

Обратите внимание на то, что аргумент [[decltуре|decltype]] является невычисляемым операндом, следовательно, например, можно создать “фиктивные объекты” без вызова конструкторов (см. #раздел_11_2_3).

## Инструкция if времени компиляции

Частичная специализация, `SFINAE` и [[enable_if|std::enable_if]] позволяют включать или отключать шаблоны в целом. C++17 дополнительно вводит инструкцию #if времени компиляции, которая позволяет включать или отключать конкретные инструкции на основе условий времени компиляции. Используя синтаксис `if constexpr (...)`, компилятор использует выражения времени компиляции для принятия решения о применении части `then` или части `else` (если таковая имеется).

В качестве первого примера рассмотрим [[Вариативные шаблоны#Примеры вариативных шаблонов|вариативный шаблон функции print()]]. Он выводит свои аргументы (произвольных типов) с использованием рекурсии. Вместо предоставления отдельной функции для прекращения рекурсии `if constexpr` позволяет нам решать, продолжать ли рекурсию, локально:
```c++
template<typename Т, typename... Types>
void print(Т const& firstArg, Types const& ... args)
{
	std::cout << firstArg << '\n';
	if constexpr(sizeof...(args) > 0)
	{
		print(args...); // Код доступен только при условии
						// sizeof... (args)>0 (начиная с С++17)
	}
```

















