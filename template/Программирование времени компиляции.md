
[[Программирование времени компиляции|Программирование времени компиляции]] 8
1. [[#Шаблонное метапрограммирование|Шаблонное метапрограммирование]] 8.1
2. [[#Вычисления с использованием constexpr|Вычисления с использованием constexpr]] 8.2



# Программирование времени компиляции

C++ всегда включал несколько простых способов вычисления значений во время компиляции. Шаблоны значительно расширяют возможности в этой области, а дальнейшая эволюции языка только добавляет новые инструменты в этот набор.

В простом случае можно решить, следует использовать тот или иной код либо выбрать один из нескольких вариантов шаблонного кода. Но компилятор во время компиляции способен даже вычислить итоговый результат всей работы потока управления при условии, что все необходимые входные данные ему доступны.

Фактически C++ имеет несколько вариантов поддержки программирования времени компиляции.
>
> Еще до С++98 шаблоны предоставляли возможность вычисления во время компиляции, включая применение циклов и выбор пути выполнения. (Однако некоторые рассматривают эти действия как “злоупотребления” возможностями шаблонов, например потому, что это требует применения неинтуитивного синтаксиса.)
> 
> С помощью частичной специализации можно выполнять выбор времени компиляции между различными реализациями шаблонов классов, в зависимости от конкретных ограничений или требований.
> 
> Принцип SFINAE обеспечивает возможность выбора между различными реализациями шаблона функции для разных типов или разных ограничений.
> 
> В С++11 и С++14 вычисления времени компиляции получили большую поддержку с использованием возможностей [[constexpr|constexpr]], с применением “интуитивного” пути выполнения и, начиная с C++14, с использованием большинства разновидностей инструкций (в том числе цикла [[for|for]], инструкции [[switch|switch]] и т.п.).
> 
> В C++17 вводится `“if времени компиляции”` для отбрасывания инструкций, зависящих от условий или ограничений времени компиляции. Эта возможность применима даже вне шаблонов.

Все упомянутые возможности рассматриваются в данной главе с особым вниманием к роли и контексту шаблонов.

# Шаблонное метапрограммирование

Шаблоны инстанцируются во время компиляции (в отличие от динамических языков, где обобщенность обрабатывается во время выполнения). Оказывается, что некоторые из возможностей шаблонов C++ могут быть объединены с процессом инстанцирования для создания своего рода примитивного рекурсивного “языка программирования” в рамках самого языка программирования C++. По этой причине шаблоны могут быть использованы для “вычисления программы”. В #главе_23, “Метапрограммирование”, этот вопрос будет рассматриваться существенно подробнее, а пока продемонстрируем на коротком примере, что это действительно возможно.

Приведенный ниже код во время компиляции выясняет, является ли данное число простым.
```c++
template<unsigned р,            // р: проверяемое значение,
		unsigned d>             // d: текущий делитель
struct DoIsPrime
{
	static constexpr bool value = (p % d != 0) &&
					DoIsPrime <p, d - 1>::value;
};

template<unsigned p>            // Завершение рекурсии при делителе 2
struct DoIsPrime<p, 2>
{
	static constexpr bool value = (p%2 != 0);
};

template<unsigned p>            // Шаблон простого числа
struct IsPrime
{
	// Начинаем рекурсию с делителя р/2:
	static constexpr bool value = DoIsPrime<p, p/2>::value;
};

// Частные случаи (для недопустимости бесконечной рекурсии):
template<>
struct IsPrime<0> { static constexpr bool value = false;};

template<>
struct IsPrime<1> { static constexpr bool value = false;};

template<>
struct IsPrime<2> { static constexpr bool value = true;};

template<>
struct IsPrime<3> { static constexpr bool value = true;};
```

Шаблон `IsPrime<>` возвращает в члене `value` значение, указывающее, является ли переданный шаблону параметр `р` простым числом. Для этой цели инстанцируется `DoIsPrime<>`, который рекурсивно развертывает выражение проверки для каждого делителя `d` от `р/2` до 2, делит ли этот делитель `р` без остатка.

Например, выражение
```c++
IsPrime<9>::value
```

разворачивается в
```c++
DoIsPrime<9,4>::value
```

которое разворачивается в
```c++
9%4!=0 && DoIsPrime<9,3>::value
```

которое разворачивается в
```c++
9%4!=0 && 9%3!=0 && DoIsPrime<9,2>::value
```

которое разворачивается в
```c++
9%4!=О && 9%3!=0 && 9%2!=0
```

вычисление которого дает значение `false`, поскольку `9%3` равно 0.

Как показывает эта цепочка инстанцирований:
>
> мы используем рекурсивное разворачивание `DoIsPrime<>` для выполнения итераций по всем делителям от `р/2` до `2` для выяснения, нет ли такого делителя, на который исходное число делится нацело (без остатка);
> 
> частичная специализация `DoIsPrime<>` для `d`, равного `2`, служит в качестве критерия завершения рекурсии.

Обратите внимание на то, что все это делается во время компиляции, так что
```c++
IsPrime<9>::value
```

становится равным `false` во время компиляции.

Возможно, синтаксис шаблонов и неуклюж, но код, подобный показанному, работает, начиная с С++98 (и даже ранее), и оказался достаточно полезным при разработке ряда библиотек.

Более подробно эти вопросы рассматриваются в #главе_23, “Метапрограммирование”.

# Вычисления с использованием constexpr























