
[[Программирование времени компиляции|Программирование времени компиляции]] 8
1. [[#Шаблонное метапрограммирование|Шаблонное метапрограммирование]] 8.1
2. [[#Вычисления с использованием constexpr|Вычисления с использованием constexpr]] 8.2
3. [[#Выбор пути выполнения с помощью частичной специализации|Выбор пути выполнения с помощью частичной специализации]] 8.3
4. [[#SFINAE|SFINAE]] 8.4
	1. [[#Выражение SFINAE с decltype|Выражение SFINAE с decltype]] 8.4.1
5. [[#Инструкция if времени компиляции|Инструкция if времени компиляции]] 8.5

# Программирование времени компиляции

C++ всегда включал несколько простых способов вычисления значений во время компиляции. Шаблоны значительно расширяют возможности в этой области, а дальнейшая эволюции языка только добавляет новые инструменты в этот набор.

В простом случае можно решить, следует использовать тот или иной код либо выбрать один из нескольких вариантов шаблонного кода. Но компилятор во время компиляции способен даже вычислить итоговый результат всей работы потока управления при условии, что все необходимые входные данные ему доступны.

Фактически C++ имеет несколько вариантов поддержки программирования времени компиляции.
>
> Еще до С++98 шаблоны предоставляли возможность вычисления во время компиляции, включая применение циклов и выбор пути выполнения. (Однако некоторые рассматривают эти действия как “злоупотребления” возможностями шаблонов, например потому, что это требует применения неинтуитивного синтаксиса.)
> 
> С помощью частичной специализации можно выполнять выбор времени компиляции между различными реализациями шаблонов классов, в зависимости от конкретных ограничений или требований.
> 
> Принцип SFINAE обеспечивает возможность выбора между различными реализациями шаблона функции для разных типов или разных ограничений.
> 
> В С++11 и С++14 вычисления времени компиляции получили большую поддержку с использованием возможностей [[constexpr|constexpr]], с применением “интуитивного” пути выполнения и, начиная с C++14, с использованием большинства разновидностей инструкций (в том числе цикла [[for|for]], инструкции [[switch|switch]] и т.п.).
> 
> В C++17 вводится `“if времени компиляции”` для отбрасывания инструкций, зависящих от условий или ограничений времени компиляции. Эта возможность применима даже вне шаблонов.

Все упомянутые возможности рассматриваются в данной главе с особым вниманием к роли и контексту шаблонов.

# Шаблонное метапрограммирование

Шаблоны инстанцируются во время компиляции (в отличие от динамических языков, где обобщенность обрабатывается во время выполнения). Оказывается, что некоторые из возможностей шаблонов C++ могут быть объединены с процессом инстанцирования для создания своего рода примитивного рекурсивного “языка программирования” в рамках самого языка программирования C++. По этой причине шаблоны могут быть использованы для “вычисления программы”. В [[Метапрограммирование|“Метапрограммирование”]], этот вопрос будет рассматриваться существенно подробнее, а пока продемонстрируем на коротком примере, что это действительно возможно.

Приведенный ниже код во время компиляции выясняет, является ли данное число простым.
```c++
template<unsigned р,            // р: проверяемое значение,
		unsigned d>             // d: текущий делитель
struct DoIsPrime
{
	static constexpr bool value = (p % d != 0) &&
					DoIsPrime <p, d - 1>::value;
};

template<unsigned p>            // Завершение рекурсии при делителе 2
struct DoIsPrime<p, 2>
{
	static constexpr bool value = (p%2 != 0);
};

template<unsigned p>            // Шаблон простого числа
struct IsPrime
{
	// Начинаем рекурсию с делителя р/2:
	static constexpr bool value = DoIsPrime<p, p/2>::value;
};

// Частные случаи (для недопустимости бесконечной рекурсии):
template<>
struct IsPrime<0> { static constexpr bool value = false;};

template<>
struct IsPrime<1> { static constexpr bool value = false;};

template<>
struct IsPrime<2> { static constexpr bool value = true;};

template<>
struct IsPrime<3> { static constexpr bool value = true;};
```

Шаблон `IsPrime<>` возвращает в члене `value` значение, указывающее, является ли переданный шаблону параметр `р` простым числом. Для этой цели инстанцируется `DoIsPrime<>`, который рекурсивно развертывает выражение проверки для каждого делителя `d` от `р/2` до 2, делит ли этот делитель `р` без остатка.

Например, выражение
```c++
IsPrime<9>::value
```

разворачивается в
```c++
DoIsPrime<9,4>::value
```

которое разворачивается в
```c++
9%4!=0 && DoIsPrime<9,3>::value
```

которое разворачивается в
```c++
9%4!=0 && 9%3!=0 && DoIsPrime<9,2>::value
```

которое разворачивается в
```c++
9%4!=О && 9%3!=0 && 9%2!=0
```

вычисление которого дает значение `false`, поскольку `9%3` равно 0.

Как показывает эта цепочка инстанцирований:
>
> мы используем рекурсивное разворачивание `DoIsPrime<>` для выполнения итераций по всем делителям от `р/2` до `2` для выяснения, нет ли такого делителя, на который исходное число делится нацело (без остатка);
> 
> частичная специализация `DoIsPrime<>` для `d`, равного `2`, служит в качестве критерия завершения рекурсии.

Обратите внимание на то, что все это делается во время компиляции, так что
```c++
IsPrime<9>::value
```

становится равным `false` во время компиляции.

Возможно, синтаксис шаблонов и неуклюж, но код, подобный показанному, работает, начиная с С++98 (и даже ранее), и оказался достаточно полезным при разработке ряда библиотек.

Более подробно эти вопросы рассматриваются в [[Метапрограммирование|“Метапрограммирование”]].

# Вычисления с использованием constexpr

В С++11 в язык введена новая функциональная возможность — [[constexpr|constexpr]], которая значительно упрощает различные виды вычислений времени компиляции. В частности, при наличии корректных входных данных constexpr-функции могут быть вычислены во время компиляции. В то время как в С++11 на constexpr-функции были наложены строгие ограничения (например, каждое определение constexpr-функции, по существу, могло состоять только из оператора `return`), большинство этих ограничений были удалены в C++14. Конечно, успешное вычисление constexpr-функции по-прежнему требует, чтобы все вычислительные действия были возможны и корректны во время компиляции, что исключает такие вещи, как, например, динамическое выделение памяти или генерацию исключений.

Наш пример с проверкой числа на простоту в C++11 мог быть реализован следующим образом:
```c++
constexpr bool
doIsPrime(unsigned p,                    // p: проверяемое значение,
unsigned d)                              // d: текущий делитель
{
	return d!=2 ? (p%d!=0)               // Проверка текущего
					&& doIsPrime(p,d-1)  // и меньшего делителей
				: (p % 2 != 0);          // Завершение рекурсии при 2
}

constexpr bool isPrime(unsigned p)
(
	return p<4 ? !(p<2)                  // Обработка особых случаев
				: doIsPrime(p,р/2);      // Начало рекурсии от р/2
}
```

Из-за ограничения на одну инструкцию мы можем использовать как механизм отбора только условный оператор, и нам все еще нужна рекурсия для итерации по элементам. Но синтаксис обычной С++-функции делает этот код более доступным и понятным, чем первая версия, основанная на инстанцировании шаблона.

Начиная с С++14, constexpr-функции могут использовать большинство управляющих структур, доступных в общем коде C++. Так, вместо написания громоздкого кода с шаблонами или загадочного однострочного кода, теперь можно просто воспользоваться обычным циклом [[for|for]]:
```c++
constexpr bool isPrime(unsigned int p)
{
	for (unsigned int d = 2; d <= p/2; ++d)
	{
		if (p%d == 0)
		{
			return false;               // Найден делитель без остатка
		}
	}

	return р > 1;                       // Такого делителя нет
J
```

Как в версии C++11, так и в версии С++14 нашей реализации `constexpr isPrime()`, мы можем просто вызвать
```c++
isPrime(9)
```

чтобы узнать, является ли простым число `9`. Обратите внимание: это может быть сделано во время компиляции, но из этого не следует, что это обязательно будет сделано во время компиляции. В контексте, который требует значение времени компиляции (например, длина массива или аргумент шаблона, не являющийся типом), компилятор попытается вычислить значение constexpr-функции во время компиляции, и, если это не представляется возможным (поскольку в конечном итоге должна быть получена константа), мы получим сообщение об ошибке. В других контекстах компилятор может попытаться выполнить вычисление во время компиляции, но если это невозможно, то сообщения об ошибке не будет, а вызов функции останется вызовом времени выполнения.

Например, код
```c++
constexpr bool b1 = isPrime(9); // Вычисляется во время компиляции
```

приведет к вычислению во время компиляции. То же самое верно и для кода
```c++
const bool Ь2 = isPrime(9);     // Вычисляется во время компиляции
								// для области видимости пространства имен
```

если `b2` определена глобально или в пространстве имен. В области видимости блока компилятор может сам решить, следует выполнять вычисления во время компиляции или во время выполнения. То же самое верно и для кода
```c++
bool fiftySevenIsPrime()
{
	return isPrime(57);         // Вычисляется во время компиляции
}                               // или во время выполнения
```

где компилятор может вычислить значение, возвращаемое `isPrime`, во время компиляции, но может этого и не делать.

С другой стороны, исходный текст
```c++
int х;

... 

std::cout << isPrime(х);       // Вычисляется во время выполнения
```

будет генерировать код, который будет проверять простоту значения `х` во время выполнения.

# Выбор пути выполнения с помощью частичной специализации

Интересным применением проверок времени компиляции, таких как `isPrime()`, является использование частичной специализации для выбора различных реализаций во время компиляции.

Например, мы можем выбирать ту или иную реализацию в зависимости от того, является ли аргумент шаблона простым числом:
```c++
// Вспомогательный шаблон:
template<int SZ, bool = isPrime(SZ)>
struct Helper;

// Реализация для составного SZ:
template<int SZ>
struct Helper<SZ, false>
{
	...
};

// Реализация для простого SZ:
template<int SZ>
struct Helper<SZ, true>
{
	...
};

template<typename T, std::size_t SZ>
long foo(std::array<T, SZ> const& coll)
{
	Helper<SZ> h;            // Реализация зависит от того, простое
	...                      // ли число элементов в массиве
}
```

Здесь, в зависимости от того, является ли аргумент размера [[Array|std::array<>]] простым числом, мы используем две различные реализации класса `Helper<>`. Этот способ применения частичной специализации широко применяется для выбора между различными реализациями шаблона функции в зависимости от свойств аргументов, для которых он вызывается.

Выше мы использовали две частичные специализации для реализации двух возможных альтернатив. Вместо этого можно также использовать первичный шаблон для одной из альтернатив (по умолчанию) и частичные специализации для любого частного случая:
```c++
// Первичный вспомогательный шаблон:
template<int SZ, bool = isPrime(SZ)>
struct Helper
{
	...
};

// Специальная реализация для простого SZ:
template<int SZ>
struct Helper<SZ, true>
{
	...
};
```

Поскольку шаблоны функций не поддерживают частичную специализацию, вы должны использовать другие механизмы для изменения реализации функции на основе определенных ограничений. Наши варианты включают следующее:
>
> использование классов со статическими функциями;
> 
> использование [[enable_if|std::enable_if]];
> 
> использование SFINAE (об этом будет рассказано далее);
> 
> применение [[Программирование времени компиляции#Инструкция if времени компиляции|конструкции if времени компиляции]], доступной начиная с С++17.

# SFINAE

[[SFINAE| см. тут]]

## Выражение SFINAE с decltype

[[SFINAE#Выражение SFINAE с decltype|см. тут]]


## Инструкция if времени компиляции

Частичная специализация, `SFINAE` и [[enable_if|std::enable_if]] позволяют включать или отключать шаблоны в целом. C++17 дополнительно вводит инструкцию [[if|if]] времени компиляции, которая позволяет включать или отключать конкретные инструкции на основе условий времени компиляции. Используя синтаксис `if constexpr (...)`, компилятор использует выражения времени компиляции для принятия решения о применении части `then` или части `else` (если таковая имеется).

В качестве первого примера рассмотрим [[Вариативные шаблоны#Примеры вариативных шаблонов|вариативный шаблон функции print()]]. Он выводит свои аргументы (произвольных типов) с использованием рекурсии. Вместо предоставления отдельной функции для прекращения рекурсии `if constexpr` позволяет нам решать, продолжать ли рекурсию, локально:
```c++
template<typename Т, typename... Types>
void print(Т const& firstArg, Types const& ... args)
{
	std::cout << firstArg << '\n';
	if constexpr(sizeof...(args) > 0)
	{
		print(args...); // Код доступен только при условии
						// sizeof... (args)>0 (начиная с С++17)
	}
```

Здесь, если `print()` вызывается только с одним аргументом, `args` становится пустым пакетом параметров, так что `sizeof... (args)` становится равным `0`. В результате такой рекурсивный вызов `print()` становится завершающим рекурсию, так как код вызова в нем не создается, и рекурсия заканчивается.

Тот факт, что код не инстанцируется, означает, что выполняется только первый этап трансляции (время определения), во время которого [[Шаблоны функций#Несколько параметров шаблона|проверяется правильность синтаксиса и имен, которые не зависят от параметров шаблона]]. Например:
```c++
template<typename Т>
void foo(T t)
{
	if constexpr(std::is_integral_v<T>)	{
		if (t > 0) {
			foo(t - 1);     // OK
		}
	}
	else
		{
			undeclared(t);  // Ошибка, если не объявлена и не отброшена
							// (Т не является целочисленным)
			undeclared();   // Ошибка, если не объявлена
							// (даже если отброшена)
			static_assert(false, "no integral"); // Всегда работает
												 // (даже если отброшена)
			static_assert(!std::is_integral_v<T>, "no integral"); // OK
		}
}
```

Обратите внимание: [[constexpr#if constexpr|if constexpr]] может использоваться в любой функции, не только в шаблонах. Требуется только выражение времени компиляции, возвращающее логическое значение. Например:
```c++
int main()
{
	if constexpr(std::numeric_limits<char>::is_signed){
		foo(42); // OK
	}
	else {
		undeclared(42); // Ошибка, если undeclared() не объявлена
		static_assert(false, "unsigned" );  // Всегда работает
											// (даже если отброшена)
		static_assert(!std::numeric_limits<char>::is_signed,
						"char is unsigned"); // OK
	}
}
```

С помощью этой возможности допустимо, например, использовать нашу [[Программирование времени компиляции#Вычисления с использованием constexpr|функцию времени компиляции isPrime()]], для выполнения дополнительного кода, если заданный размер не является простым числом:

```c++
template<typename Т, std::size_t SZ>
void foo(std::array<T, SZ> const& coll)
{
	if constexpr(!isPrime(SZ)){
		...     // Специальная дополнительная обработка,
				// если размер массива - составное число
	}
}
```

[[Инстанцирование в шаблонах#Инструкции if времени компиляции|Подробности см.]].

