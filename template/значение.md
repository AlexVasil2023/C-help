
[[#Категории значений]] Б
1. [[#Традиционные l- и r-значения|Традиционные l- и r-значения]] Б.1
2. [[rvalue|Традиционные lvalue и rvalue]]
	1. [[#Преобразования l-значений в r-значения|Преобразования l-значений в r-значения]] Б.1.1
3. [[#Категории значений, начиная с C++11|Категории значений, начиная с C++11]] Б.2
[[#gl-значение|gl-значение]]
[[#pr-значения]]
[[#x-значения]]
[[#l-значение]]
[[#r-значения]]

# Категории значений

Выражения являются краеугольным камнем языка C++, предоставляя основной механизм, позволяющий выразить необходимые вычисления. Каждое выражение имеет тип, который описывает статический тип значения, производимого при вычислении. Так, выражение `7` имеет тип `int`, как и выражение `5+2` или выражение `х`, если `х` является переменной типа `int`. Каждое выражение имеет также категорию значения (value category), которая описывает то, как было сформировано значение, и влияет на поведение выражения.

## Традиционные l- и r-значения

Исторически изначально имелись только две категории значений: `l-значения` и `r-значения`. `L-значениями` являются выражения, ссылающиеся на фактические значения, хранящиеся в памяти или в регистре компьютера, такие как выражение `х`, где `х` — имя переменной. Эти выражения могут быть изменяемыми, позволяя обновлять сохраненное значение. Например, если `х` является переменной типа `int`, то следующее присваивание заменит значение `х` на `7`:
```c++
х = 7;
```


Термин `l-значение` ([[rvalue|lvalue]]) является производным от роли, которую это выражение могло бы играть в рамках присваивания: буква / означает “левый” потому что (исторически в языке программирования С) слева от знака присваивания могут находиться только `l-значения`. И наоборот, `r-значения` ( [[rvalue|rvalues]], где `r` означает “справа”) может находиться только в правой части выражения присваивания.

Однако после стандартизации языка С в 1989 году все изменилось: хотя по-прежнему значение `int const` хранится в памяти, оно не может находиться в левой части присваивания:
```c++
int const х;        // х - неизменяемое значение
х = 7;              // Ошибка: слева должно быть изменяемое значение
```

Изменения в C++ пошли еще дальше: класс `r-значений` может находиться слева в присваиваниях. Такие присваивания на самом деле являются вызовами функций операторов присваивания соответствующих классов, а не “простыми” присваиваниями скалярных типов, так что они управляются (отдельными) правилами вызовов функций-членов.

Учитывая все эти изменения, термин `l-значение` теперь иногда трактуется как локализуемое значение. Выражения, которые ссылаются на переменную, являются не единственными выражениями `l-значений`. Еще один класс выражений, которые являются `l-значениями`, включает операцию разыменования указателя (например, `*р`), и ссылается на значения, хранящиеся по адресу, на который указывает указатель, а также выражения, которые ссылаются на члены объектов классов (например, `p->data`). Даже вызовы функций, возвращающих значения “традиционных” ссылочных на `l-значения` типов, объявленных с использованием `&`, являются `l-значениями`. Например (см. подробности в #разделе_Б_4):
```c++
std::vector<int> v;
v.front();                  // l-значение, так как возвращаемый тип
							// является ссылкой на l-значение
```

Возможно, это покажется удивительным, но строковые литералы также являются (неизменяемыми) l-значениями.

R-значения являются чисто математическими значениями (например, `7` или символ `' а '` ), которые не обязательно имеют связанное с ними место хранения; они существуют только для вычислений, но после того, как они были использованы, на них нельзя ссылаться. В частности, любые литеральные значения, за исключением строковых литералов (например, `7`, `' а'`, `true`, [[nullptr_t|nullptr]]), являются r-значениями, как и результаты многих встроенных арифметических вычислений (например, `х+5` для `х` целочисленного типа) и вызовов функций, возвращающих результат по значению. То есть все временные значения являются г-значениями. (Хотя это не относится к именованным ссылкам, которые ссылаются на них.)

### Преобразования l-значений в r-значения

В силу своей эфемерной природы `r-значения` ограничены присутствием только с правой стороны (“простых”) присваиваний: присваивание `7=8` не имеет смысла, потому что математическое значение `7` не может быть переопределено. С другой стороны, `l-значения` подобного ограничения не имеют: безусловно можно вычислить присваивание `х=у`, когда и `х`, и `у` являются переменными совместимого типа, даже если оба выражения `х` и `у` являются `l-значениями`.

Присваивание `х=у` работает благодаря тому, что выражение справа, `у`, подвергается неявному преобразованию, которое называется преобразованием `l-значения` в `r-значение` (`lvalue-to-rvalue conversion`). Как предполагает название, это преобразование принимает `l-значение` и выполняет чтение из памяти или регистра, связанных с `r-значением`, `r-значения` того же типа. Таким образом, это преобразование выполняет два действия: во-первых, оно гарантирует, что `l-значения` могут использоваться везде, где ожидается `г-значение` (например, в правой части присваивания или в математическом выражении наподобие `х+у`). Во-вторых, оно определяет, где в программе компилятор может включать (до оптимизации) инструкцию “загрузка” для чтения значения из памяти.

## Категории значений, начиная с C++11

Когда в C++11 для поддержки семантики перемещения были введены ссылки на `г-значение`, традиционного деления выражений на `l-значения` и `r-значения` стало недостаточно, чтобы описать все поведение C++11. Поэтому комитет по стандартизации C++ изменил систему категорий значений, основав ее на трех основных и двух составных категориях (см. рис. ). Основными категориями являются: [[#l-значение|l-значение]], [[#pr-значения|pr-значение]] (pure rvalue — чистое `r-значение`) и [[#x-значения|х-значение]]. Составными категориями являются [[#gl-значение|gl-значение]] (generalized lvalue — обобщенное `l-значение`, которое является объединением `l-значения` и `х-значения`) и [[#r-значения|r-значение]] (объединение `х-значения` и `рr-значения`).

Обратите внимание на то, что все выражения по-прежнему являются `l-значениями` или `r-значениями`, но теперь категория `r-значения` разделяется.
![[Template_B_1.png]]

Эта категоризация С++11 остается в силе, но в С++17 характеристики категорий были пересмотрены следующим образом.

> **`gl-значение`** представляет собой выражение, вычисление которого определяет идентичность объекта, битового поля или функции (сущности, имеющей место хранения).
> 
> **`pr-значение`** представляет собой выражение, вычисление которого инициализирует объект или битовое поле, или вычисляет значение операнда оператора.
> 
> **`х-значение`** представляет собой `gl-значение`, обозначающее объект или битовое поле, ресурсы которого могут быть повторно использованы (обычно из-за того, что вскоре истечет его время жизни — так что “x” в `xvalue` означает “eXpiring value” — завершающееся значение).
> 
> **`l-значение`** представляет собой `gl-значение`, не являющееся `х-значением`.
> 
> **`r-значение`** представляет собой выражение, являющееся либо `рr-значением`, либо `х-значением`.

Обратите внимание на то, что в С++17 (и в некоторой степени в С++11 и С++14) разделение `gl-значений` и `pr-значений`, возможно, более фундаментальное, чем традиционное отличие `l-значений` от `r-значений`.

Хотя это описание характеристик введено в C++17, оно применимо и в C++11 и C++14 (более ранние описания эквивалентны по смыслу, но с ними трудно работать).

За исключением битовых полей, `gl-значения` производят сущности с адресами. Этот адрес может быть адресом подобъектов большего охватывающего объекта. В случае подобъекта базового класса тип `gl-значения` (выражения) называется статическим типом, а тип наиболее производного объекта, частью которого является базовый класс, называется динамическим типом `gl-значения`. Если `gl-значение` не производит подобъект базового класса, статические и динамические типы являются идентичными (типом выражения).

Примеры **`l-значений`** таковы:
> Выражения, обозначающие переменные или функции.
> 
> Применения встроенного унарного оператора `*` (разыменование указателя).
> 
>Выражение, являющееся простым строковым литералом.
>
>Вызов функции с возвращаемым типом, являющимся ссылкой на l-значение.

Примеры **`pr-значений`** таковы:









# gl-значение

**`gl-значение`** представляет собой выражение, вычисление которого определяет идентичность объекта, битового поля или функции (сущности, имеющей место хранения).


# pr-значения

**`pr-значение`** представляет собой выражение, вычисление которого инициализирует объект или битовое поле, или вычисляет значение операнда оператора.



# x-значения

**`х-значение`** представляет собой `gl-значение`, обозначающее объект или битовое поле, ресурсы которого могут быть повторно использованы (обычно из-за того, что вскоре истечет его время жизни — так что “x” в `xvalue` означает “eXpiring value” — завершающееся значение).



# l-значение

**`l-значение`** представляет собой `gl-значение`, не являющееся `х-значением`.


# r-значения

**`r-значение`** представляет собой выражение, являющееся либо `рr-значением`, либо `х-значением`.




