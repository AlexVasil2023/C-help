
[[#Категории значений]] Б
1. [[#Традиционные l- и r-значения|Традиционные l- и r-значения]] Б.1
2. [[rvalue|Традиционные lvalue и rvalue]]
	1. [[#Преобразования l-значений в r-значения|Преобразования l-значений в r-значения]] Б.1.1
3. [[#Категории значений, начиная с C++11|Категории значений, начиная с C++11]] Б.2
	1. [[#Временная материализация|Временная материализация]]  Б.2.1
[[#gl-значение|gl-значение]]
[[#pr-значения]]
[[#x-значения]]
[[#l-значение]]
[[#r-значения]]

# Категории значений

Выражения являются краеугольным камнем языка C++, предоставляя основной механизм, позволяющий выразить необходимые вычисления. Каждое выражение имеет тип, который описывает статический тип значения, производимого при вычислении. Так, выражение `7` имеет тип `int`, как и выражение `5+2` или выражение `х`, если `х` является переменной типа `int`. Каждое выражение имеет также категорию значения (value category), которая описывает то, как было сформировано значение, и влияет на поведение выражения.

## Традиционные l- и r-значения

Исторически изначально имелись только две категории значений: `l-значения` и `r-значения`. `L-значениями` являются выражения, ссылающиеся на фактические значения, хранящиеся в памяти или в регистре компьютера, такие как выражение `х`, где `х` — имя переменной. Эти выражения могут быть изменяемыми, позволяя обновлять сохраненное значение. Например, если `х` является переменной типа `int`, то следующее присваивание заменит значение `х` на `7`:
```c++
х = 7;
```


Термин `l-значение` ([[rvalue|lvalue]]) является производным от роли, которую это выражение могло бы играть в рамках присваивания: буква / означает “левый” потому что (исторически в языке программирования С) слева от знака присваивания могут находиться только `l-значения`. И наоборот, `r-значения` ( [[rvalue|rvalues]], где `r` означает “справа”) может находиться только в правой части выражения присваивания.

Однако после стандартизации языка С в 1989 году все изменилось: хотя по-прежнему значение `int const` хранится в памяти, оно не может находиться в левой части присваивания:
```c++
int const х;        // х - неизменяемое значение
х = 7;              // Ошибка: слева должно быть изменяемое значение
```

Изменения в C++ пошли еще дальше: класс `r-значений` может находиться слева в присваиваниях. Такие присваивания на самом деле являются вызовами функций операторов присваивания соответствующих классов, а не “простыми” присваиваниями скалярных типов, так что они управляются (отдельными) правилами вызовов функций-членов.

Учитывая все эти изменения, термин `l-значение` теперь иногда трактуется как локализуемое значение. Выражения, которые ссылаются на переменную, являются не единственными выражениями `l-значений`. Еще один класс выражений, которые являются `l-значениями`, включает операцию разыменования указателя (например, `*р`), и ссылается на значения, хранящиеся по адресу, на который указывает указатель, а также выражения, которые ссылаются на члены объектов классов (например, `p->data`). Даже вызовы функций, возвращающих значения “традиционных” ссылочных на `l-значения` типов, объявленных с использованием `&`, являются `l-значениями`. Например (см. подробности в #разделе_Б_4):
```c++
std::vector<int> v;
v.front();                  // l-значение, так как возвращаемый тип
							// является ссылкой на l-значение
```

Возможно, это покажется удивительным, но строковые литералы также являются (неизменяемыми) l-значениями.

R-значения являются чисто математическими значениями (например, `7` или символ `' а '` ), которые не обязательно имеют связанное с ними место хранения; они существуют только для вычислений, но после того, как они были использованы, на них нельзя ссылаться. В частности, любые литеральные значения, за исключением строковых литералов (например, `7`, `' а'`, `true`, [[nullptr_t|nullptr]]), являются r-значениями, как и результаты многих встроенных арифметических вычислений (например, `х+5` для `х` целочисленного типа) и вызовов функций, возвращающих результат по значению. То есть все временные значения являются г-значениями. (Хотя это не относится к именованным ссылкам, которые ссылаются на них.)

### Преобразования l-значений в r-значения

В силу своей эфемерной природы `r-значения` ограничены присутствием только с правой стороны (“простых”) присваиваний: присваивание `7=8` не имеет смысла, потому что математическое значение `7` не может быть переопределено. С другой стороны, `l-значения` подобного ограничения не имеют: безусловно можно вычислить присваивание `х=у`, когда и `х`, и `у` являются переменными совместимого типа, даже если оба выражения `х` и `у` являются `l-значениями`.

Присваивание `х=у` работает благодаря тому, что выражение справа, `у`, подвергается неявному преобразованию, которое называется преобразованием `l-значения` в `r-значение` (`lvalue-to-rvalue conversion`). Как предполагает название, это преобразование принимает `l-значение` и выполняет чтение из памяти или регистра, связанных с `r-значением`, `r-значения` того же типа. Таким образом, это преобразование выполняет два действия: во-первых, оно гарантирует, что `l-значения` могут использоваться везде, где ожидается `г-значение` (например, в правой части присваивания или в математическом выражении наподобие `х+у`). Во-вторых, оно определяет, где в программе компилятор может включать (до оптимизации) инструкцию “загрузка” для чтения значения из памяти.

## Категории значений, начиная с C++11

Когда в C++11 для поддержки семантики перемещения были введены ссылки на `г-значение`, традиционного деления выражений на `l-значения` и `r-значения` стало недостаточно, чтобы описать все поведение C++11. Поэтому комитет по стандартизации C++ изменил систему категорий значений, основав ее на трех основных и двух составных категориях (см. рис. ). Основными категориями являются: [[#l-значение|l-значение]], [[#pr-значения|pr-значение]] (pure rvalue — чистое `r-значение`) и [[#x-значения|х-значение]]. Составными категориями являются [[#gl-значение|gl-значение]] (generalized lvalue — обобщенное `l-значение`, которое является объединением `l-значения` и `х-значения`) и [[#r-значения|r-значение]] (объединение `х-значения` и `рr-значения`).

Обратите внимание на то, что все выражения по-прежнему являются `l-значениями` или `r-значениями`, но теперь категория `r-значения` разделяется.
![[Template_B_1.png]]

Эта категоризация С++11 остается в силе, но в С++17 характеристики категорий были пересмотрены следующим образом.

> **`gl-значение`** представляет собой выражение, вычисление которого определяет идентичность объекта, битового поля или функции (сущности, имеющей место хранения).
> 
> **`pr-значение`** представляет собой выражение, вычисление которого инициализирует объект или битовое поле, или вычисляет значение операнда оператора.
> 
> **`х-значение`** представляет собой `gl-значение`, обозначающее объект или битовое поле, ресурсы которого могут быть повторно использованы (обычно из-за того, что вскоре истечет его время жизни — так что “x” в `xvalue` означает “eXpiring value” — завершающееся значение).
> 
> **`l-значение`** представляет собой `gl-значение`, не являющееся `х-значением`.
> 
> **`r-значение`** представляет собой выражение, являющееся либо `рr-значением`, либо `х-значением`.

Обратите внимание на то, что в С++17 (и в некоторой степени в С++11 и С++14) разделение `gl-значений` и `pr-значений`, возможно, более фундаментальное, чем традиционное отличие `l-значений` от `r-значений`.

Хотя это описание характеристик введено в C++17, оно применимо и в C++11 и C++14 (более ранние описания эквивалентны по смыслу, но с ними трудно работать).

За исключением битовых полей, `gl-значения` производят сущности с адресами. Этот адрес может быть адресом подобъектов большего охватывающего объекта. В случае подобъекта базового класса тип `gl-значения` (выражения) называется статическим типом, а тип наиболее производного объекта, частью которого является базовый класс, называется динамическим типом `gl-значения`. Если `gl-значение` не производит подобъект базового класса, статические и динамические типы являются идентичными (типом выражения).

Примеры **`l-значений`** таковы:
>
> Выражения, обозначающие переменные или функции.
> 
> Применения встроенного унарного оператора `*` (разыменование указателя).
> 
>Выражение, являющееся простым строковым литералом.
>
>Вызов функции с возвращаемым типом, являющимся ссылкой на l-значение.

Примеры **`pr-значений`** таковы:
>
> Выражения, которые состоят из литерала, не являющегося строковым литералом или литералом, определяемым пользователем.
> 
> Применения встроенного унарного оператора `&` (взятие адреса выражения).
> 
> Применение встроенных арифметических операторов.
> 
> Вызов функции с возвращаемым типом, который не является ссылочным типом.
> 
> Лямбда-выражения.

Примеры **`х-значений`** таковы:
>
> Вызов функции с возвращаемым типом, который представляет собой ссылку на `r-значение` на тип объекта (например, [[move|std::move()]]).
> 
> Приведение к `r-значению` ссылки на тип объекта.

Обратите внимание на то, что ссылки на `r-значение` на типы функций производят `l-значения`, а не `х-значения`.

Стоит подчеркнуть, что `gl-значения`, `pr-значения`, `х-значения` и так далее являются выражениями, а не значениями или сущностями. Например, переменная не является `l-значением`, несмотря на то, что выражение, описывающее переменную, является таковым:
```c++
int х = 3;      // Здесь х — переменная, но не l-значение. 3 является
				// pr-значением, инициализирующим переменную х.
int у = х;      // Здесь х — l-значение. Вычисление этого выражения
				// l-значения не дает значения 3, но обозначает объект,
				// содержащий значение 3. Такое l-значение затем
				// преобразуется в рr-значение, которое инициализирует у.
```

### Временная материализация

Ранее мы упоминали, что `l-значения` часто проходят преобразования `l-значения` в `r-значение`, потому что `pr-значения` представляют собой разновидность выражений, которые инициализируют объекты (или предоставляют операнды для большинства встроенных операторов).

В C++17 существует дуальное преобразование к данному, известное как временная материализация (но его можно было бы также назвать преобразованием `pr-значения` в `х-значение`): в любой момент, когда `pr-значение` корректно появляется там, где ожидается `gl-значение` (которое включает `х-значение`), создается временный объект, который инициализируется `рг-значением` (вспомните, что `pr-значения` являются главным образом инициализирующими значениями), и `pr-значение` заменяется временным `х-значением`. Например:
```c++
int f(int const&);
int r = f(3);
```

Поскольку `f()` в этом примере имеет ссылочный параметр, ожидается аргумент, являющийся `gl-значением`. Однако выражение `3` является `рr-значением`. Поэтому вступает в дело правило временной материализации, и выражение 3 “преобразуется” в `х-значение`, обозначающее временный объект, инициализированный значением 3.

В целом временное значение материализуется с инициализацией `рг-значением` в следующих ситуациях.
>
> `pr-значение` связано со ссылкой (например, как в вызове f` (3)` выше).
> 
> Доступ к члену `pr-значения` классового типа.
> 
> Индексация массива `рг-значений`.
> 
> Массив `рr-значений` преобразуется в указатель на его первый элемент {низведение массива).
> 
> `pr-значение` находится в списке инициализации в фигурных скобках, который для некоторого типа `X` инициализирует объект типа [[initializer_list|std::initializer_list<X>]].
>
> Применение операторов [[sizeof|sizeof]] или [[typeid|typeid]] к `рr-значению`.
> 
  `pr-значение` представляет собой выражение верхнего уровня в инструкции вида `“ехрг; ”` или выражение, приводимое к void.

Таким образом, в C++17 объект, инициализированный `рг-значением`, всегда определяется контекстом, и в результате временные значения создаются только тогда, когда они действительно необходимы. До С++17 `pr-значения` (в частности, классового типа) всегда подразумевали временные объекты. Копии этих временных объектов позже могли (необязательно) быть устранены, но компилятор попрежнему должен был обеспечивать большинство семантических ограничений операции копирования (например, мог требоваться вызываемый копирующий конструктор). В следующем примере показано следствие пересмотра правил в С++17:
```c++

```























# gl-значение

**`gl-значение`** представляет собой выражение, вычисление которого определяет идентичность объекта, битового поля или функции (сущности, имеющей место хранения).


# pr-значения

**`pr-значение`** представляет собой выражение, вычисление которого инициализирует объект или битовое поле, или вычисляет значение операнда оператора.

Примеры **`pr-значений`** таковы:
>
> Выражения, которые состоят из литерала, не являющегося строковым литералом или литералом, определяемым пользователем.
> 
> Применения встроенного унарного оператора `&` (взятие адреса выражения).
> 
> Применение встроенных арифметических операторов.
> 
> Вызов функции с возвращаемым типом, который не является ссылочным типом.
> 
> Лямбда-выражения.




# x-значения

**`х-значение`** представляет собой `gl-значение`, обозначающее объект или битовое поле, ресурсы которого могут быть повторно использованы (обычно из-за того, что вскоре истечет его время жизни — так что “x” в `xvalue` означает “eXpiring value” — завершающееся значение).

Примеры **`х-значений`** таковы:
>
> Вызов функции с возвращаемым типом, который представляет собой ссылку на `r-значение` на тип объекта (например, [[move|std::move()]]).
> 
> Приведение к `r-значению` ссылки на тип объекта.



# l-значение

**`l-значение`** представляет собой `gl-значение`, не являющееся `х-значением`.

Примеры **`l-значений`** таковы:
>
> Выражения, обозначающие переменные или функции.
> 
> Применения встроенного унарного оператора `*` (разыменование указателя).
> 
>Выражение, являющееся простым строковым литералом.
>
>Вызов функции с возвращаемым типом, являющимся ссылкой на l-значение.




# r-значения

**`r-значение`** представляет собой выражение, являющееся либо `рr-значением`, либо `х-значением`.




