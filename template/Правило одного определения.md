
[[#Правило одного определения|Правило одного определения]] А
1. [[#Единицы трансляции|Единицы трансляции]] A.1
2. [[#Объявления и определения|Объявления и определения]] A.2
3. [[#Детали правила одного определения|Детали правила одного определения]] A.3
	1. [[#Ограничения “одно на программу”|Ограничения “одно на программу”]] A.3.1
	2. [[#Ограничения “одно на единицу трансляции”|Ограничения “одно на единицу трансляции”]] A.3.2



# Правило одного определения

Правило одного определения (one-definition rule — ODR) — это краеугольный камень хорошо оформленного структурирования программ на C++. Наиболее общие следствия этого правила достаточно просты для того, чтобы их запомнить и использовать: следует определять невстраиваемые функции и объекты ровно один раз для всех файлов, а классы и встраиваемые функции и встраиваемые переменные — не более одного раза на единицу трансляции. При этом нужно следить за тем, чтобы все определения одного и того же объекта были идентичны.

Однако основные проблемы заключены в деталях, которые в сочетании с инстанцированием шаблона могут оказаться обескураживающими. Данное приложение поможет заинтересованному читателю получить всестороннее представление об `ODR`. Если отдельные темы подробно описаны в той или иной главе книги, об этом обязательно упоминается в тексте приложения.

# Единицы трансляции

На практике программы на C++ пишутся путем заполнения файлов “кодом”. Однако границы, устанавливаемые файлом, не так важны в контексте `ODR`. Вместо этого важную роль играют так называемые единицы трансляции. По сути, единица трансляции (`translation unit`) представляет собой результат препроцессорной обработки файла, переданного компилятору. Препроцессор удаляет части кода в соответствии с директивами условной компиляции (`#if`, `#ifdef` и связанными с ними), удаляет комментарии, (рекурсивно) вставляет файлы, определяемые директивой `#include`, и разворачивает макросы.

Следовательно, в контексте `ODR` файлы
```c++
// ===== header.hpp:
#ifdef DO_DEBUG
	#define debug(x)  std::cout << x << '\n'
#else
	#define debug(x)
#endif

void debuglnit() ;
```

и
```c++
// ===== myprog.cpp:
#include "header.hpp"
int main()
{
	debugInit();
	debug("main()");
}
```

эквивалентны одному следующему файлу:
```c++
// ===== myprog,срр:
void debugInit();

int main{)
{
	debugInit();
}
```

Связи между единицами трансляции устанавливаются с помощью соответствующих объявлений с внешним связыванием в двух единицах трансляции (например, двух объявлений глобальной функции `debug_init()`).

Следует отметить, что концепция единицы трансляции несколько более абстрактна, чем просто концепция “файла, обработанного препроцессором”. Например, если дважды передать компилятору файл после обработки препроцессором для формирования единой программы, он выдаст две отдельные единицы трансляции (хотя, надо сказать, для этого нет причин).

# Объявления и определения

В разговоре между собой программисты часто не делают различия между терминами объявление (`declaration`) и определение (`definition`). Тем не менее в контексте `ODR` важно точное значение этих слов.

***===Объявление===*** — это конструкция C++, которая (обычно) первый раз (или повторно) вводит в программу какое-либо имя. Объявление может одновременно быть и определением, в зависимости от того, какой объект и как вводится.
>
> ***===Пространства имен и псевдонимы пространств имен===***. Объявления пространств имен и их псевдонимов также являются определениями, хотя термин "Определение" в этом контексте необычен, поскольку список членов пространства имен позднее может быть расширен (в отличие, например, от классов и перечислимых типов).
> 
> ***===Классы, шаблоны классов, функции, шаблоны функций, функции-члены и шаблоны функций-членов.===*** Объявление является определением тогда и только тогда, когда объявление включает связанное с именем тело, ограниченное фигурными скобками. Это правило включает объединения, операторы, операторы-члены, статические функции-члены, конструкторы и деструкторы, а также явные специализации шаблонных версий таких объектов (т.е. любого объекта типа класса и типа функции).
> 
> ***===Перечисления===***. Объявление является определением тогда и только тогда, когда оно включает список перечисленных значений, заключенный в фигурные скобки.
>
> ***===Локальные переменные и нестатические члены-данные===***. Эти объекты всегда рассматриваются как определения, хотя изредка встречаются и редкие исключения. Обратите внимание на то, что объявление параметра функции в определении функции само по себе является определением, потому что обозначает локальную переменную, но параметр функции в объявлении функции, которое не является определением, также не является определением.
> 
> ***===Глобальные переменные.===*** Если непосредственно перед объявлением не стоит ключевое слово [[extern|extern]] или переменная инициализирована, такое объявление глобальной переменной является одновременно ее определением. В противном случае это не определение.
> 
> ***===Статические данные-члены.===*** Объявление является определением тогда и только тогда, когда оно находится за пределами класса или шаблона класса, членом которого оно является, или если член определен как [[inline|inline]] или [[constexpr|constexpr]] в классе или шаблоне класса.
> 
> ***===Явная и частичная специализации.===*** Объявление является определением, если объявление, следующее после `template<>` или `template<...>`, само по себе является определением, с тем исключением, что явная специализация статических членов-данных или шаблонов статических членов-данных является определением только тогда, когда включает инициализатор.

Прочие объявления определениями не являются. Сюда входят псевдонимы типов (получаемые с помощью [[typedef|typedef]] или `using`), объявления `using`, директивы `using`, объявления параметров шаблонов, директивы явного инстанцирования, объявления [[static#static_assert|static_assert]] и т.д.

# Детали правила одного определения

Как уже упоминалось во введении к данному приложению, практическое использование этого правила связано с массой тонкостей. Рассмотрим ограничения данного правила в соответствии с областью их действия.

## Ограничения “одно на программу”

Перечисленные ниже объекты могут иметь лишь одно определение на программу.
>
> Невстраиваемые функции и невстраиваемые функции-члены (включая полные специализации шаблонов функций).
> 
> Невстраиваемые переменные (по сути, переменные, объявленные в области видимости пространства имен или в глобальной области видимости, и без спецификатора [[static|static]]).
> 
> Невстраиваемые статические данные-члены.

Например, приведенная ниже программа на C++, состоящая из двух единиц трансляции, неработоспособна.
```c++
// ===== Единица трансляции 1:
int counter;
// ===== Единица трансляции 2;
int counter;
// Ошибка: повторное определение (нарушение ODR)
```

Это правило не применяется к объектам с внутренним связыванием (сущности, объявленные со спецификатором [[static|static]] в глобальной области видимости или области видимости пространства имен), поскольку даже когда два таких объекта имеют одно и то же имя, они считаются разными. Объекты, объявленные в безымянных пространствах имен, считаются различными, если они находятся в разных единицах трансляции; в С++11 и более поздних стандартах такие сущности также по умолчанию имеют внутреннее связывание, но до С++11 они имели по умолчанию внешнее связывание. Например, следующие две единицы трансляции можно объединить в корректную программу на C++:
```c++
// ===== Единица трансляции 1:
static int counter =2; //Не связана с прочими единицами трансляции
namespace
{
	void unique()      // Не связана с прочими единицами трансляции
	{
	}
}

// ===== Единица трансляции 2:
static int counter = 0; // Не связана с прочими единицами трансляции
namespace
{
	void unique()       // Не связана с прочими единицами трансляции
	{
		++counter;
	}
}

int main()
{
	unique() ;
}
```

Кроме того, в программе должен быть только один из упомянутых выше объектов, если упомянутые выше объекты используются в контексте, отличном от отброшенной ветви конструкции `if constexpr` (функциональная возможность, доступная только в C++17). У термина “используются” в данном контексте точное значение. Он означает, что к данному объекту где-то в программе есть обращение, которое приводит к необходимости генерации кода. Это обращение может быть доступом к значению переменной, вызовом функции или получением адреса такого объекта. Это может быть явное обращение в исходном тексте, но может быть и неявное. Например, выражение с оператором [[new|new]] может создавать неявный вызов связанного с ним оператора [[delete|delete]] для обработки ситуаций, когда конструктор генерирует исключение, которое требует очистки неиспользуемой (но выделенной) памяти. Другой пример — копирующие конструкторы, которые должны быть определены, даже если в конечном итоге они удаляются оптимизатором (кроме случаев, когда такое удаление требуется языком, что является распространенной практикой в C++17). Виртуальные функции также используются неявно (с помощью внутренних структур, которые обеспечивают их вызовы), если только это не чисто виртуальные функции. Существует несколько других видов неявного использования, однако для краткости изложения здесь они не рассматриваются.

Существуют некоторые обращения, которые не являются использованием в указанном смысле. Это применение объекта в качестве невычисляемого операнда (например, операнд оператора [[sizeof|sizeof]] или [[decltуре|decltype]]). [[Применение шаблонов на практике#Модель включения|Операнд оператора typeid  является невычисляемым только в некоторых случаях]]. Конкретно, если ссылка появляется как часть оператора [[typeid|typeid]], это не является использованием в указанном ранее смысле, если только аргумент оператора [[typeid|typeid]] не используется с полиморфным объектом (объектом с — возможно, унаследованными — виртуальными функциями). Рассмотрим, например, следующую программу, состоящую из одного файла:
```c++
#include <typeinfo>

class Decider
{
	#if defined(DYNAMIC)
		virtual ~Decider()
		{
		}
	#endif
);

extern Decider d;

int main()
{
	char const* name = typeid(d).name();
	return (int)sizeof(d);
}
```

Эта программа корректна тогда и только тогда, когда не определен символ препроцессора `DYNAMIC`. На самом деле переменная `d` не определена, однако обращение к `d` в операторе `sizeof(d)` не является использованием, а обращение в операторе `typeid(d)` может быть использованием, только если `d` — объект полиморфного типа (поскольку в общем случае не всегда удается определить результат применения полиморфного оператора [[typeid|typeid]] до момента выполнения).

В соответствии со стандартом C++ ограничения, описанные в данном разделе, не требуют диагностических сообщений от компилятора C++. На практике же компоновщик почти всегда сообщает о них как о двойных или пропущенных определениях.

## Ограничения “одно на единицу трансляции”
































