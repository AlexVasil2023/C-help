
[[#Перегрузка свойств типов|Перегрузка свойств типов]] 20
1. [[#Специализация алгоритма|Специализация алгоритма]] 20.1
2. [[#Диспетчеризация дескрипторов|Диспетчеризация дескрипторов]] 20.2
3. [[#Включение/отключение шаблонов функций|Включение/отключение шаблонов функций]] 20.3
	1. [[#Предоставление нескольких специализаций|Предоставление нескольких специализаций]] 20.3.1
	2. [[#Откуда берется EnableIf?|Откуда берется EnableIf?]] 20.3.2
	3. [[#if времени компиляции|if времени компиляции]] 20.3.3



# Перегрузка свойств типов

Перегрузка функций позволяет использовать одно и то же имя для нескольких различных функций, лишь бы они отличались типами своих параметров. Например:
```c++
void f(int);
void f(char const*);
```

При использовании шаблонов функций перегрузка выполняется с учетом схемы типов, как, например, для указателя на `Т` или `Аггау<Т>`:
```c++
template<typename Т> void f(T*);
template<typename Т> void f(Array<T>);
```

Учитывая распространенность [[Реализация свойств типов|свойств типов]], вполне естественным оказывается желание перегрузки шаблонов функций на основе свойств аргументов шаблона. Например:
```c++
template<typename Number> 
void f(Number);                       // Только для чисел

template<typename Container>
void f(Container);                    // Только для контейнеров
```

Однако в настоящее время C++ не обеспечивает никакого способа непосредственного выражения перегрузки на основе свойств типов. Два шаблона функций `f`, показанные выше, фактически являются объявлением одного и того же шаблона функции, а не различных перегрузок, потому что при сравнении двух шаблонов функций имена параметров шаблона игнорируются.

К счастью, есть целый ряд методов, которые могут использоваться для эмуляции перегрузки шаблонов функций на основе свойств типов. Именно эти методы, а также общие мотивы такой перегрузки рассматриваются в данной главе.

# Специализация алгоритма

Одним из распространенных мотивов перегрузок шаблонов функций является предоставление более специализированных версий алгоритмов, основанное на знании особенностей используемых типов. Рассмотрим простую операцию `swap()` для обмена двух значений:
```c++
template<typename Т>
void swap(T& х, Т& у)
{
	T tmp(х);
	х = у;
	у = tmp;
)
```

Данная реализация включает в себя три операции копирования. Однако для некоторых типов можно предоставить более эффективную операцию `swap()`, как, например, для типа [[Array|Аrrау<Т>]], который хранит свои данные в виде указателя на содержимое массива и его длину:
```c++
template<typename Т>
void swap(Array<T>& х, Array<T>& у)
{
	swap(x.ptr, у.ptr);
	swap(x.len, y.len);
}
```

Обе реализации `swap()` корректно обменивают содержимое двух объектов `Аггау<Т>`. Однако последняя реализация более эффективна, так как она использует дополнительные свойства `Аггау<Т>` (в частности, информацию о наличии и смысле `ptr` и `lеп`), которые не доступны для произвольного типа. Последний шаблон функции (концептуально) более специализирован, чем первый, потому что он выполняет ту же операцию для подмножества типов, принимаемых первым шаблоном функции. К счастью, второй шаблон функции является также более специализированным на основе правил [[Шаблоны Специализация и перегрузка#Частичное упорядочение перегруженных шаблонов функций|частичного упорядочения шаблонов функций]], поэтому компилятор выберет более специализированный (а следовательно, и более эффективный) шаблон функции при его применимости для данного типа (т.е. для аргументов `Аггау<Т>`) и вернется к более общему (и потенциально менее эффективному) алгоритму, когда более специализированная версия окажется неприменима.

Подход проектирования и оптимизации более специализированных вариантов универсального алгоритма называется специализацией алгоритма. Более специализированные варианты применяются к подмножеству допустимых входных данных универсального алгоритма, которое задается определенными типами или свойствами типов, и обычно являются более эффективными, чем обобщенные реализации универсального алгоритма.

Решающим значением для реализации специализации алгоритма является то свойство, что более специализированные варианты, когда они применимы, выбираются автоматически, так что вызывающему коду даже не нужно знать об их существовании. В нашем примере с шаблоном `swap()` это было достигнуто путем перегрузки (концептуально) более специализированным шаблоном функции (второй `swap()`) более общего шаблона функции (первый `swap()` ), и гарантии того, что более специализированный шаблон функции является также более специализированным на основе правил частичного упорядочения C++.

Не все концептуально более специализированные варианты алгоритмов могут непосредственно транслироваться в шаблоны функций, которые обеспечивают правильное поведение частичного упорядочения. Рассмотрим в нашем следующем примере функцию `advancelter()` (аналог [[advance|std::advance()]] из стандартной библиотеки C++), которая перемещает итератор `х` вперед на `n` шагов. Этот общий алгоритм может работать с любым входным итератором (`input iterator`):
```c++
template<typename Inputlterator, typename Distance>
void advancelter(Inputlterators x, Distance n)
{
	while (n > 0)     	// Линейное время
	{
		++x;
		--n;
	}
}
```

Для определенного класса итераторов (которые предоставляют возможность произвольного доступа) можно предложить более эффективную реализацию:
```c++
template<typename RandomAccessIterator, typename Distance>
void advancelter(RandomAccessIterator& x, Distance n)
{
	x += n;         // Константное время
}
```

К сожалению, определение обоих шаблонов функций приведет к ошибке компилятора, поскольку, как отмечалось во введении, шаблоны функций, отличающиеся только именами параметров шаблонов, не перегружаются. В остальной части этой главы мы рассмотрим методы, имитирующие желаемый эффект перегрузки этих шаблонов функций.

# Диспетчеризация дескрипторов

Одним из подходов к специализации алгоритмов является присваивание “дескрипторов” (“тегов”) различным вариантам реализации алгоритма в виде уникального типа, который идентифицирует конкретный вариант. Например, чтобы справиться с только что представленной проблемой `advancelter()`, можно использовать типы дескрипторов категорий итераторов стандартной библиотеки (определены ниже) для идентификации двух вариантов реализации алгоритма `advancelter()`:
```c++
template<typename Iterator, typename Distance>
void advancelterImpl(Iterators x, Distance n, std::input_iterator_tag)
{
	while (n > 0) // Линейное время
	{
		++x;
		--n;
	}
}

template<typename Iterator, typename Distance>
void advancelterImpl(Iterators x, Distance n, 
					std::random_access_iterator_tag)
{
	x += n;     // Константное время
}
```

Тогда шаблон функции `advancelter()` просто передает свои аргументы и соответствующий дескриптор:
```c++
template<typename Iterator, typename Distance>
void advancelter(Iterators x, Distance n)
{
	advancelterImpl(x, n,
			typename
			std::iterator_traits<Iterator>::iterator_category());
}
```

Класс свойств [[iterator_traits|std::iterator_traits]] предоставляет категорию итератора через его член-тип `iterator_category`. Категория итератора является одним из типов `_tag`, упоминавшихся ранее, который указывает, с какой разновидностью итератора мы имеем дело. В стандартной библиотеке C++ доступные дескрипторы определены с помощью наследования, отражающего ситуацию, когда один дескриптор описывает категорию, которая является производной от другой:
```c++
namespace std
{
	struct input_iterator_tag{};
	struct output_iterator_tag{};
	struct forward_iterator_tag :public input_iterator_tag{};
	struct bidirectional_iterator_tag:public forward_iterator_tag{};
	struct random_access_iterator_tag:public bidirectional_iterator_tag{};
}
```

Ключ к эффективному использованию диспетчеризации дескрипторов заключается в отношениях между дескрипторами. Наши два варианта `advancelterlmpl()` отмечены дескрипторами [[input_iterator_tag|std::input_iterator_tag]] и [[random_access_iterator_tag|std::random_access_iterator_tag]], а поскольку дескриптор [[random_access_iterator_tag|std::random_access_iterator_tag]] наследуется от [[input_iterator_tag|std::input_iterator_tag]], обычная перегрузка функций при вызове `advancelterlmpl()` с итератором произвольного доступа предпочтет более специализированный вариант алгоритма (который использует [[random_access_iterator_tag|std::гandom_access_iterator_tag]]). Таким образом, диспетчеризация дескрипторов основана на делегировании функциональности из единственного, первичного шаблона функции набору вариантов `_impl`, помеченных таким образом, что обычная перегрузка функций выберет наиболее специализированный алгоритм, применимый к данным аргументам шаблона.

Диспетчеризация хорошо работает, когда имеется естественная иерархическая структура характеристик, используемых алгоритмом, и существующий набор классов свойств, которые предоставляют эти значения дескрипторов. Данный способ не столь удобен, когда специализация алгоритма зависит от произвольных свойств типов, например от того, имеет ли тип `Т` тривиальный оператор копирующего присваивания. Для этого нам нужна более мощная методика.

## Включение/отключение шаблонов функций

Специализация алгоритмов включает в себя предоставление различных шаблонов функций, которые выбираются на основе свойств аргументов шаблона.

К сожалению, ни[[Шаблоны Специализация и перегрузка#Частичное упорядочение перегруженных шаблонов функций| частичное упорядочение шаблонов функции]], ни разрешение перегрузки ( #приложение_В, “Разрешение перегрузки”) не являются достаточно мощными для того, чтобы выразить более сложные формы специализации алгоритмов.

Одним из помощников для решения этих вопросов, которые предоставляет стандартная библиотека C++, является шаблон [[Семантика перемещения - Отключение шаблонов с помощью enable_if - template|std::enable_if]]. В данном разделе рассматривается, как можно реализовать этот вспомогательный шаблон путем введения соответствующего шаблона псевдонима, который мы назовем `Enablelf` во избежание коллизии имен.

Также, как и [[Семантика перемещения - Отключение шаблонов с помощью enable_if - template|std::enable_if]], шаблон псевдонима `Enablelf` можно использовать для того, чтобы включать (или отключать) конкретные шаблоны функций при определенных условиях. Например, версия с произвольным доступом алгоритма `advanceIter()` может быть реализована следующим образом:
```c++
template<typename Iterator>
constexpr bool IsRandomAccessIterator =
	IsConvertible<
		typename std::iterator_traits<Iterator>::iterator_category,
		std::random_access_iterator_tag>;

template<typename Iterator, typename Distance>
Enablelf<IsRandomAccessIterator<Iterator>>
	advanceIter(Iterators x, Distance n)
{
	x += n; // Константное время
}
```

Здесь специализация `Enablelf` используется для включения данного варианта `advancelter()` только тогда, когда итератор на самом деле является итератором произвольного доступа. Эти два аргумента `Enablelf` являются логическим условием, указывающим, следует ли включить этот шаблон, и типом, получаемым при раскрытии `Enablelf`, когда условие имеет значение `true`. В нашем примере выше мы использовали свойство типа [[IsConvertibleT#IsConvertibleT|IsConvertible]], в качестве условия для определения свойства типа `IsRandomAccessIterator`. Таким образом, эта конкретная версия нашей реализации `advancelter()` рассматривается только тогда, когда конкретный тип, подставляемый вместо `Iterator`, может использоваться в качестве итератора с произвольным доступом (т.е. он связан с дескриптором, преобразуемым в [[random_access_iterator_tag|std::random_access_iterator_tag]]).

Шаблон `Enablelf` имеет очень простую реализацию:
```c++
template<bool, typename Т = void>
struct EnablelfT
{
};

template<typename Т>
struct EnableIfT<true, T>
{
	using Type = Т;
};

template<bool Cond, typename T = void>
using Enablelf = typename EnableIfT<Cond, T>::Type;
```

`EnableIf` раскрывается в тип и, следовательно, реализован как шаблон псевдонима. Для его реализации мы хотим использовать [[Шаблоны Специализация и перегрузка#Специализация и перегрузка|частичную специализацию]], но шаблоны псевдонимов не могут быть частично специализированы. К счастью, можно ввести шаблон вспомогательного класса `EnableIfТ`, который делает всю необходимую фактическую работу, нужную нам, и тогда шаблон псевдонима `EnableIf` просто выбирает результирующий тип из вспомогательного шаблона. Если условие истинно, `EnableIfT<...>::Туре` (а значит, и `EnableIf<...>`) просто вычисляется как второй аргумент шаблона `Т`. Когда условие имеет значение `false`, `EnableIf` не производит допустимый тип, потому что первичный шаблон класса `EnableIfТ` не имеет члена с именем `Туре`. Обычно это рассматривается как ошибка, но в [[SFINAE#Принцип SFINAE|контексте SFINAE]] в качестве возвращаемого типа шаблона функции это приводит к сбою вывода аргумента шаблона, так что данный шаблон функции удаляется из рассмотрения.

В `advanceIter()` использование `EnableIf` означает, что шаблон функции будет доступен (и иметь возвращаемый тип `void`), когда аргумент `Iterator` будет итератором произвольного доступа, а если `Iterator` не является таковым — этот шаблон будет полностью удален из рассмотрения. Мы можем рассматривать `EnableIf` как способ “охранять” шаблоны от инстанцирования с аргументами шаблона, которые не соответствуют требованиям его реализации (поскольку этот `advanceIter()` может быть инстанцирован только с итератором произвольного доступа, так как он требует операции, которые доступны только для итераторов с произвольным доступом). Хотя защита с помощью `Enablelf` не является совершенно “пуленепробиваемой” (пользователь может утверждать, что предоставляемый им тип является итератором с произвольным доступом, без предоставления необходимых операций), данный метод может помочь ранней диагностике распространенных ошибок.

Теперь мы знаем, как явно “активировать” более специализированный шаблон для типов, к которым он применим. Однако этого недостаточно: мы должны также “деактивировать” менее специализированный шаблон, поскольку компилятор не имеет возможности “заказать” два шаблона, так что при применимости обеих версий он сообщит об ошибке неоднозначности. К счастью, решить эту проблему легко: мы просто используем тот же шаблон `Enablelf` для менее специализированного шаблона, но только с отрицанием условного выражения. Это гарантирует, что для любого конкретного типа итератора будет активирован только один из двух шаблонов. Таким образом, наша версия `advanceIter()` для итератора, который не является итератором с произвольным доступом, принимает следующий вид:
```c++
template<typename Iterator, typename Distance>
EnableIf<!IsRandomAccessIterator<Iterator>>
		advanceIter(Iterator& x, Distance n)
{
	while (n > 0) // Линейное время
	{
		++x;
		--n;
	}
}
```

## Предоставление нескольких специализаций

Предыдущая схема обобщается для случаев, где требуется более двух альтернативных реализаций. Мы просто оснащаем все альтернативы конструкциями `Enableif`, условия которых являются взаимоисключающими для определенного набора конкретных аргументов шаблона. Эти условия обычно используют различные характеристики типов, которые могут быть выражены через их свойства.

Рассмотрим, например, добавление третьего варианта алгоритма `advanceIter()`: на этот раз мы хотим разрешить перемещение “назад”, указывая отрицательное расстояние. Это явно недопустимо для входного итератора и вполне корректно для итератора произвольного доступа. Однако стандартная библиотека включает в себя еще и понятие двунаправленного итератора, который так же допускает передвижение назад без необходимости произвольного доступа. Реализация этого варианта требует несколько более сложной логики: каждый шаблон функции должен использовать `Enableif` с условием, которое является взаимоисключающим с условиями всех прочих шаблонов функций, представляющих различные варианты алгоритма. Это приводит нас к следующему набору условий.
>
> Итератор произвольного доступа: случай произвольного доступа (константное время; перемещение и вперед, и назад).
> 
> Двунаправленный итератор без произвольного доступа: двунаправленный случай (линейное время; перемещение и вперед, и назад).
> 
> Входной итератор, не являющийся двунаправленным: общий случай (линейное время; перемещение только вперед).

Описанную ситуацию реализует следующий набор шаблонов функций:
```c++
#include <iterator>

// Реализация для итераторов произвольного доступа:
template<typename Iterator, typename Distance>
EnableIf<isRandomAccessIterator<Iterator>>
advancelter(Iterators x, Distance n)
{
	x += n; // Константное время
}

template<typename Iterator>
constexpr bool IsBidirectionalIterator =
	IsConvertible <
		typename std::iterator_traits<Iterator>::iterator_category,
		std::bidirectional_iterator_tag >;
		
// Реализация для двунаправленных итераторов:
template<typename Iterator, typename Distance>
Enablelf <IsBidirectionalIterator<Iterator>&&
		!IsRandomAccessIterator<Iterator>>
advanceIter(Iterator& x, Distance n)
{
	if (n > 0)
	{
		for (; n > 0; ++x, --n) // Линейное время
		{
		}
	}
	else {
		for (; n c 0; --x, ++n) // Линейное время
		{
		}
	}
}

// Реализация для всех прочих итераторов:
template<typename Iterator, typename Distance>
Enablelf <!isBidirectionalIterator<lterator>>
advanceIter(Iterator& x, Distance n)
{
	if (n < 0)
	{
		throw "advancelter(): неверная категория итератора";
	}
	
	while (n > 0)
	{
		++x;
		--n;
	}
}
```

Делая условие `Enablelf` для каждого шаблона функции взаимоисключающим с условиями `Enablelf` для всех других шаблонов функций, мы гарантируем, что для каждого данного набора аргументов успешно выводится не более одного шаблона функции.

Наш пример иллюстрирует один из недостатков использования `Enablelf` для специализации алгоритмов: каждый раз, когда вводится новый вариант алгоритма, необходимо пересмотреть условия всех вариантов алгоритма для обеспечения того, чтобы все они были взаимно исключающими. В отличие от этого введение варианта для двунаправленного итератора с помощью [[Перегрузка свойств типов#Диспетчеризация дескрипторов|диспетчеризации дескрипторов]] требует добавления только новой перегрузки `advanceIterlmpl()` с использованием дескриптора [[bidirectional_iterator_tag|std::bidirectional_iterator_tag]].

Обе методики — диспетчеризация дескрипторов и `Enablelf` — оказываются полезными в различных контекстах. В общем случае диспетчеризация дескрипторов поддерживает простую диспетчеризацию на основе иерархии дескрипторов, в то время как `Enablelf` поддерживает более сложную диспетчеризацию на основе произвольного набора характеристик, определяемых свойствами типов.

## Откуда берется EnableIf?

`Enablelf` обычно используется в качестве типа возвращаемого значения шаблона функции. Однако этот подход не работает для шаблонов конструкторов или шаблонов функций преобразования типов, потому что в них не задается возвращаемый тип. Кроме того, использование `EnableIf` может сделать тип возвращаемого значения очень трудным для чтения и понимания. В таких случаях мы можем вместо этого встроить `EnableIf` в аргумент шаблона по умолчанию следующим образом:
```c++
#include <iterator>
#include "enableif.hpp"
#include "isconvertible.hpp"

template<typename Iterator>
constexpr bool IslnputIterator =
	Isconvertible <
		typename std::iterator_traits<iterator>::iterator_category,
		std::input_iterator_tag>;

template<typename T>
class Container
{
	public:
		// Конструирование из последовательности входных итераторов:
		template<typename Iterator,
				typename = EnableIf<isInputIterator<Iterator>>>
		Container(Iterator first, Iterator last);

		// Преобразование в контейнер, если типы значений преобразуемы:
		template<typename U, typename = EnableIf<isConvertible<T, U>>>
		operator Container<U>() const;
};
```

Однако тут есть проблема. Если мы попытаемся добавить еще одну перегрузку (например, более эффективную версию конструктора `Container` для итераторов произвольного доступа), это приведет к ошибке:
```c++
// Конструирование из последовательности входных итераторов:
template<typename Iterator,
		typename = EnableIf<isInputIterator<Iterator> &&
							!IsRandomAccessIterator<Iterator>>>
Container(Iterator first, Iterator last);

template<typename Iterator,
		typename = EnableIf<isRandomAccessIterator<Iterator>>>
Container(Iterator first, Iterator last); // Ошибка: повторное
									// объявление шаблона конструктора
```

Проблема заключается в том, что два шаблона конструкторов идентичны, за исключением аргумента шаблона по умолчанию, но аргументы шаблона по умолчанию не учитываются при определении эквивалентности двух шаблонов.

Мы можем решить эту проблему, добавив еще один параметр шаблона по умолчанию, так что два шаблона конструкторов будут иметь различное количество параметров шаблона:
```c++
// Конструирование из последовательности входных итераторов:
template<typename Iterator,
		typename = EnableIf<islnputIterator<Iterator> &&
							!IsRandomAccessIterator<Iterator >>>
Container(Iterator first, Iterator last);

template<typename Iterator,
		typename = EnableIf<isRandomAccessIterator<Iterator>>,
		typename = int>     // Дополнительный фиктивный параметр
Container(Iterator first, Iterator last); // Теперь работает
```

## if времени компиляции

Стоит отметить, что конструкция С++17 [[Программирование времени компиляции#Инструкция if времени компиляции|if constexpr]] во многих случаях позволяет избежать необходимости в `Enablelf`. Например, в C++17 наш пример `advancelter()` можно переписать следующим образом:
```c++
template<typename Iterator, typename Distance>
void advancelter(Iterator& x, Distance n)
{
	if constexpr(IsRandomAccessIterator<Iterator>)
	{
		// Реализация для итераторов произвольного доступа:
		х += п; // Константное время
	}
	else if constexpr(IsBidirectionalIterator<Iterator>)
	{
		// Реализация для двунаправленных итераторов:
		if (n > 0)
		{
			for(;n>0;++х,--n){} // Линейное время для положительных n
		}
		else {
			for(;n<0;--x,++n){} // Линейное время для отрицательных n
		}
	}
	else {
			// Реализация для прочих (как минимум входных) итераторов
		if (п < 0)
		{
			throw "advancelter () : неверная категория итератора";
		}
		
		while(n>0)
		{ ++х; --n; } // Линейное время для положительных n
	}
}
```









