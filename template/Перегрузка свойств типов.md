
[[#Перегрузка свойств типов|Перегрузка свойств типов]] 20
1. [[#Специализация алгоритма|Специализация алгоритма]] 20.1
2. [[#Диспетчеризация дескрипторов|Диспетчеризация дескрипторов]] 20.2
3. [[#Включение/отключение шаблонов функций|Включение/отключение шаблонов функций]] 20.3
	1. [[#Предоставление нескольких специализаций|Предоставление нескольких специализаций]] 20.3.1
	2. [[#Откуда берется EnableIf?|Откуда берется EnableIf?]] 20.3.2
	3. [[#if времени компиляции|if времени компиляции]] 20.3.3
	4. [[#Концепты|Концепты]] 20.3.4
4. [[#Специализация класса|Специализация класса]] 20.4
	1. [[#Включение/отключение шаблонов классов|Включение/отключение шаблонов классов]] 20.4.1
	2. [[#Диспетчеризация дескрипторов для шаблонов классов|Диспетчеризация дескрипторов для шаблонов классов]] 20.4.2
5. [[#Шаблоны, безопасные по отношению к инстанцированию|Шаблоны, безопасные по отношению к инстанцированию]] 20.5
6. [[#В стандартной библиотеке|В стандартной библиотеке]] 20.6



# Перегрузка свойств типов

Перегрузка функций позволяет использовать одно и то же имя для нескольких различных функций, лишь бы они отличались типами своих параметров. Например:
```c++
void f(int);
void f(char const*);
```

При использовании шаблонов функций перегрузка выполняется с учетом схемы типов, как, например, для указателя на `Т` или `Аггау<Т>`:
```c++
template<typename Т> void f(T*);
template<typename Т> void f(Array<T>);
```

Учитывая распространенность [[Реализация свойств типов|свойств типов]], вполне естественным оказывается желание перегрузки шаблонов функций на основе свойств аргументов шаблона. Например:
```c++
template<typename Number> 
void f(Number);                       // Только для чисел

template<typename Container>
void f(Container);                    // Только для контейнеров
```

Однако в настоящее время C++ не обеспечивает никакого способа непосредственного выражения перегрузки на основе свойств типов. Два шаблона функций `f`, показанные выше, фактически являются объявлением одного и того же шаблона функции, а не различных перегрузок, потому что при сравнении двух шаблонов функций имена параметров шаблона игнорируются.

К счастью, есть целый ряд методов, которые могут использоваться для эмуляции перегрузки шаблонов функций на основе свойств типов. Именно эти методы, а также общие мотивы такой перегрузки рассматриваются в данной главе.

# Специализация алгоритма

Одним из распространенных мотивов перегрузок шаблонов функций является предоставление более специализированных версий алгоритмов, основанное на знании особенностей используемых типов. Рассмотрим простую операцию `swap()` для обмена двух значений:
```c++
template<typename Т>
void swap(T& х, Т& у)
{
	T tmp(х);
	х = у;
	у = tmp;
)
```

Данная реализация включает в себя три операции копирования. Однако для некоторых типов можно предоставить более эффективную операцию `swap()`, как, например, для типа [[Array|Аrrау<Т>]], который хранит свои данные в виде указателя на содержимое массива и его длину:
```c++
template<typename Т>
void swap(Array<T>& х, Array<T>& у)
{
	swap(x.ptr, у.ptr);
	swap(x.len, y.len);
}
```

Обе реализации `swap()` корректно обменивают содержимое двух объектов `Аггау<Т>`. Однако последняя реализация более эффективна, так как она использует дополнительные свойства `Аггау<Т>` (в частности, информацию о наличии и смысле `ptr` и `lеп`), которые не доступны для произвольного типа. Последний шаблон функции (концептуально) более специализирован, чем первый, потому что он выполняет ту же операцию для подмножества типов, принимаемых первым шаблоном функции. К счастью, второй шаблон функции является также более специализированным на основе правил [[Шаблоны Специализация и перегрузка#Частичное упорядочение перегруженных шаблонов функций|частичного упорядочения шаблонов функций]], поэтому компилятор выберет более специализированный (а следовательно, и более эффективный) шаблон функции при его применимости для данного типа (т.е. для аргументов `Аггау<Т>`) и вернется к более общему (и потенциально менее эффективному) алгоритму, когда более специализированная версия окажется неприменима.

Подход проектирования и оптимизации более специализированных вариантов универсального алгоритма называется специализацией алгоритма. Более специализированные варианты применяются к подмножеству допустимых входных данных универсального алгоритма, которое задается определенными типами или свойствами типов, и обычно являются более эффективными, чем обобщенные реализации универсального алгоритма.

Решающим значением для реализации специализации алгоритма является то свойство, что более специализированные варианты, когда они применимы, выбираются автоматически, так что вызывающему коду даже не нужно знать об их существовании. В нашем примере с шаблоном `swap()` это было достигнуто путем перегрузки (концептуально) более специализированным шаблоном функции (второй `swap()`) более общего шаблона функции (первый `swap()` ), и гарантии того, что более специализированный шаблон функции является также более специализированным на основе правил частичного упорядочения C++.

Не все концептуально более специализированные варианты алгоритмов могут непосредственно транслироваться в шаблоны функций, которые обеспечивают правильное поведение частичного упорядочения. Рассмотрим в нашем следующем примере функцию `advancelter()` (аналог [[advance|std::advance()]] из стандартной библиотеки C++), которая перемещает итератор `х` вперед на `n` шагов. Этот общий алгоритм может работать с любым входным итератором (`input iterator`):
```c++
template<typename Inputlterator, typename Distance>
void advancelter(Inputlterators x, Distance n)
{
	while (n > 0)     	// Линейное время
	{
		++x;
		--n;
	}
}
```

Для определенного класса итераторов (которые предоставляют возможность произвольного доступа) можно предложить более эффективную реализацию:
```c++
template<typename RandomAccessIterator, typename Distance>
void advancelter(RandomAccessIterator& x, Distance n)
{
	x += n;         // Константное время
}
```

К сожалению, определение обоих шаблонов функций приведет к ошибке компилятора, поскольку, как отмечалось во введении, шаблоны функций, отличающиеся только именами параметров шаблонов, не перегружаются. В остальной части этой главы мы рассмотрим методы, имитирующие желаемый эффект перегрузки этих шаблонов функций.

# Диспетчеризация дескрипторов

Одним из подходов к специализации алгоритмов является присваивание “дескрипторов” (“тегов”) различным вариантам реализации алгоритма в виде уникального типа, который идентифицирует конкретный вариант. Например, чтобы справиться с только что представленной проблемой `advancelter()`, можно использовать типы дескрипторов категорий итераторов стандартной библиотеки (определены ниже) для идентификации двух вариантов реализации алгоритма `advancelter()`:
```c++
template<typename Iterator, typename Distance>
void advancelterImpl(Iterators x, Distance n, std::input_iterator_tag)
{
	while (n > 0) // Линейное время
	{
		++x;
		--n;
	}
}

template<typename Iterator, typename Distance>
void advancelterImpl(Iterators x, Distance n, 
					std::random_access_iterator_tag)
{
	x += n;     // Константное время
}
```

Тогда шаблон функции `advancelter()` просто передает свои аргументы и соответствующий дескриптор:
```c++
template<typename Iterator, typename Distance>
void advancelter(Iterators x, Distance n)
{
	advancelterImpl(x, n,
			typename
			std::iterator_traits<Iterator>::iterator_category());
}
```

Класс свойств [[iterator_traits|std::iterator_traits]] предоставляет категорию итератора через его член-тип `iterator_category`. Категория итератора является одним из типов `_tag`, упоминавшихся ранее, который указывает, с какой разновидностью итератора мы имеем дело. В стандартной библиотеке C++ доступные дескрипторы определены с помощью наследования, отражающего ситуацию, когда один дескриптор описывает категорию, которая является производной от другой:
```c++
namespace std
{
	struct input_iterator_tag{};
	struct output_iterator_tag{};
	struct forward_iterator_tag :public input_iterator_tag{};
	struct bidirectional_iterator_tag:public forward_iterator_tag{};
	struct random_access_iterator_tag:public bidirectional_iterator_tag{};
}
```

Ключ к эффективному использованию диспетчеризации дескрипторов заключается в отношениях между дескрипторами. Наши два варианта `advancelterlmpl()` отмечены дескрипторами [[input_iterator_tag|std::input_iterator_tag]] и [[random_access_iterator_tag|std::random_access_iterator_tag]], а поскольку дескриптор [[random_access_iterator_tag|std::random_access_iterator_tag]] наследуется от [[input_iterator_tag|std::input_iterator_tag]], обычная перегрузка функций при вызове `advancelterlmpl()` с итератором произвольного доступа предпочтет более специализированный вариант алгоритма (который использует [[random_access_iterator_tag|std::гandom_access_iterator_tag]]). Таким образом, диспетчеризация дескрипторов основана на делегировании функциональности из единственного, первичного шаблона функции набору вариантов `_impl`, помеченных таким образом, что обычная перегрузка функций выберет наиболее специализированный алгоритм, применимый к данным аргументам шаблона.

Диспетчеризация хорошо работает, когда имеется естественная иерархическая структура характеристик, используемых алгоритмом, и существующий набор классов свойств, которые предоставляют эти значения дескрипторов. Данный способ не столь удобен, когда специализация алгоритма зависит от произвольных свойств типов, например от того, имеет ли тип `Т` тривиальный оператор копирующего присваивания. Для этого нам нужна более мощная методика.

## Включение/отключение шаблонов функций

Специализация алгоритмов включает в себя предоставление различных шаблонов функций, которые выбираются на основе свойств аргументов шаблона.

К сожалению, ни[[Шаблоны Специализация и перегрузка#Частичное упорядочение перегруженных шаблонов функций| частичное упорядочение шаблонов функции]], ни разрешение перегрузки ( [[Разрешение перегрузки#Разрешение перегрузки|“Разрешение перегрузки”]]) не являются достаточно мощными для того, чтобы выразить более сложные формы специализации алгоритмов.

Одним из помощников для решения этих вопросов, которые предоставляет стандартная библиотека C++, является шаблон [[Семантика перемещения - Отключение шаблонов с помощью enable_if - template|std::enable_if]]. В данном разделе рассматривается, как можно реализовать этот вспомогательный шаблон путем введения соответствующего шаблона псевдонима, который мы назовем `Enablelf` во избежание коллизии имен.

Также, как и [[Семантика перемещения - Отключение шаблонов с помощью enable_if - template|std::enable_if]], шаблон псевдонима `Enablelf` можно использовать для того, чтобы включать (или отключать) конкретные шаблоны функций при определенных условиях. Например, версия с произвольным доступом алгоритма `advanceIter()` может быть реализована следующим образом:
```c++
template<typename Iterator>
constexpr bool IsRandomAccessIterator =
	IsConvertible<
		typename std::iterator_traits<Iterator>::iterator_category,
		std::random_access_iterator_tag>;

template<typename Iterator, typename Distance>
Enablelf<IsRandomAccessIterator<Iterator>>
	advanceIter(Iterators x, Distance n)
{
	x += n; // Константное время
}
```

Здесь специализация `Enablelf` используется для включения данного варианта `advancelter()` только тогда, когда итератор на самом деле является итератором произвольного доступа. Эти два аргумента `Enablelf` являются логическим условием, указывающим, следует ли включить этот шаблон, и типом, получаемым при раскрытии `Enablelf`, когда условие имеет значение `true`. В нашем примере выше мы использовали свойство типа [[IsConvertibleT#IsConvertibleT|IsConvertible]], в качестве условия для определения свойства типа `IsRandomAccessIterator`. Таким образом, эта конкретная версия нашей реализации `advancelter()` рассматривается только тогда, когда конкретный тип, подставляемый вместо `Iterator`, может использоваться в качестве итератора с произвольным доступом (т.е. он связан с дескриптором, преобразуемым в [[random_access_iterator_tag|std::random_access_iterator_tag]]).

Шаблон `Enablelf` имеет очень простую реализацию:
```c++
template<bool, typename Т = void>
struct EnablelfT
{
};

template<typename Т>
struct EnableIfT<true, T>
{
	using Type = Т;
};

template<bool Cond, typename T = void>
using Enablelf = typename EnableIfT<Cond, T>::Type;
```

`EnableIf` раскрывается в тип и, следовательно, реализован как шаблон псевдонима. Для его реализации мы хотим использовать [[Шаблоны Специализация и перегрузка#Специализация и перегрузка|частичную специализацию]], но шаблоны псевдонимов не могут быть частично специализированы. К счастью, можно ввести шаблон вспомогательного класса `EnableIfТ`, который делает всю необходимую фактическую работу, нужную нам, и тогда шаблон псевдонима `EnableIf` просто выбирает результирующий тип из вспомогательного шаблона. Если условие истинно, `EnableIfT<...>::Туре` (а значит, и `EnableIf<...>`) просто вычисляется как второй аргумент шаблона `Т`. Когда условие имеет значение `false`, `EnableIf` не производит допустимый тип, потому что первичный шаблон класса `EnableIfТ` не имеет члена с именем `Туре`. Обычно это рассматривается как ошибка, но в [[SFINAE#Принцип SFINAE|контексте SFINAE]] в качестве возвращаемого типа шаблона функции это приводит к сбою вывода аргумента шаблона, так что данный шаблон функции удаляется из рассмотрения.

В `advanceIter()` использование `EnableIf` означает, что шаблон функции будет доступен (и иметь возвращаемый тип `void`), когда аргумент `Iterator` будет итератором произвольного доступа, а если `Iterator` не является таковым — этот шаблон будет полностью удален из рассмотрения. Мы можем рассматривать `EnableIf` как способ “охранять” шаблоны от инстанцирования с аргументами шаблона, которые не соответствуют требованиям его реализации (поскольку этот `advanceIter()` может быть инстанцирован только с итератором произвольного доступа, так как он требует операции, которые доступны только для итераторов с произвольным доступом). Хотя защита с помощью `Enablelf` не является совершенно “пуленепробиваемой” (пользователь может утверждать, что предоставляемый им тип является итератором с произвольным доступом, без предоставления необходимых операций), данный метод может помочь ранней диагностике распространенных ошибок.

Теперь мы знаем, как явно “активировать” более специализированный шаблон для типов, к которым он применим. Однако этого недостаточно: мы должны также “деактивировать” менее специализированный шаблон, поскольку компилятор не имеет возможности “заказать” два шаблона, так что при применимости обеих версий он сообщит об ошибке неоднозначности. К счастью, решить эту проблему легко: мы просто используем тот же шаблон `Enablelf` для менее специализированного шаблона, но только с отрицанием условного выражения. Это гарантирует, что для любого конкретного типа итератора будет активирован только один из двух шаблонов. Таким образом, наша версия `advanceIter()` для итератора, который не является итератором с произвольным доступом, принимает следующий вид:
```c++
template<typename Iterator, typename Distance>
EnableIf<!IsRandomAccessIterator<Iterator>>
		advanceIter(Iterator& x, Distance n)
{
	while (n > 0) // Линейное время
	{
		++x;
		--n;
	}
}
```

## Предоставление нескольких специализаций

Предыдущая схема обобщается для случаев, где требуется более двух альтернативных реализаций. Мы просто оснащаем все альтернативы конструкциями `Enableif`, условия которых являются взаимоисключающими для определенного набора конкретных аргументов шаблона. Эти условия обычно используют различные характеристики типов, которые могут быть выражены через их свойства.

Рассмотрим, например, добавление третьего варианта алгоритма `advanceIter()`: на этот раз мы хотим разрешить перемещение “назад”, указывая отрицательное расстояние. Это явно недопустимо для входного итератора и вполне корректно для итератора произвольного доступа. Однако стандартная библиотека включает в себя еще и понятие двунаправленного итератора, который так же допускает передвижение назад без необходимости произвольного доступа. Реализация этого варианта требует несколько более сложной логики: каждый шаблон функции должен использовать `Enableif` с условием, которое является взаимоисключающим с условиями всех прочих шаблонов функций, представляющих различные варианты алгоритма. Это приводит нас к следующему набору условий.
>
> Итератор произвольного доступа: случай произвольного доступа (константное время; перемещение и вперед, и назад).
> 
> Двунаправленный итератор без произвольного доступа: двунаправленный случай (линейное время; перемещение и вперед, и назад).
> 
> Входной итератор, не являющийся двунаправленным: общий случай (линейное время; перемещение только вперед).

Описанную ситуацию реализует следующий набор шаблонов функций:
```c++
#include <iterator>

// Реализация для итераторов произвольного доступа:
template<typename Iterator, typename Distance>
EnableIf<isRandomAccessIterator<Iterator>>
advancelter(Iterators x, Distance n)
{
	x += n; // Константное время
}

template<typename Iterator>
constexpr bool IsBidirectionalIterator =
	IsConvertible <
		typename std::iterator_traits<Iterator>::iterator_category,
		std::bidirectional_iterator_tag >;
		
// Реализация для двунаправленных итераторов:
template<typename Iterator, typename Distance>
Enablelf <IsBidirectionalIterator<Iterator>&&
		!IsRandomAccessIterator<Iterator>>
advanceIter(Iterator& x, Distance n)
{
	if (n > 0)
	{
		for (; n > 0; ++x, --n) // Линейное время
		{
		}
	}
	else {
		for (; n c 0; --x, ++n) // Линейное время
		{
		}
	}
}

// Реализация для всех прочих итераторов:
template<typename Iterator, typename Distance>
Enablelf <!isBidirectionalIterator<lterator>>
advanceIter(Iterator& x, Distance n)
{
	if (n < 0)
	{
		throw "advancelter(): неверная категория итератора";
	}
	
	while (n > 0)
	{
		++x;
		--n;
	}
}
```

Делая условие `Enablelf` для каждого шаблона функции взаимоисключающим с условиями `Enablelf` для всех других шаблонов функций, мы гарантируем, что для каждого данного набора аргументов успешно выводится не более одного шаблона функции.

Наш пример иллюстрирует один из недостатков использования `Enablelf` для специализации алгоритмов: каждый раз, когда вводится новый вариант алгоритма, необходимо пересмотреть условия всех вариантов алгоритма для обеспечения того, чтобы все они были взаимно исключающими. В отличие от этого введение варианта для двунаправленного итератора с помощью [[Перегрузка свойств типов#Диспетчеризация дескрипторов|диспетчеризации дескрипторов]] требует добавления только новой перегрузки `advanceIterlmpl()` с использованием дескриптора [[bidirectional_iterator_tag|std::bidirectional_iterator_tag]].

Обе методики — диспетчеризация дескрипторов и `Enablelf` — оказываются полезными в различных контекстах. В общем случае диспетчеризация дескрипторов поддерживает простую диспетчеризацию на основе иерархии дескрипторов, в то время как `Enablelf` поддерживает более сложную диспетчеризацию на основе произвольного набора характеристик, определяемых свойствами типов.

## Откуда берется EnableIf?

`Enablelf` обычно используется в качестве типа возвращаемого значения шаблона функции. Однако этот подход не работает для шаблонов конструкторов или шаблонов функций преобразования типов, потому что в них не задается возвращаемый тип. Кроме того, использование `EnableIf` может сделать тип возвращаемого значения очень трудным для чтения и понимания. В таких случаях мы можем вместо этого встроить `EnableIf` в аргумент шаблона по умолчанию следующим образом:
```c++
#include <iterator>
#include "enableif.hpp"
#include "isconvertible.hpp"

template<typename Iterator>
constexpr bool IslnputIterator =
	Isconvertible <
		typename std::iterator_traits<iterator>::iterator_category,
		std::input_iterator_tag>;

template<typename T>
class Container
{
	public:
		// Конструирование из последовательности входных итераторов:
		template<typename Iterator,
				typename = EnableIf<isInputIterator<Iterator>>>
		Container(Iterator first, Iterator last);

		// Преобразование в контейнер, если типы значений преобразуемы:
		template<typename U, typename = EnableIf<isConvertible<T, U>>>
		operator Container<U>() const;
};
```

Однако тут есть проблема. Если мы попытаемся добавить еще одну перегрузку (например, более эффективную версию конструктора `Container` для итераторов произвольного доступа), это приведет к ошибке:
```c++
// Конструирование из последовательности входных итераторов:
template<typename Iterator,
		typename = EnableIf<isInputIterator<Iterator> &&
							!IsRandomAccessIterator<Iterator>>>
Container(Iterator first, Iterator last);

template<typename Iterator,
		typename = EnableIf<isRandomAccessIterator<Iterator>>>
Container(Iterator first, Iterator last); // Ошибка: повторное
									// объявление шаблона конструктора
```

Проблема заключается в том, что два шаблона конструкторов идентичны, за исключением аргумента шаблона по умолчанию, но аргументы шаблона по умолчанию не учитываются при определении эквивалентности двух шаблонов.

Мы можем решить эту проблему, добавив еще один параметр шаблона по умолчанию, так что два шаблона конструкторов будут иметь различное количество параметров шаблона:
```c++
// Конструирование из последовательности входных итераторов:
template<typename Iterator,
		typename = EnableIf<islnputIterator<Iterator> &&
							!IsRandomAccessIterator<Iterator >>>
Container(Iterator first, Iterator last);

template<typename Iterator,
		typename = EnableIf<isRandomAccessIterator<Iterator>>,
		typename = int>     // Дополнительный фиктивный параметр
Container(Iterator first, Iterator last); // Теперь работает
```

## if времени компиляции

Стоит отметить, что конструкция С++17 [[Программирование времени компиляции#Инструкция if времени компиляции|if constexpr]] во многих случаях позволяет избежать необходимости в `Enablelf`. Например, в C++17 наш пример `advancelter()` можно переписать следующим образом:
```c++
template<typename Iterator, typename Distance>
void advancelter(Iterator& x, Distance n)
{
	if constexpr(IsRandomAccessIterator<Iterator>)
	{
		// Реализация для итераторов произвольного доступа:
		х += п; // Константное время
	}
	else if constexpr(IsBidirectionalIterator<Iterator>)
	{
		// Реализация для двунаправленных итераторов:
		if (n > 0)
		{
			for(;n>0;++х,--n){} // Линейное время для положительных n
		}
		else {
			for(;n<0;--x,++n){} // Линейное время для отрицательных n
		}
	}
	else {
			// Реализация для прочих (как минимум входных) итераторов
		if (п < 0)
		{
			throw "advancelter () : неверная категория итератора";
		}
		
		while(n>0)
		{ ++х; --n; } // Линейное время для положительных n
	}
}
```

Этот код гораздо яснее. Более специализированные пути выполнения (например, для итераторов произвольного доступа) будут создаваться только для типов, которые могут их поддерживать. Таким образом, код может безопасно включать операции, присущие не всем итераторам (например, `+=`), при условии, что в исходном тексте они надлежащим образом охраняются конструкцией `if constexpr`.

Однако и здесь есть свои недостатки. Такое применение `if constexpr` возможно только тогда, когда разница в обобщенном компоненте может быть полностью выражена в теле шаблона функции. Нам все еще нужен `Enableif`, если:
>
> используются различные “интерфейсы”;
> 
> необходимы разные определения классов;
> 
> не должно существовать корректных инстанцирований для определенных списков аргументов шаблонов.

Последнюю ситуацию соблазнительно обработать с использованием следующей схемы:
```c++
template<typename Т>
void f(Т р)
{
	if constexpr(condition<T>::value)
	{
		// Что-то делаем...
	}
	else
	{
		// Для этого Т f() не имеет смысла:
		static_assert(condition<T>::value,
		"Вызов f() для этого Т не имеет смысла");
	}
}
```

Но поступать так не рекомендуется, потому что этот способ плохо согласуется со [[SFINAE|SFINAE]]: функция `f<Т>()` не удаляется из списка кандидатов, а потому может мешать другим результатам разрешения перегрузки. В качестве альтернативы при использовании `Enablelf` вызов `f<T>()` приведет к удалению при сбое подстановки `Enablelf<...>`.

## Концепты

Методы, представленные до настоящего времени, работают хорошо, но они зачастую неуклюжи, могут требовать большого количества ресурсов компилятора и в случае ошибки выдавать громоздкие диагностические сообщения. Поэтому многие авторы обобщенных библиотек были бы рады видеть в языке средство, позволяющее достичь того же результата более эффективно и непосредственно. По этой причине такое языковое средство под названием [[Concepts|концепты]], скорее всего, будет добавлено к языку в ближайшем будущем; см [[Семантика перемещения - Применение концептов для упрощения выражений enable_if - template|раздел]] и [[Полиморфная мощь шаблонов#Применение концептов|раздел]], а также [[Concepts#Концепты|“Концепты”]].

Например, ожидается, что наши перегруженные конструкторы класса `Container` будут выглядеть следующим образом:
```c++
template<typename T>
class Container
{
	public:
		// Конструирование из последовательности входных итераторов:
		template<typename Iterator>
		requires IslnputIterator<Iterator>
		Container(Iterator first, Iterator last);
		
		// Конструирование из последовательности
		// итераторов произвольного доступа:
		template<typename Iterator>
		requires IsRandomAccessIterator<Iterator>
		Container(Iterator first, Iterator last);
		
		// Преобразование в контейнер, если типы значений преобразуемы:
		template<typename U>
		requires IsConvertible<T, U>
		operator Container<U> () const;
};
```

Конструкция требований (requires clause) (рассматривается в [[Concepts#Использование концептов (template)|Использование концептов]]) описывает требования шаблона. Если какое-либо из требований не выполнено, шаблон не рассматривается в качестве кандидата. Поэтому [[Concepts|концепты]] являются более непосредственным выражением идеи, формулируемой с помощью `Enablelf`, при этом поддерживаемым самим языком.

Конструкция требований имеет дополнительные преимущества перед `EnableIf`. Категоризация ограничений (описанная в [[Concepts#Поглощение ограничений (template)|Поглощение ограничений]]) предоставляет возможность упорядочения шаблонов, которые отличаются только требованиями, устраняя тем самым необходимость в диспетчеризации дескрипторов. Кроме того, требование может быть прикреплено к сущности, не являющейся шаблоном. Например, для того, чтобы предоставить функцию-член [[sort|sort()]] только тогда, когда объекты типа `Т` можно сравнивать с помощью оператора `<`:
```c++
template<typename Т>
class Container
{
	public:
		
		...
		
		requires HasLess<T>
		void sort()
		{
			...
		}
};
```

# Специализация класса

Частичные специализации шаблона классов могут использоваться для предоставления альтернативных, специализированных реализаций шаблонов классов для определенных аргументов шаблонов так же, как мы использовали перегрузки для шаблонов функций. Подобно перегруженным шаблонам функций может иметь смысл дифференциация этих частичных специализаций на основе свойств аргументов шаблона. Рассмотрим обобщенный шаблон класса `Dictionary` с типами ключа и значения в качестве параметров шаблона. Простой (но неэффективный) словарь может быть реализован при условии, что тип ключа обеспечивает один лишь оператор сравнения на равенство:
```c++
template<typename Key, typename Value>
class Dictionary
{
	private:
		vector<pair<Key const, Value>> data;
		
	public:
		// Индексированный доступ к данным:
		value& operator[](Key const& key)
		{
			// Поиск элемента с данным ключом:
			for (auto& element : data)
			{
				if (element.first == key)
				{
					return element.second;
				}
			}
			
			// Элемента с указанным ключом нет — добавляем:
			data.push back(pair<Key const, Value>(key, Value()));
			return data.back().second;
		}
	...
}
```

Если тип ключа поддерживает оператор `<`, можно обеспечить более эффективную реализацию на основе контейнера [[map#std map|map]] стандартной библиотеки. Аналогично, если тип ключа поддерживает операции хеширования, мы можем обеспечить еще более эффективную реализацию на основе [[unordered_map#std unordered_map|unordered_map]] из стандартной библиотеки.

## Включение/отключение шаблонов классов

Способ включения/отключения различных реализаций шаблонов классов заключается в использовании включения/отключения частичных специализаций шаблонов классов. Для использования `Enablelf` с частичной специализацией шаблона класса мы сначала введем в `Dictionary` неименованный параметр шаблона по умолчанию:
```c++
template<typename Key, typename Value, typename = void>
class Dictionary
{
	... // Реализация c vector, как показано выше
};
```

Этот новый параметр шаблона служит якорем для `Enablelf`, который теперь может быть встроен в список аргументов шаблона частичной специализации для версии словаря с использованием контейнера [[map#std map|map]]:
```c++
template<typename Key, typename Value>
class Dictionary<Key, Value, Enablelf <HasLess<Key>>>
{
	private:
		map<Key, Value> data;
	public;
		value& operator[](Key const& key)
		{
			return data[key];
		}
	...
};
```

В отличие от перегруженных шаблонов функций, нам не нужно отключать никакие условия в первичном шаблоне, потому что любая частичная специализация имеет приоритет над первичным шаблоном. Однако, добавив еще одну реализацию для ключей с поддержкой операций хеширования, мы должны будем обеспечить взаимоисключаемость условий частичных специализаций:
```c++
template<typename Key, typename Value, typename = void>
class Dictionary
{
	... // Реализация c vector, как показано выше
};

template<typename Key, typename Value>
class Dictionary<Key, Value, EnableIf<HasLess<Key>>>
{
	{
		... // Реализация c map, как показано выше
	}
}

template<typename Key, typename Value>
class Dictionary<Key, Value, EnableIf<HasHash<Key>>>
{
	private:
		unordered_map<Key, Value> data;

	public:
		value&, operator[] (Key const& key)
		{
			return data[key];
		}
	...
};
```

## Диспетчеризация дескрипторов для шаблонов классов

Диспетчеризация дескрипторов может использоваться также и для выбора среди частичных специализаций шаблона класса. Чтобы это проиллюстрировать, определим тип функционального объекта `Advance<Iterator>`, аналога алгоритма `advanceIter()`, который перемещает итератор на некоторое количество шагов (этот алгоритм уже использовался в предыдущих разделах). Мы предоставляем как общую реализацию (для входных итераторов), так и специализированные реализации для двунаправленных итераторов и итераторов произвольного доступа, полагаясь на вспомогательное свойство `BestMatchInSet` (описано ниже) для выбора наилучшего соответствия дескриптору категории итератора:
```c++
// Первичный шаблон (преднамеренно не определен):
template<
	typename Iterator,
	typename Tag =
		BestMatchInSet<
			typename std::iterator_traits<Iterator>::iterator_category,
			std::input_iterator_tag,
			std::bidirectional_iterator_tag,
			std::random_access_iterator_tag>>
class Advance;

// Общая линейная реализация для входных итераторов:
template<typename Iterator>
class Advance<Iterator, std::input_iterator_tag>
{
	public:
		using DifferenceType =
			typename std::iterator_traits<Iterator>::difference_type;

		void operator()(Iterators х, DifferenceType n) const
		{
			while (n > 0)
			{
				++x;
				--n;
			}
		}
};

// Двунаправленный линейный алгоритм для двунаправленных итераторов:
template<typename Iterator>
class Advance<Iterator, std::bidirectional_iterator_tag>
{
	public:
		using DifferenceType =
			typename std::iterator_traits<Iterator>::difference__type;

		void operator()(Iterators x, DifferenceType n) const
		{
			if (n > 0)
			{
				while (n > 0)
				{
					++x;
					--n;
				}
			}
			else {
				while (n < 0)
				{
					--x;
					++n;
				}
			}
		}
};

// Двунаправленный с константным временем алгоритм
// для итераторов произвольного доступа:
template<typename Iterator>
class Advance<Iterator, std::random_access_iterator_tag>
{
	public:
		using DifferenceType =
			typename std::iterator_traits<Iterator>::difference_type;

			void operator()(Iterators x, DifferenceType n) const
			{
				x += n;
			}
}
```

Эта формулировка аналогична таковой для диспетчеризации дескрипторов для шаблонов функций. Однако задача заключается в написании свойства `BestMatchInSet`, предназначенного для выбора наиболее подходящего дескриптора (среди дескрипторов входного, двунаправленного и итератора произвольного доступа) для данного итератора. В сущности, предназначение этого свойства — выяснить, какая из следующих перегрузок была бы выбрана для данного значения дескриптора категории итератора, и сообщить его тип параметра:
```c++
void f(std::input_iterator_tag);
void f(std::bidirectional_iterator_tag);
void f(std::random_access_iterator_tag);
```

Самый простой способ эмулировать разрешение перегрузки — использовать ее на самом деле, как показано ниже:
```c++
// Строим набор перегрузок match() для типов в Types...:
template<typename... Types>
struct MatchOverloads;

// Базовый случай: соответствий нет:
template<>
struct MatchOverloads<>
{
	static void match(...);
};

// Рекурсивный случай: вводим новую перегрузку match():
template<typename T1, typename... Rest>
struct MatchOverloads<T1, Rest...> : public MatchOverloads<Rest...>
(
	static T1 match(T1);                  // Перегрузка для T1
	using MatchOverloads<Rest...>::match; // Сбор перегрузок
};

// Поиск лучшего соответствия для Т из Types...:
template<typename Т, typename... Types>
struct BestMatchInSetT
{
	using Type = decltype(MatchOverloads<Types...>::match(declval<T>()));
}

template<typename T, typename... Types>
using BestMatchInSet = typename BestMatchInSetT<T, Types...>::Type;
```

Шаблон `MatchOverloads` использует рекурсивное наследование для объявления функции `match()` с каждым типом из входного множества `Types`. Каждое инстанцирование рекурсивной частичной специализации `MatchOverloads` вводит новые функции `match()` для следующего типа в списке. Затем он использует объявление `using` для сбора функций `match()`, определенных в базовом классе, который обрабатывает оставшиеся в списке типы. При рекурсивном применении результат представляет собой полный набор перегрузок `match()`, соответствующий заданным типам, каждый из которых возвращает свой тип параметра. Затем шаблон `BestMatchInSetT` передает объект `Т` этому множеству перегруженных функций `match()` и производит возвращаемый тип выбранной (наилучшей) функции `match()`. Если ни одна из функций не является соответствующей, возвращающий `void` базовый случай (который использует многоточие для соответствия любому аргументу) указывает на сбой. Подытоживая, мы видим, что `BestMatchlnSetT` транслирует результат перегрузки функции в свойство и обеспечивает относительно легкое использование диспетчеризации дескрипторов для выбора среди частичных специализаций шаблона класса.

# Шаблоны, безопасные по отношению к инстанцированию

Суть метода `EnableIf` состоит во включении конкретного шаблона или частичной специализации только в случае соответствия аргументов шаблона некоторым определенным критериям. Например, наиболее эффективная разновидность алгоритма `advanceIter()` проверяет, что категория итератора-аргумента преобразуема в `std::random_access_iterator_tag`. Отсюда следует, что алгоритму доступны различные операции итераторов произвольного доступа.

Но что, если довести это понятие до предела и закодировать каждую операцию, выполняемую шаблоном над его аргументами, как часть условия `Enableif`? Инстанцирование такого шаблона никогда не будет неудачным, потому что аргументы шаблона, не предоставляющие необходимые операции, приведут к сбою вывода типов (через `EnableIf`), не позволяя перейти к инстанцированию. Мы будем говорить о таких шаблонах как о “безопасных с точки зрения инстанцирования” и представим здесь набросок реализации таких шаблонов.

Начнем с очень простого шаблона `min()`, который вычисляет минимальное из двух значений. Обычно в виде шаблона этот алгоритм реализуется следующим образом:
```c++
template<typename Т>
Т const& min(T const& х, Т const& у)
{
	if (У < х)
	{
		return у;
	}
	
	return х;
}
```

Этот шаблон требует, чтобы тип `Т` имел оператор `<`, способный сравнивать два значения типа `Т` (в частности, два константных [[r-значение|l-значения]] `Т`), а затем неявно преобразующий результат этого сравнения в `bool` для использования в инструкции [[if|if]]. Свойство, которое проверяет наличие оператора `<` и вычисляет тип его результата, является аналогом дружественного по отношению к [[SFINAE#SFINAE и свойства||SFINAE свойства]] `PlusResultT`; однако для удобства мы приведем код `LessResultT` здесь:
```c++
#include <utility>       // Для declval()
#include <type_traits>   // Для true_type и false_type

template<typename T1, typename T2>
class HasLess
{
	template<typename T> 
	struct Identity;
	
	template<typename U1, typename U2> static std::true_type
	test(Identity<decltype(std::declval<U1>()<std::declval<U2>())>*);
	
	template<typename U1, typename U2> static std::false_type
	test(...);

public:
	static constexpr bool value =
		decltype(test<T1, T2>(nullptr))::value;
};

template<typename T1, typename T2, bool HasLess>
class LessResultImpl
{
	public:
		using Type = decltype(std::declval<T1>() <std::declval<T2>());
};

template<typename T1, typename T2>
class LessResultImpl<T1, T2, false>
{
};

template<typename T1, typename T2>
class LessResultT
	: public LessResultImpl<T1, T2, HasLess<T1, T2>::value>
{
};

template<typename T1, typename T2>
using LessResult = typename LessResultT<T1, T2>::Type;
```

Затем это свойство может быть объединено со свойством `IsConvertible`, чтобы сделать `min()` безопасным с точки зрения инстанцирования:
```c++
#include "isconvertible.hpp"
#include "lessresult.hpp"

template<typename T>
EnableIf<isConvertible<LessResult<T const&, T const&>, bool>, T const&>
min(T const& x, T const& y)
{
	if (У < х)
	{
		return у;
	}
	return х;
}
```

Поучительно попытаться вызвать эту функцию `min()` с различными типами с разными операторами `<` (или с полностью отсутствующим данным оператором), как показано в следующем примере:
```c++
#include "min.hpp"

struct X1 { };
bool operator< (X1 const&, X1 const&)
{
	return true;
}

struct X2 { };
bool operator<(X2, X2)
{
	return true;
}

struct X3 { };
bool operator<(X3&, X3&)
{
	return true;
}

struct X4 { );
struct BoolConvertible
{
	operator bool() const
	{
		return true;  // неявное преобразование в bool
	}
};

struct X5 { };
BoolConvertible operator< (X5 const&, X5 const&)
{
	return BoolConvertible();
}

struct NotBoolConvertible  // Нет преобразования в bool
{
};

struct Х6 { };
NotBoolConvertible operator< (Х6 const&, Х6 const&)
{
	return NotBoolConvertible();
}

struct BoolLike
{
	explicit operator bool() const
	{
		return true;      // Явное преобразование в bool
	}
};

struct X7 { };
BoolLike operator< (X7 const&, X7 const&)
{
	return BoolLike();
}

int main()
{
	min(X1(), X1());  // X1 может быть передан в min()
	min(X2(), X2());  // X2 может быть передан в min()
	min(X3(), X3());  // Ошибка: ХЗ не может быть передан в min()
	min(X4(), X4());  // Ошибка: Х4 не может быть передан в min()
	min(X5(), X5());  // X5 может быть передан в min()
	min(X6(), X6());  // Ошибка: Х6 не может быть передан в min()
	min(X7(), X7());  // Неожиданная ошибка:
					  // Х7 не может быть передан min ()
}
```

При компиляции этой программы обратите внимание на то, что хотя для четырех различных вызовов `min()` (для `ХЗ`, `Х4`, `Х6` и `Х7`) есть ошибки, они генерируются не телом `min()`, как было бы в варианте, небезопасном с точки зрения инстанцирования. Вместо этого мы получаем сообщения о том, что не существует подходящей функции `min()`, потому что единственный вариант был исключен в соответствии с принципом [[SFINAE|SFINAE]]. Вот как выглядит диагностика `Clang`:
```
min.срр:41:3: error: no matching function for call to 'min'
min(X3(), X3()); // ERROR: X3 cannot be passed to min

./min.hpp:8:1: note: candidate template ignored: substitution failure
[with T = X3] : no type named 'Type' in
'LessResultT<const X3 s, const X3 S>'

min(T consts x, T consts y)
```

Таким образом, `Enablelf` допускает инстанцирование только для тех аргументов шаблона, которые отвечают требованиям шаблона (`X1`, `Х2` и `Х5`), поэтому мы никогда не получим сообщения об ошибке из тела `min()`. Кроме того, если бы у нас была некоторая другая перегрузка `min()`, которая могла бы работать с этими типами, то процесс разрешения перегрузки мог бы выбрать ее вместо вывода сообщения об ошибках.

Последний тип в нашем примере, `Х7`, иллюстрирует некоторые тонкости реализации безопасных с точки зрения инстанцирования шаблонов. В частности, если `Х7` передается в небезопасный с точки зрения инстанцирования шаблон `min()`, то инстанцирование будет успешным. Безопасный с точки зрения инстанцирования шаблон `min()` отвергает его, потому что `BoolLike` не является неявно преобразуемым в `bool`. Различие здесь особенно тонкое: [[explicit|explicit-преобразование]] в `bool` может в некоторых контекстах использоваться неявно, в том числе в логических условиях для управления потоком выполнения ([[if|if]], [[while|while]], [[for|for]] и `do`), во встроенных операторах `!`, `&&` и `||` и в тернарном операторе `?:`. В этих контекстах значение называется контекстно преобразуемым в `bool`.

Однако наше упорство в требовании наличия общего, неявного преобразования в `bool` приводит к тому, что наш безопасный с точки зрения инстанцирования шаблон перегружен ограничениями, т.е. его требования (в `EnableIf`) оказываются сильнее, чем его фактические потребности (что необходимо для надлежащего инстанцирования шаблона). Если, с другой стороны, полностью забыть о требовании преобразования в `bool`, наш шаблон `min()` будет недоограничен, и эго допускало бы некоторые аргументы шаблона, которые могут вызвать сбой при инстанцировании (например, `Х6`).

Чтобы исправить безопасный с точки зрения инстанцирования шаблон `min()`, нам требуется свойство, способное определить, является ли тип `Т` контекстно преобразуемым в `bool`. В определении этого свойства нам не помогут ни инструкции управления потоком выполнения (потому что инструкции не могут выполняться в контексте [[SFINAE|SFINAE]]), ни логические операции, которые могут быть перегружены для произвольного типа. К счастью, тернарный оператор `?:` является выражением, и он не перегружаем, поэтому он позволяет проверить, является ли данный тип контекстно преобразуемым в `bool`:
```c++
#include <utility>       // Для declval()
#include <type__traits> // Для true_type и false_type

template<typename T>
class IsContextualBoolT
{
	private:
		template<typename T> struct Identity;
		template<typename U> static std::true_type
		test(Identity < decltype(declval<U>() ? 0 : 1) > *);
		
		template<typename U> static std::false_type
		test(...);
	public:
		static constexpr bool value = decltype(test<T>(nullptr))::value;
};

template<typename T>
constexpr bool IsContextualBool = IsContextualBoolT<T>::value;
```

При наличии этого нового свойства мы можем предоставить безопасный с точки зрения инстанцирования шаблон `min()` с правильным набором требований в `EnableIf`:
```c++
#include "iscontextualbool.hpp"
#include "lessresult.hpp"

template<typename T>
EnableIf<isContextualBool<LessResult<T const&, T const&>>,
		T const&>
		min(T const& x, T const& y)
{
	if (y < x)
		return y;
	
	return x;
}
```

Методы, используемые здесь для того, чтобы сделать шаблон `min()` безопасным с точки зрения инстанцирования, можно расширить для описания требований для нетривиальных шаблонов. Такое расширение можно обеспечить путем объединения проверок различных требований в свойства, которые описывают некоторые классы типов, как, например, однонаправленные итераторы, и комбинирования этих свойств в пределах `EnableIf`. Поступая так, мы получаем как преимущества лучшего поведения перегрузки, так и устранение “романов об ошибках”, которые так любят выводить компиляторы при ошибках в инстанцировании глубоко вложенного шаблона. С другой стороны, в этом случае сообщения об ошибках имеют тенденцию к неконкретности относительно конкретной неудачной операции. Кроме того, как мы показали на примере небольшого и несложного шаблона `min()`, аккуратное определение и кодирование точных требований шаблона может оказаться сложной задачей.

# В стандартной библиотеке

Стандартная библиотека C++ предоставляет дескрипторы итераторов для различных итераторов — дескрипторы входного, выходного, однонаправленного, двунаправленного и с произвольным доступом итераторов, которые мы использовали в нашей презентации. Эти дескрипторы итераторов являются частью стандартных свойств итераторов ([[iterator_traits|std::iterator_traits]]) и требований, предъявляемых к итераторам, чтобы они могли безопасно использоваться для целей диспетчеризации дескрипторов.

Шаблон класса стандартной библиотеки C++11 [[enable_if|std::enable_if]] демонстрирует то же поведение, что и шаблон класса `EnableIfТ`, представленный в этой главе. Единственное отличие заключается в том, что стандарт использует имя члена-типа `type` в нижнем регистре вместо нашего `Туре`.

Специализация алгоритмов используется в ряде мест стандартной библиотеки C++. Например, [[advance|std::advance()]] и [[distance|std::distance()]] имеют несколько вариантов, основанных на категории их аргумента-итератора. Большинство реализаций стандартной библиотеки, как правило, используют диспетчеризацию дескрипторов, хотя совсем недавно некоторые из них стали использовать для реализации специализации алгоритмов [[enable_if|std::enable_if]]. Кроме того, ряд реализаций стандартной библиотеки C++ также используют эти методы внутренне, для реализации специализации различных стандартных алгоритмов. Например, [[copy|std::сору()]] можно специализировать для вызова `std::memcpy()` `или std::memmove()`, когда итераторы указывают на непрерывную память, а их типы значений имеют тривиальные операторы присваивания. Аналогично алгоритм [[fill|std::fill()]] может быть оптимизирован для вызова `std::memset()`, а различные алгоритмы могут избежать вызова деструкторов, когда известно, что тип имеет тривиальный деструктор. Эти специализации алгоритмов не санкционированы стандартом так же, как, например, в случае [[advance|std::advance()]] или [[distance|std::distance()]], но разработчики решили использовать их из соображений эффективности.

[[SFINAE|Стандартная библиотеки C++ также намекает на использование std::enable_if<> или аналогичных методов, основанных на SFINAE]], в своих требованиях. Так, [[vector|std::vector]] имеет шаблон конструктора, который создает вектор из последовательности итераторов:
```c++
template<typename InputIterator>
vector(InputIterator first, InputIterator second,
allocator_type const& alloc = allocator_type());
```

При этом выдвигается требование, что “если конструктор вызывается с типом `InputIterator`, который не квалифицирован как входной, то такой конструктор не участвует в разрешении перегрузки”. Эта формулировка слишком расплывчата, чтобы допустить использование наиболее эффективных современных методов для реализации, но в то время, когда это требование было добавлено к стандарту, предполагалось использование [[enable_if|std::enable_if<>]].

