
[[#Перегрузка свойств типов|Перегрузка свойств типов]] 20
1. [[#Специализация алгоритма|Специализация алгоритма]] 20.1
2. [[#Диспетчеризация дескрипторов|Диспетчеризация дескрипторов]] 20.2
3. [[#Включение/отключение шаблонов функций|Включение/отключение шаблонов функций]] 20.3
	1. [[#Предоставление нескольких специализаций|Предоставление нескольких специализаций]] 2.3.1



# Перегрузка свойств типов

Перегрузка функций позволяет использовать одно и то же имя для нескольких различных функций, лишь бы они отличались типами своих параметров. Например:
```c++
void f(int);
void f(char const*);
```

При использовании шаблонов функций перегрузка выполняется с учетом схемы типов, как, например, для указателя на `Т` или `Аггау<Т>`:
```c++
template<typename Т> void f(T*);
template<typename Т> void f(Array<T>);
```

Учитывая распространенность [[Реализация свойств типов|свойств типов]], вполне естественным оказывается желание перегрузки шаблонов функций на основе свойств аргументов шаблона. Например:
```c++
template<typename Number> 
void f(Number);                       // Только для чисел

template<typename Container>
void f(Container);                    // Только для контейнеров
```

Однако в настоящее время C++ не обеспечивает никакого способа непосредственного выражения перегрузки на основе свойств типов. Два шаблона функций `f`, показанные выше, фактически являются объявлением одного и того же шаблона функции, а не различных перегрузок, потому что при сравнении двух шаблонов функций имена параметров шаблона игнорируются.

К счастью, есть целый ряд методов, которые могут использоваться для эмуляции перегрузки шаблонов функций на основе свойств типов. Именно эти методы, а также общие мотивы такой перегрузки рассматриваются в данной главе.

# Специализация алгоритма

Одним из распространенных мотивов перегрузок шаблонов функций является предоставление более специализированных версий алгоритмов, основанное на знании особенностей используемых типов. Рассмотрим простую операцию `swap()` для обмена двух значений:
```c++
template<typename Т>
void swap(T& х, Т& у)
{
	T tmp(х);
	х = у;
	у = tmp;
)
```

Данная реализация включает в себя три операции копирования. Однако для некоторых типов можно предоставить более эффективную операцию `swap()`, как, например, для типа [[Array|Аrrау<Т>]], который хранит свои данные в виде указателя на содержимое массива и его длину:
```c++
template<typename Т>
void swap(Array<T>& х, Array<T>& у)
{
	swap(x.ptr, у.ptr);
	swap(x.len, y.len);
}
```

Обе реализации `swap()` корректно обменивают содержимое двух объектов `Аггау<Т>`. Однако последняя реализация более эффективна, так как она использует дополнительные свойства `Аггау<Т>` (в частности, информацию о наличии и смысле `ptr` и `lеп`), которые не доступны для произвольного типа. Последний шаблон функции (концептуально) более специализирован, чем первый, потому что он выполняет ту же операцию для подмножества типов, принимаемых первым шаблоном функции. К счастью, второй шаблон функции является также более специализированным на основе правил [[Шаблоны Специализация и перегрузка#Частичное упорядочение перегруженных шаблонов функций|частичного упорядочения шаблонов функций]], поэтому компилятор выберет более специализированный (а следовательно, и более эффективный) шаблон функции при его применимости для данного типа (т.е. для аргументов `Аггау<Т>`) и вернется к более общему (и потенциально менее эффективному) алгоритму, когда более специализированная версия окажется неприменима.

Подход проектирования и оптимизации более специализированных вариантов универсального алгоритма называется специализацией алгоритма. Более специализированные варианты применяются к подмножеству допустимых входных данных универсального алгоритма, которое задается определенными типами или свойствами типов, и обычно являются более эффективными, чем обобщенные реализации универсального алгоритма.

Решающим значением для реализации специализации алгоритма является то свойство, что более специализированные варианты, когда они применимы, выбираются автоматически, так что вызывающему коду даже не нужно знать об их существовании. В нашем примере с шаблоном `swap()` это было достигнуто путем перегрузки (концептуально) более специализированным шаблоном функции (второй `swap()`) более общего шаблона функции (первый `swap()` ), и гарантии того, что более специализированный шаблон функции является также более специализированным на основе правил частичного упорядочения C++.

Не все концептуально более специализированные варианты алгоритмов могут непосредственно транслироваться в шаблоны функций, которые обеспечивают правильное поведение частичного упорядочения. Рассмотрим в нашем следующем примере функцию `advancelter()` (аналог [[advance|std::advance()]] из стандартной библиотеки C++), которая перемещает итератор `х` вперед на `n` шагов. Этот общий алгоритм может работать с любым входным итератором (`input iterator`):
```c++
template<typename Inputlterator, typename Distance>
void advancelter(Inputlterators x, Distance n)
{
	while (n > 0)     	// Линейное время
	{
		++x;
		--n;
	}
}
```

Для определенного класса итераторов (которые предоставляют возможность произвольного доступа) можно предложить более эффективную реализацию:
```c++
template<typename RandomAccessIterator, typename Distance>
void advancelter(RandomAccessIterator& x, Distance n)
{
	x += n;         // Константное время
}
```

К сожалению, определение обоих шаблонов функций приведет к ошибке компилятора, поскольку, как отмечалось во введении, шаблоны функций, отличающиеся только именами параметров шаблонов, не перегружаются. В остальной части этой главы мы рассмотрим методы, имитирующие желаемый эффект перегрузки этих шаблонов функций.

# Диспетчеризация дескрипторов

Одним из подходов к специализации алгоритмов является присваивание “дескрипторов” (“тегов”) различным вариантам реализации алгоритма в виде уникального типа, который идентифицирует конкретный вариант. Например, чтобы справиться с только что представленной проблемой `advancelter()`, можно использовать типы дескрипторов категорий итераторов стандартной библиотеки (определены ниже) для идентификации двух вариантов реализации алгоритма `advancelter()`:
```c++
template<typename Iterator, typename Distance>
void advancelterImpl(Iterators x, Distance n, std::input_iterator_tag)
{
	while (n > 0) // Линейное время
	{
		++x;
		--n;
	}
}

template<typename Iterator, typename Distance>
void advancelterImpl(Iterators x, Distance n, 
					std::random_access_iterator_tag)
{
	x += n;     // Константное время
}
```

Тогда шаблон функции `advancelter()` просто передает свои аргументы и соответствующий дескриптор:
```c++
template<typename Iterator, typename Distance>
void advancelter(Iterators x, Distance n)
{
	advancelterImpl(x, n,
			typename
			std::iterator_traits<Iterator>::iterator_category());
}
```

Класс свойств [[iterator_traits|std::iterator_traits]] предоставляет категорию итератора через его член-тип `iterator_category`. Категория итератора является одним из типов `_tag`, упоминавшихся ранее, который указывает, с какой разновидностью итератора мы имеем дело. В стандартной библиотеке C++ доступные дескрипторы определены с помощью наследования, отражающего ситуацию, когда один дескриптор описывает категорию, которая является производной от другой:
```c++
namespace std
{
	struct input_iterator_tag{};
	struct output_iterator_tag{};
	struct forward_iterator_tag :public input_iterator_tag{};
	struct bidirectional_iterator_tag:public forward_iterator_tag{};
	struct random_access_iterator_tag:public bidirectional_iterator_tag{};
}
```

Ключ к эффективному использованию диспетчеризации дескрипторов заключается в отношениях между дескрипторами. Наши два варианта `advancelterlmpl()` отмечены дескрипторами [[input_iterator_tag|std::input_iterator_tag]] и [[random_access_iterator_tag|std::random_access_iterator_tag]], а поскольку дескриптор [[random_access_iterator_tag|std::random_access_iterator_tag]] наследуется от [[input_iterator_tag|std::input_iterator_tag]], обычная перегрузка функций при вызове `advancelterlmpl()` с итератором произвольного доступа предпочтет более специализированный вариант алгоритма (который использует [[random_access_iterator_tag|std::гandom_access_iterator_tag]]). Таким образом, диспетчеризация дескрипторов основана на делегировании функциональности из единственного, первичного шаблона функции набору вариантов `_impl`, помеченных таким образом, что обычная перегрузка функций выберет наиболее специализированный алгоритм, применимый к данным аргументам шаблона.

Диспетчеризация хорошо работает, когда имеется естественная иерархическая структура характеристик, используемых алгоритмом, и существующий набор классов свойств, которые предоставляют эти значения дескрипторов. Данный способ не столь удобен, когда специализация алгоритма зависит от произвольных свойств типов, например от того, имеет ли тип `Т` тривиальный оператор копирующего присваивания. Для этого нам нужна более мощная методика.

## Включение/отключение шаблонов функций

Специализация алгоритмов включает в себя предоставление различных шаблонов функций, которые выбираются на основе свойств аргументов шаблона.

К сожалению, ни[[Шаблоны Специализация и перегрузка#Частичное упорядочение перегруженных шаблонов функций| частичное упорядочение шаблонов функции]], ни разрешение перегрузки ( #приложение_В, “Разрешение перегрузки”) не являются достаточно мощными для того, чтобы выразить более сложные формы специализации алгоритмов.

Одним из помощников для решения этих вопросов, которые предоставляет стандартная библиотека C++, является шаблон [[Семантика перемещения - Отключение шаблонов с помощью enable_if - template|std::enable_if]]. В данном разделе рассматривается, как можно реализовать этот вспомогательный шаблон путем введения соответствующего шаблона псевдонима, который мы назовем `Enablelf` во избежание коллизии имен.

Также, как и [[Семантика перемещения - Отключение шаблонов с помощью enable_if - template|std::enable_if]], шаблон псевдонима `Enablelf` можно использовать для того, чтобы включать (или отключать) конкретные шаблоны функций при определенных условиях. Например, версия с произвольным доступом алгоритма `advanceIter()` может быть реализована следующим образом:
```c++
template<typename Iterator>
constexpr bool IsRandomAccessIterator =
	IsConvertible<
		typename std::iterator_traits<Iterator>::iterator_category,
		std::random_access_iterator_tag>;

template<typename Iterator, typename Distance>
Enablelf<IsRandomAccessIterator<Iterator>>
	advanceIter(Iterators x, Distance n)
{
	x += n; // Константное время
}
```

Здесь специализация `Enablelf` используется для включения данного варианта `advancelter()` только тогда, когда итератор на самом деле является итератором произвольного доступа. Эти два аргумента `Enablelf` являются логическим условием, указывающим, следует ли включить этот шаблон, и типом, получаемым при раскрытии `Enablelf`, когда условие имеет значение `true`. В нашем примере выше мы использовали свойство типа [[IsConvertibleT#IsConvertibleT|IsConvertible]], в качестве условия для определения свойства типа `IsRandomAccessIterator`. Таким образом, эта конкретная версия нашей реализации `advancelter()` рассматривается только тогда, когда конкретный тип, подставляемый вместо `Iterator`, может использоваться в качестве итератора с произвольным доступом (т.е. он связан с дескриптором, преобразуемым в [[random_access_iterator_tag|std::random_access_iterator_tag]]).

Шаблон `Enablelf` имеет очень простую реализацию:
```c++
template<bool, typename Т = void>
struct EnablelfT
{
};

template<typename Т>
struct EnableIfT<true, T>
{
	using Type = Т;
};

template<bool Cond, typename T = void>
using Enablelf = typename EnableIfT<Cond, T>::Type;
```

`EnableIf` раскрывается в тип и, следовательно, реализован как шаблон псевдонима. Для его реализации мы хотим использовать [[Шаблоны Специализация и перегрузка#Специализация и перегрузка|частичную специализацию]], но шаблоны псевдонимов не могут быть частично специализированы. К счастью, можно ввести шаблон вспомогательного класса `EnableIfТ`, который делает всю необходимую фактическую работу, нужную нам, и тогда шаблон псевдонима `EnableIf` просто выбирает результирующий тип из вспомогательного шаблона. Если условие истинно, `EnableIfT<...>::Туре` (а значит, и `EnableIf<...>`) просто вычисляется как второй аргумент шаблона `Т`. Когда условие имеет значение `false`, `EnableIf` не производит допустимый тип, потому что первичный шаблон класса `EnableIfТ` не имеет члена с именем `Туре`. Обычно это рассматривается как ошибка, но в [[SFINAE#Принцип SFINAE|контексте SFINAE]] в качестве возвращаемого типа шаблона функции это приводит к сбою вывода аргумента шаблона, так что данный шаблон функции удаляется из рассмотрения.

В `advanceIter()` использование `EnableIf` означает, что шаблон функции будет доступен (и иметь возвращаемый тип `void`), когда аргумент `Iterator` будет итератором произвольного доступа, а если `Iterator` не является таковым — этот шаблон будет полностью удален из рассмотрения. Мы можем рассматривать `EnableIf` как способ “охранять” шаблоны от инстанцирования с аргументами шаблона, которые не соответствуют требованиям его реализации (поскольку этот `advanceIter()` может быть инстанцирован только с итератором произвольного доступа, так как он требует операции, которые доступны только для итераторов с произвольным доступом). Хотя защита с помощью `Enablelf` не является совершенно “пуленепробиваемой” (пользователь может утверждать, что предоставляемый им тип является итератором с произвольным доступом, без предоставления необходимых операций), данный метод может помочь ранней диагностике распространенных ошибок.

Теперь мы знаем, как явно “активировать” более специализированный шаблон для типов, к которым он применим. Однако этого недостаточно: мы должны также “деактивировать” менее специализированный шаблон, поскольку компилятор не имеет возможности “заказать” два шаблона, так что при применимости обеих версий он сообщит об ошибке неоднозначности. К счастью, решить эту проблему легко: мы просто используем тот же шаблон `Enablelf` для менее специализированного шаблона, но только с отрицанием условного выражения. Это гарантирует, что для любого конкретного типа итератора будет активирован только один из двух шаблонов. Таким образом, наша версия `advanceIter()` для итератора, который не является итератором с произвольным доступом, принимает следующий вид:
```c++
template<typename Iterator, typename Distance>
EnableIf<!IsRandomAccessIterator<Iterator>>
		advanceIter(Iterator& x, Distance n)
{
	while (n > 0) // Линейное время
	{
		++x;
		--n;
	}
}
```

## Предоставление нескольких специализаций


















