
[[#По значению или по ссылке|По значению или по ссылке]] 7
1. [[#Передача по значению|Передача по значению]] 7.1
2. [[#Передача по ссылке|Передача по ссылке]] 7.2
	1. [[#Передача с помощью константной ссылки|Передача с помощью константной ссылки]] 7.2.1
	2. [[#Передача с помощью неконстантной ссылки|Передача с помощью неконстантной ссылки]] 7.2.2



# По значению или по ссылке

Поскольку C++ изначально предоставляет возможность передачи аргумента в функцию и по значению, и по ссылке, не всегда просто решить, какой из методов выбрать: обычно передача по ссылке дешевле для нетривиальных объектов, но более сложна. C++11 добавил еще и семантику перемещения, так что теперь
у нас есть различные способы передачи по ссылке.

1. **`х const&`** (константная [[rvalue|l-ссылка]]):
параметр ссылается на переданный объект, который невозможно модифицировать.
2. **`х&`** (неконстантная [[rvalue|l-ссылка]]):
параметр ссылается на переданный объект, который можно модифицировать.
1. **`Х&&`** ([[rvalue|г-ссылка]]):
параметр ссылается на переданный объект с семантикой перемещения, что означает, что его можно модифицировать или “украсть” его значение.

Выбор способа объявления параметров с известными конкретными типами является достаточно сложной задачей. В шаблонах типы не известны, и поэтому становится еще труднее решить, какой механизм передачи аргументов использовать в том или ином случае.

Тем не менее мы рекомендовали [[Шаблоны функций#Передача по значению или по ссылке|передавать параметры в шаблоны функций по значению]], если только нет веских причин поступать иначе, например, следующих:

* невозможность копирования;
* параметры используются для возврата данных;
* шаблоны просто передают параметры куда-то еще, сохраняя все свойства исходных аргументов;
* имеется серьезное улучшение производительности.

В этой главе обсуждаются различные подходы к объявлению параметров в шаблонах, причины общей рекомендации передавать аргументы по значению, а также аргументы в пользу отказа от этого решения. Кроме того, здесь рассматриваются сложные проблемы, с которыми вы столкнетесь при работе со строковыми литералами и другими видами массивов.

При чтении этой главы было бы полезно ознакомиться с терминологией, связанной с категориями значений ( [[значение#l-значение|l-значения]], [[значение#r-значения|r-значения]], [[значение#pr-значения|pr-значения]], [[значение#x-значения|х-значения]] и [[значение#gl-значение|gl-значение]].).

## Передача по значению

При передаче аргументов по значению каждый аргумент в принципе должен быть скопирован. Таким образом, каждый параметр становится копией переданного аргумента. В случае классов объект, создаваемый как копия, обычно инициализируется с помощью копирующего конструктора.

Вызов копирующего конструктора может быть достаточно дорогим. Однако существуют различные пути избежать дорогостоящего копирования даже при передаче параметров по значению: компиляторы при оптимизации зачастую могут полностью удалить операции копирования и с помощью семантики перемещения сделать копирование объектов дешевым даже для сложных объектов.

Например, рассмотрим простой шаблон функции, реализованный с передачей аргумента по значению:
```c++
template<typename Т>
void printV(T arg)
{
	...
}
```

При вызове этого шаблона функции для целочисленного значения получающийся в результате код имеет вид
```c++
void printV(int arg)
{
	...
}
```

Параметр `arg` становится копией любого переданного аргумента, является он объектом, литералом или значением, возвращаемым вызовом функции.

Если мы определим объект типа [[string|std::string]] и вызовем для него наш шаблон функции:
```c++
std::string s = "hi";
printV(s);
```

то параметр шаблона `T` будет инстанцирован как [[string|std::string]], так что мы получим
```c++
void printV(std::string arg)
{
	...
}
```

И вновь при передаче строки `arg` становится копией `s`. На этот раз копия создается копирующим конструктором класса [[string|string]], который является потенциально дорогостоящей операцией, потому что в принципе эта операция копирования выполняет глубокое копирование, так что для копии выделяется собственная память для хранения значения.

Однако потенциальный копирующий конструктор вызывается не всегда. Рассмотрим следующий код:
```c++
std::string returnstring()
std::string s = "hi";

printv(s);                      // Копирующий конструктор
printv(std::string("hi"));      // Обычно копирование устраняется (или
								// использует перемещающий конструктор)
printV(returnstring());         // Обычно копирование устраняется (или
								// использует перемещающий конструктор)
printv(std::move(s));           // Перемещающий конструктор
```

В первом вызове передается `l-значение`, что означает, что используется копирующий конструктор. Однако во втором и третьем вызовах, когда шаблон функции вызывается непосредственно для `pr-значений` ([[значение|временные объекты, создаваемые на лету или возвращаемые другой функцией]]), компиляторы обычно выполняют оптимизацию, передавая аргумент так, что копирующий конструктор не вызывается вовсе. Обратите внимание на то, что, начиная с C++17, эта оптимизация является обязательной. До С++17 компилятор, который не отбрасывал копирование при оптимизации, должен был как минимум попытаться использовать семантику перемещения, которая обычно удешевляет копирование. В последнем вызове при передаче `х-значения` (существующий неконстантный объект с [[move|std::move()]] ) мы принудительно вызываем перемещающий конструктор, указывая, что больше не нуждаемся в значении `s`.

Таким образом, вызов реализации `printv()`, которая объявлена с передачей параметра по значению, обычно оказывается дороже только при передаче `l-значения` (объекта, созданного ранее и обычно используемого после вызова, раз уж мы не использовали [[move|std::move()]] при его передаче). К сожалению, это довольно распространенный случай. Одной из причин является распространенность практики создания объектов заранее для передачи их другим функциям позднее (после некоторых изменений).

> **Низведение при передаче по значению**

У передачи по значению есть еще одно свойство, о котором мы должны упомянуть: при передаче аргументов по значению тип низводится ([[decay|decay]]). Это означает, что обычные массивы преобразуются в указатели, и что квалификаторы, например [[const|const]] и [[volatile|volatile]], удаляются (так же, как и при использовании значения в качестве инициализатора для объекта, объявленного с помощью [[auto|auto]]):
```c++
template<typename Т>
void printV(Т arg)
{
	...
}

std::string const c = "hi";
printV(c);          // с низводится, так что arg имеет тип std::string
printV("hi");       // Низводится до указателя,
					// так что arg имеет тип char const*

int arr[4];         // Низводится до указателя,
printV(arr);        // так что arg имеет тип int*
```

Таким образом, при передаче строкового литерала `"hi"` его тип `char const [3]` низводится до `char const*`, так что именно таков выведенный тип `Т`. Итак, шаблон создается следующим образом:
```c++
void printV(char const* arg)
{
	...
}
```

Это поведение является производным от языка программирования С и имеет свои преимущества и недостатки. Часто оно упрощает обработку передаваемых строковых литералов, но его недостатком является то, что внутри `printV()` мы не можем различить передачу указателя на один элемент и передачу массива. Как бороться со строковыми литералами и другими массивами, мы обсудим в #разделе_7_4.

## Передача по ссылке

Давайте теперь рассмотрим различные “за” передачу по ссылке. Во всех случаях копия не создается (поскольку параметр просто ссылается на передаваемый аргумент). Кроме того, при этом не происходит низведения типа. Однако иногда такая передача невозможна, а если и возможна, то бывают ситуации, когда результирующий тип параметра может вызвать проблемы.

### Передача с помощью константной ссылки

Чтобы избежать любого (ненужного) копирования при передаче объектов, не являющихся временными, можно использовать константные ссылки. Например:
```c++
template<typename Т>
void printR(T const& arg)
{
	...
}
```

При использовании данного объявления передача объекта никогда не приводит к созданию копии (независимо от ее дороговизны):
```c++
std::string returnstring()
std::string s = "hi";

printR(s);                     // Копия не создается
printR(std::string("hi"));     // Копия не создается
printR(returnString());        // Копия не создается
printR(std::move(s));          // Копия не создается
```

По ссылке передается даже `int` (что несколько контрпродуктивно, хотя и не имеет особого значения). Таким образом:
```c++
int i = 42;
printR(i);                     // Передача ссылки вместо копирования i
```

приводит к следующему инстанцированию `printR():`

За сценой передача аргумента по ссылке осуществляется с помощью передачи адреса аргумента. Адреса кодируются компактно, так что передача адреса из вызывающей функции в вызываемую сама по себе эффективна. Однако при передаче адреса для компилятора создается некоторая неопределенность: что вызываемая функция делает с этим адресом? В теории вызываемый код может изменять все значения, до которых удается “добраться” с использованием этого адреса. Это означает, что компилятор должен считать, что все значения, которые он может кешировать (обычно в регистрах процессора), после вызова являются недействительными. Перезагрузка всех этих значений может оказаться довольно дорогой. Вы можете возразить, что мы передаем константную ссылку: не может ли компилятор на этом основании определить, что никакие изменения не могут произойти? К сожалению, это не так, потому что вызывающий код может изменить объект через свою собственную, неконстантную ссылку.

Эти плохие новости смягчаются применением встраивания: если компилятор может развернуть вызов как встроенный, он может увидеть вызывающий и вызываемый код вместе и во многих случаях “понять”, что адрес не используется ни для чего, кроме передачи указываемого им значения. Шаблоны функций часто очень короткие и потому являются вероятными кандидатами для встраивания. Однако, если шаблон инкапсулирует более сложный алгоритм, встраивание вряд ли произойдет.

> **Передача по ссылке не приводит к низведению**

При передаче аргументов по ссылке низведение их типов не выполняется. Это означает, что массивы не преобразуются к указателям, а квалификаторы наподобие [[const|const]] и [[volatile|volatile]] не удаляются. Однако, поскольку параметр вызова объявляется как `Т const&`, сам параметр шаблона `Т` как [[const|const]] не выводится. Например:
```c++
template<typename Т>
void printR(Т const& arg)
{
	...
}

std::string const c = "hi";

printR(c);    // T выводится как std::string, arg - std::string const&
printR("hi"); // T выводится как char[3], arg - char const(&)[3]

int arr[4];
printR(arr);  // T выводится как int[4], arg - int const(&)[4]
```

Таким образом, локальные объекты `printR()`, объявленные с типом `Т`, константными не являются.

### Передача с помощью неконстантной ссылки

Когда вы хотите возвращать значения с помощью переданных аргументов (то есть когда вы хотите использовать выходные параметры), вы должны использовать неконстантные ссылки (если только не предпочитаете передавать их через указатели). И вновь это означает, что при передаче аргументов не создается копия. Параметры шаблона вызываемой функции просто получают непосредственный доступ к переданному аргументу.

Рассмотрим следующий код:
```c++
template<typename Т>
void outR(T& arg)
{
	...
}
```

Обратите внимание на то,что вызов `outR()` для временного объекта (`pr-значение`) или существующего объекта, переданного с использованием [[move|std::move()]] (`х-значение`), обычно не разрешен:
```c++
std::string returnString();
std::string s = "hi";

outR (s);                   // OK: Т выводится как std::string,
							// arg - std::strings
outR(std::string("hi"));    // Ошибка: нельзя передавать временный
							// объект (рг-значение)

outR(returnString());       // Ошибка: нельзя передавать временный
							// объект (рг-значение)
outR(std::move(s));         // Ошибка: нельзя передавать х-значение
```

Можно передавать массивы неконстантных типов (над которыми здесь так же, как и в предыдущем разделе, не будет выполняться низведение типов):
```c++
int arr[4];
outR(arr);                 // OK: T выводится как int[4], arg - int(&)[4]
```

Таким образом, можно изменять элементы, а также, например, работать с размером массива:
```c++
template<typename Т>
void outR(T& arg)
{
	if (std::is_array<T>::value)
	{
		std::cout << "Массив из " << std::extent<T>::value
				<< " элементов \п";
	}
}
```

Однако шаблоны здесь с хитростью. Если вы передадите `const-аргумент`, вывод может привести к тому, что `arg` станет объявлением константной ссылки, что означает, что становится возможным передавать `r-значение` там, где, казалось бы, ожидается `l-значение`:
```c++
std::string const с = "hi";

outR(с);                        // OK: выводится как std::string const
outR(returnConstString());      // OK: то же, если returnConstString()
								// возвращает const string
outR(std::move(c));             // OK: T выводится как std::string const
outR("hi") ;                    // OK: T выводится как char const
```

Конечно, любая попытка изменить переданный аргумент внутри шаблона функции в такой ситуации является ошибкой. Передача константного объекта возможна в самом выражении вызова, но, когда функция полностью инстанцирована (что может произойти позже в процессе компиляции), любая попытка изменить значение вызовет ошибку (которая, однако, может произойти глубоко внутри вызванного шаблона; см. #раздел_9_4).

Если вы хотите запретить передачу константных объектов по неконстантным ссылкам, то можно сделать следующее:







