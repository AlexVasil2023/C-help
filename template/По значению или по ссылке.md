
[[#По значению или по ссылке|По значению или по ссылке]] 7
1. [[#Передача по значению|Передача по значению]] 7.1
2. [[#Передача по ссылке|Передача по ссылке]] 7.2
	1. [[#Передача с помощью константной ссылки|Передача с помощью константной ссылки]] 7.2.1



# По значению или по ссылке

Поскольку C++ изначально предоставляет возможность передачи аргумента в функцию и по значению, и по ссылке, не всегда просто решить, какой из методов выбрать: обычно передача по ссылке дешевле для нетривиальных объектов, но более сложна. C++11 добавил еще и семантику перемещения, так что теперь
у нас есть различные способы передачи по ссылке.

1. **`х const&`** (константная [[rvalue|l-ссылка]]):
параметр ссылается на переданный объект, который невозможно модифицировать.
2. **`х&`** (неконстантная [[rvalue|l-ссылка]]):
параметр ссылается на переданный объект, который можно модифицировать.
1. **`Х&&`** ([[rvalue|г-ссылка]]):
параметр ссылается на переданный объект с семантикой перемещения, что означает, что его можно модифицировать или “украсть” его значение.

Выбор способа объявления параметров с известными конкретными типами является достаточно сложной задачей. В шаблонах типы не известны, и поэтому становится еще труднее решить, какой механизм передачи аргументов использовать в том или ином случае.

Тем не менее мы рекомендовали [[Шаблоны функций#Передача по значению или по ссылке|передавать параметры в шаблоны функций по значению]], если только нет веских причин поступать иначе, например, следующих:

* невозможность копирования;
* параметры используются для возврата данных;
* шаблоны просто передают параметры куда-то еще, сохраняя все свойства исходных аргументов;
* имеется серьезное улучшение производительности.

В этой главе обсуждаются различные подходы к объявлению параметров в шаблонах, причины общей рекомендации передавать аргументы по значению, а также аргументы в пользу отказа от этого решения. Кроме того, здесь рассматриваются сложные проблемы, с которыми вы столкнетесь при работе со строковыми литералами и другими видами массивов.

При чтении этой главы было бы полезно ознакомиться с терминологией, связанной с категориями значений ( [[значение#l-значение|l-значения]], [[значение#r-значения|r-значения]], [[значение#pr-значения|pr-значения]], [[значение#x-значения|х-значения]] и [[значение#gl-значение|gl-значение]].).

## Передача по значению

При передаче аргументов по значению каждый аргумент в принципе должен быть скопирован. Таким образом, каждый параметр становится копией переданного аргумента. В случае классов объект, создаваемый как копия, обычно инициализируется с помощью копирующего конструктора.

Вызов копирующего конструктора может быть достаточно дорогим. Однако существуют различные пути избежать дорогостоящего копирования даже при передаче параметров по значению: компиляторы при оптимизации зачастую могут полностью удалить операции копирования и с помощью семантики перемещения сделать копирование объектов дешевым даже для сложных объектов.

Например, рассмотрим простой шаблон функции, реализованный с передачей аргумента по значению:
```c++
template<typename Т>
void printV(T arg)
{
	...
}
```

При вызове этого шаблона функции для целочисленного значения получающийся в результате код имеет вид
```c++
void printV(int arg)
{
	...
}
```

Параметр `arg` становится копией любого переданного аргумента, является он объектом, литералом или значением, возвращаемым вызовом функции.

Если мы определим объект типа [[string|std::string]] и вызовем для него наш шаблон функции:
```c++
std::string s = "hi";
printV(s);
```

то параметр шаблона `T` будет инстанцирован как [[string|std::string]], так что мы получим
```c++
void printV(std::string arg)
{
	...
}
```

И вновь при передаче строки `arg` становится копией `s`. На этот раз копия создается копирующим конструктором класса [[string|string]], который является потенциально дорогостоящей операцией, потому что в принципе эта операция копирования выполняет глубокое копирование, так что для копии выделяется собственная память для хранения значения.

Однако потенциальный копирующий конструктор вызывается не всегда. Рассмотрим следующий код:
```c++
std::string returnstring()
std::string s = "hi";

printv(s);                      // Копирующий конструктор
printv(std::string("hi"));      // Обычно копирование устраняется (или
								// использует перемещающий конструктор)
printV(returnstring());         // Обычно копирование устраняется (или
								// использует перемещающий конструктор)
printv(std::move(s));           // Перемещающий конструктор
```

В первом вызове передается `l-значение`, что означает, что используется копирующий конструктор. Однако во втором и третьем вызовах, когда шаблон функции вызывается непосредственно для `pr-значений` ([[значение|временные объекты, создаваемые на лету или возвращаемые другой функцией]]), компиляторы обычно выполняют оптимизацию, передавая аргумент так, что копирующий конструктор не вызывается вовсе. Обратите внимание на то, что, начиная с C++17, эта оптимизация является обязательной. До С++17 компилятор, который не отбрасывал копирование при оптимизации, должен был как минимум попытаться использовать семантику перемещения, которая обычно удешевляет копирование. В последнем вызове при передаче `х-значения` (существующий неконстантный объект с [[move|std::move()]] ) мы принудительно вызываем перемещающий конструктор, указывая, что больше не нуждаемся в значении `s`.

Таким образом, вызов реализации `printv()`, которая объявлена с передачей параметра по значению, обычно оказывается дороже только при передаче `l-значения` (объекта, созданного ранее и обычно используемого после вызова, раз уж мы не использовали [[move|std::move()]] при его передаче). К сожалению, это довольно распространенный случай. Одной из причин является распространенность практики создания объектов заранее для передачи их другим функциям позднее (после некоторых изменений).

> **Низведение при передаче по значению**

У передачи по значению есть еще одно свойство, о котором мы должны упомянуть: при передаче аргументов по значению тип низводится ([[decay|decay]]). Это означает, что обычные массивы преобразуются в указатели, и что квалификаторы, например [[const|const]] и [[volatile|volatile]], удаляются (так же, как и при использовании значения в качестве инициализатора для объекта, объявленного с помощью [[auto|auto]]):
```c++
template<typename Т>
void printV(Т arg)
{
	...
}

std::string const c = "hi";
printV(c);          // с низводится, так что arg имеет тип std::string
printV("hi");       // Низводится до указателя,
					// так что arg имеет тип char const*

int arr[4];         // Низводится до указателя,
printV(arr);        // так что arg имеет тип int*
```

Таким образом, при передаче строкового литерала `"hi"` его тип `char const [3]` низводится до `char const*`, так что именно таков выведенный тип `Т`. Итак, шаблон создается следующим образом:
```c++
void printV(char const* arg)
{
	...
}
```

Это поведение является производным от языка программирования С и имеет свои преимущества и недостатки. Часто оно упрощает обработку передаваемых строковых литералов, но его недостатком является то, что внутри `printV()` мы не можем различить передачу указателя на один элемент и передачу массива. Как бороться со строковыми литералами и другими массивами, мы обсудим в #разделе_7_4.

## Передача по ссылке

Давайте теперь рассмотрим различные “за” передачу по ссылке. Во всех случаях копия не создается (поскольку параметр просто ссылается на передаваемый аргумент). Кроме того, при этом не происходит низведения типа. Однако иногда такая передача невозможна, а если и возможна, то бывают ситуации, когда результирующий тип параметра может вызвать проблемы.

### Передача с помощью константной ссылки

Чтобы избежать любого (ненужного) копирования при передаче объектов, не являющихся временными, можно использовать константные ссылки. Например:
```c++
template<typename Т>
void printR(T const& arg)
{
	...
}
```


































