
[[#SFINAE|SFINAE]]
[[#Выражение SFINAE с decltype|Выражение SFINAE с decltype]]
[[#Принцип SFINAE|Принцип SFINAE]]
	[[#Непосредственный контекст|Непосредственный контекст]]
[[#Свойства на основе SFINAE|Свойства на основе SFINAE]] (19.4)
1. [[#Принцип SFINAE и перегрузки функций|Принцип SFINAE и перегрузки функций]] 19.4.1
2. [[#SFINAE и частичные специализации|SFINAE и частичные специализации]] 19.4.2

# SFINAE

В C++ перегрузка функций для различных типов аргументов — распространенная практика. Когда компилятор видит вызов перегруженной функции, он должен рассмотреть каждого кандидата отдельно, оценивая аргументы вызова и выбирая кандидата, который наилучшим образом соответствует передаваемым аргументам (см. дополнительную информацию в #приложении_В, “Разрешение перегрузки”).

В тех случаях, когда набор кандидатов для вызова включает шаблоны функций, компилятор сначала должен определить, какие аргументы шаблона должны использоваться для этого кандидата, затем подставить эти аргументы в список параметров функции и возвращаемый тип, а потом оценить, насколько хорошо она соответствует аргументам (так же, как это делается в случае обычной функции). Однако процесс подстановки может столкнуться с проблемами: он может давать конструкции, которые не имеют никакого смысла. Вместо того, чтобы считать такую бессмысленную подстановку ошибкой, правила языка требуют просто игнорировать кандидатов с такими проблемами.

Этот принцип именуется **`SFINAE`**, что представляет собой аббревиатуру для **“substitution failure is not an error”** (ошибка подстановки ошибкой не является).

Обратите внимание на то, что описанный здесь процесс подстановки отличается от [[template Шаблоны классов#Использование шаблона класса Stack|процесса инстанцирования по требованию]]: подстановка может быть выполнена даже для потенциальных инстанцирований, которые на самом деле не нужны (так что компилятор может выяснить, действительно ли они не нужны). Эта подстановка выполняется непосредственно в объявлении функции (но не в ее теле).

Рассмотрим следующий пример:
```c++
// Количество элементов в массиве:
template<typename Т, unsigned N>
std::size_t len(T(&)[N])
{
	return N;
}

// Количество элементов для типа, имеющего член size_type:
template<typename Т>
typename T::size_type len(T const& t)
{
	return t.size();
}
```

Здесь мы определяем два шаблона функций `lеn()`, получающих один обобщенный аргумент.

1. Первый шаблон функции объявляет параметр как `Т(&)[N]`, что означает, что параметр должен быть массивом из `N` элементов типа `Т`.
2. Шаблон второй функции объявляет параметр просто как `Т`, что снимает все ограничения на сам параметр, но имеет возвращаемый тип `Т::size_type`, что требует от передаваемого типа аргумента наличия соответствующего члена `size_type`.

При передаче простого массива или строкового литерала соответствие наблюдается только в случае шаблона функции для простых массивов:
```c++
int а[10];

std::cout << len(a);       // ОК: соответствует только 1еn() для массива
std::cout << len("Hi");    // ОК: соответствует только 1еn() для массива
```

Согласно сигнатуре для второго шаблона функции также наблюдается соответствие при замене `Т` соответственно на `int[10]` и `char const [3]`, но эти подстановки ведут к потенциальным ошибкам в возвращаемом типе `Т: : size_type`. Поэтому второй шаблон при рассмотрении этих вызовов игнорируется.

При передаче [[vector|std::vector<>]] соответствие наблюдается только для второго шаблона:
```c++
std::vector<int> v;
std::cout << len(v);       // OK: годится только len() с типом size_type
```

При передаче простого указателя не подходит ни один из шаблонов функций (без сообщения об ошибке). В результате компилятор сообщает о том, что не может найти ни одной функции `lеn()`, соответствующей переданным аргументам:
```c++
int* р;
std::cout << len(p);       // Ошибка: подходящая 1еn() не найдена
```

Обратите внимание: эта ситуация отличается от передачи объекта с типом, имеющим тип-член `size_type`, но не имеющим функции-члена `size()`, как, например, для [[allocator|std::allocator<>]]:
```c++
std::allocator<int> x;
std::cout << len(x);      // Ошибка: len() найдена, но нет члена size()
```

При передаче объекта такого типа компилятор находит второй шаблон функции как соответствующий вызову. Поэтому вместо сообщения об ошибке, гласящего, что не найдена соответствующая функция `lеn()`, мы получаем сообщение об ошибке времени компиляции, говорящей о том, что невозможен вызов `size()` для `std::allocator<int>`. На этот раз второй шаблон функции не игнорируется.

Игнорирование кандидата при бессмысленности подстановки возвращаемого типа может заставить компилятор выбрать другого кандидата, параметры которого подходят хуже. Например:
```c++
// Количество элементов в простом массиве:
template<typename Т, unsigned N>
std::size_t len(T(&)[N])
{
	return N;
}

// Количество элементов для типа, имеющего тип-член size_type:
template<typename Т>
typename T::size_type len(T const& t)
{
	return t.size ();
}

// Запасной вариант для всех прочих типов:
std::size_t len(...)
{
	return 0;
}
```

Здесь мы также предоставляем общую функцию `len()`, которая соответствует всегда, но имеет наихудшее соответствие (с многоточием `(...)`) в разрешении перегрузки (см. #раздел_В_2).

Итак, для обычных массивов и векторов у нас есть два варианта, причем лучше подходит вариант с конкретными типами. Для указателей годится только запасной вариант, так что компилятор больше не жалуется на отсутствие `len()` для этого вызова. Но для распределителя памяти подходят второй и третий варианты функции, при этом второй шаблон обеспечивает лучшее соответствие. Так что это все еще приводит к сообщению об ошибке о том, что функция-член `size()` не может быть вызвана:
```c++
int а[10];
std::cout << len(a);         // OK: лучше подходит len() для массива
std::cout << len("Hi");      // OK: лучше подходит len() для массива

std::vector<int> v;
std::cout << len(v);         // OK: лучше подходит len() для типа с
							 // типом-членом size_type	
int* р;
std::cout << len(p);         // OK: годится только запасной вариант

std::allocator<int> х;
std::cout << len(x);         // Ошибка: вторая функция len() подходит
							 // лучше, но не может вызвать size() для х
```

Подробнее `SFINAE` рассматривается в #разделе_15_7, а некоторые приложения `SFINAE` — в #разделе_19_4.

==**SFINAE и разрешение перегрузки**==

Со временем принцип `SFINAE` стал столь важным и настолько превалирующим среди разработчиков шаблонов, что эта аббревиатура стала глаголом. Иногда говорят *“мы SFINAE’им функцию"*, имея в виду применение механизма `SFINAE` для обеспечения игнорирования шаблонов функции для определенных ограничений; код шаблонов при этих ограничениях становится недопустимым. Всякий раз, когда вы читаете в стандарте C++, что “шаблон функции не должен участвовать в разрешении перегрузки, если..”, это означает, что для того, чтобы шаблон функции игнорировался для определенных случаев, используется `SFINAE`.

Например, [[thread|std::thread]] объявляет конструктор:
```c++
namespace std
{
	class thread
	{
		public:
			template<typename F, typename... Args>
			explicit thread(F&& f, Args&& ... args);

			...
	};
};
```

co следующим примечанием:

Примечание: этот конструктор не должен участвовать в разрешении перегрузки, если `decay_t<F>` представляет собой тот же тип, что и [[thread|std::thread]].

Это означает, что шаблонный конструктор игнорируется, если он вызывается с [[thread|std::thread]] в качестве первого и единственного аргумента. Причина в том, что в противном случае шаблон-член наподобие показанного иногда может демонстрировать лучшее соответствие, чем любой предопределенный копирующий или [[template Семантика перемещения - Шаблоны специальных функций-членов|перемещающий конструктор]] (см. подробности в #16_2_4). Применяя принцип `SFINAE` для игнорирования шаблона конструктора при вызове для потока, мы гарантируем, что, если поток строится из другого потока, всегда используется предопределенный копирующий или перемещающий конструктор.

Применение такой методики на индивидуальной основе может оказаться громоздким. К счастью, стандартная библиотека предоставляет инструменты для более легкого отключения шаблонов. [[template Семантика перемещения - Отключение шаблонов с помощью enable_if|Наиболее известным средством является шаблон std::enable_if<>]]. Он позволяет отключить шаблон, просто заменив тип конструкцией с условием отключения шаблона.

В результате реальное объявление [[thread|std::thread]] обычно имеет следующий вид:
```c++
namespace std
{
	class thread
	{
		public:
			template<typename F, typename... Args,
					typename = enable_if_t<!is_same_v<
											decay_t<F>, thread>>>
				explicit thread(F&& f, Args&&... args);
				...
	};
};
```

Подробности реализации [[enable_if|std::enable_if<>]] и описание применения частичной специализации и `SFINAE` приведены в #разделе_20_3.

### Выражение SFINAE с decltype

Не всегда легко найти и сформулировать правильное выражение для того, чтобы воспользоваться принципом `SFINAE` для обеспечения игнорирования шаблона функции при определенных условиях.

Предположим, например, что мы хотим гарантировать, что шаблон функции `len()` игнорируется для аргументов типа, который имеет тип-член `size_type`, но не имеет функции-члена `size()`. Без каких-либо требований к функции-члену `size()` в объявлении функции шаблон будет выбран, после чего его инстанцирование приведет к ошибке:
```c++
template<typename Т>
typename T::size_type len(T const& t)
{
	return t.size ();
}

std::allocator<int> x;
std::cout << len(x)         // Ошибка: выбрана len(), но x
			<< '\n';        // не имеет функции-члена size()
```

Вот как выглядят обычные действия в такой ситуации.
>
> Указываем возвращаемый тип с помощью синтаксиса завершающего возвращаемого типа (trailing return type syntax), с использованием [[auto|auto]] в начале объявления и `->` перед возвращаемым типом в конце.
> 
> Определяем возвращаемый тип с использованием [[decltуре|decltype]] и оператора “запятая”.
> 
> Формулируем все выражения, которые должны быть корректны, в начале оператора “запятая” (преобразуя в `void`, если оператор “запятая” перегружен).
> 
> Определяем объект реального возвращаемого типа в конце оператора запятой.

Например:
```c++
template<typename Т>
auto len(T const& t) -> decltype((void) (t.size()), T::size type())
{
	return t.size();
}
```

Здесь возвращаемый тип задается выражением
```c++
decitype((void) (t.size()), T::size_type())
```

Операнд конструкции [[decltуре|decltype]] представляет собой список выражений, разделенных запятыми, так что последнее выражение `Т::size_type()` дает значение желаемого типа возвращаемого значения (который конструкция [[decltуре|decltype]] использует для преобразования в возвращаемый тип). Перед (последней) запятой находится выражение, которые должно быть корректным (и которое в данном случае представляет собой просто `t.size<>`). Приведение выражения к `void` используется для того, чтобы избежать возможной перегрузки оператора запятой для типа данного выражения.

Обратите внимание на то, что аргумент [[decltуре|decltype]] является невычисляемым операндом, следовательно, например, можно создать “фиктивные объекты” без вызова конструкторов (см. #раздел_11_2_3).

# Принцип SFINAE

Принцип `SFINAE` (substitution failure is not an error — ошибка подстановки ошибкой не является), [[#SFINAE|SFINAE является важным аспектом вывода аргументов шаблона]], не позволяющим шаблонам не относящихся к делу функций приводить к ошибкам при разрешении перегрузки*.

Рассмотрим, например, пару шаблонов функций, которые получают итератор, указывающий на начало контейнера или массива:
```c++
template<typename Т, unsigned N>
Т* begin(Т(&array)[N])
{
	return array;
}

template<typename Container>
typename Container::iterator begin(Container& c)
{
	return c.begin));
}

int main()
{
	std::vector<int> v;
	int a[10];

	::begin(v); // OK: соответствует только begin() для контейнера,
				// поскольку первый вывод неудачен
	::begin(a)  // ОК: соответствует только begin() для массивов,
				// поскольку вторая постановка неудачна
}
```

Первый вызов `begin()`, аргумент которого представляет собой `std::vector<int>`, пытается вывести аргумент шаблона для обоих шаблонов функций.
>
> Вывод аргумента шаблона `begin()` для массива неуспешен, поскольку [[vector|std::vector]] не является массивом, а потому этот шаблон игнорируется.
> 
> Вывод аргумента шаблона `begin()` для контейнера успешен при выводе `Container` как `std::vector<int>`, так что инстанцируется и вызывается именно этот шаблон функции.

Второй вызов `begin()`, аргумент которого представляет собой массив, также частично неудачен.
>
> Вывод аргумента шаблона `begin()` для массива успешен при выводе `Т` как `int`, а `N` — как `10`.
> 
> Вывод аргумента шаблона `begin()` для контейнера определяет, что `Container` должен быть заменен на `int[10]`. В то время как в общем случае эта подстановка корректна, получающийся возвращаемый тип `Container::iterator` является неверным, поскольку тип массива не имеет вложенного типа по имени `iterator`. В любом ином контексте попытка обращения к несуществующему вложенному типу привела бы к немедленной ошибке времени компиляции. При подстановке аргументов шаблона `SFINAE` превращает такие ошибки в сбои вывода, и соответствующие шаблоны функций удаляются из рассмотрения. Таким образом, второй кандидат `begin()` игнорируется, и вызывается специализация первого шаблона функции `begin()`.

## Непосредственный контекст

`SFINAE` защищает от попыток формирования недопустимых типов или выражений, включая ошибки из-за неоднозначностей или нарушений контроля доступа, которые происходят в непосредственном контексте (immediate context) подстановки шаблона функции. Определение непосредственного контекста подстановки шаблона функции более легко дать путем определения, что не является этим контекстом. В частности, во время подстановки в шаблон функции с целью вывода ничто из того, что происходит во время инстанцирования, не является частью непосредственного контекста подстановки этого шаблона функции, в частности:
>
> определение шаблона класса (т.е. его тело и список базовых классов);
> 
> определение шаблона функции (тело и, в случае конструктора, его инициализаторы);
> 
> инициализатор шаблона переменной;
> 
> аргумент по умолчанию;
> 
> инициализатор члена по умолчанию;
> 
> спецификации исключений.

Также не является частью непосредственного контекста подстановки любое неявное определение специальных функций-членов, вызванное процессом подстановки. Все остальное является частью этого контекста.

Так что если подстановка параметров шаблона объявления шаблона функции требует инстанцирования тела шаблона класса, потому что ссылается на член этого класса, ошибка при таком инстанцировании не находится в непосредственном контексте подстановки шаблона функции, а потому является реальной ошибкой (даже если для другого шаблона функции соответствие определяется без ошибок). Например:
```c++
template<typename Т>
class Array
{
	public:
		using iterator = T*;
};

template<typename T>
void f(Array<T>::iterator first, Array<T>::iterator last);

template<typename T>
void f (T*, T*);

int main()
{
	f<int&>(0,0); // Ошибка: подстановка int& вместо T в первом
} // шаблоне функции инстанцирует Array<int&>, что приводит к ошибке
```

Основное различие между этим примером и предыдущим заключается в том, где происходит сбой. В предыдущем примере ошибка происходила при формировании типа `typename Container::iterator`, который находился в непосредственном контексте подстановки шаблона функции `begin()`. В этом же примере сбой происходит при инстанцировании `Array<int&>`, которое, хотя и запущено из контекста шаблона функции, на самом деле происходит в контексте шаблона класса `Array`. Таким образом, принцип `SFINAE` не применяется, и компилятор выдаст сообщение об ошибке.

Далее приведен пример на C++14, который основан на выводе возвращаемого типа (см. #раздел_15_10_1) и включает ошибку во время инстанцирования определения шаблона функции:
```c++
template<typename Т> auto f(Т р)
{
	return p->m;
)

int f (...);

template<typename T> auto g(T p) -> decltype(f(p));
int main()
{
	g(42) ;
}
```

Вызов `g(42)` выводит тип `T` как `int`. Выполнение соответствующей подстановки в объявлении `g()` требует от нас определить тип `f(р)` (где `р`, как теперь известно, имеет тип `int`), а следовательно, и возвращаемый тип `f()`. Для `f()` есть два кандидата. Нешаблонный кандидат обеспечивает совпадение, но не очень хорошее — потому что это совпадение с параметром, являющимся многоточием. К сожалению, шаблонный кандидат имеет выведенный тип возвращаемого значения, так что мы должны инстанцировать его определение для вывода типа возвращаемого значения. Это инстанцирование неудачное, потому что `р->т` не является допустимым, когда `р` представляет собой `int`; а поскольку отказ происходит вне непосредственного контекста подстановки (так как она происходит в последующем инстанцировании определения функции), этот отказ приводит к ошибке. Из-за этого мы рекомендуем избегать вывода типов возвращаемых значений, если они легко могут быть заданы явно.

Принцип `SFINAE` первоначально предназначался для устранения странно выглядящих ошибок из-за непреднамеренных соответствий с перегрузками шаблонов функций, как в случае с примером `begin()` для контейнера. Однако способность обнаруживать недопустимое выражение или тип обеспечивает работоспособность замечательных методов времени компиляции, позволяя определить, корректен ли тот или иной конкретный синтаксис. Эти методы рассматриваются в #разделе_19_4.

Особого внимания заслуживает #раздел_19_4_4, где приводится пример создания свойства типа, дружественного к `SFINAE`, чтобы избежать проблем, связанных с непосредственным контекстом.


# Свойства на основе SFINAE

Принцип SFINAE превращает потенциальные ошибки при формировании недопустимых типов и выражений во время вывода аргументов шаблонов (которые делают программу некорректной) в простой сбой вывода, позволяя разрешению перегрузки выбрать другого кандидата. Хотя первоначально этот принцип предназначался для избегания ложных сбоев при перегрузке шаблонов функций, SFINAE обеспечивает также замечательную методику времени компиляции, которая может определить, является ли допустимым определенный тип или выражение. Это позволяет нам писать свойства, которые определяют, например, имеет ли тип определенный член, поддерживает ли конкретную операцию или является классом.

Два основных подхода к свойствам на основе SFINAE представляют собой применение SFINAE для перегрузки функций и для частичных специализаций.

## Принцип SFINAE и перегрузки функций

Наше первое знакомство со свойствами на основе SFINAE иллюстрирует базовую технологию применения SFINAE с перегрузкой функций для выяснения, является ли тип конструируемым по умолчанию, т.е. можно ли создавать объекты без каких-либо значений для инициализации (т.е. является ли корректным выражение наподобие `Т()` для данного типа `Т`).

Базовая реализация может иметь следующий вид:
```c++
#include "issame.hpp"

template<typename T>
struct IsDefaultConstructibleT
{
	private:
		// test() пытается подставить вызов конструктора
		//по умолчанию для Т, переданного как U:
		template<typename U, typename = decltype (U())>
		static char test(void*);
			
		// Резервный вариант test О:
		template<typename>
		static long test(...);

	public:
		static constexpr bool value
				= IsSameT<decltype(test<T>(nullptr)), char>::value;
};
```

Обычный подход к реализации свойств на основе SFINAE с перегрузкой функций состоит в объявлении двух перегруженных шаблонов функций с именем `test()` и с различными возвращаемыми типами:
```c++
template<...> static char test(void*);
template<...> static long test(...);
```

Первая перегрузка разработана так, что демонстрирует соответствие, только если запрашиваемая проверка проходит успешно (ниже мы рассмотрим, как это достигается). Вторая перегрузка является резервной: она всегда соответствует вызову, но наличие многоточия (т.е. переменного количества параметров) делает ее наименее предпочтительной по сравнению с любой другой функцией (см. #раздел_В_2).

Наше “возвращаемое значение” `value` зависит от того, какой перегруженный член `test` выбран:
```c++
static constexpr bool value
				= IsSameT<decltype(test<T>(nullptr)), char>::value;
```

Если выбрана функция-член `test()`, возвращающая `char`, то `value` инициализируется значением `isSame<char, char>`, которое равно `true`. В противном случае оно инициализируется значением `isSame<long, char>`, равным `false`.

Мы работаем с определенными характеристиками типа, которые хотим проверить. Цель заключается в том, чтобы сделать первую перегрузку `test()` действительной только в том случае, когда проверяемое условие выполняется. В рассматриваемом случае мы хотим узнать, возможно ли конструирование объекта переданного типа `Т` по умолчанию. Для этого мы передаем `Т` в качестве `U` и передаем нашему первому объявлению `test()` второй безымянный (фиктивный) аргумент шаблона, инициализированный конструкцией, которая является корректной тогда и только тогда, когда условие является выполненным. В нашем случае мы используем выражение, которое может быть корректным только если существует явный или
неявный конструктор по умолчанию: `U()`. Это выражение помещено в [[decltуре|decltype]], чтобы использовать это выражение для инициализации параметра типа.

Второй параметр шаблона не может быть выведен, так как соответствующий
аргумент не передается, и мы не предоставляем для него явный аргумент шаблона. Таким образом, будет выполнена подстановка аргумента шаблона по умолчанию, и если она будет неудачна, то согласно принципу SFINAE это объявление `test()` будет отброшено, так что соответствие будет демонстрировать только резервное объявление.

Итак, мы можем использовать разработанное свойство следующим образом:
```c++
IsDefaultConstructibleT<int>::value   // Дает true
struct S
{
	S() = delete;
};

IsDefaultConstructibleT<S>::value     // Дает false
```

Обратите внимание на то, что мы не можем использовать параметр шаблона `Т` в первой функции `test()` непосредственно:
```c++
template<typename Т>
struct IsDefaultConstructibleT
{
	private:
		// Ошибка: test() использует Т непосредственно:
		template<typename, typename = decltype(Т())>
		static char test(void*);
		
		// Резервный вариант test():
		template<typename>
		static long test (...);
		
	public:
		static constexpr bool value
					= IsSameT<decltype(test<T>(nullptr)), char>::value;
```

Этот вариант не работает, потому что для любого `Т` всегда выполняется подстановка во все функции-члены, так что для типа, который не является конструируемым по умолчанию, код приводит к ошибке компиляции, а не к игнорированию первого перегруженного метода `test()`. Путем передачи параметра шаблона класса `Т` в качестве параметра шаблона функции `U` мы создаем определенный контекст SFINAE.

***===Стратегии альтернативных реализаций свойств на основе SFINAE===***

Реализовать свойства на основе SFINAE было невозможно до тех пор, пока не был опубликован первый стандарт C++ в 1998 году. Ключевым моментом этого подхода является объявление двух перегруженных шаблонов функций, имеющих различные типы возвращаемых значений:
```c++
templatec...> static char test(void*);
templatec...> static long test (...);
```

Однако изначально опубликованная методика использовала размер возвращаемого типа для определения того, какая из перегрузок была выбрана (а кроме того, использовались `0` и `enum`, поскольку [[nullptr_t|nullptr]] и [[constexpr|constexpr]] тогда еще не были доступны):
```c++
enum { value = sizeof(test<...>(0)) == 1 };
```

На некоторых платформах может оказаться,что `sizeof(char) == sizeof (long)`. Например, в процессорах для обработки цифровых сигналов (`digital signal processors — DSP`) или старых машинах `Cray` все целочисленные фундаментальные типы могут иметь один и тот же размер. По определению, `sizeof(char)` равен 1, но на этих машинах `sizeof(long)` и даже `sizeof (long long)` также равны 1.

С учетом этого замечания мы хотим добиться, чтобы возвращаемые типы функций `test()` имели различные размеры на всех платформах. Например, после определения
```c++
using SizelT = char;
using Size2T = struct
{
	char a[2];
};
```

или
```c++
templatec...> static Size1T test(void*); // Проверяющая test()
template<...> static Size2T test(...);   // Резервная функция
```

Здесь возвращается либо тип `Size1T`, который представляет собой один символ размером `1`, либо (структура, включающая) массив из двух `char`, который имеет размер по крайней мере 2 на всех платформах.

Код, использующий один из этих подходов, все еще широко распространен.

Обратите внимание на то, что тип аргумента вызова, передаваемого в `func()`, значения не имеет. Важно только, чтобы переданный аргумент соответствовал ожидаемому типу. Например, можно написать определения для передачи целого числа `42`:
```c++
template<...> static Size1T test(int); // Проверяющая test()
template<...> static Size2T test(...); // Резервная функция
...
enum { value = sizeof(test<...>(42)) == 1 };
```

***===Создание свойств-предикатов на основе SFINAE===***

Введенные [[template Реализация свойств типов#Свойства-предикаты|свойства-предикаты]], возвращающие логическое значение, должны возвращать значение, производное от `std::true_type` или `std::false_type`. Таким способом можно также решить проблему, связанную с тем, что на некоторых платформах `sizeof (char) == sizeof (long)`.

Для этого нам нужно косвенное определение `IsDefaultConstructibleT`. Это свойство само должно быть унаследовано от `Туре` вспомогательного класса, который является необходимым базовым классом. К счастью, можно просто предоставить соответствующие базовые классы как возвращаемые типы перегрузок `test()`:
```c++
template<...> static std::true_type test(void*); // Проверяющая test ()
template<...> static std::false_type test(...);  // Резервная функция
```

Таким образом, член `Туре` базового класса может быть объявлен следующим образом:
```c++
using Туре = decltype(test<FROM>(nullptr));
```

и нам больше не нужно свойство `IsSameT`.

Таким образом, полная усовершенствованная реализация `IsDefaultConstructibleT` становится следующей:
```c++
#include ctype_traits>
template<typename T>
struct IsDefaultConstructibleHelper
{
	private:
		// test() пытается подставить вызов конструктора
		// по умолчанию для Т, переданного как U:
		template<typename U, typename = decltype(U())>
		static std::true_type test(void*);
		
		// Резервная версия test():
		template<typename>
		static std::false_type test(...);

	public:
		using Type = decltype(test<T>(nullptr));
};

template<typename Т>
struct IsDefaultConstructibleT:IsDefaultConstructibleHelper<T>::Type
{
};
```

Теперь, если первый шаблон функции `test()` является допустимым, он представляет собой предпочтительную перегрузку, так что член `IsDefaultConstructibleHelper::Туре` инициализируется его возвращаемым типом `std::true_type`. Как следствие, `IsConvertibleT<. . .>` оказывается производным от `std::true_type`.

Если же первый шаблон функции `test()` не является допустимым, из-за SFINAE он становится недоступным, и `IsDefaultConstructibleHelper::Туре` инициализируется возвращаемым типом резервной версии `test()`, то есть `std::false_type`. В результате `IsConvertibleT<...>` наследуется от `std::false__type`.

## SFINAE и частичные специализации


