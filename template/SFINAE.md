
[[#SFINAE|SFINAE]]
[[#Выражение SFINAE с decltype|Выражение SFINAE с decltype]]
[[#Принцип SFINAE|Принцип SFINAE]]
	[[#Непосредственный контекст|Непосредственный контекст]]
[[#Свойства на основе SFINAE|Свойства на основе SFINAE]] (19.4)
1. [[#Принцип SFINAE и перегрузки функций|Принцип SFINAE и перегрузки функций]] 19.4.1
2. [[#SFINAE и частичные специализации|SFINAE и частичные специализации]] 19.4.2
3. [[#Применение обобщенных лямбда-выражений со SFINAE|Применение обобщенных лямбда-выражений со SFINAE]] 19.4.3
4. [[#SFINAE и свойства|SFINAE и свойства]] 19.4.4

# SFINAE

В C++ перегрузка функций для различных типов аргументов — распространенная практика. Когда компилятор видит вызов перегруженной функции, он должен рассмотреть каждого кандидата отдельно, оценивая аргументы вызова и выбирая кандидата, который наилучшим образом соответствует передаваемым аргументам (см. дополнительную информацию в #приложении_В, “Разрешение перегрузки”).

В тех случаях, когда набор кандидатов для вызова включает шаблоны функций, компилятор сначала должен определить, какие аргументы шаблона должны использоваться для этого кандидата, затем подставить эти аргументы в список параметров функции и возвращаемый тип, а потом оценить, насколько хорошо она соответствует аргументам (так же, как это делается в случае обычной функции). Однако процесс подстановки может столкнуться с проблемами: он может давать конструкции, которые не имеют никакого смысла. Вместо того, чтобы считать такую бессмысленную подстановку ошибкой, правила языка требуют просто игнорировать кандидатов с такими проблемами.

Этот принцип именуется **`SFINAE`**, что представляет собой аббревиатуру для **“substitution failure is not an error”** (ошибка подстановки ошибкой не является).

Обратите внимание на то, что описанный здесь процесс подстановки отличается от [[Шаблоны классов#Использование шаблона класса Stack|процесса инстанцирования по требованию]]: подстановка может быть выполнена даже для потенциальных инстанцирований, которые на самом деле не нужны (так что компилятор может выяснить, действительно ли они не нужны). Эта подстановка выполняется непосредственно в объявлении функции (но не в ее теле).

Рассмотрим следующий пример:
```c++
// Количество элементов в массиве:
template<typename Т, unsigned N>
std::size_t len(T(&)[N])
{
	return N;
}

// Количество элементов для типа, имеющего член size_type:
template<typename Т>
typename T::size_type len(T const& t)
{
	return t.size();
}
```

Здесь мы определяем два шаблона функций `lеn()`, получающих один обобщенный аргумент.

1. Первый шаблон функции объявляет параметр как `Т(&)[N]`, что означает, что параметр должен быть массивом из `N` элементов типа `Т`.
2. Шаблон второй функции объявляет параметр просто как `Т`, что снимает все ограничения на сам параметр, но имеет возвращаемый тип `Т::size_type`, что требует от передаваемого типа аргумента наличия соответствующего члена `size_type`.

При передаче простого массива или строкового литерала соответствие наблюдается только в случае шаблона функции для простых массивов:
```c++
int а[10];

std::cout << len(a);       // ОК: соответствует только 1еn() для массива
std::cout << len("Hi");    // ОК: соответствует только 1еn() для массива
```

Согласно сигнатуре для второго шаблона функции также наблюдается соответствие при замене `Т` соответственно на `int[10]` и `char const [3]`, но эти подстановки ведут к потенциальным ошибкам в возвращаемом типе `Т: : size_type`. Поэтому второй шаблон при рассмотрении этих вызовов игнорируется.

При передаче [[vector|std::vector<>]] соответствие наблюдается только для второго шаблона:
```c++
std::vector<int> v;
std::cout << len(v);       // OK: годится только len() с типом size_type
```

При передаче простого указателя не подходит ни один из шаблонов функций (без сообщения об ошибке). В результате компилятор сообщает о том, что не может найти ни одной функции `lеn()`, соответствующей переданным аргументам:
```c++
int* р;
std::cout << len(p);       // Ошибка: подходящая 1еn() не найдена
```

Обратите внимание: эта ситуация отличается от передачи объекта с типом, имеющим тип-член `size_type`, но не имеющим функции-члена `size()`, как, например, для [[allocator|std::allocator<>]]:
```c++
std::allocator<int> x;
std::cout << len(x);      // Ошибка: len() найдена, но нет члена size()
```

При передаче объекта такого типа компилятор находит второй шаблон функции как соответствующий вызову. Поэтому вместо сообщения об ошибке, гласящего, что не найдена соответствующая функция `lеn()`, мы получаем сообщение об ошибке времени компиляции, говорящей о том, что невозможен вызов `size()` для `std::allocator<int>`. На этот раз второй шаблон функции не игнорируется.

Игнорирование кандидата при бессмысленности подстановки возвращаемого типа может заставить компилятор выбрать другого кандидата, параметры которого подходят хуже. Например:
```c++
// Количество элементов в простом массиве:
template<typename Т, unsigned N>
std::size_t len(T(&)[N])
{
	return N;
}

// Количество элементов для типа, имеющего тип-член size_type:
template<typename Т>
typename T::size_type len(T const& t)
{
	return t.size ();
}

// Запасной вариант для всех прочих типов:
std::size_t len(...)
{
	return 0;
}
```

Здесь мы также предоставляем общую функцию `len()`, которая соответствует всегда, но имеет наихудшее соответствие (с многоточием `(...)`) в разрешении перегрузки (см. #раздел_В_2).

Итак, для обычных массивов и векторов у нас есть два варианта, причем лучше подходит вариант с конкретными типами. Для указателей годится только запасной вариант, так что компилятор больше не жалуется на отсутствие `len()` для этого вызова. Но для распределителя памяти подходят второй и третий варианты функции, при этом второй шаблон обеспечивает лучшее соответствие. Так что это все еще приводит к сообщению об ошибке о том, что функция-член `size()` не может быть вызвана:
```c++
int а[10];
std::cout << len(a);         // OK: лучше подходит len() для массива
std::cout << len("Hi");      // OK: лучше подходит len() для массива

std::vector<int> v;
std::cout << len(v);         // OK: лучше подходит len() для типа с
							 // типом-членом size_type	
int* р;
std::cout << len(p);         // OK: годится только запасной вариант

std::allocator<int> х;
std::cout << len(x);         // Ошибка: вторая функция len() подходит
							 // лучше, но не может вызвать size() для х
```

Подробнее `SFINAE` рассматривается в #разделе_15_7, а некоторые приложения `SFINAE` — в #разделе_19_4.

==**SFINAE и разрешение перегрузки**==

Со временем принцип `SFINAE` стал столь важным и настолько превалирующим среди разработчиков шаблонов, что эта аббревиатура стала глаголом. Иногда говорят *“мы SFINAE’им функцию"*, имея в виду применение механизма `SFINAE` для обеспечения игнорирования шаблонов функции для определенных ограничений; код шаблонов при этих ограничениях становится недопустимым. Всякий раз, когда вы читаете в стандарте C++, что “шаблон функции не должен участвовать в разрешении перегрузки, если..”, это означает, что для того, чтобы шаблон функции игнорировался для определенных случаев, используется `SFINAE`.

Например, [[thread|std::thread]] объявляет конструктор:
```c++
namespace std
{
	class thread
	{
		public:
			template<typename F, typename... Args>
			explicit thread(F&& f, Args&& ... args);

			...
	};
};
```

co следующим примечанием:

Примечание: этот конструктор не должен участвовать в разрешении перегрузки, если `decay_t<F>` представляет собой тот же тип, что и [[thread|std::thread]].

Это означает, что шаблонный конструктор игнорируется, если он вызывается с [[thread|std::thread]] в качестве первого и единственного аргумента. Причина в том, что в противном случае шаблон-член наподобие показанного иногда может демонстрировать лучшее соответствие, чем любой предопределенный копирующий или [[Семантика перемещения - Шаблоны специальных функций-членов - template|перемещающий конструктор]] (см. подробности в #16_2_4). Применяя принцип `SFINAE` для игнорирования шаблона конструктора при вызове для потока, мы гарантируем, что, если поток строится из другого потока, всегда используется предопределенный копирующий или перемещающий конструктор.

Применение такой методики на индивидуальной основе может оказаться громоздким. К счастью, стандартная библиотека предоставляет инструменты для более легкого отключения шаблонов. [[Семантика перемещения - Отключение шаблонов с помощью enable_if - template|Наиболее известным средством является шаблон std::enable_if<>]]. Он позволяет отключить шаблон, просто заменив тип конструкцией с условием отключения шаблона.

В результате реальное объявление [[thread|std::thread]] обычно имеет следующий вид:
```c++
namespace std
{
	class thread
	{
		public:
			template<typename F, typename... Args,
					typename = enable_if_t<!is_same_v<
											decay_t<F>, thread>>>
				explicit thread(F&& f, Args&&... args);
				...
	};
};
```

Подробности реализации [[enable_if|std::enable_if<>]] и описание применения частичной специализации и `SFINAE` приведены в #разделе_20_3.

### Выражение SFINAE с decltype

Не всегда легко найти и сформулировать правильное выражение для того, чтобы воспользоваться принципом `SFINAE` для обеспечения игнорирования шаблона функции при определенных условиях.

Предположим, например, что мы хотим гарантировать, что шаблон функции `len()` игнорируется для аргументов типа, который имеет тип-член `size_type`, но не имеет функции-члена `size()`. Без каких-либо требований к функции-члену `size()` в объявлении функции шаблон будет выбран, после чего его инстанцирование приведет к ошибке:
```c++
template<typename Т>
typename T::size_type len(T const& t)
{
	return t.size ();
}

std::allocator<int> x;
std::cout << len(x)         // Ошибка: выбрана len(), но x
			<< '\n';        // не имеет функции-члена size()
```

Вот как выглядят обычные действия в такой ситуации.
>
> Указываем возвращаемый тип с помощью синтаксиса завершающего возвращаемого типа (trailing return type syntax), с использованием [[auto|auto]] в начале объявления и `->` перед возвращаемым типом в конце.
> 
> Определяем возвращаемый тип с использованием [[decltуре|decltype]] и оператора “запятая”.
> 
> Формулируем все выражения, которые должны быть корректны, в начале оператора “запятая” (преобразуя в `void`, если оператор “запятая” перегружен).
> 
> Определяем объект реального возвращаемого типа в конце оператора запятой.

Например:
```c++
template<typename Т>
auto len(T const& t) -> decltype((void) (t.size()), T::size type())
{
	return t.size();
}
```

Здесь возвращаемый тип задается выражением
```c++
decitype((void) (t.size()), T::size_type())
```

Операнд конструкции [[decltуре|decltype]] представляет собой список выражений, разделенных запятыми, так что последнее выражение `Т::size_type()` дает значение желаемого типа возвращаемого значения (который конструкция [[decltуре|decltype]] использует для преобразования в возвращаемый тип). Перед (последней) запятой находится выражение, которые должно быть корректным (и которое в данном случае представляет собой просто `t.size<>`). Приведение выражения к `void` используется для того, чтобы избежать возможной перегрузки оператора запятой для типа данного выражения.

Обратите внимание на то, что аргумент [[decltуре|decltype]] является невычисляемым операндом, следовательно, например, можно создать “фиктивные объекты” без вызова конструкторов (см. #раздел_11_2_3).

# Принцип SFINAE

Принцип `SFINAE` (substitution failure is not an error — ошибка подстановки ошибкой не является), [[#SFINAE|SFINAE является важным аспектом вывода аргументов шаблона]], не позволяющим шаблонам не относящихся к делу функций приводить к ошибкам при разрешении перегрузки*.

Рассмотрим, например, пару шаблонов функций, которые получают итератор, указывающий на начало контейнера или массива:
```c++
template<typename Т, unsigned N>
Т* begin(Т(&array)[N])
{
	return array;
}

template<typename Container>
typename Container::iterator begin(Container& c)
{
	return c.begin));
}

int main()
{
	std::vector<int> v;
	int a[10];

	::begin(v); // OK: соответствует только begin() для контейнера,
				// поскольку первый вывод неудачен
	::begin(a)  // ОК: соответствует только begin() для массивов,
				// поскольку вторая постановка неудачна
}
```

Первый вызов `begin()`, аргумент которого представляет собой `std::vector<int>`, пытается вывести аргумент шаблона для обоих шаблонов функций.
>
> Вывод аргумента шаблона `begin()` для массива неуспешен, поскольку [[vector|std::vector]] не является массивом, а потому этот шаблон игнорируется.
> 
> Вывод аргумента шаблона `begin()` для контейнера успешен при выводе `Container` как `std::vector<int>`, так что инстанцируется и вызывается именно этот шаблон функции.

Второй вызов `begin()`, аргумент которого представляет собой массив, также частично неудачен.
>
> Вывод аргумента шаблона `begin()` для массива успешен при выводе `Т` как `int`, а `N` — как `10`.
> 
> Вывод аргумента шаблона `begin()` для контейнера определяет, что `Container` должен быть заменен на `int[10]`. В то время как в общем случае эта подстановка корректна, получающийся возвращаемый тип `Container::iterator` является неверным, поскольку тип массива не имеет вложенного типа по имени `iterator`. В любом ином контексте попытка обращения к несуществующему вложенному типу привела бы к немедленной ошибке времени компиляции. При подстановке аргументов шаблона `SFINAE` превращает такие ошибки в сбои вывода, и соответствующие шаблоны функций удаляются из рассмотрения. Таким образом, второй кандидат `begin()` игнорируется, и вызывается специализация первого шаблона функции `begin()`.

## Непосредственный контекст

`SFINAE` защищает от попыток формирования недопустимых типов или выражений, включая ошибки из-за неоднозначностей или нарушений контроля доступа, которые происходят в непосредственном контексте (immediate context) подстановки шаблона функции. Определение непосредственного контекста подстановки шаблона функции более легко дать путем определения, что не является этим контекстом. В частности, во время подстановки в шаблон функции с целью вывода ничто из того, что происходит во время инстанцирования, не является частью непосредственного контекста подстановки этого шаблона функции, в частности:
>
> определение шаблона класса (т.е. его тело и список базовых классов);
> 
> определение шаблона функции (тело и, в случае конструктора, его инициализаторы);
> 
> инициализатор шаблона переменной;
> 
> аргумент по умолчанию;
> 
> инициализатор члена по умолчанию;
> 
> спецификации исключений.

Также не является частью непосредственного контекста подстановки любое неявное определение специальных функций-членов, вызванное процессом подстановки. Все остальное является частью этого контекста.

Так что если подстановка параметров шаблона объявления шаблона функции требует инстанцирования тела шаблона класса, потому что ссылается на член этого класса, ошибка при таком инстанцировании не находится в непосредственном контексте подстановки шаблона функции, а потому является реальной ошибкой (даже если для другого шаблона функции соответствие определяется без ошибок). Например:
```c++
template<typename Т>
class Array
{
	public:
		using iterator = T*;
};

template<typename T>
void f(Array<T>::iterator first, Array<T>::iterator last);

template<typename T>
void f (T*, T*);

int main()
{
	f<int&>(0,0); // Ошибка: подстановка int& вместо T в первом
} // шаблоне функции инстанцирует Array<int&>, что приводит к ошибке
```

Основное различие между этим примером и предыдущим заключается в том, где происходит сбой. В предыдущем примере ошибка происходила при формировании типа `typename Container::iterator`, который находился в непосредственном контексте подстановки шаблона функции `begin()`. В этом же примере сбой происходит при инстанцировании `Array<int&>`, которое, хотя и запущено из контекста шаблона функции, на самом деле происходит в контексте шаблона класса `Array`. Таким образом, принцип `SFINAE` не применяется, и компилятор выдаст сообщение об ошибке.

Далее приведен пример на C++14, который основан на выводе возвращаемого типа (см. #раздел_15_10_1) и включает ошибку во время инстанцирования определения шаблона функции:
```c++
template<typename Т> auto f(Т р)
{
	return p->m;
)

int f (...);

template<typename T> auto g(T p) -> decltype(f(p));
int main()
{
	g(42) ;
}
```

Вызов `g(42)` выводит тип `T` как `int`. Выполнение соответствующей подстановки в объявлении `g()` требует от нас определить тип `f(р)` (где `р`, как теперь известно, имеет тип `int`), а следовательно, и возвращаемый тип `f()`. Для `f()` есть два кандидата. Нешаблонный кандидат обеспечивает совпадение, но не очень хорошее — потому что это совпадение с параметром, являющимся многоточием. К сожалению, шаблонный кандидат имеет выведенный тип возвращаемого значения, так что мы должны инстанцировать его определение для вывода типа возвращаемого значения. Это инстанцирование неудачное, потому что `р->т` не является допустимым, когда `р` представляет собой `int`; а поскольку отказ происходит вне непосредственного контекста подстановки (так как она происходит в последующем инстанцировании определения функции), этот отказ приводит к ошибке. Из-за этого мы рекомендуем избегать вывода типов возвращаемых значений, если они легко могут быть заданы явно.

Принцип `SFINAE` первоначально предназначался для устранения странно выглядящих ошибок из-за непреднамеренных соответствий с перегрузками шаблонов функций, как в случае с примером `begin()` для контейнера. Однако способность обнаруживать недопустимое выражение или тип обеспечивает работоспособность замечательных методов времени компиляции, позволяя определить, корректен ли тот или иной конкретный синтаксис. Эти методы рассматриваются в #разделе_19_4.

Особого внимания заслуживает #раздел_19_4_4, где приводится пример создания свойства типа, дружественного к `SFINAE`, чтобы избежать проблем, связанных с непосредственным контекстом.


# Свойства на основе SFINAE

Принцип SFINAE превращает потенциальные ошибки при формировании недопустимых типов и выражений во время вывода аргументов шаблонов (которые делают программу некорректной) в простой сбой вывода, позволяя разрешению перегрузки выбрать другого кандидата. Хотя первоначально этот принцип предназначался для избегания ложных сбоев при перегрузке шаблонов функций, SFINAE обеспечивает также замечательную методику времени компиляции, которая может определить, является ли допустимым определенный тип или выражение. Это позволяет нам писать свойства, которые определяют, например, имеет ли тип определенный член, поддерживает ли конкретную операцию или является классом.

Два основных подхода к свойствам на основе SFINAE представляют собой применение SFINAE для перегрузки функций и для частичных специализаций.

## Принцип SFINAE и перегрузки функций

Наше первое знакомство со свойствами на основе SFINAE иллюстрирует базовую технологию применения SFINAE с перегрузкой функций для выяснения, является ли тип конструируемым по умолчанию, т.е. можно ли создавать объекты без каких-либо значений для инициализации (т.е. является ли корректным выражение наподобие `Т()` для данного типа `Т`).

Базовая реализация может иметь следующий вид:
```c++
#include "issame.hpp"

template<typename T>
struct IsDefaultConstructibleT
{
	private:
		// test() пытается подставить вызов конструктора
		//по умолчанию для Т, переданного как U:
		template<typename U, typename = decltype (U())>
		static char test(void*);
			
		// Резервный вариант test О:
		template<typename>
		static long test(...);

	public:
		static constexpr bool value
				= IsSameT<decltype(test<T>(nullptr)), char>::value;
};
```

Обычный подход к реализации свойств на основе SFINAE с перегрузкой функций состоит в объявлении двух перегруженных шаблонов функций с именем `test()` и с различными возвращаемыми типами:
```c++
template<...> static char test(void*);
template<...> static long test(...);
```

Первая перегрузка разработана так, что демонстрирует соответствие, только если запрашиваемая проверка проходит успешно (ниже мы рассмотрим, как это достигается). Вторая перегрузка является резервной: она всегда соответствует вызову, но наличие многоточия (т.е. переменного количества параметров) делает ее наименее предпочтительной по сравнению с любой другой функцией (см. #раздел_В_2).

Наше “возвращаемое значение” `value` зависит от того, какой перегруженный член `test` выбран:
```c++
static constexpr bool value
				= IsSameT<decltype(test<T>(nullptr)), char>::value;
```

Если выбрана функция-член `test()`, возвращающая `char`, то `value` инициализируется значением `isSame<char, char>`, которое равно `true`. В противном случае оно инициализируется значением `isSame<long, char>`, равным `false`.

Мы работаем с определенными характеристиками типа, которые хотим проверить. Цель заключается в том, чтобы сделать первую перегрузку `test()` действительной только в том случае, когда проверяемое условие выполняется. В рассматриваемом случае мы хотим узнать, возможно ли конструирование объекта переданного типа `Т` по умолчанию. Для этого мы передаем `Т` в качестве `U` и передаем нашему первому объявлению `test()` второй безымянный (фиктивный) аргумент шаблона, инициализированный конструкцией, которая является корректной тогда и только тогда, когда условие является выполненным. В нашем случае мы используем выражение, которое может быть корректным только если существует явный или
неявный конструктор по умолчанию: `U()`. Это выражение помещено в [[decltуре|decltype]], чтобы использовать это выражение для инициализации параметра типа.

Второй параметр шаблона не может быть выведен, так как соответствующий
аргумент не передается, и мы не предоставляем для него явный аргумент шаблона. Таким образом, будет выполнена подстановка аргумента шаблона по умолчанию, и если она будет неудачна, то согласно принципу SFINAE это объявление `test()` будет отброшено, так что соответствие будет демонстрировать только резервное объявление.

Итак, мы можем использовать разработанное свойство следующим образом:
```c++
IsDefaultConstructibleT<int>::value   // Дает true
struct S
{
	S() = delete;
};

IsDefaultConstructibleT<S>::value     // Дает false
```

Обратите внимание на то, что мы не можем использовать параметр шаблона `Т` в первой функции `test()` непосредственно:
```c++
template<typename Т>
struct IsDefaultConstructibleT
{
	private:
		// Ошибка: test() использует Т непосредственно:
		template<typename, typename = decltype(Т())>
		static char test(void*);
		
		// Резервный вариант test():
		template<typename>
		static long test (...);
		
	public:
		static constexpr bool value
					= IsSameT<decltype(test<T>(nullptr)), char>::value;
```

Этот вариант не работает, потому что для любого `Т` всегда выполняется подстановка во все функции-члены, так что для типа, который не является конструируемым по умолчанию, код приводит к ошибке компиляции, а не к игнорированию первого перегруженного метода `test()`. Путем передачи параметра шаблона класса `Т` в качестве параметра шаблона функции `U` мы создаем определенный контекст SFINAE.

***===Стратегии альтернативных реализаций свойств на основе SFINAE===***

Реализовать свойства на основе SFINAE было невозможно до тех пор, пока не был опубликован первый стандарт C++ в 1998 году. Ключевым моментом этого подхода является объявление двух перегруженных шаблонов функций, имеющих различные типы возвращаемых значений:
```c++
templatec...> static char test(void*);
templatec...> static long test (...);
```

Однако изначально опубликованная методика использовала размер возвращаемого типа для определения того, какая из перегрузок была выбрана (а кроме того, использовались `0` и `enum`, поскольку [[nullptr_t|nullptr]] и [[constexpr|constexpr]] тогда еще не были доступны):
```c++
enum { value = sizeof(test<...>(0)) == 1 };
```

На некоторых платформах может оказаться,что `sizeof(char) == sizeof (long)`. Например, в процессорах для обработки цифровых сигналов (`digital signal processors — DSP`) или старых машинах `Cray` все целочисленные фундаментальные типы могут иметь один и тот же размер. По определению, `sizeof(char)` равен 1, но на этих машинах `sizeof(long)` и даже `sizeof (long long)` также равны 1.

С учетом этого замечания мы хотим добиться, чтобы возвращаемые типы функций `test()` имели различные размеры на всех платформах. Например, после определения
```c++
using SizelT = char;
using Size2T = struct
{
	char a[2];
};
```

или
```c++
templatec...> static Size1T test(void*); // Проверяющая test()
template<...> static Size2T test(...);   // Резервная функция
```

Здесь возвращается либо тип `Size1T`, который представляет собой один символ размером `1`, либо (структура, включающая) массив из двух `char`, который имеет размер по крайней мере 2 на всех платформах.

Код, использующий один из этих подходов, все еще широко распространен.

Обратите внимание на то, что тип аргумента вызова, передаваемого в `func()`, значения не имеет. Важно только, чтобы переданный аргумент соответствовал ожидаемому типу. Например, можно написать определения для передачи целого числа `42`:
```c++
template<...> static Size1T test(int); // Проверяющая test()
template<...> static Size2T test(...); // Резервная функция
...
enum { value = sizeof(test<...>(42)) == 1 };
```

***===Создание свойств-предикатов на основе SFINAE===***

Введенные [[Реализация свойств типов#Свойства-предикаты|свойства-предикаты]], возвращающие логическое значение, должны возвращать значение, производное от `std::true_type` или `std::false_type`. Таким способом можно также решить проблему, связанную с тем, что на некоторых платформах `sizeof (char) == sizeof (long)`.

Для этого нам нужно косвенное определение `IsDefaultConstructibleT`. Это свойство само должно быть унаследовано от `Туре` вспомогательного класса, который является необходимым базовым классом. К счастью, можно просто предоставить соответствующие базовые классы как возвращаемые типы перегрузок `test()`:
```c++
template<...> static std::true_type test(void*); // Проверяющая test ()
template<...> static std::false_type test(...);  // Резервная функция
```

Таким образом, член `Туре` базового класса может быть объявлен следующим образом:
```c++
using Туре = decltype(test<FROM>(nullptr));
```

и нам больше не нужно свойство `IsSameT`.

Таким образом, полная усовершенствованная реализация `IsDefaultConstructibleT` становится следующей:
```c++
#include ctype_traits>
template<typename T>
struct IsDefaultConstructibleHelper
{
	private:
		// test() пытается подставить вызов конструктора
		// по умолчанию для Т, переданного как U:
		template<typename U, typename = decltype(U())>
		static std::true_type test(void*);
		
		// Резервная версия test():
		template<typename>
		static std::false_type test(...);

	public:
		using Type = decltype(test<T>(nullptr));
};

template<typename Т>
struct IsDefaultConstructibleT:IsDefaultConstructibleHelper<T>::Type
{
};
```

Теперь, если первый шаблон функции `test()` является допустимым, он представляет собой предпочтительную перегрузку, так что член `IsDefaultConstructibleHelper::Туре` инициализируется его возвращаемым типом `std::true_type`. Как следствие, `IsConvertibleT<. . .>` оказывается производным от `std::true_type`.

Если же первый шаблон функции `test()` не является допустимым, из-за SFINAE он становится недоступным, и `IsDefaultConstructibleHelper::Туре` инициализируется возвращаемым типом резервной версии `test()`, то есть `std::false_type`. В результате `IsConvertibleT<...>` наследуется от `std::false__type`.

## SFINAE и частичные специализации

Второй подход к реализации свойств на основе SFINAE применяет частичную специализацию. Мы вновь используем пример, выясняющий, имеет ли тип ё конструктор по умолчанию:
```c++
#include "issame.hpp"

#include <type_traits> // Определения true_type и false_type

// Вспомогательный тип для игнорирования
// количества параметров шаблона:
template<typename...> using VoidT = void;

// Первичный шаблон:
template<typename, typename = VoidT<>>
struct IsDefaultConstructibleT : std::false_type
{
};

// Частичная специализация (может быть удалена с помощью SFINAE):
template<typename Т>
struct IsDefaultConstructibleT<T, VoidT<decltype(Т())>> :
std::true_type
{
};
```

Как и в усовершенствованной версии `IsDefaultConstructibleT` для свойства-предиката выше, определяем общий случай, производный от `std::false_type`, потому что в общем случае тип не имеет конструктора по умолчанию.

Здесь интересной особенностью является второй аргумент шаблона, который по умолчанию использует вспомогательный тип `VoidT`. Это позволяет нам предоставлять частичные специализации, которые используют произвольное количество типовых конструкций времени компиляции.

В данном случае нам нужна только одна конструкция `decltype(Т())` для проверки, допустим ли конструктор по умолчанию для `Т`. Если для конкретного `Т` данная конструкция является некорректной, в этот раз SFINAE удалит всю частичную специализацию, и мы вернемся к первичному шаблону. В противном случае частичная специализация оказывается корректной и предпочтительной.

В C++17 в стандартную библиотеку введено свойство типа `std::void_t<>`, соответствующее типу, который здесь представлен как `VoidT`. До С++17 может быть полезным определить его самостоятельно, как указано выше, или даже в пространстве имен `std` следующим образом:
```c++
#include <type_traits>

#ifndef __ cpp_lib_void_t
namespace std
{
	template<typename...> using void__t = void;
}
#endif
```

Начиная c C++14, Комитет по стандартизации C++ рекомендовал указывать, какие части стандарта реализованы в компиляторах и стандартных библиотеках, для чего определил согласованные макросы свойств (feature macros). Это не является требованием стандарта, но разработчики, как правило, следуют полезным для их пользователей рекомендациям. Макрос `__cpp_lib_void_t` представляет собой макрос, который рекомендован для указания, что стандартная библиотека реализует `std::void_t`; таким образом, приведенный выше код является условно компилируемым в зависимости от определения этого макроса.

Очевидно, что определение свойств типа таким образом выглядит более сжатым, чем рассмотренный ранее первый подход с перегрузкой шаблонов функций. Однако он требует возможности формулировать условие внутри объявления параметра шаблона. Применение шаблона класса с перегрузкой функций позволяет нам использовать дополнительные вспомогательные функции или вспомогательные типы.

## Применение обобщенных лямбда-выражений со SFINAE

Какой бы метод мы ни использовали, всегда существует некоторый стереотипный код для определения свойств: перегрузка и вызов двух функций-членов `test()` или реализация множественной частичной специализации. Далее мы покажем, как в C++17 можно минимизировать этот код, указав проверяемое условие в обобщенном лямбда-выражении.

Начнем с инструмента, построенного из двух обобщенных лямбда-выражений:
```c++
#include <utility>

// Вспомогательный шаблон проверки корректности
// f(args...) для F f и Args... args:
template<typename F, typename... Args,
		typename = decltype(
					std::decival<F>()(std::declval<Args&&>()...))>
std::true_type isValidImpl(void*);

// Резервный вариант для случая, если SFINAE
// отвергнет вспомогательный шаблон:
template<typename F, typename... Args>
std::false_type isValidImpl(...);

// Определение лямбда-выражения, которое принимает
// лямбда-выражение f и проверяет, корректен ли вызов f с args
inline constexpr
auto isValid = [](auto f)
{
	return [](auto && ... args)
	{
		return decltype(isValidlmpl<decltype(f),
									decltype(args)&&...
									>(nullptr)) {};
	};
};

// Вспомогательный шаблон для представления типа в виде значения
template<typename Т>
struct ТуреТ
{
	using Туре = Т;
};

// Вспомогательный шаблон для обертки типа в значение
template<typename Т>
constexpr auto type = ТуреТ<Т> {};

// Вспомогательный шаблон для развертывания обернутого
// типа в невычислимых контекстах
template<typename Т>
Т valueT(ТуреТ<T>); // Определение не требуется
```

Начнем с определения `isValid`: это переменная [[constexpr|constexpr]], типом которой является лямбда-замыкание. Объявление обязательно должно использовать тип-заместитель (в нашем коде [[auto|auto]]), поскольку C++ не имеет возможности выражать типы замыканий непосредственно. До C++17 лямбда-выражения не могут появляться в константных выражениях; поэтому данный код является допустимым только в С++17. Поскольку `isValid` имеет тип замыкания, он может быть вызван, но возвращаемый элемент сам является объектом с типом лямбда-замыкания, сгенерированным внутренним лямбда-выражением.

Прежде чем углубляться в детали этого внутреннего лямбда-выражения, рассмотрим типичное применение `isValid`:
```c++
constexpr auto isDefaultConstructible
		= isValid([](auto x)->decltype((void)decltype(valueT(x))()){});
```

Мы уже знаем, что `isDefaultConstructible` имеет тип лямбда-замыкания, и, как предполагает данное имя, это функциональный объект, который проверяет свойство типа быть конструируемым по умолчанию (вскоре мы увидим, как). Другими словами, `isValid` представляет собой фабрику свойств, компонент, генерирующий свойства, проверяющие объекты из своих аргументов.

Шаблон вспомогательной переменной `type` позволяет нам представить тип в виде значения. Значение `х`, полученное таким способом, может быть вновь превращено в исходный тип с помощью `decltype (valueT(х))()`, и именно это делает лямбда-выражение, переданное выше в `isValid`. Если этот извлеченный тип не может быть сконструирован по умолчанию, `decltype (valueT(х))()` является некорректным выражением, и мы либо получим сообщение об ошибке компиляции, либо соответствующее объявление будет удалено в соответствии с принципом SFINAE (именно этот результат мы получаем благодаря деталям определения `isValid`).

`isDefaultConstructible` может быть использован следующим образом:
```c++
isDefaultConstructible(type<int>)   // true (int конструируем 
									// по умолчанию)
isDefaultConstructible(type<int&>)  // false (ссылки не конструируемы 
									// по умолчанию)
```

Чтобы увидеть, как все части работают совместно, рассмотрим, во что превращается внутреннее лямбда-выражение в `isValid` с параметром `f`, связанным с аргументом, которое представляет собой обобщенное лямбда-выражение, указанное в определении `isDefaultConstructible`. Выполнение подстановки в определении `isValid` дает код, эквивалентный следующему:
```c++
constexpr auto isDefaultConstructible = [](auto && ... args)
{
	return decltype(
		isValidlmpl <
			decltype([](auto x) -> decltype((void)decltype(valueT(x))())),
			decltype(args)&&...
		>(nullptr)) {};
};
```

Если мы вернемся к первому объявлению `isValidlmpl()` выше, то заметим, что оно включает в себя аргумент шаблона по умолчанию вида
```c++
decltype(std::declval<F>()(std::declval<Args&&>()...))>
```
который пытается вызвать значение типа своего первого аргумента шаблона, который имеет тип лямбда-замыкания в определении `isDefaultConstructible`, со значениями типов аргументов (`decltype (args) &&...`), переданных `isDefault Constructible`. Поскольку у лямбда-выражения имеется только один параметр `х`, `args` должно раскрыться только в один аргумент; в наших примерах [[static_assert|static_assert]] выше этот аргумент имеет тип `TypeT<int>` или `TypeT<int&>`. В случае `TypeT<int&>, decltype (valueT(х) )` представляет собой `int&`, что делает `decltype (valueT(х))()` некорректным, и, таким образом, подстановка аргумента шаблона по умолчанию в первое объявление `isValidlmpl()` оказывается неудачной, и согласно принципу SFINAE оно игнорируется. Это оставляет нам только второе объявление (которое в противном случае имело бы худшее соответствие), которое производит значение `false type`. В целом, когда передается `type<int&>, isDefaultConstructible` производит `false_type`. Если же вместо этого передается `type<int>`, то подстановка оказывается успешной, и выбирается первое объявление `isValidlmpl()`, генерирующее значение `true_type`.

Вспомним, что для работы SFINAE подстановка должна выполняться в непосредственном контексте замещаемых шаблонов. В нашем случае замещаемыми шаблонами являются первое объявление `isValidlmpl` и оператор вызова обобщенного лямбда-выражения, передаваемого в `isValid`. Таким образом, тестируемая конструкция должна находиться в возвращаемом типе этого лямбда-выражения, а не в его теле!

Наше свойство `isDefaultConstructible` немного отличается от предыдущих реализаций свойства тем, что он требует вызова в стиле функции вместо указания аргументов шаблона. Это, вероятно, более удобочитаемая запись, но можно добиться и стиля, применявшегося ранее:
```c++
template<typename Т>
using IsDefaultConstructibleT
	= decltype(isDefaultConstructible(std::declval<T>()));
```

Однако, поскольку это традиционное объявление шаблона, оно может находиться только в области видимости пространства имен, в то время как определение `isDefaultConstructible`, по-видимому, может быть введено в области видимости блока.

Пока что этот метод может показаться не слишком интересным, поскольку оба выражения, участвующие в реализации, и стиль использования оказываются более сложными, чем в предыдущих методах. Однако при наличии понятного `isValid` многие свойства можно реализовать с помощью только одного объявления. Например, проверка доступности члена с именем `first` оказывается очень простой (см. полный пример в #разделе_19_6_4):
```c++
constexpr auto hasFirst
	= isValid([] (auto x) -> decltype((void)valueT(x).first)
{
});
```

## SFINAE и свойства

В общем случае свойство типа должно отвечать на конкретный вопрос, не приводя к некорректному коду программы. Свойства на основе SFINAE решают эту задачу путем выявления потенциальных проблем в контексте SFINAE, превращая эти потенциальные ошибки в отрицательные результаты.

Однако некоторые свойства, представленные в книге к этому моменту (например, [[Реализация свойств типов#Свойства типов результатов|свойство PlusResultT]]), ведут себя при наличии ошибок не так хорошо. Вспомним определение `PlusResultT` из указанного раздела:
```c++
#include <utility>

template<typename T1, typename T2>
struct PlusResultT
(
	using Type = decltype(std::declval<T1>() + std::declval<T2>());
};

template<typename T1, typename T2>
using PlusResult = typename PlusResultT<T1, T2>::Type;
```

В этом определении `+` используется в контексте, который не защищен с помощью принципа SFINAE. Поэтому, если программа попытается вычислить `PlusResultT` для типов, которые не имеют подходящего оператора `+`, программа станет некорректной, как показывает следующая попытка объявления типа возвращаемого значения суммирования массивов несвязанных типов `А` и `В`:
```c++
template<typename Т>
class Array
{
	...
};

// Объявление + для массивов с разными типами элементов:
template<typename T1, typename Т2>
Array<typename PlusResultT<T1, T2>::Type>
operator+ (Array<T1> const&, Array<T2> const&);
```

Очевидно, что использование здесь `PlusResultT<>` приведет к ошибке, если для элементов массивов не существует соответствующего оператора `+`.
```c++
class А
{
};

class В
{
};

void addAB(Array<A> arrayA, Array<B> arrayB)
{
	auto sum = arrayA +       // Ошибка: сбой при инстанцировании
				arrayB;       // PlusResultT<A, В>
	...
}
```

На практике проблема не в том, что этот сбой происходит в коде, который очевидно некорректен (нельзя сложить массив `А` и массив `В`), а в том, что он происходит во время вывода аргумента шаблона для оператора `+`, глубоко в инстанцировании `PlusResultT<A, В>`.

У этого факта есть замечательное следствие: это означает, что программа может не компилироваться, даже если мы добавим перегрузку для сложения массивов `А` и `В`, поскольку C++ не указывает, должны ли типы в шаблоне функции быть инстанцированы фактически, если другая перегрузка оказывается лучшей:
```c++
// Объявление обобщенного оператора +
// для массивов с различными типами элементов:
template<typename T1, typename Т2>
Array<typename PlusResultT<T1, T2>::Type>
operator+ (Array<T1> const&, Array<T2> const&);

// Перегрузка оператора + для конкретных типов:
Array<A> operator+(Array<A> const& arrayA, Array<B> const& arrayB);
void addAB(Array<A> const& arrayA, Array<B> const& arrayB)
{
	auto sum = arrayA + arrayB; // Ошибка? Зависит от того,
	...                         // инстанцирует ли компилятор
}                               // PlusResultT<A,В>
```

Если компилятор может без выполнения вывода и подстановки в первое (шаблонное) объявление `operator+` определить, что второе объявление `operator+` имеет лучшее соответствие, то он примет этот код.

Однако во время вывода и подстановки кандидата шаблона функции все, что происходит при инстанцировании определения шаблона класса, не является частью непосредственного контекста подстановки этого шаблона функции, так что SFINAE не защищает нас от попыток сформировать некорректные типы или выражения. Вместо того, чтобы просто отбросить кандидата шаблона функции, сразу же выводятся сообщения об ошибках, поскольку мы пытаемся вызвать `operator+` для двух элементов типа `А` и типа `В` внутри `PlusResultT<>`:
```c++
template<typename T1, typename Т2>
struct PlusResultT
{
	using Type = decltype(std::declval<T1>() + std::declval<T2>());
};
```

Для решения этой проблемы необходимо сделать `PlusResultT` дружественным по отношению к SFINAE, т.е. сделать его более устойчивым, давая ему подходящее определение, даже когда его выражение [[decltуре|decltype]] некорректно.

Следуя примеру `HasLessT`, описанному в предыдущем разделе, мы определяем свойство `HasPlusT`, которое позволяет нам обнаружить, существует ли подходящая операция `+` для данных типов:
```c++
#include <utility>     // Для declval
#include <type_traits> // Для true type, false_type и void_t

// Первичный шаблон:
template<typename, typename, typename = std::void_t<>>
struct HasPlusT : std::false_type
{
};

// Частичная специализация (может быть удалена с помощью SFINAE):
template<typename T1, typename T2>
struct HasPlusT<T1, T2, std::void_t<decltype(std::declval<T1>()
										+ std::declval<T2>())>>
	: std::true_type
{
};
```

Если шаблон дает результат `true`, `PlusResultT` может использовать существующую реализацию. В противном случае `PlusResultT` требует безопасное значение по умолчанию. Лучшее значение по умолчанию для свойства, которое не имеет значащего результата для множества аргументов шаблона, заключается в том, чтобы не предоставлять член `Туре` вовсе. Таким образом, если это свойство используется в контексте SFINAE (например, в качестве возвращаемого типа шаблона оператора `operator+` для массивов), отсутствующий член `Туре` сделает вывод аргумента шаблона неудачным, и это именно то поведение, которое требуется для шаблона оператора `operator+` для массивов.

Это поведение предоставляет следующая реализация `PlusResultT`:
```c++
#include "hasplus.hpp"

template<typename T1, typename T2, bool = HasPlusT<T1, T2>::value>
struct PlusResultT      // Первичный шаблон - используется,
{                       // когда HasPlusT дает true
	using Type = decltype(std::declval<T1>() + std::declval<T2>());
};

template<typename T1, typename Т2>
struct PlusResultT<T1, T2, false>  // Частичная специализация,
{                                  // используемая в противном случае
};
```

В этой версии `PlusResultT` мы добавляем параметр шаблона с аргументом по умолчанию, который с помощью нашего свойства `HasPlusT`, рассматривавшегося выше, определяет, поддерживается ли сложение первых двух параметров. Затем мы частично специализируем `PlusResultT` для значения дополнительного параметра, равного `false`, и это наше определение частичной специализации не имеет никаких членов вообще (тем самым позволяя избежать описанной проблемы). Для случаев, когда поддерживается сложение, аргумент по умолчанию принимает значение `true`, и выбирается первичный шаблон с соответствующим определением члена `Туре`. Таким образом, мы выполняем контракт, по которому `PlusResultT` обеспечивает результирующий тип, только если результат операции суммирования является корректным. (Обратите внимание на то, что добавленный параметр шаблона никогда не должен иметь явно указанный аргумент шаблона.)

Вновь рассмотрим суммирование `Аггау<А>` и `Аггау<В>` с использованием нашей последней реализации шаблона `PlusResultT` инстанцирование `PlusResultT<A, В>` не будет иметь член `Туре`, потому что значения `А` и `В` являются не суммируемыми. Следовательно, тип результата шаблона оператора `operator+` массива является недопустимым, и SFINAE устранит данный шаблон функции из рассмотрения. Таким образом, будет выбран перегруженный `operator+`, специфичный для `Аrrау<А>` и `Аrrау<В>`.

В качестве общего принципа проектирования шаблон свойств никогда не должен сбоить во время инстанцирования, если в качестве входных данных получены разумные аргументы шаблона. Этот общий подход часто выполняет соответствующую проверку дважды.
1. Один раз для проверки, что операция корректна.
2. Еще один раз — для вычисления результата.

Мы уже видели это при рассмотрении `PlusResultT`, где вызывали `HasPlusT<>`, чтобы выяснить, корректен ли вызов `operator+` в `PlusResultImpl<>`.

Давайте [[Реализация свойств типов#Типы элементов|применим этот принцип к ElementT]], он создает тип элемента из типа контейнера. И вновь, поскольку ответ зависит от того, имеет ли тип (контейнера) тип-член `value__type`, первичный шаблон должен пытаться определить член `Туре` только тогда, когда тип контейнера имеет член `value_type`:
```c++
template<typename C, bool = HasMemberT_value_type<C>::value>
struct ElementT
{
	using Type = typename C::value_type;
};

template<typename С>
struct ElementT<C, false>
{
};
```

Третий пример создания свойства, дружественного по отношению к SFINAE, показан в #разделе_19_7_2, где `IsNothrowMoveConstructibleT` сначала должен проверить, существует ли перемещающий конструктор перед тем, как выяснять, объявлен ли он как [[noexcept|noexcept]].


