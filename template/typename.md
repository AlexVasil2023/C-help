
[[#typename|typename]]

# typename

Ключевое слово `typename` введено в язык в процессе стандартизации С++ для указания того, что идентификатор в шаблоне является типом. Рассмотрим следующий пример:
```c++
template<typename Т>
class MyClass
{
	public:
		
		...
		
		void foo()
		{
			typename T::SubType* ptr;
		}
};
```

В этом примере второе ключевое слово `typename` используется для пояснения того, что `SubType` является типом, определенным внутри класса `Т`. Таким образом, `ptr` является указателем на тип `T::SubType`.

Без применения `typename` идентификатор `SubType` интерпретировался бы как член класса, не являющийся типом (например, как статический член-данные или константа перечисления). В результате выражение
```c++
Т::SubType* ptr
```

представляло бы собой умножение статического члена `SubType` класса `Т` на `ptr`, что не было бы ошибкой, поскольку для некоторых инстанцирований `MyClass<>` это могло бы быть корректным кодом.

В общем случае ключевое слово `typename` следует использовать всякий раз, когда имя, зависящее от параметра шаблона, представляет собой тип (более подробно этот вопрос рассматривается в #разделе_13_3_2).

Одним из применений `typename` является объявление итераторов стандартных контейнеров в обобщенном коде.
```c++
#include <iostream>

// Вывод элементов контейнера STL
template<typename T>
void printcoll(T const& coll)
{
	typename T::const_iterator pos;            // Итератор для обхода coll
	typename T::const_iterator end(coll.end());// Конечная позиция

	for (pos = coll.begin(); pos != end; ++pos)
	{
		std::cout << *pos << '  '
	}
	
	std::cout << '\n';
}
```

В этом шаблоне функции параметр вызова представляет собой стандартный контейнер типа `Т`. Для обхода всех элементов контейнера используется итератор, который объявлен внутри каждого класса стандартного контейнера как тип [[Предпочитайте итераторы const_iterator итераторам iterator|const_iterator]].
```c++
class stlcontainer
{
	public:
		using iterator = ...;           // Итератор для чтения/записи
		using const_iterator = ...;     // Итератор для чтения

	...
};
```

Таким образом, для доступа к типу [[Предпочитайте итераторы const_iterator итераторам iterator|const_iterator]] шаблонного типа `Т` нужно квалифицировать тип с использованием ключевого слова `typename`:
```c++
typename Т::const_iterator pos;
```

Более подробно о применении ключевого слова `typename` до С++17 рассказывается в #разделе_13_3_2. Обратите внимание на то, что стандарт С++20, вероятно, устранит необходимость `typename` во многих распространенных ситуациях (подробнее см. #раздел_17_1).

