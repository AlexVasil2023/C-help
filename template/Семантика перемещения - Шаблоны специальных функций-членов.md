
# Шаблоны специальных функций-членов

Шаблоны функций-членов могут использоваться и для специальных функций-членов, включая конструкторы, что, однако, может привести к удивительному поведению.

Рассмотрим следующий пример.
```c++
#include <utility>
#include <string>
#include <iostream>

class Person
{
	private:
		std::string name;
	
	public:
		// Конструктор для передачи начального имени::
		explicit Person(std::string const& n) : name(n)
		(
			std::cout << "Конструктор, копирующий строку
					<< name << ”'\n";
		}
		
		explicit Person(std::string&& n) : name(std::move(n))
		{
			std::cout << "Конструктор, перемещающий строку
					<< name << "'\n";
		}
		
		// Копирующий и перемещающий конструкторы:
		Person(Person const& p) : name(p.name)
		{
			std::cout << "Копирующий конструктор Person
					<< name << ”'\n";
		}
		
		Person(Person&& p) : name(std::move(p.name))
		{
			std::cout << "Перемещающий конструктор Person
					<< name << ”'\n";
		}
};

int main()
{
	std::string s = "sname";
	
	Person p1(s);               // Инициализация строкой =>
								// копирующий строку конструктор
	Person p2("tmp");           // Инициализация строковым литералом =>
								// перемещающий строку конструктор

	Person рЗ(p1);              // Копирование Person =>
								// вызов копирующего конструктора
	Person p4(std::move(pi));   // Перемещение Person =>
								// вызов перемещающего конструктора
}
```

Здесь представлен класс `Person` с членом-строкой `name`, для которого предоставляются инициализирующие конструкторы. Для поддержки семантики перемещения мы перегружаем конструктор, принимающий [[string|std::string]].

* Мы предоставляем версию для строкового объекта, в которой `name` инициализируется копией переданного аргумента:
```c++
Person(std::string const& n) : name(n)
{
	std::cout << "Конструктор, копирующий строку
			<< name << ’"\n";
}
```

* Мы предоставляем версию для перемещаемого строкового объекта, в которой для “кражи” значения используется [[move|std::move()]]:
```c++
Person(std::string&& n) : name(std::move(n))
{
	std::cout << "Конструктор, перемещающий строку
			<< name << '"\n";
}
```

Как и ожидается, первый конструктор вызывается для строковых объектов ([[rvalue|l-значений]]), а второй — для перемещаемых объектов ([[rvalue|г-значений]]):
```c++
std::string s = "sname";
	
Person p1(s);               // Инициализация строкой =>
							// копирующий строку конструктор
Person p2("tmp");           // Инициализация строковым литералом =>
							// перемещающий строку конструктор
```

Помимо этих конструкторов в примере имеются реализации копирующего конструктора и перемещающего конструктора для случаев копирования/перемещения `Person` в целом:
```c++
Person рЗ(p1);              // Копирование Person =>
							// вызов копирующего конструктора
Person p4(std::move(pi));   // Перемещение Person =>
							// вызов перемещающего конструктора
```

Давайте теперь заменим два строковых конструктора одним обобщенным конструктором с использованием прямой передачи аргумента члену `name`.
```c++
#include <utility>
#include <string>
#include <iostream>

class Person
{
	private:
		std::string name;
	
	public:
		// Обобщенный конструктор для передачи начального имени:
		template<typename STR>
		explicit Person(STR&& n) : name(std::forward<STR>(n))
		{
			std::cout << "Шаблонный конструктор для
					<< name << '"\n";
		}
		
		// Копирующий и перемещающий конструкторы:
		Person(Person const& p) : name(p.name)
		{
			std::cout << "Копирующий конструктор Person '" 
					<< name << ”'\n";
		}
		
		Person(Person&& p) : name(std::move(p.name))
		{
			std::cout << "Перемещающий конструктор Person
					<< name << "’\n";
		)
};
```

Создание объектов при передаче строк работает корректно, как и ожидалось:
```c++
std::string s = "sname";
	
Person p1(s);               // Инициализация строкой =>
							// копирующий строку конструктор
Person p2("tmp");           // Инициализация строковым литералом =>
							// перемещающий строку конструктор
```

Обратите внимание, что при создании `р2` временная строка не создается: параметр `STR` выводится как тип `char const[4]`. Применение `std::forward<STR>` к параметру-указателю конструктора не оказывает особого действия, и член `name` таким образом создается из С-строки с завершающим нулевым символом.

Но если мы попытаемся вызвать копирующий конструктор, то получим ошибку:
```c++
Person p3(p1); // Ошибка
```

в то время как инициализация нового объекта `Person` перемещаемым объектом работает корректно:
```c++
Person р4(std::move(p1));   // ОК: перемещаемый объект Person =>
							// вызов перемещающего конструктора
```

Обратите внимание на то, что копирование константного объекта `Person` также отлично работает:
```c++
Person const p2c("ctmp");   // Инициализация константного объекта
							// строковым литералом
Person рЗс(р2с);            // ОК: копирование константного Person =>
							// вызов копирующего конструктора
```

Проблема заключается в том, что согласно правилам разрешения перегрузки языка программирования C++ (см. #раздел_16_2_4) для неконстантного [[rvalue|l-значения]] `Person р` шаблон члена
```c++
template<typename STR>
Person(STR&& n)
```

оказывается лучшим соответствием, чем (обычно предопределенный) копирующий конструктор:
```c++
Person(Person const& р)
```

`STR` просто заменяется типом `Persons`, в то время как для копирующего конструктора необходимо преобразование в [[const|const]].

Можно было бы попытаться решить эту проблему, предоставляя дополнительно неконстантный копирующий конструктор:
```c++
Person(Person& р)
```

Однако это лишь частичное решение, потому что для объектов производного класса шаблон члена остается лучшим соответствием. Что нам действительно нужно — это отключить шаблон члена для случая, когда переданный аргумент представляет собой `Person` или выражение, которое может быть преобразовано в `Person`. Это может быть сделано с помощью конструкции [[enable_if|std::enable_if<>]].
