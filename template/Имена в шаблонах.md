
[[#Имена в шаблонах|Имена в шаблонах]] 13
1. [[#Систематизация имен|Систематизация имен]] 13.1
2. [[#Поиск имен|Поиск имен]] 13.2




# Имена в шаблонах

Имена в большинстве зыков программирования представляют собой фундаментальную концепцию. Они являются средством, с помощью которого программист может обращаться к ранее созданным объектам. Когда компилятор C++ встречает имя, он должен выполнить его "поиск", чтобы определить, на какой объект ссылается это имя. С точки зрения реализации C++ в этом отношении является сложным языком. Рассмотрим, например, выражение C++ `x*y;`. Если `x` и `y` - имена переменных, данное выражение является умножением, но если `x` является именем типа, то это не что иное, как объявление `y` как указателя на объест типа `x`.

	Из этого небольшого примера видно, что C++ (как и C) является так называемым ***контекстно-зависимым языком программирования***. Другими словами, конструкцию языка не всегда можно распознать без знания ее более широкого контекста. Естественно задать вопрос: а какое это имеет отношение к шаблонам? Шаблоны являются конструкциями, которые имеют дело с несколькими контекстами: 1) контекст, в котором шаблон появляется, 2) контекст, в котором шаблон инстанцируется, и 3) контекст, связанный с аргументами шаблона, для которых происходит инстанцирование. Следовательно, теперь вас не должно удивить то, что имена в C++ требуют к себе особого внимание.

# Систематизация имен

Имена в C++ классифицируются разными способами, причем этих способов существует огромное количество. Чтобы помочь справиться с этим изобилием терминологии, все способы классификации имен сведены в табл. К счастью, многие вопросы, касающиеся шаблонов  C++, станут гораздо понятнее, если ознакомиться с основными концепциями именования.
>
> Имя является ***полным***, или ***квалифицированным именем*** (qualified name), если область видимости, которой оно принадлежит, явно указывается либо с помощью с помощью оператора разрешения области видимости (`::`), либо с помощью оператора доступа к членам класса(`.` или `->`). Например, `this->count` - квалифированное имя, а `count` - нет (даже если само по себе `count` в действительности является ссылкой на член класса).
> 
> Имя является ***зависимым именем*** (dependent name), если оно каким-либо образом зависит от параметра шаблона. Например, `std::vector<T>::iterator` - зависимое имя, если `T` - параметр шаблона, и независимое, если `T` является известным псевдонимом типа (таким как `T` из `using T = int`).

Таблица. Систематизация имен

| Классификация                                      | Пояснения и примечания                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| -------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Идентификатор                                      | Имя, которое содержит только неразрывные последовательности букв, знаков подчеркивания (`_`) и цифр. Идентификатор не может начинаться с цифры; кроме того, некоторые идентификаторы зарезервированы в реализации языка: их нельзя самостоятельно вводить в программы (используйте эмпирическое правило: избегайте идентификаторов, начинающихся с подчеркиваний и двойных подчеркиваний). Понятие “буква” интерпретируется расширенно: сюда включаются специальные ***универсальные имена символов*** (universal character names — UCN), с помощью которых кодируются знаки из неалфавитных языков                                                                                                                                                                                                                                       |
| Идентификатор<br>функции оператора                 | Ключевое слово `operator`, за которым следует символ,<br>обозначающий оператор, например `operator new` или<br>`operator[]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Идентификатор<br>функции<br>преобразования<br>типа | Используется для обозначения определенного пользователем неявного оператора преобразования, например operator int&, который может также быть представлен как `operator int bitand`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Идентификатор<br>оператора литерала                | Используется для обозначения пользовательского оператора литерала — например, `operator ""_km`, который будет использоваться при написании литерала наподобие `100_km` (введен в С++11)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Идентификатор<br>шаблона                           | Имя шаблона, за которым следуют аргументы шаблона,<br>заключенные в угловые скобки, например `List<T, int, 0>`. Идентификатором шаблона может также быть идентификатор функции оператора или идентификатор оператора литерала, за которым следуют аргументы шаблона, заключенные в угловые скобки; например `operator+<X<int>>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Неквалифицированный<br>идентификатор               | Обобщение идентификатора. Неквалифицированный идентификатор может быть любым из приведенных выше видов идентификаторов (идентификатор, идентификатор функции оператора, идентификатор функции преобразования типа, идентификатор оператора литерала или идентификатор шаблона), а также “имя деструктора”  (например, записи наподобие `~Data` или `~List<T,T,N>`)                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Квалифици­рованный<br>идентификатор                | Неквалифицированный идентификатор, который квалифицирован именем класса, перечисления или пространства имен, или с помощью оператора разрешения глобальной области видимости. Заметим, что такое имя само по себе может быть квалифицированным. Примерами являются `::х`, `S::х`, `Аггау<Т>::у` и `::N::А<Т>::z`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Квалифицированное имя                              | Этот термин в стандарте не определен, но мы используем его для обозначения имен, которые подвергаются так называемому квалифицированному поиску (qualified lookup). В частности, это могут быть квалифицированные или неквалифицированные идентификаторы, которые используются после явного оператора доступа (`.` или `->`). Примерами являются `S::х`, `this->f` и `р->А::m`. Однако просто `class_mem` в контексте, когда он неявно эквивалентен `this->class_mem`, не является квалифицированным именем: доступ к члену класса должен быть явным                                                                                                                                                                                                                                                                                      |
| Неквалифицированное имя                            | Неквалифицированный идентификатор, который не является квалифицированным именем. Это не стандартный термин, но он соответствует именам, которые подвергаются тому, что в стандарте именуется неквалифицированным поиском                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Имя                                                | Квалифицированное или неквалифицированное имя                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Зависимое имя                                      | Имя, которое каким-либо образом зависит от параметра шаблона. Обычно квалифицированное или неквалифицированное имя, которое явно содержит параметр шаблона, является зависимым. Более того, квалифицированное имя, которое включает оператор доступа к члену класса (`.` или `->`), обычно является зависимым, если тип выражения в левой части оператора является типозависимым, (type-dependent, концепция,<br>рассматриваемая в #разделе_13_3_6). В частности, `b` в `this->b` в общем случае является зависимым именем при присутствии в шаблоне. И наконец, имя, являющееся субъектом поиска, зависящего от аргумента (описан в #разделе_13_2), такое как `ident` в вызове вида `ident (х, у)` или `+` в выражении `х+у`, является зависимым именем тогда и только тогда, когда любое из выражений аргументов является типозависимым |
| Независимое имя                                    | Имя, которое не является зависимым согласно данному выше определению                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

С этой таблицей полезно ознакомиться хотя бы для того, чтобы получить некоторое представление о терминах, которые иногда используются при описании тем, касающихся шаблонов C++. Однако запоминать точное значение каждого термина вовсе не обязательно. Если возникнет необходимость, всегда можно вернуться к данной таблице.

# Поиск имен

Существует много незначительных деталей, касающихся поиска имен в C++, но здесь мы остановимся только на нескольких основных концепциях. Подробностям будем уделять внимание только в случаях, когда:
>
> нужно убедиться в правильности интуитивной трактовки 
> 
> в “патологических” случаях, которые тем или иным образом описаны в стандарте.










