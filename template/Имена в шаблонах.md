
[[#Имена в шаблонах|Имена в шаблонах]] 13
1. [[#Систематизация имен|Систематизация имен]] 13.1
2. [[#Поиск имен|Поиск имен]] 13.2
	1. [[#Поиск, зависящий от аргументов|Поиск, зависящий от аргументов]] 13.2.1
	2. [[#ADL объявлений друзей|ADL объявлений друзей]] 13.2.2
	3. [[#Внесение имен классов|Внесение имен классов]] 13.2.3
	4. [[#Текущие инстанцирования|Текущие инстанцирования]] 13.2.4




# Имена в шаблонах

Имена в большинстве зыков программирования представляют собой фундаментальную концепцию. Они являются средством, с помощью которого программист может обращаться к ранее созданным объектам. Когда компилятор C++ встречает имя, он должен выполнить его "поиск", чтобы определить, на какой объект ссылается это имя. С точки зрения реализации C++ в этом отношении является сложным языком. Рассмотрим, например, выражение C++ `x*y;`. Если `x` и `y` - имена переменных, данное выражение является умножением, но если `x` является именем типа, то это не что иное, как объявление `y` как указателя на объест типа `x`.

	Из этого небольшого примера видно, что C++ (как и C) является так называемым ***контекстно-зависимым языком программирования***. Другими словами, конструкцию языка не всегда можно распознать без знания ее более широкого контекста. Естественно задать вопрос: а какое это имеет отношение к шаблонам? Шаблоны являются конструкциями, которые имеют дело с несколькими контекстами: 1) контекст, в котором шаблон появляется, 2) контекст, в котором шаблон инстанцируется, и 3) контекст, связанный с аргументами шаблона, для которых происходит инстанцирование. Следовательно, теперь вас не должно удивить то, что имена в C++ требуют к себе особого внимание.

# Систематизация имен

Имена в C++ классифицируются разными способами, причем этих способов существует огромное количество. Чтобы помочь справиться с этим изобилием терминологии, все способы классификации имен сведены в табл. К счастью, многие вопросы, касающиеся шаблонов  C++, станут гораздо понятнее, если ознакомиться с основными концепциями именования.
>
> Имя является ***полным***, или ***квалифицированным именем*** (qualified name), если область видимости, которой оно принадлежит, явно указывается либо с помощью с помощью оператора разрешения области видимости (`::`), либо с помощью оператора доступа к членам класса(`.` или `->`). Например, `this->count` - квалифированное имя, а `count` - нет (даже если само по себе `count` в действительности является ссылкой на член класса).
> 
> Имя является ***зависимым именем*** (dependent name), если оно каким-либо образом зависит от параметра шаблона. Например, `std::vector<T>::iterator` - зависимое имя, если `T` - параметр шаблона, и независимое, если `T` является известным псевдонимом типа (таким как `T` из `using T = int`).

Таблица. Систематизация имен

| Классификация                                      | Пояснения и примечания                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| -------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Идентификатор                                      | Имя, которое содержит только неразрывные последовательности букв, знаков подчеркивания (`_`) и цифр. Идентификатор не может начинаться с цифры; кроме того, некоторые идентификаторы зарезервированы в реализации языка: их нельзя самостоятельно вводить в программы (используйте эмпирическое правило: избегайте идентификаторов, начинающихся с подчеркиваний и двойных подчеркиваний). Понятие “буква” интерпретируется расширенно: сюда включаются специальные ***универсальные имена символов*** (universal character names — UCN), с помощью которых кодируются знаки из неалфавитных языков                                                                                                                                                                                                                                       |
| Идентификатор<br>функции оператора                 | Ключевое слово `operator`, за которым следует символ,<br>обозначающий оператор, например `operator new` или<br>`operator[]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Идентификатор<br>функции<br>преобразования<br>типа | Используется для обозначения определенного пользователем неявного оператора преобразования, например operator int&, который может также быть представлен как `operator int bitand`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Идентификатор<br>оператора литерала                | Используется для обозначения пользовательского оператора литерала — например, `operator ""_km`, который будет использоваться при написании литерала наподобие `100_km` (введен в С++11)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Идентификатор<br>шаблона                           | Имя шаблона, за которым следуют аргументы шаблона,<br>заключенные в угловые скобки, например `List<T, int, 0>`. Идентификатором шаблона может также быть идентификатор функции оператора или идентификатор оператора литерала, за которым следуют аргументы шаблона, заключенные в угловые скобки; например `operator+<X<int>>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Неквалифицированный<br>идентификатор               | Обобщение идентификатора. Неквалифицированный идентификатор может быть любым из приведенных выше видов идентификаторов (идентификатор, идентификатор функции оператора, идентификатор функции преобразования типа, идентификатор оператора литерала или идентификатор шаблона), а также “имя деструктора”  (например, записи наподобие `~Data` или `~List<T,T,N>`)                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Квалифици­рованный<br>идентификатор                | Неквалифицированный идентификатор, который квалифицирован именем класса, перечисления или пространства имен, или с помощью оператора разрешения глобальной области видимости. Заметим, что такое имя само по себе может быть квалифицированным. Примерами являются `::х`, `S::х`, `Аггау<Т>::у` и `::N::А<Т>::z`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Квалифицированное имя                              | Этот термин в стандарте не определен, но мы используем его для обозначения имен, которые подвергаются так называемому квалифицированному поиску (qualified lookup). В частности, это могут быть квалифицированные или неквалифицированные идентификаторы, которые используются после явного оператора доступа (`.` или `->`). Примерами являются `S::х`, `this->f` и `р->А::m`. Однако просто `class_mem` в контексте, когда он неявно эквивалентен `this->class_mem`, не является квалифицированным именем: доступ к члену класса должен быть явным                                                                                                                                                                                                                                                                                      |
| Неквалифицированное имя                            | Неквалифицированный идентификатор, который не является квалифицированным именем. Это не стандартный термин, но он соответствует именам, которые подвергаются тому, что в стандарте именуется неквалифицированным поиском                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Имя                                                | Квалифицированное или неквалифицированное имя                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Зависимое имя                                      | Имя, которое каким-либо образом зависит от параметра шаблона. Обычно квалифицированное или неквалифицированное имя, которое явно содержит параметр шаблона, является зависимым. Более того, квалифицированное имя, которое включает оператор доступа к члену класса (`.` или `->`), обычно является зависимым, если тип выражения в левой части оператора является типозависимым, (type-dependent, концепция,<br>рассматриваемая в #разделе_13_3_6). В частности, `b` в `this->b` в общем случае является зависимым именем при присутствии в шаблоне. И наконец, имя, являющееся субъектом поиска, зависящего от аргумента (описан в #разделе_13_2), такое как `ident` в вызове вида `ident (х, у)` или `+` в выражении `х+у`, является зависимым именем тогда и только тогда, когда любое из выражений аргументов является типозависимым |
| Независимое имя                                    | Имя, которое не является зависимым согласно данному выше определению                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

С этой таблицей полезно ознакомиться хотя бы для того, чтобы получить некоторое представление о терминах, которые иногда используются при описании тем, касающихся шаблонов C++. Однако запоминать точное значение каждого термина вовсе не обязательно. Если возникнет необходимость, всегда можно вернуться к данной таблице.

# Поиск имен

Существует много незначительных деталей, касающихся поиска имен в C++, но здесь мы остановимся только на нескольких основных концепциях. Подробностям будем уделять внимание только в случаях, когда:
>
> нужно убедиться в правильности интуитивной трактовки 
> 
> в “патологических” случаях, которые тем или иным образом описаны в стандарте.

Поиск квалифицированных имен проводится в области видимости, вытекающей из квалифицирующей конструкции. Если эта область видимости является классом, то поиск также проводится и в базовых классах. Однако при поиске квалифицированных имен не рассматриваются области видимости, охватывающие данную.

Основной принцип такого поиска иллюстрируется приведенным ниже кодом:
```c++
int х;
class В
{
	public:
		int i;
};

class D : public В
{ };

void f(D* pd)
{
	pd->i = 3;  // Находит B::i
	D::x = 2;  	// Ошибка: не находит ::x в охватывающей области видимости
}
```

Поиск же неквалифицированных имен, напротив, выполняется в последовательно расширяющихся областях видимости, охватывающих данную (однако в определениях функций-членов сначала проводится поиск в области видимости класса и его базовых классов, а уже затем — в охватывающих областях видимости). Такая разновидность поиска называется обычным поиском (ordinary lookup). Приведенный ниже пример иллюстрирует главную идею, лежащую в основе обычного поиска:
```c++
extern int count;                 // #1
int lookup_example(int count)     // #2
{
	if(count < 0)
	{
		int count =1;             // #3
		lookup_example(count);    // Неквалифицированное count из #3
	}
	
	return count + ::count; // Первое, неквалифицированное count из
							// #2; второе, квалифицированное - из #1	
}
```

Современные методы поиска неквалифицированных имен в дополнение к обычному поиску могут включать так называемый поиск, зависящий от аргументов (argument-dependent lookup — ADL)2. Прежде чем перейти к подробному рассмотрению ADL, рассмотрим механизм этого поиска на нашем вечном примере шаблона `max()`:
```c++
template<typename Т>
Т max(T а, Т Ь)
{
	return Ь < а ? а : Ь;
}
```

Предположим, что нам необходимо применить этот шаблон к типу, определенному в другом пространстве имен:
```c++
namespace BigMath
{
	class BigNumber
	{
		...
	};
	
	bool operator < (BigNumber const&, BigNumber const&);

	...
}

using BigMath::BigNumber;
void g(BigNumber const& a, BigNumber const& b)
{
	...
	
	BigNumber x = ::max(a, b);

	...
}
```

Проблема заключается в том, что шаблону `max()` ничего не известно о пространстве имен `BigMath`, и с помощью обычного поиска не будет найден оператор `<`, применимый к значениям типа `BigNumber`. Если не ввести некоторые специальные правила, такие ситуации в значительной степени сокращают применимость шаблонов в контексте пространств имен C++. Поиск ADL является ответом C++ на необходимость введения таких “специальных правил”.

## Поиск, зависящий от аргументов

ADL относится главным образом к неквалифицированным именам, которые выглядят как если бы они именовали функции, не являющиеся членами, в вызовах функций или применениях операторов. ADL не будет выполняться, если обычный поиск находит
>
> имя функции-члена;
> 
> имя переменной;
> 
> имя типа или
> 
> имя объявления функции с областью видимости блока.

ADL также запрещен, если имя вызываемой функции заключено в круглые скобки.

В противном случае, если после имени следует заключенный в круглые скобки список выражений аргументов, ADL выполняется путем поиска имени в пространствах имен и классах, “связанных” или “ассоциированных” с типами аргументов вызова. Точное определение этих связанных пространств имен и связанных классов будет дано позже, но интуитивно их можно рассматривать как все пространства имен и классы, которые очевидным образом непосредственно имеют отношение к данному типу. Например, если тип является указателем на класс `X`, то связанные классы и пространство имен будут включать `X`, а также все пространства имен и классы, к которым принадлежит `X`.

Точное определение множества связанных пространств имен и связанных классов для данного типа регламентируется приведенными далее правилами.
>
> Для встроенных типов это пустое множество.
> 
> Для типов указателей и массивов множество связанных пространств имен и классов — это пространства имен и классы лежащего в основе типа (на который указывает указатель или который является типом элемента массива).
> 
> Для перечислимых типов связанным пространством имен является пространство имен, в котором объявлено перечисление.
> 
> Для членов классов связанным классом является охватывающий класс.
> 
> Для типов классов (включая [[union|объединения]]) множеством связанных классов является сам тип класса, его охватывающий класс, а также все непосредственные или опосредованные базовые классы. Множество связанных пространств имен представляет собой пространства имен, в которых объявлены связанные классы. Если класс является экземпляром шаблона класса, то сюда включаются и типы аргументов типов шаблона, а также классы и пространства имен, в которых объявлены шаблонные аргументы шаблона.
> 
> Для типов функций множества связанных пространств имен и классов включают пространства имен и классы, связанные со всеми типами параметров, а также связанные с типами возвращаемых значений.
> 
> Для указателей на члены класса `X` множества связанных пространств имен и классов включают пространства имен и классы, связанные с `X` в дополнение к связанным с типом члена класса (если это тип указателя на функцию-член, то учитываются также типы параметров и возвращаемых значений этой функции-члена).

При применении ADL осуществляется последовательный поиск имени во всех связанных пространствах имен так, как если бы это имя было квалифицировано поочередно с помощью каждого из этих пространств имен (директивы `using` при этом игнорируются). Этот механизм иллюстрируется приведенным ниже примером:
```c++
#include <iostream>

namespace X
{
	template<typename T> void f(T);
}

namespace N
{
	using namespace X;
	enum E { e1 };

	void f(E)
	{
		std::cout << "Вызов N::f(N::E)\n";
	}
}

void f(int)
{
	std::cout << "Вызов ::f(int)\n";
}

int main()
{
	::f(N::e1); // Квалифицированное имя функции: без ADL
	f(N::e1);   // Обычный поиск находит ::f(), ADL находит
}               // N::f(), последний предпочтительнее
```

Заметим, что в данном примере директива `using` в пространстве имен `N` при выполнении ADL игнорируется. Следовательно, `X::f()` никогда даже не будет рассматриваться как кандидат для вызова в main ().

## ADL объявлений друзей

Объявление дружественной функции может быть первым объявлением функции-кандидата при поиске. В этом случае считается, что функция объявлена в области видимости ближайшего пространства имен (которым может быть глобальное пространство имен), охватывающего класс, содержащий объявление дружественной функции. Однако такое объявление друга не является непосредственно видимым в данной области видимости. Рассмотрим следующий пример:
```c++
template<typename Т>
class С
{
	...
	
	friend void f();
	friend void f(C<T> const&);

	...
);

void g(C<int>* p)
{
	f();         // Видима ли здесь f()?
	f(*p);       // Видима ли здесь f(C<int> const&)?
}
```

Если объявления дружественных конструкций видимы в охватывающем пространстве имен, то инстанцирование шаблона класса может сделать видимыми объявления обычных функций. Это может привести к удивительному поведению: вызов `f()` ведет к ошибке компиляции, если только инстанцирование класса `С` не произошло ранее в программе!

С другой стороны, может быть полезным объявить (и определить) функцию только в объявлении друга (см. в #разделе_21_2_1 методику, основанную на таком поведении). Такая функция может быть найдена, когда класс, для которого она является другом, находится среди связанных классов, рассматриваемых ADL.

Рассмотрим наш последний пример. Вызов `f()` не имеет связанных классов или пространств имен, поскольку не имеет аргументов: это некорректный вызов в нашем примере. Однако вызов `f(*р)` имеет связанный класс `C<int>` (поскольку это тип `*р`), и с ним также связано глобальное пространство имен (поскольку это пространство имен, в котором объявлен тип `*р`). Следовательно, объявление второй дружественной функции может быть найдено, если класс `C<int>` в действительности полностью инстанцирован до этого вызова. Чтобы обеспечить выполнение данного условия, предполагается, что вызов, инициирующий поиск дружественных конструкций в связанных классах, фактически вызывает инстанцирование класса (если оно еще не выполнено).

Возможность ADL найти объявления и определения друзей иногда называют внесением, или инъекцией имени друга (friend name injection). Однако этот термин несколько вводит в заблуждение, потому что это название возможности C++, имевшейся еще до разработки стандарта, которая на самом деле “вносит” имена объявлений друзей в охватывающую область видимости, делая их видимыми для обычного поиска имен. В приведенном выше примере это означает, что оба вызова корректны. В заключительных примечаниях к главе история внесения имен друзей рассматривается более подробно.

## Внесение имен классов

Имя класса “внесено” в область видимости самого этого класса и, следовательно, является доступным в данной области видимости как неквалифицированное имя (однако оно недоступно в качестве квалифицированного имени, поскольку это запись, используемая для обозначения конструкторов). Например:
```c++
#include <iostream>

int С;
class С
{
	private:
		int i [2];

	public:
		static int f()
		{
			return sizeof(С);
		}
};

int f ()
{
	return sizeof(C);
}

int main()
{
	std::cout << "C::f() = " << C::f() << ','
			  << " ::f() = " << ::f()  << '\n' ;
};
```

Функция-член `C::f()` возвращает размер типа `С`, в то время как функция `::f()` возвращает размер переменной `С` (другими словами, размер объекта типа `int`).

Шаблоны классов также имеют внесенные имена классов. Однако они еще более непривычны, чем обычные внесенные имена классов: за ними могут идти аргументы шаблона (в этом случае они являются внесенными именами шаблона класса), но если за ними не следуют аргументы шаблона, то они представляют класс с использованием параметров шаблонов в качестве аргументов (или при частичной специализации с использованием аргументов специализации), если контекст ожидает тип, или шаблон, если контекст ожидает шаблон. Это поясняет следующую ситуацию:
```c++
template<template<typename> class ТТ> class X
{
};

template<typename Т> class С
{
	С* а;        // OK: то же, что и "С<Т>* а;

	C<void>& Ь;  // ОК
	
	Х<С> с;      // OK: С без списка аргументов шаблонов
				 // обозначает шаблон С
	Х<::С> d;    // ОК: ::С не является внесенным именем класса,
				 // а потому всегда обозначает шаблон
};
```

Обратите внимание на то, как неквалифицированное имя ссылается на внесенное имя, и на то, что имя шаблона не рассматривается, если за ним не следует список аргументов. Для компенсации можно заставить имя шаблона быть найденным, используя квалификатор области видимости файла `::`.

Внесенное имя класса для вариативного шаблона имеет свои хитрости: если внесенное имя класса было сформировано непосредственно с использованием вариативных шаблонных параметров шаблона в качестве аргументов шаблона, то внесенное имя будет содержать пакеты параметров шаблона, которые не были раскрыты ([[Вглубь шаблонов#Раскрытие пакета|о раскрытии пакетов]]). Таким образом, при формировании внесенного имени класса для вариативного шаблона аргумент шаблона, соответствующий пакету параметров шаблона, представляет собой раскрытие пакета, схемой которого является этот пакет параметров шаблона:
```c++
template<int I, typename... Т> class V
{
	V* а;         // ОК: то же, что и "V<I, Т...>* а;"
	V<0, void> b; // OK
};
```

## Текущие инстанцирования
















