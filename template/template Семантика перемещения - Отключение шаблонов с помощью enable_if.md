
# Отключение шаблонов с помощью enable_if<>

Начиная с С++11, в стандартной библиотеке C++ имеется вспомогательный шаблон [[enable_if|std::enable_if<>]], позволяющий игнорировать шаблоны функций при определенных условиях времени компиляции.

Например, если шаблон функции `fоо<>()` определен следующим образом:
```c++
template<typename Т>
typename std::enable_if < (sizeof(Т) > 4) >::type
foo ()
{  }
```

то это определение `foo<>()` игнорируется, если условие `sizeof(Т) > 4` дает `false`. Если `sizeof(Т) > 4` дает `true`, то шаблон функции раскрывается до
```c++
foo ()
{  }
```

То есть [[enable_if|std::enable_if<>]] представляет собой свойство типа, которое вычисляет заданное выражение времени компиляции, переданное в качестве его (первого) аргумента шаблона, и ведет себя следующим образом.

> Если выражение вычисляется как `true`, член-тип `type` дает тип:
* `void`, если второй аргумент не передан;
* в противном случае — второй аргумент шаблона.

> Если выражение вычисляется как `false`, член-тип `type` не определен. Благодаря возможности шаблонов, которая называется SFINAE (substitution failure is not an error — ошибка подстановки ошибкой не является), о которой мы поговорим позже (см.  #раздел_8_4 ), шаблон функции с выражением [[enable_if#enable_if|enable_if]] в этом случае игнорируется.

Как и для всех свойств типов, которые представляют собой тип, начиная с С++14, имеется соответствующий шаблон псевдонима [[enable_if#enable_if_t<>|std::enable_if_t<>]], который [[template Шаблоны классов#Псевдонимы типов|позволяет опустить typename и ::type]].

Таким образом, начиная с C++14, можно написать
```c++
template<typename Т>
std::enable_if_t < (sizeof(T) > 4) >
foo ()
{  }
```

Если передать в [[enable_if#enable_if|enable_if<>]] или [[enable_if#enable_if_t<>|enable_if_t<>]] второй аргумент:
```c++
template<typename Т>
std::enable_if_t < (sizeof(T) > 4), Т >
foo()
{
	return Т();
}
```

то конструкция [[enable_if|enable_if]] раскроется до этого второго аргумента, если значение выражения будет вычислено как `true`. Так что, если `МуТуре` представляет собой конкретный тип, переданный или выведенный как `Т`, и его размер окажется больше 4, результатом будет
```c++
МуТуре foo();
```

Обратите внимание на то, что выражение [[enable_if|enable_if]] в середине объявления является довольно неуклюжей конструкцией. По этой причине наиболее распространенным способом использования [[enable_if#enable_if|std: :enable_if<>]] является использование дополнительного аргумента шаблона функции со значением по умолчанию:
```c++
template<typename Т, typename = std::enable_if_t<(sizeof(T)> 4)
void foo()
{  }
```

Такая запись при `sizeof (Т) > 4` раскрывается в
```c++
template<typename Т, typename = void>
void foo()
{  }
```

Если и это все еще выглядит слишком неуклюжим, и вы хотите сделать требование/ограничение более явно выраженным, с помощью шаблона псевдонима можно определить для него собственное имя:
```c++
template<typename Т>
using EnableIfSizeGreater4 = std::enable_if_t <(sizeof(T) > 4)>;
template<typename T, typename = EnableIfSizeGreater4<T>>
void foo()
{  }
```

Вопросы реализации [[enable_if|std::enable_if]] рассмотрены в #разделе_20_3.
