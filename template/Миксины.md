
[[#Миксины|Миксины]] 21.3 (template)
	1. [[#Странные миксины|Странные миксины]] 21.3.1 (template) 
	2. [[#Параметризованная виртуальность|Параметризованная виртуальность]] 21.3.2 (template)

# Миксины

Рассмотрим простой класс `Polygon`, состоящий из последовательности точек:
```c++
class Point
{
	public:
		double x, у;
		
		Point() : x(0.0), y(0.0) 
		{ }
		
		Point(double x, double y) : x(x), y(y)
		{ }
};

class Polygon
{
	private:
		std::vector<Point> points;
	public:
		... // Открытые операции
};
```

Этот класс `Polygon` будет более полезным, если пользователь сможет расширить набор сведений, связанных с каждой точкой `Point`, чтобы иметь возможность указать информацию приложения, такую как цвет каждой точки, или возможно, связать с каждой точкой метку. Один из вариантов сделать такое расширение возможным — параметризовать `Polygon` типом точки:
```c++
template<typename Р>
class Polygon
{
	private:
		std::vector<P> points;
	public:
		... // Открытые операции
};
```

Пользователи могут создавать свой собственный “точкообразный” тип данных, предоставляющий тот же интерфейс, что и `Point`, но включающий и другие данные приложения с помощью наследования:
```c++
class LabeledPoint : public Point
{
	public:
		std::string label;
		
		LabeledPoint() 
			: Point()
			, label("") 
		{ }
		
		LabeledPoint(double x, double y) 
			: Point(x, y)
			, label("")
		{ }
};
```

Эта реализация имеет свои недостатки. С одной стороны она требует, чтобы тип `Point` был доступен пользователю, так, чтобы пользователь мог его наследовать. Кроме того, автор `LabeledPoint` должен быть осторожным и предоставить точно такой же интерфейс, как и `Point` (например, наследованием или предоставлением всех тех же конструкторов, что и у `Point`), иначе `LabeledPoint` не сможет работать с `Polygon`. Это ограничение становится более проблематичным, если `Point` изменяется от одной версии шаблона `Polygon` к другой: добавление нового конструктора `Point` может потребовать обновления каждого производного класса.

***Миксины (mixins)*** обеспечивают альтернативный способ настроить поведение типа без наследования от него. Миксины, по существу, инвертируют нормальное направление наследования, потому что новые классы являются “подмешанными” (mixed in) в иерархию наследования как базовые классы шаблона класса, а не создаются как новые производные классы. Этот подход разрешает введение новых членов-данных и других операций, не требуя какого-либо дублирования интерфейса.

Шаблон класса, который поддерживает миксины, обычно принимает произвольное количество дополнительных классов, от которых он наследуется:
```c++
template<typename... Mixins>
class Point : public Mixins...
{
	public:
		double x, y;
		
		Point() 
			: Mixins()...
			, x(0.0)
			, y(0.0) 
		{ }

		Point(double x, double y) 
			: Mixins()...
			, x(x)
			, y(y)
		{ }
};
```

Теперь мы можем “подмешать” базовый класс с меткой, чтобы получить `LabeledPoint`:
```c++
class Label
{
	public:
		std::string label;

		Label()
			: label("")
		{ }
};

using LabeledPoint = Point<Label>;
```

или даже добавить несколько базовых классов:
```c++
class Color
{
	public:
		unsigned char   red = 0, 
						green = 0, 
						blue = 0;
};

using MyPoint = Point<Label, Color>;
```

Этот основанный на миксинах класс `Point` позволяет легко предоставить дополнительную информацию к классу `Point` без изменения его интерфейса, так что `Polygon` становится проще использовать и развивать. Пользователи должны только применять неявное преобразование из специализации `Point` в соответствующий класс миксина (такой как `Label` или `Color`, показанные выше) для доступа к данным или интерфейсу. Кроме того, класс `Point` может быть даже полностью скрытым с помощью предоставления миксинов шаблону класса `Polygon`:
```c++
template<typename... Mixins>
class Polygon
{
	private:
		std::vector<Point<Mixins...>> points;
	public:
		... // Открытые операции
);
```

Миксины полезны в тех случаях, когда шаблон требует некоторого небольшого уровня настройки — например, декорирование внутренне хранимых объектов пользовательскими данными — без необходимости требовать от библиотеки открытия и документирования этих внутренних типов данных и их интерфейсов.

## Странные миксины

Миксины могут быть еще более мощным средством при объединении их со [[Шаблоны и наследование#Странно рекурсивный шаблон проектирования|странно рекурсивным шаблоном проектирования]] (`CRTP`). Здесь каждый из миксинов на самом деле является шаблоном класса, который будет предоставлен с типом производного класса, что обеспечивает дополнительные настройки этого производного класса. Версия класса `Point` на основе миксина с применением идиомы `CRTP` будет выглядеть следующим образом:
```c++
template<template<typename>... Mixins>
class Point : public Mixins<Point>...
{
	public:
		double x, y;
		
		Point() 
			: Mixins<Point>()...
			, x(0.0)
			, y(0.0) 
		{ }
		
		Point(double x, double y) 
			: Mixins<Point>()...
			, x(x)
			, y(0.0)
		{ }
};
```

Эта формулировка требует немного больше работы для каждого класса, который будет “подмешан”, поэтому такие классы, как `Label` и `Color`, должны стать шаблонами классов. Однако теперь миксины могут адаптировать свое поведение для определенного экземпляра производного класса, к которому они “подмешиваются”. Например, можно смешать рассматривавшийся ранее шаблон `ObjectCounter` с `Point`, чтобы подсчитывать количество точек, создаваемых `Polygon`, или объединять миксины с другими миксинами, специфичными для данного приложения.

## Параметризованная виртуальность

Миксины также позволяют косвенно параметризовать такие атрибуты производного класса, как виртуальность функции-члена. Простой пример демонстрирует эту весьма удивительную технику:
```c++
#include <iostream>

class NotVirtual
{
};

class Virtual
{
	public:
		virtual void foo()
		{ }
};

template<typename... Mixins>
class Base : public Mixins...
{
	public:
		// Виртуальность foo() зависит от ее объявления
		// (если таковое имеется) в миксинах базовых классов...
		void foo()
		{
			std::cout << "Base::foo()" << ' \n';
		}
};

template<typename... Mixins>
class Derived : public Base<Mixins...>
{
	public:
		void foo()
		{
			std::cout << "Derived::foo() " << '\n';
		}
};

int main()
{
	Base<NotVirtual>* p1 = new Derived<NotVirtual>;
	p1->foo(); 	                                  // Вызов Base::foo()
	
	Base<Virtual>* p2 = new Derived<Virtual>;
	p2->foo();                                    // Вызов Derived::foo()
}
```

Эта методика может служить инструментом для проектирования шаблона класса, используемого как для инстанцирования конкретных классов, так и для расширения с применением наследования. Однако для получения класса, который оказывается хорошим базовым классом для более специализированной функциональности, редко бывает достаточно всего лишь придать виртуальность некоторым функциям-членам. Метод разработки такого вида требует более фундаментальных проектных решений. Поэтому обычно более практичной оказывается разработка двух различных инструментов (иерархии классов или шаблонов классов), чем попытки интегрировать их в единую иерархию шаблонов.

