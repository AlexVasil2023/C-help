
[[#Дальнейшее развитие|Дальнейшее развитие]] 17
1. [[#Ослабленные правила применения typename|Ослабленные правила применения typename]] 17.1
2. [[#Обобщенные параметры шаблонов, не являющиеся типами|Обобщенные параметры шаблонов, не являющиеся типами]] 17.2
3. [[#Частичная специализация шаблонов функций|Частичная специализация шаблонов функций]] 17.3
4. [[#Именованные аргументы шаблонов|Именованные аргументы шаблонов]] 17.4
5. [[#Перегруженные шаблоны классов|Перегруженные шаблоны классов]] 17.5
6. [[#Вывод неконечных раскрытий пакетов|Вывод неконечных раскрытий пакетов]] 17.6
7. [[#Регуляризация void|Регуляризация void]] 17.7
8. [[#Проверка типов для шаблонов|Проверка типов для шаблонов]] 17.8
9. [[#Рефлективное метапрограммирование|Рефлективное метапрограммирование]] 17.9
10. [[#Работа с пакетами|Работа с пакетами]] 17.10
11. [[#Модули|Модули]] 17.11

# Дальнейшее развитие

Шаблоны C++ существенно эволюционировали со времени их первоначального появления в 1988 году, пройдя через различные этапы стандартизации в 1998, 2011, 2014 и 2017 годах. Можно сказать, что большинство добавлений в стандарт после разработки стандарта 1998 было связано с шаблонами.

В первом издании этой книги перечислен ряд расширений, которые мы могли бы увидеть в последующих стандартах; некоторые из них стали реальностью.
>
> Проблема с угловыми скобками: в C++11 убрана необходимость вставки пробела между двумя закрывающими угловыми скобками.
> 
> Аргументы шаблонов функций по умолчанию: C++11 позволяет шаблонам функций иметь аргументы шаблонов по умолчанию.
> 
> Шаблоны [[typedef|typedef]]: в С++11 в стандарт введены подобные по свойствам шаблоны псевдонимов.
> 
> Оператор `typeof`: в C++11 введен оператор [[decltуре|decltype]], который играет туже роль (но использует иное имя во избежание конфликтов с существующим расширением, которое не вполне отвечает нуждам сообщества программистов C++).
> 
> Статические свойства: в первом издании предполагается выбор свойств типов, непосредственно поддерживаемых компиляторами. Это сделано, хотя интерфейс выражается с использованием стандартной библиотеки (которая для многих свойств реализуется с помощью расширений компилятора).
> 
> Пользовательская диагностика инстанцирования: новое ключевое слово [[static#static_assert|static_assert]] реализует идею, изложенную в описании `std::instantiation_error` в первом издании данной книги.
> 
> Параметры-списки: реализованы как ***пакеты параметров*** в C++11.
> 
> Управление размещением в памяти: операторы С++11 [[alignof#alignof|alignof]] и [[alignas#alignas|alignas]] охватывают нужды программистов, описанные в первом издании книги. Кроме того, в стандартную библиотеку C++17 добавлен шаблон [[variant|std::variant]], поддерживающий размеченные объединения.
> 
> Вывод на основе инициализаторов: в C++17 добавлен вывод аргументов шаблонов классов, который решает те же вопросы.
> 
> Функциональные выражения: лямбда-выражения C++11 в точности обеспечивают данную функциональность (с синтаксисом, несколько отличным от обсуждавшегося в первом издании).

Прочие предположительные направления развития, о которых писалось в первом издании, в современном языке отсутствуют, но большинство из них время от времени по-прежнему обсуждаются, так что мы оставим их и в этой книге. Тем временем появляются новые идеи, некоторые из которых также будут представлены далее.

# Ослабленные правила применения typename

В первом издании книги в этом разделе было высказано предположение, что будущее может принести [[Имена в шаблонах - template#Зависимые имена типов|два вида ослабления правил использования typename]]: разрешить применение `typename` там, где оно не было разрешено ранее, и сделать необязательным использование `typename` там, где компилятор может относительно легко определить, что квалифицированное имя с зависимым квалификатором должно быть именем типа. Первое предположение сбылось (`typename` в C++! 1 может избыточно использоваться во многих местах), а последнее — нет.

Недавно, однако, наблюдалась новая попытка сделать `typename` необязательным в различных распространенных контекстах, где однозначно предполагается спецификатор типа.
>
> Тип возвращаемого значения и типы параметров функций в объявлениях функций и функций-членов в областях видимости пространств имен и классов. То же относится и к шаблонам функций и функций-членов, а также лямбда-выражений в любой области видимости.
> 
> Типы в объявлениях переменных, шаблонов переменных и статических членов-данных. То же самое относится и к шаблонам переменных.
> 
> Тип после токена `=` в объявлении псевдонима или шаблона псевдонима.
> 
> Аргумент по умолчанию параметра типа шаблона.
> 
>  Тип в угловых скобках после конструкций [[static_cast|static_cast]], [[const_cast|const_cast]], [[dynamic_cast|dynamic_cast]] или [[reinterpret_cast|reinterpret_cast]].
>  
> Тип, именованный в выражении [[new|new]].

Хотя это не слишком продуманный список, оказывается, что такие изменения в языке позволили бы устранить большинство применений `typename`, что сделало бы код более компактным и удобочитаемым.

# Обобщенные параметры шаблонов, не являющиеся типами

Пожалуй, и для начинающих, и для опытных программистов, пишущих шаблоны, самое удивительное из всех ограничений на аргументы шаблонов, не являющиеся типами, состоит в том, что строковый литерал невозможно использовать в качестве аргумента шаблона.

Приведенный ниже пример интуитивно понятен:
```c++
template<char const* msg>
class Diagnoser
{
	public:
		void print();
};

int main()
{
	Diagnoser<"Surprise!">().print() ;
}
```

Однако здесь есть ряд потенциальных проблем. В стандарте C++ два экземпляра класса `Diagnoser` будут принадлежать одному и тому же типу тогда и только тогда, когда у них одни и те же аргументы. В данном случае аргумент является указателем, другими словами — адресом. Однако у двух идентичных строковых литералов, расположенных в разных местах исходного кода, не обязательно должен быть один и тот же адрес. Таким образом, можно оказаться в неловкой ситуации, когда классы `Diagnoser<"X">` и `Diagnoser<"X">` будут представлять два разных несовместимых типа! (Обратите внимание на то, что `"X"` имеет тип `char const[2]`, но когда он передается в качестве аргумента шаблона, его тип низводится до `char const*`.)

Исходя из этих (и других, связанных с ними) соображений, в стандарте C++ запрещено использовать строковые литералы в качестве аргументов шаблонов. Однако в некоторых реализациях такая возможность существует в виде расширения. Это обеспечивается использованием содержимого строковых литералов во внутреннем представлении экземпляра шаблона. Хотя это вполне осуществимо, некоторые толкователи языка C++ полагают, что не являющийся типом параметр шаблона, который может замещаться строковым литералом, должен объявляться иначе, чем параметр, который может замещаться адресом. Одной из возможностей является захват строковых литералов в пакет параметров символов, например:
```c++
template<char... msg>
class Diagnoser
{
	public:
		void print();
};

int main()
{
	// Инстанцирует Diagnoser<'S','u1,'r','p','r','i',1s','e', '!'>
	Diagnoser<"Surprise! ">().print();
}
```

Кроме того, следует отметить, что в данном вопросе кроется один дополнительный технический недостаток. Рассмотрим следующие объявления шаблонов и предположим, что язык расширен так, чтобы строковые литералы могли использоваться в качестве аргументов шаблонов:
```c++
template<char const* str>
class Bracket
{
	public:
		static char const* address());
		static char const* bytes());
};

template<char const* str>
char const* Bracket<str>::address()
{
	return str;
}

template<char const* str>
char const* Bracket<str>::bytes()
{
	return str;
}
```

В этом коде две функции-члена идентичны во всем, кроме своих имен, — ситуация не такая уж и редкая. Предположим, что некоторая реализация инстанцирует `Bracket<"X">` с помощью процесса, подобного макрорасширению: тогда, если эти две функции-члена инстанцируются в разных единицах трансляции, они могут возвращать разные значения. Интересно, что тестирование некоторых компиляторов языка C++, имеющих данное расширение, показало, что они обладают таким удивительным поведением.

С этим вопросом связан и вопрос о возможности использования литералов с плавающей точкой (и простых константных выражений с плавающей точкой) в качестве аргументов шаблонов, например:
```c++
template<double Ratio>
class Converter
{
	public:
		static double convert(double val)
		{
			return val * Ratio;
		}
};

using InchToMeter = Converter<0.0254>;
```

Эта возможность также имеется в некоторых реализациях языка C++, и она не представляет собой серьезной технической задачи (в отличие от использования строковых литералов в качестве аргументов).

В C++11 вводится понятие ***литерального типа класса***: тип класса, который может принимать константное значение, вычисляемое во время компиляции (включая нетривиальные вычисления с использованием [[constexpr|constexpr]]-функций). После того как такие типы классов стали доступны, тут же стало желательно позволить им быть параметрами шаблонов, не являющимися типами. Однако при этом возникают проблемы, аналогичные описанным выше проблемам, связанным с использованием в качестве параметров строковых литералов. В частности, “равенство” двух значений типа класса является отнюдь не тривиальным вопросом, потому что в общем случае оно определяется с помощью оператора `operator==`. Это равенство определяет, эквивалентны ли два экземпляра, но на практике такая эквивалентность должна проверяться компоновщиком путем сравнения декорированных имен. Одним из выходов может быть вариант, при котором определенные литеральные классы помечаются как имеющие тривиальный критерий равенства, обеспечивающий попарное сравнение скалярных членов класса, после чего в качестве параметров шаблонов, не являющихся типами, могут использоваться только типы классов с таким тривиальным критерием равенства.

# Частичная специализация шаблонов функций

[[Шаблоны Специализация и перегрузка - template|отмечалось, что шаблоны классов можно частично специализировать, тогда как шаблоны функций просто перегружают]]. Эти два механизма различаются между собой.

При частичной специализации не создается полностью новый шаблон: это просто расширение существующего (первичного) шаблона. Когда выбирается шаблон класса, сначала рассматриваются только первичные шаблоны. Если после выбора первичного шаблона оказывается, что существует его частичная специализация с аргументами шаблона, соответствующими данному инстанцированию, его определение (или, другими словами, его тело) инстанцируется вместо определения первичного шаблона (при полной специализации шаблона все выполняется точно так же).

Перегруженные шаблоны функций, напротив, являются отдельными шаблонами, полностью независимыми друг от друга. Когда компилятор решает, какой именно шаблон инстанцировать, он рассматривает все перегруженные шаблоны и выбирает наиболее подходящий. На первый взгляд такой подход кажется вполне адекватным, однако на практике имеется ряд ограничений.
>
> Можно специализировать шаблоны — члены класса без изменения определения этого класса. Однако добавление перегруженного члена требует изменения в определении класса. Во многих случаях этот вариант невозможен, так как у программиста может не быть на это прав. Более того, существующий стандарт языка C++ не позволяет программистам добавлять новые шаблоны в пространство имен `std`, но позволяет специализировать шаблоны из этого пространства имен.
> 
> Чтобы перегрузка шаблонов функций была возможна, параметры этих функций должны различаться каким-то существенным образом. Рассмотрим шаблон функции `R convert (T const&)`, где `R` и `T` — параметры шаблона. Этот шаблон вполне можно специализировать для `R = void`, но с помощью перегрузки этого сделать нельзя.
> 
> Код, который корректен для неперегруженной функции, может перестать быть корректным, когда эта функция перегружается. В частности, если есть два шаблона функций `f(Т)` и `g(Т)` (где `Т` — параметр шаблона), выражение `g(&f<int>)` корректно только в случае, если функция `f` не перегружена (в противном случае будет невозможно решить, какая именно функция `f` имеется в виду).
> 
> Дружественные объявления относятся к определенному шаблону функции или инстанцированию определенного шаблона функции. Перегруженная версия шаблона функции не будет автоматически иметь привилегии, которыми обладает исходный шаблон.

В целом этот список представляет собой убедительный аргумент в пользу частичной специализации шаблонов функций.

Естественным синтаксисом частичной специализации шаблонов функций является обобщение записи для шаблона класса.
```c++
template<typename Т>
Т consts max(T const&, Т const&);         // Первичный шаблон

template<typename Т>
Т* const& max <Т*>(Т* const&, Т* const&);// Частичная специализация
```

Некоторых разработчиков языка беспокоит взаимодействие такого подхода к частичной специализации и перегрузки шаблонов функций. Например:
```c++
template<typename Т>
void add(T& х, int i);     // Первичный шаблон

template<typename T1, typename T2>
void add(T1 a, T2 b);      // Другой (перегруженный) первичный шаблон

template<typename Т>
void add<T*>(Т*&,int);     // Какой из первичных шаблонов специализирован?
```

Однако мы ожидаем, что такие ошибки не окажут значительного влияния на полезность данной функциональной возможности.

Это расширение вкратце обсуждалось во время работы над стандартом C++11, но в итоге собрало относительно мало голосов. Тем не менее эта тема время от времени возрождается, потому что такое нововведение могло бы аккуратно решать некоторые общие проблемы программирования. Возможно, к ее рассмотрению вновь вернутся в некоторых будущих версиях стандарта C++.

# Именованные аргументы шаблонов

В #разделе_21_4 описывается методика, позволяющая предоставлять для определенного параметра аргумент шаблона, не используемый по умолчанию, без необходимости задавать другие аргументы шаблона, для которых используется значение по умолчанию. Это интересная методика, но ясно, что она требует значительного объема работы для достижения относительно простого результата. Поэтому вполне естественным представляется создание механизма для именования аргументов шаблонов.

Здесь следует отметить, что в процессе стандартизации языка C++ подобное расширение (иногда называемое ключевыми аргументами) предлагалось ранее Роландом Хартингером (Roland Hartinger). Это предложение, хотя и вполне обоснованное технически, в конечном итоге не было принято по ряду причин. В настоящее время нет никаких оснований полагать, что именованные аргументы шаблонов когда-нибудь попадут в язык, хотя эта тема регулярно поднимается на заседаниях Комитета. Однако для полноты картины упомянем об одной синтаксической идее, которая бродила в умах некоторых разработчиков.
```c++
template<typename Т,
		typename Move = defaultMove<T>,
		typename Copy = defaultCopy<T>,
		typename Swap = defaultSwap<T>,
		typename Init = defaultInit<T>,
		typename Kill = defaultKill<T>>
class Mutator
{
	...
};

void test(MatrixList m1)
{
	mySort(m1, Mutator <Matrix, .Swap = matrixSwap>);
}
```

Здесь точка, предшествующая имени аргумента, используется для указания, что мы ссылаемся на аргумент шаблона по имени. Этот синтаксис похож на синтаксис инициализации членов структур, введенный в стандарт языка С в 1999 году:
```c++
struct Rectangle
{
	int top, left, width, height;
};

struct Rectangle r = { .width = 10, .height = 10, .top = 0, .left =0 };
```

Конечно, введение именованных аргументов шаблона означает, что имена параметров шаблона теперь являются частью общего интерфейса данного шаблона и не могут быть свободно изменены. Эту проблему можно решить путем более явного синтаксиса, например, такого:
```c++
template<typename Т,
		Move: typename M = defaultMove<T>,
		Copy: typename C = defaultCopy<T>,
		Swap: typename S = defaultSwap<T>,
		Init: typename I = defaultInit<T>,
		Kill: typename K = defaultKill<T>>
class Mutator
{
	...
};

void test(MatrixList m1)
{
	mySort(m1, Mutator <Matrix, .Swap = matrixSwap>);
}
```

# Перегруженные шаблоны классов

Вполне представима перегрузка шаблонов классов на основе их параметров шаблонов. Например, можно представить создание семейства шаблонов `Array`, которые содержат массивы как с динамическими, так и со статическими размерами:
```c++
template<typename Т>
class Array
{
		// массив с динамическим размером
	...
};

template<typename Т, unsigned Size>
class Array
{
		// Массив с фиксированным размером
	...
}
```

Перегрузка не обязательно ограничена количеством параметров шаблона; может также варьироваться и вид параметров:
```c++
template<typename T1, typename Т2>
class Pair
{
		// Пара полей
	...
};

template<int I1, int I2>
class Pair
{
		// Пара константных целочисленных значений
	...
};
```

Хотя неофициально эта идея обсуждалась некоторыми разработчиками языка, однако официально она все еще не была представлена на рассмотрение Комитета по стандартизации языка C++.

# Вывод неконечных раскрытий пакетов

Вывод аргумента шаблона для раскрытия пакета работает только в том случае, когда раскрытие пакета происходит в конце списка параметров или аргументов. Это означает, что, хотя довольно просто получить первый элемент из списка:
```c++
template<typename... Types>
struct Front;

template<typename FrontT, typename... Types>
struct Front<FrontT, Types...>
{
	using Type = FrontT;
};
```

извлечь последний элемент из списка невозможно из-за [[Шаблоны Специализация и перегрузка - template#Частичная специализация шаблона класса|ограничений, накладываемых на частичные специализации]]:
```c++
template<typename... Types>
struct Back;

template<typename ВаскТ, typename... Types>
struct Back<Types..., BackT>           // Ошибка: раскрытие пакета не в
{                                      // конце списка аргументов шаблона
	using Туре = ВаскТ;
};
```

Вывод аргумента шаблона для вариативных шаблонов функций ограничен аналогично. Вполне вероятно, что правила, касающиеся вывода аргумента шаблона раскрытия пакета и частичных специализаций, будут смягчены и станут допускать раскрытие пакета в любом месте списка аргументов шаблона, что сделает операции этого вида гораздо проще. Кроме того, возможно (хотя и менее вероятно), что вывод будет позволять несколько раскрытий пакетов в пределах одного и того же списка параметров:
```c++
template<typename... Types> class Tuple
{
};

template<typename T, typename... Types>
struct Split;

template<typename T, typename... Before, typename... After)
struct Split<T, Before..., T, After...>
{
	using before = Tuple<Before...>;
	using after = Tuple<After...>;
};
```

Разрешение нескольких раскрытий пакетов привносит дополнительные сложности. Например, должен ли `Split` отделять первое вхождение `Т`, последнее его вхождение или некоторое между ними? Насколько сложным станет процесс вывода, прежде чем компилятору будет позволено от него отказаться?

# Регуляризация void

При программировании шаблонов регулярность является добродетелью: если единственная конструкция может охватывать все случаи, это делает наш шаблон проще. Одним из несколько иррегулярных аспектов наших программ являются типы. Например, рассмотрим следующий код:
```c++
auto&& r = f();    // Ошибка, если f() возвращает void
```

Это выражение работает почти для любого типа, который возвращает `f()`, за исключением `void`. Та же проблема возникает и при использовании [[decltуре#decltype(auto) C++14|decltype (auto)]]:
```c++
decltype(auto) r = f();   // Ошибка, если f() возвращает void
```

`void` является не единственным иррегулярным типом: типы функций и ссылочные типы также часто демонстрируют поведение, делающее их в том или ином отношении исключительными. Однако оказывается, что `void` часто осложняет наши шаблоны, и что нет никаких глубоких причин для того, чтобы `void` был таким необычным. Например, [[Обобщенные библиотеки - template#Оборачивание вызовов функций|имеется пример того, как это осложняет реализацию]] идеальной оболочки [[invoke|std::invoke()]].

Можно было бы просто сказать, что `void` — это нормальный тип значения с уникальным значением (как тип [[nullptr_t|std::nullptr_t]] для значения [[nullptr_t#nullptr|nullptr]]). Для обеспечения обратной совместимости нам бы по-прежнему пришлось поддерживать частный случай для объявлений функций наподобие следующих:
```c++
void g(void);  // То же, что и void g();
```

Однако в большинстве других применений `void` стал бы полным типом значений. Тогда мы могли бы, например, объявлять переменные и ссылки `void`:
```c++
void v = void{};
void&& rrv = f() ;
```

И, что более существенно, многие шаблоны больше не требовали бы специализаций для случая `void`.

# Проверка типов для шаблонов

Большая часть сложности программирования шаблонов связана с неспособностью компилятора локально проверить правильность определения шаблона. Вместо этого большинство проверок шаблонов выполняется уже во время инстанцирования, когда контекст определения шаблона и контекст инстанцирования шаблона тесно переплетаются. Это смешение различных контекстов затрудняет выяснение того, кто виноват: виновно ли определение шаблона, потому что неверно использует свои аргументы шаблона, или виновен пользователь шаблона, предоставивший аргументы, не отвечающие требованиям шаблона? Эту проблему можно проиллюстрировать простым примером, который мы аннотировали диагностикой, генерируемой типичным компилятором:
```c++
template<typename Т>
Т mах(Т а, Т b)
{
	return b < a ? a : b;   // Ошибка: "нет соответствующего оператора
							// operator < (типы оператора 'X' и 'X')"
}

struct X
{
};

bool operator > (X, X);

int main()
{
	X a, b;
	X m = max(a,b);          // Примечание: "в запрошенном здесь
				// инстанцировании специализации шаблона функции 'mах<Х>'"
}
```

Обратите внимание на то, что фактическая ошибка (отсутствие корректного оператора `operator <`) обнаруживается внутри определения шаблона функции `max()`. Возможно, это истинная ошибка — может быть, функция `max()` должна использовать вместо него оператор `operator>`? Однако компилятор выводит также примечание в месте, которое приводит к инстанцированию `mах<Х>`, которое и может быть реальной ошибкой — возможно, шаблон функции `max()` документирован как требующий наличия оператора `operator<`? Именно неспособность ответить на этот вопрос часто приводит к [[Применение шаблонов на практике - template#Расшифровка романов об ошибках|“роману ошибок”]], где компилятор предоставил всю историю инстанцирования шаблона — от исходного шаблона до определения шаблона, в котором была обнаружена ошибка. Как ожидается, программист после этого сможет определить, какое из определений шаблонов (или, возможно, исходное использование шаблона в программе) на самом деле содержит ошибку.

Идея, лежащая в основе проверки типов шаблонов, состоит в описании требований шаблона в самом шаблоне, таким образом, чтобы компилятор мог определить, является причиной сбоя компиляции определение или использование шаблона. Одним из решений этой проблемы является описание требований шаблона как часть его сигнатуры с помощью [[Concepts|концепта]]:
```c++
template<typename Т> requires LessThanComparable<T>
Т max(T а, Т b)
{
	return b < а ? а : Ь;
}

struct X {   };

bool operator> (X, X);

int main()
{
	X a, b;
	X m = max(a,b);         // Ошибка: X не отвечает
}                           // требованию LessThanComparable
```

С помощью описания требования к параметру шаблона `Т` компилятор способен гарантировать, что шаблон функции `max()` использует только те операции над `Т`, наличие которых пользователь, как ожидается, должен обеспечить (в данном случае [[Concepts#концепт LessThanComparable|концепт LessThanComparable]] описывает потребность в операторе `operator<`). Кроме того, при использовании шаблона компилятор может проверить, что переданный аргумент шаблона предоставляет все необходимое для правильной работы шаблона функции `max()` поведение. Путем разделения проблемы проверки типов для компилятора становится гораздо проще обеспечить точный диагноз проблемы.

В приведенном выше примере [[Concepts#концепт LessThanComparable|LessThanComparable]] называется ***концептом***: он представляет собой ограничения, накладываемые на тип (в более общем случае, ограничения на множество типов), которые компилятор может проверить. Системы концептов могут быть спроектированы по-разному.

В процессе цикла стандартизации C++11 была полностью спроектирована и реализована сложная система концептов, которые оказались достаточно мощными для выполнения проверок как точек инстанцирования, так и определений шаблона. Первое в нашем примере выше означает, что ошибка в функции `main()` может быть обнаружена очень рано, с диагностикой, которая объясняет, что тип `X` не удовлетворяет ограничениям `LessThanComparable`. Последнее означает, что при обработке компилятором шаблона функции `max()` он проверяет, что не используется ни одна операция, которая не разрешена концептом `LessThanComparable` (и при нарушении этого ограничения выводится соответствующая диагностика). В конечном итоге это предложение в стандарте C++11 было удалено из спецификации языка по разным практическим соображениям (например, оставалось много незначительных вопросов по спецификации, решение которых грозило затянуться, в то время как принятие стандарта и так затягивалось).

После выхода C++11 членами комитета было разработано и представлено новое предложение (сначала называвшееся concepts lite). Эта система не проверяла правильность шаблонов на основе присоединённых к ним ограничений. Вместо этого она фокусировалась только на точке создания экземпляра. Таким образом, если в нашем примере `max()` был реализован с использованием оператора `>`, сообщение об ошибке в этот момент выводиться не будет. Однако оно по-прежнему будет выводиться в функции `main()`, потому что тип `X` не удовлетворяет ограничениям `LessThanComparable`. Новое предложение было реализовано и специфицировано под названием `Concepts TS` (где TS означало «техническая спецификация») и окончательно получило название «Расширения C++ для концептов». В настоящее время основные элементы этой технической спецификации интегрированы в проект следующего стандарта (ожидается, что им станет C++20). [[Concepts|«Концепты»]] описывает эту функциональную возможность языка в том виде, в котором она представлена в проекте языка на момент публикации этой книги.

# Рефлективное метапрограммирование

В контексте программирования рефлексия (reflection) относится к способности программы проверять функциональные возможности самой программы (например, получать ответы на вопросы: «Это целочисленный тип?» «Какие статические члены-данные содержит этот класс?»). Метапрограммирование — это возможность «программировать программу», которая обычно важна для программной генерации нового кода. Рефлексивное метапрограммирование позволяет автоматически генерировать код, который адаптируется к существующим свойствам (часто — типам) программы.

В #части_III «Шаблоны и проектирование» этой книги мы рассмотрим, как шаблоны позволяют достичь некоторых простых форм рефлексии и метапрограммирования (в определённом смысле создание экземпляра шаблона является одной из форм метапрограммирования, поскольку приводит к генерации нового кода). Однако возможности шаблонов C++17 весьма ограничены когда дело доходит до рефлексии (например, не представляется возможным ответить на вопрос, какие нестатические члены-данные содержит некоторый тип класса), и способы метапрограммирования оказываются крайне неудобными (в частности, синтаксис становится громоздким, а производительность — разочаровывающей).

Признавая потенциал новых объектов в этой области, Комитет по стандартизации C++ создал исследовательскую группу (SG7) для изучения возможностей для более мощных рефлексий. Позже деятельность группы была распространена также и на метапрограммирование. Вот пример одного из рассматриваемых группой вариантов:
```c++
template<typename Т> void report(Т р)
{
	constexpr
	{
		std::meta::info infoT = reflexpr(T);

		for(std::meta::info : std::meta::data_members(infoT))
		{
			-> {
				std::cout << ( : std::meta::name(info) :)
							<< ": " << p.(.info.) << ’\n';
			}
		}
	}
// Код будет внедрен сюда
}
```

В этом коде присутствует довольно много новых вещей. Во-первых, конструкция [[constexpr|constexpr {...}]] обеспечивает вычисление инструкций во время компиляции, но если она находится в шаблоне, то это вычисление выполняется только при инстанцировании шаблона. Во-вторых, оператор `reflexpr<>` генерирует выражение непрозрачного типа `std::meta::info`, которое является дескриптором рефлективной информации о его аргументе (тип, в этом примере подставленный вместо `Т`). Библиотека стандартных метафункций разрешает запрос этой метаинформации. Одной из таких стандартных метафункций является `std::meta::data_members`, которая создает последовательность объектов `std::meta::info`, описывающих непосредственные нестатические члены-данные своего операнда. Так что показанный выше цикл [[for|for]] действительно является циклом по всем нестатическим членам-данным `р`.

В основе метапрограммирования в этой системе лежит возможность “внедрения” кода в различные области видимости. Конструкция `->{...}` внедряет инструкции и/или объявления сразу после инструкции или объявления, которые вызывают вычисление [[constexpr|constexpr]]. В приведенном примере это означает — после конструкции `constexpr{...}`. Фрагменты внедряемого кода могут содержать определенные схемы, заменяемые вычисляемыми значениями. В нашем примере `(:...:)` создает значение строкового литерала (выражение `std::meta::name(info)` производит строковый объект, представляющий неквалифицированное имя сущности (в данном случае — член-данные), представленный именем `info`). Аналогично выражение (`.info`.) создает идентификатор, именующий сущность, представленную именем `info`. Предлагаются так­ же и другие шаблоны для генерации типов, списков аргументов шаблона, и т.д.

С учетом всего сказанного инстанцирование шаблона функции `report()` для тина
```c++
struct X
{
	int х;
	std::string s;
};
```

будет давать инстанцирование наподобие
```c++
template<> void report(X const& p)
{
	std::cout << "x" << ": " << "p.x" << '\n';
	std::cout << "s" << ": " << "p.s" << '\n';
}
```

Т.е. эта функция автоматически генерирует функцию для вывода значений нестатических членов-данных типа класса.

Для этих возможностей существует множество приложений. Хотя вполне вероятно, что-то вроде этого в конечном итоге войдет в стандарт языка, неясно, когда именно можно этого ожидать. Тем не менее на момент написания книги было продемонстрировано несколько экспериментальных реализаций таких систем. (Перед самой передачей этой книги в печать группа SG7 согласовала общее направление использования вычислений [[constexpr|constexpr]] и типов значений наподобие `std::meta::infо` для работы с рефлексивным метапрограммированием. Однако представленный здесь механизм внедрения согласован не был и, скорее всего, будет реализована другая система.)

# Работа с пакетами

Пакеты параметров были введены в стандарт C++11, но работа с ними часто требует применения рекурсивных технологий инстанцирования шаблонов.
Вернемся к [[Инстанцирование в шаблонах - template#Инструкции if времени компиляции|наброску кода]]:
```c++
template<typename Head, typename... Remainder>
void f(Head&& h, Remainder&& ... r)
{
	doSomething(h);
	if constexpr(sizeof...(r) != 0)
	{
		// Рекурсивная обработка остальных параметров
		// (прямая передача аргументов):
		f(r...) ;	
	}
}
```

Этот пример можно сделать более простым, используя такую функциональную возможность С++17, как [[#Инструкция if времени компиляции|if времени компиляции]], но метод рекурсивного инстанцирования остается в силе, что может оказаться чрезмерно дорогим для компиляции.

Несколько предложений Комитета направлены на упрощение текущего положения дел. Одним из примеров таких предложений является введение обозначений, позволяющих выбирать определенный элемент из пакета. В частности, для пакета `Р` в качестве способа обозначения `N+1`-го элемента этого пакета предлагалась запись `Р.[N]`. Были сделаны и другие предложения, в частности, для обозначения “срезов” пакетов (например, с использованием обозначений `Р.[b, e]`).

При изучении таких предложений становится понятно, что они в определенной мере взаимодействуют с рассматривавшимся выше рефлективным метапрограммированием. На данный момент неясно, будут ли добавлены в стандарт некоторые механизмы выбора пакетов, или вместо этого данная потребность будет удовлетворяться с помощью возможностей метапрограммирования.

# Модули

Еще одно грядущее крупное расширение — модули, которые слабо связаны с шаблонами, но которые стоит здесь отметить, потому что наибольшую выгоду от них получат библиотеки шаблонов.

В настоящее время интерфейсы библиотек указываются в заголовочных файлах, которые текстуально включаются (с помощью директив `#include`) в единицы трансляции. У этого подхода имеется ряд недостатков, но два наиболее нежелательных таковы: 1) значение текста интерфейса может быть случайно изменено ранее включенным кодом (например, макросами) и 2) время повторной обработки начинает быстро доминировать во времени построения.

Модули представляют собой функциональную возможность, которая позволяет скомпилировать библиотеку интерфейсов в формате, специфичном для данного компилятора, а затем эти интерфейсы можно “импортировать” в единицы трансляции, не опасаясь влияния макросов или модификации значения кода из-за случайного добавления объявления. Более того, компилятор может обеспечить чтение только тех частей файла скомпилированного модуля, которые имеют отношение к клиентскому коду, и тем самым резко ускорить процесс компиляции.

Вот как может выглядеть определение модуля:
```c++
module MyLib;

void helper ()
{
	...
}

export inline void libFunc()
{
	helper();

	...
}
```

Этот модуль экспортирует функцию `libFunc()`, которая может быть использована в клиентском коде следующим образом:
```c++
import MyLib;
int main()
{
	libFunc();
}
```

Заметим, что `libFunc()` становится видимой для клиентского кода, но функция `helper()` таковой не является, несмотря на то, что файл скомпилированного модуля, скорее всего, будет содержать информацию о функции `helper()` для обеспечения возможности встраивания.

Предложение добавить модули в C++ разумно, и Комитет по стандартизации планирует его интеграцию после C++17. Одной из проблем в разработке такого предложения является переход от мира заголовочных файлов в мир модулей. Уже имеются средства, как в определенной степени это позволяющие (например, возможность включать заголовочные файлы, не делая их содержимое частью модуля), так и все еще находящиеся на стадии обсуждения (например, возможность экспортировать макросы из модулей).

Модули особенно полезны для библиотек шаблонов, потому что шаблоны почти всегда полностью определены в заголовочных файлах. Даже включение базового стандартного заголовочного файла наподобие `<vector>` приводит к обработке десятков тысяч строк кода на языке C++ (даже при очень малом количестве ссылок на объявления в этом заголовочном файле). У ряда популярных библиотек эта величина больше на порядок. Избежать расходов на компиляцию всего этого кода — мечта программистов на C++, работающих с большими и сложными проектами.

