
[[#Полиморфная мощь шаблонов|Полиморфная мощь шаблонов]] 18
1. [[#Динамический полиморфизм|Динамический полиморфизм]] 18.1
2. [[#Статический полиморфизм|Статический полиморфизм]] 18.2
3. [[#Сравнение динамического и статического полиморфизма|Сравнение динамического и статического полиморфизма]] 18.3
4. [[#Применение концептов|Применение концептов]] 18.4
5. [[#Новые виды проектных шаблонов|Новые виды проектных шаблонов]] 18.5
6. [[#Обобщенное программирование|Обобщенное программирование]] 18.6
7. [[#Заключительные замечания|Заключительные замечания]] 18.7

# Полиморфная мощь шаблонов

Полиморфизм представляет собой способность связывать различные специфические виды поведения с помощью единой общей записи. Кроме того, полиморфизм является краеугольным камнем парадигмы объектно-ориентированного программирования, которая в C++ поддерживается главным образом через наследование свойств классов и виртуальные функции. Поскольку этот механизм (по крайней мере частично) работает во время выполнения программы, можно употребить термин динамический полиморфизм. Обычно так говорят, когда речь идет об обычном полиморфизме в C++. Однако шаблоны также позволяют связывать различные специфические виды поведения единой общей записью, но это связывание обрабатывается, как правило, в процессе компиляции, так что в данном случае следует говорить о статическом полиморфизме. В этой главе приводится обзор обоих вариантов полиморфизма и обсуждается вопрос, какой из них
соответствует той или иной конкретной ситуации.

Обратите внимание на то, что в #главе_22, “Статический и динамический полиморфизм”, обсуждаются некоторые способы работы с полиморфизмом после введения и обсуждения ряда вопросов проектирования.

# Динамический полиморфизм

Исторически сложилось так, что язык C++ начался с поддержки полиморфизма только посредством наследования, объединенного с виртуальными функциями. В этом контексте искусство полиморфного дизайна состоит в идентификации общего набора возможностей среди связанных типов объектов и объявлении их в качестве интерфейсов виртуальных функций в общем базовом классе.

Наглядным примером этого подхода к конструированию является приложение, которое управляет построением геометрических фигур с возможностью их воспроизведения определенным способом (например, на экране). В таком приложении можно указать так называемый ***абстрактный базовый класс*** (abstract base class — ABC) `GeoObj`, который объявляет общие операции и свойства, применимые к геометрическим объектам вообще. Каждый конкретный класс для конкретных геометрических объектов будет затем порождаться из абстрактного базового класса `GeoObj` (рис.).
![[template_1.png]]
Рис. Полиморфизм, реализованный с помощью наследования

```c++
#include "coord.hpp"

// Общий абстрактный базовый класс GeoObj
// для геометрических объектов
class GeoObj
{
	public:
		// Черчение геометрического объекта:
		virtual void draw() const = 0;
		
		// Возврат центра масс геометрического объекта:
		virtual Coord center_of_gravity() const = 0;

		...
	
		virtual ~GeoObj() = default;
};

// Конкретный класс геометрического объекта Circle
// - унаследован от GeoObj
class Circle : public GeoObj
{
	public:
		virtual void draw() const override;
		virtual Coord center_of_gravity() const override;

		...
};

// Конкретный класс геометрического объекта Line
// - унаследован от GeoObj
class Line : public GeoObj
{
	public:
		virtual void draw() const override;
		virtual Coord center_of_gravity() const override;

		...
};

...
```

После создания конкретных объектов клиентский код может управлять этими объектами через ссылки или указатели на базовый класс, который дает возможность задействовать механизм диспетчеризации виртуальных функций. В результате вызова виртуальной функции-члена посредством указателя или ссылки на подобъект базового класса происходит вызов соответствующего члена объекта, на который осуществлялась ссылка.

В нашем примере конкретный код может выглядеть, как показано ниже.
```c++
#include "dynahier.hpp"
#include <vector>

// Черчение любого GeoObj
void myDraw(GeoObj consts obj)
{
	obj.draw();  // Вызов draw() в соответствии с типом объекта
)

// Вычисление расстояния между центрами масс двух GeoObjs
Coord distance(GeoObj const& x1, GeoObj const& x2)
{
	Coord c = x1.center_of_gravity() - x2.center_of_gravity();
	return c.abs();  // Возврат абсолютного значения
}

// Черчение неоднородного набора объектов GeoObjs
void drawElems(std::vector<GeoObj*> const& elems)
{
	for(std::size_type i = 0; i < elems.size(); ++i)
	{
		elems[i]->draw();   // Вызов draw() в соответствии
							// с типом элемента
	}
}

int main()
{
	Line l;
	Circle c, c1, c2;
	
	myDraw(l);        // myDraw(GeoObj&) => Line::draw()
	myDraw(c);        // myDraw(GeoObj&) => Circle::draw()
	
	distance(c1, c2); // distance(GeoObj &,GeoObj &)
	distance(l, c);   // distance(GeoObj &,GeoObj &)
	
	std::vector<GeoObj*> coll; // Неоднородная коллекция
	coll.push_back(&l);        // Вставка линии
	coll.push_back(&c);        // Вставка окружности

	drawElems(coll);           // Черчение разных GeoObjs
}
```

Ключевыми элементами полиморфного интерфейса являются функции `draw()` и `center_of_gravity()`. Обе функции являются виртуальными функциями-членами. В нашем примере продемонстрировано их использование в функциях `myDraw()`, `distance()` и `drawElems()`. Последние три функции записаны с использованием общего базового типа `GeoObj`. Вследствие этого в процессе компиляции нельзя определить, какая именно версия функции `draw()` или `center_of_gravity()` должна использоваться. Однако в процессе выполнения программы при диспетчеризации вызовов функций определяется полный динамический тип объектов, для которых вызываются виртуальные функции. Следовательно, соответствующая операция выполняется в зависимости от фактического типа геометрического объекта: если `myDraw()` вызывается для объекта `Line`, то выражение `obj.draw()` вызывает функцию `Line::draw()`, тогда как для объекта `Circle` вызывается функция `Circle::draw()`. Подобным же образом в вызове `distance()` функции-члены `center_of_gravity()` соответствуют переданным в качестве параметров объектам.

Пожалуй, наиболее впечатляющей возможностью динамического полиморфизма является способность обрабатывать разнородные коллекции объектов. Эта концепция иллюстрируется функцией `drawElems()`; простое выражение
```c++
elems[1]->draw()
```

выполняет вызов разных функций-членов, в зависимости от типа итерируемого элемента.

# Статический полиморфизм

Шаблоны также могут использоваться для реализации полиморфизма. Однако они не зависят от фактора общего поведения, свойственного базовым классам. Вместо этого общность подразумевает поддержку операций с использованием общего синтаксиса (т.е. соответствующие функции имеют одни и те же имена). Конкретные классы при этом определяются независимо друг от друга (рис.), а сам полиморфизм проявляется при инстанцировании шаблонов с конкретными классами.
![[template_2.png]]
Рис. Полиморфизм, реализованный с помощью шаблонов

Например, функция `myDraw()` из предыдущего раздела
```c++
void myDraw (GeoObj const& obj)  // GeoObj - абстрактный базовый класс
{
	obj.draw();
}
```

может быть переписана следующим образом:
```c++
template<typename GeoObj>
void myDraw (GeoObj const& obj) // GeoObj - параметр шаблона
{
	obj.draw();
}
```

Сравнивая эти две реализации функции `myDraw()`, можно видеть, что основное различие состоит в указании `GeoObj` в качестве параметра шаблона вместо указания в качестве общего базового класса. Имеются, однако, и более существенные различия. Например, при использовании динамического полиморфизма в процессе выполнения у нас была только одна функция `myDraw()`, тогда как, применяя шаблон, мы имеем различные функции, такие как `myDraw<Line>()` и `myDraw<Circle>()`.

Можно попытаться переписать весь пример из предыдущего раздела с использованием статического полиморфизма. При этом вместо иерархии геометрических классов у нас появится несколько индивидуальных геометрических классов.
```c++
#include "coord.hpp"

// Конкретный класс геометрического объекта Circle
// - не являющийся производным от какого-либо иного класса
class Circle
{
	public:
		void draw() const;
		Coord center_of_gravity() const;

		...
};

// Конкретный класс геометрического объекта Line
// - не являющийся производным от какого-либо иного класса
class Line
(
	public:
		void draw() const;
		Coord center_of_gravity() const;

		...
};

...
```

Теперь применение этих классов имеет следующий вид:
```c++
#include "statichier.hpp"
#include <vector>

// Черчение любого GeoObj
template<typename GeoObj>
void myDraw(GeoObj const& obj)
{
	obj.draw()); // Вызов draw() в соответствии с типом объекта
}

// Вычисление расстояния между центрами масс двух GeoObjs
template<typename GeoObj1, typename GeoObj2>
Coord distance(GeoObj1 const& x1, GeoObj2 const& x2)
{
	Coord c = x1.center_of_gravity() - x2.center_of_gravity();
	return c.abs(); // Возврат абсолютного значения
}

// Черчение однородного набора объектов GeoObjs
template<typename GeoObj>
void drawElems(std::vector<GeoObj> const& elems)
{
	for (unsigned i = 0; i c elems.size(); ++i)
	{
		elems[i].draw();    // Вызов draw() в соответствии
							//с типом объекта
	}
}

int main()
{
	Line l;
	Circle с, c1, c2;
	
	myDraw(l); // myDraw<Line>(GeoObj&) => Line::draw()
	myDraw(c); // myDraw<Circle>(GeoObj&) => Circle::draw()
	
	distance (c1, c2); // distance<Circle,Circle>(GeoObj1 &,GeoObj2 &) 
	distance(l, c);    // distance<Line,Circle>(GeoObj1 &,GeoObj2 &)

	// std::vector<GeoObj*> coll;   // Ошибка: гетерогенная
									// коллекция невозможна

	std::vector<Line> coll;         // OK: гомогенная коллекция
	coll.push_back(1);              // Вставка линии
	drawElems(coll);                // Черчение всех линий
}
```

Тип `GeoObj` больше не может использоваться в качестве конкретного параметра типа как для функции `distance()`, так и в функции `myDraw()`. Вместо этого в функции `distance()` предусмотрены два параметра шаблона — `GeoObj1` и `GeoObj 2`. Два разных параметра шаблона позволяют вычислять расстояние между разными типами геометрических объектов:
```c++
distance(l, с); // distance<Line,Circle>(GeoObj1 &,GeoObj2 &)
```

Теперь, однако, разнородные коллекции больше не могут быть прозрачно обработаны. Это тот случай, когда статическая часть статического полиморфизма налагает свои ограничения, а именно: все типы должны быть определены во время компиляции. Взамен предоставляется возможность легко вводить разные коллекции для различных типов геометрических объектов; к тому же больше не требуется, чтобы коллекция была ограничена указателями, что дает существенные преимущества в аспекте производительности и безопасности типов.

# Сравнение динамического и статического полиморфизма

А теперь классифицируем и сравним обе формы полиморфизма.

***===Терминология===***

Динамический и статический полиморфизм обеспечивает поддержку различных идиом языка программирования C++.
>
> Полиморфизм, реализованный с использованием наследования, является ***ограниченным***, или ***связанным*** (bounded) и ***динамическим*** (dynamic).
> 	> Термин ***ограниченный*** означает, что интерфейсы типов, участвующих в процессе полиморфизма, предопределены дизайном общего базового класса (другими терминами для обозначения данной концепции являются ***инвазивный*** (invasive) или ***интрузивный*** (intrusive)).
> 	> 
> 	> Термин ***динамический*** означает, что связывание интерфейсов происходит в процессе выполнения программы (т.е. динамически).
> 
> Полиморфизм, реализованный с использованием шаблонов, является ***неограниченным*** (unbounded) и ***статическим*** (static).
> 	> 
> 	> Термин ***неограниченный*** означает, что интерфейсы типов, участвующих в процессе полиморфизма, не предопределены заранее (другими терминами для обозначения данной концепции являются ***неинвазивный*** (noninvasive) или ***неинтрузивный*** (nonintrusive)).
> 	> 
> 	> Термин ***статический*** означает, что связывание интерфейсов происходит в процессе компиляции (т.е. статически).

Строго говоря, в терминах языка C++ понятия ***динамический полиморфизм*** и ***статический полиморфизм*** — это сокращенные варианты понятий ***ограниченный динамический полиморфизм*** и ***неограниченный статический полиморфизм***. В других языках используются иные комбинации (например, `Smalltalk` предоставляет неограниченный динамический полиморфизм). Однако более краткие термины ***динамический полиморфизм*** и ***статический полиморфизм*** в контексте языка C++ не приводят к возникновению путаницы.

***===Преимущества и недостатки===***

Динамический полиморфизм в C++ обладает рядом преимуществ.
>
> Элегантная обработка разнородных коллекций.
> 
> Размер исполняемого кода потенциально меньше (поскольку в данном случае нужна только одна полиморфная функция, тогда как для шаблонов с разными параметрами типов должны быть сгенерированы отдельные экземпляры).
> 
> Код полностью компилируем; таким образом, исходные тексты не обязательно должны быть опубликованы (распространение библиотек шаблонов обычно требует распространения исходного кода реализации шаблонов).

Приведем преимущества статического полиморфизма в C++.
>
> Легко реализуются коллекции встроенных типов. Общность интерфейса не обязательно должна выражаться через общий базовый класс.
> 
> Сгенерированный код потенциально выполняется быстрее (поскольку отсутствует необходимость в косвенном обращении через указатели, а невиртуальные функции могут быть встраиваемыми намного чаще).
> 
> Могут использоваться конкретные типы, в которых имеются только частичные интерфейсы (только если приложение ограничивается использованием этого частичного интерфейса).

Часто статический полиморфизм расценивается как более надежный в плане безопасности типов, чем динамический, поскольку все связывания выполняются в процессе компиляции. Например, опасность того, что в контейнер, реализованный шаблоном, будет вставлен объект неправильного типа, крайне мала; в то же время в контейнере, который содержит указатели на общий базовый класс, существует возможность непреднамеренного использования указателей на объекты совершенно иного типа.

На практике инстанцирование шаблонов может вызвать определенные неприятности в том случае, когда за идентично выглядящими интерфейсами скрываются разные семантические допущения. Например, неприятные сюрпризы могут произойти тогда, когда шаблон предполагает наличие ассоциативного оператора `+` у типа, который таким оператором не обладает. Обычно этот вид семантического несоответствия встречается гораздо реже в иерархиях, основанных на наследовании; вероятно, это связано с более явным и точным определением интерфейса.

***===Объединение обеих форм===***

Конечно, можно совместить обе формы наследования. Например, различные виды геометрических объектов можно порождать из общего базового класса, для того чтобы иметь возможность обрабатывать неоднородные коллекции геометрических объектов. Однако одновременно можно использовать и шаблоны в целях написания кода для некоторого отдельного вида геометрического объекта.

Комбинация наследования и шаблонов описана в #главе_21, “Шаблоны и наследование”. В ней рассматривается (помимо прочего), как может быть параметризована виртуальность функции-члена и как можно предоставить дополнительную гибкость статическому полиморфизму, используя основанную на наследовании ***модель необычного рекуррентного шаблона*** (curiously recurring template pattern — CRTP).

# Применение концептов

Одним из аргументов против статического полиморфизма с шаблонами является то, что связывание интерфейсов выполняется путем инстанцирования соответствующих шаблонов. Это означает, что не существует некоторого общего интерфейса (класса), а работает любое использование шаблона, лишь бы весь инстанцированный код был корректен. Если же это не так, то это может привести к трудно понимаемым сообщениям об ошибках или даже вызвать корректное, но нежелательное поведение.

По этой причине разработчики языка C++ работали над возможностью явно предоставлять (и проверять) интерфейсы для параметров шаблонов. Обычно такой интерфейс называется в C++ [[Concepts|концептом]]. Он обозначает набор ограничений, которым должны отвечать аргументы шаблона для того, чтобы инстанцирование шаблона было успешным.

Несмотря на многие годы работы в этой области концепты по-прежнему не являются частью стандарта C++ — по крайней мере до стандарта C++17 включительно. Некоторые компиляторы предоставляют экспериментальную поддержку такой возможности, так что концепты, вероятно, станут частью следующего после C++17 стандарта.

Концепты можно рассматривать как своего рода “интерфейс” для статического полиморфизма. В нашем примере это может выглядеть следующим образом:
```c++
#include "coord.hpp"

template<typename T>
concept GeoObj = requires(T x)
{
	{
		x.draw() 
	} -> void;
	
	{
		x.center_of_gravity()
	} -> Coord;
};
```

Здесь ключевое слово [[Concepts|concept]] использовано для определения концепты `GeoObj`, которая ограничивает тип наличием вызываемых членов `draw()` и `center_of_gravity()` с соответствующими возвращаемыми типами.

Теперь можно переписать некоторые из наших примеров шаблонов, включив конструкцию `requires`, которая ограничивает параметры шаблона концептом `GeoObj`:
```c++
#include "conceptsreq.hpp"
#include <vector>

// Черчение любого GeoObj
template<typename T>
requires GeoObj<T>
void myDraw(T const& obj)
{
	obj.draw();  // Вызов draw() в соответствии с типом объекта
}

// Вычисление расстояния между центрами масс между двумя GeoObjs
template<typename T1, typename T2>
requires GeoObj<T1> && GeoObj<T2>
Coord distance(T1 const& x1, T2 const& x2)
{
	Coord c = x1.center_of_gravity() - x2.center_of_gravity();
	return c.abs(); // Возврат абсолютного значения
}

// Черчение однородной коллекции GeoObjs
template<typename Т>
requires GeoObj<T>
void drawElems(std::vector<T> const& elems)
{
	for (std::size_type i = 0; i < elems.size(); ++i)
	{
		elems[i].draw(); // Вызов draw() в соответствии с типом элемента
	}
}
```

Этот подход по-прежнему неинвазивный по отношению к типам, которые могут участвовать в (статическом) полиморфном поведении:
```c++
// Конкретный класс геометрического объекта Circle
// - не является производным от другого класса
// и не реализующий никакой интерфейс

class Circle
{
	public:
		void draw() const;
		Coord center_of_gravity() const;

		...
}
```

To есть такие типы по-прежнему определяются без каких-либо конкретных базовых классов или конструкций требований и могут быть фундаментальными типами данных или типов из независимых каркасов.

В #приложении_Д, “Концепты”, концепты в C++ обсуждаются более подробно, поскольку ожидается, что они войдут в следующий стандарт языка.

# Новые виды проектных шаблонов

Следствием использования новой формы статического полиморфизма являются новые пути реализации проектных шаблонов. Возьмем, например, шаблон “Мост” (Bridge pattern), который играет большую роль в программах на C++. Одна из задач использования этого проектного шаблона состоит в переключении между различными реализациями интерфейса.

Обычно это переключение осуществляется с использованием класса интерфейса, который содержит указатель для обращения к фактической реализации и делегирования всех обращений к этому классу (рис.).
![[template_3.png]]
Рис. Проектный шаблон "Мост", реализованный с использованием наследования. 

Однако если тип реализации известен во время компиляции, то вместо этого можно использовать подход с применением шаблонов (рис. ). Это приведет к большей безопасности типов и позволит избежать использования указателей, что должно способствовать более высокой производительности программы.
![[template_4.png]]
Рис. Проектный шаблон "Мост", реализованный с использованием шаблонов

# Обобщенное программирование

Статический полиморфизм порождает концепцию ***обобщенного программирования*** (generic programming). Однако единого универсального установившегося определения этого понятия не существует (как не существует и единого установившегося определения понятия ***объектно-ориентированного программирования***).

Имеются определения от ***программирования с обобщенными параметрами*** (programming with generic parameters) до поиска наиболее абстрактного представления эффективных алгоритмов (finding the most abstract representation of efficient algorithms). Книга резюмирует: Обобщенное программирование — это поддисциплина информатики, которая имеет дело с поиском абстрактных представлений эффективных алгоритмов, структур данных и других понятий программного обеспечения, вместе с организацией их систематики... Обобщенное программирование сосредоточивает внимание на представлении семейств концепций доменов.

В контексте C++ обобщенное программирование иногда определяется как программирование с шаблонами (programming with templates), а объектно-ориентированное программирование рассматривается как программирование с виртуальными функциями (programming with virtual functions). В этом смысле почти любое использование шаблонов в C++ можно рассматривать как пример обобщенного программирования. Однако практикующие программисты часто рассматривают обобщенное программирование как имеющее дополнительный существенный компонент, а именно: шаблоны должны конструироваться в целях предоставления большого числа полезных комбинаций.

Наиболее значительный вклад в этой области принадлежит стандартной библиотеке шаблонов {Standard Template Library — STL), которая позже была адаптирована и включена в стандартную библиотеку C++. STL является каркасом, который предоставляет большое количество полезных операций, называемых алгоритмами, для ряда линейных структур данных для хранения коллекции объектов (контейнеров). И алгоритмы и контейнеры являются шаблонами; однако ключевой момент состоит в том, что алгоритмы не являются функциями-членами контейнеров. Они написаны обобщенным способом, так что их можно использовать с любым контейнером (и линейной коллекцией элементов). Для обеспечения такого использования проектировщики STL определили абстрактное понятие итераторов, которые могут быть предоставлены для любого вида линейной коллекции. По существу, аспекты функционирования контейнера, специфические для данной коллекции, оказались переложенными на функциональность итераторов.

Вследствие этого операция наподобие вычисления максимального значения в последовательности может быть выполнена без знания того, каким образом в этой последовательности хранятся значения.
```c++
template<typename Iterator>
Iterator max_element(Iterator beg,    // Начало коллекции
						Iterator end) // Конец коллекции
{
	// Используются определенные операции итератора
	// для обхода всех элементов коллекции с целью
	// поиска элемента с максимальным значением и
	// возврата его позиции посредством итератора		

	...
}
```

Вместо того чтобы обеспечить полезными операциями, подобными `mах_element()`, каждый из линейных контейнеров, контейнер должен предоставить итератор для обхода всех содержащихся в нем значений, а также функции-члены, необходимые для создания таких итераторов.
```c++
namespace std
{
	template<typename Т, ...>
	class vector
	{
		public:
			using const_iterator = ...; // Зависящий от реализации
			...                         // итератор для константных
										// векторов
			const_iterator begin() const; // Итератор начала коллекции
			const_iterator end() const;   // Итератор конца коллекции

			...
	};

	template<typename Т, ...>
	class list
	{
		public:
			using const_iterator = ...; // Зависящий от реализации
			...                         // итератор для константных
										// списков
			const_iterator begin() const; // Итератор начала коллекции
			const_iterator end() const;   // Итератор конца коллекции
	
			...
	};
}
```

Теперь можно находить максимум любой коллекции, вызывая обобщенную операцию `max_element()` с указанием начала и конца коллекции в качестве аргументов (здесь опущен частный случай пустой коллекции):
```c++
#include <vector>
#include <list>
#include <algorithm>
#include <iostream>
#include "MyClass.hpp"

template<typename T>
void printMax(T const& coll)
{
	// Вычисление позиции максимального значения
	auto pos = std::max_element(coll.begin(), coll.end());
	
	// Вывод значения максимального элемента coll
	// (если таковой имеется):
	if (pos != coll.end())
	{
		std::cout << *pos << '\n';
	}
	else
	{
		std::cout << "empty" << '\n';
	}
}

int main()
{
	std::vector<MyClass> c1;
	std::list<MyClass> c2;

	...

	printMax(cl);
	printMax(c2);
}
```

Параметризируя свои операции в терминах итераторов, STL избегает резкого увеличения количества определений операций. Вместо того чтобы реализовать каждую операцию для каждого контейнера, нужно реализовать алгоритм всего лишь один раз, после чего его можно будет использовать для каждого контейнера. ***Обобщенная связка*** (generic glue) — это итераторы, которые обеспечиваются контейнерами и используются алгоритмами. Этот метод работоспособен, поскольку итераторы имеют определенный интерфейс, который обеспечивается контейнерами и используется алгоритмами. Этот интерфейс обычно называется концептом, что обозначает набор ограничений, которым должен удовлетворять шаблон, чтобы вписаться в соответствующую схему.

[[Полиморфная мощь шаблонов#Применение концептов|Концепты]] (более подробно они изложены в #приложении_Д, “Концепты”), и фактически данная возможность языка точно отображается на приведенное здесь понятие. В самом деле, термин концепт в данном контексте был впервые введен разработчиками STL для формализации их работы. Вскоре после этого начались работы по введению этого понятия в шаблоны явным образом.

Предполагаемая функциональная возможность языка поможет указывать и дважды проверять требования к итераторам (поскольку имеются различные категории итераторов, такие как одно- и двунаправленные итераторы, будет использоваться несколько соответствующих концептов; см. #раздел_Д_3_1). Однако в современном C++ [[Concepts|концепты]] в основном используются в спецификациях наших обобщенных библиотек (в том числе стандартной библиотеки C++) неявно. К счастью, некоторые функциональные возможности и методы (например, [[assert#static_assert()|static_assert]] и [[SFINAE|SFINAE]]) позволяют выполнить часть автоматизированных проверок.

В принципе, функциональность наподобие STL-подобной может быть реализована и с использованием динамического полиморфизма. Однако на практике она имела бы ограниченное применение, поскольку концепция итераторов слишком “легковесная” по сравнению с механизмом вызова виртуальной функции. Добавление уровня интерфейса на основе виртуальных функций, скорее всего, замедлит наши операции на порядок (а то и больше).

Обобщенное программирование практично именно потому, что оно основано на статическом полиморфизме, который выполняет разрешение интерфейсов во время компиляции. С другой стороны, требование, чтобы интерфейсы разрешались во время компиляции, вызывает к жизни новые принципы проектирования, которые во многих отношениях отличаются от принципов объектно-ориентированного проектирования. Некоторые из наиболее важных из этих принципов обобщенного проектирования описываются в оставшейся части книги. Кроме того, обобщенное программирование подробно рассмотрено в #приложении_Д, “Концепты”.

# Заключительные замечания

Контейнерные типы были первым толчком для введения шаблонов в язык программирования C++. До шаблонов наиболее популярным подходом при разработке контейнеров были полиморфные иерархии. В качестве широко известного примера можно привести библиотеку классов Национального института здравоохранения (National Institutes of Health Class Library — NIHCL), в которой была расширена иерархия контейнеров `Smalltalk` (рис.).
![[template_5.png]]
Рис. Иерархия классов NIHCL

Во многом подобно стандартной библиотеке C++ библиотека `NIHCL` поддерживала широкое разнообразие контейнеров и итераторов. Однако реализация библиотеки следовала стилю динамического полиморфизма Smalltalk: для работы с коллекциями разных типов итераторы использовали абстрактный базовый класс `Collection`:
```c++
Bag c1;
Set с2;

...

Iterator i1(c1);
Iterator i2(c2);

...
```

К сожалению, цена такого подхода была весьма высока, это касалось как времени работы, так и используемой памяти. Обычно время работы оказывалось на порядок больше, чем у эквивалентного кода, использующего стандартную библиотеку C++, поскольку большинство операций приводили к виртуальным вызовам (в то время как в стандартной библиотеке C++ многие операции являются встраиваемыми, а в интерфейсах итераторов и контейнеров нет никаких виртуальных функций). Кроме того, поскольку (в отличие от Smalltalk) интерфейсы были ограниченными, встроенные типы должны были быть “обернутыми” в большие полиморфные классы (что и обеспечивала NIHCL), а это, в свою очередь, увеличивало потребность в памяти.

Даже в нынешнюю эпоху шаблонов во многих проектах все еще делается неоптимальный выбор в пользу использования полиморфизма. Очевидно, что существует множество ситуаций, когда следует отдать предпочтение динамическому полиморфизму (в качестве яркого примера можно привести гетерогенные коллекции). Однако ничуть не меньше задач программирования естественно и эффективно решаются с использованием шаблонов.

Использование статического полиморфизма хорошо подходит для кодирования наиболее фундаментальных вычислительных структур; необходимость же выбора общего базового типа приводит к тому, что динамическая полиморфная библиотека обычно хорошо удовлетворяет требованиям конкретной предметной области. Поэтому не должен вызывать никакого удивления тот факт, что STL-часть стандартной библиотеки C++ никогда не включала в свой состав полиморфные контейнеры, но зато содержит богатый набор контейнеров и итераторов, которые используют [[Полиморфная мощь шаблонов#Обобщенное программирование|статический полиморфизм]].

Средние и большие программы, написанные на C++, обычно работают с обоими видами полиморфизма, рассмотренными в данной главе. Порой может даже возникнуть необходимость их весьма тесной комбинации. Во многих случаях выбор оптимального варианта проектирования в свете нашего обсуждения изначально представляется совершенно ясным, однако спустя некоторое время приходит понимание того, что здесь, как нигде, важна роль долгосрочного планирования с учетом всех возможных путей эволюции разрабатываемого проекта.
