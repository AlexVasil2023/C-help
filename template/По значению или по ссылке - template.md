
[[#По значению или по ссылке|По значению или по ссылке]] 7
1. [[#Передача по значению|Передача по значению]] 7.1
2. [[#Передача по ссылке|Передача по ссылке]] 7.2
	1. [[#Передача с помощью константной ссылки|Передача с помощью константной ссылки]] 7.2.1
	2. [[#Передача с помощью неконстантной ссылки|Передача с помощью неконстантной ссылки]] 7.2.2
	3. [[#Передача с помощью передаваемой ссылки|Передача с помощью передаваемой ссылки]] 7.2.3
3. [[#Использование std ref() и std cref()|Использование std::ref() и std::cref()]] 7.3
4. [[#Работа со строковыми литералами и массивами|Работа со строковыми литералами и массивами]] 7.4
	1. [[#Специальные реализации для строковых литералов и обычных массивов|Специальные реализации для строковых литералов и обычных массивов]] 7.4.1
5. [[#Работа с возвращаемыми значениями|Работа с возвращаемыми значениями]] 7.5
6. [[#Рекомендуемые объявления параметров шаблона|Рекомендуемые объявления параметров шаблона]] 7.6

# По значению или по ссылке

Поскольку C++ изначально предоставляет возможность передачи аргумента в функцию и по значению, и по ссылке, не всегда просто решить, какой из методов выбрать: обычно передача по ссылке дешевле для нетривиальных объектов, но более сложна. C++11 добавил еще и семантику перемещения, так что теперь
у нас есть различные способы передачи по ссылке.

1. **`х const&`** (константная [[rvalue|l-ссылка]]):
параметр ссылается на переданный объект, который невозможно модифицировать.
2. **`х&`** (неконстантная [[rvalue|l-ссылка]]):
параметр ссылается на переданный объект, который можно модифицировать.
1. **`Х&&`** ([[rvalue|г-ссылка]]):
параметр ссылается на переданный объект с семантикой перемещения, что означает, что его можно модифицировать или “украсть” его значение.

Выбор способа объявления параметров с известными конкретными типами является достаточно сложной задачей. В шаблонах типы не известны, и поэтому становится еще труднее решить, какой механизм передачи аргументов использовать в том или ином случае.

Тем не менее мы рекомендовали [[Шаблоны функций - template#Передача по значению или по ссылке|передавать параметры в шаблоны функций по значению]], если только нет веских причин поступать иначе, например, следующих:

* невозможность копирования;
* параметры используются для возврата данных;
* шаблоны просто передают параметры куда-то еще, сохраняя все свойства исходных аргументов;
* имеется серьезное улучшение производительности.

В этой главе обсуждаются различные подходы к объявлению параметров в шаблонах, причины общей рекомендации передавать аргументы по значению, а также аргументы в пользу отказа от этого решения. Кроме того, здесь рассматриваются сложные проблемы, с которыми вы столкнетесь при работе со строковыми литералами и другими видами массивов.

При чтении этой главы было бы полезно ознакомиться с терминологией, связанной с категориями значений ( [[значение - template#l-значение|l-значения]], [[значение - template#r-значения|r-значения]], [[значение - template#pr-значения|pr-значения]], [[значение - template#x-значения|х-значения]] и [[значение - template#gl-значение|gl-значение]].).

## Передача по значению

При передаче аргументов по значению каждый аргумент в принципе должен быть скопирован. Таким образом, каждый параметр становится копией переданного аргумента. В случае классов объект, создаваемый как копия, обычно инициализируется с помощью копирующего конструктора.

Вызов копирующего конструктора может быть достаточно дорогим. Однако существуют различные пути избежать дорогостоящего копирования даже при передаче параметров по значению: компиляторы при оптимизации зачастую могут полностью удалить операции копирования и с помощью семантики перемещения сделать копирование объектов дешевым даже для сложных объектов.

Например, рассмотрим простой шаблон функции, реализованный с передачей аргумента по значению:
```c++
template<typename Т>
void printV(T arg)
{
	...
}
```

При вызове этого шаблона функции для целочисленного значения получающийся в результате код имеет вид
```c++
void printV(int arg)
{
	...
}
```

Параметр `arg` становится копией любого переданного аргумента, является он объектом, литералом или значением, возвращаемым вызовом функции.

Если мы определим объект типа [[string|std::string]] и вызовем для него наш шаблон функции:
```c++
std::string s = "hi";
printV(s);
```

то параметр шаблона `T` будет инстанцирован как [[string|std::string]], так что мы получим
```c++
void printV(std::string arg)
{
	...
}
```

И вновь при передаче строки `arg` становится копией `s`. На этот раз копия создается копирующим конструктором класса [[string|string]], который является потенциально дорогостоящей операцией, потому что в принципе эта операция копирования выполняет глубокое копирование, так что для копии выделяется собственная память для хранения значения.

Однако потенциальный копирующий конструктор вызывается не всегда. Рассмотрим следующий код:
```c++
std::string returnstring()
std::string s = "hi";

printv(s);                      // Копирующий конструктор
printv(std::string("hi"));      // Обычно копирование устраняется (или
								// использует перемещающий конструктор)
printV(returnstring());         // Обычно копирование устраняется (или
								// использует перемещающий конструктор)
printv(std::move(s));           // Перемещающий конструктор
```

В первом вызове передается `l-значение`, что означает, что используется копирующий конструктор. Однако во втором и третьем вызовах, когда шаблон функции вызывается непосредственно для `pr-значений` ([[значение - template|временные объекты, создаваемые на лету или возвращаемые другой функцией]]), компиляторы обычно выполняют оптимизацию, передавая аргумент так, что копирующий конструктор не вызывается вовсе. Обратите внимание на то, что, начиная с C++17, эта оптимизация является обязательной. До С++17 компилятор, который не отбрасывал копирование при оптимизации, должен был как минимум попытаться использовать семантику перемещения, которая обычно удешевляет копирование. В последнем вызове при передаче `х-значения` (существующий неконстантный объект с [[move|std::move()]] ) мы принудительно вызываем перемещающий конструктор, указывая, что больше не нуждаемся в значении `s`.

Таким образом, вызов реализации `printv()`, которая объявлена с передачей параметра по значению, обычно оказывается дороже только при передаче `l-значения` (объекта, созданного ранее и обычно используемого после вызова, раз уж мы не использовали [[move|std::move()]] при его передаче). К сожалению, это довольно распространенный случай. Одной из причин является распространенность практики создания объектов заранее для передачи их другим функциям позднее (после некоторых изменений).

> **Низведение при передаче по значению**

У передачи по значению есть еще одно свойство, о котором мы должны упомянуть: при передаче аргументов по значению тип низводится ([[decay|decay]]). Это означает, что обычные массивы преобразуются в указатели, и что квалификаторы, например [[const|const]] и [[volatile|volatile]], удаляются (так же, как и при использовании значения в качестве инициализатора для объекта, объявленного с помощью [[auto|auto]]):
```c++
template<typename Т>
void printV(Т arg)
{
	...
}

std::string const c = "hi";
printV(c);          // с низводится, так что arg имеет тип std::string
printV("hi");       // Низводится до указателя,
					// так что arg имеет тип char const*

int arr[4];         // Низводится до указателя,
printV(arr);        // так что arg имеет тип int*
```

Таким образом, при передаче строкового литерала `"hi"` его тип `char const [3]` низводится до `char const*`, так что именно таков выведенный тип `Т`. Итак, шаблон создается следующим образом:
```c++
void printV(char const* arg)
{
	...
}
```

Это поведение является производным от языка программирования С и имеет свои преимущества и недостатки. Часто оно упрощает обработку передаваемых строковых литералов, но его недостатком является то, что внутри `printV()` мы не можем различить передачу указателя на один элемент и передачу массива. Как бороться со строковыми литералами и другими массивами, мы обсудим в #разделе_7_4.

## Передача по ссылке

Давайте теперь рассмотрим различные “за” передачу по ссылке. Во всех случаях копия не создается (поскольку параметр просто ссылается на передаваемый аргумент). Кроме того, при этом не происходит низведения типа. Однако иногда такая передача невозможна, а если и возможна, то бывают ситуации, когда результирующий тип параметра может вызвать проблемы.

### Передача с помощью константной ссылки

Чтобы избежать любого (ненужного) копирования при передаче объектов, не являющихся временными, можно использовать константные ссылки. Например:
```c++
template<typename Т>
void printR(T const& arg)
{
	...
}
```

При использовании данного объявления передача объекта никогда не приводит к созданию копии (независимо от ее дороговизны):
```c++
std::string returnstring()
std::string s = "hi";

printR(s);                     // Копия не создается
printR(std::string("hi"));     // Копия не создается
printR(returnString());        // Копия не создается
printR(std::move(s));          // Копия не создается
```

По ссылке передается даже `int` (что несколько контрпродуктивно, хотя и не имеет особого значения). Таким образом:
```c++
int i = 42;
printR(i);                     // Передача ссылки вместо копирования i
```

приводит к следующему инстанцированию `printR():`

За сценой передача аргумента по ссылке осуществляется с помощью передачи адреса аргумента. Адреса кодируются компактно, так что передача адреса из вызывающей функции в вызываемую сама по себе эффективна. Однако при передаче адреса для компилятора создается некоторая неопределенность: что вызываемая функция делает с этим адресом? В теории вызываемый код может изменять все значения, до которых удается “добраться” с использованием этого адреса. Это означает, что компилятор должен считать, что все значения, которые он может кешировать (обычно в регистрах процессора), после вызова являются недействительными. Перезагрузка всех этих значений может оказаться довольно дорогой. Вы можете возразить, что мы передаем константную ссылку: не может ли компилятор на этом основании определить, что никакие изменения не могут произойти? К сожалению, это не так, потому что вызывающий код может изменить объект через свою собственную, неконстантную ссылку.

Эти плохие новости смягчаются применением встраивания: если компилятор может развернуть вызов как встроенный, он может увидеть вызывающий и вызываемый код вместе и во многих случаях “понять”, что адрес не используется ни для чего, кроме передачи указываемого им значения. Шаблоны функций часто очень короткие и потому являются вероятными кандидатами для встраивания. Однако, если шаблон инкапсулирует более сложный алгоритм, встраивание вряд ли произойдет.

> **Передача по ссылке не приводит к низведению**

При передаче аргументов по ссылке низведение их типов не выполняется. Это означает, что массивы не преобразуются к указателям, а квалификаторы наподобие [[const|const]] и [[volatile|volatile]] не удаляются. Однако, поскольку параметр вызова объявляется как `Т const&`, сам параметр шаблона `Т` как [[const|const]] не выводится. Например:
```c++
template<typename Т>
void printR(Т const& arg)
{
	...
}

std::string const c = "hi";

printR(c);    // T выводится как std::string, arg - std::string const&
printR("hi"); // T выводится как char[3], arg - char const(&)[3]

int arr[4];
printR(arr);  // T выводится как int[4], arg - int const(&)[4]
```

Таким образом, локальные объекты `printR()`, объявленные с типом `Т`, константными не являются.

### Передача с помощью неконстантной ссылки

Когда вы хотите возвращать значения с помощью переданных аргументов (то есть когда вы хотите использовать выходные параметры), вы должны использовать неконстантные ссылки (если только не предпочитаете передавать их через указатели). И вновь это означает, что при передаче аргументов не создается копия. Параметры шаблона вызываемой функции просто получают непосредственный доступ к переданному аргументу.

Рассмотрим следующий код:
```c++
template<typename Т>
void outR(T& arg)
{
	...
}
```

Обратите внимание на то,что вызов `outR()` для временного объекта (`pr-значение`) или существующего объекта, переданного с использованием [[move|std::move()]] (`х-значение`), обычно не разрешен:
```c++
std::string returnString();
std::string s = "hi";

outR (s);                   // OK: Т выводится как std::string,
							// arg - std::strings
outR(std::string("hi"));    // Ошибка: нельзя передавать временный
							// объект (рг-значение)

outR(returnString());       // Ошибка: нельзя передавать временный
							// объект (рг-значение)
outR(std::move(s));         // Ошибка: нельзя передавать х-значение
```

Можно передавать массивы неконстантных типов (над которыми здесь так же, как и в предыдущем разделе, не будет выполняться низведение типов):
```c++
int arr[4];
outR(arr);                 // OK: T выводится как int[4], arg - int(&)[4]
```

Таким образом, можно изменять элементы, а также, например, работать с размером массива:
```c++
template<typename Т>
void outR(T& arg)
{
	if (std::is_array<T>::value)
	{
		std::cout << "Массив из " << std::extent<T>::value
				<< " элементов \п";
	}
}
```

Однако шаблоны здесь с хитростью. Если вы передадите `const-аргумент`, вывод может привести к тому, что `arg` станет объявлением константной ссылки, что означает, что становится возможным передавать `r-значение` там, где, казалось бы, ожидается `l-значение`:
```c++
std::string const с = "hi";

outR(с);                        // OK: выводится как std::string const
outR(returnConstString());      // OK: то же, если returnConstString()
								// возвращает const string
outR(std::move(c));             // OK: T выводится как std::string const
outR("hi") ;                    // OK: T выводится как char const
```

Конечно, любая попытка изменить переданный аргумент внутри шаблона функции в такой ситуации является ошибкой. Передача константного объекта возможна в самом выражении вызова, но, когда функция полностью инстанцирована (что может произойти позже в процессе компиляции), любая попытка изменить значение вызовет ошибку (которая, однако, может произойти глубоко внутри вызванного шаблона; см. #раздел_9_4).

Если вы хотите запретить передачу константных объектов по неконстантным ссылкам, то можно сделать следующее:

> использовать [[assert#static_assert()|static_assert]] для генерации ошибки времени компиляции:

```c++
template<typename Т>
void outR(T& arg)
{
	static_assert(!std::is_const<T>::value,
			"Выходной параметр foo<T>(T&) - константа");

	...
}
```

> [[Семантика перемещения - Отключение шаблонов с помощью enable_if - template|отключить шаблон для этого случая совсем с помощью std::enable_if<>]]
```c++
template <typename Т,
		typename = std::enable_if_t<!std::is_const<T>::value>>
void outR(T& arg)
{
	...
}
```

> [[Семантика перемещения - Применение концептов для упрощения выражений enable_if - template|концептов]] (если таковые поддерживаются; #приложение_Д):
```c++
template<typename Т>
requires !std::is_const_v<T>
void outR(T& arg)
{
	...
}
```

### Передача с помощью передаваемой ссылки

Одной из причин использования передачи аргументов по ссылке является возможность [[Семантика перемещения - Прямая передача - template|прямой передачи параметра]]. Но помните, что при использовании передаваемой ссылки, которая определяется как [[значение - template#r-значения|r-ссылка]] параметра шаблона, применяются специальные правила. Рассмотрим следующий код:
```c++
template<typename Т>
void passR(T&& arg)       // arg объявлен как передаваемая ссылка
{
	...
}
```

Передаваемой ссылке можно передать что угодно, и, как всегда при передаче аргумента по ссылке, копия не создается:
```c++
std::string s = "hi";

passR (s);                      // OK: T выводится как std::string&
								// (a также как тип arg)
passR (std::string("hi"));      // OK: Т выводится как std::string,
								// arg - std::string&&
passR (returnstring());         // OK: Т выводится как std::string,
								// arg - std::string&&
passR (std::move(s));           // OK: Т выводится как std::string,
								// arg - std::string&&
passR (arr)                     // OK: Т выводится как int(&)[4]
								// (a также как тип arg)
```

Однако специальные правила вывода типов могут несколько удивить:
```c++
std::string const с = "hi";

passR(c);               // OK: T выводится как std::string const&

passR("hi");            // OK: T выводится как char const(&)[3]
						// (а также как тип arg)
int arr[4];

passR(arr);             // OK: T выводится как int(&)[4]
						// (а также как тип arg)
```

В каждом из этих случаев внутри `passR()` параметр `arg` имеет тип, который знает, передали мы `r-значение` (чтобы использовать семантику перемещения) или константное/неконстантное `l-значение`. Это единственный способ передачи аргумента, который можно использовать для того, чтобы обеспечить различное поведение для каждого из этих трех случаев.

Это создает впечатление, что объявление параметра как передаваемой ссылки - почти идеальное решение. Но будьте осторожны, бесплатных обедов не бывает.

Например, это единственный случай, когда параметр `Т` шаблона может неявно стать ссылочным типом. Как следствие, может возникнуть ошибка при использовании `Т` при объявлении локального объекта без инициализации:
```c++
template<typename Т>
void passR(Т&& arg)     // arg - передаваемая ссылка
{
	Т х;                // Для переданных l-значений х представляет
						// собой ссылку, которая требует инициализатор
	...
}

passR(42);              // OK: Т выводится как int

int i;
passR(i);               // Ошибка: Т выводится как int&, что делает
						// объявление х в passR() некорректным
```

Как поступить в этой ситуации, рассказывается в #разделе_15_6_2.

## Использование std::ref() и std::cref()

Начиная с С++11, можно позволить вызывающему коду решить, должен ли аргумент шаблона функции передаваться по значению или по ссылке. Когда шаблон объявлен как принимающий аргументы по значению, вызывающий код может использовать [[ref#std cref()|std::cref()]] и [[ref#std ref()|std::ref ()]], объявленные в заголовочном файле `<functional>`, для передачи аргумента по ссылке. Например:
```c++
template<typename Т>
void printT(T arg)
{
	...
}

std::string s = "hello";

printT(s);                   // Передача s по значению
printT(std::cref(s));        // Передача s "как будто по ссылке"
```

Однако обратите внимание на то, что [[ref#std cref()|std::cref()]] не изменяет обработку параметра в шаблоне. Вместо этого данная конструкция использует хитрый трюк: он заворачивает переданный аргумент `s` в объект, который действует как ссылка. Фактически она создает объект типа [[reference_wrapper|std::reference_wrapper<>]], ссылающийся на исходный аргумент, и передает этот объект по значению. Эта обертка более или менее поддерживает только одну операцию: неявное преобразование типа обратно в исходный тип, давая при этом исходный объект. Так, всякий раз, когда у вас есть корректный оператор для переданного объекта, вместо последнего можно использовать оболочку. Например:
```c++
#include <functional>             // Для std::cref()
#include <string>
#include <iostream>

void printString(std::string const& s)
{
	std::cout << s << ' \n';
}

template<typename T>
void printT(T arg)
{
	printString(arg);       // Может преобразовывать arg
							// обратно в std::string	
}

int main()
{
	std::string s = " hello";

	printT(s);               // Вывод s, переданного по значению
	printT(std::cref(s));    // Вывод s, переданного "как будто по ссылке"
}
```

Последний вызов передает по значению объект типа **`std::reference_wrapper<string const>`** параметру `arg`, который затем передается далее и преобразуется при этом в базовый тип [[string|std::string]].

Обратите внимание на то, что компилятор должен знать о необходимости неявного преобразования обратно в исходный тип. По этой причине [[ref#std ref()|std::ref()]] и [[ref#std cref()|std::cref()]] обычно хорошо работают только тогда, когда вы передаете объекты с помощью обобщенного кода необобщенным функциям. Например, попытки непосредственно вывести переданный объект обобщенного типа `Т` будут неуспешны, поскольку нет оператора вывода, определенного для [[reference_wrapper|std::reference_wrapper<>]]:
```c++
template<typename Т>
void printV(T arg)
{
	std::cout << arg << '\n';
}

std::string s = "hello";

printV(s);                //OK
printV(std::cref(s));     // Ошибка: для оболочки нет оператора <<
```

Кроме того, следующий код не будет работать, потому что объект оболочки нельзя сравнивать с `char const*` или [[string|std::string]]:
```c++
template<typename T1, typename T2>
bool isless(T1 arg1, T2 arg2)
{
	return arg1 < arg2;
}

std::string s = "hello";

if(isless(std::cref(s), "world"))                // Ошибка
	...
	
if(isless(std::cref(s), std::string("world")))   // Ошибка
	...
```

He поможет также попытка использовать общий тип `Т` для `arg1` и `arg2`:
```c++
template<typename Т>
bool isless(Т arg1, Т arg2)
{
	return arg1 < arg2;
)
```

поскольку в этом случае компилятор получит конфликтующие типы при попытке вывести `Т` для `arg1` и `arg2`.

Таким образом, эффект применения класса [[reference_wrapper|std::reference_wrapper<>]] заключается в возможности использовать ссылку как “первоклассный объект”, который можно копировать и потому передавать по значению в шаблоны функций. Его также можно использовать в классах, например для хранения в контейнерах ссылок на объекты. Но в конечном итоге всегда требуется обратное преобразование к базовому типу.

## Работа со строковыми литералами и массивами

До сих пор мы видели различные результаты для параметров шаблонов при использовании строковых литералов и обычных С-массивов:
* передача по значению низводит данные типы, так что они становятся указателями на тип элемента;
* при любой разновидности передачи по ссылке низведение не выполняется, так что аргументы, ставшие ссылками, ссылаются на массивы.

И то, и другое и хорошо, и плохо. При низведении массива к указателю вы теряете возможность различать обработку указателей на элементы и обработку переданных массивов. С другой стороны, при работе с параметрами, в которые могут быть переданы строковые литералы, отсутствие низведения может стать проблемой, поскольку строковые литералы разного размера в результате оказываются имеющими различные типы. Например:
```c++
template<typename Т>
void foo(T const& arg1, T const& arg2)
{
	...
}

foo("hi", "guy");                          // Ошибка
```

Здесь вызов `foo( "hi", "guy")` не будет компилироваться, поскольку `"hi"` имеет тип `char const [3]`, в то время как `"guy"` имеет тип `char const [4]`; шаблон же требует, чтобы они были одного и того же типа `Т`. Этот код успешно компилируется только тогда, когда строковые литералы в нем имеют одинаковую длину. По этой причине настоятельно рекомендуется при тестировании использовать строковые литералы разной длины.

При объявлении шаблона функции `foo()` с передачей передачи аргументов по значению упомянутый вызов вполне возможен:
```c++
template<typename Т>
void foo(T arg1, Т arg2)
{
	...
}

foo("hi", "guy");                    // Компилируется, но...
```

Но это не значит, что все проблемы исчезли. Все становится даже хуже - проблемы времени компиляции могут стать проблемами времени выполнения. Рассмотрим следующий код, где мы сравниваем переданные аргументы с помощью оператора `==`:
```c++
template<typename Т>
void foo(T arg1, Т arg2)
{
	if (arg1 == arg2)       // Ой: сравнение адресов
	{						// или переданных массивов
		...
	}
}

foo("hi", "guy");          // Компилируется, но. . .
```

Как было сказано, вы должны знать, что следует интерпретировать переданные указатели на символы как строки. Но, вероятно, это необходимо в любом случае, потому что шаблон должен также работать с аргументами, получаемыми из уже низведенных строковых литералов (например, передаваемых из другой функции, куда они были переданы по значению, или присвоенных объекту, объявленному с ключевым словом [[auto|auto]]).

Тем не менее во многих случаях низведение полезно, особенно для проверки того, имеют ли два объекта (оба переданные как аргументы или один переданный как аргумент, а второй — ожидающий аргумента) один и тот же тип или являются конвертируемыми в один и тот же тип. Одним из типичных применений является прямая передача. Но если вы хотите использовать прямую передачу, то нужно объявить параметры как передаваемые ссылки. При этом можно выполнить явное низведение аргументов с использованием свойства типа [[decay|std::decay<>()]] (см. конкретный пример в #разделе_7_6).

Обратите внимание на то, что другие свойства типов иногда также неявно выполняют низведение, как, например, [[common_type|std: :common_type<>]], который [[Шаблоны функций - template#Возвращаемый тип как общий тип|дает общий тип для двух переданных в качестве аргументов типов]] (см. #раздел_Г_5 (раздел 1.3.3)).

### Специальные реализации для строковых литералов и обычных массивов

Возможно, вам придется использовать различные реализации в зависимости от того, передан указатель или массив. Конечно, при этом требуется, чтобы переданный массив не был низведен к указателю.

Чтобы различать эти случаи, необходимо выяснить, не передан ли массив. В принципе, имеется два варианта.

> Можно объявить параметры шаблона так, чтобы они были корректны только для массивов:
```c++
template<typename Т, std::size_t L1, std::size_t L2>
void foo(T(&arg1)[L1], T(&arg2)[L2])
{
	T* pa = arg1; // Низведение arg1
	T* pb = arg2; // Низведение arg2
	
	if (compareArrays(pa, L1, pb, L2))
	{
		...
	}
}
```

Здесь `arg1` и `arg2` должны быть обычными массивами элементов одного и того же типа `Т`, но с разными размерами `L1` и `L2`. Заметим, однако, что может потребоваться [[Шаблоны для массивов и строковых литералов - template|несколько реализаций для поддержки массивов различных видов]].

> Можно использовать свойства типов для выяснения, передан массив (или указатель):
```c++
template<typename Т,
		typename = std::enable_if_t<std::is_array_v<T>>>
void foo(T && arg1, T && arg2)
{
	...
}
```

Благодаря специальной обработке зачастую наилучший способ работы с массивами различными способами заключается в том, чтобы просто использовать различные имена функций. Еще лучше, конечно, чтобы вызывающий шаблон код использовал [[vector|std::vector]] или [[Array|std::array]]. Но, пока строковые литералы будут представлять собой обычные массивы, мы всегда должны учитывать их существование.

## Работа с возвращаемыми значениями

Что касается возвращаемых значений, то здесь вы также можете выбирать между возвратом значений или ссылок. Однако возврат ссылки — потенциальный источник неприятностей, поскольку вы ссылаетесь на нечто, что находится вне вашего контроля. Есть несколько случаев, когда возврат ссылки представляет собой обычную практику.
>
> Возврат элементов контейнеров или строк (например, с помощью `operator[]` или `front()` ).
>
> Предоставление возможности записи члена класса.
> 
> Возврат объектов для цепочек вызовов (операторы `operator<<` и `operator>>` для потоков и `operator=` в общем случае для объектов классов).

Кроме того, распространено предоставление доступа к члену для чтения путем возврата константной ссылки.

Обратите внимание на то, что во всех этих случаях ненадлежащее применение ссылок может вызвать проблемы. Например:
```c++
std::string* s = new std::string("whatever");
auto& c = (*s)[0];
delete s;
std::cout << с;      // Ошибка времени выполнения
```

Здесь мы получаем ссылку на элемент строки, но к тому времени, когда используется эта ссылка, основная строка больше не существует (т.е. имеется висячая ссылка (dangling reference)), так что мы сталкиваемся с неопределенным поведением. Это несколько надуманный пример (опытный программист сразу заметит проблему), но такие вещи могут легко стать менее очевидными. Например:
```c++
auto s = std::make_shared<std::string>("whatever");
auto& c = (*s)[0];
s.reset();
std::cout << с;     // Ошибка времени выполнения
```

Таким образом, мы должны гарантировать, что шаблоны функции возвращают их результат по значению. Однако, как говорилось в данной главе, применение параметра шаблона `Т` не гарантирует, что это не будет ссылкой, потому что `T` иногда может неявно выводиться как ссылка:
```c++
template<typename Т>
Т retR(T&& р)              // р - передаваемая ссылка
{
	return Т{...};         // Ой: возврат по ссылке для l-значений
}
```

Даже когда `Т` представляет собой параметр шаблона, выведенный из вызова с передачей по значению, она может стать ссылочным типом при явном указании, что параметр шаблона является ссылкой:
```c++
template<typename Т>
Т retV(T р)              // Примечание: Т может стать ссылкой
{
	return Т{...};       // Ой: возвращает ссылку, если Т - ссылка
}

int х;
retV<int&>(х);           // retT() инстанцирована для Т как int&
```

Для достижения безопасности возможны два варианта действий:
>
> Использовать свойство типа [[remove_reference|std::remove_reference<>]] (см. #раздел_Г_4) для преобразования `Т` в тип, не являющийся ссылочным:
```c++
template<typename Т>
typename std::remove_reference<T>::type retV(T p)
{
	return Т{...};       // Всегда возврат значения
}
```

> Позволить компилятору [[Шаблоны функций - template#Вывод возвращаемого типа|выводить тип возвращаемого значения]], просто объявляя возвращаемый тип как [[auto|auto]] (начиная с C++14), поскольку при использовании [[auto|auto]] всегда выполняется низведение типа:
```c++
template<typename Т>
auto retV(T р)             // Выведенный компилятором тип,
{                          // возвращаемый по значению
	return Т{...};         // Всегда возврат значения
}
```

# Рекомендуемые объявления параметров шаблона

Как мы узнали в предыдущих разделах, существуют разные способы объявления параметров, которые зависят от параметров шаблона.
>
> **Объявление аргументов как передаваемых по значению.** Этот подход прост, он низводит строковые литералы и обычные массивы до указателей, но не обеспечивает наивысшую производительность для больших объектов. Вызывающий код может по-прежнему выполнить передачу по ссылке с помощью [[ref#std cref()|std::cref()]] и [[ref#std ref()|std::ref()]], но должен быть осторожен и убедиться, что такая передача является допустимой.
>
> **Объявление аргументов как передаваемых по ссылке.** Этот подход часто обеспечивает лучшую производительность для достаточно крупных объектов, особенно при передаче
> 	> существующих объектов (l-значений) l-ссылкам;
> 	> 
> 	> временных объектов ([[значение - template#pr-значения|pr-значений]]) или объектов, помеченных как перемещаемые ([[значение - template#x-значения|х-значений]]) [[значение - template#r-значения|r-ссылкам]];
> 	> 
> 	> обоих видов значений передаваемым ссылкам.
> 	> 
> Поскольку во всех этих случаях над аргументами не выполняется низведение типов, может понадобиться специальная обработка при передаче строковых литералов и других массивов. Для передаваемых ссылок следует также остерегаться неявного вывода ссылочных типов.

==**Общие рекомендации**==

С учетом сказанного для шаблонов функций мы рекомендуем следующее.
1. По умолчанию объявляйте параметры передаваемыми по значению. Это просто и обычно работает даже со строковыми литералами. Для небольших аргументов и для временных или перемещаемых объектов производительность оказывается достаточной. Чтобы избежать дорогостоящих копирований, вызывающий код может иногда использовать [[ref#std ref()|std::ref()]] и [[ref#std cref()|std::cref()]] при передаче существующих крупных объектов ([[значение - template#l-значение|l-значений]]).
2. При наличии важных причин поступайте иначе.
	* Если вам нужны выходные параметры, которые возвращают новые объекты или позволяют вызывающему коду модифицировать аргументы, передавайте аргумент как неконстантную ссылку (если только вы не предпочитаете передать указатель). Однако можно рассмотреть [[По значению или по ссылке - template#Передача по ссылке|запрет случайного принятия константных объектов]].
	* Если шаблон предназначен для передачи аргумента, используйте прямую передачу, т.е. объявляйте параметры как передаваемые ссылки и используйте в соответствующих местах [[forward|std::forward<>()]]. Подумайте о применении [[decay|std::dесау<>]] или [[common_type|std::common_type<>]] для “согласования” различных типов строковых литералов и массивов.
	* Если ключевой характеристикой является производительность и ожидается, что копирование аргументов будет дорогим, используйте константные ссылки. Этот способ, конечно, не применяется, если вам в любом случае нужна локальная копия.
3. Если вы знаете ситуацию более точно, не следуйте этим рекомендациям. Однако ни в коем случае не следует делать интуитивных предположений о производительности. Здесь постоянно ошибаются даже эксперты. Обязательно выполняйте измерения!

==**Не переборщите с обобщенностью**==

Заметим, что на практике шаблоны функций часто не предназначены для произвольных типов аргументов и используют некоторые ограничения. Например, вы можете знать, что будут передаваться только векторы некоторого типа. В этом случае лучше не объявлять такую функцию слишком обобщенно, потому что, как уже говорилось, это может привести к удивительным побочным эффектам. Вместо этого используйте следующее объявление:
```c++
template<typename Т>
void printVector(std::vector<T> const& v)
{
	...
}
```

При таком объявлении параметра `v` в `printVector()` мы можем быть уверены, что передаваемый тип `Т` не может быть ссылкой, поскольку использовать ссылки как типы элементов вектора нельзя. Кроме того, достаточно очевидно, что передача вектора по значению почти всегда дорогостоящая, так как копирующий конструктор [[vector|std::vector<>]] создает копии всех элементов. По этой причине, вероятно, никогда не следует передавать вектор по значению. Если мы объявим параметр `v` просто как имеющий тип `Т`, то принятие решения о выборе между передачей по значению и по ссылке становится менее очевидным.

==**Пример [[make_pair|std::make_pair()]]**==

Хорошим примером, демонстрирующим ловушки при принятии решения о механизме передачи параметров, является [[make_pair|std::make_pair<>()]]. Это обычный шаблон функции из стандартной библиотеки C++ для создания объектов [[pair|std::pair<>]] с использованием вывода типа. Его объявление менялось от версии к версии стандарта C++.

> В первом стандарте C++ (С++98) шаблон [[make_pair|make_pair<>()]] был объявлен в пространстве имен `std` с использованием передачи по ссылке во избежание излишнего копирования:
```c++
template<typename T1, typename Т2>
pair<T1, Т2> make_pair(T1 const& a, T2 const& b)
{
	return pair<T1, T2>(a, b);
}
```

Однако это почти немедленно привело к значительным проблемам при использовании пар строковых литералов или массивов разных размеров.

> В результате, в С++03 определение функции было изменено на вызов по значению:
```c++
template<typename T1, typename Т2>
pair<T1, Т2> make_pair(T1 а, Т2 Ь)
{
	return pair<T1, Т2>(а, b);
}
```

Как можно прочесть в обосновании этого решения, "оказалось, что это гораздо меньшее изменение стандарта, чем два других предложения, и все проблемы эффективности были более чем компенсированы преимуществами данного решения".

> Однако в С++11 функция [[make_pair|make_pair()]] должна поддерживать семантику перемещения, так что ее аргументы должны были стать передаваемыми ссылками. По этой причине определение функции в очередной раз изменено, теперь примерно следующим образом:
```c++
template<typename T1, typename Т2>
constexpr pair<typename decay<T1>::type,
				typename decay<T2>::type>
make_pair(T1&& a, T2&& b)
{
	return pair<typename decay<T1>::type,
				typename decay<T2>::type>(
						forward<T1>(a),
						forward<T2>(b));
}
```

Полная реализация более сложная: для поддержки [[ref#std ref()|std::ref()]] и [[ref#std cref()|std::cref()]] функция также выполняет разворачивание экземпляров [[reference_wrapper|std::reference_wrapper]] в реальные ссылки.
