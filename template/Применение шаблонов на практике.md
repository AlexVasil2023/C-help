
[[#Применение шаблонов на практике|Применение шаблонов на практике]] 9
1. [[#Модель включения|Модель включения]] 9.1
	1. [[#Ошибки компоновщика|Ошибки компоновщика]] 9.1.1
	2. [[#Шаблоны в заголовочных файлах|Шаблоны в заголовочных файлах]] 9.1.2
2. [[#Шаблоны и inline|Шаблоны и inline]] 9.2
3. [[#Предкомпилированные заголовочные файлы|Предкомпилированные заголовочные файлы]] 9.3
4. [[#Расшифровка романов об ошибках|Расшифровка романов об ошибках]] 9.4
5. [[#Некоторые замечания|Некоторые замечания]] 9.5

# Применение шаблонов на практике

Код шаблона немного отличается от обычного кода. В некотором смысле шаблоны лежат где-то между макросами и обычными, нешаблонными объявлениями. Хотя это может быть и чрезмерным упрощением, оно имеет следствия не только для способа написания алгоритмов и структур данных с использованием шаблонов, но и для повседневной логистики выражения и анализа программ с применением шаблонов.

В этой главе мы рассмотрим некоторые практические вопросы без углубления в технические детали, лежащие в их основе. Многие из этих деталей рассматриваются в [[Инстанцирование в шаблонах|“Инстанцирование”]]. Чтобы упростить обсуждение, мы предполагаем, что наши системы компиляции C++ состоят из традиционных компиляторов и компоновщиков (системы, не попадающие в эту категорию, крайне редки).

# Модель включения

Существует несколько способов организации исходных текстов шаблонов. В этом разделе представлен наиболее популярный подход: модель включения.

## Ошибки компоновщика

Большинство программистов на С и C++ организуют свой нешаблонный код в основном следующим образом.
>
> Классы и прочие объявления типов полностью размещаются в заголовочных файлах. Обычно эти файлы имеют расширение `.hpp` (или `.Н`, `.h`, `.hh`, `.hxx`).
> 
> Что касается глобальных (невстраиваемых) переменных и (невстраиваемых) функций, в заголовочный файл помещаются только объявления, а определения размещаются в файлах, компилируемых как отдельные единицы трансляции. Такие СРР-файлы обычно имеют расширение `.срр` ( или `.С`, `.с`, `.сс`, `.схх`).

Этот способ вполне работоспособен: он делает определение необходимого типа легко доступным во всей программе и позволяет избежать ошибок компоновки, связанных с дублированием определений переменных и функций.

С учетом данных соглашений распространенная ошибка, на которую часто жалуются начинающие программисты, может быть проиллюстрирована следующей (неверной) небольшой программой. Как и для “обычного кода”, шаблон объявлен в заголовочном файле:
```c++
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

// Объявление шаблона
template<typename T>
void printTypeof(T const&);

#endif // MYFIRST_HPP
```

`printTypeof()` представляет собой объявление простой вспомогательной функции, которая выводит некоторую информацию о типе. Реализация этой функции помещается в СРР-файл:
```c++
#include <iostream>
#include <typeinfo>
#include "myfirst.hpp"

// Реализация/определение шаблона
template<typename T>
void printTypeof(T const& x)
{
	std::cout << typeid(x).name() << '\n';
}
```

В этом примере использован оператор [[typeid|typeid]], позволяющий вывести строку, описывающую тип переданного ему выражения. Он возвращает 1-значение статического типа [[type_info|std::type_info]], который предоставляет функцию-член `name()`, возвращающую строковое представление типа. На самом деле стандарт C++ не требует от `name()` возврата чего-то значимого, но в хороших реализациях C++ вы должны получить строку, которая представляет собой хорошее описание типа выражения, переданного `typeid`.

Наконец, мы используем шаблон в другом СРР-файле, в который объявление шаблона включено с использованием директивы препроцессора `#include`:
```c++
#include "myfirst.hpp"

// Использование шаблона
int main()
{
	double ice = 3.0;
	printTypeof(ice);        // Вызов шаблона функции для double
)
```

Компилятор C++, вероятно, примет эту программу без каких-либо проблем, но компоновщик, скорее всего, сообщит об ошибке отсутствия определения функции `printTypeof()`.

Причиной этой ошибки является то, что определение шаблона функции `printTypeof()` не инстанцировано. Чтобы шаблон был инстанцирован, компилятор должен знать, какие определения должны быть инстанцированы и для каких именно аргументов шаблона. К сожалению, в предыдущем примере эти две части информации находятся в файлах, компилируемых по отдельности. Таким образом, когда наш компилятор видит вызов `printTypeof()`, но не имеет определения шаблона, чтобы инстанцировать его для `double`, он просто предполагает, что такое определение представлено в другом месте, и создает для этого определения соответствующую ссылку (разрешаемую компоновщиком). С другой стороны, когда компилятор обрабатывает файл `myfirst.срр`, он не имеет никаких указаний о том, что он должен инстанцировать определение содержащегося в нем шаблона для некоторых конкретных аргументов.

## Шаблоны в заголовочных файлах

Обычное решение описанной проблемы заключается в использовании того же подхода, что и для макросов или встраиваемых функций: мы включаем определения шаблона в заголовочный файл, объявляющий этот шаблон.

Таким образом, вместо предоставления файла `myfirst.срр`, мы переписываем `myfirst.hpp` так, чтобы он содержал как объявление, так и определение шаблона.
```c++
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

#include <iostream>
#include <typeinfo>

// Объявление шаблона
template<typename T>
void printTypeof(T const&);

// Реализация/определение шаблона
template<typename T>
void printTypeof(T const& x)
{
	std::cout << typeid(x).name() << '\n';
}
#endif // MYFIRST_HPP
```

Этот способ организации шаблонов называется моделью включения (`inclusion model`). При ее использовании наша программа теперь корректно компилируется, компонуется и выполняется.

Следует сделать несколько замечаний. Наиболее важным является то, что этот подход значительно увеличивает стоимость включения заголовочного файла `myfirst.hpp`. В нашем примере стоимость является не результатом размера определения самого шаблона, а результатом того факта, что мы должны также включать заголовочные файлы, используемые в определении нашего шаблона — в данном случае `<iostream>` и `<typeinfo>`. Вы можете обнаружить, что это приводит к включению десятков тысяч строк кода, потому что такие заголовочные файлы, как `<iostream>`, содержат множество собственных определений шаблонов.

На практике это становится реальной проблемой, потому что значительно увеличивает время, необходимое компилятору для компиляции больших программ. Поэтому мы рассмотрим некоторые возможные пути решения этой проблемы, включая [[Применение шаблонов на практике#Предкомпилированные заголовочные файлы|предкомпилированные заголовочные файлы]] и использование [[Инстанцирование в шаблонах#Явное инстанцирование|явного инстанцирования шаблонов]].

Несмотря на рассматриваемую проблему времени построения, мы рекомендуем по возможности использовать модель включения для организации ваших шаблонов, пока не будет доступен более совершенный механизм. На момент написания этой книги в 2017 году такой механизм находится в работе: это [[Дальнейшее развитие - template#Модули|модули]]. Они представляют собой механизм языка, который позволяет программисту более логично организовывать код — так, чтобы компилятор мог отдельно компилировать все объявления, а затем эффективно и выборочно импортировать обработанные объявления всякий раз, когда они необходимы.

Еще одно (более тонкое) замечание о модели включения заключается в том, что невстраиваемые шаблоны функций отличаются от встраиваемых функций и макросов важным моментом: они не встраиваются в точке вызова. Вместо этого при их создании генерируется новая копия функции. Поскольку это автоматический процесс, компилятор может в конечном итоге создать две копии функции в двух разных файлах, а некоторые компоновщики могут сообщать об ошибках, встречая два различных определения одной и той же функции. Теоретически это не должно быть нашей проблемой: это проблема для системы компиляции C++. На практике все хорошо работает большую часть времени, и нам не приходится сталкиваться с этой проблемой. Однако для больших проектов, которые создают свои собственные библиотеки кода, эти проблемы иногда возникают. Обсуждение схем инстанцирования в [[Инстанцирование в шаблонах|“Инстанцирование”]], и тщательное изучение документации, поставляемой с компилятором C++, должно помочь решить эти проблемы.

Наконец, мы должны указать на то, что вопросы, относящиеся в нашем примере к шаблонам обычных функций, применимы и к функциям-членам и статическим членам-данным шаблонов классов, а также к шаблонам функций-членов.

# Шаблоны и inline

[[inline#Шаблоны и inline| см. Шаблоны и inline]]

# Предкомпилированные заголовочные файлы

Даже без шаблонов заголовочные файлы C++ могут стать очень большими и требовать много времени для обработки при компиляции. Шаблоны вносят свой вклад в эту тенденцию, и возмущения программистов заставили поставщиков компиляторов реализовать схему, обычно известную как предкомпилированные заголовочные файлы (precompiled headers — РСН). Эта схема работает вне области применения стандарта и основана на специфике конкретного производителя. Подробности о том, как создавать и использовать файлы предкомпилированных заголовочных файлов, вы найдете в документации по соответствующей системе компиляции C++, а здесь вы получите только некоторое общее представление о том, как работает этот механизм.

Когда компилятор транслирует файл, он начинает с самого начала файла и читает его до конца. По мере обработки каждого токена в файле (которые могут находиться во включаемых с помощью директивы `#include` файлах) компилятор изменяет свое внутреннее состояние, включая выполнение таких действий, как добавление записей в таблицу символов, в которой позже может выполняться поиск. При этом компилятор может также генерировать код в объектных файлах.

Схема предкомпилированных заголовочных файлов опирается на тот факт, что код может быть организован таким образом, что многие файлы начинаются с одних и тех же строк кода. Давайте предположим, что каждый компилируемый файл начинается с одних и тех же `N` строк кода. Мы могли бы скомпилировать эти `N` строк и сохранить текущее состояние компилятора в предкомпилированном заголовочном файле. Затем для каждого файла в нашей программе можно просто загрузить сохраненное состояние и начать компиляцию с `N+1`-й строки. Здесь следует заметить, что загрузка сохраненного состояния является операцией, которая может быть на порядки быстрее, чем реальная компиляция первых `N` строк. Однако при первом выполнении сохранение состояния обычно дороже, чем простая компиляция `N` строк. Увеличение стоимости колеблется примерно от 20 до 200 процентов.

Ключом к эффективному использованию предкомпилированных заголовочных файлов является обеспечение как можно большего количества одинаковых строк кода в начале каждого файла. На практике это означает, что файлы должны начинаться с одних и тех же директив `#include` в одном и том же порядке, которые (как упоминалось ранее) потребляют значительную часть времени построения программы. Следовательно, может оказаться очень выгодным обратить внимание на порядок, в котором включаются заголовочные файлы. Например, следующие два файла:
```c++
#include <iostream>
#include <vector>
#include <list>

...
```

и
```c++
#include <list>
#include <vector>

...
```

мешают использованию предкомпилированных заголовочных файлов, потому что у них нет общего начального состояния.

Некоторые программисты считают, что лучше включить в файл некоторые дополнительные ненужные заголовочные файлы, но обеспечить возможность ускорить трансляцию за счет использования предкомпилированного заголовочного файла. Такое решение может существенно облегчить управление стратегией включения. Например, обычно относительно просто создать заголовочный файл с именем `std.hpp`, который включает в себя все стандартные заголовки:
```c++
#include <iostream>
#include <string>
#include <vector>
#include <deque>
#include <list>

...
```

Затем этот файл может быть предкомпилирован, и каждый файл программы, использующий стандартную библиотеку, просто начинается следующим образом:
```c++
#include "std.hpp"

...
```

Обычно это требует некоторого времени для предкомпиляции, но в системе с достаточным объемом памяти схема с предкомпилированным заголовочным файлом позволяет работать значительно быстрее, чем требуется почти любому стандартному заголовочному файлу без предварительной компиляции. Стандартные заголовочные файлы особенно удобно использовать таким образом, потому что они редко изменяются, а следовательно, предкомпилированный заголовочный файл для файла `std.hpp` может быть построен один раз. В противном случае предкомпилированные заголовочные файлы обычно являются частью конфигурации зависимостей проекта (например, обновляются по мере необходимости популярной программой [[CMake|make]] или соответствующим инструментарием интегрированной среды разработки (IDE)).

Одним из привлекательных подходов к управлению предкомпилированными заголовочными файлами является создание слоев предкомпилированных заголовочных файлов, которые образуются из наиболее широко используемых и стабильных заголовочных файлов (как, например, наш заголовочный файл `std.hpp`), для которых не ожидается внесение изменений, а потому имеет смысл их предварительная компиляция. Однако, если заголовочные файлы находятся в постоянном развитии, их предкомпиляция может потребовать больше времени, чем даст экономия при повторном их использовании. Ключевой концепцией этого подхода является то, что предкомпилированные заголовочные файлы более стабильного слоя могут быть повторно использованы для улучшения времени компиляции менее стабильных заголовочных файлов. Предположим, например, что в дополнение к нашему заголовочному файлу `std.hpp` (который мы предварительно скомпилировали), мы также определили заголовочный файл `core.hpp`, который включает дополнительные возможности, специфичные для нашего проекта, но тем не менее достигшие определенного уровня стабильности:
```c++
#include "std.hpp"
#include "core_data.hpp"
#include "core_algos.hpp"

...
```

Поскольку этот файл начинается с `#include "std.hpp"`, компилятор может загрузить соответствующий предкомпилированный заголовок и продолжить работу со следующими строками без перекомпиляции всех стандартных заголовков. Когда файл будет полностью обработан, может быть создан новый предкомпилированный заголовочный файл. Затем приложения могут использовать `#include "core.hpp"` для обеспечения быстрого доступа к большому количеству функциональности, потому что компилятор может загрузить последний предкомпилированный заголовочный файл.

# Расшифровка романов об ошибках

Обычные ошибки компиляции, как правило, довольно кратки и говорят по существу. Например, когда компилятор говорит, что *`"класс X не имеет члена 'fun'"`* обычно не слишком трудно понять, что за неприятность случилась в нашем коде (например, мы могли ошибиться и набрать `fun` вместо `run`). Но шаблоны — совсем другое дело. Давайте рассмотрим несколько примеров.

==**Простое несоответствие типов**==

Рассмотрим следующий относительно простой пример с использованием стандартной библиотеки C++:
```c++
#include <string>
#include <map>
#include <algorithm>

int main()
{
	std::map<std::string, double> coll;
	...
	
	// Поиск первой непустой строки в coll:
	auto pos = std::find_if(coll.begin(), coll.end(),
							[](std::string const & s)
	{
		return s != "";
	});
}
```

В нем содержится небольшая ошибка: в лямбда-выражении, используемом для поиска первой совпадающей строки в коллекции, мы выполняем сравнение с заданной строкой. Однако элементами в отображении являются пары ключ/значение, так что здесь ожидается тип `std::pair<std::string const, double>`.

Одна из версий популярного компилятора GNU C++ сообщает об ошибке следующим образом:
```c++
1 In file included from /cygdrive/p/gcc/gcc61-include/bits/stl_algobase.h:71:0,

2 from /cygdrive/p/gcc/gcc61-include/bits/char_traits.h:39,

3 from /cygdrive/p/gcc/gcc61-include/string:40,

4 from errornovell.срр:1:

5 /cygdrive/p/gcc/gcc61-include/bits/predefined_ops.h: In instantiation of 'bool __ gnu_cxx::__ ops::_Iter_pred<_Predicate>::operator()(_Iterator) [with _Iterator = std::_Rb_tree_iterator<std::pair<const std::__ cxxll::basic_ string<char>, double> >; _Predicate = main() ::<lambda(const string&)>]':

6 /cygdrive/p/gcc/gcc61-include/bits/stl_algo .h:104:42: required from '_lnputlterator std::__ find_if(_lnputlterator, _lnputlterator, _Predicate, std::input_iterator_tag) [with _lnputlterator = std::_Rb_tree_iterator<std::pair<const std::__ cxxll::basic_string<char>, double> >; —Predicate = __ gnu_cxx::__ ops::_Iter_pred<main()::-clambda (const strings)> >]' 

7 /cygdrive/р/gcc/gcc61-include/bits/stl_algo.h:161:23: required from '_Iterator std::__ find_if(—Iterator, _Iterator, —Predicate) [with _Iterator = std::_Rb_tree_iterator<std::pair<const std::__ cxxll::basic_string<char>, double> >; -Predicate = gnu_cxx::__ ops::_Iter_pred<main()::clambda(const strings)> >] '


8 /cygdrive/p/gcc/gcc61-include/bits/stl_algo.h:3824:28: required from '_IIter std::find_if(_IIter, _IIter, —Predicate) [with -liter = std::_Rb_tree_iterator<std::pair<const std::__ cxxll::basiC—string<char>, double> >; —Predicate = main()::clambda(const strings)>]'

9 errornovell.cpp:13:29: required from here

10 /cygdrive/p/gcc/gcc61-include/bits/predefined_ops.h:234:11: error: no match for call to '(main()::clambda(const strings)>) (std::pair<const std::__ cxxll::basic_stringcchar>, double>S)' 

11 { return bool(_M—pred(*__ it)); }

12

13 /cygdrive/p/gcc/gcc61-include/bits/predefined_ops.h:234:11: note: candidate: bool (*)(const strings) (aka bool (*)(const std::
cxxll::basic_stringcchar>&)} cconversion>

14 /cygdrive/p/gcc/gcc61-include/bits/predefined_ops.h:234:11: note: candidate expects 2 arguments, 2 provided 

15 errornovell.cpp:11:52: note: candidate: main()::Clambda(const strings)>
16 [] (std::string constS s) {
17

18 errornovell.cpp:ll:52: note: no known conversion for argument 1 from 'std::pairCconst std::__ cxxll::basic_stringcchar>, double>' to 'const strings {aka const std::__ cxxll:: basic_stringcchar>s)'
```

Такое сообщение больше напоминает неудачный роман, чем диагностику. Его размеры и непонятность подавляют начинающих пользователей шаблонов, отталкивая их от этой возможности языка программирования. Однако при некоторой практике подобные сообщения становится воспринимаемыми, и ошибки находятся легко — по крайней мере, относительно легко.

Первая часть этого сообщения об ошибке говорит, что ошибка произошла в экземпляре шаблона функции глубоко внутри заголовочного файла `predefined_ops.h`, включаемого в `errornovell.срр` через различные другие заголовочные файлы. Здесь и в следующих строках компилятор сообщает, что именно было инстанцировано и с какими аргументами. В данном случае все началось с инструкции, заканчивающейся в строке `13` файла `errornovell.срр`, которая представляет собой следующее:
```c++
auto pos = std::find_if(coll.begin(), coll.end(),
						[](std::string const& s)
{
	return s != "";
});
```

Это приводит к инстанцированию шаблона [[find#std find_if|find_if]] в строке 115 заголовочного файла `stl_algo.h`, где код
```c++
_IIter std::find_if(_IIter, _IIter, _Predicate)
```

инстанцируется с
```c++
_IIter = std::_Rb_tree_iterator<std::pair<const
				std::__ cxx11::basic_string<char>, double>>
_Predicate = main()::<lambda(const string&)>
```

Компилятор сообщает всю эту цепочку инстанцирований, что позволяет нам определить цепь событий, которые привели к данному инстанцированию, вызвавшему ошибку. Зачастую программист просто не ожидает такой длинной цепочки инстанцирований.

Однако в нашем примере мы готовы поверить, что все эти виды шаблонов должны быть созданы, и нас просто интересует, почему же он не работает. Эта информация находится в последней части сообщения. Часть, в которой говорится “no match for call”, подразумевает, что вызов функции не может быть разрешен, потому что типы аргументов и типы параметров не совпадают. В ней указано, что именно вызывается
```c++
(main()::<lambda(const string&)>)(
	std::pair<const std::__ cxx11::basic_string<char>,
	double>&)
```

и код, который приводит к этому вызову:
```c++
{ return bool(_M_pred(*__ it)); }
```

Кроме того, сразу после этого строка, содержащая текст `“note: candidate: ”`, поясняет, что единственный тип-кандидат ожидает `const strings`, что этот кандидат определен в строке `11` файла `errornovell.срр` как лямбда-выражение `[] (std::string const & s)`, и почему этот возможный кандидат не годится:
```c++
no known conversion for argument 1
from 'std::pair<const std::__ cxx11::basic_string<char>, double>' 
to 'const string& {aka const std::__ cxx11::basic_string<char>&}'
```

описывая имеющуюся у нас проблему невозможности преобразования типов один в другой.

Несомненно, что сообщение об ошибке могло бы быть получше. Реальную проблему стоило бы выводить до истории инстанцирований, а вместо того чтобы использовать для экземпляра полное расширенное имя шаблона, как, например, `std::cxx11::basic_string<char>`, было бы достаточно использовать только [[string|std::string]]. Однако также верно и то, что вся эта диагностическая информация в ряде ситуаций может быть очень полезной. Поэтому не удивительно, что другие компиляторы в основном предоставляют аналогичную информацию. Так, вывод Visual C++ выглядит примерно следующим образом (показан вывод русской локализации Visual C++ 2015):
```c++
1 C:\Program Files (х8б)\Microsoft Visual Studio 14.0\VC\INCLUDE\algorithm(87): error C2664: "bool main::<lambda_8df7a0afc6bll83ce0c8e081dl832054>::operator (((const std::string S) const":невозможно преобразовать аргумент 1 из "std::pair<const _Kty, _Ty>" в "const std::string S"

2       with
3       [
4            _Kty=std::string,
5            _Ty=double
6       ]

7 C:\Program Files (х86)\Microsoft Visual Studio 14.O\VC\INCLUDE\algorithm(87): note: Причина: невозможно преобразовать "std::pair<const _Kty,_Ty>" в "const std::string"

8       with
9       [
10           _Kty=std::string,
11           _Ty=double
12      ]

13 C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\INCLUDE\algorithm(87): note: Для выполнения данного преобразования нет доступного оператора преобразования, определенного пользователем, или вызов оператора невозможен

14 C:\Program Files (х86)\Microsoft Visual Studio 14.0\VC\INCLUDE\algorithm(98): note: см. ссылку на создание экземпляров функции шаблон при компиляции "_lnlt std::_Find_if_unchecked<std::_Tree_unchecked_iterator<_Mytree>,_Pr>(_lnlt,_lnlt,_Pr &)"

15      with
16      [
17          _InXt=std::_Tree_unchecked_iterator<std::
			_Tree_val<std::_Tree_simple_types<std::pair<
			const std::string, double>>>>,

18          _Mytree=std::_Tree_val<std::_Tree_simple_types<
					std::pair<const std::string, double>>>,

19          _Pr=main::<lambda_8df7a0afc6bll83ce0c8e081dl832054>
20      ]

21 errornovellll.cpp (14) : note: см. ссылку на создание экземпляров функции шаблон при компиляции "_lnlt std::find_if<std::_Tree_iterator<std::_Tree_val<std::_Tree__simple_types<std::pair<const _Kty,_Ty>>>>,main::<lambda_8df7a0afc6bll83ce0c8e081dl832054>>(_InIt,_InIt,_Pr) "

22      with
23      [
24          _Inlt=std::_Tree_iterator<std::_Tree_val<
					std::_Tree_simple_types<std::pair<const
					std::string, double>>>>,
25          _Kty=std::string,
26          _Ty=double,
27          _Pr=main::<lambda_8df7a0afc6bll83ce0c8e081dl832054>
28      ]
```

Здесь вновь предоставлена цепочка инстанцирования с информацией, которая говорит нам о том, что именно было инстанцировано, с какими аргументами и в каком месте кода, и мы видим, что
```c++
невозможно преобразовать "std::pair<const _Kty, Ту>"
						в "const std::string"
with
[
	_Kty=std::string,
	_Ty=double
]
```

**==Отсутствие [[const|const]] у некоторых компиляторов==**

К сожалению, иногда случается, что обобщенный код представляет собой проблему только для некоторых компиляторов. Рассмотрим следующий пример:
```c++
#include <string>
#include <unordered_set>

class Customer
{
	private:
		std::string name;

	public:
		Customer(std::string const& n)
			: name(n)
		{   }
		
		std::string getName() const
		{
			return name;
		}
};

int main()
{
	// Пользовательская хеш-функция:
	struct MyCustomerHash
	{
		// Примечание: отсутствие const является ошибкой только
		// для g++ и clang:
		std::size__t operator()(Customer const& c)
		{
			return std::hash<std::string>()(c.getName());
		}
	};

	// Используем пользовательскую хеш-функцию для хеш-таблицы
	//с элементами типа Customer:
	std::unordered__set<Customer, MyCustomerHash> coll;

	...
}
```

При использовании Visual Studio 2013 или 2015 этот код компилируется, как и ожидалось. Однако в случае g++ или clang код приводит к сообщениям об ошибке. Например, в g++ 6.1 первое сообщение об ошибке имеет следующий вид:
```c++
1 In file included from /cygdrive/p/gcc/gcc61-include/bits/hashtable.h:35:0,

2 from /cygdrive/p/gcc/gcc61-include/unordered_set:4 7,

3 from errornovel2.cpp:2:

4 /cygdrive/p/gcc/gcc61-include/bits/hashtable_policy.h: In instantiation of 'struct std::__ detail::__ is_noexcept_hash<Customer, main()::MyCustomerHash>':

5 /cygdrive/p/gcc/gcc61-include/type_traits:143:12: required from 'struct std::__and_<std::__ is_fast_hash<main()::MyCustomerHash>, std::detail::__is_noexcept_hash<Customer, main()::MyCustomerHash> >'

6 /cygdrive/p/gcc/gcc61-include/type_traits:154:38: required from 'struct std::__ not_<std::__ and_<std::__ is_fast_hash<main()::MyCustomerHash>, std::__ detail::__ is_noexcept_hash<Customer, main()::MyCustomerHash> > >'

7 /cygdrive/p/gcc/gcc61-include/bits/unordered_set.h: 95: 63: required from 'class std::unordered_set<<Customer, main()::MyCustomerHash>'

8 errornovel2.cpp:28:47: required from here

9 /cygdrive/p/gcc/gcc61-include/bits/hashtable_policy.h:85:34: error: no match for call to '(const main()::MyCustomerHash)(const Customer&)'

10 noexcept (declva<const _Hash&> () (declva<const _Key&>()))>

12 errornovel2.cpp:22:17: note: candidate: std::size_t main()::MyCustomerHash::operator()(const Customer&)
<near match>

13 std::size_t operator() (const Customer& c) {

14

15 errornovel2.cpp:22:17: note: passing 'const main()::MyCustomerHash*' as 'this' argument discards qualifiers
```

за которым следуют более 20 других сообщений об ошибке:
```c++
16 In file included from /cygdrive/p/gcc/gcc61-include/bits/move.h:57:0,
from /cygdrive/p/gcc/gcc61-include/bits/

17 stl_pair,h:59, from /cygdrive/p/gcc/gcc61-include/bits/

18 stl_algobase.h:64, from /cygdrive/p/gcc/gcc61-include/bits/

19 char_traits.h:39, 

20 from /cygdrive/p/gcc/gcc61-include/string:40,

21 from errornovel2.cpp:1:

22 /cygdrive/p/gcc/gcc61-include/type_traits: In instantiation of 'struct std::__not_<std::__and_<std::__is_fast_hash<main()::MyCustomerHash>, std::__detail::__ is_noexcept_hash<Customer, main()::MyCustomerHash>>>':

23 /cygdrive/p/gcc/gcc61-include/bits/unordered_set.h:95:63: required from 'class std::unordered_set<Customer, main()::MyCustomerHash>'

24 errornovel2.cpp:28:47: required from here

25 /cygdrive/p/gcc/gcc61-include/type_traits:154:38: error: 'value' is not a member of 'std::__and_<std::__is_fast_hash<main()::MyCustomerHash>, std::__ detail::__ is_noexcept_hash<Customer,main()::MyCustomerHash>>'

26     : public integral_constant<bool, !__Pp::value>

27

28 In file included from /cygdrive/p/gcc/gcc61-include/unordered_set:48:0,

29 from errornovel2.cpp:2:

30 /cygdrive/p/gcc/gcc61-include/bits/unordered_set.h: Ininstantiation of 'class std::unordered_set<Customer, main()::MyCustomerHash>':

31 errornovel2.cpp:28:47: required from here

32 /cygdrive/p/gcc/gcc61-include/bits/unordered_set.h: 95:63: error:'value' is not a member of 'std::__ not_<std::__ and_<std::__is_fast_hash<main()::MyCustomerHash>, std::__ detail::__is_noexcept_hash<Customer, main()::MyCustomerHash>>>'

33 typedef __user_hashtable<_Value,_Hash,_Pred,__Alloc> _Hashtable;

34  

35 /cygdrive/р/gcc/gcc61-include/bits/unordered_set.h:102:45: error: 'value' is not a member of 'std::__not_<std::__and_<std::__is_fast_hash<main()::MyCustomerHash>, std::__ detail::__is_noexcept_hash<Customer, main()::MyCustomerHash>>>'

36 typedef typename _Hashtable::key_type key_type;

37

...
```

Это сообщение об ошибке так же трудно прочесть, как и предыдущие (даже просто найти начало и конец каждого сообщения — работа непростая). Проблема заключается в том, что глубоко в заголовочном файле `hashtable_policy.h` в инстанцировании [[set#std unordered_set<>|std::unordered_set<>]], инициированном
```c++
std::unordered_set<Customer,MyCustomerHash> coll;
```

не находится соответствие для вызова
```c++
const main()::MyCustomerHash (const Customer&)
```

в инстанцировании
```c++
noexcept (declval<const _Hash&> ()(declval<const _Key&>()))>
```

(`declval<const _Hash&>()` представляет собой выражение типа `main()::MyCustomerHash`). Возможный “близкий” кандидат представляет собой
```c++
std::size_t main()::MyCustomerHash::operator()(const Customer&)
```

который объявлен как
```c++
std::size_t operator() (const Customer& c) {
```

и последнее примечание информирует о проблеме:
```c++
passing 'const main()::MyCustomerHash*' as 'this' argument discards qualifiers
```

Вы можете понять, в чем суть проблемы? Данная реализация шаблона класса [[set#std unordered_set<>|std::unordered_set]] требует, чтобы оператор вызова объекта хеша был константной функцией-членом (см. также [[Обобщенные библиотеки - template#Поддержка функциональных объектов|Поддержка функциональных объектов]]). И когда это не так, где-то глубоко “в ливере” алгоритма возникает ошибка.

Все прочие сообщения об ошибках просто вытекают из первого и исчезают, если добавить квалификатор [[const|const]] к оператору хеш-функции:
```c++
std::size_t operator() (const Customer& c) const {
	...
}
```

Подсказка clang 3.9 немного лучше, так как в конце первого сообщения об ошибке ясно говорит, что `operator()` функтора хеширования не помечен как [[const|const]]:
```c++
...
errornovel2.срр:28:47: note: in instantiation of template class 'std::unordered_set<Customer, MyCustomerHash, std::equal_to<Customer>, std::allocator<Customer> >' requested here std::unordered_set<Customer, MyCustomerHash> coll;

errornovel2.cpp:22:17: note: candidate function not viable: 'this' argument has type 'const MyCustomerHash', but method is not marked const

std::size_t operator() (const Customer& c) {
```

Обратите внимание на то, что clang упоминает здесь параметры шаблона по умолчанию, такие как `std::allocator<Customer>`, в то время как gcc их опускает.

Как можно видеть, часто полезно иметь несколько компиляторов для тестирования кода. Это не только поможет написать более переносимый код, но и, когда один компилятор выдаст особенно непостижимое сообщение об ошибке, другой компилятор может помочь вам его понять.

# Некоторые замечания

Организация исходного кода в заголовочных файлах и CPP-файлах является практическим следствием различных воплощений правила одного определения (one-definition rule — ODR). Подробное обсуждение этого правила содержится в [[Правило одного определения#Правило одного определения|“Правило одного определения”]].

Модель включения является прагматичным ответом, во многом продиктованным существующей практикой реализации компиляторов C++. Однако первая реализация C++ была иной: подразумевалось включение определений шаблона, что создало определенную иллюзию разделения (см. подробности этой модели в [[Инстанцирование в шаблонах|“Инстанцирование”]]).

Первый стандарт C++ предоставил явную поддержку разделения модели разделения компиляции шаблонов посредством экспортированных шаблонов. Модель разделения позволяла маркировать объявления шаблонов как `export`, чтобы объявлять их в заголовочных файлах, в то время как соответствующие определения помещались в CPP-файлы, так же, как объявления и определения нешаблонного кода. В отличие от модели включения эта модель была теоретической, не основанной на какой-либо существующей реализации, и сама по себе оказалась гораздо более сложной, чем предполагал Комитет по стандартизации C++. Потребовалось более пяти лет, чтобы увидеть ее первую реализацию опубликованной (в мае 2002 года), и с тех пор никаких других реализаций не появлялось. Чтобы стандарт C++ лучше соответствовал существующей практике, Комитет по стандартизации C++ удалил из C++11 экспортируемые шаблоны. 

Иногда бывает заманчиво представить способы расширения концепции предкомпилированных заголовочных файлов, чтобы для одиночной компиляции можно было загрузить более одного заголовка. В принципе это обеспечило бы более тонкий, мелкозернистый подход к предварительной компиляции. Главным препятствием здесь является препроцессор: макросы в одном заголовочном файле могут полностью изменить смысл последующих заголовочных файлов. Однако после того, как файл будет предкомпилирован, а макрообработка завершена, задача изменения предкомпилированного заголовочного файла с учетом эффектов, вызванных другими заголовками, окажется слишком сложной с практической точки зрения. Ожидается, что для решения этой проблемы в C++ в не слишком отдаленном будущем будет добавлена новая возможность языка, известная как [[Дальнейшее развитие - template#Модули|модули]] (макроопределения не смогут попасть в интерфейсы модулей).
