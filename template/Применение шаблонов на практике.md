
[[#Применение шаблонов на практике|Применение шаблонов на практике]] 9
1. [[#Модель включения|Модель включения]] 9.1
	1. [[#Ошибки компоновщика|Ошибки компоновщика]] 9.1.1
	2. [[#Шаблоны в заголовочных файлах|Шаблоны в заголовочных файлах]] 9.1.2
2. [[#Шаблоны и inline|Шаблоны и inline]] 9.2



# Применение шаблонов на практике

Код шаблона немного отличается от обычного кода. В некотором смысле шаблоны лежат где-то между макросами и обычными, нешаблонными объявлениями. Хотя это может быть и чрезмерным упрощением, оно имеет следствия не только для способа написания алгоритмов и структур данных с использованием шаблонов, но и для повседневной логистики выражения и анализа программ с применением шаблонов.

В этой главе мы рассмотрим некоторые практические вопросы без углубления в технические детали, лежащие в их основе. Многие из этих деталей рассматриваются в #главе_14, “Инстанцирование”. Чтобы упростить обсуждение, мы предполагаем, что наши системы компиляции C++ состоят из традиционных компиляторов и компоновщиков (системы, не попадающие в эту категорию, крайне редки).

# Модель включения

Существует несколько способов организации исходных текстов шаблонов. В этом разделе представлен наиболее популярный подход: модель включения.

## Ошибки компоновщика

Большинство программистов на С и C++ организуют свой нешаблонный код в основном следующим образом.
>
> Классы и прочие объявления типов полностью размещаются в заголовочных файлах. Обычно эти файлы имеют расширение `.hpp` (или `.Н`, `.h`, `.hh`, `.hxx`).
> 
> Что касается глобальных (невстраиваемых) переменных и (невстраиваемых) функций, в заголовочный файл помещаются только объявления, а определения размещаются в файлах, компилируемых как отдельные единицы трансляции. Такие СРР-файлы обычно имеют расширение `.срр` ( или `.С`, `.с`, `.сс`, `.схх`).

Этот способ вполне работоспособен: он делает определение необходимого типа легко доступным во всей программе и позволяет избежать ошибок компоновки, связанных с дублированием определений переменных и функций.

С учетом данных соглашений распространенная ошибка, на которую часто жалуются начинающие программисты, может быть проиллюстрирована следующей (неверной) небольшой программой. Как и для “обычного кода”, шаблон объявлен в заголовочном файле:
```c++
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

// Объявление шаблона
template<typename T>
void printTypeof(T const&);

#endif // MYFIRST_HPP
```

`printTypeof()` представляет собой объявление простой вспомогательной функции, которая выводит некоторую информацию о типе. Реализация этой функции помещается в СРР-файл:
```c++
#include <iostream>
#include <typeinfo>
#include "myfirst.hpp"

// Реализация/определение шаблона
template<typename T>
void printTypeof(T const& x)
{
	std::cout << typeid(x).name() << '\n';
}
```

В этом примере использован оператор [[typeid|typeid]], позволяющий вывести строку, описывающую тип переданного ему выражения. Он возвращает 1-значение статического типа [[type_info|std::type_info]], который предоставляет функцию-член `name()`, возвращающую строковое представление типа. На самом деле стандарт C++ не требует от `name()` возврата чего-то значимого, но в хороших реализациях C++ вы должны получить строку, которая представляет собой хорошее описание типа выражения, переданного `typeid`.

Наконец, мы используем шаблон в другом СРР-файле, в который объявление шаблона включено с использованием директивы препроцессора `#include`:
```c++
#include "myfirst.hpp"

// Использование шаблона
int main()
{
	double ice = 3.0;
	printTypeof(ice);        // Вызов шаблона функции для double
)
```

Компилятор C++, вероятно, примет эту программу без каких-либо проблем, но компоновщик, скорее всего, сообщит об ошибке отсутствия определения функции `printTypeof()`.

Причиной этой ошибки является то, что определение шаблона функции `printTypeof()` не инстанцировано. Чтобы шаблон был инстанцирован, компилятор должен знать, какие определения должны быть инстанцированы и для каких именно аргументов шаблона. К сожалению, в предыдущем примере эти две части информации находятся в файлах, компилируемых по отдельности. Таким образом, когда наш компилятор видит вызов `printTypeof()`, но не имеет определения шаблона, чтобы инстанцировать его для `double`, он просто предполагает, что такое определение представлено в другом месте, и создает для этого определения соответствующую ссылку (разрешаемую компоновщиком). С другой стороны, когда компилятор обрабатывает файл `myfirst.срр`, он не имеет никаких указаний о том, что он должен инстанцировать определение содержащегося в нем шаблона для некоторых конкретных аргументов.

## Шаблоны в заголовочных файлах

Обычное решение описанной проблемы заключается в использовании того же подхода, что и для макросов или встраиваемых функций: мы включаем определения шаблона в заголовочный файл, объявляющий этот шаблон.

Таким образом, вместо предоставления файла `myfirst.срр`, мы переписываем `myfirst.hpp` так, чтобы он содержал как объявление, так и определение шаблона.
```c++
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

#include <iostream>
#include <typeinfo>

// Объявление шаблона
template<typename T>
void printTypeof(T const&);

// Реализация/определение шаблона
template<typename T>
void printTypeof(T const& x)
{
	std::cout << typeid(x).name() << '\n';
}
#endif // MYFIRST_HPP
```

Этот способ организации шаблонов называется моделью включения (`inclusion model`). При ее использовании наша программа теперь корректно компилируется, компонуется и выполняется.

Следует сделать несколько замечаний. Наиболее важным является то, что этот подход значительно увеличивает стоимость включения заголовочного файла `myfirst.hpp`. В нашем примере стоимость является не результатом размера определения самого шаблона, а результатом того факта, что мы должны также включать заголовочные файлы, используемые в определении нашего шаблона — в данном случае `<iostream>` и `<typeinfo>`. Вы можете обнаружить, что это приводит к включению десятков тысяч строк кода, потому что такие заголовочные файлы, как `<iostream>`, содержат множество собственных определений шаблонов.

На практике это становится реальной проблемой, потому что значительно увеличивает время, необходимое компилятору для компиляции больших программ. Поэтому мы рассмотрим некоторые возможные пути решения этой проблемы, включая предкомпилированные заголовочные файлы (см. #раздел_9_3) и использование явного инстанцирования шаблонов (см. #раздел_14_5).

Несмотря на рассматриваемую проблему времени построения, мы рекомендуем по возможности использовать модель включения для организации ваших шаблонов, пока не будет доступен более совершенный механизм. На момент написания этой книги в 2017 году такой механизм находится в работе: это модули, которые представлены в #разделе_17_11. Они представляют собой механизм языка, который позволяет программисту более логично организовывать код — так, чтобы компилятор мог отдельно компилировать все объявления, а затем эффективно и выборочно импортировать обработанные объявления всякий раз, когда они необходимы.

Еще одно (более тонкое) замечание о модели включения заключается в том, что невстраиваемые шаблоны функций отличаются от встраиваемых функций и макросов важным моментом: они не встраиваются в точке вызова. Вместо этого при их создании генерируется новая копия функции. Поскольку это автоматический процесс, компилятор может в конечном итоге создать две копии функции в двух разных файлах, а некоторые компоновщики могут сообщать об ошибках, встречая два различных определения одной и той же функции. Теоретически это не должно быть нашей проблемой: это проблема для системы компиляции C++. На практике все хорошо работает большую часть времени, и нам не приходится сталкиваться с этой проблемой. Однако для больших проектов, которые создают свои собственные библиотеки кода, эти проблемы иногда возникают. Обсуждение схем инстанцирования в #главе_14, “Инстанцирование”, и тщательное изучение документации, поставляемой с компилятором C++, должно помочь решить эти проблемы.

Наконец, мы должны указать на то, что вопросы, относящиеся в нашем примере к шаблонам обычных функций, применимы и к функциям-членам и статическим членам-данным шаблонов классов, а также к шаблонам функций-членов.

# Шаблоны и inline

Объявление функций встраиваемыми является распространенным способом улучшить время работы программы. Спецификатор [[inline|inline]] задумывался как подсказка реализации о том, что встраивание тела функции в точку вызова предпочтительнее, чем механизм вызова обычной функции.























