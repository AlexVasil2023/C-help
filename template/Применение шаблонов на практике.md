
[[#Применение шаблонов на практике|Применение шаблонов на практике]] 9
1. [[#Модель включения|Модель включения]] 9.1
	1. [[#Ошибки компоновщика|Ошибки компоновщика]] 9.1.1
	2. [[#Шаблоны в заголовочных файлах|Шаблоны в заголовочных файлах]] 9.1.2
2. [[#Шаблоны и inline|Шаблоны и inline]] 9.2
3. [[#Предкомпилированные заголовочные файлы|Предкомпилированные заголовочные файлы]] 9.3
4. [[#Расшифровка романов об ошибках|Расшифровка романов об ошибках]] 9.4



# Применение шаблонов на практике

Код шаблона немного отличается от обычного кода. В некотором смысле шаблоны лежат где-то между макросами и обычными, нешаблонными объявлениями. Хотя это может быть и чрезмерным упрощением, оно имеет следствия не только для способа написания алгоритмов и структур данных с использованием шаблонов, но и для повседневной логистики выражения и анализа программ с применением шаблонов.

В этой главе мы рассмотрим некоторые практические вопросы без углубления в технические детали, лежащие в их основе. Многие из этих деталей рассматриваются в #главе_14, “Инстанцирование”. Чтобы упростить обсуждение, мы предполагаем, что наши системы компиляции C++ состоят из традиционных компиляторов и компоновщиков (системы, не попадающие в эту категорию, крайне редки).

# Модель включения

Существует несколько способов организации исходных текстов шаблонов. В этом разделе представлен наиболее популярный подход: модель включения.

## Ошибки компоновщика

Большинство программистов на С и C++ организуют свой нешаблонный код в основном следующим образом.
>
> Классы и прочие объявления типов полностью размещаются в заголовочных файлах. Обычно эти файлы имеют расширение `.hpp` (или `.Н`, `.h`, `.hh`, `.hxx`).
> 
> Что касается глобальных (невстраиваемых) переменных и (невстраиваемых) функций, в заголовочный файл помещаются только объявления, а определения размещаются в файлах, компилируемых как отдельные единицы трансляции. Такие СРР-файлы обычно имеют расширение `.срр` ( или `.С`, `.с`, `.сс`, `.схх`).

Этот способ вполне работоспособен: он делает определение необходимого типа легко доступным во всей программе и позволяет избежать ошибок компоновки, связанных с дублированием определений переменных и функций.

С учетом данных соглашений распространенная ошибка, на которую часто жалуются начинающие программисты, может быть проиллюстрирована следующей (неверной) небольшой программой. Как и для “обычного кода”, шаблон объявлен в заголовочном файле:
```c++
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

// Объявление шаблона
template<typename T>
void printTypeof(T const&);

#endif // MYFIRST_HPP
```

`printTypeof()` представляет собой объявление простой вспомогательной функции, которая выводит некоторую информацию о типе. Реализация этой функции помещается в СРР-файл:
```c++
#include <iostream>
#include <typeinfo>
#include "myfirst.hpp"

// Реализация/определение шаблона
template<typename T>
void printTypeof(T const& x)
{
	std::cout << typeid(x).name() << '\n';
}
```

В этом примере использован оператор [[typeid|typeid]], позволяющий вывести строку, описывающую тип переданного ему выражения. Он возвращает 1-значение статического типа [[type_info|std::type_info]], который предоставляет функцию-член `name()`, возвращающую строковое представление типа. На самом деле стандарт C++ не требует от `name()` возврата чего-то значимого, но в хороших реализациях C++ вы должны получить строку, которая представляет собой хорошее описание типа выражения, переданного `typeid`.

Наконец, мы используем шаблон в другом СРР-файле, в который объявление шаблона включено с использованием директивы препроцессора `#include`:
```c++
#include "myfirst.hpp"

// Использование шаблона
int main()
{
	double ice = 3.0;
	printTypeof(ice);        // Вызов шаблона функции для double
)
```

Компилятор C++, вероятно, примет эту программу без каких-либо проблем, но компоновщик, скорее всего, сообщит об ошибке отсутствия определения функции `printTypeof()`.

Причиной этой ошибки является то, что определение шаблона функции `printTypeof()` не инстанцировано. Чтобы шаблон был инстанцирован, компилятор должен знать, какие определения должны быть инстанцированы и для каких именно аргументов шаблона. К сожалению, в предыдущем примере эти две части информации находятся в файлах, компилируемых по отдельности. Таким образом, когда наш компилятор видит вызов `printTypeof()`, но не имеет определения шаблона, чтобы инстанцировать его для `double`, он просто предполагает, что такое определение представлено в другом месте, и создает для этого определения соответствующую ссылку (разрешаемую компоновщиком). С другой стороны, когда компилятор обрабатывает файл `myfirst.срр`, он не имеет никаких указаний о том, что он должен инстанцировать определение содержащегося в нем шаблона для некоторых конкретных аргументов.

## Шаблоны в заголовочных файлах

Обычное решение описанной проблемы заключается в использовании того же подхода, что и для макросов или встраиваемых функций: мы включаем определения шаблона в заголовочный файл, объявляющий этот шаблон.

Таким образом, вместо предоставления файла `myfirst.срр`, мы переписываем `myfirst.hpp` так, чтобы он содержал как объявление, так и определение шаблона.
```c++
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

#include <iostream>
#include <typeinfo>

// Объявление шаблона
template<typename T>
void printTypeof(T const&);

// Реализация/определение шаблона
template<typename T>
void printTypeof(T const& x)
{
	std::cout << typeid(x).name() << '\n';
}
#endif // MYFIRST_HPP
```

Этот способ организации шаблонов называется моделью включения (`inclusion model`). При ее использовании наша программа теперь корректно компилируется, компонуется и выполняется.

Следует сделать несколько замечаний. Наиболее важным является то, что этот подход значительно увеличивает стоимость включения заголовочного файла `myfirst.hpp`. В нашем примере стоимость является не результатом размера определения самого шаблона, а результатом того факта, что мы должны также включать заголовочные файлы, используемые в определении нашего шаблона — в данном случае `<iostream>` и `<typeinfo>`. Вы можете обнаружить, что это приводит к включению десятков тысяч строк кода, потому что такие заголовочные файлы, как `<iostream>`, содержат множество собственных определений шаблонов.

На практике это становится реальной проблемой, потому что значительно увеличивает время, необходимое компилятору для компиляции больших программ. Поэтому мы рассмотрим некоторые возможные пути решения этой проблемы, включая предкомпилированные заголовочные файлы (см. #раздел_9_3) и использование явного инстанцирования шаблонов (см. #раздел_14_5).

Несмотря на рассматриваемую проблему времени построения, мы рекомендуем по возможности использовать модель включения для организации ваших шаблонов, пока не будет доступен более совершенный механизм. На момент написания этой книги в 2017 году такой механизм находится в работе: это модули, которые представлены в #разделе_17_11. Они представляют собой механизм языка, который позволяет программисту более логично организовывать код — так, чтобы компилятор мог отдельно компилировать все объявления, а затем эффективно и выборочно импортировать обработанные объявления всякий раз, когда они необходимы.

Еще одно (более тонкое) замечание о модели включения заключается в том, что невстраиваемые шаблоны функций отличаются от встраиваемых функций и макросов важным моментом: они не встраиваются в точке вызова. Вместо этого при их создании генерируется новая копия функции. Поскольку это автоматический процесс, компилятор может в конечном итоге создать две копии функции в двух разных файлах, а некоторые компоновщики могут сообщать об ошибках, встречая два различных определения одной и той же функции. Теоретически это не должно быть нашей проблемой: это проблема для системы компиляции C++. На практике все хорошо работает большую часть времени, и нам не приходится сталкиваться с этой проблемой. Однако для больших проектов, которые создают свои собственные библиотеки кода, эти проблемы иногда возникают. Обсуждение схем инстанцирования в #главе_14, “Инстанцирование”, и тщательное изучение документации, поставляемой с компилятором C++, должно помочь решить эти проблемы.

Наконец, мы должны указать на то, что вопросы, относящиеся в нашем примере к шаблонам обычных функций, применимы и к функциям-членам и статическим членам-данным шаблонов классов, а также к шаблонам функций-членов.

# Шаблоны и inline

[[inline#Шаблоны и inline| см. Шаблоны и inline]]

# Предкомпилированные заголовочные файлы

Даже без шаблонов заголовочные файлы C++ могут стать очень большими и требовать много времени для обработки при компиляции. Шаблоны вносят свой вклад в эту тенденцию, и возмущения программистов заставили поставщиков компиляторов реализовать схему, обычно известную как предкомпилированные заголовочные файлы (precompiled headers — РСН). Эта схема работает вне области применения стандарта и основана на специфике конкретного производителя. Подробности о том, как создавать и использовать файлы предкомпилированных заголовочных файлов, вы найдете в документации по соответствующей системе компиляции C++, а здесь вы получите только некоторое общее представление о том, как работает этот механизм.

Когда компилятор транслирует файл, он начинает с самого начала файла и читает его до конца. По мере обработки каждого токена в файле (которые могут находиться во включаемых с помощью директивы `#include` файлах) компилятор изменяет свое внутреннее состояние, включая выполнение таких действий, как добавление записей в таблицу символов, в которой позже может выполняться поиск. При этом компилятор может также генерировать код в объектных файлах.

Схема предкомпилированных заголовочных файлов опирается на тот факт, что код может быть организован таким образом, что многие файлы начинаются с одних и тех же строк кода. Давайте предположим, что каждый компилируемый файл начинается с одних и тех же `N` строк кода. Мы могли бы скомпилировать эти `N` строк и сохранить текущее состояние компилятора в предкомпилированном заголовочном файле. Затем для каждого файла в нашей программе можно просто загрузить сохраненное состояние и начать компиляцию с `N+1`-й строки. Здесь следует заметить, что загрузка сохраненного состояния является операцией, которая может быть на порядки быстрее, чем реальная компиляция первых `N` строк. Однако при первом выполнении сохранение состояния обычно дороже, чем простая компиляция `N` строк. Увеличение стоимости колеблется примерно от 20 до 200 процентов.

Ключом к эффективному использованию предкомпилированных заголовочных файлов является обеспечение как можно большего количества одинаковых строк кода в начале каждого файла. На практике это означает, что файлы должны начинаться с одних и тех же директив `#include` в одном и том же порядке, которые (как упоминалось ранее) потребляют значительную часть времени построения программы. Следовательно, может оказаться очень выгодным обратить внимание на порядок, в котором включаются заголовочные файлы. Например, следующие два файла:
```c++
#include <iostream>
#include <vector>
#include <list>

...
```

и
```c++
#include <list>
#include <vector>

...
```

мешают использованию предкомпилированных заголовочных файлов, потому что у них нет общего начального состояния.

Некоторые программисты считают, что лучше включить в файл некоторые дополнительные ненужные заголовочные файлы, но обеспечить возможность ускорить трансляцию за счет использования предкомпилированного заголовочного файла. Такое решение может существенно облегчить управление стратегией включения. Например, обычно относительно просто создать заголовочный файл с именем `std.hpp`, который включает в себя все стандартные заголовки:
```c++
#include <iostream>
#include <string>
#include <vector>
#include <deque>
#include <list>

...
```

Затем этот файл может быть предкомпилирован, и каждый файл программы, использующий стандартную библиотеку, просто начинается следующим образом:
```c++
#include "std.hpp"

...
```

Обычно это требует некоторого времени для предкомпиляции, но в системе с достаточным объемом памяти схема с предкомпилированным заголовочным файлом позволяет работать значительно быстрее, чем требуется почти любому стандартному заголовочному файлу без предварительной компиляции. Стандартные заголовочные файлы особенно удобно использовать таким образом, потому что они редко изменяются, а следовательно, предкомпилированный заголовочный файл для файла `std.hpp` может быть построен один раз. В противном случае предкомпилированные заголовочные файлы обычно являются частью конфигурации зависимостей проекта (например, обновляются по мере необходимости популярной программой [[CMake|make]] или соответствующим инструментарием интегрированной среды разработки (IDE)).

Одним из привлекательных подходов к управлению предкомпилированными заголовочными файлами является создание слоев предкомпилированных заголовочных файлов, которые образуются из наиболее широко используемых и стабильных заголовочных файлов (как, например, наш заголовочный файл `std.hpp`), для которых не ожидается внесение изменений, а потому имеет смысл их предварительная компиляция. Однако, если заголовочные файлы находятся в постоянном развитии, их предкомпиляция может потребовать больше времени, чем даст экономия при повторном их использовании. Ключевой концепцией этого подхода является то, что предкомпилированные заголовочные файлы более стабильного слоя могут быть повторно использованы для улучшения времени компиляции менее стабильных заголовочных файлов. Предположим, например, что в дополнение к нашему заголовочному файлу `std.hpp` (который мы предварительно скомпилировали), мы также определили заголовочный файл `core.hpp`, который включает дополнительные возможности, специфичные для нашего проекта, но тем не менее достигшие определенного уровня стабильности:
```c++
#include "std.hpp"
#include "core_data.hpp"
#include "core_algos.hpp"

...
```

Поскольку этот файл начинается с `#include "std.hpp"`, компилятор может загрузить соответствующий предкомпилированный заголовок и продолжить работу со следующими строками без перекомпиляции всех стандартных заголовков. Когда файл будет полностью обработан, может быть создан новый предкомпилированный заголовочный файл. Затем приложения могут использовать `#include "core.hpp"` для обеспечения быстрого доступа к большому количеству функциональности, потому что компилятор может загрузить последний предкомпилированный заголовочный файл.

# Расшифровка романов об ошибках































