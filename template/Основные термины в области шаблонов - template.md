
[[#Основные термины в области шаблонов|Основные термины в области шаблонов]] 10
1. [[#“Шаблон класса” или “шаблонный класс”|“Шаблон класса” или “шаблонный класс”]] 10.1
2. [[#Подстановка, инстанцирование и специализация|Подстановка, инстанцирование и специализация]] 10.2
3. [[#Объявления и определения|Объявления и определения]] 10.3
	1. [[#Полные и неполные типы|Полные и неполные типы]] 10.3.1
4. [[#Правило одного определения|Правило одного определения]] 10.4
5. [[#Аргументы и параметры шаблонов|Аргументы и параметры шаблонов]] 10.5

# Основные термины в области шаблонов

Предыдущие главы книги были посвящены знакомству с основами концепции шаблонов в C++. Теперь, прежде чем перейти к более подробному рассмотрению шаблонов, хотелось бы уделить внимание терминам, которые используются при изложении материала. В этом есть необходимость, поскольку в сообществе C++ (и даже в ранних версиях стандарта) иногда отсутствует четкое понимание концепций и терминологии.

# “Шаблон класса” или “шаблонный класс”

В C++ структуры, классы и объединения имеют общее название типы классов, или классовые типы (`class types`). Без дополнительного уточнения слово “класс” обычно служит для обозначения типов класса, заданных с помощью ключевых слов `class` или struct. Особо следует отметить, что понятие “тип класса” включает объединения, а “класс” — нет.

Имеется определенная некоторая путаница в отношении того, как следует именовать класс, являющийся шаблоном.
>
> Термин ***шаблон класса*** (class template) означает, что класс является шаблоном. Другими словами, это параметризованное описание семейства классов.
> 
> С другой стороны, термин ***шаблонный класс*** (template class) используется
> 	> как синоним для шаблона класса;
> 	> для обозначения классов, сгенерированных из шаблона;
> 	> для обозначения классов с именем, которое является идентификатором шаблона (комбинацией имени шаблона, за которым следуют аргументы шаблона между < и >).

Разница между вторым и третьим значениями весьма незначительна и в остальной части книги не играет сколько-нибудь заметной роли.

Из-за упомянутой неточности в данной книге мы старались избегать термина шаблонный класс.

Аналогично мы используем термины ***шаблон функции*** (function template), ***шаблон члена*** (member template), ***шаблон функции-члена*** (member function template) и ***шаблон переменной*** (variable template), но стараемся избегать терминов ***шаблонная функция*** (template function), ***шаблонный член*** (template member), ***шаблонная функция-член*** (template member function) и ***шаблонная переменная*** (template variable).

# Подстановка, инстанцирование и специализация

При обработке исходного текста, в котором используются шаблоны, компилятор C++ должен в разные моменты времени выполнять подстановку (substitute) конкретных аргументов шаблона вместо параметров шаблона в шаблоне. Иногда эта замена только предварительная: компилятору может потребоваться проверить, [[Программирование времени компиляции - template#SFINAE|является ли допустимым такое замещение]] (см. #раздел_15_7).

Процесс создания определения (definition) для обычного класса, псевдонима типа, функции, функции-члена или переменной из шаблона путем подстановки конкретных аргументов в качестве параметров шаблона называется инстанцированием шаблона (template instantiation).

Удивительно, но в настоящее время нет стандартного или хотя бы в целом согласованного термина для обозначения процесса создания объявления (declaration), которое не является определением, путем подстановки параметров шаблона. Мы встречались с такими терминами, используемыми разными группами, как частичное инстанцирование (partial instantiation) или инстанцирование объявления (instantiation of a declaration), но они ни в коем случае не являются универсальными. Возможно, более интуитивным является термин неполное инстанцирование (incomplete instantiation) (которое в случае шаблона класса производит неполный класс).

Сущности, появляющиеся в результате инстанцирования или неполного инстанцирования (т.е. класс, функция, функция-член или переменная) в общем случае называются специализациями (specialization).

Однако в C++ процесс инстанцирования является не единственным способом получить специализацию. Существуют альтернативные механизмы, позволяющие программисту явно задавать объявление, привязанное к определенной подстановке параметров шаблона. [[Шаблоны классов - template#Специализации шаблонов классов|Как упоминалось]], такая специализация вводится с помощью префикса `template<>`:
```c++
template<typename T1, typename T2> // Первичный шаблон класса
class MyClass
{
	...
};

template<>                         // Явная специализация
class MyClass<std::string, float>
{
	...
};
```

Строго говоря, это так называемая явная специализация (explicit specialization) (в отличие от инстанцируемой, или генерируемой специализации (instantiated specialization, generated specialization)).

[[Шаблоны классов - template#Частичная специализация|Как отмечалось]], специализации, в которых остаются параметры шаблона, называются частичными специализациями (partial specialization).
```c++
template<typename Т>          // Частичная специализация
class MyClass<T, Т>
{
	...
};

template<typename Т>          // Частичная специализация
class MyClass<bool, Т>
{
	...
};
```

Если речь идет о специализации (явной или частичной), то общий шаблон называется первичным шаблоном (primary template).

# Объявления и определения

До сих пор понятия ***объявление*** (declaration) и ***определение*** (definition) встречались не слишком часто. Однако оба понятия достаточно точно определены в стандарте C++, и именно эти значения данных понятий используются в нашей книге.

***Объявление*** (declaration) является конструкцией C++, которая вводит или повторно задает имя в области видимости C++. Такое задание всегда включает частичную классификацию имени, но для корректности объявления указание всех деталей не требуется, например:
```c++
class С;                        // Объявление С как класса

void f(int р);                  // Объявление f () как функции,
								// а р- как именованного параметра
extern int v;                   // Объявление V как переменной
```

Отметим, что макроопределения и метки [[goto|goto]], несмотря на то, что они имеют “имена”, в C++ объявлениями не считаются.

Объявления становятся ***определениями*** (definition), когда делается известной информация об их структуре или, в случае переменных, когда для них должна быть выделена память. Для определений типов классов это означает, что должно быть предоставлено заключенное в фигурные скобки тело. Для определений функций это означает, что должно быть предоставлено заключенное в фигурные скобки тело (в общем случае) или функция должна быть определена как `=default` или `=delete`. В случае переменных для того, чтобы объявление стало определением, достаточно инициализации или отсутствия спецификатора [[extern|extern]]. Далее приведены примеры, которые дополняют представленные выше объявления, не являющиеся определениями.
```c++
class С {};         // Определение (и объявление) класса С

void f(int р)       // Определение (и объявление) функции f ()
{
	std::cout << р << '\n';
}

extern int v = 1;   // Инициализатор делает этот код определением v
int w;              // Объявления глобальных переменных, не
					// предшествуемые ключевым словом extern,
					// также являются определениями
```

Распространение этого принципа на шаблоны приводит к тому, что объявление шаблона класса или шаблона функции называется определением, если оно имеет тело. Следовательно,
```c++
template<typename Т>
void func(T);
```

является объявлением, но не определением, в то время как
```c++
template<typename Т>
class S {};
```

фактически является определением.

## Полные и неполные типы

Типы могут быть ***полными*** (complete) или ***неполными*** (incomplete); это понятие тесно связано с различиями между ***объявлением*** и ***определением***. Некоторые языковые конструкции требуют ***полные типы*** (complete types), тогда как другие являются корректными и при использовании ***неполных типов*** (incomplete types).

Неполный тип представляет собой одно из следующего списка:
>
> объявленный, но неопределенный тип класса;
> 
> тип массива с неопределенными границами;
> 
> тип массива с элементами неполного типа;
> 
> void;
> 
> тип перечисления, пока не определен его базовый тип или значения перечислителей;
> 
> любой из перечисленных выше типов, к которому применен спецификатор [[const|const]] и/или [[volatile|volatile]].

Все прочие типы являются полными, например:
```c++
class С;                        // С - неполный тип
С const* ср;                    // ср - указатель на неполный тип
extern С elems[10];             // elems имеет неполный тип
extern int arr[];               // arr имеет неполный тип

class С {};                     // С теперь является полным типом (а
								// следовательно, ср и elems больше
								// не ссылаются на неполные типы)
int arr|АО];                    // arr имеет полный тип
```

Подсказки по работе с неполными типами в шаблонах представлены в #разделе_11_5.

# Правило одного определения

В языке C++ на повторные объявления различных сущностей накладываются определенные ограничения. Вся совокупность этих ограничений известна как правило одного определения (one definition rule — ODR). Детали этого правила очень сложны и охватывают огромное множество ситуаций. В последующих главах различные аспекты правила одного определения будут проиллюстрированы для каждого рассматриваемого случая, а полное его описание читатель найдет в #приложении_А, “Правило одного определения”. Пока что достаточно знать лишь основные положения этого правила.
> 
> Обычные, т.е. невстраиваемые функции и функции-члены, так же как и (невстраиваемые) глобальные переменные и статические данные-члены, должны определяться однократно в рамках программы в целом.
>
> Типы классов (включая структуры и объединения), шаблоны (включая частичные, но не полные специализации) и встраиваемые функции и переменные должны быть определены не более одного раза в пределах единицы трансляции (translation unit), и все эти определения должны быть идентичными.

***Единица трансляции*** представляет собой то, что получается в результате обработки исходного файла процессором; другими словами, она включает содержимое, заданное директивами включения файлов `#include` и полученное в результате раскрытия макроопределений.

В оставшейся части книги ***связываемый объект*** (linkable entity) будет означать одно из следующего списка: функция или функция-член, глобальная переменная или статические данные-члены (включая любой из перечисленных объектов, сгенерированный из шаблона), видимые компоновщику.

# Аргументы и параметры шаблонов

Сравним шаблон класса
```c++
template<typename Т, int N>
class ArrayInClass
{
	public:
		Т array[N];
};
```

с аналогичным обычным классом:
```c++
class DoubleArrayInClass
{
	public:
		double array[10];
};
```

Последний становится, по сути, эквивалентен первому, если заменить параметры `Т` и `N` значениями `double` и 10 соответственно. В C++ эта подстановка обозначается как
```c++
ArrayInClass<double, 10>
```

Заметим, что за именем шаблона следуют так называемые аргументы шаблона в угловых скобках.

Зависят ли эти аргументы от параметров шаблона или нет, комбинация имени шаблона, за которым следуют аргументы в угловых скобках, называется идентификатором шаблона (template-id).

Это имя может использоваться почти так же, как и соответствующие нешаблонные объекты, например:
```c++
int main()
{
	ArrayInClass<double, 10> ad;
	ad.array[0] = 1.0;
}
```

Важно различать ***параметры шаблона*** и ***аргументы шаблона***. Коротко говоря, можно сказать, что “***параметры*** инициализируются ***аргументами***”. Или, если быть более точным:
>
> ***параметрами шаблона*** являются те имена, которые перечислены после ключевого слова `template` в объявлении или определении шаблона (в нашем примере — `Т` и `N`);
> 
> ***аргументы шаблона*** являются элементами, которые подставляются вместо параметров шаблона (`double` и `10` в нашем примере). В отличие от параметров шаблона, аргументы шаблона могут представлять собой нечто большее, чем просто “имена”.

Подстановка аргументов шаблона вместо параметров шаблона выполняется явно посредством идентификатора шаблона, однако есть различные ситуации, когда подстановка выполняется неявно (например, если вместо параметров подставляются их аргументы по умолчанию).

Фундаментальный принцип заключается в том, что любой аргумент шаблона должен быть величиной или значением, которое определимо во время компиляции. Как станет понятно позже, это сулит огромные выгоды в плане стоимости времени выполнения шаблонных объектов. Поскольку параметры шаблона в конечном счете заменяются значениями времени компиляции, они сами могут быть использованы для образования выражений, вычисляемых во время компиляции. Эта возможность используется в шаблоне `ArraylnClass` для задания размера члена массива [[Array|array]]. Размер массива должен быть так называемым константным выражением (constant-expression), и параметр шаблона `N` является именно таковым.

Поскольку параметры шаблона — это объекты времени компиляции, их также можно использовать для создания корректных аргументов шаблонов. Приведем пример:
```c++
template<typename Т>
class Dozen
{
	public:
		ArrayInClass<T, 12> contents;
};
```

Обратите внимание на то, что в данном примере имя `Т` является как параметром шаблона, так и аргументом шаблона. Таким образом обеспечивается механизм конструирования более сложных шаблонов из более простых. Разумеется, этот механизм не имеет фундаментальных отличий от механизмов, которые позволяют связывать типы и функции.
