
[[#Шаблоны функций|Шаблоны функций]] 1
1. [[#Первое знакомство с шаблонами функций|Первое знакомство с шаблонами функций]] 1.1
	1. [[#Определение шаблона|Определение шаблона]] 1.1.1
	2. [[#Понятие шаблона функций|Понятие шаблона функций]] 1.1.2
	3. [[#Когда шаблонная функция (не) будет работать?|Когда шаблонная функция (не) будет работать?]] 1.1.3
	4. [[#Двухэтапная трансляция|Двухэтапная трансляция]] 1.1.4
2. [[#Вывод аргумента шаблона|Вывод аргумента шаблона]] 1.2
3. [[#Несколько параметров шаблона|Несколько параметров шаблона]] 1.3


# Шаблоны функций

Шаблоны функций — это параметризованные функции; таким образом, шаблон функции представляет целое семейство функций.

# Первое знакомство с шаблонами функций

Шаблоны функций предоставляют функциональное поведение, которое может быть вызвано для разных типов. Другими словами, шаблон функции представляет семейство функций. Шаблон очень похож на обычную функцию, разница только в том, что некоторые элементы этой функции остаются неопределенными и являются параметризованными. Чтобы проиллюстрировать сказанное выше, рассмотрим небольшой пример.

#### Определение шаблона

Ниже приведен шаблон функции, возвращающей большее из двух значений.
```c++
template<typename Т>
Т max(T а, Т b) {
	// Если b < а, возвращаем а, в противном случае b
	return b < а ? а : b;
}
```

Это определение шаблона задает семейство функций, возвращающих большее из двух значений; эти значения передаются функции как ее параметры `а` и `b`. Тип этих параметров остается открытым как параметр шаблона `Т`. Как показано в примере, параметры шаблонов объявляются с использованием следующего синтаксиса:
```c++
template< разделенный запятыми список параметров >
```

В нашем примере список параметров представляет собой `typename Т`. Обратите внимание на то, что в качестве скобок используются символы “меньше” (`<`) и “больше” (`>`), которые мы будем называть угловыми скобками (angle brackets). Ключевое слово` typename` задает так называемый параметр, являющийся типом, или, для краткости — параметр типа, или типовой параметр. Это пока что наиболее распространенный вид параметров шаблонов в программах на C++, хотя возможны и другие параметры.

В данном примере параметр типа обозначен как `Т`. В качестве имени параметра можно использовать любой идентификатор, но обычно по соглашению используется именно `Т`. Параметр типа представляет произвольный тип, который определяется при вызове функции. Можно использовать любой тип (это может быть один из фундаментальных типов, класс и т.п.), который допускает применение операций, использованных в шаблоне. В нашем случае тип `Т` должен поддерживать оператор `<`, поскольку он используется в теле функции для сравнения `а` и `b`. Из определения `max ()` несколько менее очевидно, что значения типа `Т` должны быть копируемы, чтобы быть возвращаемыми.

По историческим причинам для определения параметра типа разрешается применение вместо `typename` ключевого слова `class`. Ключевое слово `typename` в ходе эволюции языка C++ появилось относительно поздно, при разработке стандарта С++98. До этого единственным способом задания параметра типа было ключевое слово `class`, применение которого для определения параметра типа корректно и сегодня. Следовательно, эквивалентным способом определения шаблона `max()` является следующий:
```c++
template<class Т>
Т max (Т а, Т b) {
	return Ь < а ? а : Ь;
}
```

Семантически в данном контексте между этими двумя способами записи нет никакой разницы. Даже в случае применения ключевого слова `class` для аргументов шаблона может быть использован любой тип. Однако, поскольку ключевое слово `class` может ввести в заблуждение (вместо `Т` можно подставлять не только тип, являющийся классом), в данном контексте следует отдавать предпочтение использованию ключевого слова `typename`. Отметим, что в отличие от объявлений типа класса ключевое слово `struct` при объявлении параметров типа вместо `typename` использовать нельзя.

## Понятие шаблона функций

Шаблоном функций называют общее описание семейства функций (обобщенного алгоритма ). Об этом уже было сказано, но рассмотрим их поподробней.
Листинг find_min_int
```c++
int min(int a, int b){
  int result = a;
  
  if(b < a)
    result = b;
    
  return result;
}
```

^55c104

Если нам понадобится поиск минимального целого числа, то можно воспользоваться функцией, представленной в листинге _**[[Шаблоны функций#^55c104|find_min_int]]**_. Однако, для поиска минимума среди действительных чисел придется в программу добавить функцию из листинга _**[[Шаблоны функций#^15b9c4|find_min_float]]**_:

Листинг find_min_float
```c++
float min(float a, float b){
  float result = a;
  
  if(b < a)
    result = b;
  
  return result;
}
```

^15b9c4

Таким образом, для каждого типа приходится переопределять функцию.

Однако, для каждого типа данных функция выглядит одинаково. В связи с чем язык С++ предлагает механизм шаблонов, который позволяет описать семейство функций. Пример соответсвующего шаблона приведен в листинге _**[[Шаблоны функций#^7e0474|find_min_tpl]]**_.

Листинг find_min_tpl
```c++
template<typename TYPE>
TYPE min(TYPE a, TYPE b){
  TYPE result = a;
  if(b < a) {
    result = b;
  }
  return result;
}
```

^7e0474

Определение шаблона начинается с ключевой конструкции **template<typename TYPE, ...>** где в угловых скобках указываются параметры шаблона. Параметров шаблона может быть любое количество, в качестве параметра может быть тип или перечислимое значение.

Пока нет вызова функции min в программе, при компиляции она в бинарном коде не создается (не инстанцируется). А если объявить группу вызовов функции с переменными различных типов, то для каждого компилятор создаст свою реализацию на основе шаблона.

Вызов шаблонной функции, в общем, эквивалентен вызову обыкновенной функции. В этом случае компилятор определит, какой тип использовать вместо TYPE, на основании типа фактических параметров. Но если подставляемые параметры окажутся разных типов, то компилятор не сможет вывести (инстанцировать шаблон) реализацию функции (см. _**[[Шаблоны функций#^99003c|min_inst]]**_).

Листинг min_inst
```c++
#include <iostream>
template<class TYPE>
TYPE min(TYPE a, TYPE b) {
    if (a < b) {
        return a;
    }
    return b;
}

int main(int argc, char** argv) {
    std::cout << min(1, 2) << std::endl; // OK
    std::cout << min(3.1, 1.2) << std::endl; // OK
    std::cout << min(5, 2.1) << std::endl; // error! can`t deduce from template!
    return 0;
}
```

^99003c

Эту проблему можно решить явным указанием подставляемого в шаблон типа.

Листинг min_inst_2
```c++
#include <iostream>
template<class TYPE>
TYPE min(TYPE a, TYPE b) {
    if (a < b) {
        return a;
    }
    return b;
}

int main(int argc, char** argv) {
    std::cout << min(1, 2) << std::endl; // OK
    std::cout << min(3.1, 1.2) << std::endl; // OK
    std::cout << min<double>(5, 2.1) << std::endl; // OK
    return 0;
}
```

## Когда шаблонная функция (не) будет работать?

На этапе компиляции программы компилятор подставляет нужный (наиболее подходящий) тип в шаблон. Но всегда ли получаемая функция будет работоспособна? Очевидно, что нет. Любой алгоритм может быть определен независимо от типа данных, но он обязательно пользуется свойствами этих данных. В случае с шаблонной функцией `min` это требование определения оператора упорядочения (**оператор <**).

Любой шаблон функции предполагает наличие определенных свойств параметризованного типа, в зависимости от реализации (например, оператора копирования, оператора сравнения, наличия определенного метода и т.д.). 

## Применение шаблонов

В приведенном ниже фрагменте кода иллюстрируется использование шаблона функции `max ()`.

```c++
#include "maxl.hpp"
#include <iostream>
#include <string>

int main() {
	int i = 42;
	std: :cout << "max(7,i):    " << ::max(7,i) << '\n';
	 
	double f1 = 3.4;
	double f2 = -6.7;
	std: :cout << "max(f1,f2):  " << ::max(f1, f2) << '\n';
	
	std::string s1 = "mathematics";
	std::string s2 = "math";
	std::cout << "max(s1,s2):  " << ::max(s1, s2) << '\n';
}
```

В этой программе `max ()` вызывается трижды: для двух значений типа `int`, для двух `double` и для двух [[string|std::string]]. Каждый раз вычисляется большее значение. В результате программа выводит следующую информацию:

![[templ_1.png]]

Обратите внимание на то, что в примере каждый вызов шаблона `max ()` предваряется двумя двоеточиями (`::`). Это вовсе не потому, что `max ()` находится в глобальном пространстве имен. Дело в том, что в стандартной библиотеке тоже есть шаблон `std::max()`, который может быть вызван при определенных обстоятельствах или способен привести к неоднозначности.

Шаблоны не компилируются в единую сущность, способную обработать любой тип данных. Вместо этого из шаблона генерируются различные объекты для каждого типа, для которого применяется шаблон. Таким образом, `max ()` компилируется для каждого из трех типов. Например, первый вызов `max ()`
```c++
int i = 42;
... max(7, i) ...
```

использует шаблон функции с `int` в качестве параметра шаблона `Т`. Таким образом, он имеет семантику вызова следующего кода:
```c++
int max(int a, int b) {
	return b < a ? a : b;
}
```

Процесс замены параметров шаблона конкретными типами называется инстанцированием шаблона (`instantiation`). Его результатом является экземпляр (`instance`) шаблона.

Отметим, что процесс инстанцирования запускается простым использованием шаблона функции. Специально требовать от компилятора инстанцирования шаблона не нужно.

Аналогично другие вызовы `max ()` инстанцируют шаблон `max` для `double` и [[string|std: :string]] точно так же, как если бы они были объявлены и реализованы отдельно:
```c++
double max(double, double);
std::string max(std::string, std::string);
```

Обратите также внимание: тип [[void|void]] является корректным аргументом шаблона при условии, что получающийся код корректен; например:
```c++
template<typename Т>
Т foo(T*) {
}

void* vp = nullptr;
foo(vp); // OK: выводится void foo(void*)
```

## Двухэтапная трансляция

Попытка инстанцирования шаблона для типа, который не поддерживает все используемые в нем операции, приведет к ошибке времени компиляции. Например:
```c++
std::complex<float> c1, с2;// Отсутствует оператор <

...

::max(c1, с2);// Ошибка времени компиляции
```

Таким образом, шаблоны “компилируются” в два этапа.

4. Во время определения (`definition time`) код шаблона проверяется на корректность без инстанцирования, с игнорированием параметров шаблонов. Этот процесс включает:
	* выявление таких синтаксических ошибок, как отсутствующие точки с запятой;
	* выявление применения неизвестных имен (имен типов, функций и т.п.), которые не зависят от параметров шаблона;
	* выполнение проверок статических утверждений, не зависящих от параметров шаблонов.
5. Во время инстанцирования код шаблона вновь проверяется на корректность. Таким образом, все части, которые зависят от параметров шаблонов, подвергаются двойной проверке.

Например:
```c++
template<typename Т>
void foo(T t) {
	undeclared();           // Если функция undeclared() неизвестна —
							// получаем ошибку первого этапа
	undeclared(t);          // Если функция undeclared(Т) неизвестна —
							// получаем ошибку второго этапа
	static_assert(sizeof(int) > 10,     // Сбой всегда при
			"int слишком мал");         // sizeof(int)<=10

	static_assert(sizeof(T) > 10,       // Сбой при инстанцировании
			"T too small");             // с типом Т, размер
										// которого <=10
```

Проверка имен, выполняемая дважды, называется двухэтапным (двухфазным) поиском (`two-phase`, `lookup`) и обсуждается в разделе_14_3_1.

Обратите внимание на то, что некоторые компиляторы не выполняют полные проверки на первом этапе. Поэтому вы можете не разглядеть общие проблемы, пока код шаблона не будет инстанцирован хотя бы раз.

> **Компиляция и компоновка**

Двухэтапная трансляция вызывает важную проблему при практической работе с шаблонами: когда шаблон функции используется способом, запускающим его инстанцирование, компилятору (в определенный момент) потребуется определение этого шаблона. Это приводит к отходу от обычной практики, различающей компиляцию и компоновку для нешаблонных функций, когда объявления функции достаточно для компиляции кода с ее использованием. Методы решения этой проблемы обсуждаются в главе_9, “Применение шаблонов на практике”. Пока что будем использовать простой подход: реализовывать каждый шаблон в заголовочном файле.

# Вывод аргумента шаблона

При вызове с некоторыми аргументами такого шаблона функции, как `max ()`, параметры этого шаблона определяются передаваемыми в функцию аргументами. Если передать два значения `int`, компилятор делает вывод, что вместо `Т` следует подставить тип `int`.

Однако `Т` может быть только “частью” типа. Например, если мы объявим шаблон функции `max ()` как использующей константные ссылки:
```c++
template<typename Т>
Т max(T const& а, Т const& Ь)
	return b < а ? а : Ь;
}
```

и передадим значения типа `int`, то тип `Т` будет выведен как `int`, поскольку параметры функции будут соответствовать `int const&`.

**Преобразования типов в процессе вывода**

Обратите внимание на то, что автоматическое преобразование типов во время вывода типа ограничено.

* При объявлении вызова по ссылке при выводе типа не выполняются даже тривиальные преобразования. Два аргумента, объявленные с одним и тем же параметром шаблона `Т`, должны точно совпадать.
* При объявлении параметров по значению поддерживаются только тривиальные низводящие ([[decay|decay]]) преобразования: игнорируются квалификаторы [[const|const]] или [[volatile|volatile]], ссылки преобразуются в тип, на который они ссылаются, а обычные массивы или функции преобразуются в соответствующий тип указателя. Для двух аргументов, объявленных с одним и тем же параметром шаблона `Т`, низведенные типы должны совпадать.

Например:
```c++
template<typename Т>
Т max (Т а, Т b);

...

int i = 17;
int const с = 42;
max(i, с);              // OK: T выводится как int
max(с, с);              // OK: T выводится как int

int& ir = i;
max(i, ir);             // OK: Т выводится как int

int arr[4];
max(&i, arr);           // OK: Т выводится как int*
```

Однако следующий код вызывает ошибку времени компиляции:
```c++
max(4, 7.2);         // Ошибка: Т может быть выведен как int или double

std::string s;
max("hello", s);    // Ошибка: T может быть выведен как
					// char const[6] или std::string
```

Справиться с этими ошибками можно тремя способами.

6. Выполнить приведение аргументов, чтобы они соответствовали одному типу:
```c++
max(static_cast<double>(4), 7.2);          // OK
```

7. Явно указать (или квалифицировать) тип `Т` для того, чтобы предупредить выведение типа компилятором:
```c++
max<double>(4, 7.2);                       // OK
```

8. Указать, что параметры могут иметь разные типы.

Мы рассмотрим эти варианты в разделе_1_3. В разделе_7_2 и главе_15, “Вывод аргументов шаблона”, правила преобразования при выведении типов будут описаны подробнее.

> **Вывод типов для аргументов по умолчанию**

Заметим также, что вывод типов не работает для аргументов по умолчанию. Например:
```c++
template<typename Т>
void f(T = "");

...

f(1); // OK: T выводится как int, так что вызывается f<int>(1)
f();  // Ошибка: невозможно вывести Т
```

Для поддержки такого применения вы должны также объявить аргумент по умолчанию для параметра шаблона (о чем будет рассказано в разделе_1_4):
```c++
template<typename Т = std::string>
void f(Т = "");

...

f();  //OK
```

# Несколько параметров шаблона



































