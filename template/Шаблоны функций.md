
[[#Шаблоны функций|Шаблоны функций]] 1
1. [[#Первое знакомство с шаблонами функций|Первое знакомство с шаблонами функций]] 1.1
	1. [[#Определение шаблона|Определение шаблона]] 1.1.1
	2. [[#Понятие шаблона функций|Понятие шаблона функций]] 1.1.2
	3. [[#Когда шаблонная функция (не) будет работать?|Когда шаблонная функция (не) будет работать?]] 1.1.3
	4. [[#Двухэтапная трансляция|Двухэтапная трансляция]] 1.1.4
2. [[#Вывод аргумента шаблона|Вывод аргумента шаблона]] 1.2
3. [[#Несколько параметров шаблона|Несколько параметров шаблона]] 1.3
	1. [[#Параметр шаблона для возвращаемого типа|Параметр шаблона для возвращаемого типа]] 1.3.1
	2. [[#Вывод возвращаемого типа|Вывод возвращаемого типа]] 1.3.2
	3. [[#Возвращаемый тип как общий тип|Возвращаемый тип как общий тип]] 1.3.3
4. [[#Аргументы шаблона по умолчанию|Аргументы шаблона по умолчанию]] 1.4
5. [[#Перегрузка шаблонов функций|Перегрузка шаблонов функций]] 1.5


# Шаблоны функций

Шаблоны функций — это параметризованные функции; таким образом, шаблон функции представляет целое семейство функций.

# Первое знакомство с шаблонами функций

Шаблоны функций предоставляют функциональное поведение, которое может быть вызвано для разных типов. Другими словами, шаблон функции представляет семейство функций. Шаблон очень похож на обычную функцию, разница только в том, что некоторые элементы этой функции остаются неопределенными и являются параметризованными. Чтобы проиллюстрировать сказанное выше, рассмотрим небольшой пример.

#### Определение шаблона

Ниже приведен шаблон функции, возвращающей большее из двух значений.
```c++
template<typename Т>
Т max(T а, Т b) {
	// Если b < а, возвращаем а, в противном случае b
	return b < а ? а : b;
}
```

Это определение шаблона задает семейство функций, возвращающих большее из двух значений; эти значения передаются функции как ее параметры `а` и `b`. Тип этих параметров остается открытым как параметр шаблона `Т`. Как показано в примере, параметры шаблонов объявляются с использованием следующего синтаксиса:
```c++
template< разделенный запятыми список параметров >
```

В нашем примере список параметров представляет собой `typename Т`. Обратите внимание на то, что в качестве скобок используются символы “меньше” (`<`) и “больше” (`>`), которые мы будем называть угловыми скобками (angle brackets). Ключевое слово` typename` задает так называемый параметр, являющийся типом, или, для краткости — параметр типа, или типовой параметр. Это пока что наиболее распространенный вид параметров шаблонов в программах на C++, хотя возможны и другие параметры.

В данном примере параметр типа обозначен как `Т`. В качестве имени параметра можно использовать любой идентификатор, но обычно по соглашению используется именно `Т`. Параметр типа представляет произвольный тип, который определяется при вызове функции. Можно использовать любой тип (это может быть один из фундаментальных типов, класс и т.п.), который допускает применение операций, использованных в шаблоне. В нашем случае тип `Т` должен поддерживать оператор `<`, поскольку он используется в теле функции для сравнения `а` и `b`. Из определения `max ()` несколько менее очевидно, что значения типа `Т` должны быть копируемы, чтобы быть возвращаемыми.

По историческим причинам для определения параметра типа разрешается применение вместо `typename` ключевого слова `class`. Ключевое слово `typename` в ходе эволюции языка C++ появилось относительно поздно, при разработке стандарта С++98. До этого единственным способом задания параметра типа было ключевое слово `class`, применение которого для определения параметра типа корректно и сегодня. Следовательно, эквивалентным способом определения шаблона `max()` является следующий:
```c++
template<class Т>
Т max (Т а, Т b) {
	return Ь < а ? а : Ь;
}
```

Семантически в данном контексте между этими двумя способами записи нет никакой разницы. Даже в случае применения ключевого слова `class` для аргументов шаблона может быть использован любой тип. Однако, поскольку ключевое слово `class` может ввести в заблуждение (вместо `Т` можно подставлять не только тип, являющийся классом), в данном контексте следует отдавать предпочтение использованию ключевого слова `typename`. Отметим, что в отличие от объявлений типа класса ключевое слово `struct` при объявлении параметров типа вместо `typename` использовать нельзя.

## Понятие шаблона функций

Шаблоном функций называют общее описание семейства функций (обобщенного алгоритма ). Об этом уже было сказано, но рассмотрим их поподробней.
Листинг find_min_int
```c++
int min(int a, int b){
  int result = a;
  
  if(b < a)
    result = b;
    
  return result;
}
```

^55c104

Если нам понадобится поиск минимального целого числа, то можно воспользоваться функцией, представленной в листинге _**[[Шаблоны функций#^55c104|find_min_int]]**_. Однако, для поиска минимума среди действительных чисел придется в программу добавить функцию из листинга _**[[Шаблоны функций#^15b9c4|find_min_float]]**_:

Листинг find_min_float
```c++
float min(float a, float b){
  float result = a;
  
  if(b < a)
    result = b;
  
  return result;
}
```

^15b9c4

Таким образом, для каждого типа приходится переопределять функцию.

Однако, для каждого типа данных функция выглядит одинаково. В связи с чем язык С++ предлагает механизм шаблонов, который позволяет описать семейство функций. Пример соответсвующего шаблона приведен в листинге _**[[Шаблоны функций#^7e0474|find_min_tpl]]**_.

Листинг find_min_tpl
```c++
template<typename TYPE>
TYPE min(TYPE a, TYPE b){
  TYPE result = a;
  if(b < a) {
    result = b;
  }
  return result;
}
```

^7e0474

Определение шаблона начинается с ключевой конструкции **template<typename TYPE, ...>** где в угловых скобках указываются параметры шаблона. Параметров шаблона может быть любое количество, в качестве параметра может быть тип или перечислимое значение.

Пока нет вызова функции min в программе, при компиляции она в бинарном коде не создается (не инстанцируется). А если объявить группу вызовов функции с переменными различных типов, то для каждого компилятор создаст свою реализацию на основе шаблона.

Вызов шаблонной функции, в общем, эквивалентен вызову обыкновенной функции. В этом случае компилятор определит, какой тип использовать вместо TYPE, на основании типа фактических параметров. Но если подставляемые параметры окажутся разных типов, то компилятор не сможет вывести (инстанцировать шаблон) реализацию функции (см. _**[[Шаблоны функций#^99003c|min_inst]]**_).

Листинг min_inst
```c++
#include <iostream>
template<class TYPE>
TYPE min(TYPE a, TYPE b) {
    if (a < b) {
        return a;
    }
    return b;
}

int main(int argc, char** argv) {
    std::cout << min(1, 2) << std::endl; // OK
    std::cout << min(3.1, 1.2) << std::endl; // OK
    std::cout << min(5, 2.1) << std::endl; // error! can`t deduce from template!
    return 0;
}
```

^99003c

Эту проблему можно решить явным указанием подставляемого в шаблон типа.

Листинг min_inst_2
```c++
#include <iostream>
template<class TYPE>
TYPE min(TYPE a, TYPE b) {
    if (a < b) {
        return a;
    }
    return b;
}

int main(int argc, char** argv) {
    std::cout << min(1, 2) << std::endl; // OK
    std::cout << min(3.1, 1.2) << std::endl; // OK
    std::cout << min<double>(5, 2.1) << std::endl; // OK
    return 0;
}
```

## Когда шаблонная функция (не) будет работать?

На этапе компиляции программы компилятор подставляет нужный (наиболее подходящий) тип в шаблон. Но всегда ли получаемая функция будет работоспособна? Очевидно, что нет. Любой алгоритм может быть определен независимо от типа данных, но он обязательно пользуется свойствами этих данных. В случае с шаблонной функцией `min` это требование определения оператора упорядочения (**оператор <**).

Любой шаблон функции предполагает наличие определенных свойств параметризованного типа, в зависимости от реализации (например, оператора копирования, оператора сравнения, наличия определенного метода и т.д.). 

## Применение шаблонов

В приведенном ниже фрагменте кода иллюстрируется использование шаблона функции `max ()`.

```c++
#include "maxl.hpp"
#include <iostream>
#include <string>

int main() {
	int i = 42;
	std: :cout << "max(7,i):    " << ::max(7,i) << '\n';
	 
	double f1 = 3.4;
	double f2 = -6.7;
	std: :cout << "max(f1,f2):  " << ::max(f1, f2) << '\n';
	
	std::string s1 = "mathematics";
	std::string s2 = "math";
	std::cout << "max(s1,s2):  " << ::max(s1, s2) << '\n';
}
```

В этой программе `max ()` вызывается трижды: для двух значений типа `int`, для двух `double` и для двух [[string|std::string]]. Каждый раз вычисляется большее значение. В результате программа выводит следующую информацию:

![[templ_1.png]]

Обратите внимание на то, что в примере каждый вызов шаблона `max ()` предваряется двумя двоеточиями (`::`). Это вовсе не потому, что `max ()` находится в глобальном пространстве имен. Дело в том, что в стандартной библиотеке тоже есть шаблон `std::max()`, который может быть вызван при определенных обстоятельствах или способен привести к неоднозначности.

Шаблоны не компилируются в единую сущность, способную обработать любой тип данных. Вместо этого из шаблона генерируются различные объекты для каждого типа, для которого применяется шаблон. Таким образом, `max ()` компилируется для каждого из трех типов. Например, первый вызов `max ()`
```c++
int i = 42;
... max(7, i) ...
```

использует шаблон функции с `int` в качестве параметра шаблона `Т`. Таким образом, он имеет семантику вызова следующего кода:
```c++
int max(int a, int b) {
	return b < a ? a : b;
}
```

Процесс замены параметров шаблона конкретными типами называется инстанцированием шаблона (`instantiation`). Его результатом является экземпляр (`instance`) шаблона.

Отметим, что процесс инстанцирования запускается простым использованием шаблона функции. Специально требовать от компилятора инстанцирования шаблона не нужно.

Аналогично другие вызовы `max ()` инстанцируют шаблон `max` для `double` и [[string|std: :string]] точно так же, как если бы они были объявлены и реализованы отдельно:
```c++
double max(double, double);
std::string max(std::string, std::string);
```

Обратите также внимание: тип [[void|void]] является корректным аргументом шаблона при условии, что получающийся код корректен; например:
```c++
template<typename Т>
Т foo(T*) {
}

void* vp = nullptr;
foo(vp); // OK: выводится void foo(void*)
```

## Двухэтапная трансляция

Попытка инстанцирования шаблона для типа, который не поддерживает все используемые в нем операции, приведет к ошибке времени компиляции. Например:
```c++
std::complex<float> c1, с2;// Отсутствует оператор <

...

::max(c1, с2);// Ошибка времени компиляции
```

Таким образом, шаблоны “компилируются” в два этапа.

6. Во время определения (`definition time`) код шаблона проверяется на корректность без инстанцирования, с игнорированием параметров шаблонов. Этот процесс включает:
	* выявление таких синтаксических ошибок, как отсутствующие точки с запятой;
	* выявление применения неизвестных имен (имен типов, функций и т.п.), которые не зависят от параметров шаблона;
	* выполнение проверок статических утверждений, не зависящих от параметров шаблонов.
7. Во время инстанцирования код шаблона вновь проверяется на корректность. Таким образом, все части, которые зависят от параметров шаблонов, подвергаются двойной проверке.

Например:
```c++
template<typename Т>
void foo(T t) {
	undeclared();           // Если функция undeclared() неизвестна —
							// получаем ошибку первого этапа
	undeclared(t);          // Если функция undeclared(Т) неизвестна —
							// получаем ошибку второго этапа
	static_assert(sizeof(int) > 10,     // Сбой всегда при
			"int слишком мал");         // sizeof(int)<=10

	static_assert(sizeof(T) > 10,       // Сбой при инстанцировании
			"T too small");             // с типом Т, размер
										// которого <=10
```

Проверка имен, выполняемая дважды, называется двухэтапным (двухфазным) поиском (`two-phase`, `lookup`) и обсуждается в #разделе_14_3_1.

Обратите внимание на то, что некоторые компиляторы не выполняют полные проверки на первом этапе. Поэтому вы можете не разглядеть общие проблемы, пока код шаблона не будет инстанцирован хотя бы раз.

> **Компиляция и компоновка**

Двухэтапная трансляция вызывает важную проблему при практической работе с шаблонами: когда шаблон функции используется способом, запускающим его инстанцирование, компилятору (в определенный момент) потребуется определение этого шаблона. Это приводит к отходу от обычной практики, различающей компиляцию и компоновку для нешаблонных функций, когда объявления функции достаточно для компиляции кода с ее использованием. Методы решения этой проблемы обсуждаются в главе_9, “Применение шаблонов на практике”. Пока что будем использовать простой подход: реализовывать каждый шаблон в заголовочном файле.

# Вывод аргумента шаблона

При вызове с некоторыми аргументами такого шаблона функции, как `max ()`, параметры этого шаблона определяются передаваемыми в функцию аргументами. Если передать два значения `int`, компилятор делает вывод, что вместо `Т` следует подставить тип `int`.

Однако `Т` может быть только “частью” типа. Например, если мы объявим шаблон функции `max ()` как использующей константные ссылки:
```c++
template<typename Т>
Т max(T const& а, Т const& Ь)
	return b < а ? а : Ь;
}
```

и передадим значения типа `int`, то тип `Т` будет выведен как `int`, поскольку параметры функции будут соответствовать `int const&`.

**Преобразования типов в процессе вывода**

Обратите внимание на то, что автоматическое преобразование типов во время вывода типа ограничено.

* При объявлении вызова по ссылке при выводе типа не выполняются даже тривиальные преобразования. Два аргумента, объявленные с одним и тем же параметром шаблона `Т`, должны точно совпадать.
* При объявлении параметров по значению поддерживаются только тривиальные низводящие ([[decay|decay]]) преобразования: игнорируются квалификаторы [[const|const]] или [[volatile|volatile]], ссылки преобразуются в тип, на который они ссылаются, а обычные массивы или функции преобразуются в соответствующий тип указателя. Для двух аргументов, объявленных с одним и тем же параметром шаблона `Т`, низведенные типы должны совпадать.

Например:
```c++
template<typename Т>
Т max (Т а, Т b);

...

int i = 17;
int const с = 42;
max(i, с);              // OK: T выводится как int
max(с, с);              // OK: T выводится как int

int& ir = i;
max(i, ir);             // OK: Т выводится как int

int arr[4];
max(&i, arr);           // OK: Т выводится как int*
```

Однако следующий код вызывает ошибку времени компиляции:
```c++
max(4, 7.2);         // Ошибка: Т может быть выведен как int или double

std::string s;
max("hello", s);    // Ошибка: T может быть выведен как
					// char const[6] или std::string
```

Справиться с этими ошибками можно тремя способами.

8. Выполнить приведение аргументов, чтобы они соответствовали одному типу:
```c++
max(static_cast<double>(4), 7.2);          // OK
```

9. Явно указать (или квалифицировать) тип `Т` для того, чтобы предупредить выведение типа компилятором:
```c++
max<double>(4, 7.2);                       // OK
```

10. Указать, что параметры могут иметь разные типы.

Мы рассмотрим [[#Несколько параметров шаблона|эти варианты]]. В #разделе_7_2 и #главе_15, “Вывод аргументов шаблона”, правила преобразования при выведении типов будут описаны подробнее.

> **Вывод типов для аргументов по умолчанию**

Заметим также, что вывод типов не работает для аргументов по умолчанию. Например:
```c++
template<typename Т>
void f(T = "");

...

f(1); // OK: T выводится как int, так что вызывается f<int>(1)
f();  // Ошибка: невозможно вывести Т
```

Для поддержки такого применения вы должны также объявить [[#Аргументы шаблона по умолчанию|аргумент по умолчанию для параметра шаблона]]:
```c++
template<typename Т = std::string>
void f(Т = "");

...

f();  //OK
```

# Несколько параметров шаблона

До сих пор мы встречались с шаблонами с двумя различными наборами параметров.

11. Параметры шаблона, объявленные в угловых скобках перед именем шаблона функции:
```c++
template<typename Т> // Т — параметр шаблона
```

12. Параметры вызова, объявленные в круглых скобках после имени шаблона функции:
```c++
Т max(Т а, Т b)     // а и b — параметры вызова
```

Количество задаваемых параметров не ограничено. Например, можно определить шаблон `max ()` для двух потенциально различных типов данных:
```c++
template<typename T1, typename Т2>
Т1 max(T1 а, Т2 Ь) {
	return Ь < а ? а : Ь;
}

auto m = ::max(4, 7.2);         // OK, но тип первого аргумента
								// определяет возвращаемый тип
```

Может показаться желательным иметь возможность передавать шаблону `max ()` параметры различных типов, но, как демонстрирует пример, этот способ имеет свои недостатки. Если использовать один из типов параметров в качестве возвращаемого типа, аргумент другого параметра должен конвертироваться в этот же тип, независимо от намерений вызвавшего этот шаблон программиста. Таким образом, возвращаемый тип зависит от порядка аргументов вызова. Наибольшее из значений `66.66` и 42 будет `double` 66.66, в то время как наибольшим из значений 42 и 66.66 оказывается `int` 66.

C++ предоставляет различные способы решения этой проблемы.
* Ввести третий параметр шаблона для возвращаемого типа.
* Позволить компилятору самому определять возвращаемый тип.
* Объявить возвращаемый тип как “общий тип” двух типов параметров.

Все эти варианты будут рассмотрены далее.

## Параметр шаблона для возвращаемого типа

Итак, наше обсуждение показало, что вывод аргументов шаблона позволяет вызывать шаблоны функций с синтаксисом, идентичным вызову обычной функции: нам не нужно явно указывать типы, соответствующие параметрам шаблона.

Мы также упоминали, что можно явно указать типы, используемые как параметры шаблона:
```c++
template<typename Т>
Т max (Т а, Т b);

...

::max<double>(4, 7.2);           // Инстанцируем Т как double
```

В тех случаях, когда связи между параметрами шаблона и параметрами вызова нет, и нельзя определить параметры шаблона, необходимо явно указать аргумент шаблона при вызове. Например, можно ввести третий аргумент шаблона для определения возвращаемого типа шаблона функции:
```c++
template<typename T1, typename Т2, typename RT>
RT max(T1 a, T2 b);
```

Однако вывод аргумента шаблона не учитывает возвращаемый тип, a `RT` среди типов параметров вызова функции не появляется. Таким образом, тип `RT` не может быть выведен.

Как следствие, необходимо явно указать список аргументов шаблона. Например:
```c++
template<typename T1, typename Т2, typename RT>
RT max(T1 a, T2 b);

...

::max<int, double, double>(4, 7.2);  // OK, но утомительно
```

Пока что мы рассмотрели случаи, в которых либо явно указаны все аргументы шаблона функции, либо ни один из них. Другой подход заключается в явном указании только первых аргументов, позволяя компилятору вывести остальные. В общем случае необходимо указать все типы аргументов до последнего, который не может быть определен неявно. Таким образом, если изменить порядок параметров шаблона в нашем примере, вызывающему коду придется указать только тип возвращаемого значения:
```c++
template<typename RT, typename T1, typename T2>
RT max(T1 a, T2 b);

...

::max<double>(4, 7.2);      // OK: возвращаемый тип double,
							// типы T1 и T2 выведены
```

В этом примере вызов `max<double>` явно устанавливает тип `RT` как `double`, а параметры `Т1` и `Т2` выводятся на основании переданных значений аргументов как `int` и `double`.

Обратите внимание на то, что такая измененная версия функции `max ()` не приводит к значительным преимуществам. Для версии с одним параметром можно указать тип параметра (и возвращаемый тип), если переданы два аргумента разного типа. Таким образом, было бы хорошо сохранить простоту и использовать однопараметрическую версию функции `max ()` (как мы и поступим в следующих разделах при обсуждении других вопросов шаблонов).

Подробнее процесс вывода аргументов шаблона рассматривается в #главе_15, “Вывод аргументов шаблона”.`

## Вывод возвращаемого типа

Если тип возвращаемого значения зависит от параметров шаблона, для вывода возвращаемого типа проще и лучше позволить компилятору выяснить его самостоятельно. Начиная с C++14, это возможно — просто нужно не указывать никакой тип возвращаемого значения (но вам все равно придется объявить тип возвращаемого значения как [[Вывод типа auto|auto]]):
```c++
template<typename T1, typename T2>
auto max(T1 a, T2 b)
{
	return b < a ? a : b;
}
```

Фактически применение [[Вывод типа auto|auto]] для возвращаемого типа без соответствующего завершающего возвращаемого типа (`trailing return type`) (который вводится с помощью `->` в конце объявления функции) указывает, что возвращаемый тип должен быть выведен из операторов `return` в теле функции. Конечно, такой вывод типа возвращаемого значения из тела функции должен быть возможным. Таким образом, код функции должен быть доступен компилятору, а все операторы `return` в нем должны возвращать значения одного и того же типа.

До C++14 единственной возможностью позволить компилятору определить тип возвращаемого была реализация функции как часть ее объявления. В С++11 мы можем воспользоваться тем, что синтаксис завершающего возвращаемого типа позволяет использовать параметры вызова. То есть мы можем объявить, что возвращаемый тип является производным от того, что дает оператор `? ::`
```c++
template<typename T1, typename T2>
auto max(T1 a, T2 b) -> decltype(b < a ? a : b)
{
	return b < a ? a : b;
}
```

Здесь результирующий тип определяется правилами работы оператора `? :`, которые довольно сложны, но обычно дают интуитивно ожидаемый результат (например, если `а` и `b` имеют разные арифметические типы, то результат имеет соответствующий общий арифметический тип).

Обратите внимание на то, что
```c++
template<typename T1, typename Т2>
auto max(T1 а, Т2 b) -> decltype(b<a?a:b);
```

является объявлением, таким образом, компилятор использует правила работы оператора `?:`, вызванного для параметров `а` и `b`, чтобы выяснить тип возвращаемого значения функции `max ()` во время компиляции. Реализация функции не обязана в точности соответствовать объявлению. Например, применения значения `true` в качестве условия оператора `? :` в объявлении вполне достаточно:
```c++
template<typename T1, typename Т2>
auto max(T1 a, T2 b) -> decltype(true?a:b);
```

Однако в любом случае это определение имеет существенный недостаток: может случиться так, что возвращаемый тип является ссылочным, поскольку в некоторых условиях `Т` может быть ссылкой. По этой причине необходимо вернуть низведенный тип `Т`, который выглядит следующим образом:
```c++
#lnclude <type_traits>

template<typename T1, typename T2>
auto max(T1 a, T2 b)->typename std::decay<decltype(true?a:b)>::type
{
	return b < a ? a : b;
}
```

Здесь использовано свойство типа [[decay|std::decay<>]], которое возвращает результирующий тип как член `type`. Оно определяется в стандартной библиотеке в заголовочном файле `<type_traits>`. Поскольку член `type` является типом, для доступа к нему следует квалифицировать выражение с помощью ключевого слова `typename` (см. #раздел_5_1).

Обратите внимание на то, что инициализация типа [[Вывод типа auto|auto]] всегда низводится. Это также относится к возвращаемым значениям, когда возвращаемый тип указан как [[auto|auto]], [[auto|auto]] в качестве возвращаемого типа ведет себя как в следующем коде, в котором а объявлен как низведенный тип `i`, т.е. `int`:
```c++
int i = 42;
int const & ir = i; // ir ссылается на i
auto a = ir;        // а объявлена как новый объект типа int
```

## Возвращаемый тип как общий тип

Начиная с C++11, стандартная библиотека C++ предоставляет средства для указания “более общего типа”, [[common_type|std::common_type<>::type]] дает “общий тип” для двух (или больше) различных типов, переданных как аргументы шаблона. Например:
```c++
#include <type_traits>

template<typename T1, typename T2>
std::common_type_t<T1, T2> max(T1 a, T2 b) {
	return b < a ? a : b;
}
```

[[common_type|std::common_type]] является свойством типа, определенным в заголовочном файле `<type_traits>`, которое представляет собой структуру, член `type` которой является результирующим типом. Таким образом, оно используется следующим образом:
```c++
typename std::common_type<T1, T2>::type // Начиная с С++11
```

Поскольку, начиная с C++14, можно упростить применение такого рода свойств, добавляя `_t` к имени свойства и опуская `typename` и `::type` (см. подробное изложение в #разделе_2_8), определение возвращаемого типа превращается в
```c++
std::common_type_t<T1, Т2> // Эквивалентная запись С++14
```

Реализация [[common_type|std::common_type<>]] использует ряд сложных технологий программирования шаблонов, которые рассматриваются в #разделе_26_5_2. Внутренне этот шаблон выбирает согласно правилам языка результирующий тип оператора `? :` или использует специализации для определенных типов. Таким образом, и `::max(4, 7.2)`, и `::max(7.2, 4)` дают одно и то же значение 7.2 типа `double`. Обратите внимание на то, что [[common_type|std::common_type<>]] также низводится. 

# Аргументы шаблона по умолчанию

Можно также определить значения по умолчанию для параметров шаблона. Эти значения называются аргументами шаблона по умолчанию и могут использоваться с шаблонами любого вида. Они могут даже ссылаться на предыдущие параметры шаблона.

Например, если вы хотите объединить подходы для определения возвращаемого типа с возможностью иметь несколько типов параметров (как рассмотрено в предыдущем разделе), то вы можете ввести параметр шаблона `RT` для возвращаемого типа со значением по умолчанию, представляющим собой общий тип двух аргументов. Существует несколько возможностей.

13. Можно использовать оператор `? :` непосредственно. Однако, поскольку мы вынуждены применить оператор `? :` до объявления параметров вызова `а` и `b`, мы можем использовать только их типы:
```c++
#include <type_traits>

template <typename T1, typename T2,
			typename RT = std::decay_t<decltype(true ? T1() : T2())>>
RT max(T1 a, T2 b)
{
	return b < a ? a : b;
}
```

Обратите внимание на применение [[decay|std::decay_t<>]] для гарантии того, что не будет возвращена ссылка.

Обратите также внимание на то, что данная реализация требует возможности вызова конструкторов по умолчанию для передаваемых типов. Есть и другое решение, использующее [[declval#std declval|std::declval]], которое, однако, делает объявление еще более сложным (см. соответствующий пример в #разделе_11_2_3).

14. Можно использовать свойство типа [[common_type|std::common_type<>]] для указания значения по умолчанию для возвращаемого типа:
```c++
#include <type_traits>

template<typename T1, typename T2,
			typename RT = std::common_type_t<T1,T2>>
RT max(T1 a, T2 b)
{
	return b < a ? a : b;
}
```

И вновь обратите внимание на то, что [[common_type|std::common_type<>]] обеспечивает низведение типа, так что из функции не может быть возвращена ссылка.

В любом случае вы можете использовать значение возвращаемого типа по умолчанию:
```c++
auto а = ::mах(4, 7.2);
```

или явно указать возвращаемый тип после типов прочих аргументов:
```c++
auto b = ::max<double, int, long double>(7.2, 4);
```

Однако мы опять сталкиваемся с проблемой необходимости определения трех типов, чтобы иметь возможность указывать тип возвращаемого значения. Нам нужна возможность указать тип возвращаемого значения в качестве первого параметра шаблона, но при этом быть в состоянии вывести его из типов аргументов. В принципе можно иметь аргументы по умолчанию для ведущих параметров шаблона функции, даже если за ними следуют параметры без аргументов по умолчанию:
```c++
template<typename RT = long, typename T1, typename T2>
RT max(T1 a, T2 b)
{
	return b < a ? a : b;
}
```

С использованием этого определения можно выполнить следующие вызовы:
```c++
int i;
long l;

...

max(i, l);          // Возврат long (аргумент по умолчанию
					// параметра шаблона для возвращаемого типа)
max<int>(4, 42);    // Возврат явно указанного int
```

Однако этот подход имеет смысл, только если имеется некоторый “естественный” тип по умолчанию для параметра шаблона. В данном случае нам нужен аргумент по умолчанию, который зависит от предыдущих параметров шаблона. В принципе это возможно, как вы узнаете из #раздела_26_5_1, но этот метод зависит от свойств типов и усложняет определение.

По всем указанным причинам наилучшее и наиболее простое решение заключается в том, чтобы позволить компилятору [[#Вывод возвращаемого типа|вывести тип возвращаемого значения]].

# Перегрузка шаблонов функций





























