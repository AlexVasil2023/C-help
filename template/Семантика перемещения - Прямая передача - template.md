
# Прямая передача

Предположим, что нужно написать обобщенный код, который передает фундаментальные свойства передаваемых аргументов.
* Модифицируемый объект должен оставаться модифицируемым.
* Константный объект должен быть передан как объект, предназначенный только для чтения.
* Перемещаемый объект (из которого можно “украсть” его внутреннее содержимое за ненужностью) должен передаваться как перемещаемый объект.

Для достижения этой функциональности без шаблонов мы должны запрограммировать все три случая. Например, чтобы передать аргумент из вызова `f()` соответствующей функции `g()`, мы пишем:
```c++
#include <utility>
#include <iostream>

class X
{
	...
};

void g(X&)
{
	std::cout << "g() для переменной\п";
}

void g(X const&)
{
	std::cout << "g() для константы\п";
}

void g(X&&)
{
	std::cout << "g() для перемещаемого объекта\п";
}

// Передача функцией f() аргумента val в g():
void f(X& val)
{
	g(val);           // val - неконстантное lvalue => вызов g(X&)
}

void f(X const& val)
{
	g(val);           // val - константное lvalue => вызов g(X const&)
}

void f(X&& val)
{
	g(std::move(val));  // val - неконстантное lvalue =>
						// необходим std::move() для вызова g(X&&)
}

int main()
{
	X v;                // Создание переменной
	X const с;          // Создание константы
	
	f(v);               // Для неконстанты вызов f(X&) => g(X&)
	f(c);               // Для константы вызов f(X const&) => g(X const&)
	f(X());             // Для временного объекта вызов f(X&&) => g(X&&)
	f(std::move(v));    // Для перемещаемой переменной
						// вызов f(X&&) => g(X&&)
}
```

Здесь мы видим три различные реализации `f()`, передающие аргументы в `g()`:
```c++
void f(X& val)
{
	g(val);           // val - неконстантное lvalue => вызов g(X&)
}

void f(X const& val)
{
	g(val);           // val - константное lvalue => вызов g(X const&)
}

void f(X&& val)
{
	g(std::move(val));  // val - неконстантное lvalue =>
						// необходим std::move() для вызова g(X&&)
}
```

Обратите внимание на то, что код для перемещаемых объектов (работающий со ссылками на [[rvalue|r-значение (или просто r-ссылками))]] отличается от прочего кода: он должен использовать `std::move()`, потому что согласно правилам языка семантика перемещения не передается. Хотя `val` в третьей `f()` объявляется как [[rvalue|r-ссылка]], категория его значения при использовании в качестве выражения — неконстантное [[rvalue|l-значение]] (см. #приложение_Б, “Категории значений”), и оно ведет себя так же, как и `val` в первой `f()`. Без применения `move()` для неконстантных значений вместо `g(Х&&)` будет вызываться `g(Х&)`.

Если мы попытаемся объединить все три случая в обобщенном коде, то столкнемся с проблемой:
```c++
template<typename Т>
void f(Т& val)
{
	g(val);
}
```

Этот код работает для двух первых случаев, но не для третьего, когда передается перемещаемый объект.

По этой причине C++11 вводит специальные правила для прямой передачи (идеальной передачи, perfect forwarding) параметров. Идиоматическая схема кода имеет следующий вид:
```c++
template<typename Т>
void f(Т&& val)
{
	g(std::forward<T>(val));     // Прямая передача val в g()
}
```

Учтите, что `std::move()` не имеет шаблонного параметра и “запускает” семантику перемещения для передаваемого аргумента, в то время как [[forward|std::forward<>()]] “передает” потенциальную семантику перемещения в зависимости от переданного аргумента шаблона.

Не думайте, что `Т&&` для параметра шаблона `Т` ведет себя так же, как `Х&&` для конкретного типа `X`. Нет, здесь применяются разные правила! Однако синтаксически они выглядят одинаково.

* `Х&&` для конкретного типа `X` объявляет параметр как [[rvalue|r-ссылку]]. Она может быть связана только с перемещаемым объектом (pr-значением, таким как временный объект, и х-значением, таким как объект, переданный с использованием `std::move()`; подробности см. в #приложении_Б, “Категории значений”). Она всегда изменяема, и вы всегда можете “украсть” ее значение.
* `Т&&` для параметра шаблона `Т` объявляет передаваемую ссылку (forwarding reference), именуемую также универсальной ссылкой (universal reference). Она может быть связана с изменяемым, неизменяемым ([[const|const]]) или перемещаемым объектом. В определении функции параметр может быть изменяемым, неизменяемым или указывать на объект, у которого можно “украсть” внутреннее содержимое.

Обратите внимание на то, что `Т` в действительности должно быть именем параметра шаблона. Зависимости от параметра шаблона недостаточно. Для параметра шаблона `Т` объявление наподобие `typename Т::iterators &` представляет собой просто [[rvalue|r-ссылку]], а не передаваемую ссылку.

Таким образом, полностью программа для прямой передачи аргументов выглядит следующим образом:
```c++
#include <utility>
#include <iostream>

class X
{
	...
}

void g(X&)
{
	std::cout << "g() для переменной\п";
}

void g(X const&)
{
	std::cout << "g() для константы\п";
}

void g(X&&)
{
	std::cout << "g() для перемещаемого объекта\п";
}

// f() выполняет прямую передачу аргумента val в g():
template<typename Т>
void f(Т&& val)
{
	g(std::forward<T>(val)); // Вызов "правильной" g() для
	                         // любого аргумента val
}

int main()
{
	X v;            // Создание переменной
	X const с;      // Создание константы
	
	f(v);           // Для переменной вызывается f(X&) => g(X&)
	f(c);           // Для константы вызывается f(X const&) => g(X const&)
	f(X());         // Для временного значения вызывается f(X&&) => g(X&&)
	f(std::move(v));// Для перемещаемой переменной
					// вызывается f(X&&) => g(X&&)
}
```

Конечно же, прямая передача может также использоваться с вариативными шаблонами (см. примеры в #разделе_4_3). Подробнее прямая передача рассматривается в #разделе_15_6_3.

