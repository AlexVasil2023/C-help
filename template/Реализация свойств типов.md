
[[#Реализация свойств типов|Реализация свойств типов]] 19
1. [[#Пример суммирование последовательности|Пример: суммирование последовательности]] 19.1
	1. [[#Фиксированные свойства|Фиксированные свойства]] 19.1.1
	2. [[#Свойства-значения|Свойства-значения]] 19.1.2
	3. [[#Параметризованные свойства|Параметризованные свойства]] 19.1.3
2. [[#Стратегии и классы стратегий|Стратегии и классы стратегий]] 19.2
	1. [[#Различие между свойствами и стратегиями|Различие между свойствами и стратегиями]] 19.2.1
	2. [[#Шаблоны членов и шаблонные параметры шаблонов|Шаблоны членов и шаблонные параметры шаблонов]] 19.2.2
	3. [[#Комбинирование нескольких стратегий и/или свойств|Комбинирование нескольких стратегий и/или свойств]] 19.2.3
	4. [[#Накопление с обобщенными итераторами|Накопление с обобщенными итераторами]] 19.2.4
3. [[#Функции типов|Функции типов]] 19.3
	1. [[#Типы элементов|Типы элементов]] 19.3.1
	2. [[#Преобразующие свойства|Преобразующие свойства]] 19.3.2
	3. [[#Свойства-предикаты|Свойства-предикаты]] 19.3.3
	4. [[#Свойства типов результатов|Свойства типов результатов]] 19.3.4
4. [[SFINAE#Свойства на основе SFINAE|Свойства на основе SFINAE]] 19.4
	1. [[SFINAE#Принцип SFINAE и перегрузки функций|Принцип SFINAE и перегрузки функций]] 19.4.1
	2. [[SFINAE#SFINAE и частичные специализации|SFINAE и частичные специализации]] 19.4.2
	3. [[SFINAE#Применение обобщенных лямбда-выражений со SFINAE|Применение обобщенных лямбда-выражений со SFINAE]] 19.4.3
	4. [[SFINAE#SFINAE и свойства|SFINAE и свойства]] 19.4.4
5. [[IsConvertibleT#IsConvertibleT|IsConvertibleT]] 19.5
6. [[Обнаружение членов#Обнаружение членов|Обнаружение членов]] 19.6
	1. [[Обнаружение членов#Обнаружение членов-типов|Обнаружение членов-типов]] 19.6.1
	2. [[Обнаружение членов#Обнаружение произвольных членов-типов|Обнаружение произвольных членов-типов]] 19.6.2
	3. [[Обнаружение членов#Обнаружение членов, не являющихся типами|Обнаружение членов, не являющихся типами]] 19.6.3
	4. [[Обнаружение членов#Использование обобщенных лямбда-выражений для обнаружения членов|Использование обобщенных лямбда-выражений для обнаружения членов]] 19.6.4
7. [[#Прочие методы работы со свойствами|Прочие методы работы со свойствами]] 19.7
	1. [[#If-Then-Else|If-Then-Else]] 19.7.1
	2. [[#Обнаружение операций, не генерирующих исключения|Обнаружение операций, не генерирующих исключения]] 19.7.2
	3. [[#Повышение удобства свойств|Повышение удобства свойств]] 19.7.3
8. [[#Классификация типов|Классификация типов]] 19.8
	1. [[#Определение фундаментальных типов|Определение фундаментальных типов]] 19.8.1
	2. [[#Определение составных типов|Определение составных типов]] 19.8.2
	3. [[#Идентификация типов функций|Идентификация типов функций]] 19.8.3
	4. [[#Обнаружение типов классов|Обнаружение типов классов]] 19.8.4
	5. [[#Обнаружение типов перечислений|Обнаружение типов перечислений]] 19.8.5
9. [[#Свойства стратегий|Свойства стратегий]] 19.9



# Реализация свойств типов

Шаблоны дают возможность параметризовать классы и функции для различных типов. Кажется весьма заманчивым вводить столько параметров шаблонов, сколько нужно для того, чтобы настроить каждый аспект поведения типа или алгоритма. Таким образом, наши “шаблонизированные” компоненты могли бы быть реализованы так, чтобы удовлетворять любым потребностям пользовательского кода. Однако с практической точки зрения нежелательно вводить большое количество параметров шаблонов для их максимально возможной параметризации. Необходимость указания всех соответствующих аргументов в пользовательском коде чрезмерно утомительна, а каждый дополнительный параметр шаблона усложняет контракт между компонентом и его клиентом.

К счастью, оказывается, что большинству дополнительных параметров можно назначить приемлемые значения по умолчанию. В ряде случаев дополнительные параметры полностью определяются несколькими основными параметрами и по этому могут быть вообще опущены. Для других параметров могут быть заданы значения по умолчанию, зависящие от основных параметров, которые отвечают нуждам большинства ситуаций, но тем не менее в ряде случаев все же должны заменяться реальными значениями. Некоторые параметры оказываются не связанными с основными параметрами, и в этом смысле сами являются основными параметрами.

Свойства (traits), или шаблоны свойств, являются теми программными устройствами C++, которые значительно облегчают управление множеством дополнительных параметров, появляющихся при разработке мощных шаблонов. В этой главе приведен ряд ситуаций, в которых они доказывают свою несомненную эффективность, а также демонстрируются различные методы разработки мощных и надежных компонентов для ваших собственных программ.

Большинство представленных здесь свойств доступны в той или иной форме в стандартной библиотеке C++. Однако для ясности мы часто представляем упрощенные реализации, которые опускают некоторые детали, имеющиеся в реализациях промышленного уровня (как, например, в стандартной библиотеке). По этой причине мы также используем нашу собственную схему именования, которая, однако, легко отображается на стандартные свойства.

# Пример: суммирование последовательности

Вычисление суммы последовательности значений — довольно тривиальная вычислительная задача. Однако эта простая на вид задача может служить прекрасным примером использования классов стратегий и свойств на разных уровнях.

## Фиксированные свойства

Предположим для начала, что значения, сумму которых необходимо вычислить, хранятся в массиве, и нам заданы указатели на первый суммируемый элемент и на элемент, следующий за последним. Естественно, потребуется написать шаблон, который будет применим для различных типов. Приведенный ниже код может показаться вам очень простым.
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

template<typename T>
T accum(T const* beg, T const* end)
{
	T total{}; // Считаем, что создается нулевое значение
	while (beg != end)
	{
		total += *beg;
		++beg;
	}
	
	return total;
}
#endif // ACCUM_HPP
```

Здесь есть только один тонкий момент: как создать нулевое значение корректного типа для начала процесса суммирования. Мы используем здесь [[Инициализация нулем - template|инициализацию значением (с использованием записи с фигурными скобками)]]. Это означает, что объект `total` инициализируется либо с помощью своего конструктора по умолчанию, либо нулем (что означает [[nullptr_t#nullptr|nullptr]] для указателей и `false` для логических значений).

Рассмотрим теперь код, в котором используется наша функция `accum()`.
```c++
#include "accum1.hpp"
#include <iostream>

int main()
{
	// Создание массива из 5 целочисленных значений
	int num[] ={1, 2, 3, 4, 5 };

	// Вывод среднего значения
	std::cout << "Среднее значение для int равно "
				<< accum(num, num + 5) / 5 << '\n';
				
	// Создание массива символов
	char name[] = "templates";
	int length = sizeof(name) - 1;
	
	// (Пытаемся) вывести среднее значение
	std::cout << "Среднее значение для char в \""
				<< name << "\" равно "
				<< accum(name, name + length) / length
				<< '\n';
};
```

В первой половине этой программы `accum()` используется для суммирования пяти целочисленных значений:
```c++
int num[] = { 1, 2, 3, 4, 5 };

...

accum(num, num + 5);
```

После этого полученная сумма просто делится на количество значений в массиве, что дает нам целочисленное среднее значение.

Вторая половина программы пытается сделать то же самое для всех символов в слове `templates` (рассматривая символы от `а` до `z` как непрерывную последовательность в наборе символов, что справедливо для ASCII, но не для EBCDIC). По-видимому, результат вычисления должен находиться между значением `а` и значением `z`. В настоящее время на большинстве платформ эти значения определяются ASCII-кодами: символ `а` имеет код 97, а символ `z` — 122. Следовательно, можно предположить, что результат должен находиться где-то между `97` и `122`. Однако на нашем компьютере программа выводит следующее:
```
Среднее значение для int равно 3
Среднее значение для char в "templates" равно -5
```

Проблема заключается в том, что наш шаблон был инстанцирован для типа `char`, у которого оказался слишком маленький диапазон для накопления даже относительно небольших значений. Ясно, что можно было решить эту проблему, введя дополнительный параметр шаблона `АссТ`, описывающий тип, который используется для переменной `total` (и, соответственно, возвращаемый тип). Однако тем самым мы бы добавили дополнительную работу всем пользователям: они были бы вынуждены указывать этот тип при каждом обращении к шаблону; например, рассмотренный ранее код использовал бы следующий вызов функции:
```c++
accum<int>(name, name+5)
```

Это не столь существенное ограничение, но и его можно избежать.

Альтернативным по отношению к применению дополнительного параметра подходом является создание связи между каждым типом `Т`, для которого вызывается функция `accum()`, и типом, который будет использоваться для хранения накопленного значения. Эта связь может рассматриваться в качестве характеристики типа `Т`, и поэтому тип вычисляемой суммы иногда называется свойством (trait) `Т`. Эта связь может быть закодирована в виде специализации шаблона:
```c++
template<typename Т>
struct AccumulationTraits;

template<>
struct AccumulationTraits<char>
{
	using AccT = int;
};

template<>
struct AccumulationTraits<short>
{
	using AccT = int;
};

template<>
struct AccumulationTraits<int>
{
	using AccT = long;
};

template<>
struct AccumulationTraits<unsigned int>
{
	using AccT = unsigned long;
};

template<>
struct AccumulationTraits<float>
{
	using AccT = double;
};
```

Шаблон `AccumulationTraits` называется ***шаблоном свойств*** (traits template), поскольку он хранит свойство типа своего параметра. (В общем случае в шаблоне свойств может быть как несколько свойств, так и несколько параметров.) В данном случае обобщенного определения шаблона нет, так как нет хорошего способа для выбора подходящего типа накопления в случае неизвестного исходного типа. Однако можно считать, что таким типом может быть сам тип `Т`.

С учетом сказанного можно переписать наш шаблон `accum()`, как показано ниже:
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

#include "accumtraits2.hpp"

template<typename T>
auto accum(T const* beg, T const* end)
{
	// Возвращаемый тип является свойством типа элемента
	using АссТ = typename AccumulationTraits<T>::АссТ;
	АссТ total{); // Считаем, что создается нулевое значение

	while (beg != end)
	{
		total += *beg;
		++beg;
	}
	
	return total;
}

#endif // ACCUM_HPP
```

Вывод нашей программы становится таким, как мы и ожидали:
```
Среднее значение для int равно 3
Среднее значение для char в "templates" равно 108
```

В целом внесенные изменения не очень впечатляющи, хотя добавлен очень полезный механизм настройки нашего алгоритма. Кроме того, если появятся новые типы, предназначенные для использования с `accum()`, соответствующий тип `АссТ` может быть связан с ними посредством простого объявления дополнительной явной специализации класса `AccumulationTraits`. Обратите внимание на то, что эта операция может быть выполнена для любого типа: фундаментальных типов, типов, которые объявлены в других библиотеках, и т.д.

## Свойства-значения

До сих пор речь шла о том, что свойства предоставляют дополнительную информацию о типах, имеющую отношение к данному “основному” типу. В этом разделе показано, что такая дополнительная информация не ограничивается только типами. С типом могут быть связаны константы и другие классы значений.

Наш исходный шаблон `accum()` использует конструктор по умолчанию, возвращающий значение для инициализации переменной-результата значением, аналогичным нулевому:
```c++
АссТ total{}; // Считаем, что создается нулевое значение

...

return total;
```

Разумеется, нет никакой гарантии, что этот код обеспечивает подходящее значение, необходимое для запуска цикла накопления. Ведь тип `АссТ` может даже не иметь конструктора по умолчанию.

Но и в этом случае классы свойств могут спасти ситуацию. В данном примере можно добавить к нашему классу `AccumulationTraits` новое свойство-значение (value trait):
```c++
template<typename T>
struct AccumulationTraits;

template<>
struct AccumulationTraits<char>
{
	using AccT = int;
	static AccT const zero = 0;
};

template<>
struct AccumulationTraits<short>
{
	using AccT = int;
	static AccT const zero = 0;
};

template<>
struct AccumulationTraits<int>
{
	using AccT = long;
	static AccT const zero = 0;
};

...
```

В представленном фрагменте кода нашим новым свойством является константа `zero`, которая может быть вычислена в процессе компиляции. Ниже показано, какой вид принимает при этом функция `асcum()`:
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

#include "accumtraits3.hpp"

template<typename T>
auto accum(T const* beg, T const* end)
{
	// Возвращаемый тип является свойством типа элемента
	using AccT = typename AccumulationTraits<T>::AccT;
	
	// Инициализация total
	AccT total = AccumulationTraits<T>::zero; // значением свойства

	while (beg != end)
	{
		total += *beg;
		++beg;
	)
	
	return total;
}

#endif // ACCDM_HPP
```

В данном коде инициализация переменной для накопления результата остается очень простой:
```c++
АссТ total = AccumulationTraits<T>::zero;
```

Недостаток этого способа состоит в том, что C++ позволяет инициализировать статический константный член-данное внутри класса, только если он имеет целочисленный или перечислимый тип.

Статические [[constexpr|constexpr]] члены-данные являются несколько более обобщенными, допуская значения типов с плавающей точкой, а также иных литеральных типов:
```c++
template<>
struct AccumulationTraits<float>
{
	using Acct = float;
	static constexpr float zero = O.Of;
};
```

Однако ни [[const|const]], ни [[constexpr|constexpr]] не разрешают инициализировать таким путем нелитеральные типы. Например, пользовательский тип для вычислений с произвольной точностью `Biglnt` не может быть литеральным типом, поскольку он обычно должен выделять память для компонентов в динамической памяти, что препятствует литеральности его типа, или просто потому, что требуемый конструктор не является [[constexpr|constexpr]]. Поэтому следующая специализация является ошибкой:
```c++
class Biglnt
{
	Biglnt(long long);

	...
};

template<>
struct AccumulationTraits<BigInt>
{
	using AccT = Biglnt;
	static constexpr Biglnt zero =  // Ошибка:
						Biglnt(0);  // не литеральный тип
};
```

Простейший альтернативный способ состоит в том, чтобы не определять свойство-значение в классе.
```c++
template<>
struct AccumulationTraits<BigInt>
{
	using AccT = Biglnt;
	static Biglnt const zero;      // Только объявление
};
```

Затем инициализатор включается в исходный текст и выглядит примерно так:
```c++
Biglnt const AccumulationTraits<BigInt>::zero = Biglnt{O};
```

Хотя этот способ вполне работоспособен, он является более многословным (код должен быть добавлен в двух местах) и потенциально менее эффективным, поскольку компиляторам обычно ничего не известно об определениях в других файлах.

В C++17 эту проблему можно решить с использованием ***встраиваемых переменных*** (inline variables):
```c++
template<>
struct AccumulationTraits<BigInt>
{
	using AccT = Biglnt;
	inline static Biglnt const zero =
							Biglnt{0};  // OK, начиная с C++17
};
```

Альтернативой, которая работает до C++17, является использование встроенных функций-членов для значений свойств, которые не всегда дают целочисленные значения. Такая функция опять же может быть объявлена как [[constexpr|constexpr]], если она возвращает тип литерала.

Например, можно переписать `AccumulationTraits` следующим образом:
```c++
template<typename Т>
struct AccumulationTraits;

template<>
struct AccumulationTraits<char>
{
	using AccT = int;
	static constexpr AccT zero()
	{
		return 0;
	}
};

template<>
struct AccumulationTraits<short>
{
	using AccT = int;
	static constexpr AccT zero()
	{
		return 0;
	}
};

template<>
struct AccumulationTraits<int>
{
	using АссТ = long;
	static constexpr AccT zero()
	{
		return 0;
	}
};

template<>
struct AccumulationTraits<unsigned int>
{
	using AccT = unsigned long;
	static constexpr AccT zero()
	{
		return 0;
	}
};

template<>
struct AccumulationTraits<float>
{
	using AccT = double;
	static constexpr AccT zero()
	{
		return 0;
	}
};

...
```

После этого данные свойства можно расширить на наши собственные типы:
```c++
traits/accumtraits4bigint. hpp

template<>
struct AccumulationTraits<BigInt>
{
	using AccT = Biglnt;
	static Biglnt zero()
	{
		return Biglnt{0};
	}
};
```

В коде приложения при этом появляется единственное отличие — использование синтаксиса вызова функции вместо несколько более краткого доступа к статической переменной-члену класса:
```c++
АссТ total =                       // Инициализация total
	AccumulationTraits<T>::zero(); // функцией-свойством
```

Ясно, что свойства могут быть чем-то гораздо большим, нежели просто дополнительными типами. В нашем примере они могут быть механизмом, обеспечивающим функцию `accum()` всей необходимой информацией о типе элемента, для которого она вызвана. В этом состоит ключевой момент концепции свойств, а именно: свойства обеспечивают средства настройки конкретных элементов (обычно типов) для обобщенных вычислений.

## Параметризованные свойства

Использование свойств в `accum()`, показанное в предыдущих разделах, называется фиксированным, поскольку, как только будет определен отдельный класс свойств, его будет нельзя заменить в алгоритме; хотя бывают ситуации, когда такое переопределение желательно. Например, может оказаться, что набор значений типа `float` вполне можно суммировать в переменной этого же типа, а не `double`; к тому же это приведет к некоторому повышению эффективности.

Решить эту проблему можно, добавив параметр шаблона `АТ` со значением по умолчанию, определяемым нашим шаблоном свойств.
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

#include "accumtraits4.hpp"

template<typename T, typename AT = AccumulationTraits<T>>
auto accum(T const* beg, T const* end)
{
	typename AT::AccT total = AT::zero();
	
	while (beg != end)
	{
		total += *beg;
		++beg;
	}
	
	return total;
}

#endif // ACCUM_HPP
```

Таким образом, многие пользователи смогут просто опустить дополнительный аргумент шаблона, но те, у кого потребности выходят за стандартные рамки, смогут указать альтернативу предопределенному типу аккумулятора. Вероятно, большинству пользователей этого шаблона никогда не придется явно указывать второй параметр шаблона, поскольку его можно настроить так, чтобы он имел подходящее значение по умолчанию для каждого типа, выводимого из первого аргумента.

# Стратегии и классы стратегий

До сих пор речь шла о накоплении применительно к суммированию. Очевидно, что можно представить и другие виды накопления, а не только суммирование. Например, можно перемножать заданную последовательность значений. Или, если значения представляют собой строки, можно просто конкатенировать эти строки. Даже поиск максимального значения последовательности можно представить как задачу накопления. Во всех этих вариантах единственная операция `accum()`, которая должна измениться, — это `total+=*beg`. Эту операцию можно назвать стратегией (policy) нашего процесса накопления.

Вот пример того, как мы могли бы ввести такую стратегию в наш шаблон функции `accum()`:
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

#include "accumtraits4.hpp"
#include "sumpolicyl.hpp"

template<typename T,
		typename Policy = SumPolicy,
		typename Traits = AccumulationTraits<T>>
auto accum(T const* beg, T const* end)
{
	using AccT = typename Traits::AccT;
	AccT total = Traits::zero ();

	while (beg != end)
	{
		Policy::accumulate(total, *beg);
		++beg;
	}

	return total;
}

#endif // ACCUM_HPP
```

В этой версии функции `accum()` имеется класс `SumPolicy` — класс стратегии, т.е. класс, реализующий одну или несколько стратегий для алгоритма через согласованный интерфейс. `SumPolicy` может быть записан следующим образом:
```c++
#ifndef SUMPOLICY_HPP
#define SUMPOLICY_HPP

class SumPolicy
{
	public:
		template<typename T1, typename T2>
		static void accumulate(T1& total, T2 const& value)
		{
			total += value;
		}
};

#endif // SUMPOLICY_HPP
```

Указывая разные стратегии накопления значений, можно вычислять разные вещи. Рассмотрим, например, программу, с помощью которой предполагается определять результат произведения ряда значений:
```c++
#include "accum6.Ьрр"
#include <iostream>

class MultPolicy
{
	public:
		template<typename T1, typename T2>
		static void accumulate(T1& total, T2 const& value)
		{
			total *= value;
		}
};

int main()
{
	// Создание массива из 5 целочисленных значений
	int num[] = { 1, 2, 3, 4, 5 };
	
	// Вывод произведения всех значений
	std::cout << "Произведение всех значений равно "
				<< accum<int, MultPolicy>(num, num + 5)
				<< '\n';
}
```

Однако вывод программы окажется вовсе не тем, который ожидается:
```
Произведение всех значений равно О
```

Проблема вызвана нашим выбором начального значения: хотя значение 0 вполне пригодно при суммировании, оно не годится для умножения (нулевое начальное значение приводит к нулевому конечному результату). Этот пример иллюстрирует взаимодействие разных свойств и стратегий друг с другом, что еще раз подчеркивает, насколько важно быть аккуратным при проектировании шаблонов.

В данном случае легко понять, что инициализация цикла накопления — это часть стратегии накопления. Данная стратегия может использовать свойство `zero()` (но может и не воспользоваться им). Не следует забывать и о других вариантах решения задачи — далеко не все должно решаться только с помощью свойств и стратегий. Например, функция `accumulate()` стандартной библиотеки C++ получает начальное значение в качестве третьего аргумента функции.

## Различие между свойствами и стратегиями

Вполне логично предположить, что стратегии представляют собой частный случай свойств. И наоборот, можно утверждать, что свойства — просто закодированные стратегии.

Оксфордский словарь дает следующие определения:
>
> свойство — ...отличительная особенность, характеризующая сущность вещи;
> 
> стратегия — ..любой образ действия, принятый как полезный или целесообразный.

На основании этих определений мы вправе ограничить использование термина стратегия классами, которые кодируют определенные действия, слабо связанные с другими аргументами шаблона, с которым это действие связано. 
```
Стратегии имеют много общего со свойствами, но отличаются от них тем, что в них меньше внимания уделяется типам и больше — поведению.
```

```
Класс свойств — это класс, используемый вместо параметров шаблона. В качестве класса он объединяет полезные типы и константы; как шаблон, он является средством для обеспечения того “дополнительного уровня косвенности”, который решает все проблемы программного обеспечения.
```

Таким образом, мы можем использовать следующие (несколько расплывчатые) определения.
>
> Свойства представляют собой естественные дополнительные свойства параметра шаблона.
> 
> Стратегии представляют настраиваемое поведение обобщенных функций и типов (зачастую с некоторыми значениями по умолчанию).

Для дальнейшей конкретизации возможных различий между двумя этими концепциями перечислим ряд замечаний, касающихся свойств.
>
> Свойства могут быть использованы и как фиксированные свойства, т.е. без передачи их шаблону в качестве параметров.
> 
> Параметры свойств обычно имеют естественные значения по умолчанию (которые крайне редко переопределяются или попросту не могут быть переопределены).
> 
> Параметры свойств имеют тенденцию к сильной зависимости от одного или нескольких основных параметров.
> 
> Свойства обычно содержат типы и константы, а не функции-члены.
> 
> Свойства имеют тенденцию к агрегации в шаблоны свойств.

О классах стратегий также можно сделать несколько замечаний.
>
> Классы стратегий практически всегда передаются в качестве параметров шаблона.
> 
> Параметры стратегий не обязательно должны иметь значения по умолчанию и часто явно специализируются (хотя многие обобщенные компоненты обычно настраиваются с использованием стратегий, заданных по умолчанию).
> 
> Параметры стратегий обычно слабо связаны с другими параметрами шаблона.
> 
> Классы стратегий обычно объединяют функции-члены в единое целое.
> 
> Стратегии могут объединяться в обычных классах или в шаблонах классов.

Следует отметить, однако, что грань между обоими терминами весьма нечеткая. Например, свойства символов стандартной библиотеки C++ определяют также функциональное поведение, в частности сравнение символов, их перемещение и поиск. Заменяя эти свойства другими, можно определять строковые классы, которые ведут себя иначе, например нечувствительны к регистру символов при использовании того же символьного типа. Таким образом, называясь свойствами, они имеют ряд характеристик, присущих стратегиям.

## Шаблоны членов и шаблонные параметры шаблонов

Для реализации стратегии накопления был выбран вариант, в котором `SumPolicy` и `MultPolicy` представляли собой обычные классы с шаблонами членов. Другой вариант заключается в конструировании интерфейса класса стратегии с использованием шаблона класса, который затем применяется в качестве [[Шаблонные параметры шаблонов|шаблонного аргумента шаблона]] ([[Вглубь шаблонов#Шаблонные параметры шаблонов|см.]]). Например, можно переписать `SumPolicy` в виде шаблона.
```c++
#ifndef SUMPOLICY_HPP
#define SUMPOLICY_HPP

template<typename T1, typename T2>
class SumPolicy
{
	public:
		static void accumulate(T1& total, T2 const& value)
		{
			total += value;
		}
};

#endif // SUMPOLICY_HPP
```

Интерфейс класса `Accum` можно затем адаптировать для использования шаблонного параметра шаблона:
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

#include "accumtraits4.hpp"
#include "sumpolicy2.hpp"

template<typename T,
			template<typename, typename> class Policy = SumPolicy,
			typename Traits = AccumulationTraits<T>>
auto accum(T const* beg, T const* end)
{
	using AccT = typename Traits::AccT;
	AccT total = Traits::zero();
	
	while (beg != end)
	{
		Policy<AccT, T>::accumulate(total, *beg);
		++beg;
	}

	return total;
}

#endif // ACCUM_HPP
```

Такое же преобразование можно применить и к параметру-свойству. (Возможны и другие варианты: например, вместо явной передачи в стратегию типа `АссТ` может оказаться полезной передача свойств накопления, а стратегия при этом определяет тип результата из параметра свойства.)

Главное преимущество использования стратегий посредством шаблонных параметров шаблона — упрощение ситуации, когда класс стратегии содержит некоторую статическую информацию (статический член-данные) с типом, зависящим от параметров шаблона. (В нашем первом подходе статические члены-данные должны быть встроены в шаблон члена класса.)

Слабой стороной подхода с использованием шаблонных параметров шаблона является то, что классы стратегий должны быть написаны как шаблоны, с точным набором параметров шаблона, определяемых нашим интерфейсом. Это может сделать выражение самих свойств более многословным и менее естественным, чем простой нешаблонный класс.

## Комбинирование нескольких стратегий и/или свойств

Как показали наши примеры, и свойства, и стратегии не позволяют полностью избежать применения нескольких параметров шаблона. При этом, однако, они снижают их количество до вполне управляемого. Возникает интересный вопрос: каким образом упорядочить такие множественные параметры?

Простая стратегия состоит в упорядочении параметров согласно возрастанию вероятности выбора значения по умолчанию. Обычно это приводит к тому, что параметры свойств следуют за параметрами стратегий, поскольку они чаще переопределяются пользователями (возможно, вы уже заметили использование этого правила в наших примерах).

Для тех, кто все же склонен прибегать к значительному количеству параметров, тем самым существенно усложняя код, существует альтернатива, состоящая в задании параметров в любом порядке, без использования значений по умолчанию. Более подробно этот вопрос изложен в #разделе_21_4.

## Накопление с обобщенными итераторами

Прежде чем закончить введение в свойства и стратегии, рассмотрим еще одну версию `accum()`, которая позволяет работать с обобщенными итераторами вместо указателей, что и ожидается от обобщенного промышленного компонента. Интересно, что возможность вызова `accum()` с указателями при
этом остается, поскольку стандартная библиотека C++ обеспечивает использование так называемых свойств итераторов (iterator traits). Для этого можно переписать начальную версию `accum()` (опускаем при этом более поздние усовершенствования):
```c++
#ifndef ACCUM_HPP
#define ACCUM_HPP

#include <iterator>

template<typename Iter>
auto accum(Iter start, Iter end)
{
	using VT = typename std::iterator_traits<Iter>::value_type;
	VT total{}; // Считаем, что создается нулевое значение
	
	while (start != end)
	{
		total += *start;
		++start;
	}
	
	return total;
}

#endif // ACCUM_HPP
```

Структура `iterator_traits` инкапсулирует все существенные свойства итератора. Благодаря наличию частичной специализации для указателей эти свойства могут использоваться для любых обычных указателей. Ниже показано, как стандартная библиотека может реализовать эту поддержку:
```c++
namespace std
{
	template<typename Т>
	struct iterator traits<T*>
	{
		using difference_type = ptrdiff_t;
		using value_type      = T;
		using pointer         = T*;
		using reference       = T&;
		using iterator_category = random_access_iterator_tag;
	};
}
```

Однако типа для накопления значений, к которым обращается итератор, здесь нет, так что нам придется разрабатывать свой собственный класс `AccumulationTraits`.

# Функции типов

В первоначальном примере использования свойств показано, что можно задавать поведение, зависящее от типов. Это отличается от того, что мы обычно делаем в программах. В языках программирования С и C++ функции более точно можно назвать функциями значений (value functions): они принимают одни значения в качестве параметров и возвращают другое значение в качестве результата. При работе с шаблонами мы сталкиваемся с функциями типов (type functions), т.е. функциями, которые принимают некоторые аргументы типа и возвращают тип или константу в качестве результата.

Весьма полезной встроенной функцией типа является [[sizeof|sizeof]], которая возвращает константу, указывающую размер (в байтах) данного аргумента типа. Шаблоны классов также могут играть роль функций типа. Параметры функции типа — это параметры шаблона, а результат получается как тип-член или константа-член. Например, оператор [[sizeof|sizeof]] может быть использован с приведенным ниже интерфейсом:
```c++
#include <cstddef>
#include <iostream>

template<typename T>
struct TypeSize
{
	static std::size_t const value = sizeof (T);
};

int main()
{
	std::cout << "TypeSize<int>::value = "
				<< TypeSize<int>::value << '\n';
}
```

Это может показаться не очень полезным, поскольку у нас есть доступный встроенный оператор [[sizeof#sizeof|sizeof]], но обратите внимание на то, что `TypeSize<T>` является типом, и поэтому он может быть передан в качестве аргумента шаблона класса. Кроме того, `TypeSize<T>` — это шаблон, и он может быть передан в качестве шаблонного аргумента шаблона.

В дальнейшем мы разработаем несколько более универсальных функций типов, которые могут использоваться в качестве свойств.

## Типы элементов

Предположим, что у нас есть ряд шаблонов контейнеров, таких как [[vector|std::vector<>]], [[list|std::list<>]], а также встроенные массивы. Нам нужна функция типа, которая для данного типа контейнера возвращает тип его элементов. Этого можно достичь с помощью частичной специализации:
```c++
#include <vector>
#include <list>

template<typename T>
struct ElementT;                // Первичный шаблон

template<typename T>            // Частичная специализация
struct ElementT<std::vector<T>> // для std::vector
{
	using Type = T;
};

template<typename T>            // Частичная специализация
struct ElementT<std::list<T>>   // для std::list
{
	using Type = T;
};

...

template<typename T, std::size_t N> 
struct ElementT<T[N]>          // Частичная специализация для
{                              // массива с известными границами
	using Type = T;
};

template<typename T>          // Частичная специализация для
struct ElementT<T[]>          // массива с неизвестными границами
{
	using Type = T;
};

...
```

Учтите, что мы должны обеспечить [[Шаблоны для массивов и строковых литералов|частичную специализацию для всех возможных типов массивов]].

Функцию типа можно использовать следующим образом:
```c++
#include "elementtype.hpp"
#include <vector>
#include <iostream>
#include <typeinfo>

template<typename T>
void printElementType(T const& c)
{
	std::cout << "Контейнер из "
			<< typeid(typename ElementT<T>::Type).name()
			<< " элементов.\n";
}

int main()
{
	std::vector<bool> s;
	printElementType(s);
	
	int arr[42];
	printElementType(arr);
}
```

Использование частичной специализации позволяет реализовать эту функцию, не требуя, чтобы в типы контейнера были заложены сведения о ней. Зачастую, однако, функция типа разрабатывается вместе с соответствующими типами, так что ее реализация может быть существенно упрощена. Например, если типы контейнера определяют тип элемента `value_type` (как это делают стандартные контейнеры), то можно написать следующее:
```c++
template<typename С>
struct ElementT
{
	using Type = typename C::value_type;
);
```

Этот код может быть реализацией по умолчанию, что не исключает наличия специализаций для тех типов контейнеров, для которых не задан соответствующий тип элемента `value_type`.

Тем не менее обычно желательно обеспечить возможность определения типов для параметров шаблонов, чтобы к ним было легче обращаться в обобщенном коде. В следующем фрагменте кода представлен набросок этой идеи:
```c++
template<typename T1, typename Т2, ...>
class X
{
	public:
		using ... = T1;
		using ... = T2;
}
```

В чем заключается польза функции типа? Она позволяет параметризовать шаблон в терминах типа контейнера, не требуя при этом дополнительных параметров для типа элемента и других характеристик. Например, вместо
```c++
template<typename Т, typename С>
Т sumOfElements(С const& с);
```

(где требуется указание типа элемента в явном виде при помощи синтаксиса на подобие `sumOfElements<int> (list)`) можно объявить
```c++
template<typename С>
typename ElementT<C>::Туре sumOfElements(С const& с);
```

(где тип элемента определяется функцией типа).

Обратите внимание на то, что свойства могут быть реализованы как расширения существующих типов. Таким образом, функции типа можно определять даже для фундаментальных типов и типов из закрытых библиотек.

В данном случае тип `ElementТ` назван ***классом свойств*** (traits class), поскольку он используется для обращения к свойствам типа данного контейнера `С` (в общем случае в таком классе может быть собрано несколько свойств). Таким образом, классы свойств не ограничиваются описанием лишь характеристик параметров контейнера, но могут использоваться для описания любого вида “основных параметров”.

Для удобства можно создать шаблон псевдонима для типа функции. Например, можно ввести
```c++
template<typename Т>
using ElementType = typename ElementT<T>::Type;
```

что позволяет нам выполнить дальнейшее упрощение объявления `sumOfElements` до
```c++
template<typename С>
ElementType<C> sumOfElements(С const& с);
```

## Преобразующие свойства

Помимо предоставления доступа к конкретным аспектам типа основного параметра, свойства могут также выполнять преобразования типов, такие как добавление или удаление ссылок или квалификаторов [[const|const]] и [[volatile|volatile]].

***==Удаление ссылок==***

Например, можно реализовать свойство `RemoveReferenceT`, которое превращает ссылочные типы в лежащие в их основе типы объектов или функций, оставляя только типы, не являющиеся ссылочными:
```c++
template<typename T>
struct RemoveReferenceT
{
	using Type = T;
};

template<typename T>
struct RemoveReferenceT<T&>
{
	using Туре = Т;
};

template<typename Т>
struct RemoveReferenceT<T&&>
{
	using Type = T;
};
```

И вновь шаблоны псевдонимов упрощают использование:
```c++
template<typename Т>
using RemoveReference = typename RemoveReferenceT<T>::Type;
```

Удаление ссылки из типа обычно полезно, когда тип получен с помощью конструкции, которая иногда производит ссылочные типы, как, например, [[Вывод аргументов шаблона#Ссылки на r-значения|специальное правило вывода для параметров функции типа `Т&&`]].

Стандартная библиотека C++ предоставляет соответствующее свойство типа [[remove_reference#std remove_reference|std::remove_reference<>]].

***===Добавление ссылки===***

Аналогичным образом можно взять существующий тип и создать из него ссылку на [[значение - template|l-значение или на r-значение]] (вместе с обычным использованием шаблона псевдонима):
```c++
template<typename T>
struct AddLValueReferenceT
{
	using Type = T&;
};

template<typename T>
using AddLValueReference = typename AddLValueReferenceT<T>::Type;

template<typename T>
struct AddRValueReferenceT
{
	using Type = T &&;
};

template<typename T>
using AddRValueReference = typename AddRValueReferenceT<T>::Type;
```

Здесь применяются [[Вывод аргументов шаблона#Ссылки на r-значения|правила свертки ссылок]]. Например, вызов `AddLValueReference<int&&>` производит тип `int&` (поэтому нет необходимости их реализации вручную с помощью частичной специализации).

Если мы оставим `AddLValueReferenceT` и `AddRValueReferenceT` как есть и не будем вводить их специализации, то псевдонимы, используемые для удобства, на самом деле могут быть упрощены до
```c++
template<typename Т>
using AddLValueReferenceT = Т&;

template<typename Т>
using AddRValueReferenceT = Т&&;
```

которые могут быть инстанцированы без инстанцирования шаблона класса (тем самым облегчая дело). Однако это рискованно, если мы захотим специализировать этот шаблон для особых случаев. Например, при написанном выше коде мы не сможем использовать `void` в качестве аргумента для этих шаблонов. Для обработки такой ситуации требуется явная специализация:
```c++
template<>
struct AddLValueReferenceT<void>
{
	using Type = void;
};

template<>
struct AddLValueReferenceT<void const>
{
	using Type = void const;
};

template<>
struct AddLValueReferenceT<void volatile>
{
	using Type = void volatile;
};

template<>
struct AddLValueReferenceT<void const volatile>
{
	using Type = void const volatile;
};
```

Аналогичный код следует написать для `AddRValueReferenceT`.

При наличии такого кода удобные шаблоны псевдонимов должны быть сформулированы в терминах шаблонов классов для гарантии работоспособности специализаций (поскольку шаблоны псевдонимов не могут быть специализированы).

Стандартная библиотека C++ предоставляет соответствующие свойства типов `std::add_lvalue_reference<>`и `std::add_rvalue_reference<>`, описанные в #разделе_Г_4. Стандартные шаблоны включают специализации для типов `void`.

***===Удаление квалификаторов===***

Преобразующие свойства могут работать с любыми составными типами, а не только со ссылками. Например, можно удалить квалификатор [[const|const]], если таковой имеется в наличии:
```c++
template<typename T>
struct RemoveConstT
{
	using Type = T;
};

template<typename T>
struct RemoveConstT<T const>
{
	using Type = T;
};

template<typename T>
using RemoveConst = typename RemoveConstT<T>::Type;
``` 

Кроме того, преобразующее свойство может быть составным, как, например, свойство `RemoveCVT`, удаляющее и [[const|const]], и [[volatile|volatile]]:
```c++
#include "removeconst.hpp"
#include "removevolatile.hpp"

template<typename T>
struct RemoveCVT : RemoveConstT<typename RemoveVolatileT<T>::Type>
{
};

template<typename T>
using RemoveCV = typename RemoveCVT<T>::Type;
```

Следует отметить пару моментов в определении `RemoveCVT`. Оно использует как `RemoveConstT`, так и связанный с ним `RemoveVolatileT`, сначала удаляя квалификатор [[volatile|volatile]] (при наличии такового) и передавая результирующий тип в `RemoveConstT`. Затем свойство использует метафункционалъную передачу (metafunction forwarding) для наследования члена `Туре` из `RemoveConstT` вместо объявления собственного члена `Туре`, идентичного члену в специализации `RemoveConstT`. Здесь метафункциональная передача используется просто для того, чтобы уменьшить количество вводимого текста в определении `RemoveCVT`. Однако она также полезна, когда метафункция определена не для всех входных данных; эта техника будет рассматриваться в #разделе_19_4.

Используемый для удобства шаблон псевдонима `RemoveCV` можно упростить до
```c++
template<typename Т>
using RemoveCV = RemoveConst<RemoveVolatile<T>>;
```

И вновь, этот способ работает, только если шаблон `RemoveCVT` не специализируется. В отличие от случая `AddLValueRefеrenсе` и `AddRValueReference`, мы не можем придумать ни одной причины для таких специализаций.

Стандартная библиотека C++ предоставляет соответствующие свойства типов `std::remove_volatile<>`, `std::remove_const<>` и `std::remove_cv<>`,
описанные в #разделе_Г_4.

***===Низведение===***

Чтобы завершить нашу дискуссию о преобразующих свойствах, разработаем свойство, имитирующее преобразование типов при передаче аргументов в качестве параметров по значению. Это означает (наследуя `С`), что выполняется низведение аргументов ([[По значению или по ссылке - template#Работа со строковыми литералами и массивами|превращение массивов в указатели, а типов функций — в указатели на функции]]; [[Обобщенные библиотеки - template#Поддержка функциональных объектов|см.]]) и удаляются любые квалификаторы
const, volatile или ссылки верхнего уровня (поскольку квалификаторы типов
верхнего уровня у типов параметров при разрешении вызова функции игнори­
руются).

Эффект от такой передачи ио значению можно увидеть в следующей програм­
ме, которая выводит тип фактического параметра, полученного после того, как
компилятор низводит указанный тип:
```c++
#include <iostream>
#include <typeinfo>
#include <type_traits>

template<typename T>
void f(T)
{
}

template<typename A>
void printParameterType(void (*)(A))
{
	std::cout << "Тип параметра: "
				<< typeid(А).name() << ' \n';
	std::cout << "- является int: "
				<< std::is_same<A, int>::value << '\n';
	std::cout << "- является const: "
				<< std::is_const<A>::value << '\n';
	std::cout << "- является указателем: "
				<< std::is_pointer<A>::value << '\n';
}

int main()
{
	printParameterType(&f<int>);
	printParameterTypef&f<int const>);
	printParameterType(&f<int[7]>);
	printParameterType(&f<int(int)>);
}
```

В выводе программы параметр `int` остается неизменным, но параметры `int const`, `int[7]` и `int(int)` низводятся до `int, int*` и `int(*) (int)` соответственно.

Мы можем реализовать свойство, которое выполняет такое же преобразование типа, что и при передаче по значению. Для соответствия свойству [[decay|std::decay]] стандартной библиотеки C++ назовем его `DecayT`. Его реализация сочетает ряд описанных выше методов. Сначала мы определяем случай, в котором нет массива или функции, когда мы просто удаляем любой квалификатор [[const|const]] и [[volatile|volatile]]:
```c++
template<typename Т>
struct DecayT : RemoveCVT<T>
{
	...
};
```

Затем мы обрабатываем низведение массива к указателю, которое требует от нас распознавания массивов любого типа (с указанными границами или без таковых) с помощью частичной специализации:
```c++
template<typename Т>
struct DecayT<T[]>
{
	using Type = T*;
};

template<typename T, std::size_t N>
struct DecayT<T[N]>
{
	using Type = T*;
};
```

Наконец, мы обрабатываем низведение функции к указателю на функцию, которое должно соответствовать любому типу функции, независимо от типа возвращаемого значения или количества и типов параметров. Для этого мы используем вариативные шаблоны:
```c++
template<typename R, typename... Args>
struct DecayT<R(Args...)>
(
	using Type = R(*)(Args...);
);

template<typename R, typename... Args>
struct DecayT<R(Args..., ...)>
{
	using Type = R(*) (Args..., ...);
};
```

Обратите внимание на то, что вторая частичная специализация соответствует любому типу функции, использующей переменное количество аргументов в стиле С. Вместе первичный шаблон `DecayT` и четыре его частичных специализации реализуют низведение типа параметра, как показывает приведенный пример программы:
```c++
#include <iostream>
#include <typeinfo>
#include <type_traits>
#include "decay.hpp"

template<typename T>
void printDecayedType()
{
	using A = typename DecayT<T>::Type;
	std::cout << "Тип параметра: "
				<< typeid(A).name() << ' \n' ;

	std::cout << "- является int: "
				<< std::is_same<A, int>::value << ' \n';

	std::cout << "- является const: "
				<< std::is_const<A>::value << ' \n';
				
	std::cout << "- является указателем: "
				<< std::is_pointer<A>::value << ' \n';
}

int main()
{
	printDecayedType<int>();
	printDecayedType<int const>();
	printDecayedType<int[7]>();
	printDecayedType<int(int)>();
}
```

Как обычно, мы предоставляем удобный шаблон псевдонима:
```c++
template<typename Т>
using Decay = typename DecayT<T>::Type;
```

Как уже говорилось, стандартная библиотека C++ обеспечивает соответствующее свойство типа [[decay|std::decay<>]], описанное в #разделе_Г_4.

## Свойства-предикаты

До сих пор мы изучали и разрабатывали функции типов от одного типа: для данного одного типа функция предоставляет другой связанный с ним тип или константу. Однако в общем случае можно разработать функцию типа, которая зависит от нескольких аргументов. Это приводит также к особой форме свойств типа — предикатам (функциям типов, возвращающим логическое значение).

***===IsSameT===***

Свойство `IsSameT` проверяет, эквивалентны ли два типа:
```c++
template<typename T1, typename T2>
struct IsSameT
{
	static constexpr bool value = false;
};

template<typename T>
struct IsSameT<T, T>
(
	static constexpr bool value = true;
};
```

Здесь первичный шаблон определяет, что в общем случае два различных типа, передаваемые в качестве аргументов шаблона, отличны. Таким образом, значение члена `value` равно `false`. Однако с помощью частичной специализации для частного случая совпадения двух переданных типов `value` равно `true`.

Например, следующее выражение проверяет, является ли переданный параметр шаблона типом `int`:
```c++
if (IsSameT<T, int>::value) ...
```

Для свойств, дающих константное значение, мы не можем предоставить шаблон псевдонима, поможем предоставить шаблон [[constexpr|constexpr]]-переменной, играющей ту же роль:
```c++
template<typename T1, typename Т2>
constexpr bool isSame = IsSameT<T1, T2>::value;
```

Стандартная библиотека C++ предоставляет соответствующее свойство типа [[is_same|std::is_same<>]], которое описано в #разделе_Г_3_3.

***===true_type и false_type===***

Можно значительно улучшить определение `IsSameT`, предоставляя различные типы для двух возможных результатов, `true` и `false`. Фактически, если мы объявим шаблон класса `BoolConstant` с двумя возможными реализациями `TrueType` и `FalseType`:
```c++
template<bool val>
struct BoolConstant
{
	using Type = BoolConstant<val>;
	static constexpr bool value = val;
};

using TrueType = BoolConstant<true>;
using FalseType = BoolConstant<false>;
```

то мы можем определить `IsSameT` так, чтобы, в зависимости от соответствия двух типов, он был производным от `TrueType` или `FalseType`:
```c++
#include "boolconstant.hpp"

template<typename T1, typename T2>
struct IsSameT : FalseType
{
};

template<typename T>
struct lsSameT<T, T> : TrueType
{
};
```

Теперь результирующий тип выражения
```c++
IsSameT<T,int>
```

неявно конвертируется в базовый класс `TrueType` или `FalseType`, который не только предоставляет соответствующий член `value`, но также позволяет нам выполнять диспетчеризацию времени компиляции различным реализациям функции или частичным специализациям класса. Например:
```c++
#include "issame.hpp"
#include <iostream>

template<typename T>
void foolmpl(T, TrueType)
{
	std::cout << "foolmpl(T,true) для int\n";
}

template<typename T>
void fooImpl(T, FalseType)
{
	std::cout << "foolmpl(T,false) для не int\n";
}

template<typename T>
void foo(T t)
{
	fooImpl(t, IsSameT<T ,int>{});  // Выбор реализации в зависимости
									// от того, является ли Т - int'ом
}

int main()
{
	foo(42);   // Вызов fooImpl(42, TrueType)
	foo(7.7);  // Вызов foolmpl(7.7, FalseType)
}
```

Эта методика называется ***диспетчеризацией дескрипторов*** (tag dispatching) и рассматривается в #разделе_20_2.

Обратите внимание на то, что наша реализация `BoolConstant` включает член `Туре`, который вновь позволяет нам ввести шаблон псевдонима для `IsSameT`:
```c++
template<typename Т>
using IsSame = typename IsSameT<T>::Type;
```

Этот шаблон псевдонима может сосуществовать с шаблоном переменной `isSame`.

В общем случае свойства, дающие логические значения, должны поддерживать диспетчеризацию дескрипторов путем наследования таких типов, как `TrueType` и `FalseType`. Однако для максимальной обобщенности должен существовать только один тип, представляющий значение `true`, и один тип, представляющий значение `false`, вместо того, чтобы каждая обобщенная библиотека определяла собственные типы для логических констант.

К счастью, стандартная библиотека C++ обеспечивает соответствующие типы в заголовочном файле `<type_traits>`, начиная со стандарта С++11: `std::true_type` и `std::false_type`. В C++11 и С++14 они определены следующим образом:
```c++
namespace std
{
	using true_type = integral_constant<bool, true>;
	using false_type = integral_constant<bool, false>;
}
```

Начиная c C++17, они определены как
```c++
namespace std
{
	using true__type = bool_constant<true>;
	using false_type = bool_constant<false>;
}
```

где имя `bool_constant` определено в пространстве имен `std` следующим образом:
```c++
template<bool В>
using bool_constant = integral_constant<bool, В>;
```

(Подробности представлены в #разделе_Г_1_1.)

По этой причине в оставшейся части книги мы используем `std::true_type` и `std::false_type`, в особенности для определения предикатов типов.

## Свойства типов результатов

Еще одним примером функций типов, которые имеют дело с несколькими типами, являются ***свойства типа результата*** (result type traits). Они очень полезны при написании шаблонов операторов. Чтобы разобраться с идеей, давайте напишем шаблон функции, которая позволяет нам суммировать два контейнера [[Array|Array]]:
```c++
template<typename Т>
Array<T> operator+ (Array<T> const&, Array<T> const&);
```

Все выглядит неплохо, но, поскольку язык позволяет нам суммировать значение типа `char` со значением типа `int`, мы бы предпочли разрешить такие смешанные операции и с массивами тоже. Но тогда мы сталкиваемся с необходимостью определить тип возвращаемого значения такого шаблона
```c++
template<typename T1, typename Т2>
Array <??? > operator+ (Array<T1> const&, Array<T2> const&);
```

Помимо различных подходов, [[Шаблоны функций#Несколько параметров шаблона|шаблон типа результата]] позволяет нам заполнить вопросительные знаки в предыдущем объявлении следующим образом:
```c++
template<typename T1, typename Т2>
Array<typename PlusResultT<T1, T2>::Type>
operator+ (Array<T1> const&, Array<T2> const&);
```

или в предположении, что доступен удобный шаблон псевдонима,
```c++
template<typename T1, typename Т2>
Array<PlusResult<T1,Т2>> operator+(Array<T1>const&,Array<T2>const&);
```

Свойство `PlusResultT` определяет тип, генерируемый при сложении двух (возможно, различных) типов с помощью оператора `+`:
```c++
template<typename T1, typename T2>
struct PlusResultT
{
	using Type = decltype(T1() + T2());
};

template<typename T1, typename T2>
using PlusResult = typename PlusResultT<T1, T2>::Type;
```

Этот шаблон свойства использует [[decltуре|decltype]] для вычисления типа выражения `T1() +Т2()`, оставляя компилятору сложную работу по определению типа результата (включая обработку правил расширения и перегрузки операторов).

Однако для целей нашего примера [[decltуре|decltype]] в действительности сохраняет слишком много информации. Например, наша формулировка `PlusResultT` может дать ссылочный тип, но вряд ли наш шаблон класса `Array` предназначен для работы со ссылками. Более реалистично, что перегруженный оператор `operator+` может возвращать значение типа константного класса:
```c++
class Integer
{
	...
};

Integer const operator+ (Integer const&, Integer const&);
```

Сложение двух значений `Array<Integer>` дает в результате массив значений `Integer const`, который, скорее всего, представляет собой не то, что нам нужно. Фактически мы хотим преобразовать тип результата путем удаления ссылок и квалификаторов, как описано в предыдущем разделе:
```c++
template<typename T1, typename Т2>
Array<RemoveCV<RemoveReference<PlusResult<T1, Т2>>>>
operator+(Array<T1> const&, Array<T2> const&);
```

Такая вложенность свойств распространена в библиотеках шаблонов и часто используется в контексте метапрограммирования. Метапрограммирование будут подробно рассматриваться в #главе_23, “Метапрограммирование”. (Шаблоны псевдонимов особенно полезны при такой многоуровневой вложенности, как показанная. Без них нам бы пришлось добавлять [[typename|typename]] и суффикс `::Туре` на каждом уровне.)

В данный момент оператор сложения массивов правильно вычисляет тип результата при сложении двух массивов с, возможно, различными типами элементов. Однако наша формулировка `PlusResultT` добавляет нежелательные ограничения на типы элементов `Т1` и `Т2`: поскольку выражение `Т1()+Т2()` пытается выполнить инициализацию значением типов `Т1` и `Т2`, оба этих типа должны иметь доступный, не удаленный конструктор по умолчанию (или быть типами, не являющимися типами классов). Сам класс `Array` может не требовать наличия такой инициализации элементов, так что это ограничение оказывается излишним.

***===declval===***

К счастью, довольно легко получить значения для выражения с “+” без необходимости в конструкторе с помощью функции, которая производит значения данного типа `Т`. Для этого стандарт C++ предоставляет шаблон [[declval|std::declval<>]]. Он определен в заголовочном файле `<utility>` следующим образом:

Выражение `declval<T>()` создает значение типа `Т`, не требуя наличия конструктора по умолчанию (или любой иной операции).

Этот шаблон функции преднамеренно оставлен неопределенным, потому что он предназначен только для использования внутри [[decltуре|decltype]], [[sizeof|sizeof]] или в некоторых других контекстах, где не требуется определение. Он имеет два других интересных атрибута.
>
> Для типов, для которых может быть создана ссылка, тип возвращаемого значения всегда представляет собой ссылку на [[значение - template#r-значения|r-значение]] типа, что позволяет [[declval|declval]] работать даже с типами, которые обычно не могут быть возвращены из функции, как, например, тип абстрактного класса (класса с чисто виртуальными функциями) или тип массива. В противном случае преобразование из `Т` в `Т&&` не имеет практического влияния на поведение `declval<T>()` при использовании в качестве выражения: оба они являются [[значение - template|r-значениями]] (если `Т` является типом объекта), а ссылки на [[значение - template#l-значение|l-значение]] остаются неизменными благодаря [[Вывод аргументов шаблона#Ссылки на r-значения|свертке ссылок]].
>
> Спецификация исключений [[noexcept|noexcept]] документирует, что [[declval|declval]] сам по себе не требует рассматривать выражение как нечто, что может генерировать исключение. Это становится полезным при использовании [[declval|declval]] в контексте [[noexcept|noexcept]]-оператора ( #раздел_19_7_2).

Используя [[declval|declval]], можно убрать требование инициализации значением для `PlusResultT`:
```c++
#include <utility>

template<typename T1, typename T2>
struct PlusResultT
{
	using Type = decltype(std::declval<T1>() + std::declval<T2>());
};

template<typename T1, typename T2>
using PlusResult = typename PlusResultT<T1, T2>::Type;
```

Свойства типа результата предлагают способ для точного определения возвращаемого типа конкретной операции и часто полезны при описании типов результатов шаблонов функций.

# Свойства на основе SFINAE

[[SFINAE#Свойства на основе SFINAE|см. Свойства на основе SFINAE]]

# IsConvertibleT

[[IsConvertibleT#IsConvertibleT|см. IsConvertibleT]]

# Обнаружение членов

[[Обнаружение членов#Обнаружение членов|см. Обнаружение членов]]

# Прочие методы работы со свойствами

Давайте напоследок рассмотрим и обсудим иные возможные подходы к определению свойств.

## If-Then-Else

В предыдущем разделе окончательное определение свойства `PlusResultT` имело совершенно иную реализацию в зависимости от результата работы другого свойства типа, `HasPlusT`. Такое поведение в стиле “if-then-else” можно сформулировать с помощью специального шаблона типа `IfThenElse`, который принимает логический параметр шаблона для выбора одного из двух параметров типа:
```c++
#ifndef IFTHENELSE_HPP
#define IFTHENELSE_HPP

// Первичный шаблон: по умолчанию дает второй аргумент и
// использует частичную специализацию для получения
// третьего аргумента при COND равном false

template<bool COND, typename TrueType, typename FalseType>
struct IfThenElseT
{
using Туре = TrueType;
};

// Частичная специализация; false дает третий аргумент
template<typename TrueType, typename FalseType>
struct IfThenElseT<false, TrueType, FalseType>
{
	using Type = FalseType;
};

template<bool COND, typename TrueType, typename FalseType>
using IfThenElse = typename
		IfThenElseT<COND, TrueType, FalseType>::Type;

#endif // IFTHENELSE HPP
```

Приведенный ниже пример демонстрирует применение этого шаблона путем определения функции типа, которая выявляет для данного значения целочисленный тип наименьшего размера:
```c++
#include <limits>
#include "ifthenelse.hpp"

template<auto N>
struct SmallestlntT
{
	using Type =
	typename IfThenElseT<N<=std::numeric_limits<char>::max() , char,
	typename IfThenElseT<N<=std::numeric_limits<short>;:max(), short,
	typename IfThenElseT<N<=std::numeric_limits<int>::max(), int,
	typename IfThenElseT<N<=std::numeric_limits<long>::max(), long,
	typename IfThenElseT<N<=std::numeric_limits<long long>::max(),
			long long, // иначе
			void       // резервный вариант
        >::Type
        >:;Type
        >::Type
        >::Type
        >::Type;
};
```

Обратите внимание: в отличие от обычной конструкции “if-then-else” в С++ здесь до выполнения выбора вычисляются аргументы шаблона для обеих ветвей — и “then”, и “else”, так что ни одна ветвь не может содержать некорректный код, иначе программа будет ошибочной. Рассмотрим, например, свойство, которое дает беззнаковый тип, соответствующий данному знаковому типу. Существует стандартное свойство `std::make_unsigned`, которое делает такое преобразование, но оно требует, чтобы переданный тип был знаковым целочисленным типом и не был типом `bool`; в противном случае его использование приводит к неопределенному поведению (см. #раздел_Г_4). Поэтому может быть хорошей идеей реализация свойства, которое возвращает соответствующий беззнаковый тип, если это возможно, и переданный тип в противном случае (избегая тем самым неопределенного поведения при передаче неподходящего типа). Простейшая реализация не срабатывает:
```c++
// Ошибка: неопределенное поведение, если Т представляет
// собой bool или не является целочисленным типом:

template<typename Т>
struct UnsignedT
{
	using Type = IfThenElse<std::is_integral<T>::value
						&& !std::is_same<T, bool>::value,
						typename std::make_unsigned<T>::type, T >;
};
```

Инстанцирование `UnsignedT<bool>` демонстрирует неопределенное поведение, поскольку компилятор все равно будет пытаться образовать тип из
```c++
typename std::make_unsigned<T>::type
```

Для решения этой проблемы нам следует добавить дополнительный уровень косвенности, чтобы аргументы `IfThenElse` сами использовали функции типов для “завертывания” результата:
```c++
// Дает Т при использовании члена Туре:
template<typename Т>
struct IdentityT
{
	using Type = T;
};

// Для получения unsigned после вычисления IfThenElse:
template<typename Т>
struct MakeUnsignedT
{
	using Type = typename std::make_unsigned<T>::type;
};

template<typename T>
struct UnsignedT
{
	using Type = typename IfThenElse <std::is_integral<T>::value
								&& !std::is_same<T, bool>::value,
								MakeUnsignedT<T>, IdentityT<T>
                            >::Type;
};
```

В этом определении `UnsignedT` аргументами типа `IfThenElse` являются сами экземпляры функций типов. Однако фактически функции типов не вычисляются до того, как `IfThenElse` выберет нужную. Шаблон `IfThenElse` выбирает экземпляр функции типа (`MakeUnsignedT` или `IdentityT`). И только затем `::Туре` вычисляет экземпляр выбранной функции типа для создания `Туре`.

Стоит подчеркнуть, что здесь мы полностью полагаемся на тот факт, что отвергнутый тип оболочки в конструкции `IfThenElse` никогда не будет полностью инстанцирован. В частности, следующее решение не работает:
```c++
template<typename Т>
struct UnsignedT
{
	using Type = typename IfThenElse<std::is_integral<T>::value
						&& !std::is_same<T, bool>::value,
					MakeUnsignedT<T>::Type, T
                >;
};
```

Вместо этого мы должны применить `::Туре` к `MakeUnsignedT<T>` позже, что означает, что нам нужен вспомогательный шаблон `IdentityT`, чтобы затем применить `::Туре` в ветви `else`.

Это также означает, что в этом контексте мы не можем использовать код на подобие
```c++
template<typename Т>
using Identity = typename IdentityT<T>::Type;
```

Мы можем объявить такой шаблон псевдонима, и это может быть полезным в других местах, но мы не можем эффективно использовать его в определении `IfThenElse`, потому что любое использование `Identity<T>` немедленно приводит к полному инстанцированию `IdentityT<T>` для получения его члена `Туре`.

Шаблон `IfThenElseT` содержится в стандартной библиотеке C++ под именем [[conditional|std::conditional<>]] (см. #раздел_Г_5). С его помощью свойство `UnsignedT` может быть определено следующим образом:
```c++
template<typename Т>
struct UnsignedT
{
	using Type
		= typename std::conditional_t<std::is_integral<T>::value
									&& !std::is_same<T, bool>::value,
							MakeUnsignedT<T>, IdentityT<T>
                 >::Type;
};
```

## Обнаружение операций, не генерирующих исключения

Иногда оказывается полезно определить, может ли некоторая конкретная операция привести к исключению. Например, перемещающие конструкторы по возможности должны быть помечены как [[noexcept|noexcept]] в качестве указания, что они не генерируют исключений. Однако, генерирует перемещающий конструктор конкретное исключение или нет, часто зависит от того, генерируют ли исключения конструкторы его членов и базовых классов. Например, рассмотрим перемещающий конструктор для простого шаблона класса [[pair|Pair]]:
```c++
template<typename T1, typename Т2>
class Pair
{
		T1 first;
		T2 second;

	public:
		Pair(Pair&& other)
			: first (std::forward<T1>(other.first)),
			  second(std::forward<T2>(other.second))
		{
		}
};
```

Перемещающий конструктор [[pair|Pair]] может генерировать исключения, когда это могут делать операции перемещения `Т1` или `Т2`. Имея свойство `IsNothrowMove ConstructibleT`, мы могли бы выразить этот факт с помощью вычисленной спецификации исключений [[noexcept|noexcept]] в перемещающем конструкторе [[pair|Pair]]. Например:
```c++
Pair(Pair&& other) noexcept(IsNothrowMoveConstructibleT<T1>::value&&
							IsNothrowMoveConstructibleT<T2>::value)
	: first(std::forward<T1>(other.first)) ,
	  second(std::forward<T2>(other.second))
{
}
```

Нам остается лишь реализовать свойство `IsNothrowMoveConstructibleT`.
Это можно сделать непосредственно с помощью оператора [[noexcept|noexcept]], который определяет, является ли данное выражение гарантированно не генерирующим исключений:
```c++
#include <utility>      // Для declval
#include <type_traits>  // Для bool_constant

template<typename T>
struct IsNothrowMoveConstructibleT
	:std::bool_constant<noexcept(T(std::declval<T>()))>
{
};
```

Здесь используется операторная версия [[noexcept|noexcept]], которая определяет, является ли выражение не генерирующим исключений. Поскольку результатом является логическое значение, мы можем передать его непосредственно в определение базового класса, `std::bool_constant<>`, которое используется для [[Реализация свойств типов#Свойства-предикаты|определения std::true_type и std::false_type]].

Однако эта реализация должна быть улучшена, поскольку она не является дружественной по отношению к [[SFINAE#SFINAE и свойства|SFINAE]]: если это свойство инстанцируется с типом, который не имеет копирующего конструктора или перемещающего конструктора (делая выражение `T(std: :declval<T&&> ()`) не действительным), то вся программа оказывается некорректной:
```c++
class Е
{
	public:
		Е(Е&&) = delete;
};

... 

std::cout <<            // Ошибка времени компиляции:
	IsNothrowMoveConstructibleT<E>::value;
```

Вместо аварийного завершения компиляции свойство типа должно давать `value` со значением `false`.

[[SFINAE#SFINAE и свойства|Как было описано, мы должны проверить, допустимо ли выражение, вычисляющее результат, до его вычисления]]. Здесь мы должны выяснить, корректно ли перемещающее создание, до проверки, является ли оно [[noexcept|noexcept]]. Таким образом, мы пересматриваем первый вариант свойства, добавляя параметр шаблона, который по умолчанию равен [[void|void]], и частичную специализацию, которая использует [[void_t|std::void_t]] для параметра с аргументом, который действителен только в том случае, когда перемещающее конструирование является корректным:
```c++
#include <utility>     // Для declval
#include <type_traits> // для true_type, false_type и bool_constant<>

// Первичный шаблон:
template<typename T, typename = std::void_t<>>
struct IsNothrowMoveConstructibleT : std::false_type
{
};

// Частичная инициализация (может быть отброшена SFINAE):
template<typename Т>
struct IsNothrowMoveConstructibleT
<T, std::void_t<decltype(T(std::declval<T>()))>>
	:std::bool_constant<noexcept(T(std::declval<T>()))>
{
};
```

Если подстановка `std::void_t<...>` в частичной специализации является допустимой, выбирается эта специализация, и выражение `noexcept (...)` в спецификаторе базового класса может быть безопасно вычислено. В противном случае частичная специализация отбрасывается без ее инстанцирования, а вместо этого инстанцируется первичный шаблон (давая в результате `std::false_type`).

Обратите внимание на то, что нет никакого способа проверить, генерирует ли перемещающий конструктор исключение, без того, чтобы вызывать его напрямую. То есть недостаточно, чтобы перемещающий конструктор был открытым и не удаленным, требуется также, чтобы соответствующий тип не был абстрактным классом (ссылки или указатели на абстрактные классы отлично работают). По этой причине свойство типа называется `IsNothrowMoveConstructible` вместо `HasNothrowMoveConstructor`. Для чего-либо иного нам потребуется поддержка компилятора.

Стандартная библиотека C++ предоставляет соответствующее свойство типа [[is_move_constructible|std::is_move_constructible<>]].

## Повышение удобства свойств

Одной из распространенных жалоб, связанных со свойствами типов, является жалоба на их относительную многословность, поскольку каждое свойство типа обычно использует завершающую конструкцию `::Туре`, а в зависимом контексте — ведущее ключевое слово [[typename|typename]]; обе конструкции, по сути, являются стандартными вставками. Когда объединяются несколько свойств типа, это может привести к некрасивому и запутанному форматированию — как в нашем примере с оператором сложения для массивов, если мы бы корректно его реализовали, гарантируя, что он не возвращает ни константный, ни ссылочный типы:
```c++
template<typename T1, typename Т2>
Array <
	typename RemoveCVT <
		typename RemoveReferenceT <
			typename PlusResultT<T1, T2>::Type
        >::Type
    >::Type
>
operator+ (Array<T1> const&, Array<T2> const&);
```

С помощью шаблонов псевдонимов и переменных можно сделать использование свойств, дающих соответственно типы и значения, более удобным. Однако обратите внимание: в некоторых контекстах эти сокращения недоступны, и мы вынуждены использовать исходный шаблон класса. Мы уже обсуждали одну такую ситуацию в нашем примере `MemberPointerToIntT`, но ниже этот вопрос будет обсуждаться в более общем контексте.

***===Шаблоны псевдонимов и свойства===***

[[Шаблоны классов#Псевдонимы типов|Как говорилось, шаблоны псевдонимов предлагают способ для уменьшения многословия]]. Вместо того чтобы выразить свойство типа как шаблон класса с членом-типом `Туре`, можно использовать шаблон псевдонима. Например, три следующие шаблона псевдонимов используются как “обертки” для рассматривавшихся выше свойств типов:
```c++
template<typename Т>
using RemoveCV = typename RemoveCVT<T>::Type;

template<typename T>
using RemoveReference = typename RemoveReferenceT<T>::Type;

template<typename T1, typename T2>
using PlusResult = typename PlusResultT<T1, T2>::Type;
```

При наличии этих шаблонов псевдонимов можно упростить объявление нашего оператора `operator+` до
```c++
template<typename T1, typename Т2>
Array<RemoveCV<RemoveReference<PlusResultT<T1, Т2>>>>
operator+ (Array<T1> const&, Array<T2> const&);
```

Эта версия заметно короче предыдущей и яснее показывает состав свойства. Возможность таких усовершенствований делает шаблоны псевдонимов более подходящими для некоторых применений свойств типов.

Однако у применения шаблонов псевдонимов для свойств типов есть и недостатки.
>
> 1. [[Шаблоны Специализация и перегрузка#Явная специализация|Шаблоны псевдонимов нельзя специализировать]]; а поскольку многие методы написания свойств зависят от специализации, шаблон псевдонима, скорее всего, в любом случае будет необходимо перенаправлять шаблону класса.
> 2.  Некоторые свойства предназначены для специализации пользователями, например свойство, указывающее, является ли некоторая конкретная операция сложения коммутативной. Применение шаблонов псевдонимов может усложнять и запутывать специализацию шаблонов классов.
> 3. Использование шаблона псевдонима всегда будет инстанцировать тип (например, базовую специализацию шаблона класса), что усложняет [[Реализация свойств типов#If-Then-Else|устранение инстанцирования тех свойств, которые не имеют смысла для данного типа]].

Еще один способ сформулировать последний пункт — [[Реализация свойств типов#Преобразующие свойства|шаблоны псевдонимов не могут использоваться с метафункциональной передачей]].

Поскольку использование шаблонов псевдонимов для свойств типов имеет как положительные, так и отрицательные аспекты, мы рекомендуем применять их так, как показано в данном разделе и как это делается в стандартной библиотеке C++: предоставляя как шаблон класса с определенным соглашением по именованию (мы выбрали суффикс `Т` и член-тип `Туре`), так и шаблон псевдонима с несколько иным именованием (мы выбрали суффикс `Т`); каждый шаблон псевдонима определяется через соответствующий базовый шаблон класса. Таким образом, мы можем использовать шаблоны псевдонимов везде, где они обеспечивают более понятный код, но всегда можем вернуться к шаблонам классов для более сложного применения.

Обратите внимание на то, что в силу исторических причин стандартная библиотека C++ использует различные соглашения. Шаблоны классов свойств типов указывают тип в члене `type` и не имеют конкретных суффиксов (многие из них были введены в С++11). Соответствующие шаблоны псевдонимов (которые дают тип непосредственно) начали появляться в C++14 и получили суффикс `_t`, так как бессуффиксные имена уже были стандартизированы (см. #раздел_Г_1).

***==Шаблоны переменных и свойства==***

Свойства, возвращающие значение, для получения результата требуют завершающую конструкцию `::value` (или иной выбор члена). В этом случае [[Шаблоны переменных#Шаблоны переменных|снизить многословность можно с помощью constexpr шаблонов переменных]].

Например, приведенные ниже шаблоны переменных служат в качестве оболочек [[Реализация свойств типов#Свойства-предикаты|свойства IsSameT]], и [[IsConvertibleT#IsConvertibleT|свойства IsConvertibleT]]:
```c++
template<typename T1, typename Т2>
constexpr bool IsSame = IsSameT<T1, T2>::value;

template<typename FROM, typename T0>
constexpr bool IsConvertible = IsConvertibleT<FROM, T0>::value;
```

Теперь мы можем написать просто
```c++
if(IsSame<T,int> || IsConvertible<T,char>) ...
```

вместо
```c++
if(IsSameT<T,int>::value || IsConvertibleT<T,char>::value) ...
```

По историческим причинам стандартная библиотека C++ использует различные соглашения. Шаблоны классов свойств возвращают результат в члене `value` без определенного суффикса, и многие из них были введены в стандарте C++11. В стандарте C++17 введены соответствующие шаблоны переменных с суффиксом `_v`, которые дают результирующее значение непосредственно (см. #раздел_Г_1).

# Классификация типов

Иногда полезно иметь возможность знать, является ли параметр шаблона встроенным типом, типом указателя, класса и так далее. В следующих разделах мы разработаем набор свойств типов, которые позволят определять различные свойства конкретного типа. В результате мы сможем писать код, специфичный для некоторых конкретных типов:
```c++
if(IsClassT<T>::value)
{
	...
}
```

Или при использовании [[Программирование времени компиляции#Инструкция if времени компиляции|конструкции if времени компиляции]], доступной начиная с С++17 и [[Реализация свойств типов#Повышение удобства свойств|описанных выше средств повышения удобства свойств]]:
```c++
if constexpr(IsClass<T>)
{
	...
}
```

Или с использованием частичных специализаций:
```c++
template<typename Т, bool = IsClass<T>>
class С              // Первичный шаблон для общего случая
{
	...
};

template<typename Т>
class С<Т, true> // Частичная специализация для типов классов
{
	...
};
```

Кроме того, такие выражения, как `IsPointerT<T>::value`, будут логическими константами, которые могут быть корректными аргументами шаблонов, не являющимися типами. Это позволяет создавать более сложные и мощные шаблоны, которые специализируют свое поведение на основе свойств их типовых аргументов.

Стандартная библиотека C++ содержит несколько подобных свойств для определения основных и составных категорий типов. Подробная информация представлена в #разделах_Г_2_1 и #Г_2_2.

## Определение фундаментальных типов

Для начала давайте разработаем шаблон, позволяющий определить, является ли данный тип фундаментальным. По умолчанию полагаем, что тип не является фундаментальным, и специализируем шаблон для фундаментальных типов:
```c++
#include <cstddef>       // Для nullptr_t
#include <type_traits>   // Для true_type, false_type и bool_constant<>

// Первичный шаблон: в общем случае Т фундаментальным типом не является
template<typename Т>
struct IsFundaT : std::false_type
{
};

// Макрос для специализации для фундаментальных типов
#define MK_FUNDA_TYPE (Т)                                 \
template<> struct IsFundaT<T> : std::true_type {          \
};

MK_FUNDA_TYPE(void)
MK_FUNDA_TYPE(bool)
MK_FUNDA_TYPE(char)
MK_FUNDA_TYPE(signed char)
MK_FUNDA_TYPE(unsigned char)
MK_FUNDA_TYPE(wchar_t)
MK_FUNDA_TYPE(char16_t)
MK_FUNDA_TYPE(char32_t)

MK_FUNDA_TYPE(signed short)
MK_FUNDA_TYPE(unsigned short)
MK_FUNDA_TYPE(signed int)
MK_FUNDA_TYPE(unsigned int)
MK_FONDA_TYPE(signed long)
MK_FUNDA_TYPE(unsigned long)
MK_FUNDA_TYPE(signed long long)
MK_FUNDA_TYPE(unsigned long long)

MK_FUNDA_TYPE(float)
MK_FUNDA_TYPE(double)
MK_FUNDA_TYPE(long double)

MK_FUNDA_TYPE(std::nullptr_t)
#undef MK_FUNDA_TYPE
```

Первичный шаблон определяет общий случай, в котором `IsFundaT<T>::value` имеет значение `false`:

Для каждого фундаментального типа специализация определена так, что `IsFundaT<T>::value` равно `true`. Для удобства мы определили макрос, который раскрывается в необходимый код. Например,
```c++
MK_FUNDA_TYPE(bool)
```

раскрывается в следующий код:
```c++
template<> struct IsFundaT<bool> : std::true_type
{
	static constexpr bool value = true;
};
```

Приведенная ниже программа демонстрирует возможное использование этого шаблона:
```c++
#include "isfunda.hpp"
#include <iostream>

template<typename T>
void test(T consts)
{
	if (IsFundaT<T>::value)
	{
		std::cout << "Т - фундаментальный тип" << '\п';
	}
	else
	{
		std::cout << "Т - не фундаментальный тип" << '\п';
	}
}

int main()
{
	test (7);
	test("hello");
}
```

Вывод этой программы имеет следующий вид:
> 
> Т - фундаментальный тип
>
> Т - не фундаментальный тип

Аналогично можно определить функции типов `IsIntegralT` и `IsFloatingT`, чтобы выяснить, какие типы являются целочисленными скалярными, а какие — скалярными типами с плавающей точкой.

Стандартная библиотека C++ использует более мелкозернистый подход по сравнению с проверкой, является ли тип фундаментальным. Она сначала определяет основные категории типов, где каждый тип соответствует ровно одной категории типа (см. #раздел_Г_2_1), а затем — составные категории типов, такие как [[is_integral|std::is_integral]] или [[is_fundamental|std::is_fundamental]] (см. #раздел_Г_2_2).

## Определение составных типов

Составные типы являются типами, построенными из других типов. Простые составные типы включают типы указателей, ссылок на [[lvalue|l и на r-значение]], указателей на члены и массивов. Они построены из одного или двух базовых типов. Типы классов и типы функций также являются составными типами, но в их состав может входить произвольное количество типов (в виде параметров или членов). В этой классификации типы перечислений также рассматриваются как составные типы, не являющиеся простыми, несмотря на то, что они не являются составными из нескольких базовых типов. Простые составные типы могут быть классифицированы с использованием частичной специализации.

***===Указатели===***

Начнем с одной простой классификации типов указателей:
```c++
template<typename T>
struct IsPointerT 
	: std::false_type  // Первичный шаблон: по умолчанию не указатель
{
};

template<typename Т>
struct IsPointerT<T*> 
	: std::true_type  // Частичная специализация для указателей
{
	using BaseT = Т; // Тип, на который указывает указатель
};
```

Первичный шаблон представляет собой “ловушку” для всех типов, не являющихся указателем; как обычно, он предоставляет константу `value`, равную `false` (указывающую, что тип не является указателем), с использованием базового класса `std: :false_type`. Частичная специализация перехватывает указатели любого вида (`Т*`) и предоставляет константу `value`, равную `true`, говорящую о том, что данный тип является указателем. Кроме того, он предоставляет член-тип `BaseT`, который описывает тип, на который указывает рассматриваемый указатель. Обратите внимание: этот член-тип доступен только тогда, когда исходный тип является указателем, что делает это [[SFINAE#SFINAE и свойства|свойство типа дружественным по отношению к SFINAE]].

Стандартная библиотека C++ предоставляет соответствующее свойство типа [[is_pointer|std::is_pointer<>]], в котором, однако, не предусмотрен член для типа, на который указывает указатель. Оно описано в #разделе_Г_2_1.

***===Ссылки===***

Аналогично можно идентифицировать тип ссылки на [[rvalue|l-значение]]:
```c++
template<typename T>
struct IsLValueReferenceT 
	:std::false_type     //По умолчанию не ссылка на l-значение
{
};

template<typename Т>
struct IsLValueReferenceT<T&> 
	:std::true_type      // Ссылка на 1-значение
{
	using BaseT = Т;     // Тип, на который указывает ссылка
};
```

и тип ссылки на [[rvalue|r-значение]]:
```c++
template<typename Т>
struct IsRValueReferenceT 
	:std::false_type     // По умолчанию не ссылка на г-значение
{
};

template<typename Т>
struct IsRValueReferenceT <Т&&> 
	:std::true_type      // Ссылка на г-значение
{
	using BaseT = Т;     // Тип, на который указывает ссылка
};
```

Эти шаблоны можно объединить в свойство `IsReferenceT<>`:
```c++
#include "islvaluereference.hpp"
#include "isrvaluereference.hpp"
#include "ifthenelse.hpp"

template<typename T>
class IsReferenceT
	: public IfThenElseT<IsLValueReferenceT<T>::value,
						IsLValueReferenceT<T>,
						IsRValueReferenceT<T>
                     >::Type
{
};
```

В этой реализации мы используем для выбора в качестве базового класса `IsLValueReference<T>` или `IsRValueReference<T>` [[Реализация свойств типов#If-Then-Else|шаблон IfThenElseT]] с помощью [[Реализация свойств типов#Преобразующие свойства|метафункциональной передачи]]. Если `Т` представляет собой ссылку на [[rvalue|r-значение]], выполняется наследование от `IsLValueReference<T>`, чтобы получить соответствующее значение `value` и член `BaseT`. В противном случае выполняется наследование от `IsRValueReference<T>`, который определяет, является тип ссылкой на [[rvalue|r-значение]] или нет (и в любом случае предоставляет соответствующие члены).

Стандартная библиотека C++ предоставляет соответствующие свойства [[is_lvalue_reference|std::is_lvalue_reference<>]] и [[is_rvalue_reference|std::is_rvalue_reference<>]], описанные в #разделе_Г_2_1, и свойство [[is_reference|std::is_reference<>]], которое описано в #разделе_Г_2_2. Эти свойства не предоставляют член-тип, указывающий тип, на который указывает ссылка.

***===Массивы===***

При определении свойств для обнаружения массивов может оказаться неожиданным то, что частичные специализации используют больше параметров, чем первичный шаблон:
```c++
#include <cstddef>

template<typename T>
struct IsArrayT : std::false_type      // Первичный шаблон: не массив
{
};

template<typename Т, std::size_t N>
struct IsArrayT<T[N]> 
	: std::true_type             // Частичная специализация для массивов
{
	using BaseT = T;
	static constexpr std::size_t size = N;	
}

template<typename T>
struct IsArrayT<T[]> 
	: std::true_type            // Частичная специализация
{                               // для массивов без границ
	using BaseT = T;
	static constexpr std::size_t size = 0;
};
```

Здесь несколько дополнительных членов предоставляют сведения о классифицируемых массивах: их базовый тип и размер (с нулем, используемым для обозначения неизвестного размера).

Стандартная библиотека C++ для проверки, является ли тип массивом, предоставляет соответствующее свойство [[is_array|std::is_array<>]], которое описано в #разделе_Г_2_1. Кроме того, такие свойства, как [[rank|std::rank<>]] и [[extent|std::extent<>]], позволяют запрашивать количество измерений и размер конкретного измерения (см. #раздел_Г_3_1).

***===Указатели на члены===***

Обработка указателей на члены использует ту же технологию:
```c++
template<typename T>
struct IsPointerToMemberT 
	:std::false_type       // По умолчанию - не указатель на член
{
};

template<typename Т, typename С>
struct IsPointerToMemberT<T С::*> 
	:std::true_type         // Частичная специализация
{
	using MemberT = Т;
	using ClassT = С;
};
```

Здесь дополнительные члены предоставляют как тип члена, так и тип класса, в котором содержится рассматриваемый член.

Стандартная библиотека C++ предоставляет более конкретные свойства, [[is_member_object_pointer|std::is_member_object_pointer<>]] и [[is_member_function_pointer|std::is_member_function_pointer<>]], описанные в #разделе_Г_2_1, а также свойство [[is_member_object_pointer|std::is_member_pointer<>]], описанное в #разделе_Г_2_2.

## Идентификация типов функций

Типы функций интересны тем, что имеют произвольное количество параметров в дополнение к возвращаемому типу. Таким образом, в частичной специализации, соответствующей типу функции, мы используем пакет параметров для охвата всех типов параметров, как мы [[Реализация свойств типов#Преобразующие свойства|делали это в свойстве DecayT]]:
```c++
#include "../typelist/typelist.hpp"

template<typename T>
struct IsFunctionT 
	:std::false_type                 // Первичный шаблон: не функция
{
};

template<typename R, typename... Params>
struct IsFunctionT<R(Params...)> : std::true_type // Функции
{
	using Type = R;
	using ParamsT = Typelist<Params...>;
	static constexpr bool variadic = false;
};

template<typename R, typename... Params>
struct IsFunctionT<R(Params..., ...)> 
	: std::true type                              // Вариативные функции
{
	using Type = R;
	using ParamsT = Typelist<Params...>;
	static constexpr bool variadic = true;
}
```

Обратите внимание на то, что представлена каждая часть типа функции: `Туре` представляет тип результата, в то время как все параметры охватываются одним списком типов `ParamsT` (списки типов (`typelist`) рассматриваются в #главе_24, “Списки типов”), а член и `variadic` указывает, является ли рассматриваемый тип типом функции с переменным количеством аргументов в стиле языка С.

К сожалению, данная формулировка `IsFunctionT` не обрабатывает все функциональные типы, потому что типы функций могут иметь квалификаторы [[const|const]] и [[volatile|volatile]], а также квалификаторы ссылок на [[rvalue|l-значения (&) и r-значения (&&)]] и, начиная с С++17, квалификаторы [[noexcept|noexcept]]. Например:
```c++
using MyFuncType = void (int&) const;
```

Такие типы функций могут осмысленно использоваться только для нестатических функций-членов, но, тем не менее, остаются типами функций. Кроме того, типы функций, помеченные как [[const|const]], на самом деле не являются константными типами, так что [[RemoveConst|RemoveConst]] не может удалить [[const|const]] из типа функции. Таким образом, чтобы распознать типы функций, которые имеют квалификаторы, нам необходимо ввести большое количество дополнительных частичных специализаций, охватывающих все комбинации квалификаторов (как для функций с переменным количеством аргументов в стиле языка С, так и для функций, не являющихся таковыми). Здесь мы покажем только пять из множества необходимых частичных специализаций:
```c++
template<typename R, typename... Params>
struct IsFunctionT<R(Params...) const> : std::true_type
{
	using Type = R;
	using ParamsT = Typelist<Params...>;
	static constexpr bool variadic = false;
};

template<typename R, typename... Params>
struct IsFunctionT<R{Params..., ...) volatile> : std::true_type
{
	using Type = R;
	using ParamsT = Typelist<Params...>;
	static constexpr bool variadic = true;
};

template<typename R, typename... Params>
struct IsFunctionT<R(Params..., ...) const volatile> 
	:std::true_type
{
	using Type = R;
	using ParamsT = Typelist<Params...>;
	static constexpr bool variadic = true;
};

template<typename R, typename... Params>
struct IsFunctionT<R(Params..., ...)&> : std::true_type
{
	using Type = R;
	using ParamsT = Typelist<Params...>;
	static constexpr bool variadic = true;
};

template<typename R, typename... Params>
struct IsFunctionT<R(Params..., ...) const&> : std::true_type
{
	using Type = R;
	using ParamsT = Typelist<Params...>;
	static constexpr bool variadic = true;
};

...
```

Собрав все эти свойства, мы теперь можем классифицировать все типы, за исключением типов классов и типов перечислений. Мы рассмотрим эти случаи в следующих разделах.

Стандартная библиотека C++ предоставляет свойство [[is_function|std::is_function<>]], описанное в #разделе_Г_2_1.

## Обнаружение типов классов

В отличие от других составных типов, с которыми мы имели дело до сих пор, частичной специализации шаблонов, которые соответствуют конкретно типам классов, не существует. Не имеет смысла и перечисление всех типов классов, как это было сделано для фундаментальных типов. Вместо этого мы должны использовать косвенный метод для идентификации типов классов, применяя некоторый тип или выражение, которое является действительным для всех типов классов (но не для прочих типов). С помощью такого типа или выражения можно применить методы [[SFINAE#Свойства на основе SFINAE|свойств с использованием SFINAE]].

В этом случае наиболее удобным свойством типов классов является то, что только типы класса могут использоваться в качестве базовых типов в указателях на член. Таким образом, в конструкции типа вида `X Y:: * Y` может быть только типом класса. Следующая формулировка `IsClassT<>` использует это свойство (и выбирает `int` для типа `X` произвольным образом):
```c++
#include <type_traits>

template<typename T, typename = std::void_t<>>
struct IsClassT
	:std::false_type          // Первичный шаблон: по умолчанию не класс
{
};

template<typename Т>
struct IsClassT<T, std::void_t<int T::*>>  // Иметь указатель на
	:std::true_type                        // член могут только классы
{
};
```

Язык C++ определяет, что типом лямбда-выражения является “уникальный неименованный тип класса, не являющийся объединением". По этой причине лямбда-выражения дают `true` при выяснении, являются ли они объектами типа класса:
```c++
auto l = [] {};
static_assert<isClassT<decltype(1)>::value, "">; // Успешно
```

Заметим, что выражение `int Т::*` является корректным для типов [[union|union]] (которые согласно стандарту C++ также являются типами классов).

Стандартная библиотека C++ предоставляет свойства [[is_class|std::is_class<>]] и [[is_union|std::is_union<>]], которые описаны в #разделе_Г_2_1. Однако эти свойства требуют специальной поддержки компилятора, чтобы отличать типы `class` и `struct` от типов [[union|union]], что в настоящее время не может быть сделано с использованием стандартных методов языка.

## Обнаружение типов перечислений

Единственные типы, которые остались не классифицированными никакими из рассмотренных выше свойств, — это типы перечислений. Тестирование типов перечисления может быть выполнено непосредственно путем написания на основе [[SFINAE|SFINAE]] свойства, которое проверяет наличие явного преобразования в целочисленный тип (например, `int`) и явно исключает фундаментальные типы, типы классов, ссылочные типы, типы указателей и указателей на члены, которые могут быть преобразованы в целочисленный тип, но не являются перечислениями. Вместо этого мы просто заметим, что любой тип, который не попадает ни в одну из прочих категорий, должен быть типом перечисления, что мы можем реализовать следующим образом:
```c++
template<typename Т>
struct IsEnumT
{
	static constexpr bool value = !IsFundaT<T>::value &&
									!IsPointerT<T>::value &&
									!IsReferenceT<T>::value &&
									!IsArrayT<T>::value &&
									!IsPointerToMemberT<T>::value &&
									!IsFunctionT<T>::value &&
									!IsClassT<T>::value;
};
```

Стандартная библиотека C++ предоставляет свойство [[is_enum|std::is_enum<>]], которое описано в #разделе_Г_2_1. Обычно для улучшения производительности компиляции компиляторы обеспечивают непосредственную поддержку такого свойства вместо реализации его в качестве “чего-то иного”, как описано здесь.

# Свойства стратегий





















