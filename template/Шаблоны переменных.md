
# Шаблоны переменных

Начиная с C++14, переменные также могут быть параметризованы определенным типом. Это называется шаблоном переменной (variable template).

Например, можно использовать приведенный ниже код для определения значения `pi` и `e`, не определяя пока что тип этого значения:
```c++
template<typename Т>
constexpr Т pi{3.1415926535897932385};

template<class T>
constexpr T e  = T(2.7182818284590452353);
```

Заметим, что, как и для всех шаблонов, это объявление не может находиться в области видимости функции или блока.

Чтобы использовать шаблон переменной, необходимо указать ее тип. Например, следующий код использует две различные переменные в области видимости объявления` pi<>`:
```c++
std::cout << pi<double> << '\n';
std::cout << pi<float> << '\n';
```

Можно также объявить шаблоны переменных, которые используются в различных единицах трансляции:
```c++
// ===== header.hpp:

template<typename Т> Т val{};       // Инициализированное нулем значение
// ===== Единица трансляции 1:

#include "header.hpp"

int main()
{
	val<long> = 42;
	print();
}
// ===== Единица трансляции 2:

#include "header.hpp"
void print()
{
	std::cout << val<long> << '\n';  // OK: выводит 42
}
```

Шаблоны переменных могут иметь аргументы шаблона по умолчанию:
```c++
template<typename Т = long double>
constexpr Т pi = Т{3.1415926535897932385};
```

Можно использовать значение по умолчанию или значение любого иного типа:
```c++
std::cout << pi<> << ’ \n ’;            // Выводит long double
std::cout << pi<float> << '\n';         // Выводит float
```

Обратите, однако, внимание на то, что вы всегда должны использовать угловые скобки. Использование `pi` без таковых является ошибкой:
```c++
std::cout << pi << '\n';                // Ошибка
```

Шаблоны переменных могут быть параметризованы параметрами, не являющимися типами, которые могут также использоваться для параметризации инициализатора. Например:
```c++
#include <iostream>
#include <array>

template<int N>                  // Массив c N элементами,
	std::array<int, N> arr{};    // инициализированными нулем

template<auto N>                 // Тип dval зависит от
constexpr decltype(N) dval = N;  // переданного значения

int main()
{
	std::cout << dval<'c'> << '\n'; // N имеет значение 'с' типа char
	arr<10>[0] = 42;                // Первый элемент глобального arr

	// Цикл использует значения из arr
	for (std::size_t i = 0; i < arr<10>.size(); ++i)
	{
		std::cout << arr<10>[i] << '\n';
	}
}
```

И вновь обратите внимание: даже когда инициализация и итерирование `arr` происходит в различных единицах трансляции, используется одна и та же переменная `std::array<int, 10> arr` из глобальной области видимости.

> **Шаблоны переменных для данных-членов**

Одним из полезных применений шаблонов переменных является определение переменных, которые являются членами шаблона класса. Например, если шаблон класса определяется следующим образом
```c++
template<typename Т>
class MyClass
{
	public:
		static constexpr int max = 1000;
};
```

который позволяет определить различные значения для разных специализаций `MyClass<>`, то вы можете определить
```c++
template<typename Т>
int myMax = MyClass<T>::mах;
```

так что прикладные программисты могут просто писать
```c++
auto i = myMax<std::string>;
```

вместо
```c++
auto i = MyClass<std::string>::max;
```

Это означает, что для стандартного класса, такого как
```c++
namespace std
{
	template<typename Т> class numeric_limits
	{
		public:
			...
			
			static constexpr bool is_signed = false;

			...
	};
}
```

можно определить
```c++
template<typename T>
constexpr bool isSigned = std::numeric_limits<T>::is_signed;
```

чтобы иметь возможность писать
```c++
isSigned<char>
```

вместо
```c++
std::numeric_limits<char>::is_signed
```













# Конфигурации шаблонных классов C++11 #

Параметром шаблонного класса может быть пользовательский тип данных, который определяет локальные типы данных и константы. Рассмотрим конкретный пример:
```c++
struct config {
    enum { size = 10 } ;
    typedef char type;
};

template< typename Сonfig>
struct vector {
    Сonfig::type data[Сonfig::size];
};

vector<config> v;
```

Этот простейший пример показывает, что все параметры шаблонного класса могут быть свёрнуты в один. Тогда, для инстанциации шаблона необходимо определить структуру, покрывающую все зависимости шаблонного класса.




