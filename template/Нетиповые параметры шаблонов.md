
[[Нетиповые параметры шаблонов|Нетиповые параметры шаблонов]] 3
1. [[#Параметры шаблонов классов, не являющиеся типами|Параметры шаблонов классов, не являющиеся типами]] 3.1
2. [[#Параметры шаблонов функций, не являющиеся типами|Параметры шаблонов функций, не являющиеся типами]] 3.2
3. [[#Ограничения на параметры шаблонов, не являющиеся типами|Ограничения на параметры шаблонов, не являющиеся типами]] 3.3


# Нетиповые параметры шаблонов

Параметры шаблонов классов или функций не обязаны быть типами. Они могут быть и обычными величинами. В этом случае, как и для шаблонов с параметрами типа, программист создает код, в котором некоторые детали остаются открытыми до момента, когда этот код будет использоваться. Однако эти детали представляют собой не типы, а величины. При использовании такого шаблона эти величины требуется указать явно, после чего выполняется инстанцирование кода шаблона. В данной главе эта возможность продемонстрирована на примере новой версии шаблона класса стека. Кроме того, здесь приведен пример параметров шаблона функции, не являющихся типами, и рассмотрены некоторые ограничения применения этой технологии.

# Параметры шаблонов классов, не являющиеся типами

В отличие от примеров реализаций стека из предыдущих глав его можно реализовать и на базе массива с фиксированным размером, в котором будут храниться элементы. Преимущество этого метода состоит в сокращении расхода ресурсов на управление памятью, независимо от того, выполняет это управление программист или стандартный контейнер. Однако возникает другая проблема: какой размер для такого стека будет оптимальным? Если указать размер меньший, чем требуется, это приведет к переполнению стека. Если задать слишком большой размер, память будет расходоваться неэффективно. Напрашивается вполне резонное решение: оставить определение этого значения на усмотрение пользователя — он должен указать максимальный размер, необходимый для работы именно с его элементами.

Для этого определим размер в качестве параметра шаблона.
```c++
#include <array>
#include <cassert>

template<typename T, std::size_t Maxsize>
class Stack
{
	private:
		std::array<T, Maxsize> elems;     // Элементы
		std::size_t numElems;             // Текущее количество элементов

	public:
		Stack();                          // Конструктор
		void push(T const& elem);         // Добавление в стек
		void pop();                       // Снятие со стека
		Т consts top() const;             // Возврат верхнего элемента
		
		bool empty() const                // Проверка пустоты стека
		{
			return numElems == 0;
		}
		
		std::size_t sized const           // Текущее количество элементов
		{
			return numElems;
		}
};

template<typename T, std::size_t Maxsize>
Stack<T, Maxsize> ::Stack()
	: numElems(0)                         // Изначально элементов нет
{
	// Никаких действий
}

template<typename Т, std::size_t Maxsize>
void Stack<T, Maxsize> ::push(T const& elem)
{
	assert(numElems < Maxsize);
	elems[numElems] = elem;              // Добавление элемента
	
	++numElems;                          // Увеличение количества элементов
}

template<typename Т, std::size_t Maxsize>
void Stack<T, Maxsize>::pop()
{
	assert(!empty());
	--numElems;                         // Уменьшение количества элементов
}

template<typename T, std::size_t Maxsize>
T const& Stack<T, Maxsize>::top() const
{
	assert(!empty());
	return elems[numElems-1];            // Возврат последнего элемента
}
```

Новый второй параметр шаблона `Maxsize` имеет тип `int`. Он задает размер внутреннего массива элементов стека:
```c++
template<typename Т, std::size_t Maxsize>
class Stack
{
	private:
		std::array<T, Maxsize> elems; // Элементы
};
```

Кроме того, он используется в функции `push()` для проверки заполненности стека.
```c++
template<typename Т, std::size_t Maxsize>
void Stack<T, Maxsize>::push(T consts elem)
{
	assert(numElems < Maxsize);
	elems[numElems] = elem;           // Добавление элемента
	++numElems;                       // Увеличение количества элементов
}
```

Для того чтобы использовать этот шаблон класса, следует указать как тип элементов, так и максимальный размер стека.
```c++
#include "stacknontype.hpp"
#include <iostream>
#include <string>

int main()
{
	Stack<int, 20> int20Stack;          // Стек для 20 int
	Stack<int, 40> int40Stack;          // Стек ДЛЯ 40 int
	Stack<std::string, 40> stringStack; // Стек ДЛЯ 40 string

	// Работа co стеком для 20 int
	int20Stack.push(7);
	std::cout << int20Stack.top() << '\n';
	int20Stack.pop();
	
	// Работа co стеком для 40 строк
	stringStack.push("hello");
	std::cout << stringStack.top() << '\n';
	stringStack.pop();
}
```

Обратите внимание на то, что каждый экземпляр шаблона имеет свой собственный тип. Таким образом, `int20Stack` и `int40Stack` — это два различных типа. Преобразование этих типов один в другой — ни явное, ни неявное — не определено. Следовательно, нельзя использовать один тип вместо другого и нельзя присваивать значение одного из этих типов другому.

Остается добавить, что для параметров шаблона можно указать значения по умолчанию:
```c++
template<typename Т = int, std::size_t MaxSize = 100>
class Stack
{
	...
};
```

Однако с точки зрения хорошего дизайна это может не быть корректным решением в данном примере. Значения по умолчанию должны быть интуитивно корректны. Но ни тип `int`, ни максимальный размер, равный 100, не кажутся интуитивно корректными для типа обобщенного стека. Таким образом, будет лучше, если оба эти значения программист будет указывать явно, так что эти два атрибута всегда будут документированы в объявлении.

# Параметры шаблонов функций, не являющиеся типами

Можно также определить параметры, не являющиеся типами, и для шаблонов функций. Например, приведенный ниже шаблон функции определяет группу функций, предназначенных для добавления некоторого значения.
```c++
template<int Val, typename T>
T addValue(T x)
{
	return x + Val;
}
```

Функции такого вида могут быть полезны тогда, когда функции или операции используются в качестве параметров. Например, при работе со стандартной библиотекой шаблонов экземпляр этого шаблона функции можно использовать для добавления определенного значения к каждому элементу коллекции:
```c++
std::transform(source.begin(),
				source.end(),      // Начало и конец источника
				dest.begin(),      // Начало приемника
				addValue<5, int>); // Операция
```

Последний аргумент инстанцирует шаблон функции `addValue<>` для добавления 5 к переданному значению типа `int`. Получающаяся функция вызывается для каждого элемента исходной коллекции `source`, в процессе чего она преобразуется в целевую коллекцию `dest`.

Обратите внимание: вы должны указать аргумент `int` в качестве параметра `Т` шаблона `addValue<>`. Вывод работает только при непосредственном вызове, а алгоритму `std::transform()` требуется полный тип для вывода типа четвертого параметра. В языке нет поддержки подстановки/вывода только некоторых параметров шаблона с последующим рассмотрением и выводом прочих параметров.

Можно также указать, что параметр шаблона выводится из предыдущего параметра — например, чтобы получить тип возвращаемого значения из переданного параметра, не являющегося типом:
```c++
template<auto Val, typename Т = decltype(Val)>
T foo();
```

или чтобы гарантировать, что переданное значение того же типа, что и переданный тип:
```c++
template <typename Т, Т Val = Т{}>
Т bar();
```

# Ограничения на параметры шаблонов, не являющиеся типами



























