
[[#Разрешение перегрузки]] В
1. [[#Когда используется разрешение перегрузки|Когда используется разрешение перегрузки]] В.1
2. [[#Упрощенное разрешение перегрузки|Упрощенное разрешение перегрузки]] В.2
	1. [[#Неявный аргумент для функций-членов|Неявный аргумент для функций-членов]] В.2.1
	2. [[#Улучшение точного соответствия|Улучшение точного соответствия]] В.2.2
3. [[#Детали перегрузки|Детали перегрузки]] В.3
	1. [[#Предпочтение нешаблонных функций или более специализированных шаблонов|Предпочтение нешаблонных функций или более специализированных шаблонов]] В.3.1
	2. [[#Последовательности преобразований|Последовательности преобразований]] В.3.2
	3. [[#Преобразования указателей|Преобразования указателей]] В.3.3
	4. [[#Списки инициализаторов|Списки инициализаторов]] В.3.4
	5. [[#Функторы и функции-суррогаты|Функторы и функции-суррогаты]] В.3.5
	6. [[#Другие контексты перегрузки|Другие контексты перегрузки]] В.3.3

# Разрешение перегрузки

***===Разрешение перегрузки===*** — это процесс выбора функции, к которой обращается данное выражение вызова. Рассмотрим простой пример:
```c++
void display_num(int);        // #1
void display_num(double);     // #2

int main()
{
	display_num(399);         // #1 соответствует лучше, чем #2
	display_num(3.99);        // #2 соответствует лучше, чем #1
}
```

Принято говорить, что в этом примере имя функции `display_num()` перегружено. Когда это имя используется в вызове, компилятор C++ должен выбирать вызываемую функцию среди различных кандидатов с использованием дополнительной информации, главным образом о типах аргументов вызова. В нашем примере интуиция подсказывает целесообразность вызова `int`-версии, когда функция вызывается с целочисленным аргументом, и `double`-версии, когда используется аргумент с плавающей точкой. Формальный процесс попытки моделирования этого интуитивного выбора — это и есть процесс разрешения перегрузки.

Общие идеи, лежащие в основе принципов, регулирующих разрешение перегрузки, достаточно просты. Однако подробности их реализации значительно усложнились в процессе стандартизации C++. Эта сложность — в основном результат желания обеспечить поддержку реально существующих примеров, которые интуитивно кажутся человеку “наилучшим выбором”. Однако при формализации такого интуитивного выбора возникают различные тонкости.

В этом приложении достаточно подробно рассматриваются правила разрешения перегрузки. Однако этот процесс настолько сложен, что мы не можем претендовать на полноту охвата данной темы.

# Когда используется разрешение перегрузки

Разрешение перегрузки — это только одна часть процесса обработки вызова функции. В действительности разрешение перегрузки не является частью любого вызова функции. Во-первых, для вызовов с помощью указателей и вызовов
с помощью указателей на функции-члены не требуется разрешения перегрузки,
поскольку вызываемая функция полностью определена (во время работы про­
граммы) с помощью указателей. Во-вторых, макросы функционального вида
нельзя перегружать, поэтому они не попадают под действие разрешения пере­
грузки.

На очень высоком уровне вызов именованной функции может быть обработан
следующим образом:
> 
> Поиск имени создает начальное множество перегрузки.
> 
> При необходимости это множество может быть уточнено различными способами (например, путем вывода аргументов шаблонов и подстановкой, что может привести к отбрасыванию некоторых кандидатов — шаблонов функций).
> 
> Любая функция-кандидат, которая совсем не соответствует вызову (даже после учета неявных преобразований и аргументов по умолчанию), удаляется из множества перегрузки. В результате формируется множество так называемых жизнеспособных функций-кандидатов (`viable function candidates`).
> 
> Для поиска наилучшего кандидата выполняется разрешение перегрузки. Если таковой есть, выбираем его; в противном случае исход вызова неоднозначен.
> 
> Выбранный кандидат проверяется. Например, если это удаленная функция (определенная с использованием `=delete`) или недоступный закрытый член, выводится соответствующая диагностика).

Каждый из этих шагов имеет свои тонкости, однако можно утверждать, что разрешение перегрузки — самый сложный из них. К счастью, несколько простых принципов позволяют прояснить большинство ситуаций. Далее эти принципы будут подробно рассмотрены.

# Упрощенное разрешение перегрузки

Разрешение перегрузки располагает жизнеспособные функции-кандидаты по рангу путем сравнения того, насколько каждый аргумент вызова совпадает с соответствующим параметром кандидата. Один из кандидатов считается лучше другого, если любой из его параметров соответствует вызову не хуже, чем соответствующий параметр другого кандидата. Данный подход можно проиллюстрировать приведенным ниже примером:
```c++
void combine(int, double);
void combine(long, int);

int main()
{
	combine(1, 2); // Неоднозначность!
}
```

В этом примере вызов `combine()` неоднозначен, поскольку первый кандидат лучше соответствует первому аргументу (литерал `1` типа `int`), тогда как второй кандидат лучше соответствует второму аргументу. Можно утверждать, что `int` в некотором смысле ближе к `long`, чем к `double` (что поддерживает выбор в пользу второго кандидата). Однако C++ не пытается определить меру близости для нескольких аргументов вызова.

Для этого принципа необходимо указать, насколько хорошо данный аргумент совпадает с соответствующим параметром жизнеспособного кандидата. В первом приближении возможные соответствия можно расположить по рангу (от лучшего к худшему) так, как описано ниже.
1. Точное соответствие. Тип параметра совпадает с типом выражения, или его тип является ссылкой на тип выражения (возможно, с добавлением спецификаторов [[const|const]] и/или [[volatile|volatile]]).
2. Соответствие, достигаемое минимумом подгонок. Включает, например, низведение переменной массива к указателю на его первый элемент или добавление спецификатора [[const|const]] для обеспечения соответствия аргумента типа `int**` параметру типа `int const* const*`.
3. Соответствие, достигаемое расширением (`promotion`) типа. Расширение — это вид неявного преобразования, которое включает преобразование меньших целочисленных типов (таких как `bool`, `char`, `short`, и иногда перечислимых типов) в тип `int`, `unsigned int`, `long` или `unsigned long`, а также преобразование типа `float` в тип `double`.
4. Соответствие, достигаемое только за счет стандартного преобразования. Оно включает любой вид стандартного преобразования (например, типа `int` в тип `float`) или преобразование производного класса в один из его открытых однозначных базовых классов, но исключает неявный вызов оператора преобразования или конструктора преобразования.
5. Соответствие за счет преобразования, определяемого пользователем. Позволяет выполнять любой тип неявного преобразования.
6. Соответствие за счет многоточия (`...`) в объявлении функции. Параметр, подставляемый на место многоточия, может совпадать почти с любым типом. Однако имеется одно исключение: типы классов с нетривиальными копирующими конструкторами могут рассматриваться и как допустимые, и как недопустимые (реализация компилятора может их разрешать или запрещать).

Приведенный ниже запутанный пример иллюстрирует некоторые из этих соответствий.
```c++
int f1(int);        // #1
int f1(double);     // #2
f1(4);              // Вызов #1 : точное соответствие (#2 требует
					// применения стандартного преобразования)
int f2(int);        // #3
int f2(char);       // #4
f2(true);           // Вызов #3 : соответствие с расширением (#4 требует
					// более сильного стандартного преобразования)
class X
{
	public:
		X(int);
};

int f3(X);          // #5
int f3(...);        // #6
f3(7);              // Вызов #5 : соответствие с помощью пользовательского
					// преобразования (#6 требует соответствия многоточию)
```

Отметим, что разрешение перегрузки осуществляется после вывода аргумента шаблона, и этот вывод не учитывает все эти виды преобразований. Проиллюстрируем это на примере:
```c++
template<typename Т>
class MyString
{
	public:
		MyString(Т const*);     // Преобразующий конструктор

	...
};

template<typename Т>
MyString<T> truncate(MyString<T> const&, int);

int main()
{
	MyString<char> str1, str2;
	str1 = truncate<char>("Hello World", 5); // OK
	str2 = truncate("Hello World", 5); // Ошибка
}
```

Неявное преобразование, предусмотренное в преобразующем конструкторе, не учитывается при выводе аргумента шаблона. Присваивание `str2` не обнаруживает жизнеспособной функции `truncate()`, так что разрешение перегрузки не выполняется вообще.

В контексте вывода аргумента шаблона вспомним также, что ссылка на [[r-значение|r-значение]] на параметр шаблона может быть выведена либо как тип ссылки на [[r-значение#l-значение|l-значение]] (после свертки ссылок), если соответствующий аргумент представляет собой [[r-значение#l-значение|l-значение]], либо как тип ссылки на [[r-значение|r-значение]], если этот аргумент [[Вывод аргументов шаблона#Ссылки на r-значения|представляет собой r-значение]]. Например:
```c++
template<typename Т> void strange(Т&&, Т&&);
template<typename Т> void bizarre(T&&, double&&);

int main()
{
	strange(1.2, 3.4); // OK: T выводится как double
	double val = 1.2;
	strange(val, val); // OK: T выводится как double&
	strange(val, 3.4); // Ошибка: конфликт вывода
	bizarre(val, val); // Ошибка: l-значение не соответствует double&&
};
```

Изложенные принципы — это только первое приближение, но они охватывают очень много случаев. Однако имеется ряд распространенных ситуаций, которые нельзя адекватно объяснить этими правилами. Далее кратко обсуждаются самые важные уточнения этих правил.

## Неявный аргумент для функций-членов

Вызовы нестатических функций-членов имеют скрытый параметр, доступ к которому возможен в определении функции-члена как к `*this`. Для функции-члена класса `MyClass` скрытый параметр обычно имеет тип `MyClasss` (для функций-членов неконстантного типа) или `MyClass consts` (для функций-членов константного типа). Несколько удивляет то, что `this` имеет тип указателя. Лучше было бы сделать его эквивалентным параметру, который сейчас определен как `*this`. Однако `this` был частью первых версий языка C++ еще до того, как в нем появился ссылочный тип данных. К моменту введения этого типа данных было уже написано слишком много кода, который зависел от параметра `this`, являющегося указателем.

Скрытый параметр `*this` принимает участие в разрешении перегрузки точно так же, как и явные параметры. Почти всегда это вполне естественно, но иногда — неожиданно. В следующем примере приведен строковый класс, который работает не так, как ожидалось (такой код приходится видеть и в реальной жизни):
```c++
#include <cstddef>

class BadString
{
	public:
		BadString(char const*);

		...
		
		// Доступ к символу через индексацию:
		char& operator[](std::size_t);              // #1
		char const& operator[](std::size_t) const;
		
		// Неявное преобразование в строку в стиле С:
		operator char*();                           // #2
		operator char const* ();

		...
};

int main()
{
	BadString str("correkt");
	str[5] = 'с';     // Возможная неоднозначность перегрузки!
}
```

Вначале кажется, что в выражении `str[5]` нет ничего неоднозначного. Оператор индексации в строке `#1` выглядит совершенно корректно. Однако это не совсем так, поскольку аргумент `5` имеет тип `int`, а оператор ожидает целое число без знака (`size_t` и [[size#std size_t|std::size_t]] обычно имеют тип `unsigned int` или `unsigned long`, но никогда не `int`). При этом простое стандартное преобразование целочисленного типа легко делает `#1` жизнеспособным. Вместе с тем есть и другой жизнеспособный кандидат — встроенный оператор индексации. Действительно, если применить оператор неявного преобразования к типу `str` (который является неявным аргументом функции-члена), получится указатель.

И теперь можно применять встроенный оператор индексации. Этот встроенный оператор принимает аргумент типа `ptrdiff_t`, который на многих платформах эквивалентен `int`, и потому полностью соответствует аргументу `5`. Поэтому, даже если встроенный оператор индексации плохо соответствует неявному аргументу (с помощью пользовательского преобразования типов), это все же лучшее соответствие, чем оператор, определенный в `#1` для действительной индексации! Это источник потенциальной неоднозначности. Чтобы решить эту проблему для конкретной платформы, необходимо объявить оператор `[]` с параметром `ptrdiff_t` либо заменить неявное преобразование типа в `char*` явным (что обычно рекомендуется делать в любом случае, независимо от прочих моментов).

Множество жизнеспособных кандидатов может содержать как статические, так и нестатические члены. При сравнении статического члена с нестатическим качество соответствия неявных аргументов игнорируется (только нестатический член имеет неявный параметр `*this`).

По умолчанию нестатическая функция-член имеет неявный параметр `*this`, который имеет тип ссылки на [[r-значение#l-значение|l-значение]], но в С++11 введен синтаксис, позволяющий сделать его ссылкой на [[r-значение#r-значения|r-значение]]. Например:
```c++
struct S
{
	void f1();   // *this неявно является ссылкой на l-значение
	void f2()&&; // *this явно является ссылкой на r-значение
	void f3()&;  // *this явно является ссылкой на 1-значение
};
```

Как видно из этого примера, можно не только сделать неявный параметр ссылкой на [[r-значение#r-значения|r-значение]] (с помощью суффикса `&&`), но и подтвердить случай ссылки на [[r-значение#l-значение|l-значение]] (с помощью суффикса `&`). Интересно, что указание суффикса `&` не эквивалентно его отсутствию: старый частный случай позволяет [[r-значение#r-значения|r-значению]] связываться с ссылкой на [[r-значение#l-значение|l-значение]] для неконстантного типа, когда эта ссылка является традиционным неявным параметром `*this`, но этот (несколько опасный) частный случай не применим, если ссылка на [[r-значение#l-значение|l-значение]] была запрошена явно. Таким образом, при указанном выше определении `S`:
```c++
int main()
{
	S().f1();   // ОК: старое правило позволяет r-значению S()
				// соответствовать типу неявной ссылки на
				//l-значение S& параметра *this
				
	S().f2();   // ОК: г-значение S() соответствует типу ссылки
				// на r-значение параметра *this
	
	S().f3(); // Ошибка: r-значение S0 не может соответствовать
			  // явному типу ссылки на 1-значение параметра *this
}
```

## Улучшение точного соответствия

Для аргумента типа `X` имеется четыре типа параметров, которые дают точное соответствие: `X`, `Х&`, `X const&` и `Х&&` (`X const&&` также дает точное соответствие, но редко применяется). Однако чаще всего происходит перегрузка функции по двум видам ссылок. До C++11 это означало наличие перегрузок наподобие показанной:
```c++
void report(int&);             // #1
void report(int const&);       // #2

int main()
{
	for(int k = 0; k < 10; ++k)
	{
		report(k);             // Вызов #1
	}
	
	report(42);                // Вызов #2
}
```

Здесь версия без [[const|const]] предпочтительна для [[r-значение#l-значение|l-значений]], в то время как для [[r-значение#l-значение|r-значений]] годится только версия с [[const|const]].

С появлением ссылок на [[r-значение#l-значение|r-значения]] в С++11 требуется различать еще один распространенный случай двух точных соответствий, проиллюстрированных в следующем примере:
```c++
struct Value
{
	...
};

void pass(Value const&);    // #1
void pass(Value&&);         // #2
void g(X&& x)
{
	pass(x);                // Вызов #1, т.к. x является l-значением
	pass(X());              // Вызов #2, т.к. Х() является r-значением
							// (фактически - рr-значением)
	pass(std:move(x));      // Вызов #2, т.к. std::move(x) является
							// r-значением (фактически - х-значением)	
}
```

В этот раз версия, принимающая ссылку на [[r-значение#r-значения|r-значение]], рассматривается как имеющая лучшее соответствие для [[r-значение#r-значения|r-значений]], но не может соответствовать [[r-значение#l-значение|l-значениям]].

Обратите внимание на то, что это относится также к неявному аргументу вызова функции-члена:
```c++
class Wonder
{
	public:
		void tick();            // #1
		void tick() const;      // #2
		void tack() const;      // #3

		void run(Wonder& device)
		{
			device.tick();      // Вызов #1
			device.tack();      // Вызов #3, т.к. нет неконстантной
								// версии Wonder::tack()
		}
};
```

Наконец, следующее изменение нашего предыдущего примера показывает, что два точных соответствия также могут создать неоднозначность, если выполняется перегрузка со ссылкой и без нее:
```c++
void report(int);             // #1
void report(int&);            // #2
void report(int const&);      // #3

int main()
{
	for (int k = 0; k < 10; ++k)
	{
		report(k);            // Неоднозначность: #1 и #2
							  // подходят одинаково хорошо
	}

	report(42);               // Неоднозначность: #1 и #3
							  // подходят одинаково хорошо
}
```

# Детали перегрузки

Предыдущий раздел охватывает большую часть ситуаций перегрузки, которые встречаются в повседневном программировании на C++. К сожалению, есть еще очень много правил и исключений из этих правил — больше, чем было бы разумно включать в книгу, которая не посвящена перегрузке функций в C++. Тем не менее обсудим некоторые из них, поскольку они используются несколько чаще, чем другие правила, и с той степенью подробности, которая здесь имеет смысл.

## Предпочтение нешаблонных функций или более специализированных шаблонов

Если все прочие аспекты разрешения перегрузки равны, нешаблонная функция предпочтительнее экземпляра шаблонной функции (не имеет значения, сгенерирован экземпляр последней из определения обобщенного шаблона или же получен в результате явной специализации). Например:
```c++
template<typename Т> 
int f (Т);                    // #1

void f(int);                  // #2

int main()
(
	return f(7);              // Ошибка: выбрана функция #2,
							  //не возвращающая значения
}
```

Этот пример также ясно показывает, что разрешение перегрузки обычно не включает возвращаемый тип выбранной функции.

Однако при незначительных отличиях других аспектов разрешения перегрузки (например, различные квалификаторы [[const|const]] или ссылки) сначала применяются общие правила разрешения перегрузки. Это может случайно вызвать удивительное поведение, когда функции-члены определены как принимающие те же аргументы, что и [[Шаблоны Специализация и перегрузка#Шаблоны и нешаблоны|копирующие или перемещающие конструкторы]].

Если делается выбор из двух шаблонов, то предпочтение отдается более специализированному (при условии, что один из них более специализирован, чем другой). [[Шаблоны Специализация и перегрузка#Частичное упорядочение перегруженных шаблонов функций|Подробное объяснение этого подхода]]. Один частный случай такого предпочтения — когда два шаблона отличаются только тем, что один добавляет завершающий пакет параметров: шаблон без пакета параметров считается более специализированным, а потому является более предпочтительным, если он соответствует вызову. [[Вариативные шаблоны#Перегрузка вариативных и невариативных шаблонов|Пример этой ситуации]].

## Последовательности преобразований

Неявное преобразование в общем случае может быть последовательностью элементарных преобразований. Рассмотрим приведенный ниже код:
```c++
class Base
{
	public:
		operator short() const;
};

class Derived : public Base
{
};

void count(int);

void process(Derived const& object)
{
	count(object);              // Соответствие при использовании
								// пользовательского преобразования
}
```

Вызов `count(object)` работает, поскольку `object` может быть неявно преобразован в `int`. Однако это преобразование требует, чтобы были выполнены перечисленные ниже действия.
1. Преобразование `object` из `Derived const` в `Base const` (это преобразование [[r-значение#gl-значение|gl-значения]]; оно сохраняет идентичность объекта).
2. Пользовательское преобразование полученного объекта из типа `Base const` в тип `short`.
3. Расширение `short` до `int`.

Это наиболее общий вид последовательности преобразований: стандартное преобразование (в данном случае из производного типа в базовый), затем пользовательское преобразование, после чего другое стандартное преобразование. Хотя в последовательности может быть не более одного пользовательского преобразования, возможна также последовательность, в которую входят только стандартные преобразования.

Важный принцип разрешения перегрузки состоит в том, что если есть последовательность, являющаяся подпоследовательностью другой последовательности преобразований, то предпочтительнее использовать подпоследовательность. Так, если бы в рассмотренном примере имелась дополнительная функция-кандидат
```c++
void count(short)
```

то она была бы предпочтительнее из-за отсутствия необходимости третьего пункта (расширения типа) в последовательности преобразований.

## Преобразования указателей

Указатели и указатели на члены класса могут подвергаться различным специальным стандартным преобразованиям, включая следующие:
>
> преобразования в тип `bool`;
> 
> преобразования из типа произвольного указателя в тип `void*`;
> 
> преобразования указателей на производный тип в указатель на базовый тип;
> 
> преобразования указателей на члены базового класса в указатели на члены производного класса.

Хотя все они могут обеспечивать “соответствие за счет только стандартных преобразований", ранг у них разный.

Прежде всего, преобразование в тип `bool` (как из обычного указателя, так и из указателя на член класса) считается менее предпочтительным, чем любой другой стандартный тип преобразования. Например:
```c++
void check(void*);          // #1
void check(bool);           // #2
void rearrange(Matrix* m)
{
	check(m);               // Вызов #1

	...
}
```

В категории преобразований обычных указателей преобразование в тип `void*` считается менее предпочтительным, чем преобразование из указателя на производный класс в указатель на базовый класс. Кроме того, если есть указатели на различные классы, связанные наследованием, то предпочтительнее преобразование в указатель на наиболее производный (т.е. ближайший базовый) класс.

Приведем небольшой пример:
```c++
class Interface
{
	...
};

class CommonProcesses : public Interface
{
	...
};

class Machine : public CommonProcesses
{
	...
);

char* serialize(Interface*);            // #1
char* serialize(CommonProcesses*);      // #2

void dump(Machine* machine)
{
	char* buffer = serialize(machine); // Вызывает #2

	...
}
```

Преобразование из `Machine*` в `CommonProcesses*` предпочтительнее, чем преобразование в `Interface*`, что вполне понятно интуитивно.

Схожее правило применяется к указателям на члены класса: из двух преобразований типов указателей на члены классов, связанных наследованием, предпочтительнее преобразование к “ближайшему базовому классу” в диаграмме наследования.

## Списки инициализаторов

Аргументы списка инициализаторов (инициализаторы, передаваемые в фигурных скобках) могут быть преобразованы в несколько различных видов параметров: [[initializer_list|initiаlizer_list]], классовые типы с конструктором c [[initializer_list|initiаlizer_list]], классовые типы, для которых элементы списка инициализаторов могут рассматриваться как (отдельные) параметры конструктора, или агрегатные классовые типы, члены которых могут быть инициализированы элементами списка инициализаторов. Следующая программа иллюстрирует эти случаи:
```c++
#include <initializer_list>
#include <string>
#include <vector>
#include <complex>
#include <iostream>

void f(std::initializer_list<int>)
{
	std::cout << "#1\n";
}

void f(std::initializer_list<std::string>)
{
	std::cout << "#2\n";
}

void g(std::vector<int> const& vec)
{
	std::cout << "#3\n";
}

void h(std::complex<double> const& cmplx)
{
	std::cout << "#4\n";
}

struct Point
{
	int х, у;
};

void i(Point const& pt)
{
	std::cout << "#5\n";
}

int main()
{
	f({1, 2, 3});                        // Выводит #1
	f({"hello", "initializer", "list"}); // Выводит #2
	g({1, 1, 2, 3, 5});                  // Выводит #3
	h({1.5, 2.5});                       // Выводит #4
	i({1, 2});                           // Выводит #5
}
```

В первых двух вызовах `f()` аргументы списка инициализаторов преобразуются в значения [[initializer_list|std::initializer_list]], что включает преобразование каждого из элементов списка в тип элементов списка [[initializer_list|std::initializer_list]]. В первом вызове все элементы уже имеют тип `int`, поэтому дополнительное преобразование не требуется. Во втором вызове каждый строковый литерал в списке инициализаторов преобразуется в [[string|std::string]] путем вызова конструктора `string (char const*)`. Третий вызов (для `g()`) выполняет пользовательское преобразование с помощью конструктора `std::vector (std::initializer_list<int>)`. Следующий за ним вызов вызывает конструктор `std::complex (double, double)`, [[Шаблоны функций#Перегрузка шаблонов функций|как если бы мы написали std::complex<double>]]. Последний вызов выполняет агрегатную инициализацию, инициализируя члены экземпляра класса `Point` элементами из списка инициализаторов без вызова конструктора `Point`.

Есть несколько интересных случаев перегрузки для списков инициализаторов. При преобразовании списка инициализаторов в [[initializer_list|initializer_list]], как в первых двух вызовах в показанном выше примере, полное преобразование получает тот же ранг, что и наихудшее преобразование любого заданного элемента в списке инициализатора к типу элемента [[initializer_list|initializer_list]] (т.е. к `Т` в `initializer_list<T>`). Это может привести к некоторым сюрпризам, как показано в следующем примере:
```c++
#include <initializer_list>
#include <iostream>

void ovl(std::initializer_list<char>)      // #1
{
	std::cout << "#1\n";
}

void ovl(std::initializer_list<int>)       // #2
{
	std::cout << "#2\n";
}

int main()
{
	ovl({'h', 'e', '1', '1', 'o', '\0'});  // Выводит #1
	ovl({'h', 'e', '1', '1', 'o', 0});     // Выводит #2
}
```

В первом вызове `ovl()` каждый элемент списка инициализаторов представляет собой `char`. Для первой функции `ovl()` эти элементы не требуют никакого преобразования. Для второй функции `ovl()` требуется расширение до `int`. Поскольку точное соответствие лучше расширения, первый вызов `ovl()` приводит к вызову `#1`.

Во втором вызове `ovl()` первые пять элементов имеют тип `char`, в то время как последний имеет тип `int`. Для первой функции `ovl()` точно подходят элементы `char`, но `int` требует стандартного преобразования, так что полное преобразование получает тот же ранг, что и стандартное преобразование. Для второй функции `ovl()` элементы `char` требуют расширения до `int`, в то время как элемент `int` в конце списка соответствует точно. Полное преобразование для второй функции `ovl()` ранжируется как расширение, что делает ее лучшим кандидатом, чем первая `ovl()`, несмотря на то, что лучшим оказалось преобразование только одного элемента.

При инициализации объекта классового типа списком инициализаторов, как в вызовах `g()` и `h()` в нашем исходном примере, разрешение перегрузки протекает в два этапа.
1. На первом этапе рассматриваются только конструкторы со списками инициализаторов, т.е. конструкторы, у которых единственный параметр (к тому же не имеющий значения по умолчанию) имеет тип [[initializer_list|std::initializer_list<T>]] для некоторого типа `Т` (после удаления ссылки верхнего уровня и квалификаторов [[const|const]]/[[volatile|volatile]]).
2. Если такой жизнеспособный конструктор не был найден, то на втором этапе рассматриваются все прочие конструкторы.

Существует одно исключение из этого правила: если список инициализаторов пуст, а класс имеет конструктор по умолчанию, первый этап пропускается, так что будет вызван конструктор по умолчанию.

Результат применения этого правила состоит в том, что любой конструктор со списком инициализаторов имеет лучшее соответствие, чем любой конструктор без списка инициализаторов, как показано в следующем примере:
```c++
#include <initializer_list>
#include <string>
#include <iostream>

template<typename T>
struct Array
{
	Array (std::initializer__list<T>)
	{
		std::cout << "#1\n";
	}
	
	Array(unsigned n, T const&)
	{
		std::cout << "#2\n";
	}
};

void arr1(Array<int>)
{
}

void arr2(Array<std::string>)
{
}

int main()
{
	arr1({1, 2, 3, 4, 5});                  // Выводит #1
	arr1({1, 2});                           // Выводит #1
	arr1({10u, 5});                         // Выводит #1
	arr2({"hello", "initializer", "list"}); // Выводит #1 
	arr2({10, "hello"});                    // Выводит #2
}
```

Обратите внимание: второй конструктор, который принимает `unsigned` и `Т const&`, при инициализации объекта `Array<int>` списком инициализаторов не вызывается, потому что его конструктор со списком инициализаторов всегда имеет лучшее соответствие, чем его конструкторы без списка инициализаторов. Однако в случае `Array<string>` во втором вызове `аrr2()` будет вызван конструктор без списка инициализаторов, так как конструктор со списком инициализаторов не является жизнеспособным.

## Функторы и функции-суррогаты

Ранее упоминалось, что после поиска имени функции для формирования начального множества перегрузки это множество обрабатывается различными способами. Интересная ситуация возникает, когда выражение вызова ссылается на объект классового типа, а не на функцию. В этом случае возможны два потенциальных дополнения ко множеству перегрузки.

Первое дополнение очевидно: ко множеству можно добавить любой оператор-член `()` (оператор вызова функции). Объекты с такими операторами обычно [[Обобщенные библиотеки - template#Вызываемые объекты|называются функторами]].

Менее очевидное дополнение возникает в ситуации, когда объект классового типа содержит оператор неявного преобразования в указатель на тип функции (или в ссылку на тип функции). В такой ситуации к набору перегрузки добавляется фиктивная функция (так называемая функция-суррогат). Эта функция-суррогат рассматривается как имеющая неявный параметр, тип которого определяется функцией преобразования, в дополнение к параметрам, типы которых соответствуют таковым в целевой функции. Приведенный ниже пример значительно проясняет ситуацию:
```c++
using FuncType = void (double, int);
class IndirectFunctor
{
	public:
		...
		void operator()(double, double) const;
		operator FuncType* () const;
};

void activate(IndirectFunctor const& funcObj)
{
	funcObj(3, 5);         // Ошибка: неоднозначность
}
```

Вызов `funcObj(3, 5)` рассматривается как вызов с тремя аргументами: `funcObj`, `3` и `5`. Жизнеспособные функции-кандидаты включают член `operator ()` (который рассматривается как имеющий параметры типа `IndirectFunctor` `const&`, `double` и `double`) и функцию-суррогат с параметрами типа `FuncType*`, `double` и `int`. Суррогат обладает худшим соответствием для неявного параметра (поскольку требуется пользовательское преобразование), однако лучшим соответствием для последнего параметра. Следовательно, невозможно отдать предпочтение какому-либо из этих кандидатов, поэтому вызов будет неоднозначным.

Функции-суррогаты относятся к одной из самых “темных” областей С++ и редко используются на практике (к счастью).

## Другие контексты перегрузки

Мы уже обсудили перегрузку в контексте определения того, к какой функции должно идти обращение в выражении вызова. Однако существует несколько других контекстов, в которых также необходимо сделать подобный выбор.

Первый контекст возникает, когда требуется адрес функции. Рассмотрим следующий пример:
```c++
int numElems(Matrix const&); // #1
int numElems(Vector const&); // #2

...

int (*funcPtr)(Vector const&) = numElems; // Выбирается #2
```

Здесь имя `numElems` обращается ко множеству перегрузки, однако необходим адрес только одной функции. Затем разрешение перегрузки проверяет соответствие нужного типа функции (тип `funcPtr` в этом примере) одному из доступных кандидатов.

Другой контекст, который требует разрешения перегрузки, — это инициализация. К сожалению, в этой теме есть масса тонкостей, которые невозможно охватить в данном приложении. Тем не менее приведем простой пример, который хотя бы проиллюстрирует этот дополнительный аспект разрешения перегрузки.
```c++
#include <string>

class BigNum
{
	public:
		BigNum(long n);               // #1
		BigNum(double n);             // #2
		BigNum(std::string const&);   // #3
		
		...
		
		operator double();            // #4
		operator long();              // #5

		...
};

void initDemo()
{
	BigNum bn1(100103);               // Выбирается #1
	BigNum bn2("7057103224.095764");  // Выбирается #3
	int in = bn1;                     // Выбирается #5
}
```

В этом примере разрешение перегрузки необходимо для выбора соответствующего конструктора или оператора преобразования. В частности, инициализация `bn1` вызывает первый конструктор, инициализация `bn2` — третий, а для `in` вызывается `operator long()`. В подавляющем большинстве случаев правила перегрузки дают интуитивно понятный результат. Тем не менее подробности этих правил довольно сложны, а некоторые приложения основаны на менее понятных принципах этой области языка C++.


