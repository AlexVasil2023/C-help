
[[#Имена в шаблонах|Имена в шаблонах]] 13
1. [[#Систематизация имен|Систематизация имен]] 13.1
2. [[#Поиск имен|Поиск имен]] 13.2
	1. [[#Поиск, зависящий от аргументов|Поиск, зависящий от аргументов]] 13.2.1
	2. [[#ADL объявлений друзей|ADL объявлений друзей]] 13.2.2
	3. [[#Внесение имен классов|Внесение имен классов]] 13.2.3
	4. [[#Текущие инстанцирования|Текущие инстанцирования]] 13.2.4
3. [[#Синтаксический анализ шаблонов|Синтаксический анализ шаблонов]] 13.3
	1. [[#Зависимость от контекста в нешаблонных конструкциях|Зависимость от контекста в нешаблонных конструкциях]] 13.3.1
	2. [[#Зависимые имена типов|Зависимые имена типов]] 13.3.2
	3. [[#Зависимые имена шаблонов|Зависимые имена шаблонов]] 13.3.3
	4. [[#Зависимые имена в объявлениях using|Зависимые имена в объявлениях using]] 13.3.4
	5. [[#ADL и явные аргументы шаблонов|ADL и явные аргументы шаблонов]] 13.3.5
	6. [[#Зависимые выражения|Зависимые выражения]] 13.3.6
	7. [[#Ошибки компиляции|Ошибки компиляции]] 13.3.7
4. [[#Наследование и шаблоны классов|Наследование и шаблоны классов]] 13.4
	1. [[#Независимые базовые классы|Независимые базовые классы]] 13.4.1
	2. [[#Зависимые базовые классы|Зависимые базовые классы]] 13.4.2

# Имена в шаблонах

Имена в большинстве зыков программирования представляют собой фундаментальную концепцию. Они являются средством, с помощью которого программист может обращаться к ранее созданным объектам. Когда компилятор C++ встречает имя, он должен выполнить его "поиск", чтобы определить, на какой объект ссылается это имя. С точки зрения реализации C++ в этом отношении является сложным языком. Рассмотрим, например, выражение C++ `x*y;`. Если `x` и `y` - имена переменных, данное выражение является умножением, но если `x` является именем типа, то это не что иное, как объявление `y` как указателя на объест типа `x`.

	Из этого небольшого примера видно, что C++ (как и C) является так называемым ***контекстно-зависимым языком программирования***. Другими словами, конструкцию языка не всегда можно распознать без знания ее более широкого контекста. Естественно задать вопрос: а какое это имеет отношение к шаблонам? Шаблоны являются конструкциями, которые имеют дело с несколькими контекстами: 1) контекст, в котором шаблон появляется, 2) контекст, в котором шаблон инстанцируется, и 3) контекст, связанный с аргументами шаблона, для которых происходит инстанцирование. Следовательно, теперь вас не должно удивить то, что имена в C++ требуют к себе особого внимание.

# Систематизация имен

Имена в C++ классифицируются разными способами, причем этих способов существует огромное количество. Чтобы помочь справиться с этим изобилием терминологии, все способы классификации имен сведены в табл. К счастью, многие вопросы, касающиеся шаблонов  C++, станут гораздо понятнее, если ознакомиться с основными концепциями именования.
>
> Имя является ***полным***, или ***квалифицированным именем*** (qualified name), если область видимости, которой оно принадлежит, явно указывается либо с помощью с помощью оператора разрешения области видимости (`::`), либо с помощью оператора доступа к членам класса(`.` или `->`). Например, `this->count` - квалифированное имя, а `count` - нет (даже если само по себе `count` в действительности является ссылкой на член класса).
> 
> Имя является ***зависимым именем*** (dependent name), если оно каким-либо образом зависит от параметра шаблона. Например, `std::vector<T>::iterator` - зависимое имя, если `T` - параметр шаблона, и независимое, если `T` является известным псевдонимом типа (таким как `T` из `using T = int`).

Таблица. Систематизация имен

| Классификация                                      | Пояснения и примечания                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| -------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Идентификатор                                      | Имя, которое содержит только неразрывные последовательности букв, знаков подчеркивания (`_`) и цифр. Идентификатор не может начинаться с цифры; кроме того, некоторые идентификаторы зарезервированы в реализации языка: их нельзя самостоятельно вводить в программы (используйте эмпирическое правило: избегайте идентификаторов, начинающихся с подчеркиваний и двойных подчеркиваний). Понятие “буква” интерпретируется расширенно: сюда включаются специальные ***универсальные имена символов*** (universal character names — UCN), с помощью которых кодируются знаки из неалфавитных языков                                                                                                                                                                                                                                       |
| Идентификатор<br>функции оператора                 | Ключевое слово `operator`, за которым следует символ,<br>обозначающий оператор, например `operator new` или<br>`operator[]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Идентификатор<br>функции<br>преобразования<br>типа | Используется для обозначения определенного пользователем неявного оператора преобразования, например operator int&, который может также быть представлен как `operator int bitand`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Идентификатор<br>оператора литерала                | Используется для обозначения пользовательского оператора литерала — например, `operator ""_km`, который будет использоваться при написании литерала наподобие `100_km` (введен в С++11)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Идентификатор<br>шаблона                           | Имя шаблона, за которым следуют аргументы шаблона,<br>заключенные в угловые скобки, например `List<T, int, 0>`. Идентификатором шаблона может также быть идентификатор функции оператора или идентификатор оператора литерала, за которым следуют аргументы шаблона, заключенные в угловые скобки; например `operator+<X<int>>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Неквалифицированный<br>идентификатор               | Обобщение идентификатора. Неквалифицированный идентификатор может быть любым из приведенных выше видов идентификаторов (идентификатор, идентификатор функции оператора, идентификатор функции преобразования типа, идентификатор оператора литерала или идентификатор шаблона), а также “имя деструктора”  (например, записи наподобие `~Data` или `~List<T,T,N>`)                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Квалифици­рованный<br>идентификатор                | Неквалифицированный идентификатор, который квалифицирован именем класса, перечисления или пространства имен, или с помощью оператора разрешения глобальной области видимости. Заметим, что такое имя само по себе может быть квалифицированным. Примерами являются `::х`, `S::х`, `Аггау<Т>::у` и `::N::А<Т>::z`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Квалифицированное имя                              | Этот термин в стандарте не определен, но мы используем его для обозначения имен, которые подвергаются так называемому квалифицированному поиску (qualified lookup). В частности, это могут быть квалифицированные или неквалифицированные идентификаторы, которые используются после явного оператора доступа (`.` или `->`). Примерами являются `S::х`, `this->f` и `р->А::m`. Однако просто `class_mem` в контексте, когда он неявно эквивалентен `this->class_mem`, не является квалифицированным именем: доступ к члену класса должен быть явным                                                                                                                                                                                                                                                                                      |
| Неквалифицированное имя                            | Неквалифицированный идентификатор, который не является квалифицированным именем. Это не стандартный термин, но он соответствует именам, которые подвергаются тому, что в стандарте именуется неквалифицированным поиском                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Имя                                                | Квалифицированное или неквалифицированное имя                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Зависимое имя                                      | Имя, которое каким-либо образом зависит от параметра шаблона. Обычно квалифицированное или неквалифицированное имя, которое явно содержит параметр шаблона, является зависимым. Более того, квалифицированное имя, которое включает оператор доступа к члену класса (`.` или `->`), обычно является зависимым, если тип выражения в левой части оператора является типозависимым, (type-dependent, концепция,<br>рассматриваемая в #разделе_13_3_6). В частности, `b` в `this->b` в общем случае является зависимым именем при присутствии в шаблоне. И наконец, имя, являющееся субъектом поиска, зависящего от аргумента (описан в #разделе_13_2), такое как `ident` в вызове вида `ident (х, у)` или `+` в выражении `х+у`, является зависимым именем тогда и только тогда, когда любое из выражений аргументов является типозависимым |
| Независимое имя                                    | Имя, которое не является зависимым согласно данному выше определению                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

С этой таблицей полезно ознакомиться хотя бы для того, чтобы получить некоторое представление о терминах, которые иногда используются при описании тем, касающихся шаблонов C++. Однако запоминать точное значение каждого термина вовсе не обязательно. Если возникнет необходимость, всегда можно вернуться к данной таблице.

# Поиск имен

Существует много незначительных деталей, касающихся поиска имен в C++, но здесь мы остановимся только на нескольких основных концепциях. Подробностям будем уделять внимание только в случаях, когда:
>
> нужно убедиться в правильности интуитивной трактовки 
> 
> в “патологических” случаях, которые тем или иным образом описаны в стандарте.

Поиск квалифицированных имен проводится в области видимости, вытекающей из квалифицирующей конструкции. Если эта область видимости является классом, то поиск также проводится и в базовых классах. Однако при поиске квалифицированных имен не рассматриваются области видимости, охватывающие данную.

Основной принцип такого поиска иллюстрируется приведенным ниже кодом:
```c++
int х;
class В
{
	public:
		int i;
};

class D : public В
{ };

void f(D* pd)
{
	pd->i = 3;  // Находит B::i
	D::x = 2;  	// Ошибка: не находит ::x в охватывающей области видимости
}
```

Поиск же неквалифицированных имен, напротив, выполняется в последовательно расширяющихся областях видимости, охватывающих данную (однако в определениях функций-членов сначала проводится поиск в области видимости класса и его базовых классов, а уже затем — в охватывающих областях видимости). Такая разновидность поиска называется обычным поиском (ordinary lookup). Приведенный ниже пример иллюстрирует главную идею, лежащую в основе обычного поиска:
```c++
extern int count;                 // #1
int lookup_example(int count)     // #2
{
	if(count < 0)
	{
		int count =1;             // #3
		lookup_example(count);    // Неквалифицированное count из #3
	}
	
	return count + ::count; // Первое, неквалифицированное count из
							// #2; второе, квалифицированное - из #1	
}
```

Современные методы поиска неквалифицированных имен в дополнение к обычному поиску могут включать так называемый поиск, зависящий от аргументов (argument-dependent lookup — ADL)2. Прежде чем перейти к подробному рассмотрению ADL, рассмотрим механизм этого поиска на нашем вечном примере шаблона `max()`:
```c++
template<typename Т>
Т max(T а, Т Ь)
{
	return Ь < а ? а : Ь;
}
```

Предположим, что нам необходимо применить этот шаблон к типу, определенному в другом пространстве имен:
```c++
namespace BigMath
{
	class BigNumber
	{
		...
	};
	
	bool operator < (BigNumber const&, BigNumber const&);

	...
}

using BigMath::BigNumber;
void g(BigNumber const& a, BigNumber const& b)
{
	...
	
	BigNumber x = ::max(a, b);

	...
}
```

Проблема заключается в том, что шаблону `max()` ничего не известно о пространстве имен `BigMath`, и с помощью обычного поиска не будет найден оператор `<`, применимый к значениям типа `BigNumber`. Если не ввести некоторые специальные правила, такие ситуации в значительной степени сокращают применимость шаблонов в контексте пространств имен C++. Поиск ADL является ответом C++ на необходимость введения таких “специальных правил”.

## Поиск, зависящий от аргументов

ADL относится главным образом к неквалифицированным именам, которые выглядят как если бы они именовали функции, не являющиеся членами, в вызовах функций или применениях операторов. ADL не будет выполняться, если обычный поиск находит
>
> имя функции-члена;
> 
> имя переменной;
> 
> имя типа или
> 
> имя объявления функции с областью видимости блока.

ADL также запрещен, если имя вызываемой функции заключено в круглые скобки.

В противном случае, если после имени следует заключенный в круглые скобки список выражений аргументов, ADL выполняется путем поиска имени в пространствах имен и классах, “связанных” или “ассоциированных” с типами аргументов вызова. Точное определение этих связанных пространств имен и связанных классов будет дано позже, но интуитивно их можно рассматривать как все пространства имен и классы, которые очевидным образом непосредственно имеют отношение к данному типу. Например, если тип является указателем на класс `X`, то связанные классы и пространство имен будут включать `X`, а также все пространства имен и классы, к которым принадлежит `X`.

Точное определение множества связанных пространств имен и связанных классов для данного типа регламентируется приведенными далее правилами.
>
> Для встроенных типов это пустое множество.
> 
> Для типов указателей и массивов множество связанных пространств имен и классов — это пространства имен и классы лежащего в основе типа (на который указывает указатель или который является типом элемента массива).
> 
> Для перечислимых типов связанным пространством имен является пространство имен, в котором объявлено перечисление.
> 
> Для членов классов связанным классом является охватывающий класс.
> 
> Для типов классов (включая [[union|объединения]]) множеством связанных классов является сам тип класса, его охватывающий класс, а также все непосредственные или опосредованные базовые классы. Множество связанных пространств имен представляет собой пространства имен, в которых объявлены связанные классы. Если класс является экземпляром шаблона класса, то сюда включаются и типы аргументов типов шаблона, а также классы и пространства имен, в которых объявлены шаблонные аргументы шаблона.
> 
> Для типов функций множества связанных пространств имен и классов включают пространства имен и классы, связанные со всеми типами параметров, а также связанные с типами возвращаемых значений.
> 
> Для указателей на члены класса `X` множества связанных пространств имен и классов включают пространства имен и классы, связанные с `X` в дополнение к связанным с типом члена класса (если это тип указателя на функцию-член, то учитываются также типы параметров и возвращаемых значений этой функции-члена).

При применении ADL осуществляется последовательный поиск имени во всех связанных пространствах имен так, как если бы это имя было квалифицировано поочередно с помощью каждого из этих пространств имен (директивы `using` при этом игнорируются). Этот механизм иллюстрируется приведенным ниже примером:
```c++
#include <iostream>

namespace X
{
	template<typename T> void f(T);
}

namespace N
{
	using namespace X;
	enum E { e1 };

	void f(E)
	{
		std::cout << "Вызов N::f(N::E)\n";
	}
}

void f(int)
{
	std::cout << "Вызов ::f(int)\n";
}

int main()
{
	::f(N::e1); // Квалифицированное имя функции: без ADL
	f(N::e1);   // Обычный поиск находит ::f(), ADL находит
}               // N::f(), последний предпочтительнее
```

Заметим, что в данном примере директива `using` в пространстве имен `N` при выполнении ADL игнорируется. Следовательно, `X::f()` никогда даже не будет рассматриваться как кандидат для вызова в main ().

## ADL объявлений друзей

Объявление дружественной функции может быть первым объявлением функции-кандидата при поиске. В этом случае считается, что функция объявлена в области видимости ближайшего пространства имен (которым может быть глобальное пространство имен), охватывающего класс, содержащий объявление дружественной функции. Однако такое объявление друга не является непосредственно видимым в данной области видимости. Рассмотрим следующий пример:
```c++
template<typename Т>
class С
{
	...
	
	friend void f();
	friend void f(C<T> const&);

	...
);

void g(C<int>* p)
{
	f();         // Видима ли здесь f()?
	f(*p);       // Видима ли здесь f(C<int> const&)?
}
```

Если объявления дружественных конструкций видимы в охватывающем пространстве имен, то инстанцирование шаблона класса может сделать видимыми объявления обычных функций. Это может привести к удивительному поведению: вызов `f()` ведет к ошибке компиляции, если только инстанцирование класса `С` не произошло ранее в программе!

С другой стороны, может быть полезным объявить (и определить) функцию только в объявлении друга (см. в #разделе_21_2_1 методику, основанную на таком поведении). Такая функция может быть найдена, когда класс, для которого она является другом, находится среди связанных классов, рассматриваемых ADL.

Рассмотрим наш последний пример. Вызов `f()` не имеет связанных классов или пространств имен, поскольку не имеет аргументов: это некорректный вызов в нашем примере. Однако вызов `f(*р)` имеет связанный класс `C<int>` (поскольку это тип `*р`), и с ним также связано глобальное пространство имен (поскольку это пространство имен, в котором объявлен тип `*р`). Следовательно, объявление второй дружественной функции может быть найдено, если класс `C<int>` в действительности полностью инстанцирован до этого вызова. Чтобы обеспечить выполнение данного условия, предполагается, что вызов, инициирующий поиск дружественных конструкций в связанных классах, фактически вызывает инстанцирование класса (если оно еще не выполнено).

Возможность ADL найти объявления и определения друзей иногда называют внесением, или инъекцией имени друга (friend name injection). Однако этот термин несколько вводит в заблуждение, потому что это название возможности C++, имевшейся еще до разработки стандарта, которая на самом деле “вносит” имена объявлений друзей в охватывающую область видимости, делая их видимыми для обычного поиска имен. В приведенном выше примере это означает, что оба вызова корректны. В заключительных примечаниях к главе история внесения имен друзей рассматривается более подробно.

## Внесение имен классов

Имя класса “внесено” в область видимости самого этого класса и, следовательно, является доступным в данной области видимости как неквалифицированное имя (однако оно недоступно в качестве квалифицированного имени, поскольку это запись, используемая для обозначения конструкторов). Например:
```c++
#include <iostream>

int С;
class С
{
	private:
		int i [2];

	public:
		static int f()
		{
			return sizeof(С);
		}
};

int f ()
{
	return sizeof(C);
}

int main()
{
	std::cout << "C::f() = " << C::f() << ','
			  << " ::f() = " << ::f()  << '\n' ;
};
```

Функция-член `C::f()` возвращает размер типа `С`, в то время как функция `::f()` возвращает размер переменной `С` (другими словами, размер объекта типа `int`).

Шаблоны классов также имеют внесенные имена классов. Однако они еще более непривычны, чем обычные внесенные имена классов: за ними могут идти аргументы шаблона (в этом случае они являются внесенными именами шаблона класса), но если за ними не следуют аргументы шаблона, то они представляют класс с использованием параметров шаблонов в качестве аргументов (или при частичной специализации с использованием аргументов специализации), если контекст ожидает тип, или шаблон, если контекст ожидает шаблон. Это поясняет следующую ситуацию:
```c++
template<template<typename> class ТТ> class X
{
};

template<typename Т> class С
{
	С* а;        // OK: то же, что и "С<Т>* а;

	C<void>& Ь;  // ОК
	
	Х<С> с;      // OK: С без списка аргументов шаблонов
				 // обозначает шаблон С
	Х<::С> d;    // ОК: ::С не является внесенным именем класса,
				 // а потому всегда обозначает шаблон
};
```

Обратите внимание на то, как неквалифицированное имя ссылается на внесенное имя, и на то, что имя шаблона не рассматривается, если за ним не следует список аргументов. Для компенсации можно заставить имя шаблона быть найденным, используя квалификатор области видимости файла `::`.

Внесенное имя класса для вариативного шаблона имеет свои хитрости: если внесенное имя класса было сформировано непосредственно с использованием вариативных шаблонных параметров шаблона в качестве аргументов шаблона, то внесенное имя будет содержать пакеты параметров шаблона, которые не были раскрыты ([[Вглубь шаблонов - template#Раскрытие пакета|о раскрытии пакетов]]). Таким образом, при формировании внесенного имени класса для вариативного шаблона аргумент шаблона, соответствующий пакету параметров шаблона, представляет собой раскрытие пакета, схемой которого является этот пакет параметров шаблона:
```c++
template<int I, typename... Т> class V
{
	V* а;         // ОК: то же, что и "V<I, Т...>* а;"
	V<0, void> b; // OK
};
```

## Текущие инстанцирования

Внесенное имя класса для класса или шаблона класса, по сути, является псевдонимом определяемого типа. Для класса, не являющегося шаблоном, это свойство очевидно, потому что сам класс является единственным типом с указанным именем в этой области видимости. Однако внутри шаблона класса или вложенного класса в шаблоне класса каждое инстанцирование шаблона производит другой тип. Это свойство особенно интересно в данном контексте, потому что означает, что внесенное имя класса относится к тому же инстанцированию шаблона класса, а не к некоторой иной специализации этого шаблона класса (то же самое справедливо и для вложенных классов шаблонов классов).

В шаблоне класса внесенное имя класса или любой тип, эквивалентный внесенному имени класса (включая просмотр объявлений псевдонимов типов) любого охватывающего класса или класса шаблона называется ссылающимся на текущее инстанцирование. Типы, которые зависят от параметра шаблона (то есть зависимые типы), но не ссылающиеся на текущее инстанцирование, называются ссылающимися на неизвестную специализацию, которая может быть инстанцирована из того же самого шаблона класса или некоторого совершенно иного шаблона класса. Следующий пример иллюстрирует это различие:
```c++
template<typename Т> class Node
{
	using Type = T;
	Node* next;             // Node ссылается на текущее
							// инстанцирование
	Node<Type>* previous;   // Node<Type> ссылается на
							// текущее инстанцирование
	Node<T*>* parent;       // Node<T*> ссылается на
							// неизвестную специализацию
};
```

Определение, является ли тип ссылающимся на текущее инстанцирование, может быть особенно запутанным при наличии вложенных классов и шаблонов классов. Внесенные имена классов охватывающих классов и шаблонов классов (или эквивалентные им типы) ссылаются на текущее инстанцирование, в то время как имена других вложенных классов или шаблонов класса — нет:
```c++
template<typename Т> class С
{
	using Туре = Т;
	struct I
	{
		С* с;           // С ссылается на текущее инстанцирование
		С<Туре>* с2;    // С<Туре> ссылается на текущее инстанцирование
		I* i;           // I ссылается на текущее инстанцирование
	};
	
	struct J
	{
		С* с;           // С ссылается на текущее инстанцирование
		С<Туре>* с2;    // С<Туре> ссылается на текущее инстанцирование
		I* i;           // I ссылается на неизвестную специализацию,
						// поскольку I не охватывает J
		J* j;           // J ссылается на текущее инстанцирование
	};
};
```

Когда тип ссылается на текущее инстанцирование, содержимое этого инстанцированного класса гарантированно инстанцируется из шаблона класса или его вложенного класса, который в настоящее время определяется. Это имеет последствия для поиска имен при синтаксическом анализе шаблонов (теме нашего следующего раздела), но это также приводит к альтернативному, больше похожему на игру способу определения, ссылается тип `X` в определении шаблона класса на текущее инстанцирование или на неизвестную специализацию: если другой программист может написать такую явную специализацию (описываемую подробно в #главе_16, “Специализация и перегрузка”), что `X` ссылается на нее, то `х` ссылается на неизвестную специализацию. Рассмотрим, например, инстанцирование типа `C<int>::J` в контексте приведенного выше примера: мы знаем, что определение `С<Т>::J` используется для инстанцирования конкретного типа (так как мы инстанцируем этот тип). Кроме того, поскольку явная специализация не может специализировать шаблон или член шаблона без одновременной специализации всех охватывающих шаблонов или членов, `C<int>` будет инстанцироваться из определения охватывающего класса. Следовательно, ссылки на `J` и `C<int>` (где `Туре` представляет собой `int`), внутри `J` ссылаются на текущее инстанцирование. С другой стороны, можно было бы написать явную специализацию для `C<int>::I` следующим образом:
```c++
template<> struct C<int>::I
{
	// Определение специализации
};
```

Здесь специализация `C<int>::I` предоставляет совершенно иное определение, чем видимое из определения `С<Т>::J`, так что `I` внутри определения `С<Т>::J` ссылается на неизвестную специализацию.

# Синтаксический анализ шаблонов

В большинстве случаев компилятор выполняет два фундаментальных действия — токенизацию, именуемую также лексическим анализом, и синтаксический анализ текста программы. При лексическом анализе исходный текст программы рассматривается как последовательность символов, из которой генерируется последовательность токенов. Например, если компилятор встречает последовательность символов i`nt* р = 0;`, лексический анализатор разделяет ее на отдельные токены — ключевое слово `int`, символ/оператор `*`, идентификатор `р`, символ/оператор `=`, целочисленный литерал `0` и символ/оператор `;`.

После лексического анализа в дело вступает синтаксический анализ, который находит в последовательности токенов известные разрешенные языковые конструкции путем рекурсивной свертки токенов или обнаруженных ранее конструкций в конструкции более высокого уровня. Например, токен `0` является корректным выражением, комбинация символа `*`, за которым следует идентификатор `р`, является корректным декларатором; а декларатор, за которым следует знак `“=”`, сопровождаемый выражением `“0”`, в свою очередь является корректным инициализирующим декларатором. И наконец, ключевое слово `int` является известным именем типа; когда за ним следует объявление инициализирующий декларатор `*р = 0`, мы получаем инициализирующее объявление переменной `р`.

## Зависимость от контекста в нешаблонных конструкциях

Как вы, вероятно, знаете или предполагаете, лексический анализ осуществляется легче, чем синтаксический. К счастью, синтаксический анализ достаточно хорошо проработан теоретически, так что использование теории синтаксического анализа позволяет довольно легко разрабатывать синтаксические анализаторы для множества различных языков программирования. Лучше всего теория синтаксического анализа разработана для так называемых контекстно-свободных языков программирования, в то время как C++ является контекстно-зависимым языком программирования. В связи с этим компилятор C++ использует таблицы символов и при лексическом, и при синтаксическом анализе. Когда проводится анализ объявления, оно вносится в таблицу символов. Когда при лексическом анализе обнаруживается идентификатор, выполняется поиск в таблице символов, и если выясняется, что это тип, выполняется соответствующее аннотирование токена.

Например, если компилятор C++ встречает
```c++
X*
```

то лексический анализатор обнаруживает `х`. Если это тип, то анализатор видит
```
идентификатор, тип, х
символ, *
```

и делает вывод, что начинается объявление. Однако если `х` не является типом, то синтаксический анализатор получает от лексического анализатора
```c++
идентификатор, не тип, х
символ, *
```

и корректный анализ данной конструкции возможен только как выражения умножения. Детали этих принципов зависят от конкретной реализации стратегии, но суть из этого примера должна быть ясна.

Еще один пример контекстной зависимости иллюстрируется следующим выражением:
```c++
Х<1>(0)
```

Если `X` является именем шаблона класса, то в предыдущем выражении целое `0` приводится к типу `Х<1>`, сгенерированному из этого шаблона. Если `X` не является шаблоном, то предыдущее выражение эквивалентно следующему:
```c++
(Х<1)>0
```

Другими словами, `X` сравнивается с `1`, а результат этого сравнения — “истина” или “ложь” (которые в данном случае неявно преобразуются в `1` или `0`) — сравнивается с `0`. Хотя код, подобный приведенному, используется редко, он является корректным кодом C++ (и, кстати, корректным кодом С). Следовательно, синтаксический анализатор C++ будет проводить поиск имен, находящихся перед `<`, и интерпретировать `<` как угловую скобку, только если имя является именем шаблона; в противном случае `<` рассматривается как обычный символ оператора “меньше чем”.

Такая форма контекстной чувствительности — одно из неудачных последствий выбора для ограничения списка аргументов шаблона угловых скобок. Ниже приведен пример еще одного такого следствия:
```c++
template<bool В>
class Invert
{
	public:
		static bool const result = !B;­
};

void g()
{
	bool test = Invert<(1>0)>::result;    // Необходимы круглые скобки!
};
```

Если опустить круглые скобки в выражении `Invert<(1>0)>`, то символ “больше чем” будет ошибочно воспринят в качестве закрывающего список аргументов шаблона. Это сделало бы код неверным, поскольку компилятор воспринял его как эквивалент `((Invert<1>))0>::result`.

Лексический анализатор также не лишен проблем, связанных с угловыми скобками. Например, в
```c++
List<List<int>> а; 	// ^-- — пробела между правыми угловыми скобками нет
```

два символа `>` объединяются в токен правого сдвига `>>`, и, следовательно, лексическим анализатором как два отдельных токена не рассматривается. Это следствие принципа максимального поглощения (maximum munch) при лексическом анализе: реализация C++ должна собирать в токен как можно больше идущих подряд символов.

[[Шаблоны классов#Использование шаблона класса Stack|начиная с С++11, стандарт C++ выделяет этот случай, когда вложенные идентификаторы шаблонов закрываются с помощью токена сдвига вправо >>]], а синтаксический анализатор рассматривает сдвиг вправо как эквивалент двух отдельных правых угловых скобок `>` и `>`, чтобы можно было завершать вложенные идентификаторы шаблонов без дополнительного пробела. Интересно отметить, что это изменение автоматически меняет смысл некоторых (следует признать, весьма надуманных) программ. Рассмотрим следующий пример:
```c++
#include <iostream>

template<int I> struct X
{
	static int const c = 2;
};

template<> struct X<O>
{
	typedef int c;
};

template<typename T> struct Y
{
	static int const c = 3;
};

static int const c = 4;

int main()
{
	std::cout << (Y<X<1> >::c >::c >::c) << ' ';
	std::cout << (Y<X< 1>>::c >::c >::c) << '\n';
};
```

Эта корректная с точки зрения стандарта С++98 программа выводит
```
О 3
```

Но эта же программа (являющаяся корректной программой с точки зрения стандарта С++11) при рассмотрении двух закрывающих угловых скобок как завершения вложенного шаблона в С++11 дает вывод
```
0 0
```

Имеется аналогичная проблема, связанная с применением диграфа `<:` в качестве альтернативы для символа `[` (который недоступен на некоторых традиционных клавиатурах). Рассмотрим следующий пример:
```c++
template<typename Т> struct G {};
struct S;
G<::S> gs; // Корректный код C++11; ошибка в более ранних версиях
```

До C++11 последняя строка кода была эквивалентна явно недопустимой записи `G[:S> gs;`. Для решения этой проблемы был добавлен еще один “лексический хак”: когда компилятор видит символы `<::`, за которыми не сразу следуют `:` или `>`, ведущая пара знаков `<:` не рассматривается как токен диграфа, эквивалентный `[`. Этот лексический хак может сделать ранее корректный (конечно, надуманный) код неверным:
```c++
#define F(X) X ## :

int а[] = { 1, 2, 3 }, i = 1;
int n = a F(<::)i];            // Корректно в C++98/C++03, но не в С++11
```

Чтобы понять, что происходит, обратите внимание на то, что “лексический хак” применяется к токенам препроцессора, которые представляют собой токены, приемлемые для препроцессора (они могут стать неприемлемыми после обработки препроцессором), и они обрабатываются до завершения раскрытия макроса. С учетом сказанного, С++98/С++03 безоговорочно превращает `<:` в `[` в вызове макроса `F(<::)`, так что определение `n` раскрывается в
```c++
int n = а[ :: i];
```

что вполне корректно. Однако С++11 не выполняет преобразования диграфа, потому что до раскрытия макроса за последовательностью `<::` не следуют ни `:`, ни `>`, `а` ). Без преобразования диграфа оператор конкатенации `##` должен попытаться собрать `::` и `:` в новый токен препроцессора, но это не работает, потому что `:::` не является допустимым токеном. Стандарт объявляет это неопределенным поведением, которое позволяет компилятору делать все, что угодно. Некоторые компиляторы будут диагностировать эту проблему, в то время как другие не будут и просто разделят два токена препроцессора, что приведет к синтаксической ошибке, так как в этом случае будет получено такое определение `n`:
```c++
int п = а < :: : i];
```

## Зависимые имена типов

Проблемы с именами в шаблонах не всегда удается полностью классифицировать. В частности, один шаблон не может заглянуть в другой шаблон, поскольку содержимое последнего может оказаться некорректным в силу явной специализации. Ниже приведен несколько искусственный пример, иллюстрирующий данное утверждение:
```c++
template<typename Т>
class Trap
{
	public:
		enum { x };         // #1 Здесь x не является типом
};

template<typename Т>
class Victim
{
	public:
		int у;
		void poof()
		{
			Trap<T>::x* y;  // #2 Объявление или умножение?
		}
};

template<>
class Trap<void>            // Специализация!
{
	public:
		using x = int;      // #3 Здесь x является типом
};

void boom(Victim<void>& bomb)
{
	bomb.poof();
}
```

Когда компилятор выполняет синтаксический анализ строки `#2`, он должен решить, с какой конструкцией он имеет дело — с объявлением или умножением. Это решение, в свою очередь, зависит от того, является ли зависимое квалифицированное имя `Тгар<Т>::х` именем типа. Неплохо бы, конечно, заглянуть в этот момент в шаблон `Trap`, и обнаружить, что согласно строке `#1` `Тгар<Т>::х` не является типом, поэтому для строки `#2` остается только умножение. Однако несколько позже все портит имеющийся код перекрытия `Тгар<Т>::х` для случая, когда `Т` является `void`. В этом случае `Тгар<Т>::х` на самом деле представляет собой тип `int`.

В этом примере тип `Тгар<Т>` является зависимым типом, потому что тип зависит от параметра `Т` шаблона. Кроме того, `Тгар<Т>` ссылается на [[Имена в шаблонах - template#Текущие инстанцирования|неизвестную специализацию]], так что компилятор не может безопасно заглянуть внутрь шаблона, чтобы определить, является ли имя `Тгар<Т>` типом или нет. Должен ли тип, предваряемый `::`, ссылаться на текущее инстанцирование — например, с `Victim<T>::у` — компилятор мог бы выяснить из определения шаблона, поскольку понятно, что здесь не может вклиниться никакая иная специализация. Таким образом, когда тип, предваренный `::`, ссылается на текущее инстанцирование, поиск квалифицированных имен в шаблоне ведет себя очень похоже на поиск квалифицированных имен для несвязанных типов.

Однако, как иллюстрирует пример, поиск имен в неизвестной специализации по-прежнему остается проблемой. Определение языка разрешает эту проблему, указывая, что в общем случае зависимое квалифицированное имя не обозначает тип, если только это имя не предваряется ключевым словом [[typename|typename]]. Если после подстановки аргументов шаблона оказывается, что имя не является именем типа, программа считается некорректной, и компилятор C++ должен пожаловаться вам на это во время инстанцирования. Обратите внимание на то, что использование [[typename|typename]] отличается от использования этого ключевого слова для обозначения параметров типа шаблона. В отличие от параметров типа нельзя заменить ключевое слово [[typename|typename]] ключевым словом `class`.

Префикс [[typename|typename]] для имени необходим, когда имя удовлетворяет всем следующим условиям.
>
> Оно квалифицировано, но за ним не следует `::` для образования более квалифицированного имени.
> 
> Оно не является частью уточненного спецификатора типа (elaborated type specifier) (т.е. имени типа, которое начинается с одного из ключевых слов `class`, `struct`, [[union|union]] или [[enum|enum]]).
> 
> Оно не используется в списке спецификаций базовых классов или в списке инициализаторов членов, вводимых определением конструктора.
> 
> Оно зависит от параметра шаблона.
> 
> Оно является членом неизвестной специализации, что означает, что тип, именованный квалификатором, ссылается на неизвестную специализацию.

Кроме того, префикс [[typename|typename]] не разрешен, если только не выполнены как минимум два первых условия. Для иллюстрации рассмотрим следующий ошибочный пример:
```c++
template<typename Т>                                     // #1
struct S : typename X<T>::Base                           // #2
{
	S() : typename X<T>::Base(typename X<T>::Base(0))    // #3 #4
	{
	}
	
	typename X<T> f()                                    // #5
	{
		typename X<T>::C* p;  // Объявление указателя p  // #6 
		X<T>::D* q;           // Умножение!
	}
	
	typename X<int>::C* s;                               // #7
	using Type = T;
	using OtherType = typename S<T>::Type;               // #8
};
```

Каждое [[typename|typename]] — корректное либо нет — для удобства указания помечено номером. Первое [[typename|typename]], означает параметр шаблона. К этому первому использованию [[typename|typename]] приведенные выше правила не относятся. Второе и третье включение [[typename|typename]] не разрешается согласно второму правилу. Именам базовых классов в этих двух контекстах не может предшествовать [[typename|typename]]. Однако [[typename|typename]] 4 должно быть указано. Здесь имя базового класса используется не для обозначения того, что должно инициализироваться или порождаться из чего-либо, а является частью выражения для создания временного объекта `Х<Т>::Base` из аргумента `0` (если угодно — это можно рассматривать как разновидность преобразования типов). Пятое [[typename|typename]] запрещено, поскольку имя, которое за ним следует (`Х<Т>`), не является квалифицированным именем. Шестое вхождение требуется, если это выражение предназначено для объявления указателя. В следующей строке ключевое слово [[typename|typename]] отсутствует, поэтому она интерпретируется компилятором как умножение. Седьмое [[typename|typename]] необязательно, поскольку оно удовлетворяет первым двум правилам, но не удовлетворяет двум последним. И наконец [[typename|typename]] 8 не обязательное, поскольку ссылается на член текущего инстанцирования (а потому не удовлетворяет последнему правилу).

Последнее из правил определения, требуется ли префикс [[typename|typename]], иногда может оказаться сложно вычислимым, потому что оно зависит от правил определения, ссылается ли тип на текущее инстанцирование или на неизвестную специализацию. В таких случаях безопаснее добавить ключевое слово [[typename|typename]], чтобы указать, что ваше намерение в том, чтобы следующее далее квалифицированное имя было типом. Ключевое слово [[typename|typename]], даже будучи необязательным, будет документировать ваши намерения.

## Зависимые имена шаблонов

Проблема, во многом подобная той, с которой мы столкнулись в предыдущем разделе, возникает и в случае, когда имя шаблона является зависимым. В общем случае от компилятора C++ требуется, чтобы он рассматривал знак `<`, следующий за именем шаблона, как начало списка аргументов шаблона; в противном случае это оператор “меньше чем”. Как и в случае с именами типов, компилятор должен предполагать, что зависимое имя не ссылается на шаблон, если только программист не обеспечивает дополнительную информацию с помощью ключевого слова `template`:
```c++
template<typename T>
class Shell
{
	public:
		template<int N>
		class In
		{
			public:
				template<int M>
				class Deep
				{
					public:
						virtual void f();
				};
		};
};

template<typename T, int N>
class Weird
{
	public:
		void case1(typename Shell<T>::template In<N>::template Deep<N>*p)
		{
			p->template Deep<N>::f(); // Запрет виртуального вызова
		}
		
		void case2(typename Shell<T>::template In<N>::template Deep<N>&p)
		{
			p.template Deep<N>::f{);  // Запрет виртуального вызова
		}
};
```

В этом несколько запутанном примере показано, как для всех операторов, могущих квалифицировать имя `(::`, `->` и `.`, может потребоваться использовать ключевое слово `template`. В частности, оно требуется всякий раз, когда тип имени или выражения, предшествующего квалифицирующему оператору, зависит от параметра шаблона и ссылается на неизвестную специализацию, а имя, которое следует за оператором, является идентификатором шаблона (другими словами, имя шаблона, за которым следуют аргументы шаблона в угловых скобках).

Например, в выражении
```c++
р.template Deep<N>::f()
```

тип `р` зависит от параметра шаблона `Т`. Следовательно, компилятор C++ не может проводить поиск `Deep` для выяснения, является ли это имя шаблоном, и необходимо явно указать это с помощью предшествующего данному имени ключевого слова `template`. Без этого предваряющего ключевого слова синтаксический анализ `р.Deep<N>::f()` проводится следующим образом: `((р. Deep) <N) >f()`. Заметим также, что может потребоваться использовать ключевое слово `template` несколько раз в пределах одного квалифицированного имени, поскольку квалификаторы сами по себе могут быть квалифицированы с помощью зависимого квалификатора (что иллюстрируют объявления параметров `case1` и `case2` в предыдущем примере).

Если опустить ключевое слово `template` в таких ситуациях, как показанная, то открывающая и закрывающая угловые скобки анализируются как операторы “меньше чем” и “больше чем”. Как и в случае ключевого слова [[typename|typename]], можно безопасно добавить префикс `template`, чтобы указать, что следующее имя является идентификатором шаблона, даже если в данном конкретном случае префикс `template` не является строго необходимым.

## Зависимые имена в объявлениях using

Объявления `using` могут быть привнесены в имена из двух мест — пространств имен и классов. Случай пространств имен в данном контексте нас не интересует, поскольку не существует шаблонов пространств имен. Что касается классов, то в действительности объявления `using` могут привноситься только из базового класса в порожденный. Такие объявления `using` в порожденном классе ведут себя как “символические связи” или “ярлыки”, направленные из производного класса к базовому, тем самым позволяя членам производного класса обращаться к соответствующему имени базового класса, как если бы оно было объявлено в производном классе. Краткий, не содержащий шаблонов, пример проиллюстрирует сказанное лучше, чем множество слов.
```c++
class ВХ
{
	public:
		void f(int);
		void f(char const*);
		void g();
};

class DX : private BX
{
	public:
		using BX::f;
};
```

Объявление `using` привносит имя `f` из базового класса `ВХ` в порожденный класс `DX`. В данном случае это имя связано с двумя разными объявлениями; таким образом подчеркивается, что мы имеем дело с механизмом для имен, а не с отдельными объявлениями таких имен. Заметим также, что такой вид `using`-объявления может сделать доступным член класса, который в противном случае был бы недоступен. Базовый класс `ВХ` (и, соответственно, его члены) является закрытым по отношению к классу `DX`, за исключением функций `ВХ::f`, которые введены в открытом интерфейсе `DX` и являются, следовательно, доступными для клиентов `DX`.

Теперь вы, вероятно, можете осознать проблему, когда объявление `using` привносит имя из зависимого класса. Хотя мы знаем об имени, мы не знаем, является ли это имя типом, шаблоном или чем-то иным:
```c++
template<typename Т>
class ВХТ
{
	public:
		using Mystery = Т;
		
		template<typename U>
		struct Magic;
};

template<typename T>
class DXTT : private BXT<T>
{
	public:
		using typename BXT<T>::Mystery;
		Mystery* p; // Без ранее использованного typename
};                  // было бы синтаксической ошибкой
```

И вновь, если мы хотим, чтобы зависимое имя было внесено объявлением `using` для обозначения типа, мы должны явно сказать об этом, использовав ключевое слово [[typename|typename]]. Как ни странно, стандарт C++ не предусматривает аналогичный механизм для обозначения таких зависимых имен, как шаблоны. Следующий фрагмент кода иллюстрирует данную проблему:
```c++
template<typename Т>
class DXTM : private ВХТ<Т>
{
	public:
		using ВХТ<Т>::template Magic; // Ошибка: не стандарт
		Magic<T>* plink;              // Синтаксическая ошибка: Magic
};                                    // не является известным шаблоном
```

Комитет по стандартизации не склонен решать эту проблему. Однако шаблоны псевдонимов C++ предоставляют частичный обходной путь:
```c++
template<typename Т>
class DXTM : private ВХТ<Т>
{
	public:
		template<typename U>
		using Magic = typename 
			BXT<T>::template Magic<T>; // Шаблон псевдонима

		Magic<T>* plink;               // OK
);
```

Это несколько громоздкое решение, но оно достигает желаемого эффекта в случае шаблонов классов. В случае шаблонов функций (пожалуй, менее распространенном) проблема, к сожалению, остается нерешенной.

## ADL и явные аргументы шаблонов

Рассмотрим следующий пример:
```c++
namespace N
{
	class X
	{
		...
	};
	
	template<int I> void select(X*);
}

void g(N::X* xp)
{
	select<3>(xp);         // Ошибка: ADL не выполняется!
}
```

В этом примере можно предположить, что в вызове `select<3>(хр)` шаблон `select()` отыскивается с помощью ADL. Однако это не так, поскольку компилятор не может принять решение о том, что `хр` является аргументом вызова функции, пока не будет решено, что `<3>` является списком аргументов шаблона. И наоборот, невозможно решить, что `<3>` является списком аргументов шаблона, пока не выяснится, что `select()` представляет собой шаблон. Поскольку эту проблему курицы и яйца разрешить невозможно, выражение анализируется как `(select<3)>(хр)`, что не имеет смысла.

Этот пример может создать впечатление, что ADL для идентификаторов шаблонов не работает, но это не так. Приведенный код может быть исправлен путем введения шаблона функции с именем `select`, который виден при вызове:
```c++
template<typename Т> void select();
```

Несмотря на то что это не имеет никакого смысла для вызова `select<3> (хр)`,
наличие этого шаблона функции гарантирует, что `select<3>` будет при анализе рассматриваться как идентификатор шаблона. Затем ADL находит шаблон функции `N::select`, и вызов будет успешным.

## Зависимые выражения

Подобно именам, выражения сами по себе могут быть зависимыми от параметров шаблона. Выражение, которое зависит от параметра шаблона, может вести себя по-разному от одного инстанцирования к другому — например, выбирая другую перегруженную функцию или производя другой тип или значение константы. Выражения, которые не зависят от параметра шаблона, напротив, обеспечивают одинаковое поведение во всех инстанцированиях.

Выражение может быть зависимым от параметра шаблона несколькими различными способами. Наиболее распространенной формой зависимых выражений является выражение, зависящее от типа, где тип самого выражения может варьироваться от одного инстанцирования к другому — например, выражение, которое ссылается на параметр функции, типом которого является тип параметра шаблона:
```c++
template<typename Т> void typeDependent1(Т х)
{
	х; // Выражение зависит от типа, поскольку
}      // тип х может варьироваться
```

Выражения, которые имеют зависимые от типа подвыражения, в общем случае сами являются зависимыми от типа — например, вызов функции `f()` с аргументом `х`:
```c++
template<typename Т> void typeDependent2(Т х)
{
	f(х);  // Выражение зависит от типа, поскольку
}          //от типа зависит х
```

Обратите внимание на то, что здесь тип `f(х)` может варьироваться от одного инстанцирования к другому, потому что вызов `f` может быть разрешен в шаблон, тип результата которого зависит от типа аргумента, так и из-за того, что двухфазный поиск (который рассматривается в #разделе_14_3_1) в различных инстанцированиях может найти совершенно разные функции с именем `f`.

Не все выражения, которые включают параметры шаблона, зависимы от типа. Например, выражение, включающее параметры шаблона, может выдавать разные константные значения от инстанцирования к инстанцированию. Такие выражения называются зависящими от значения, и простейшими из них являются те, которые ссылаются на нетиповой параметр шаблона независимого типа. Например:
```c++
template<int N> void valueDependent1()
{
	N;  // Это выражение зависимо от значения, но не от типа,
		// поскольку N имеет фиксированный тип, но варьируемое
		// константное значение
}
```

Подобно зависимым от типа выражениям, выражения зависят от значений в общем случае тогда, когда они составлены из других подвыражений, зависящих от значения, поэтому `N+N` или `f(N)` также являются зависящими от значения выражениями.

Интересно, что некоторые операции, такие как [[sizeof|sizeof]], имеют известный тип результата, поэтому они могут превратить зависящий от типа операнд в зависящее от значения выражение, которое не зависит от типа. Например:
```c++
template<typename Т> void valueDependent2(Т х)
{
	sizeof(х); // Выражение зависит от значения, но не от типа
}
```

Операция [[sizeof|sizeof]] всегда дает значение типа [[size#std size_t|std::size_t]], независимо от ее входных данных, так что выражение [[sizeof|sizeof]] никогда не является зависящим от типа, даже если — как в данном случае — его подвыражение является зависимым от типа. Однако результирующее значение константы будет варьироваться от одного инстанцирования к другому, так что `sizeof(х)` является выражением, зависящим от значения.

Что если мы применим [[sizeof|sizeof]] к выражению, зависящему от значения?
```c++
template<typename Т> void maybeDependent(Т const& х)
{
	sizeof(sizeof(х));
}
```

Здесь внутреннее выражение [[sizeof|sizeof]] является зависимым от значения, как отмечалось выше. Однако внешнее выражение [[sizeof|sizeof]] всегда вычисляет размер типа [[size#std size_t|std::size_t]], так что и тип, и значение получаемой константы одинаково при любых инстанцированиях этого шаблона, несмотря на то, что наиболее глубоко вложенное выражение `(х)` является зависимым от типа. Любое выражение, включающее параметр шаблона, является ***выражением, зависящим от инстанцирования***, даже если и его тип, и константное выражение являются инвариантом для различных корректных инстанцирований. Однако выражения, зависящие от инстанцирования, могут оказаться некорректны при инстанцировании. Например, инстанцирование `maybeDependent()` с неполным типом класса приведет к ошибке, так как [[sizeof|sizeof]] не может быть применено к таким типам.

Зависимость от типа, значения и инстанцирования можно рассматривать как ряд все более всеобъемлющих классификаций выражений. Любое выражение, зависящие от типа, также рассматривается как зависящее от значения, поскольку выражение, тип которого варьируется от одного инстанцирования к другому, естественно, будет иметь постоянно меняющееся значение в разных инстанцированиях. Аналогично выражение, тип или значение которого варьируется от одного инстанцирования к другому, некоторым образом зависит от параметра шаблона, поэтому как выражения, зависящие от типа, так и выражения, зависящие от значения, зависят от инстанцирования. Это отношение включения иллюстрируется на рис.
![[templates_1.png]]

По мере передвижения от наиболее глубоко вложенного внутреннего контекста (выражения, зависимые от типа) ко внешнему, поведение шаблона определяется при синтаксическом анализе во все большей степени, и поэтому не может варьироваться от одного инстанцирования к другому. Рассмотрим, например, вызов `f(х):` если `х` зависит от типа, то `f` является зависимым именем, которое является субъектом двухфазного поиска ( #раздел_14_3_1), тогда как если `х` является зависимым от значения, но не от типа, `f` является независимым именем, для которого поиск имени может быть полностью выполнен во время синтаксического анализа шаблона.

## Ошибки компиляции

Компилятор C++ может (но не обязан!) диагностировать ошибку во время синтаксического анализа шаблона, когда все инстанцирования шаблона приводят к этой ошибке. Давайте расширим пример `f (х)` из предыдущего раздела для более подробного изучения:
```c++
void f() { }

template<int х>
void nondependentCall()
{
	f(X);       // x зависит от значения, так что имя f независимое;
				// этот вызов не может быть успешным
}
```

Здесь вызов `f(х)` ведет к ошибке в каждом инстанцировании, потому что `f` является независимым именем, а единственная видимая `f` принимает нуль аргументов, а не один. Компилятор C++ может сообщить об ошибке при синтаксическом анализе шаблона, а может ждать первого инстанцирования шаблона. Самые распространенные компиляторы ведут себя по-разному даже в этом простом примере. Можно создать подобные примеры с выражениями, зависящими от инстанцирования, но не зависящими от значения:
```c++
template<int N>
void instantiationDependentBound()
{
	constexpr int x = sizeof(N);
	constexpr int у = sizeof(N) + 1;
	int array[x-y];                 // Массив имеет отрицательный размер
									//во всех инстанцированиях
}
```

# Наследование и шаблоны классов

Шаблоны классов могут как порождать производные классы, так и сами быть производными классами. В большинстве случаев особой разницы между сценариями с использованием шаблонов и без них нет; однако есть один важный тонкий момент при порождении шаблона класса из базового класса, обращение к которому выполняется с помощью зависимого имени. Давайте сначала рассмотрим более простой случай независимых базовых классов.

## Независимые базовые классы

В шаблоне класса независимый базовый класс является классом с полным типом, который может быть определен без знания аргументов шаблона. Другими словами, для обозначения этого класса используется независимое имя.
```c++
template<typename Х>
class Base
{
	public:
		int basefield;
		using T = int;
};

class DI: public Base<Base<void>> // В действительности
{                                 // это не шаблон
	public:
		void f()
		{
			basefield = 3;        // Обычный доступ к
		}                         // унаследованному члену
};

template<typename T>
class D2 : public Base<double>    // Независимый базовый класс
{
	public:
		void f()
		{
			basefield = 7;        // Обычный доступ к
		}                         // унаследованному члену
		T strange;                // Т не параметр шаблона -
};                                // это Base<double>::Т!
```

Поведение независимых базовых классов в шаблонах очень похоже на поведение базовых классов в обычных нешаблонных классах, однако здесь имеет место некоторая досадная неожиданность: когда поиск неквалифицированного имени выполняется в производном шаблоне, независимые базовые классы рассматриваются до списка параметров шаблона. Это означает, что в предыдущем примере член класса `strange` шаблона класса `D2` всегда имеет тип `Т`, соответствующий `Base<double>::Т` (другими словами, `int`). Например, следующая функция (при использовании предыдущих объявлений) с точки зрения C++ некорректна:
```c++
void g(D2<int*>& d2, int* p)
{
	d2.strange = p;  // Ошибка: несоответствие типов!
}
```

Такое поведение далеко не интуитивно и требует от разработчика порожденного шаблона внимания по отношению к именам в независимых базовых классах, от которых он порождается, даже когда это порождение является непрямым или имена являются закрытыми. Вероятно, было бы предпочтительнее разместить параметры шаблона в области видимости “шаблонизируемой” сущности.

## Зависимые базовые классы

В предыдущем примере базовый класс был полностью определенным и не зависел от параметра шаблона. Это означает, что компилятор C++ может искать независимые имена в тех базовых классах, где видимо определение шаблона. Альтернатива (не разрешенная стандартом C++) могла бы заключаться в отсрочке поиска таких имен, пока шаблон не будет инстанцирован. Недостаток этого подхода состоит в том, что до инстанцирования откладываются все сообщения об ошибках. Поэтому в стандарте C++ указано, что поиск независимого имени, присутствующего в шаблоне, происходит немедленно после того, как компилятор встречает его. Рассмотрим с учетом сказанного приведенный ниже пример.
```c++
template<typename Т>
class DD : public Base<T>          // Зависимый базовый класс
{
	public:
		void f ()
		{
			basefield = 0;         // #1 Проблема...
		}
};

template<>                         // Явная специализация
class Base<bool>
{
	public:
		enum { basefield = 42 };   // #2 Трюк!
};

void g(DD<bool>& d)
{
	d.f();                         // #3  Xmm?
}
```

В точке `#1` имеется ссылка на независимое имя `basefield`, поиск которого следует провести немедленно. Предположим, что оно найдено в шаблоне `Base` и связано с членом класса с типом `int` в этом классе. Однако вскоре после этого компилятор встречает явную специализацию данного класса. Когда это происходит, смысл члена класса `basefield` изменяется — при том, что его старый смысл уже использован! Так, при инстанцировании определения `DD::f` в точке `#3` выясняется, что независимое имя в точке `#1` связано с членом класса типа `int` преждевременно — в `DD<bool>`, специализированном в точке `#2`, не существует переменной `basefield`, которой можно было бы присвоить новое значение, так что компилятором будет выдано сообщение об ошибке.

Чтобы обойти эту проблему, стандарт C++ гласит, что поиск независимых имен не проводится в зависимых базовых классах (однако сам поиск выполняется, как только эти имена встречаются компилятором). Таким образом, соответствующий стандарту C++ компилятор выдаст диагностику в точке `#1`. Для исправления этого кода достаточно сделать имя `basefield` зависимым, поскольку поиск зависимых имен может проводиться только во время инстанцирования шаблона, а к этому моменту точная специализация базового класса, где будет вестись поиск, уже будет известна. Например, в точке `#3` компилятор уже будет знать, что базовым по отношению к `DD<bool>` является класс `Base<bool>`, явно специализированный программистом. Сделать имя зависимым можно, например, как показано ниже.
```c++
// Вариант 1:
template<typename Т>
class DD1 : public Base<T>
{
	public:
		void f()
		{
			this->basefield = 0; // Поиск отложен
		}
};
```

Еще один вариант — введение зависимости с помощью квалифицированного имени.
```c++
// Вариант 2:
template<typename Т>
class DD2 : public Base<T>
{
	public:
		void f()
		{
			Base<T>::basefield = 0;
		}
};
```

Применение этого варианта требует особой тщательности, поскольку если неквалифицированное независимое имя используется для формирования вызова виртуальной функции, то квалификация подавляет механизм виртуального вызова и смысл программы изменяется. Несмотря на это, существуют ситуации, когда первый вариант нельзя использовать и приходится применять альтернативный.
```c++
template<typename Т>
class В
{
	public:
		enum Е { e1 = 6, е2 = 28, еЗ = 496 };
		virtual void zero(E е = e1);
		virtual void one(E&);
};

template<typename T>
class D : public B<T>
{
	public:
		void f()
		{
			typename D<T>::E e; // this->E синтаксически неверно
			this->zero();       // D<T>::zero() подавляет виртуальность
			one(e);             // one является зависимым именем
		}						// из-за зависимости аргумента	
}
```

Обратите внимание на то, что в этом примере мы использовали `D<T>::Е` вместо `В<Т>::Е`. В этом случае работает любой вариант. Но в случаях множественного наследования мы не можем знать, какой именно базовый класс предоставляет требуемый член (в таком случае работает квалификация с помощью производного класса), или несколько базовых классов могут объявлять одно и то же имя (в этом случае может потребоваться использовать конкретное имя базового класса для устранения неоднозначности).

Заметим, что имя `one` в вызове `one(е)` зависимо от параметра шаблона просто потому, что тип одного из явно заданных аргументов вызова является зависимым. Неявно используемые аргументы по умолчанию с типом, который зависит от параметра шаблона, во внимание не принимаются, поскольку компилятор не может их проверить до тех пор, пока не будет проведен поиск, — все та же проблема курицы и яйца. Чтобы избежать таких нюансов, предпочтительно использовать префикс `this->` во всех ситуациях, где только можно, — даже для нешаблонного кода.

Если вы обнаружите, что повторяющиеся квалификаторы загромождают ваш код, можно внести имя из зависимого базового класса в порожденный класс раз и навсегда.
```c++
// Версия 3:
template<typename Т>
class DD3 : public Base<T>
{
	public:
		using Base<T>::basefield;   // #1 Теперь зависимое имя
									// в области видимости
		void f()
		{
			basefield = 0;          // #2 Все в порядке
		}
};
```

Поиск в точке `#2` успешен и находит объявление `using` в точке `#1`. Однако объявление `using` не проверяется до инстанцирования, так что поставленная цель достигнута. Эта схема имеет несколько тонких ограничений. Например, если осуществляется множественное наследование из нескольких базовых классов, программист должен точно указать, какой из них содержит необходимый член.

При поиске квалифицированного имени в текущем инстанцировании стандарт C++ указывает, что сначала имя ищется в текущем инстанцировании и всех независимых базовых классах, подобно выполнению неквалифицированного поиска для этого имени. Если найдено любое имя, то квалифицированное имя ссылается на член текущего инстанцирования и не будет зависимым именем. Если такое имя не найдено, и класс имеет любые зависимые базовые классы, то квалифицированное имя ссылается на член неизвестной специализации. Например:
```c++
class NonDep
{
	public:
		using Type = int;
};

template<typename T>
class Dep
{
	public:
		using OtherType = Т;
} ;

template<typename Т>
class DepBase : public NonDep, public Dep<T>
{
	public:
		void f()
		{
			typename DepBase<T>::Type t;
					// Находится NonDep::Type; ключевое
					// слово typename не обязательное
			typename DepBase<T>::OtherType* ot;
					// He находится ничего; DepBase<T>::OtherType
					// является членом неизвестной специализации
		}
};
```

