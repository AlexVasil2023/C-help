
[[#Полиморфная мощь шаблонов|Полиморфная мощь шаблонов]] 18
1. [[#Динамический полиморфизм|Динамический полиморфизм]] 18.1
2. [[#Статический полиморфизм|Статический полиморфизм]] 18.2
3. [[#Сравнение динамического и статического полиморфизма|Сравнение динамического и статического полиморфизма]] 18.3
4. [[#Применение концептов|Применение концептов]] 18.4
5. [[#Новые виды проектных шаблонов|Новые виды проектных шаблонов]] 18.5
6. [[#Обобщенное программирование|Обобщенное программирование]] 18.6



# Полиморфная мощь шаблонов

Полиморфизм представляет собой способность связывать различные специфические виды поведения с помощью единой общей записи. Кроме того, полиморфизм является краеугольным камнем парадигмы объектно-ориентированного программирования, которая в C++ поддерживается главным образом через наследование свойств классов и виртуальные функции. Поскольку этот механизм (по крайней мере частично) работает во время выполнения программы, можно употребить термин динамический полиморфизм. Обычно так говорят, когда речь идет об обычном полиморфизме в C++. Однако шаблоны также позволяют связывать различные специфические виды поведения единой общей записью, но это связывание обрабатывается, как правило, в процессе компиляции, так что в данном случае следует говорить о статическом полиморфизме. В этой главе приводится обзор обоих вариантов полиморфизма и обсуждается вопрос, какой из них
соответствует той или иной конкретной ситуации.

Обратите внимание на то, что в #главе_22, “Статический и динамический полиморфизм”, обсуждаются некоторые способы работы с полиморфизмом после введения и обсуждения ряда вопросов проектирования.

# Динамический полиморфизм

Исторически сложилось так, что язык C++ начался с поддержки полиморфизма только посредством наследования, объединенного с виртуальными функциями. В этом контексте искусство полиморфного дизайна состоит в идентификации общего набора возможностей среди связанных типов объектов и объявлении их в качестве интерфейсов виртуальных функций в общем базовом классе.

Наглядным примером этого подхода к конструированию является приложение, которое управляет построением геометрических фигур с возможностью их воспроизведения определенным способом (например, на экране). В таком приложении можно указать так называемый ***абстрактный базовый класс*** (abstract base class — ABC) `GeoObj`, который объявляет общие операции и свойства, применимые к геометрическим объектам вообще. Каждый конкретный класс для конкретных геометрических объектов будет затем порождаться из абстрактного базового класса `GeoObj` (рис.).
![[template_1.png]]
Рис. Полиморфизм, реализованный с помощью наследования

```c++
#include "coord.hpp"

// Общий абстрактный базовый класс GeoObj
// для геометрических объектов
class GeoObj
{
	public:
		// Черчение геометрического объекта:
		virtual void draw() const = 0;
		
		// Возврат центра масс геометрического объекта:
		virtual Coord center_of_gravity() const = 0;

		...
	
		virtual ~GeoObj() = default;
};

// Конкретный класс геометрического объекта Circle
// - унаследован от GeoObj
class Circle : public GeoObj
{
	public:
		virtual void draw() const override;
		virtual Coord center_of_gravity() const override;

		...
};

// Конкретный класс геометрического объекта Line
// - унаследован от GeoObj
class Line : public GeoObj
{
	public:
		virtual void draw() const override;
		virtual Coord center_of_gravity() const override;

		...
};

...
```

После создания конкретных объектов клиентский код может управлять этими объектами через ссылки или указатели на базовый класс, который дает возможность задействовать механизм диспетчеризации виртуальных функций. В результате вызова виртуальной функции-члена посредством указателя или ссылки на подобъект базового класса происходит вызов соответствующего члена объекта, на который осуществлялась ссылка.

В нашем примере конкретный код может выглядеть, как показано ниже.
```c++
#include "dynahier.hpp"
#include <vector>

// Черчение любого GeoObj
void myDraw(GeoObj consts obj)
{
	obj.draw();  // Вызов draw() в соответствии с типом объекта
)

// Вычисление расстояния между центрами масс двух GeoObjs
Coord distance(GeoObj const& x1, GeoObj const& x2)
{
	Coord c = x1.center_of_gravity() - x2.center_of_gravity();
	return c.abs();  // Возврат абсолютного значения
}

// Черчение неоднородного набора объектов GeoObjs
void drawElems(std::vector<GeoObj*> const& elems)
{
	for(std::size_type i = 0; i < elems.size(); ++i)
	{
		elems[i]->draw();   // Вызов draw() в соответствии
							// с типом элемента
	}
}

int main()
{
	Line l;
	Circle c, c1, c2;
	
	myDraw(l);        // myDraw(GeoObj&) => Line::draw()
	myDraw(c);        // myDraw(GeoObj&) => Circle::draw()
	
	distance(c1, c2); // distance(GeoObj &,GeoObj &)
	distance(l, c);   // distance(GeoObj &,GeoObj &)
	
	std::vector<GeoObj*> coll; // Неоднородная коллекция
	coll.push_back(&l);        // Вставка линии
	coll.push_back(&c);        // Вставка окружности

	drawElems(coll);           // Черчение разных GeoObjs
}
```

Ключевыми элементами полиморфного интерфейса являются функции `draw()` и `center_of_gravity()`. Обе функции являются виртуальными функциями-членами. В нашем примере продемонстрировано их использование в функциях `myDraw()`, `distance()` и `drawElems()`. Последние три функции записаны с использованием общего базового типа `GeoObj`. Вследствие этого в процессе компиляции нельзя определить, какая именно версия функции `draw()` или `center_of_gravity()` должна использоваться. Однако в процессе выполнения программы при диспетчеризации вызовов функций определяется полный динамический тип объектов, для которых вызываются виртуальные функции. Следовательно, соответствующая операция выполняется в зависимости от фактического типа геометрического объекта: если `myDraw()` вызывается для объекта `Line`, то выражение `obj.draw()` вызывает функцию `Line::draw()`, тогда как для объекта `Circle` вызывается функция `Circle::draw()`. Подобным же образом в вызове `distance()` функции-члены `center_of_gravity()` соответствуют переданным в качестве параметров объектам.

Пожалуй, наиболее впечатляющей возможностью динамического полиморфизма является способность обрабатывать разнородные коллекции объектов. Эта концепция иллюстрируется функцией `drawElems()`; простое выражение
```c++
elems[1]->draw()
```

выполняет вызов разных функций-членов, в зависимости от типа итерируемого элемента.

# Статический полиморфизм

Шаблоны также могут использоваться для реализации полиморфизма. Однако они не зависят от фактора общего поведения, свойственного базовым классам. Вместо этого общность подразумевает поддержку операций с использованием общего синтаксиса (т.е. соответствующие функции имеют одни и те же имена). Конкретные классы при этом определяются независимо друг от друга (рис.), а сам полиморфизм проявляется при инстанцировании шаблонов с конкретными классами.
![[template_2.png]]
Рис. Полиморфизм, реализованный с помощью шаблонов

Например, функция `myDraw()` из предыдущего раздела
```c++
void myDraw (GeoObj const& obj)  // GeoObj - абстрактный базовый класс
{
	obj.draw();
}
```

может быть переписана следующим образом:
```c++
template<typename GeoObj>
void myDraw (GeoObj const& obj) // GeoObj - параметр шаблона
{
	obj.draw();
}
```

Сравнивая эти две реализации функции `myDraw()`, можно видеть, что основное различие состоит в указании `GeoObj` в качестве параметра шаблона вместо указания в качестве общего базового класса. Имеются, однако, и более существенные различия. Например, при использовании динамического полиморфизма в процессе выполнения у нас была только одна функция `myDraw()`, тогда как, применяя шаблон, мы имеем различные функции, такие как `myDraw<Line>()` и `myDraw<Circle>()`.

Можно попытаться переписать весь пример из предыдущего раздела с использованием статического полиморфизма. При этом вместо иерархии геометрических классов у нас появится несколько индивидуальных геометрических классов.
```c++
#include "coord.hpp"

// Конкретный класс геометрического объекта Circle
// - не являющийся производным от какого-либо иного класса
class Circle
{
	public:
		void draw() const;
		Coord center_of_gravity() const;

		...
};

// Конкретный класс геометрического объекта Line
// - не являющийся производным от какого-либо иного класса
class Line
(
	public:
		void draw() const;
		Coord center_of_gravity() const;

		...
};

...
```

Теперь применение этих классов имеет следующий вид:
```c++
#include "statichier.hpp"
#include <vector>

// Черчение любого GeoObj
template<typename GeoObj>
void myDraw(GeoObj const& obj)
{
	obj.draw()); // Вызов draw() в соответствии с типом объекта
}

// Вычисление расстояния между центрами масс двух GeoObjs
template<typename GeoObj1, typename GeoObj2>
Coord distance(GeoObj1 const& x1, GeoObj2 const& x2)
{
	Coord c = x1.center_of_gravity() - x2.center_of_gravity();
	return c.abs(); // Возврат абсолютного значения
}

// Черчение однородного набора объектов GeoObjs
template<typename GeoObj>
void drawElems(std::vector<GeoObj> const& elems)
{
	for (unsigned i = 0; i c elems.size(); ++i)
	{
		elems[i].draw();    // Вызов draw() в соответствии
							//с типом объекта
	}
}

int main()
{
	Line l;
	Circle с, c1, c2;
	
	myDraw(l); // myDraw<Line>(GeoObj&) => Line::draw()
	myDraw(c); // myDraw<Circle>(GeoObj&) => Circle::draw()
	
	distance (c1, c2); // distance<Circle,Circle>(GeoObj1 &,GeoObj2 &) 
	distance(l, c);    // distance<Line,Circle>(GeoObj1 &,GeoObj2 &)

	// std::vector<GeoObj*> coll;   // Ошибка: гетерогенная
									// коллекция невозможна

	std::vector<Line> coll;         // OK: гомогенная коллекция
	coll.push_back(1);              // Вставка линии
	drawElems(coll);                // Черчение всех линий
}
```

Тип `GeoObj` больше не может использоваться в качестве конкретного параметра типа как для функции `distance()`, так и в функции `myDraw()`. Вместо этого в функции `distance()` предусмотрены два параметра шаблона — `GeoObj1` и `GeoObj 2`. Два разных параметра шаблона позволяют вычислять расстояние между разными типами геометрических объектов:
```c++
distance(l, с); // distance<Line,Circle>(GeoObj1 &,GeoObj2 &)
```

Теперь, однако, разнородные коллекции больше не могут быть прозрачно обработаны. Это тот случай, когда статическая часть статического полиморфизма налагает свои ограничения, а именно: все типы должны быть определены во время компиляции. Взамен предоставляется возможность легко вводить разные коллекции для различных типов геометрических объектов; к тому же больше не требуется, чтобы коллекция была ограничена указателями, что дает существенные преимущества в аспекте производительности и безопасности типов.

# Сравнение динамического и статического полиморфизма

А теперь классифицируем и сравним обе формы полиморфизма.

***===Терминология===***

Динамический и статический полиморфизм обеспечивает поддержку различных идиом языка программирования C++.
>
> Полиморфизм, реализованный с использованием наследования, является ***ограниченным***, или ***связанным*** (bounded) и ***динамическим*** (dynamic).
> 	> Термин ***ограниченный*** означает, что интерфейсы типов, участвующих в процессе полиморфизма, предопределены дизайном общего базового класса (другими терминами для обозначения данной концепции являются ***инвазивный*** (invasive) или ***интрузивный*** (intrusive)).
> 	> 
> 	> Термин ***динамический*** означает, что связывание интерфейсов происходит в процессе выполнения программы (т.е. динамически).
> 
> Полиморфизм, реализованный с использованием шаблонов, является ***неограниченным*** (unbounded) и ***статическим*** (static).
> 	> 
> 	> Термин ***неограниченный*** означает, что интерфейсы типов, участвующих в процессе полиморфизма, не предопределены заранее (другими терминами для обозначения данной концепции являются ***неинвазивный*** (noninvasive) или ***неинтрузивный*** (nonintrusive)).
> 	> 
> 	> Термин ***статический*** означает, что связывание интерфейсов происходит в процессе компиляции (т.е. статически).

Строго говоря, в терминах языка C++ понятия ***динамический полиморфизм*** и ***статический полиморфизм*** — это сокращенные варианты понятий ***ограниченный динамический полиморфизм*** и ***неограниченный статический полиморфизм***. В других языках используются иные комбинации (например, `Smalltalk` предоставляет неограниченный динамический полиморфизм). Однако более краткие термины ***динамический полиморфизм*** и ***статический полиморфизм*** в контексте языка C++ не приводят к возникновению путаницы.

***===Преимущества и недостатки===***

Динамический полиморфизм в C++ обладает рядом преимуществ.
>
> Элегантная обработка разнородных коллекций.
> 
> Размер исполняемого кода потенциально меньше (поскольку в данном случае нужна только одна полиморфная функция, тогда как для шаблонов с разными параметрами типов должны быть сгенерированы отдельные экземпляры).
> 
> Код полностью компилируем; таким образом, исходные тексты не обязательно должны быть опубликованы (распространение библиотек шаблонов обычно требует распространения исходного кода реализации шаблонов).

Приведем преимущества статического полиморфизма в C++.
>
> Легко реализуются коллекции встроенных типов. Общность интерфейса не обязательно должна выражаться через общий базовый класс.
> 
> Сгенерированный код потенциально выполняется быстрее (поскольку отсутствует необходимость в косвенном обращении через указатели, а невиртуальные функции могут быть встраиваемыми намного чаще).
> 
> Могут использоваться конкретные типы, в которых имеются только частичные интерфейсы (только если приложение ограничивается использованием этого частичного интерфейса).

Часто статический полиморфизм расценивается как более надежный в плане безопасности типов, чем динамический, поскольку все связывания выполняются в процессе компиляции. Например, опасность того, что в контейнер, реализованный шаблоном, будет вставлен объект неправильного типа, крайне мала; в то же время в контейнере, который содержит указатели на общий базовый класс, существует возможность непреднамеренного использования указателей на объекты совершенно иного типа.

На практике инстанцирование шаблонов может вызвать определенные неприятности в том случае, когда за идентично выглядящими интерфейсами скрываются разные семантические допущения. Например, неприятные сюрпризы могут произойти тогда, когда шаблон предполагает наличие ассоциативного оператора `+` у типа, который таким оператором не обладает. Обычно этот вид семантического несоответствия встречается гораздо реже в иерархиях, основанных на наследовании; вероятно, это связано с более явным и точным определением интерфейса.

***===Объединение обеих форм===***

Конечно, можно совместить обе формы наследования. Например, различные виды геометрических объектов можно порождать из общего базового класса, для того чтобы иметь возможность обрабатывать неоднородные коллекции геометрических объектов. Однако одновременно можно использовать и шаблоны в целях написания кода для некоторого отдельного вида геометрического объекта.

Комбинация наследования и шаблонов описана в #главе_21, “Шаблоны и наследование”. В ней рассматривается (помимо прочего), как может быть параметризована виртуальность функции-члена и как можно предоставить дополнительную гибкость статическому полиморфизму, используя основанную на наследовании ***модель необычного рекуррентного шаблона*** (curiously recurring template pattern — CRTP).

# Применение концептов

Одним из аргументов против статического полиморфизма с шаблонами является то, что связывание интерфейсов выполняется путем инстанцирования соответствующих шаблонов. Это означает, что не существует некоторого общего интерфейса (класса), а работает любое использование шаблона, лишь бы весь инстанцированный код был корректен. Если же это не так, то это может привести к трудно понимаемым сообщениям об ошибках или даже вызвать корректное, но нежелательное поведение.

По этой причине разработчики языка C++ работали над возможностью явно предоставлять (и проверять) интерфейсы для параметров шаблонов. Обычно такой интерфейс называется в C++ [[Concepts|концептом]]. Он обозначает набор ограничений, которым должны отвечать аргументы шаблона для того, чтобы инстанцирование шаблона было успешным.

Несмотря на многие годы работы в этой области концепты по-прежнему не являются частью стандарта C++ — по крайней мере до стандарта C++17 включительно. Некоторые компиляторы предоставляют экспериментальную поддержку такой возможности, так что концепты, вероятно, станут частью следующего после C++17 стандарта.

Концепты можно рассматривать как своего рода “интерфейс” для статического полиморфизма. В нашем примере это может выглядеть следующим образом:
```c++
#include "coord.hpp"

template<typename T>
concept GeoObj = requires(T x)
{
	{
		x.draw() 
	} -> void;
	
	{
		x.center_of_gravity()
	} -> Coord;
};
```

Здесь ключевое слово [[Concepts|concept]] использовано для определения концепты `GeoObj`, которая ограничивает тип наличием вызываемых членов `draw()` и `center_of_gravity()` с соответствующими возвращаемыми типами.

Теперь можно переписать некоторые из наших примеров шаблонов, включив конструкцию `requires`, которая ограничивает параметры шаблона концептом `GeoObj`:
```c++
#include "conceptsreq.hpp"
#include <vector>

// Черчение любого GeoObj
template<typename T>
requires GeoObj<T>
void myDraw(T const& obj)
{
	obj.draw();  // Вызов draw() в соответствии с типом объекта
}

// Вычисление расстояния между центрами масс между двумя GeoObjs
template<typename T1, typename T2>
requires GeoObj<T1> && GeoObj<T2>
Coord distance(T1 const& x1, T2 const& x2)
{
	Coord c = x1.center_of_gravity() - x2.center_of_gravity();
	return c.abs(); // Возврат абсолютного значения
}

// Черчение однородной коллекции GeoObjs
template<typename Т>
requires GeoObj<T>
void drawElems(std::vector<T> const& elems)
{
	for (std::size_type i = 0; i < elems.size(); ++i)
	{
		elems[i].draw(); // Вызов draw() в соответствии с типом элемента
	}
}
```

Этот подход по-прежнему неинвазивный по отношению к типам, которые могут участвовать в (статическом) полиморфном поведении:
```c++
// Конкретный класс геометрического объекта Circle
// - не является производным от другого класса
// и не реализующий никакой интерфейс

class Circle
{
	public:
		void draw() const;
		Coord center_of_gravity() const;

		...
}
```

To есть такие типы по-прежнему определяются без каких-либо конкретных базовых классов или конструкций требований и могут быть фундаментальными типами данных или типов из независимых каркасов.

В #приложении_Д, “Концепты”, концепты в C++ обсуждаются более подробно, поскольку ожидается, что они войдут в следующий стандарт языка.

# Новые виды проектных шаблонов

Следствием использования новой формы статического полиморфизма являются новые пути реализации проектных шаблонов. Возьмем, например, шаблон “Мост” (Bridge pattern), который играет большую роль в программах на C++. Одна из задач использования этого проектного шаблона состоит в переключении между различными реализациями интерфейса.

Обычно это переключение осуществляется с использованием класса интерфейса, который содержит указатель для обращения к фактической реализации и делегирования всех обращений к этому классу (рис.).
![[template_3.png]]
Рис. Проектный шаблон "Мост", реализованный с использованием наследования. 

Однако если тип реализации известен во время компиляции, то вместо этого можно использовать подход с применением шаблонов (рис. ). Это приведет к большей безопасности типов и позволит избежать использования указателей, что должно способствовать более высокой производительности программы.
![[template_4.png]]
Рис. Проектный шаблон "Мост", реализованный с использованием шаблонов

# Обобщенное программирование

Статический полиморфизм порождает концепцию ***обобщенного программирования*** (generic programming). Однако единого универсального установившегося определения этого понятия не существует (как не существует и единого установившегося определения понятия ***объектно-ориентированного программирования***).


















































