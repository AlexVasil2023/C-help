
[[#Полиморфная мощь шаблонов|Полиморфная мощь шаблонов]] 18
1. [[#Динамический полиморфизм|Динамический полиморфизм]] 18.1
2. [[#Статический полиморфизм|Статический полиморфизм]] 18.2



# Полиморфная мощь шаблонов

Полиморфизм представляет собой способность связывать различные специфические виды поведения с помощью единой общей записи. Кроме того, полиморфизм является краеугольным камнем парадигмы объектно-ориентированного программирования, которая в C++ поддерживается главным образом через наследование свойств классов и виртуальные функции. Поскольку этот механизм (по крайней мере частично) работает во время выполнения программы, можно употребить термин динамический полиморфизм. Обычно так говорят, когда речь идет об обычном полиморфизме в C++. Однако шаблоны также позволяют связывать различные специфические виды поведения единой общей записью, но это связывание обрабатывается, как правило, в процессе компиляции, так что в данном случае следует говорить о статическом полиморфизме. В этой главе приводится обзор обоих вариантов полиморфизма и обсуждается вопрос, какой из них
соответствует той или иной конкретной ситуации.

Обратите внимание на то, что в #главе_22, “Статический и динамический полиморфизм”, обсуждаются некоторые способы работы с полиморфизмом после введения и обсуждения ряда вопросов проектирования.

# Динамический полиморфизм

Исторически сложилось так, что язык C++ начался с поддержки полиморфизма только посредством наследования, объединенного с виртуальными функциями. В этом контексте искусство полиморфного дизайна состоит в идентификации общего набора возможностей среди связанных типов объектов и объявлении их в качестве интерфейсов виртуальных функций в общем базовом классе.

Наглядным примером этого подхода к конструированию является приложение, которое управляет построением геометрических фигур с возможностью их воспроизведения определенным способом (например, на экране). В таком приложении можно указать так называемый ***абстрактный базовый класс*** (abstract base class — ABC) `GeoObj`, который объявляет общие операции и свойства, применимые к геометрическим объектам вообще. Каждый конкретный класс для конкретных геометрических объектов будет затем порождаться из абстрактного базового класса `GeoObj` (рис.).
![[template_1.png]]
Рис. Полиморфизм, реализованный с помощью наследования

```c++
#include "coord.hpp"

// Общий абстрактный базовый класс GeoObj
// для геометрических объектов
class GeoObj
{
	public:
		// Черчение геометрического объекта:
		virtual void draw() const = 0;
		
		// Возврат центра масс геометрического объекта:
		virtual Coord center_of_gravity() const = 0;

		...
	
		virtual ~GeoObj() = default;
};

// Конкретный класс геометрического объекта Circle
// - унаследован от GeoObj
class Circle : public GeoObj
{
	public:
		virtual void draw() const override;
		virtual Coord center_of_gravity() const override;

		...
};

// Конкретный класс геометрического объекта Line
// - унаследован от GeoObj
class Line : public GeoObj
{
	public:
		virtual void draw() const override;
		virtual Coord center_of_gravity() const override;

		...
};

...
```

После создания конкретных объектов клиентский код может управлять этими объектами через ссылки или указатели на базовый класс, который дает возможность задействовать механизм диспетчеризации виртуальных функций. В результате вызова виртуальной функции-члена посредством указателя или ссылки на подобъект базового класса происходит вызов соответствующего члена объекта, на который осуществлялась ссылка.

В нашем примере конкретный код может выглядеть, как показано ниже.
```c++
#include "dynahier.hpp"
#include <vector>

// Черчение любого GeoObj
void myDraw(GeoObj consts obj)
{
	obj.draw();  // Вызов draw() в соответствии с типом объекта
)

// Вычисление расстояния между центрами масс двух GeoObjs
Coord distance(GeoObj const& x1, GeoObj const& x2)
{
	Coord c = x1.center_of_gravity() - x2.center_of_gravity();
	return c.abs();  // Возврат абсолютного значения
}

// Черчение неоднородного набора объектов GeoObjs
void drawElems(std::vector<GeoObj*> const& elems)
{
	for(std::size_type i = 0; i < elems.size(); ++i)
	{
		elems[i]->draw();   // Вызов draw() в соответствии
							// с типом элемента
	}
}

int main()
{
	Line l;
	Circle c, c1, c2;
	
	myDraw(l);        // myDraw(GeoObj&) => Line::draw()
	myDraw(c);        // myDraw(GeoObj&) => Circle::draw()
	
	distance(c1, c2); // distance(GeoObj &,GeoObj &)
	distance(l, c);   // distance(GeoObj &,GeoObj &)
	
	std::vector<GeoObj*> coll; // Неоднородная коллекция
	coll.push_back(&l);        // Вставка линии
	coll.push_back(&c);        // Вставка окружности

	drawElems(coll);           // Черчение разных GeoObjs
}
```

Ключевыми элементами полиморфного интерфейса являются функции `draw()` и `center_of_gravity()`. Обе функции являются виртуальными функциями-членами. В нашем примере продемонстрировано их использование в функциях `myDraw()`, `distance()` и `drawElems()`. Последние три функции записаны с использованием общего базового типа `GeoObj`. Вследствие этого в процессе компиляции нельзя определить, какая именно версия функции `draw()` или `center_of_gravity()` должна использоваться. Однако в процессе выполнения программы при диспетчеризации вызовов функций определяется полный динамический тип объектов, для которых вызываются виртуальные функции. Следовательно, соответствующая операция выполняется в зависимости от фактического типа геометрического объекта: если `myDraw()` вызывается для объекта `Line`, то выражение `obj.draw()` вызывает функцию `Line::draw()`, тогда как для объекта `Circle` вызывается функция `Circle::draw()`. Подобным же образом в вызове `distance()` функции-члены `center_of_gravity()` соответствуют переданным в качестве параметров объектам.

Пожалуй, наиболее впечатляющей возможностью динамического полиморфизма является способность обрабатывать разнородные коллекции объектов. Эта концепция иллюстрируется функцией `drawElems()`; простое выражение
```c++
elems[1]->draw()
```

выполняет вызов разных функций-членов, в зависимости от типа итерируемого элемента.

# Статический полиморфизм


































