
[[#Полиморфная мощь шаблонов|Полиморфная мощь шаблонов]] 18
1. [[#Динамический полиморфизм|Динамический полиморфизм]] 18.1
2. [[#Статический полиморфизм|Статический полиморфизм]] 18.2
3. [[#Сравнение динамического и статического полиморфизма|Сравнение динамического и статического полиморфизма]] 18.3



# Полиморфная мощь шаблонов

Полиморфизм представляет собой способность связывать различные специфические виды поведения с помощью единой общей записи. Кроме того, полиморфизм является краеугольным камнем парадигмы объектно-ориентированного программирования, которая в C++ поддерживается главным образом через наследование свойств классов и виртуальные функции. Поскольку этот механизм (по крайней мере частично) работает во время выполнения программы, можно употребить термин динамический полиморфизм. Обычно так говорят, когда речь идет об обычном полиморфизме в C++. Однако шаблоны также позволяют связывать различные специфические виды поведения единой общей записью, но это связывание обрабатывается, как правило, в процессе компиляции, так что в данном случае следует говорить о статическом полиморфизме. В этой главе приводится обзор обоих вариантов полиморфизма и обсуждается вопрос, какой из них
соответствует той или иной конкретной ситуации.

Обратите внимание на то, что в #главе_22, “Статический и динамический полиморфизм”, обсуждаются некоторые способы работы с полиморфизмом после введения и обсуждения ряда вопросов проектирования.

# Динамический полиморфизм

Исторически сложилось так, что язык C++ начался с поддержки полиморфизма только посредством наследования, объединенного с виртуальными функциями. В этом контексте искусство полиморфного дизайна состоит в идентификации общего набора возможностей среди связанных типов объектов и объявлении их в качестве интерфейсов виртуальных функций в общем базовом классе.

Наглядным примером этого подхода к конструированию является приложение, которое управляет построением геометрических фигур с возможностью их воспроизведения определенным способом (например, на экране). В таком приложении можно указать так называемый ***абстрактный базовый класс*** (abstract base class — ABC) `GeoObj`, который объявляет общие операции и свойства, применимые к геометрическим объектам вообще. Каждый конкретный класс для конкретных геометрических объектов будет затем порождаться из абстрактного базового класса `GeoObj` (рис.).
![[template_1.png]]
Рис. Полиморфизм, реализованный с помощью наследования

```c++
#include "coord.hpp"

// Общий абстрактный базовый класс GeoObj
// для геометрических объектов
class GeoObj
{
	public:
		// Черчение геометрического объекта:
		virtual void draw() const = 0;
		
		// Возврат центра масс геометрического объекта:
		virtual Coord center_of_gravity() const = 0;

		...
	
		virtual ~GeoObj() = default;
};

// Конкретный класс геометрического объекта Circle
// - унаследован от GeoObj
class Circle : public GeoObj
{
	public:
		virtual void draw() const override;
		virtual Coord center_of_gravity() const override;

		...
};

// Конкретный класс геометрического объекта Line
// - унаследован от GeoObj
class Line : public GeoObj
{
	public:
		virtual void draw() const override;
		virtual Coord center_of_gravity() const override;

		...
};

...
```

После создания конкретных объектов клиентский код может управлять этими объектами через ссылки или указатели на базовый класс, который дает возможность задействовать механизм диспетчеризации виртуальных функций. В результате вызова виртуальной функции-члена посредством указателя или ссылки на подобъект базового класса происходит вызов соответствующего члена объекта, на который осуществлялась ссылка.

В нашем примере конкретный код может выглядеть, как показано ниже.
```c++
#include "dynahier.hpp"
#include <vector>

// Черчение любого GeoObj
void myDraw(GeoObj consts obj)
{
	obj.draw();  // Вызов draw() в соответствии с типом объекта
)

// Вычисление расстояния между центрами масс двух GeoObjs
Coord distance(GeoObj const& x1, GeoObj const& x2)
{
	Coord c = x1.center_of_gravity() - x2.center_of_gravity();
	return c.abs();  // Возврат абсолютного значения
}

// Черчение неоднородного набора объектов GeoObjs
void drawElems(std::vector<GeoObj*> const& elems)
{
	for(std::size_type i = 0; i < elems.size(); ++i)
	{
		elems[i]->draw();   // Вызов draw() в соответствии
							// с типом элемента
	}
}

int main()
{
	Line l;
	Circle c, c1, c2;
	
	myDraw(l);        // myDraw(GeoObj&) => Line::draw()
	myDraw(c);        // myDraw(GeoObj&) => Circle::draw()
	
	distance(c1, c2); // distance(GeoObj &,GeoObj &)
	distance(l, c);   // distance(GeoObj &,GeoObj &)
	
	std::vector<GeoObj*> coll; // Неоднородная коллекция
	coll.push_back(&l);        // Вставка линии
	coll.push_back(&c);        // Вставка окружности

	drawElems(coll);           // Черчение разных GeoObjs
}
```

Ключевыми элементами полиморфного интерфейса являются функции `draw()` и `center_of_gravity()`. Обе функции являются виртуальными функциями-членами. В нашем примере продемонстрировано их использование в функциях `myDraw()`, `distance()` и `drawElems()`. Последние три функции записаны с использованием общего базового типа `GeoObj`. Вследствие этого в процессе компиляции нельзя определить, какая именно версия функции `draw()` или `center_of_gravity()` должна использоваться. Однако в процессе выполнения программы при диспетчеризации вызовов функций определяется полный динамический тип объектов, для которых вызываются виртуальные функции. Следовательно, соответствующая операция выполняется в зависимости от фактического типа геометрического объекта: если `myDraw()` вызывается для объекта `Line`, то выражение `obj.draw()` вызывает функцию `Line::draw()`, тогда как для объекта `Circle` вызывается функция `Circle::draw()`. Подобным же образом в вызове `distance()` функции-члены `center_of_gravity()` соответствуют переданным в качестве параметров объектам.

Пожалуй, наиболее впечатляющей возможностью динамического полиморфизма является способность обрабатывать разнородные коллекции объектов. Эта концепция иллюстрируется функцией `drawElems()`; простое выражение
```c++
elems[1]->draw()
```

выполняет вызов разных функций-членов, в зависимости от типа итерируемого элемента.

# Статический полиморфизм

Шаблоны также могут использоваться для реализации полиморфизма. Однако они не зависят от фактора общего поведения, свойственного базовым классам. Вместо этого общность подразумевает поддержку операций с использованием общего синтаксиса (т.е. соответствующие функции имеют одни и те же имена). Конкретные классы при этом определяются независимо друг от друга (рис.), а сам полиморфизм проявляется при инстанцировании шаблонов с конкретными классами.
![[template_2.png]]
Рис. Полиморфизм, реализованный с помощью шаблонов

Например, функция `myDraw()` из предыдущего раздела
```c++
void myDraw (GeoObj const& obj)  // GeoObj - абстрактный базовый класс
{
	obj.draw();
}
```

может быть переписана следующим образом:
```c++
template<typename GeoObj>
void myDraw (GeoObj const& obj) // GeoObj - параметр шаблона
{
	obj.draw();
}
```

Сравнивая эти две реализации функции `myDraw()`, можно видеть, что основное различие состоит в указании `GeoObj` в качестве параметра шаблона вместо указания в качестве общего базового класса. Имеются, однако, и более существенные различия. Например, при использовании динамического полиморфизма в процессе выполнения у нас была только одна функция `myDraw()`, тогда как, применяя шаблон, мы имеем различные функции, такие как `myDraw<Line>()` и `myDraw<Circle>()`.

Можно попытаться переписать весь пример из предыдущего раздела с использованием статического полиморфизма. При этом вместо иерархии геометрических классов у нас появится несколько индивидуальных геометрических классов.
```c++
#include "coord.hpp"

// Конкретный класс геометрического объекта Circle
// - не являющийся производным от какого-либо иного класса
class Circle
{
	public:
		void draw() const;
		Coord center_of_gravity() const;

		...
};

// Конкретный класс геометрического объекта Line
// - не являющийся производным от какого-либо иного класса
class Line
(
	public:
		void draw() const;
		Coord center_of_gravity() const;

		...
};

...
```

Теперь применение этих классов имеет следующий вид:
```c++
#include "statichier.hpp"
#include <vector>

// Черчение любого GeoObj
template<typename GeoObj>
void myDraw(GeoObj const& obj)
{
	obj.draw()); // Вызов draw() в соответствии с типом объекта
}

// Вычисление расстояния между центрами масс двух GeoObjs
template<typename GeoObj1, typename GeoObj2>
Coord distance(GeoObj1 const& x1, GeoObj2 const& x2)
{
	Coord c = x1.center_of_gravity() - x2.center_of_gravity();
	return c.abs(); // Возврат абсолютного значения
}

// Черчение однородного набора объектов GeoObjs
template<typename GeoObj>
void drawElems(std::vector<GeoObj> const& elems)
{
	for (unsigned i = 0; i c elems.size(); ++i)
	{
		elems[i].draw();    // Вызов draw() в соответствии
							//с типом объекта
	}
}

int main()
{
	Line l;
	Circle с, c1, c2;
	
	myDraw(l); // myDraw<Line>(GeoObj&) => Line::draw()
	myDraw(c); // myDraw<Circle>(GeoObj&) => Circle::draw()
	
	distance (c1, c2); // distance<Circle,Circle>(GeoObj1 &,GeoObj2 &) 
	distance(l, c);    // distance<Line,Circle>(GeoObj1 &,GeoObj2 &)

	// std::vector<GeoObj*> coll;   // Ошибка: гетерогенная
									// коллекция невозможна

	std::vector<Line> coll;         // OK: гомогенная коллекция
	coll.push_back(1);              // Вставка линии
	drawElems(coll);                // Черчение всех линий
}
```

Тип `GeoObj` больше не может использоваться в качестве конкретного параметра типа как для функции `distance()`, так и в функции `myDraw()`. Вместо этого в функции `distance()` предусмотрены два параметра шаблона — `GeoObj1` и `GeoObj 2`. Два разных параметра шаблона позволяют вычислять расстояние между разными типами геометрических объектов:
```c++
distance(l, с); // distance<Line,Circle>(GeoObj1 &,GeoObj2 &)
```

Теперь, однако, разнородные коллекции больше не могут быть прозрачно обработаны. Это тот случай, когда статическая часть статического полиморфизма налагает свои ограничения, а именно: все типы должны быть определены во время компиляции. Взамен предоставляется возможность легко вводить разные коллекции для различных типов геометрических объектов; к тому же больше не требуется, чтобы коллекция была ограничена указателями, что дает существенные преимущества в аспекте производительности и безопасности типов.

# Сравнение динамического и статического полиморфизма

А теперь классифицируем и сравним обе формы полиморфизма.

***===Терминология===***

Динамический и статический полиморфизм обеспечивает поддержку различных идиом языка программирования C++.
>
> Полиморфизм, реализованный с использованием наследования, является ***ограниченным***, или ***связанным*** (bounded) и ***динамическим*** (dynamic).
> 	> Термин ***ограниченный*** означает, что интерфейсы типов, участвующих в процессе полиморфизма, предопределены дизайном общего базового класса (другими терминами для обозначения данной концепции являются ***инвазивный*** (invasive) или ***интрузивный*** (intrusive)).
> 	> 
> 	> Термин ***динамический*** означает, что связывание интерфейсов происходит в процессе выполнения программы (т.е. динамически).
> 
> Полиморфизм, реализованный с использованием шаблонов, является ***неограниченным*** (unbounded) и ***статическим*** (static).
> 	> 
> 	> Термин ***неограниченный*** означает, что интерфейсы типов, участвующих в процессе полиморфизма, не предопределены заранее (другими терминами для обозначения данной концепции являются ***неинвазивный*** (noninvasive) или ***неинтрузивный*** (nonintrusive)).
> 	> 
> 	> Термин ***статический*** означает, что связывание интерфейсов происходит в процессе компиляции (т.е. статически).

Строго говоря, в терминах языка C++ понятия ***динамический полиморфизм*** и ***статический полиморфизм*** — это сокращенные варианты понятий ***ограниченный динамический полиморфизм*** и ***неограниченный статический полиморфизм***. В других языках используются иные комбинации (например, `Smalltalk` предоставляет неограниченный динамический полиморфизм). Однако более краткие термины ***динамический полиморфизм*** и ***статический полиморфизм*** в контексте языка C++ не приводят к возникновению путаницы.

***===Преимущества и недостатки===***










































