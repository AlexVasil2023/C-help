
[[#Вывод аргументов шаблона|Вывод аргументов шаблона]] 15
1. [[#Процесс вывода|Процесс вывода]] 15.1
2. [[#Выводимые контексты|Выводимые контексты]] 15.2
3. [[#Особые ситуации вывода|Особые ситуации вывода]] 15.3
4. [[#Списки инициализаторов|Списки инициализаторов]] 15.4
5. [[#Пакеты параметров|Пакеты параметров]] 15.5
	1. [[#Шаблоны оператора литерала|Шаблоны оператора литерала]] 15.5.1
6. [[#Ссылки на r-значения|Ссылки на r-значения]] 15.6
	1. [[#Правила свертки ссылок|Правила свертки ссылок]] 15.6.1
	2. [[#Передаваемые ссылки|Передаваемые ссылки]] 15.6.2
	3. [[#Прямая передача|Прямая передача]] 15.6.3
	4. [[#Сюрпризы вывода|Сюрпризы вывода]] 15.6.4
7. [[#Принцип SFINAE|Принцип SFINAE]] 15.7
	1. [[SFINAE#Непосредственный контекст|Непосредственный контекст]] 15.7.1
8. [[#Ограничения вывода|Ограничения вывода]] 15.8
	1. [[#Допустимые преобразования аргументов|Допустимые преобразования аргументов]] 15.8.1
	2. [[#Аргументы шаблона класса|Аргументы шаблона класса]] 15.8.2
	3. [[#Аргументы вызова по умолчанию|Аргументы вызова по умолчанию]] 15.8.3
	4. [[#Спецификации исключений|Спецификации исключений]] 15.8.4
9. [[#Явные аргументы шаблонов функций|Явные аргументы шаблонов функций]] 15.9
10. [[#Вывод из инициализаторов и выражений|Вывод из инициализаторов и выражений]] 15.10
	1. [[#Спецификатор типа auto|Спецификатор типа auto]] 15.10.1
	2. [[decltуре#Запись типа выражения с помощью decltype|Запись типа выражения с помощью decltype]] 15.10.2
	3. [[decltуре#decltype(auto) C++14|decltype (auto)]] 15.10.3
	4. [[auto#Особые случаи вывода auto|Особые случаи вывода auto]] 15.10.4
	5. [[#Структурированное связывание|Структурированное связывание]] 15.10.5
	6. [[#Обобщенные лямбда-выражения|Обобщенные лямбда-выражения]] 15.10.6
11. [[#Шаблоны псевдонимов|Шаблоны псевдонимов]] 15.11
12. [[#Вывод аргументов шаблонов классов|Вывод аргументов шаблонов классов]] 15.12
	1. [[#Правила вывода|Правила вывода]] 15.12.1
	2. [[#Неявные правила вывода|Неявные правила вывода]] 15.12.2
	3. [[#Прочие тонкости|Прочие тонкости]] 15.12.3

# Вывод аргументов шаблона

Если при каждом вызове шаблона функции явным образом задавать аргументы шаблона (например,` concat<std::string, int> (s, 3)` ), то код может быстро стать громоздким. К счастью, компилятор C++ часто в состоянии автоматически определить, какими должны быть аргументы шаблона. Это достигается с помощью мощного механизма под названием ***вывод аргументов шаблона*** (template argument deduction).

В этой главе подробно объясняется, что происходит в процессе вывода аргументов шаблонов. Как это часто бывает в C++, с этим процессом связано множество правил, соблюдение которых обычно приводит к интуитивно понятному результату. Глубокое понимание материала, изложенного в этой главе, позволит избежать многих досадных неожиданностей.

Хотя вывод аргументов шаблона был впервые разработан для упрощения вызова шаблонов функций, он с тех пор был расширен для ряда других использований, включая определение типов переменных из их инициализаторов.

# Процесс вывода

В процессе вывода типы аргументов вызова функции сравниваются с соответствующими типами параметров шаблона функции, и компилятор пытается сделать вывод о том, что именно нужно подставить вместо одного или нескольких выведенных параметров. Анализ каждой пары “аргумент-параметр” проводится независимо, и, если выводы в конечном итоге отличаются, процесс вывода завершается неудачей. Рассмотрим следующий пример:
```c++
template<typename Т>
Т max (Т а, Т Ь)
{
	return b < а ? а : Ь;
}

auto g = max(1, 1.0);
```

Здесь первый аргумент вызова имеет тип `int`, из чего можно заключить, что в роли параметра `Т` в исходном шаблоне `max()` должен выступать тип `int`. Однако второй аргумент вызова имеет тип `double`, а это означает, что вместо параметра типа `Т` нужно подставить тип `double`. Этот вывод противоречит предыдущему. Заметим, что утверждение “вывод выполнить не удается” не означает, что программа некорректна. В конце концов может случиться так, что этот процесс удастся провести для другого шаблона с именем `max` ([[Шаблоны функций - template#Перегрузка шаблонов функций|шаблоны функций, как и обычные функции, можно перегружать]]; #главу_16, “Специализация и перегрузка”).

Даже если удалось вывести все параметры шаблона, это еще не означает, что вывод успешен. Бывает и так, что при подстановке выведенных аргументов в оставшуюся часть определения функции получается некорректная конструкция. Например:
```c++
template<typename Т>
typename T::ElementT at(T a, int i)
{
	return a[i];
}

void f(int* p)
{
	int x = at(p, 7);
}
```

Здесь `T` выводится как `int*` (тут имеется только один тип параметра, в котором появляется `Т`, так что, очевидно, никакой конфликт анализа невозможен). Однако подстановка `int*` вместо `Т` в возвращаемом типе `Т::ElementT`, очевидно, представляет собой некорректный код C++, и процесс вывода завершается неудачей.

Рассмотрим, как происходит процедура проверки соответствия параметра и аргумента. Опишем его в терминах соответствия типа `a` (выведенного из типа аргумента) параметризованному типу `p` (выведенному из объявления параметра вызова). Если параметр объявлен как ссылка, считаем, что `p` — это тип, на который делается ссылка, а `a` — тип аргумента. В противном случае `p` представляет собой объявленный тип параметра, а тип `a` получается из типа аргумента путем низведения (decaying) типов массива или функции к указателю на соответствующий тип. При этом квалификаторы верхнего уровня [[const|const]] и [[volatile|volatile]] игнорируются. Например:
```c++
template<typename Т> void f(Т);     // Параметризованный тип p
									// представляет собой тип Т
template<typename Т> void g(Т&) ;   // Параметризованный тип p также
									// представляет собой Т
double arr[20];
int const seven = 7;

f(arr);             // Передача по значению: T является double*
g(arr);             // Передача по ссылке: T является double[20]
f(seven);           // Передача по значению: T является int
g(seven);           // Передача по ссылке: T является int const
f(7);               // Передача по значению: T является int
g(7);               // Передача по ссылке: T является int => Ошибка: нельзя
					// передать 7 в int&
```

При вызове `f(arr)` тип массива `arr` низводится к типу `double*`, который представляет собой тип, выведенный для `Т`. В `f(seven)` квалификатор [[const|const]] убирается и, следовательно, `Т` выводится как `int`. Напротив, вызов `g(х)` приводит к выводу `Т` как типа `double[20]` (низведение не выполняется). Аналогично `g(seven)` имеет аргумент, являющийся [[значение - template#l-значение|l-значением]] типа `int const`, а, поскольку квалификаторы [[const|const]] и [[volatile|volatile]] не отбрасываются при сопоставлении ссылочных параметров, `Т` выводится как `int const`. Обратите, однако, внимание на то, что `g(7)` приводит к выводу `Т` как `int` (поскольку выражение [[значение - template#r-значения|r-значения]], не являющееся классом, никогда не имеет квалификаторы типа [[const|const]] или [[volatile|volatile]]), и вызов будет неудачным, так как аргумент `7` не может быть передан параметру типа `int&`.

Тот факт, что для аргументов, которые передаются по ссылке, низведение не выполняется, может привести к неожиданным результатам в тех случаях, когда эти аргументы являются строковыми литералами. Еще раз рассмотрим шаблон `max()`, объявленный со ссылками:
```c++
template<typename Т>
Т const& max(T const& а, Т const& b);
```

Разумно было бы ожидать, что в выражении `max("Apple", "Pie")` параметр `Т` будет выведен как тип `char const*`. Однако строка `"Apple"` имеет тип `char const [6]`, а строка `"Pie"` — тип `char const [4]`. Никакого низведения массива к указателю на массив не происходит (поскольку вывод типа выполняется на основе параметров, передаваемых по ссылке). Таким образом, вместо параметра `Т` нужно одновременно подставить и тип `char [6]`, и тип `char [4]`, а это, конечно же, невозможно. [[По значению или по ссылке - template#Работа со строковыми литералами и массивами|Более подробное обсуждение этой темы]].

# Выводимые контексты

Типу аргумента могут соответствовать значительно более сложные параметризованные типы, чем просто `Т`. Ниже приведено несколько (все еще не слишком сложных) примеров:
```c++
template<typename Т>
void f1(Т*);

template<typename Е, int N>
void f2(E(&)[N]);

template<typename T1, typename T2, typename T3>
void f3(T1(T2::*)(T3*));

class S
{
	public:
		void f(double*);
};

void g(int*** ррр)
{
	bool b[42];
	
	f1(ррр);              // T выводится как int**
	f2(b);                // Е выводится как bool, а N - как 42
	f3(&S::f);            // Выводится: T1 = void, Т2 = S и ТЗ = double
}
```

Сложные объявления типов составляются из более простых конструкций (деклараторов указателей, ссылок, массивов и функций, деклараторов указателей на члены, идентификаторов шаблонов и т.д.). Процесс определения нужного типа происходит в нисходящем порядке, начиная с конструкций высокого уровня и рекурсивно продвигаясь к составляющим их элементам. Уместно заметить, что этим путем можно подобрать тип для большинства конструкций объявлений типов; в этом случае они называются выводимым контекстом (deduced context). Однако некоторые конструкции выводимым контекстом не являются. К их числу относятся следующие.
>
> Квалифицированное имя типа. Например, имя типа наподобие `Q<T>::Х` никогда не используется для вывода параметра шаблона `Т`.
> 
> Выражения, не являющиеся типами, но которые при этом не являются нетиповыми параметрами (не являющимися типами). Например, ни имя типа наподобие `S<I+1>` никогда не используется для вывода `I`, ни параметр `Т` не выводится путем сравнения с параметром типа `int(&)[sizeof(S<T>)]`.

Эти ограничения не должны вызывать удивления, поскольку в общем случае вывод может оказаться неоднозначным (может даже оказаться, что подходящих типов бесконечно много), хотя ограничение на квалифицированные имена типов иногда легко просмотреть. Если в программе встречается невыводимый контекст, это еще не означает, что программа содержит ошибку или что анализируемый параметр не может принимать участия в выводе типа. Чтобы это проиллюстрировать, рассмотрим более сложный пример.
```c++
template<int N>
class X
{
	public:
		using I = int;
		void f(int)
		{   }
};

template<int N>
void fppm(void (X<N>::*p)(typename X<N>::I));

int main()
{
	fppm(&X<33>::f);            // Все в порядке: N выводится как 33
}
```

Конструкция `X<N>::I`, которая находится в шаблоне функции `fppm ()`, является невыводимым контекстом; однако использующийся в ней компонент `X<N>` члена класса с типом указателя на член класса является выводимым контекстом. Когда выведенный из этого компонента параметр `N` подставляется в невыводимый контекст, получается тип, совместимый с типом фактического аргумента (`&Х<33>:: f`). Таким образом, для этой пары “аргумент-параметр” вывод удается успешно выполнить до конца.

И наоборот, если параметр типа состоит только из выводимого контекста, то это еще не означает, что вывод не приведет к противоречиям. Например, предположим, что у нас имеются надлежащим образом объявленные шаблоны классов `X` и `Y`. Рассмотрим приведенный ниже код.
```c++
template<typename Т>
void f(X<Y<T>, Y<T>>);

void g()
{
	f(X<Y<int>, Y<int>>());      // OK
	f(X<Y<int>, Y<char>>());     // Ошибка: неудачный вывод
}
```

Проблема, связанная со вторым вызовом шаблона функции `f()`, заключается в том, что для параметра `Т` на основе двух аргументов функции выводятся разные типы, что приводит к противоречию. (В обоих вызовах аргументы функции являются временными объектами, полученными путем вызова конструктора по умолчанию для шаблона класса `X`.)

# Особые ситуации вывода

Возможны несколько ситуаций, в которых использующаяся для вывода пара `(Р, А)` получается не из аргументов вызова функции и параметров шаблона функции. Первая ситуация осуществляется, когда используется адрес шаблона функции. В этом случае `Р` — это параметризованный тип объявления шаблона функции, а `A` — тип функции, на которую ссылается инициализируемый указатель или указатель, которому присваивается значение. Например:
```c++
template<typename Т>
void f(Т, Т);
void (*pf)(char, char) = &f;
```

В этом примере `Р` — `void (Т, Т)`, а `A` — `void (char, char)`. Вывод успешен, при этом `Т` заменяется на `char`, a `pf` инициализируется адресом специализации `f<char>`.

Аналогично типы функций для `Р` и `A` используются и в некоторых других особых ситуациях.
>
> Определение частичного упорядочения между перегруженными шаблонами функций.
> 
> Соответствие явной специализации шаблону функции.
>
> Соответствие явного инстанцирования шаблону.
> 
> Соответствие шаблону специализации шаблона дружественной функции.
> 
> Соответствие шаблонов размещающих операторов `operator delete` или `operator delete[]` соответствующим шаблонам размещающих операторов `operator new` или `operator new []`.

Некоторые из этих тем, наряду с использованием вывода аргумента шаблона для частичной специализации шаблона класса, получат дальнейшее развитие в #главе_16, “Специализация и перегрузка”.

Еще одна особая ситуация связана с шаблоном оператора преобразования типа. Например:
```c++
class S
{
	public:
		template<typename Т> operator Т&
};
```

В этом случае пара `(Р, A)` получается таким образом, как если бы в нее входил аргумент того типа, к которому мы пытаемся выполнить преобразование, и тип параметра, возвращаемый оператором преобразования. Приведенный ниже код иллюстрирует один из возможных вариантов этой ситуации.
```c++
void f(int (&)[20]);
void g(S s)
{
	f(s);
}
```

В этом фрагменте делается попытка преобразовать `S` к типу `int(&)[20]`. Поэтому тип `А` — это `int[20]`, а тип `Р` — это `Т`. Процесс вывода выполняется успешно, и `Т` заменяется типом `int[20]`.

Наконец, отдельное рассмотрение требуется для вывода заместителя типа [[auto|auto]] (см. #раздел_15_10_4).

# Списки инициализаторов

Когда в качестве аргумента функции выступает список инициализации, такой аргумент не имеет определенного типа, так что в общем случае вывод из данной пары `(Р,А)` не выполняется за отсутствием `А`. Например:
```c++
#include <initializer_list>

template<typename Т> void f(Т p);
int main()
{
	f({1,2,3});                  // Ошибка: невозможно вывести T
}                                // из списка в фигурных скобках
```

Однако, если тип `Р` параметра после удаления ссылочности и квалификаторов верхнего уровня [[const|const]] и [[volatile|volatile]] эквивалентен `std::initializer_list<P0>` для некоторого типа `Р`, который имеет выводимую схему, вывод продолжается путем сравнения Р0 с типом каждого элемента в списке инициализаторов, и успешно завершается, только если все элементы имеют один и тот же тип:
```c++
#include <initializer_list>

template<typename T> void f(std::initializer_list<T>);
int main()
{
	f({2, 3, 5, 7, 9});                 //OK: T выводится как int
	f({'a','e',' i','o', 'u', 42});     // Ошибка: T выводится
}                                       // и как char, и как int
```

Аналогично, если тип параметра `Р` является ссылкой на тип массива с типом элементов `Р0` для некоторого типа `Р0`, имеющего выводимую схему, то вывод выполняется путем сравнения `Р0` с типом каждого элемента в списке инициализаторов, и является успешным, только если все элементы имеют один и тот же тип. Кроме того, если граница имеет выводимую схему (т.е. просто именует параметр шаблона, не являющийся типом), то эта граница выводится как количество элементов в списке.

# Пакеты параметров

Процесс вывода проверяет соответствие каждого аргумента каждому параметру для определения значений аргументов шаблона. Однако при выполнении вывода аргумента шаблона для вариативных шаблонов отношение “один к одному” между параметрами и аргументами больше не выполняется, потому что пакету параметров могут соответствовать несколько аргументов. В этом случае один и тот же пакет параметров (`Р`) сопоставляется нескольким аргументам (`A`), и каждое соответствие производит дополнительные значения для любого пакета параметров шаблонов в `Р`:
```c++
template<typename First, typename... Rest>
void f(First first, Rest... rest);
void g(int i, double j, int* k)
{
	f(i, j, k);  // Вывод First как int, Rest как {double, int*}
}
```

Здесь вывод первого параметра функции прост, поскольку он не включает каких-либо пакетов параметров. Второй параметр функции, `rest`, представляет собой пакет параметров функции. Его тип — раскрытие пакета (`Rest...`), схема которого имеет тип `Rest`: этот шаблон служит в качестве `Р`, для сравнения с типами `А` второго и третьего аргументов. При сравнении с первым таким `А` (тип `double`), первое значение в пакете параметров шаблона `Rest` выводится как `double`. Аналогично, когда сравнивается второй такой `А` (тип `int*`), второе значение в пакете параметров шаблона `Rest` выводится как `int*`. Таким образом, вывод определяет значение пакета параметров `Rest` как последовательность `{double, int*}`. Подстановка результатов этого вывода и вывода для первого параметра функции дает тип функции `void (int, double, int*)`, который соответствует типам аргументов в точке вызова.

Поскольку вывод для пакетов параметров функций использует для сравнения схему раскрытия, схема может быть произвольно сложной, а значения для нескольких параметров шаблона и пакетов параметров могут быть определены из каждого типа аргументов. Рассмотрим поведение вывода для представленных ниже функций `h1()` и `h2()`:
```c++
template<typename Т, typename U> class pair{};

template<typename T, typename... Rest>
void h1(pair<T, Rest> const& ...);

template<typename... Ts, typename... Rest>
void h2(pair<Ts, Rest> const& ...);

void foo(pair<int, float> pif, pair<int, double> pid,
			pair<double, double> pdd)
{
	h1(pif, pid);   // OK; T - int, Rest - {float, double}
	h2(pif, pid);   // OK: Ts - {int, int}, Rest - {float, double}
	h1(pif, pdd);   // Ошибка: T - int bp первого аргумента,
					// но double из второго
	h2(pif, pdd);   // OK: Ts - {int, double}, Rest - {float, double}
```

И для `h1()`, и для `h2()` `P` — это ссылочный тип, приведенный к неквалифицированной версии ссылки (`pair<T, Rest>` или `pair<Ts, Rest>` соответственно) для вывода типа каждого аргумента. Так как все параметры и аргументы являются специализациями шаблона класса [[pair|pair]], сравниваются аргументы шаблона. Для `h1()` первый аргумент шаблона (`Т`) не является пакетом параметров, поэтому его значение выводится независимо для каждого аргумента. Если выведенные типы отличаются, как во втором вызове `h1()`, вывод является неуспешным. Для второго аргумента шаблона [[pair|pair]] в `h1()` и `h2()` (`Rest`) и для первого аргумента [[pair|pair]] в `h2()` (`Ts`) вывод из каждого из типов аргументов в `А` определяет последовательные значения пакетов параметров шаблонов.

Вывод для пакетов параметров не ограничивается пакетами параметров функции, где из аргументов вызова получаются пары “аргумент-параметр”. Фактически этот вывод используется везде, где раскрытие пакета находится в конце списка параметров функции или списка аргументов шаблонов. Рассмотрим две аналогичные операции над простым типом [[tuple|Tuple]]:
```c++
template<typename... Types> class Tuple { };

template<typename... Types>
bool f1(Tuple<Types...>, Tuple<Types...>);

template<typename... Types1, typename... Types2>
bool f2(Tuple<Types1...>, Tuple<Types2...>);

void bar(Tuple<short, int, long> sv,
		 Tuple<unsigned short, unsigned, unsigned long> uv)
{
	f1(sv, sv); // OK: Types выполняется как {short, int, long}
	f2(sv, sv); // OK: Types1 выполняется как {short, int, long}
				// Types2 выводится как {short, int, long}

	f1(sv, uv); // Ошибка: Types выводится как {short, int, long}
				// из первого аргумента, но как {unsigned	
				// short, unsigned, unsigned long} из второго
	f2(sv, uv); // OK: Types1 Typesl выводится как {short, int, long},
				// Types2 выводится как {unsigned short,
				// unsigned, unsigned long}
```

И в `f1()`, и в `f2()` пакеты параметров шаблонов выводятся путем сравнения схемы раскрытия пакета, встроенного в тип [[tuple|Tuple]] (например, `Types` для `h1())` ) с каждым из аргументов шаблона типа [[tuple|Tuple]], предоставляемым аргументом вызова, и выведением последовательных значений для соответствующего пакета параметров шаблона. Функция `f1()` использует один и тот же пакет параметров шаблона `Types` в обоих параметрах функции, гарантируя, что вывод завершается успешно только тогда, когда аргументы вызова двух функций имеют ту же специализацию [[tuple|Tuple]], что и их тип. С другой стороны, функция `f2()` использует различные пакеты параметров для типов [[tuple|Tuple]] в каждом из своих параметров функции, так что типы аргументов вызова функции могут быть различными — при условии, что оба являются специализациями [[tuple|Tuple]]. 

## Шаблоны оператора литерала

Шаблоны оператора литерала (literal operator template) должны определять свои аргументы уникальным способом, иллюстрируемым следующим примером:
```c++
template<char...> int operator "" _В7();     // #1

...

int а = 121_В7;                              // #2
```

Здесь инициализатор в `#2` содержит пользовательский литерал, который превращается в вызов шаблона оператора литерала `#1` со списком аргументов шаблона `<' 1', ' 2 ', ' 1' >`. Таким образом, реализация оператора литерала, такая как
```c++
template<char... cs>
int operator"" _B7()
{
	std::array<char, sizeof...(cs)>       // Инициализация массива
						chars{cs...};     // переданными символами
	for (char c : chars)                  // и их использование (в
	{                                     // данном случае - печать)
		std::cout << "'" << c << "'";
	}
	
	std::cout << '\n';
	return ...;
}
```

выведет для литерала `121.5_В7` следующее:
```c++
'1' '2' '1' '.' '5'
```

Обратите внимание на то, что эта методика поддерживается только для числовых литералов, корректных даже без суффикса. Например:
```c++
auto b - 01.3_В7;       // OK: выводит <'O’, '1', '.', '3'>
auto с = 0xFF00_B7;     // OK: выводит <'O’, 'x', 'F', 'F', 'O', '0’>
auto d = 0815_В7;       // Ошибка: 8 не является корректным
						// восьмеричным литералом
auto е = hello_B7;      // Ошибка: идентификатор hello_B7 не определен
auto f = "hello"_B7;    // Ошибка: нет соответствия оператора _В7
```

В #разделе_25_6 описывается применение этой возможности для вычисления целочисленных литералов во время компиляции.

# Ссылки на r-значения

В C++11 вводятся ссылки на [[значение - template#r-значения|r-значения]] (rvalue references), которые позволяют применять новые методы работы, включая семантику перемещений и прямую передачу. В этом разделе описывается взаимодействие между ссылками на [[значение - template#r-значения|r-значения]] и выводом типов.

## Правила свертки ссылок

Программисты не могут объявить “ссылку на ссылку” непосредственно:
```c++
int const& г = 42;
int const&& ref2ref = i;      // Ошибка: ссылка на ссылку
```

Однако при создании типов путем подстановки параметров шаблонов, применении псевдонимов типов или конструкций [[decltуре|decltype]], такие ситуации допускаются. Например:
```c++
using RI = int&;
int i = 42;
RI r = i;
RI const& rr = r; // OK: rr имеет тип int&
```

Правила, которые определяют тип, получающийся при такой композиции, известны как правила свертки ссылок (reference collapsing). Во-первых, любые квалификаторы [[const|const]] или [[volatile|volatile]], применяемые поверх внутренней ссылки, просто отбрасываются (т.е. сохраняются только квалификаторы под знаком внутренней ссылки). Затем две ссылки сводятся к одной согласно табл., которую можно резюмировать как “если любая из ссылок является ссылкой на [[значение - template#l-значение|l-значение]], то таковым будет и результирующий тип; в противном случае получаем ссылку на [[значение - template#r-значения|r-значение]]”.

| **Внутренняя ссылка** | **Внешняя ссылка** | **Результирующая ссылка** |
| --------------------- | ------------------ | ------------------------- |
| &                     | &                  | &                         |
| &                     | &&                 | &                         |
| &&                    | &                  | &                         |
| &&                    | &&                 | &&                        |

Еще один пример показывает эти правила в действии:
```c++
using RCI = int const&;
RCI volatile&& r = 42;   // OK: r имеет тип int const&

using RRI = int&&;
RRI const&& rr = 42;     // OK: rr имеет тип int&&
```

Здесь [[volatile|volatile]] применяется поверх ссылочного типа `RCI` (псевдоним для `int const &`) и поэтому игнорируется. Затем поверх этого типа применяется ссылка на [[значение - template#r-значения|r-значение]], но, поскольку базовый тип представляет собой ссылку на [[значение - template#l-значение|l-значение]], а ссылки на [[значение - template#l-значение|l-значение]] имеют более высокий “приоритет” в правилах свертки ссылок, в конечном итоге получается тип `int const &` (или эквивалентный псевдоним `RCI`). Аналогично отбрасывается [[const|const]] поверх `RRI`, а применение ссылки на [[значение - template#r-значения|r-значение]] поверх получающейся ссылки на [[значение - template#r-значения|r-значение]] по-прежнему оставляет нас с типом ссылки на [[значение - template#r-значения|r-значение]] (позволяя связывать ее с таким [[значение - template#r-значения|r-значение]], как 42).

## Передаваемые ссылки

[[Семантика перемещения - Прямая передача - template|Вывод аргумента шаблона ведет себя особым образом, когда параметр функции представляет собой передаваемую ссылку]] (forwarding reference) (ссылку на [[значение - template#r-значения|r-значение]] на параметр шаблона данного шаблона функции). В этом случае вывод аргумента шаблона рассматривает не только тип аргумента вызова функции, но и выясняет, является этот аргумент [[значение - template#l-значение|l-значением]] или [[значение - template#r-значения|r-значением]]. В случаях, когда аргумент является [[значение - template#l-значение|l-значением]], тип, определяемый выводом аргумента шаблона, представляет собой ссылку на [[значение - template#l-значение|l-значение]] на тип аргумента, а рассмотренные выше правила свертки ссылок приводят к тому, что подставляемый параметр будет ссылкой на [[значение - template#l-значение|l-значение]]. В противном случае выведенный для параметра шаблона тип является просто типом аргумента (не ссылочным типом), и подставляемый параметр является ссылкой на [[значение - template#l-значение|r-значение]] на этот тип. Например:
```c++
template<typename Т> void f(Т&& р) ; // р - передаваемая ссылка

void g()
{
	int i;
	int const j = 0;
	
	f{i);   // Аргумент является l-значением; T выводится как
			// int&, а параметр р имеет тип int&
	f(j);   // Аргумент является l-значением; Т выводится как
			// int const&, а параметр р имеет тип int const&
	f(2);   // Аргумент является r-значением; Т выводится как
			// int, а параметр р имеет тип int&&
}
```

В вызове `f(i)` параметр шаблона `Т` выводится как `int&`, поскольку выражение `i` является [[значение - template#l-значение|l-значением]] типа `int`. Подстановка `int&` вместо `Т` в тип параметра `Т&&` требует свертки ссылки, и мы применяем правило `&+&&->&`, чтобы заключить, что результирующий параметр типа — `int&`, который идеально подходит для принятия [[значение - template#l-значение|l-значения]] типа `int`. Напротив, в вызове `f(2)`, аргумент `2` представляет собой [[значение - template#r-значения|r-значение]], и поэтому параметр шаблона выводится просто как тип [[значение - template#r-значения|r-значения]] (т.е. `int`). Для результирующего параметра функции, который представляет собой простой `int&&`, применение правил свертки ссылок не требуется (а параметр подходит для переданного аргумента).

Вывод `Т` как ссылочного типа может иметь некоторое интересное влияние на инстанцирование шаблона. Например, локальная переменная, объявленная с типом `Т`, после инстанцирования для [[значение - template#l-значение|l-значения]] имеет ссылочный тип и поэтому требует наличия инициализатора:
```c++
template<typename Т> void f(Т&&) // р - передаваемая ссылка
{
	Т х; // Для переданного l-значения х является ссылкой

	...
}
```

Это означает, что при определении функции `f()` выше необходимо быть осторожным при использовании типа `Т`, иначе сам шаблон функции не будет корректно работать с аргументами, являющимися [[значение - template#l-значение|l-значениями]]. Чтобы справиться с этой ситуацией, часто используется свойство типа [[remove_reference|std::remove_reference]] для гарантии, что `х` не является ссылкой:

## Прямая передача

Сочетание специальных правил вывода для ссылок на [[значение - template#r-значения|r-значения]] и правил свертки ссылок позволяет написать шаблон функции с параметром, который принимает практически любой аргумент и фиксирует его основные свойства (его тип и то, является он [[значение - template#l-значение|l-значением]] или [[значение - template#r-значения|r-значением]]). Шаблон функции может затем “передать” аргумент другой функции следующим образом:
```c++
class С
{
	...
};

void g(С&);
void g(С const&);
void g(C&&);

tempiate<typename T>
void forwardToG(T&& x)
{
	g(static_cast<T&&> (x) );  // Передача x в g()
}

void foo()
{
	C v;
	C const c;
	
	forwardToG(v);              // Вызов g(C&)
	forwardToG(c);              // Вызов g(C const&)
	forwardToG(C());            // Вызов g(C&&)
	forwardToG(std::move(v));   // Вызов g(C&&)
}
```

Проиллюстрированная здесь методика называется прямой передачей (perfect forwarding), потому что результат вызова `g()` косвенно через `forwardToG()` будет тем же, как если бы код вызывал `g()` непосредственно: не делается никаких дополнительных копий, и выбирается в точности та же перегрузка `g()`.

Применение [[static_cast|static_cast]] в функции `forwardToG()` требует некоторых дополнительных объяснений. В каждом инстанцировании `forwardToG()` параметр `х` будет иметь тип либо ссылки на [[значение - template#l-значение|l-значение]], либо ссылки на [[значение - template#r-значения|r-значение]]. Независимо от этого выражение `х` будет [[значение - template#l-значение|l-значением]] того типа, на который указывает ссылка [[static_cast|static_cast]] приводит `х` к исходному типу и [[значение - template|l- или r-“значимости”]]. Тип `Т&&` будет либо свернут к ссылке на [[значение - template#l-значение|l-значение]] (если исходный аргумент был [[значение - template#l-значение|l-значением]], заставляя `Т` стать ссылкой на [[значение - template#l-значение|l-значение]]) или ссылке на [[значение - template#r-значения|r-значение]] (если исходный аргумент был [[значение - template#r-значения|r-значением]]), так что результат применения [[static_cast|static_cast]] имеет тот же тип и [[значение - template|l- или r-“значимость”]], что и исходный аргумент, обеспечивая тем самым прямую передачу.

Стандартная библиотека C++ предоставляет шаблон функции [[forward|std::forward<>()]] в заголовочном файле `<utility>`, которая должна использоваться для корректной передачи вместо [[static_cast|static_cast]]. С помощью этого вспомогательного шаблона намерения программиста оказываются лучше документированы, чем при применении непрозрачного [[static_cast|static_cast]], он также препятствует таким ошибкам, как пропуск одного символа `&`. То есть приведенный выше пример более ясно записывается следующим образом:
```c++
#include <utility>

template<typename Т> void forwardToG(Т&& x)
{
	g(std::forward<T>(x));  // Передача x в g()
}
```

**===Прямая передача для вариативных шаблонов===**

Прямая передача хорошо сочетается с вариативными шаблонами, позволяя шаблону функции принимать любое количество аргументов вызова функции и передавать каждый из них в другую функцию:
```c++
template<typename... Ts> 
void forwardToG(Ts&&... xs)
{
	g(std::forward<Ts>(xs)...);   // Передача всех xs в g()
}
```

Аргументы в вызове `forwardToG()` (независимо) приводят к [[Вывод аргументов шаблона - template#Пакеты параметров|выводу последовательных значений пакета параметров]] `Ts`, так что сохраняются типы и [[значение - template|l- или r-“значимость”]]. [[Вглубь шаблонов - template#Раскрытие пакета|Раскрытие пакета]] в вызове `g()` выполняет передачу каждого из этих аргументов с использованием технологии прямой передачи, объясненной выше.

Несмотря на свое название, прямая передача по сути является не совсем “прямой”, в том смысле, что она не охватывает все интересные свойства выражения. Например, она не в состоянии выяснить, ни является ли [[значение - template#l-значение|l-значение]] значением битового поля, ни имеет ли выражение определенное константное значение. Последнее может вызвать проблемы, в частности, когда мы имеем дело с константой нулевого указателя, которая представляет собой константное значение целочисленного типа, равное нулю. Поскольку константное значение выражения при прямой передаче не захватывается, разрешение перегрузки в следующем примере будет вести себя по-разному для прямого и переадресованного вызова `g()`:
```c++
void g(int*);
void g(...);

template<typename T> 
void forwardToG(T&& x)
{
	g(std::forward<T>(x));    // Передача x в g()
}

void foo()
{
	g(0);                     // Вызов g(int*)
	forwardToG(0);            // Вызов g(...)
}
```

Это еще одна причина использовать значение [[nullptr_t|nullptr]] (введенное в C++11) вместо константы нулевого указателя:
```c++
g(nullptr);           // Вызов g(int*)
forwardToG(nullptr);  // Вызов g(int*)
```

Все наши примеры прямой передачи были сосредоточены на передаче аргументов функций при сохранении их точного типа и [[значение - template|l- или r-“значимости”]]. Та же проблема возникает при пересылке возвращаемого значения вызова в другую функцию с точно тем же типом и категорией значения, обобщением [[значение - template|l- и r-значений]], рассматривающимся в #приложении_Б, “Категории значений”. Конструкция [[decltуре|decltype]], введенная в C++11 обеспечивает применение показанной далее несколько многословной идиомы:
```c++
template<typename... Ts>
auto forwardToG(Ts&&... xs) -> decltype(g(std::forward<Ts>(xs)...))
{
	return g(std::forward<Ts>(xs) ...); // Передача всех xs в g()
}
```

Обратите внимание на то, что выражение в операторе `return` скопировано в тип [[decltуре|decltype]], так что вычисляется точный тип возвращаемого выражения. Кроме того, используется завершающий возвращаемый тип (trailing return type) функции (т.е. для указания возвращаемого типа перед именем функции ставится заместитель [[auto#Вывод типа auto|auto]], а после него - `->`), так что пакет параметров функции xs находится в области видимости данного типа [[decltуре|decltype]]. Эта функция переадресации выполняет прямую передачу всех аргументов функции `g()`, а затем выполняет такую же прямую передачу результата вызова обратно в вызывающий код. 

C++14 вводит дополнительные возможности упрощения данного кода:
```c++
template<typename... Ts>
decltype(auto) forwardToG(Ts&& ... xs)
{
	return g(std::forward<Ts>(xs)...);   // Передача всех xs в g()
}
```

Использование [[decltуре#decltype(auto) C++14|decltype (auto)]] в качестве типа возвращаемого значения указывает, что компилятор должен вывести тип возвращаемого значения из определения функции (см. #разделы_15_10_1 и #15_10_3).

## Сюрпризы вывода

Результаты специальных правил вывода для ссылок на [[значение - template#r-значения|r-значения]] являются очень полезными для прямой передачи. Однако они могут оказаться неожиданными, потому что шаблоны функций обычно обобщают типы в сигнатуре функции, не учитывая, какие разновидности аргументов ([[значение - template#l-значение|l-значения]] или [[значение - template#r-значения|r-значения]]) она допускает. Рассмотрим следующий пример:
```c++
void int_lvalues(int&);   // Принимает l-значения типа int

template<typename T>
void lvalues(T&);         // Принимает l-значения любого типа

void int_rvalues(int&&);  // Принимает r-значения типа int

template<typename T>
void anything(T&&);      // Сюрприз: принимает l- и r-значения
						 // любого типа
```

Программисты, которые просто абстрагируют конкретные функции наподобие `int_rvalues` в их шаблонные эквиваленты, вероятно, будут удивлены тем фактом, что шаблон функции `anything` принимает [[значение - template#l-значение|l-значения]]. К счастью, это поведение вывода применяется только тогда, когда параметр функции, записанный в виде параметра шаблона `&&`, является частью шаблона функции, и именованный параметр шаблона объявляется этим шаблоном функции. Таким образом, данное правило вывода не применяется ни в одной из следующих ситуаций:
```c++
template<typename Т>
class X
{
	public:
		Х(Х&&);        // X не является параметром шаблона
		Х(Т&&);        // Этот конструктор не является шаблоном функции

	template<typename U>
		X(X<U>&&);     // Х<U> не является параметром шаблона
		
	template<typename U>
		X(U, Т&&);     // Т является параметром внешнего шаблона
};
```

Несмотря на удивительное поведение, которое дает это правило вывода, случаи, когда такое поведение вызывает проблемы, на практике встречается нечасто. Когда это происходит, можно использовать сочетание [[Программирование времени компиляции - template#SFINAE|SFINAE]] и свойство типа, такое как [[enable_if|std::enable_if]], для того, чтобы ограничить шаблон только [[значение - template#r-значения|r-значениями]]:
```c++
template<typename Т>
typename std::enable_if<!std::is_lvalue_reference<T>::value>::type
rvalues(T&&); // Принимает r-значения любого типа
```

# Принцип SFINAE

[[SFINAE#Принцип SFINAE| см. тут]] - сделать

# Ограничения вывода

Вывод аргумента шаблона — это мощная функциональная возможность, устраняющая необходимость явно указывать аргументы шаблона в большинстве вызовов шаблонов функций, и обеспечивающая как [[Шаблоны функций - template#Перегрузка шаблонов функций|перегрузку шаблонов функций]], так и частичную специализацию шаблонов классов (см. #раздел_16_4). Однако есть несколько ограничений, с которыми при использовании шаблонов могут столкнуться программисты. Эти ограничения и обсуждаются в данном разделе.

## Допустимые преобразования аргументов

Обычно вывод шаблонов пытается найти подстановку для параметров шаблона функции, которая делает параметризованный тип `Р` идентичным типу `А`. Однако когда это невозможно, допускаются следующие различия, когда `Р` содержит параметр шаблона в выводимом контексте.
>
> Если исходный параметр был объявлен с декларатором ссылки, то заменяемый тип `Р` может иметь дополнительные квалификаторы [[const|const]]/[[volatile|volatile]] по сравнению с типом `А`.
> 
> Если тип `А` представляет собой тип указателя или указателя на член, он может быть преобразуем в заменяемый тип `Р` путем преобразования квалификации (другими словами, преобразования, которое добавляет квалификаторы [[const|const]] и/или [[volatile|volatile]]).
> 
> Если только вывод не выполняется для шаблона оператора преобразования типа, заменяемый тип `Р` может быть типом базового класса для типа `А` или указателем на тип базового класса для типа класса, для которого `А` является типом указателя. Например:
```c++
template<typename Т>
class В
{   };

template<typename Т>
class D : public В<Т>
{   };

template<typename Т> 
void f(B<T>*);

void g(D<long> d1)
{
	f(&d1);      // Вывод успешен; T заменяется на long
I
```

Если `Р` не содержит параметр шаблона в выводимом контексте, допустимы все неявные преобразования. Например:
```c++
template<typename Т> 
int f(T, typename Т::Х);

struct V
{
	V();
	
	struct X
	{
		X(double);
	};
} v;

int г = f(v, 7.0);  // OK: Т из первого параметра выводится как V,
					// что приводит к тому, что второй параметр имеет
					// тип V::X, который может быть построен из double
```

Ослабленные требования соответствия рассматриваются только тогда, когда точное соответствие невозможно. Даже в этом случае вывод успешен, только если обнаруживается ровно одна подстановка, которая позволяет “подогнать” тип `А` к заменяемому типу `Р` с указанными дополнительными преобразованиями.

Обратите внимание на то, что эти правила очень узки и игнорируют, например, различные преобразования, которые могут быть применены к аргументам функции, чтобы сделать вызов успешным. Рассмотрим такой [[Вывод аргументов шаблона - template#Процесс вывода|вызов шаблона функции max ()]]:
```c++
std::string maxWithHello(std::string s)
{
	return ::max(s, "hello");
}
```

Здесь вывод аргумента шаблона из первого аргумента дает в качестве `Т` тип [[string|std::string]], в то время как из второго аргумента `Т` выводится как `char[6]`, поэтому вывод аргументов шаблона неудачен — так как оба параметра используют один и тот же параметр шаблона. Эта неудача может показаться удивительной, поскольку строковый литерал `"hello"` неявно преобразуем в [[string|std::string]], и вызов
```c++
::max<std::string>(s, "hello")
```

должен быть успешен.

Возможно, еще более удивительно то, что, когда два аргумента имеют различные типы классов, производных от общего базового класса, вывод не рассматривает этот общий базовый класс в качестве кандидата для выведенного типа. [[Шаблоны функций - template#Вывод аргумента шаблона|Этот вопрос и возможные его решения рассматриваются тут]].

## Аргументы шаблона класса

До C++17 вывод аргумента шаблона применяется исключительно к шаблонам функций и функций-членов. В частности, аргументы для шаблона класса не выводились из аргументов вызова одного из его конструкторов. Например:
```c++
template<typename Т>
class S
{
	public:
		S(T b) : a(b)
		{   }

	private:
		T a;
};

	S x(12);    // Ошибка до C++17: параметр T шаблона класса
				// не выводится из аргумента вызова конструктора `12`
```

Это ограничение снято в C++17 — см. #раздел_15_12.

## Аргументы вызова по умолчанию

Аргументы вызова функции по умолчанию могут быть указаны в шаблонах функций так же, как и в обычных функциях:
```c++
template<typename Т>
void init (Т* loc, Т const& val = Т())
{
	*lос = val;
}
```

На самом деле, как показывает этот пример, аргумент вызова функции по умолчанию может зависеть от параметра шаблона. Такой зависимый аргумент по умолчанию инстанцируется только тогда, когда не указаны явные аргументы — принцип, который делает следующий пример корректным:
```c++
class S
{
	public:
		S(int, int);
};

S s(0, 0);

int main()
{
	init(&s, S(7, 42)); // T() некорректно в случае T = S, но
						// аргумент вызова по умолчанию Т() не
						// инстанцируется, так как имеется
						// явно указанный аргумент.
}
```

Даже когда аргумент вызова по умолчанию не является зависимым, он не может использоваться для вывода аргументов шаблона. Это означает, что следующий код — неверный код C++:
```c++
template<typename Т>
void f(T х = 42)
{   }

int main()
{
	f<int>(); // OK: T = int
	
	f();      // Ошибка: невозможно вывести T
}             // из аргумента вызова по умолчанию
```

## Спецификации исключений

Подобно аргументам вызова по умолчанию спецификации исключений инстанцируются только тогда, когда они необходимы. Это означает, что они не участвуют в выводе аргумента шаблона. Например:
```c++
template<typename Т>
void f(T, int) noexcept(nonexistent(Т())); // #1

template<typename Т>
void f (Т, ...);                    // #2 (вариативная функция в стиле С)

void test(int i)
{
	f(i, i);                        // Ошибка: выбран #1, но выражение
}                                   // nonexistent(Т()) некорректно
```

Спецификация [[noexcept|noexcept]] в функции, помеченной как `#1`, пытается вызвать несуществующую функцию. Обычно такие ошибки непосредственно в объявлении шаблона функции приводят к неудаче вывода аргумента шаблона ([[SFINAE|SFINAE]]), позволяя вызову `f (i, i)` достичь успеха, выбрав функцию, помеченную как `#2`, которая без этого имела бы худшее соответствие (соответствие многоточию — худший вид соответствия с точки зрения разрешения перегрузки; смотрите #приложение_В, “Разрешение перегрузки”). Однако поскольку спецификации исключений не участвуют в выводе аргумента шаблона, разрешение перегрузки выбирает `#1`, и программа становится некорректной при более позднем инстанцировании спецификации [[noexcept|noexcept]].

То же правило применимо к спецификациям исключений, которые перечисляют потенциально возможные типы исключений:
```c++
template<typename Т>
void g(T, int) throw(typename T::Nonexistent);  // #1

template<typename T>
void g(T, ...);                                 // #2

void test(int i)
{
	g(i, i); // Ошибка: выбирает #1, но тип Т::Nonexistent некорректен
}
```

Однако эти “динамические” спецификации исключений не рекомендованы к применению начиная с С++11, и были полностью удалены в С++17.

# Явные аргументы шаблонов функций

Когда аргумент шаблона функции не может быть выведен, может оказаться возможным явно указать его после имени шаблона функции. Например:
```c++
template<typename Т> 
Т default_value()
(
	return Т{};
}

int main()
{
	return default_value<int>();
}
```

Это также может быть сделано и для выводимых параметров шаблонов:
```c++
template<typename Т> 
void compute(Т р)
{
	...
}

int main()
{
	compute<double>(2);
}
```

После того как аргумент шаблона указан явно, соответствующий ему параметр больше не подлежит выводу. Это, в свою очередь, позволяет выполнить преобразования над параметрами вызова функции, которые не были бы возможны в выведенном вызове. В примере выше аргумент `2` в вызове `compute<double>(2)` неявно преобразуется в `double`.

Это позволяет явно указать некоторые аргументы шаблона, в то время как остальные могут быть выведены. Однако явно указанные аргументы всегда должны соответствовать параметрам шаблона слева направо. Поэтому в объявлении шаблона сначала указываются параметры, которые нельзя вывести (или которые, скорее всего, будут указаны явно). Например:
```c++
template<typename Out, typename In>
Out convert(In p)
{
	...
}

int main()
{
	auto x = convert<double>(42);   // Тип параметра p выводится,
									// возвращаемый тип указан явно
}
```

Иногда полезно указать пустой список аргументов шаблона, чтобы гарантировать, что выбранная функция является экземпляром шаблона, но при этом использует вывод для определения аргументов шаблона:
```c++
int f(int);                        // #1

template<typename T> T f(T);       // #2

int main()
{
	auto x = f(42);                // Вызов #1
	auto у = f<>(42);              // Вызов #2
}
```

Здесь для вызова `f(42)` выбирается нешаблонная функция, потому что разрешение перегрузки предпочитает при прочих равных условиях обычные функции шаблонам функций. Однако для вызова `f<>(42)` наличие списка аргументов шаблона требует выбора шаблона функции (даже если фактические аргументы шаблона не указаны).

В контексте объявлений дружественных функций наличие явного списка аргументов шаблона имеет интересный эффект. Рассмотрим следующий пример:
```c++
void f();

template<typename> 
void f();

namespace N
{
	class С
	{
		friend int f();     //OK
		friend int f<>();   // Ошибка: конфликт возвращаемого типа
	};
}
```

Когда простой идентификатор используется для именования дружественной функции, эта функция ищется только в ближайшей охватывающей области видимости, и если она там не найдена, объявляется новая сущность в данной области видимости (но она остается “невидимой”, за исключением поиска, [[Имена в шаблонах - template#ADL объявлений друзей|зависящего от аргументов (ADL)]]). Это и происходит с нашим первым объявлением `friend` выше: `f` не объявлена в пространстве имен `N`, поэтому “невидимо” объявляется новая функция `N::f()`.

Однако когда за идентификатором, именующим друга, следует список аргументов шаблона, шаблон в этой точке должен быть виден с помощью обычного поиска, и этот обычный поиск будет проходить по любому необходимому количеству областей видимости. Таким образом, наше второе объявление выше найдет глобальный шаблон функции `f()`, но затем компилятор выдаст ошибку, поскольку типы возвращаемых значений не совпадают (поскольку здесь не выполняется ADL, объявление, созданное предыдущим объявлением дружественной функции, игнорируется).

Явно указанные аргументы шаблона заменяются с использованием принципов [[SFINAE#SFINAE|SFINAE]]: если подстановка приводит к ошибке в непосредственном контексте этой подстановки, шаблон функции отбрасывается, но другие шаблоны могут по-прежнему быть успешны. Например:
```c++
template<typename Т> typename Т::ЕТуре f();   // #1
template<typename Т> Т f();                   // #2

int main()
{
	auto х = f<int*>();
}
```

Здесь подстановка `int*` вместо `Т` в кандидате `#1` является неудачной, но в кандидате `#2` она вполне успешна, поэтому выбирается этот кандидат. Фактически если после подстановки остается ровно один кандидат, то имя шаблона функции с явными аргументами шаблона ведет себя очень похоже на имя обычной функции, включая низведение к типу указателя на функцию во многих контекстах. То есть, заменив приведенную выше функцию `main()` следующей
```c++
int main()
{
	auto х = f<int*>;   // OK: x - указатель на функцию
}
```

мы получим корректную единицу трансляции. Однако следующий код:
```c++
template<typename Т> 
void f(Т);

template<typename Т> 
void f(T, Т);

int main()
{
	auto x = f<int*>; // Ошибка: две возможных f<int*>
)
```

будет некорректным, поскольку `f<int*>` в данном случае не идентифицирует единственную функцию.

Вариативные шаблоны функций также могут использоваться с явными аргументами шаблона:
```c++
template<typename ... Ts> 
void f(Ts ... ps) ;

int main()
(
	f<double, double, int>(1, 2, 3); // OK: 1 и 2 преобразуются в double
}
```

Интересно, что пакет может быть частично указан явно, а частично — выведен:
```c++
template<typename ... Ts> 
void f(Ts ... ps);

int main()
{
	f<double,int>(1, 2, 3); // OK: аргументы шаблона - <double,int,int>
)
```

# Вывод из инициализаторов и выражений

Стандарт С++11 включает возможность объявления переменной, тип которой выводится из ее инициализатора. Он также обеспечивает механизм для выражения типа именованной сущности (переменной или функции) или выражения. Эти возможности оказались очень удобными, и в стандартах С++14 и С++17 были внесены новые дополнения на эту тему.

## Спецификатор типа auto

Спецификатор типа [[auto|auto]] может использоваться в ряде мест (главным образом, в областях видимости пространства имен и локальных) для вывода типа переменной из ее инициализатора. В таких случаях [[auto|auto]] называется ***типом-заместителем*** (placeholder type). Еще один тип-заместитель, [[decltуре#decltype(auto) C++14|decltype (auto)]], будет описан чуть позже в #разделе_15_10_2. Например:
```c++
template<typename Container>
void useContainer(Container const& container)
{
	auto pos = container.begin();
	while (pos != container.end())
	{
		auto& element = *pos++;
		... // Операции над элементом
	}
}
```

Эти два применения [[auto|auto]] в приведенном примере устраняют необходимость записывать два длинных и потенциально сложных типа, — тип итератора контейнера и тип значения итератора:
```c++
typename Container::iterator pos = container.begin();

...

typename std::iterator_traits<typename Container::iterator>::reference
element = *pos++;
```

Вывод для [[auto|auto]] использует тот же механизм, что и вывод аргумента шаблона. Спецификатор типа [[auto|auto]] заменяется параметром типа `Т` шаблона, после чего вывод выполняется так, как если бы переменная была параметром функции, а ее инициализатор — соответствующим аргументом функции. В первом примере [[auto|auto]] это соответствует следующей ситуации:
```c++
template<typename Т> 
void deducePos(T pos);

deducePos(container.begin());
```

где `T` — тип, который выводится для [[auto|auto]]. Одним из непосредственных последствий этого является то, что переменная типа [[auto|auto]] никогда не будет ссылочным типом. Использование `auto&` во втором примере иллюстрирует, как получить ссылку на выведенный тип. Его вывод эквивалентен следующему шаблону функции и вызову:
```c++
template<typename Т> 
deduceElement(Т& element);

deduceElement(*pos++) ;
```

Здесь `element` всегда имеет ссылочный тип, и его инициализатор не может производить временное значение.

Можно также скомбинировать [[auto|auto]] со ссылкой на [[значение - template#r-значения|r-значение]], но это приведет к поведению, похожему на поведение передаваемой ссылки, поскольку модель вывода для
```c++
auto&& fr = ...;
```

основана на шаблоне функции:
```c++
template<typename t>      // auto заменяется
void f(T&& fr);           // параметром шаблона T
```

Это поясняет следующий пример:
```c++
int х;
auto&& rr = 42; // OK: ссылка на r-значение связана
				//с r-значением (auto = int)
auto&& lr = x;  // Также OK: auto = int&, и свертка ссылок
				// делает lr ссылкой на l-значение
```

Этот метод часто используется в обобщенном коде для привязки результата вызова функции или оператора, категория значения которого ([[значение - template|l- или r-значение]]) неизвестна, без копирования этого результата. Например, она часто является предпочтительным способом объявить итерируемое значение в цикле [[for|for]] для диапазона:
```c++
template<typename Container> 
void g(Container c)
{
	for (auto && x : c)
	{
		...
	}
}
```

Здесь мы не знаем сигнатуры итерирующих интерфейсов контейнера, но с помощью `auto&&` мы можем быть уверены, что никаких дополнительных копий итерируемых значений создано не будет. Как обычно, можно использовать [[forward|std: : forward<T> ()]], если требуется прямая передача связанного значения. Это обеспечивает [[Обобщенные библиотеки - template#Прямая передача временных значений|“отложенную” прямую передачу]].

В дополнение к ссылкам можно комбинировать спецификатор [[auto|auto]] с другими для получения константной переменной, указателя, указателя на член и так далее, но [[auto|auto]] должен быть “главным” спецификатором объявления. Он не может быть вложенным в аргумент шаблона или частью декларатора, за которым следует спецификатор типа. Следующий пример иллюстрирует различные возможности:
```c++
template<typename Т> struct X
{
	Т const m;
};

auto const N = 400u;            // OK: константа. типа unsigned int
auto* gp = (void*)nullptr;      // OK: gp имеет тип void*
auto const S::*pm = &X<int>::m; // OK: pm имеет тип int const X<int>::*
X <auto> xa = X<int>();         // Ошибка: auto в аргументе шаблона
int const auto::* pm2 = 
		&X<int>::m;         // Ошибка: auto является частью "декларатора"
```

Нет никаких технических причин, по которым C++ не мог бы поддерживать все случаи в последнем примере, но Комитет по стандартизации C++ считает, что получаемые выгоды перевешивались бы стоимостью дополнительных реализаций и потенциальных злоупотреблений.

Во избежание путаницы как для программиста, так и для компилятора, старое применение [[auto|auto]] как “спецификатора класса хранения” в C++11 (и более поздних стандартах) запрещено:
```c++
int g()
{
	auto int r = 24;  // OK в C++03, ошибка в С++11
	return г;
}
```

Это старое применение [[auto|auto]] (унаследованное от С) всегда было излишним. Большинство компиляторов могут (но не должны) разрешить неоднозначность и определить, используется ли [[auto|auto]] по-новому, как тип-заместитель, и предложить вариант перехода от старого кода C++ к новому. Однако на практике старое применение [[auto|auto]] встречается крайне редко.

**==*Выводимые возвращаемые типы==**

C++14 добавил еще одну ситуацию, где может встретиться выводимый тип-заместитель [[auto|auto]]: типы возвращаемых значений функций. Например:
```c++
auto f()
{
	return 42;
}
```

Этот код определяет функцию с возвращаемым типом `int` (тип значения `42`).

Это можно также выразить с помощью синтаксиса завершающего возвращаемого типа (trailing return type):
```c++
auto f() -> auto 
{ 
	return 42; 
}
```

В этом последнем случае первый `auto` завершающий возвращаемый тип, а второй `auto` является выводимым типом-заместителем. Однако имеется мало доводов в пользу более многословного синтаксиса.

Тот же механизм по умолчанию используется в лямбда-выражениях: если тип возвращаемого значения не указан явным образом, то возвращаемый тип лямбда-выражения выводится так, как будто это [[auto|auto]]:
```c++
auto lm = [] (int x)
{
	return f(x);
};
// To же, что и: [](int x) -> auto { return f(x); };
```

Функции могут быть объявлены отдельно от их определений. Это верно и для функций, возвращаемый тип которых выводится:
```c++
auto f(); // Предварительное объявление

auto f()
{
	return 42;
}
```

Однако предварительное объявление в подобном случае имеет весьма ограниченное применение, так как в любой точке, где используется функция, должно быть видимым ее определение. Возможно, это покажется удивительным, но предоставление предварительного объявления с “разрешенным” возвращаемым типом некорректно. Например:
```c++
int known();

auto known ()
{
	return 42;       // Ошибка: несовместимые возвращаемые типы
}
```

Главным образом возможность предварительного объявления функции с выводимым возвращаемым типом полезна только для того, чтобы иметь возможность переместить определение функции-члена вне определения класса из-за стилистических предпочтений:
```c++
struct S
{
	auto f();    // Определение находится после определения класса
};


auto S::f()
{
	return 42;
}
```

**===*Выводимые параметры, не являющиеся типами*===**

До C++17 аргументы шаблонов, не являющиеся типами, должны были объявляться с указанием конкретного типа. Однако этот тип может быть типом параметра шаблона, например:
```c++
template<typename Т, Т V> struct S;
S<int, 42>* ps;
```

В этом примере необходимость указывать тип аргумента шаблона, не являющегося типом (т.е. указывать `int` в дополнение к `42`), может быть утомительной. Поэтому стандарт C++17 добавил возможность объявления параметров шаблонов, не являющихся типами, фактические типы которых выводятся из соответствующих аргументов шаблонов. Они объявляются следующим образом:
```c++
template<auto V> struct S;
```

что позволяет записать
```c++
S<42>* ps;
```

Здесь тип `V` для `S<42>` выводится как `int`, потому что `42` имеет тип `int`. Если мы напишем вместо этого `S<42u>`, тип `V` будет выведен как `unsigned int` ([[Вывод аргументов шаблона - template#Спецификатор типа auto|см. подробности выведения спецификатора типа auto]]).

Обратите внимание на то, что общие ограничения на тип параметров шаблонов, не являющихся типами, остаются в силе. Например:
```c++
S<3.14>* pd;    // Ошибка: аргумент, не являющийся типом,
				// представляет собой число с плавающей точкой
```

Определение шаблона с такого рода выводимыми параметрами, не являющимися типами, часто требует выражения фактического типа соответствующего аргумента. Это легко сделать с помощью конструкции [[decltуре|decltype]].

Например:
```c++
template<auto V> struct Value
{
	using ArgType = decltype(V);
};
```

`auto`-параметры шаблона, не являющиеся типами, полезны также для параметризации шаблонов членов или классов. Например:
```c++
template<typename> 
struct PMClassT;

template<typename C, typename M> 
struct PMClassT<M C::*>
{
	using Type = C;
};

template<typename PM> 
using PMClass = typename PMClassT<PM>::Type;

template<auto PMD> 
struct CounterHandle
{
	PMClasscdecltype(PMD)>& c;
	CounterHandle(PMClass<decltype(PMD)>& c): c(c)
	{
	}
	
	void incr()
	(
		++(c.*PMD);
	}
};

struct S
{
	int i;
};

int main()
{
	S s{41};
	CounterHandle<&S::i> h(s) ;
	h.incrf); // Увеличивает s.i
}
```

Здесь мы использовали вспомогательный шаблон класса `PMClassT` для извлечения из типа указателя на член тип “родительского” класса, с помощью частичной специализации шаблона класса (описан в #разделе_16_4). С параметром шаблона [[auto|auto]] нам нужно только задать константный указатель на член `&S::i` в качестве аргумента шаблона. До C++17 мы должны были также указывать тип указателя на член; т.е. писать что-то вроде
```c++
OldCounterHandle<int S::*, &S::i>
```

что, конечно, и громоздко и излишне.

Как вы и ожидали, эта возможность может также использоваться для пакетов параметров, не являющихся типами:
```c++
template<auto... VS> struct Values
{
};

Values<1, 2, 3> beginning;
Values<1, 'x', nullptr> triplet;
```

Пример `triplet` показывает, что каждый элемент пакета параметров, не являющихся типами, может быть выведен как отдельный тип. В отличие от случая нескольких деклараторов переменных (см. #раздел_15_10_4) здесь нет требования, чтобы все выводы были эквивалентными.

Если мы хотим обеспечить однородный пакет параметров, не являющихся типами, это также возможно:
```c++
template<auto V1, decltype(V1)... VRest> struct HomogeneousValues
{
};
```

Однако в данном конкретном случае список аргументов шаблона не может быть пустым.

Завершенный пример использования [[auto|auto]] в качестве параметра [[Нетиповые параметры шаблонов - template#Тип параметра шаблона auto|типа шаблона]].

## Запись типа выражения с помощью decltype

[[decltуре#Запись типа выражения с помощью decltype|см. тут]]

## decltype (auto)

[[decltуре#decltype(auto) C++14|см. тут]]

## Особые случаи вывода auto

[[auto#Особые случаи вывода auto|см. тут]]

## Структурированное связывание

C++17 добавляет новую возможность, известную как структурированное связывание. (structured bindings). Наиболее просто понять, о чем идет речь, с помощью маленького примера:
```c++
struct Maybelnt
{
	bool valid;
	int value;
};

MaybeInt g();
auto const&& [b, N] = g(); // Связывает b и N с членами результата g()
```

Вызов `g()` производит значение (в данном случае — простой класс-агрегат типа `Maybelnt`), которое можно разложить на “элементы” (в данном случае — члены данных `Maybelnt`). Значение этого вызова производится как если бы список идентификаторов в квадратных скобках `[b, N]` был заменен уникальным именем переменной. Если это имя `e`, то указанная инициализация эквивалентна следующей:
```c++
auto const&& е = g();
```

Идентификаторы в квадратных скобках затем связываются с элементами `е`. Таким образом, вы можете думать о `[b, N]` как введении имен для частей `е` (некоторые детали этого связывания мы будем обсуждать позже).

Синтаксически структурированное связывание должно всегда иметь тип [[auto|auto]] с необязательными квалификаторами [[const|const]] и/или [[volatile|volatile]] и/или операторами деклараторов `&` и/или `&&` (но не декларатором указателя `*` или некоторыми другими). Далее следует список в квадратных скобках, содержащий по крайней мере один идентификатор (напоминает список захвата лямбда-выражения). Все это, в свою очередь, должно сопровождаться инициализатором.

Структурированное связывание можно инициализировать сущностями трех разных видов.
1. ***Первый случай*** — простой тип класса, в котором все нестатические члены-данные открыты (как в примере выше). Чтобы этот случай был применим, все нестатические члены-данные должны быть открытыми (либо непосредственно в самом классе, либо в однозначном открытом базовом классе; анонимные объединения использоваться не могут). В этом случае количество идентификаторов в квадратных скобках должно равняться числу членов, и использование одного из этих идентификаторов в области видимости структурированного связывания равносильно использованию соответствующего члена объекта, обозначенного `е` (со всеми связанными свойствами; например, если соответствующий член является битовым полем, невозможно получить его адрес).
2. ***Второй случай*** соответствует массивам. Вот соответствующий пример:
```c++
int main()
{
	double pt[3];
	auto& [x, у, z] = pt;
	
	x = 3.0;
	у = 4.0;
	z = 0.0;

	plot(pt);
}
```

Неудивительно, что переменные в квадратных скобках просто представляют собой сокращения для соответствующих элементов неименованной переменной массива. Количество элементов массива должно совпадать с количеством инициализаторов в квадратных скобках.

Вот другой пример:
```c++
auto f() -> int(&)[2]; // f() возвращает ссылку на массив int
auto [ х, у ] = f();   // #1
auto&[ r, s ] = f();   // #2
```

Строка `#1` особенная: обычно сущность `е`, описанная ранее, выводится для этого случая из следующего кода:
```c++
auto е = f();
```

Однако так будет выведен низведенный указатель на массив, и это совсем не то, что происходит при выполнении структурированного связывания массива. Вместо этого `е` выводится как переменная типа массива, соответствующего типу инициализатора. Затем этот массив поэлементно копируется из инициализатора: для встроенных массивов это несколько необычная концепция. Наконец, `х` и `у` становятся псевдонимами для выражений `е [ 0 ]` и `е [ 1 ]` соответственно.

Строка `#2` не выполняет копирования массивов и следует обычным правилам для [[auto|auto]]. Так что гипотетически `е` объявляется следующим образом:
```c++
autos е = f();
```

Эго дает нам ссылку на массив, и `х` и `у` вновь становятся псевдонимами для выражений `е[0]` и `е[1]` соответственно (которые представляют собой [[значение - template#l-значение|l-значения]], ссылающиеся непосредственно на элементы массива, создаваемого вызовом `f()`).

3. И, наконец, третий случай позволяет классам наподобие [[tuple|std::tuple]] разложение на элементы с помощью протокола на основе шаблона с использованием `get<>()`. Пусть `Е` — тип выражения (`е`), в котором `е` объявлено, как указано выше. Поскольку `E` является типом выражения, оно никогда не является ссылочным типом. Если выражение `std::tuple_size<E>::value` является корректным целочисленным константным выражением, оно должно быть равно количеству идентификаторов в скобках (протокол отдает предпочтение этому варианту по сравнению с первым, но не со вторым вариантом для массивов). Давайте обозначим идентификаторы в квадратных скобках как n0, n1, n2 и т. д. Если `е` имеет любой член с именем `get`, то поведение получается таким, как если бы эти идентификаторы были объявлены как
```c++
std::tuple_element<i, Е>::type& ni = e.get<i>();
```

если `e` выводится как имеющее ссылочный тип, или
```c++
std::tuple_element<i, E>::type&& ni = e.get<i>();
```

в противном случае. Если у `е` нет члена get, то соответствующие объявления приобретают вид
```c++
std::tuple_element<i, E>::type& ni = get<i>(e);
```

или
```c++
std::tuple_element<i, E>::type&& ni = get<i>(e);
```

где `get` ищется только в связанных классах и пространствах имен. (Во всех случаях предполагается, что `get` является шаблоном и, следовательно, за ним следует угловая скобка `<`.) Все шаблоны — [[tuple|std::tuple]], [[pair|std::pair]] и [[Array|std::array]] — реализуют этот протокол, делая корректным, например, следующий код:
```c++
#include <tuple>

std::tuple<bool, int> bi {true, 42};
auto [b, i] = bi;
int r = i;                // Инициализация r значением 42
```

Однако несложно добавить специализации [[tuple#std tuple_size|std::tuple_size]], [[tuple#std tuple_element|std::tuple_element]] и шаблон функции или функции-члена `get<>()`, которые сделают этот механизм работающим для произвольного типа класса или перечисления. Например:
```c++
#include <utility>

enum М {};

template<> 
class std::tuple_size<M>
{
	public:
		static unsigned const value = 2;    // Отображение M на 
											// пару значений
};

template<> 
class std::tuple_element<0, M>
{
	public:
		using type = int;    // Первое значение будет иметь тип int
};

template<> 
class std::tuple_element<1, M>
{
	public:
		using type = double; // Второе значение будет иметь тип double
};

template<int> 
auto get(M);

template<> 
auto get<0>(M)
{
	return 42;
}

template<> 
auto get<1>(M)
{
	return 7.0;
}

auto [i, d] = M(); // Как если бы int&& i = 42; double&& d = 7.0;
```

Учтите, что вам нужно включить заголовочный файл `<utility>`, чтобы использовать две вспомогательные функции [[tuple#std tuple_size|std::tuple_size<>]] и [[tuple#std tuple_element|std::tuple_element<>]].

Кроме того, обратите внимание, что третий из показанных выше случаев (использующий протокол `tuple`) выполняет фактическую инициализацию инициализаторов в скобках, а связывания представляют собой фактические ссылочные переменные, а не просто псевдонимы для других выражений (в отличие от первых двух случаев, использующих простые типы классов и массивов). Это интересно, потому что инициализация ссылки может выполниться неправильно; например, она может сгенерировать исключение, и такое исключение теперь является неизбежным. Однако комитет по стандартизации C++ обсуждал также возможность не связывать идентификаторы с инициализированными ссылками, а вместо этого при каждом последующем использовании идентификаторов вычислять выражение `get<>()`. Это позволило бы использовать структурированное связывание с типами, в которых “первое” значение должно быть протестировано до обращения ко “второму” (например, основанными на [[optional|std::optional]]).

## Обобщенные лямбда-выражения

Лямбда-выражения быстро стали одной из наиболее популярных возможностей С++11, отчасти потому, что они значительно облегчили использование функциональных конструкций в стандартной библиотеке C++ (и многих других современных библиотеках C++) благодаря значительно сокращенному синтаксису. Однако в рамках самих шаблонов лямбда-выражения могут стать довольно громоздкими, что обусловлено необходимостью уточнения типов параметров и результатов. Рассмотрим, например, шаблон функции для поиска первого отрицательного значения в последовательности:
```c++
template<typename Iter>
Iter findNegative(Iter first, Iter last)
{
	return std::find_if(
				first, last,
				[](typename std::iterator_traits<iter>::value_type value)
				{ return value < 0; }
			);
}
```

В этом шаблоне функции наиболее сложной частью лямбда-выражения является тип параметра. C++14 вводит понятие “обобщенных” лямбда-выражений, в которых один или несколько типов параметров используют ключевое слово [[auto|auto]] для автоматического вывода типа вместо явного его указания:
```c++
template<typename Iter>
Iter findNegative(Iter first, Iter last)
{
	return std::find_if(first, last,
						[](auto value)
						{ return value < 0; }
			);
}
```

[[auto|auto]] в параметре лямбда-выражения обрабатывается аналогично [[auto|auto]] в позиции типа переменной на основе типа инициализатора: это ключевое слово заменяется открытым параметром типа шаблона `Т`. Однако, в отличие от случая переменной, здесь вывод не выполняется немедленно, потому что аргумент в момент создания лямбда-выражения неизвестен. Вместо этого само лямбда-выражение становится обобщенным (если оно еще не было таковым), и типовой параметр шаблона добавляется в список параметров шаблона. Таким образом, приведенное выше лямбда-выражение может быть вызвано с любым типом аргумента, лишь бы этот тип аргумента поддерживал операцию `<0`, результат которой был преобразуем в значение типа `bool`. Например, это лямбда-выражение может быть вызвано со значением типа `int` или `double`.

Чтобы понять, что для лямбда-выражения означает быть обобщенным, сначала рассмотрим модель реализации лямбда-выражений, не являющихся обобщенными. Данное лямбда-выражение
```c++
[] (int i)
{
	return i < 0;
}
```

компилятор C++ транслирует в экземпляр вновь создаваемого специально для данного лямбда-выражения класса. Этот экземпляр называется замыканием (closure) или ***объектом замыкания***, а класс называется ***типом замыкания***. Тип замыкания имеет оператор вызова функции, и, следовательно, замыкание является функциональным объектом. Для данного лямбда-выражения тип замыкания будет выглядеть примерно следующим образом (для краткости и простоты мы опустили преобразование функции в значение указателя на функцию):
```c++
class SomeCompilerSpecificNameX
{
	public:
		SomeCompilerSpecificNameX(); // Вызывается только компилятором

		bool operator()(int i) const
		{
			return i < 0;
		}
};
```

При проверке категории типа для лямбда-выражения std::is_class<> ( #std_is_class) вернет `true` (см. #раздел_Г_2_1).

Лямбда-выражение, таким образом, оказывается объектом данного класса (типа замыкания). Например, код
```c++
foo(...,
	[](int i)
	{
		return i < 0;
	}
);
```

создает объект (замыкание) внутреннего, специфичного для конкретного компилятора класса `SomeCompilerSpecificNameX`:
```c++
foo (...,
	SomeCompilerSpecificNameX{}); // Передача объекта типа замыкания
```

Если лямбда-выражение должно захватывать локальные переменные:
```c++
int х, у;

...

[х, у](int i)
{
	 return i > х && i < у;
}
```

то эти захваты моделируются в виде инициализируемых членов соответствующего типа класса:
```c++
class SomeCompilerSpecificNameY
{
	private:
		int _x, _y;

	public:
		SomeCompilerSpecificNameY(int x, int у) // Вызывается только
			: _x(x), _y(y)                      // компилятором
		{   }
		
		bool operator()(int i) const
		{
			return i > _x && i < _y;
		}
};
```

В случае обобщенного лямбда-выражения оператор вызова функции становится шаблоном функции-члена, поэтому наше простое обобщенное лямбда-выражение
```c++
[] (auto i)
{
	return i < 0;
}
```

преобразуется в следующий созданный компилятором класс (мы опять игнорируем функцию преобразования, которая в обобщенном лямбда-выражении становится шаблоном функции):
```c++
class SomeCompilerSpecificNameZ
{
	public:
		SomeCompilerSpecificNameZ(); // Вызывается только компилятором
		
		template<typename Т>
		auto operator()(T i) const
		{
			return i < 0;
		}
};
```

Шаблон функции-члена инстанцируется при вызове замыкания, что обычно происходит не там, где появляется лямбда-выражение. Например:
```c++
#include ciostream>

template<typename F, typename... Ts> 
void invoke(F f, Ts... ps)
{
	f(ps...);
}

int main()
{
	invoke([](auto x, auto y)
	{
		std::cout << x + у << '\n'
	},
	21, 21);
}
```

Здесь лямбда-выражение появляется в функции `main()`, где и создается связанное замыкание. Однако оператор вызова замыкания при этом не инстанцируется. Вместо этого инстанцируется шаблон функции `invoke()` с типом замыкания в качестве первого параметра типа и типом `int` (тип значения 21) в качестве второго и третьего параметров типа. Это инстанцирование `invoke()` вызывается с копией замыкания (которое до сих пор остается замыканием, связанным с исходным лямбда-выражением), и инстанцирует шаблон `operator()` замыкания для удовлетворения инстанцированного вызова `f (ps. . .)`.

# Шаблоны псевдонимов

[[Шаблоны классов - template#Псевдонимы типов|Шаблоны псевдонимов]] “прозрачны” по отношению к выводам. Это означает, что везде, где появляется шаблон псевдонима с некоторыми аргументами шаблона, выполняется подстановка аргументов в определение псевдонима (т.е. типа справа от `=`), и получающийся в результате шаблон используется для вывода. Например, вывод аргумента шаблона успешен в трех следующих вызовах:
```c++
template<typename Т, typename Cont>
class Stack;

template<typename T>
using DequeStack = Stack<T, std::deque<T>>;

template<typename T, typename Cont>
void f1(Stack<T, Cont>);

template<typename T>
void f2(DequeStack<T>);

template<typename Т>
void f3(Stack<T, std::deque<T>);    // Эквивалентно f2

void test(DequeStack<int> intStack)
{
	f1(intStack);   // OK: T выводится как int,
					// Cont выводится как std::deque<int>
	f2(intStack);   // OK: T выводится как int
	f3(intStack);   // OK: T выводится как int
}
```

В первом вызове (`f1()`) использование шаблона псевдонима `DequeStack` в типе `intStack` на вывод влияния не оказывает: указанный тип `DequeStack<int>` рассматривается как подставляемый тип `Stack<int, std::deque<int>>`. Второй и третий вызовы имеют то же поведение вывода, поскольку `DequeStack<T>` в `f2()` и подставляемая форма `Stack<T, std::deque<T>>` в `f3()` эквивалентны. Для вывода аргументов шаблона шаблоны псевдонимов прозрачны: они могут использоваться для прояснения и упрощения кода, но при этом не влияют на то, как работает вывод.

Обратите внимание, что это возможно потому, что шаблоны псевдонимов не могут быть специализированы (см. в #главе_16, “Специализация и перегрузка”, подробную информацию о специализации шаблонов). Предположим, что было бы возможно следующее:
```c++
template<typename Т> 
using А = Т;

template<> 
using A<int> = void;            // Ошибка, но предположим,
								// что это возможно...
```

тогда мы бы не могли проверить соответствие `А<T>` типу `void` и заключить, что тип `Т` должен быть `void`, потому что и `A<int>`, и `A<void>` эквивалентны `void`. Тот факт, что это невозможно, гарантирует, что каждое использование псевдонима может быть обобщенно расширено согласно его определению, что и делает шаблоны псевдонимов прозрачными для вывода.

# Вывод аргументов шаблонов классов

C++17 вводит новую разновидность вывода: вывод параметров шаблонов типа класса из аргументов, указанных в инициализаторе объявления переменной или преобразовании типа в стиле функции. Например:
```c++
template<typename T1, typename Т2, typename ТЗ = Т2>
class С
{
	public:
		// Конструктор для 0, 1, 2 или 3 аргументов:
		С(Т1 х = T1{}, Т2 у = Т2{}, ТЗ z = ТЗ{});

		...
};

С c1(22, 44.3, "hi");   // ОК в С++17: T1 = int, Т2 = double,
						// ТЗ = char const*
С с2(22, 44.3);         // ОК в С++17; T1 = int, Т2 = ТЗ = double
С сЗ("hi", "guy");      // ОК в С++17: T1 = Т2 = ТЗ = char const*
С с4;                   // Ошибка: Т1 и Т2 не определены
С c5("hi");             // Ошибка: Т2 не определен
```

## Правила вывода

Рассмотрим сначала небольшое изменение в нашем [[Вывод аргументов шаблона - template#Аргументы шаблона класса|приведенном ранее примере]]:
```c++
template<typename Т>
class S
{
	private:
		Т а;
	public:
		S(Т Ь) : а(b)
		{
		}
};

template<typename Т> S(T) -> S<T> // Правило вывода

S х{12};            // ОК с С++17, то же что и S<int> х{12};
S у(12);            // OK с С++17, то же что и S<int> у(12);
auto z = S{12};     // ОК с С++17, то же что и auto z = S<int>{12);
```

Обратите внимание на новую шаблонообразную конструкцию, именуемую ***правилом вывода*** (deduction guide). Она выглядит подобно шаблону функции, но синтаксически отличается от шаблона функции несколькими моментами.
>
> Часть, которая выглядит подобно завершающему возвращаемому типу, не может быть записана как традиционный возвращаемый тип. Тип, который она обозначает (`S<T>` в нашем примере), мы называем типом, ***задаваемым правилом*** (guided type).
> 
> Нет ведущего ключевого слова [[auto|auto]] для указания наличия завершающего возвращаемого типа.
> 
> “Имя” правила вывода должно быть неквалифицированным именем шаблона класса, объявленного ранее в той же самой области видимости.
> 
> Тип, задаваемый правилом, должен быть ***идентификатором шаблона***, имя шаблона которого соответствует имени правила.
> 
> Оно может быть объявлено со спецификатором [[explicit|explicit]].

В объявлении `S х{12}`; спецификатор `S` называется типом — заместителем класса (placeholder class type). При использовании такого заместителя имя объявляемой переменной должно следовать непосредственно за ним, а за именем, в свою очередь, должен следовать инициализатор. Так что следующий код некорректен:
```c++
S* р = &х; // Ошибка: неразрешенный синтаксис
```

При наличии правила, приведенного в нашем примере, объявление `S х{12}` ;
выводит тип переменной, рассматривая правила вывода, связанные с классом `S`, как множество перегрузок, и пытаясь выполнить разрешение перегрузки с инициализатором с помощью этого множества. В нашем случае это множество состоит только из одного правила, и оно успешно выводит `Т` как `int`, а тип, задаваемый правилом, как `S<int>`. Поэтому этот тип выбирается как тип объявления.

Обратите внимание на то, что в случае нескольких деклараторов, следующих за именем шаблона класса, требующего вывода, инициализатор для каждого из этих деклараторов должен давать один и тот же тип. Например, для приведенных выше объявлений:
```c++
S s1(1), s2(2.0);   // Ошибка: вывод S и как S<int>, и как S<double>
```

Это аналогично ограничению при выводе типа-заместителя С++11 [[auto|auto]].

В предыдущем примере имеется неявная связь между правилом вывода, которое мы объявили, и конструктором `S(Т b)`, объявленным в классе `S`. Однако такая связь не является обязательной, что означает, что правила вывода могут использоваться с шаблонами классов-агрегатов:
```c++
template<typename Т>
struct А
{
	Т val;
};

template<typename Т> А(Т) -> А<Т>; // Правило вывода
```

Без этого правила вывода мы должны всегда (даже в C++17) указывать явные аргументы шаблона:
```c++
A<int> a1{42};     // ОК
A<int> а2(42);     // Ошибка не агрегатная инициализация
A<int> аЗ = {42};  // ОК
А а4 = 42;         // Ошибка: невозможно вывести тип
```

Но при наличии такого правила, как приведенное выше, можно записать:
```c++
А а4 = {42}; // ОК
```

Однако в случаях, подобных этому, тонкостью является то, что инициализатор должен оставаться корректным инициализатором агрегата; т.е. он должен использовать список инициализации в фигурных скобках. Поэтому не допускаются следующие альтернативы:
```c++
А а5(42);  // Ошибка: не агрегатная инициализация
А аб = 42; // Ошибка: не агрегатная инициализация
```

## Неявные правила вывода

Довольно часто правила вывода желательны для каждого конструктора в шаблоне класса. Это привело разработчиков вывода аргументов шаблонов классов к включению неявного механизма вывода, что эквивалентно представлению для каждого конструктора и шаблона конструктора неявного правила вывода следующим образом.
>
> Список параметров шаблона для неявного правила состоит из параметров шаблона для шаблона класса, за которыми (в случае шаблона конструктора) следуют параметры шаблонов шаблона конструктора. Эти последние сохраняют любые аргументы по умолчанию.
> 
> “Функциеобразные” параметры правила копируются из конструктора или шаблона конструктора.
> 
> Тип, задаваемый правилом, представляет собой имя шаблона с аргументами, которые представляют собой параметры шаблонов, взятые из шаблона класса.

Применим сказанное к нашему простому шаблону класса:
```c++
template<typename Т>
class S
{
	private:
		Т а;
		
	public:
		S(T b) : a(b)
		{
		}
};
```

Список параметров шаблона представляет собой `typename Т`, “функциеобразный” список параметров становится просто `(Т b)`, а тип, задаваемый правилом, — `S<T>`. Таким образом, мы получаем правило, эквивалентное объявленному пользователем, которое мы писали ранее: следовательно, получается, что это правило не требовалось для получения желаемого результата! Иными словами, при работе с такими простыми шаблонами классов, как рассмотренный выше (и без правил вывода) можно вполне корректно просто записать `S х{12}`; и получить ожидаемый результат — что `х` имеет тип `S<int>`.

Правила выводов содержат неоднозначность. Снова рассмотрим наш простой шаблон класса `S` и следующие инициализации:
```c++
S х{12);  // х имеет тип S<int>
S у{х};
S z(х);
```

Мы уже видели, что `х` имеет тип `S<int>`, но какими должны быть типы `у` и `z`? Интуитивно эти два типа должны быть `S<S<int>>` и `S<int>`. Комитет принял несколько спорное решение, что это должен быть тип `S<int>` в обоих случаях. Почему это спорно? Рассмотрим похожий пример с типом [[vector|vector]]:
```c++
std::vector v{1, 2, 3};     // vector<int> - ничего удивительного
std::vector w2{v, v};       // vector<vector<int>>
std::vector w1{v};          // vector<int>!
```

Другими словами, инициализатор с одним элементом в фигурных скобках приводит к иному выводу, чем инициализатор с фигурными скобками с несколькими элементами. Часто результат в виде вектора с одним элементом является желательным, но непоследовательность оказывается тонким вопросом. В обобщенном коде эту тонкость легко упустить:
```c++
template<typename Т, typename... Ts>
auto f(Т р, Ts... ps)
{
	std::vector v{p, ps...}; // Тип зависит от длины пакета
	...
}
```

Здесь легко забыть, что если `Т` выводится как векторный тип, то тип `v` будет принципиально различен в зависимости от того, является ли `ps` пустым или не пустым пакетом.

Добавление неявных правил само по себе несколько противоречиво. Основной аргумент против их включения заключается в том, что эта возможность автоматически добавляет интерфейсы к существующим библиотекам. Чтобы понять, о чем идет речь, рассмотрим еще раз наш простой шаблон класса `S`, приведенный выше. Его определение было корректным с момента ввода шаблонов в C++. Предположим, однако, что автор `S` расширяет библиотеку, что приводит к определению `S` более сложным способом:
```c++
template<typename Т>
struct ValueArg
{
	using Type = T;
};

template<typename Т>
class S
{
	private:
		Т а;
	
	public:
		using ArgType = typename ValueArg<T>::Type;
		S(ArgType b) : a(b)
		{
		}
};
```

До C++17 подобные преобразования (мало распространенные) не влияли на существующий код. Однако в C++17 они отключают неявные правила вывода. Чтобы увидеть это, напишем правило вывода, соответствующее правилу, генерируемому процессом создания неявных правил вывода, описанным выше: список параметров шаблона и правило вывода остаются неизменными, но “функциеобразный” параметр теперь записывается в терминах `ArgType`, который представляет собой не что иное, как `typename ValueArg<T>: : Type`:
```c++
template<typename> S(typename ValueArg<T>::Type) -> S<T>;
```

[[Вывод аргументов шаблона - template#Выводимые контексты|Вспомним, что квалификатор имени]] наподобие `ValueArg<T>::` не является выводимым контекстом. Так что правило вывода такого вида является бесполезным и не разрешает объявление наподобие `S х(12)` ;. Другими словами, разработчик библиотеки, выполнивший такое преобразование, нарушит работу клиентского кода в C++17.

Что же должен делать разработчик библиотеки в такой ситуации? Наш совет заключается в том, чтобы тщательно рассмотреть каждый конструктор — хотите ли вы предложить его в качестве источника для неявного правила вывода на все оставшееся время жизни библиотеки. Если нет, то замените каждый экземпляр выводимого параметра конструктора типа `X` на что-то вроде `typename ValueArg<X>::Туре`. К сожалению, более простого способа избавиться от неявных правил вывода не имеется.

## Прочие тонкости

***==Внедренные имена классов==***

Рассмотрим следующий пример:
```c++
template<typename Т> 
struct X
{
	template<typename Iter> X(Iter b, Iter e);
	
	template<typename Iter> auto f(Iter b, Iter e)
	{
		return X(b, e); // Что это?
	}
};
```

Этот код корректен в C++14: `X` в `Х(b, е)` представляет собой [[Имена в шаблонах - template#Внесение имен классов|внедренное имя класса]] (injected class name), в данном контексте эквивалентное `Х<Т>`. Правила вывода аргументов шаблонов класса, однако, естественным образом делают `X` эквивалентным `X<Iter>`.

Тем не менее для обеспечения обратной совместимости вывод аргументов шаблона класса отключен, если имя шаблона представляет собой внедренное имя класса.

***==Передаваемые ссылки==***

Рассмотрим другой пример:
```c++
template<typename Т> 
struct Y
{
	Y(Т const&);
	Y(T&&) ;
};

void g(std::string s)
{
	Y у = s;
}
```

Очевидно, что здесь преследуется цель вывести `Т` как [[string|std::string]] с помощью неявных правил вывода, связанных с копирующим конструктором. Написание неявных правил вывода как явно объявленных приводит к сюрпризу:
```c++
template<typename Т> Y(T const&) -> Y<T>; // #1
template<typename T> Y(T&&) -> Y<T>;
// #2
```

[[Вывод аргументов шаблона - template#Ссылки на r-значения|Вспомним, что Т&& во время вывода аргументов шаблона ведет себя особым образом]]: будучи передаваемой ссылкой (forwarding reference), она приводит к тому, что `Т` выводится как ссылочный тип, если соответствующий аргумент вызова представляет собой [[значение - template#l-значение|l-значение]]. В нашем примере выше в процессе вывода аргументом является выражение `s`, которое представляет собой [[значение - template#l-значение|l-значение]]. Неявное правило `#1` выводит `Т` как [[string|std::string]], но требует, чтобы аргумент был исправлен с [[string|std::string]] на `std::string const`. Однако правило `#2` обычно выводит `Т` как ссылочный тип [[string|std::string]] и генерирует параметр того же типа (из-за правила свертки ссылок), который является подходящим в большей степени, поскольку не требует добавления [[const|const]]. Этот результат кажется несколько удивительным и скорее всего приведет к ошибке инстанцирования (при использовании параметра шаблона класса в контекстах, которые не допускают ссылочные типы) или, хуже того, к молчаливому неверному инстанцированию (приводящему, например, к висящим ссылкам).

Поэтому Комитет по стандартизации C++ пришел к решению удалить особое правило вывода для `Т&&` при выполнении вывода для неявных правил вывода, если `Т` изначально был параметром шаблона класса (в отличие от параметра шаблона конструктора; для них особое правило вывода остается в силе). Таким образом, приведенный выше пример выводит `Т` как [[string|std::string]], что и следовало ожидать.

***==Ключевое слово explicit==***

Правило вывода может быть объявлено с ключевым словом [[explicit|explicit]]. В таком случае оно рассматривается только при непосредственной, но не при копирующей инициализации. Например:
```c++
template<typename Т, typename U> 
struct Z
{
	Z(T const&);
	Z (T&&);
};

template<typename T> Z(T const&) -> Z<T, T&>;     // #1

template<typename T> explicit Z(T&&) -> Z<T, T>;  // #2

Z z1 = 1; // Рассматривается только #1; аналог Z<int,int&>z1=1;
Z z2{2};  // Предпочтительно #2; аналог Z<int,int> z2{2};
```

Обратите внимание на то, что инициализация `z1` является копирующей, а потому правило вывода `#2` при этом не рассматривается, будучи объявлено как [[explicit|explicit]].

***==Копирующее конструирование и списки инициализации==***

Рассмотрим следующий шаблон класса:
```c++
template<typename ... Ts> 
struct Tuple
{
	Tuple(Ts...);
	Tuple(Tuple<Ts...> const&);
};
```

Чтобы понять результат применения неявных правил, давайте запишем их как явные объявления:
```c++
template<typename... Ts> Tuple(Ts...) -> Tuple<Ts... >;
template<typename... Ts> Tuple(Tuple<Ts...> const&) -> Tuple<Ts...>;
```

Теперь рассмотрим несколько примеров:
```c++
auto х = Tuple{1, 2};
```

Ясно, что здесь выбирается первое правило, а значит, и первый конструктор: `х`, таким образом, представляет собой `Tuple<int, int>`. Давайте продолжим и рассмотрим некоторые примеры, использующие синтаксис, который наводит на мысль о копировании `х`:
```c++
Tuple а = х;
Tuple b(х);
```

Оба правила походят и для `а`, и для `b`. Первое правило выбирает тип `Tuple <Tuple<int, int>>`, в то время как правило, связанное с копирующим конструктором, дает `Tuple<int, int>`. К счастью, второе правило обеспечивает лучшее соответствие, а потому и `а`, и `b` конструируются копированием из `х`.

Рассмотрим теперь несколько правил с использованием списков инициализации в фигурных скобках:
```c++
Tuple с{х, х};
Tuple d{х};
```

В первом из этих примеров (`х`) может соответствовать только первому правилу, так что получается `Tuple<Tuple<int, int>, Tuple<int, int>>`. Это соответствует интуитивным представлениям и не является чем-то удивительным. Точно так же кажется, что во втором примере тип `d` должен быть выведен как `Tuple<Tuple<int>>`. Однако вместо этого второй пример рассматривается как копирующее конструирование (т.е. предпочтительнее оказывается второе неявное правило). То же самое происходит и при выполнении функционального приведения типов:
```c++
auto е = Tuple{x};
```

Здесь `е` выводится как `Tuple<int, int>`, а не как `Tuple<Tuple<int>>`.

***===Правила используются только для вывода===***

Правила вывода не предназначены для шаблонов функций — они используются только для вывода параметров шаблонов и не “вызываются”. Это означает, что разница между передачей аргументов по ссылке или по значению не важна для объявлений, управляемых правилами. Например:
```c++
template<typename Т> struct X
{
	...
};

template<typename Т> struct Y
{
	Y(Х<Т> const&);
	Y(X<T>&&);
};

template<typename T> Y(X<T>) -> Y<T>;
```

Обратите внимание, что правило вывода не совсем соответствует двум конструкторам `Y`. Однако это не имеет значения, потому что правило используется только для вывода. Для данного значения `xtt` типа `Х<ТТ>` — [[значение - template|l- или r-значения]] — будет выбран выведенный тип `Y<TT>`. Затем инициализация выполнит разрешение перегрузки конструкторов `Y<TT>`, чтобы решить, какой из них следует вызвать (что будет зависеть от того, является `xtt` [[значение - template|l- или r-значением]]).
