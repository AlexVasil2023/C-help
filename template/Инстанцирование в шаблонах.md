
[[#Инстанцирование|Инстанцирование]] 14
1. [[#Инстанцирование по требованию|Инстанцирование по требованию]] 14.1
2. [[#Отложенное инстанцирование|Отложенное инстанцирование]] 14.2
	1. [[#Частичное и полное инстанцирование|Частичное и полное инстанцирование]] 14.2.1
	2. [[#Инстанцированные компоненты|Инстанцированные компоненты]] 14.2.2
3. [[#Модель инстанцирования С++|Модель инстанцирования С++]] 14.3
	1. [[#Двухфазный поиск|Двухфазный поиск]] 14.3.1




# Инстанцирование

Инстанцирование (instantiation) шаблонов — это процесс, при котором на основе обобщенного определения шаблонов генерируются типы и функции. В C++ концепция инстанцирования шаблонов играет фундаментальную роль, однако она несколько запутана. Одна из основных причин этой запутанности состоит в том, что определения генерируемых шаблоном элементов не сосредоточены в одном месте исходного кода. Местонахождение определения шаблона, его использования и определения аргументов — все это играет роль.

В данной главе объясняется, как организовать исходный код для надлежащего использования шаблонов. Кроме того, здесь представлены различные методы, которые используются в наиболее популярных компиляторах C++ для инстанцирования шаблонов. Хотя все эти методы должны быть семантически эквивалентны, полезно понимать основные принципы, лежащие в основе стратегии инстанцирования, которой придерживается ваш компилятор. С одной стороны, каждый механизм инстанцирования обладает своим набором мелких особенностей, с другой — он подвергается влиянию конечных спецификаций языка C++.

# Инстанцирование по требованию

Когда компилятор C++ встречает использование специализации шаблона, он создает ее, подставляя вместо параметров шаблона необходимые аргументы. Эти действия выполняются автоматически и не требуют каких бы то ни было указаний от пользовательского кода (или от определения шаблона). Это инстанцирование по требованию ставит шаблоны C++ особняком по отношению к ряду подобных функциональных возможностей в других ранних компилируемых языках (наподобие Ada или Eiffel; некоторые из этих языков требуют явных директив инстанцирования, в то время как другие используют механизмы диспетчеризации времени выполнения для полного устранения процесса инстанцирования). Это инстанцирование шаблона по требованию называют неявным (`implicit`) или автоматическим (`automatic`) инстанцированием. Шаблоны C++ стоят особняком по отношению к подобным возможностям других компилируемых языков программирования.

При инстанцировании по требованию компилятор обычно нуждается в доступе к полному определению (другими словами, не только к объявлению) шаблона и некоторых его членов в точке, где этот шаблон используется. Рассмотрим небольшой исходный текст.
```c++
template<typename Т> class С;    // #1 Только объявление

C<int>* р = 0;        // #2 Определение C<int> не требуется

template<typename Т>
class С
{
	public:
		void f();     // #3 Объявление члена
};                    // #4 Определение шаблона класса завершено

void g(C<int>& с)     // #5 Использование только объявления шаблона класса
{
	c.f();            // #6 Использование определения шаблона класса
}                     // требует определения С::f() в данной
					  // единице трансляции
template<typename Т>
void С<Т>::f()        // Требуемое объявление для #6
{
}
```

В точке `#1` исходного текста доступно только объявление шаблона, но не его определение (такое объявление иногда называют предварительным объявлением (forward declaration)). Как и для обычных классов, определение шаблона класса не обязано находиться в области видимости для объявления указателей или ссылок на данный тип (как это сделано в точке `#2`). Например, для указания типа, которому принадлежит параметр функции `g()`, не требуется полное определение шаблона `С`. Однако, как только компоненту понадобится информация о размере специализации шаблона, или при доступе к члену такой специализации, нужно, чтобы определение шаблона класса находилось полностью в области видимости. Этим объясняется, что в точке `#6` исходного кода должно быть доступно определение шаблона класса; в противном случае компилятор не в состоянии проверить наличие и доступность членов (ни закрытых, ни защищенных). Кроме того, необходимо также определение функции-члена, поскольку вызов в точке `#6` требует существования `C<int>::f()`.

Приведем еще одно выражение, требующее инстанцирования предыдущего шаблона класса, чтобы узнать размер конструкции `C<void>`:
```c++
C<void>* р = new C<void>;
```

В данном случае инстанцирование необходимо для того, чтобы компилятор мог определить размер объекта `C<void>`, который необходим выражению `new` для выяснения, какое количество памяти следует выделить. Возможно, вы заметили, что для данного конкретного шаблона тип аргумента `X`, который подставляется вместо параметра `Т`, не влияет на размер шаблона, поскольку в любом случае класс `С<Х>` будет пустым. Однако от компилятора не требуется избежать инстанцирования путем анализа определения шаблона (и все компиляторы на практике выполняют инстанцирование). Кроме того, в данном примере инстанцирование необходимо для того, чтобы определить, доступен ли конструктор по умолчанию для класса `C<void>`, а также убедиться, что в этом классе не объявлены операторы-члены `new` или [[delete|delete]].

Необходимость доступа к члену шаблона класса не всегда явно видна в исходном коде. Например, для разрешения перегрузки в C++ требуется, чтобы типы классов, которым принадлежат параметры функции-кандидата, находились в области видимости.
```c++
template<typename Т>
class С
{
	public:
		C(int); // Конструктор, который может быть вызван с одним
};              // параметром, может использоваться для неявных
				// преобразований
void candidate(C<double>);  // #1
void candidate(int) { }     // #2

int main()
{
	candidate(42);          // Могут быть вызваны обе функции,
}                           // объявления которых приведены выше
```

Вызов функции `candidate(42)` будет разрешен с помощью объявления `#2`. Однако объявление `#1` также может быть инстанцировано, чтобы проверить, подходит ли оно для разрешения вызова (благодаря тому, что конструктор с одним аргументом способен неявно преобразовать аргумент `42` в [[значение#r-значения|r-значение]] типа `C<double>`). Заметим, что компилятор может (но не обязан) выполнить инстанцирование, даже если способен обойтись при разрешении вызова и без него (в приведенном примере именно так и происходит, поскольку предпочесть неявное преобразование типов их точному совпадению невозможно). Заметим также, что инстанцирование `C<double>` может привести к ошибке (что, возможно, покажется удивительным)

# Отложенное инстанцирование

Приведенные к настоящему моменту примеры иллюстрируют требования, которые существенно не отличаются от требований при использовании обычных, не шаблонных классов. Во многих случаях нужно, чтобы [[Основные термины в области шаблонов#Полные и неполные типы|класс был полным, или завершенным]] (complete). В случае шаблона компилятор генерирует полное определение класса из определения шаблона класса.

В связи с этим возникает вопрос: какая часть шаблона инстанцируется? Можно было бы ответить так: ровно столько, сколько необходимо. Другими словами, при инстанцировании шаблонов компилятору следует быть максимально “ленивым”. Рассмотрим, что это означает.

## Частичное и полное инстанцирование

Как мы видели, иногда компилятору не требуется подстановка полного определения шаблона класса или функции. Например:
```c++
template<typename Т> Т f(Т р)
{
	return 2 * р;
}

decltype(f(2)) х = 2;
```

В этом примере тип, указанный как `decltype(f(2))`, не требует полного инстанцирования шаблона функции `f()`. Поэтому компилятору разрешена только подстановка объявления `f()`, но не ее “тела”. Иногда это называют частичным инстанцированием.

Аналогично, если экземпляр шаблона класса передается без необходимости иметь полный тип для этого экземпляра, компилятор не должен выполнять полное инстанцирование этого экземпляра шаблона класса. Рассмотрим следующий пример:
```c++
template<typename Т> class Q
{
	using Type = typename T::Type;
};

Q<int>* p = 0;           // OK: тело Q<int> не подставляется
```

Здесь полное инстанцирование `Q<int>` приводило бы к ошибке, поскольку `Т::Туре` не имеет смысла, когда `Т` представляет собой `int`. Но, поскольку `Q<int>` в данном примере не обязан быть полным типом, полное инстанцирование не выполняется, и код оказывается корректным (хотя и подозрительным).

У шаблонов переменных также различаются “полное” и “частичное” инстанцирование. Это иллюстрирует следующий пример:
```c++
template<typename Т> Т v = Т::default_value();
decltype(v<int>) s;      // OK: инициализатор v<int> не инстанцирован
```

Полное инстанцирование `v<int>` могло бы вызвать ошибку, но оно не является необходимым, если нам нужен только тип экземпляра шаблона переменной.

Интересно, что шаблоны псевдонимов этим различием не обладают: не существует двух способов их подстановки.

В C++, когда речь идет об “инстанцировании шаблона” без уточнения, идет речь о полном или частичном инстанцировании, подразумевается первое. То есть инстанцирование по умолчанию является полным инстанцированием.

## Инстанцированные компоненты

В процессе неявного (полного) инстанцирования шаблона класса инстанцируются все объявления его членов, но не соответствующие определения (т.е. члены инстанцируются частично). Из этого правила есть несколько исключений. Во-первых, если в шаблоне класса содержится безымянное объединение, члены определения этого объединения также инстанцируются. Другое исключение связано с виртуальными функциями-членами. При инстанцировании шаблона класса определения этих функций могут как инстанцироваться, так и нет. Во многих реализациях эти определения будут инстанцироваться в силу того, что внутренняя структура, обеспечивающая механизм виртуальных вызовов, требует, чтобы виртуальные функции существовали в виде объектов, доступных для связывания.

При инстанцировании шаблонов аргументы функции по умолчанию рассматриваются отдельно. В частности, они не инстанцируются, если только не вызывается именно та функция (или функция-член), в которой используются эти аргументы по умолчанию. Они не инстанцируются и в том случае, когда при вызове функции аргументы указываются явным образом, т.е. аргументы по умолчанию не используются.

Аналогично не инстанцируются спецификации исключений и инициализаторы членов по умолчанию, если они не требуются.

Приведем пример, иллюстрирующий все упомянутые случаи:
```c++
template<typename T>
class Safe
{
};

template<int N>
class Danger
{
	int arr[N];                     // OK, хотя некорректно при N<=0
};

template<typename T, int N>
class Tricky
{
	public:
		void noBodyHere(Safe<T>=3); // OK до тех пор, пока использование
									// значения по умолчанию не приведет
									//к ошибке
		void inclass()
		{
			Danger<N> noBoomYet;    // ОК до тех пор, пока inclass()
		}                           // не используется с N <= 0

		struct Nested
		{
			Danger<N> pfew;         // ОК до тех пор, пока Nested
		};                          // не используется с N<=0

		union                       // Благодаря безымянному объединению:
		{
			Danger<N> anonymous;    // OK до тех пор, пока Tricky не
			int align;              // инстанцируется с N<=0
		};

		void unsafe(T(*p)[N]);      // ОК до тех пор, пока Tricky не
									// инстанцируется с N<=0
		void error()
		{
			Danger < -1 > boom;     // Всегда ошибка (которую обнаруживают
		}                           // не все компиляторы)
};
```

Соответствующий стандарту компилятор C++ будет рассматривать эти определения шаблонов, чтобы проверить их синтаксис и общие семантические ограничения. При проверке ограничений, включающих параметры шаблонов, компилятор предполагает, что “все обстоит наилучшим образом”. Например, параметр `N` в члене `Danger::arr` может быть равным нулю или отрицательным (что привело бы к ошибке), однако предполагается, что это не так. Определения `inclass()`, `struct Nested` и безымянного объединения, таким образом, проблем не вызывают.

По той же причине объявление члена `unsafe (Т(*р)[N])` тоже не представляет проблемы до тех пор, пока вместо параметра шаблона `N` не подставляется конкретное значение.

Спецификация аргумента по умолчанию (`=3`) в объявлении члена `noBodyHere()` подозрительна, поскольку шаблон `Safe<>` не является инициализируемым целочисленным значением, однако предполагается, что аргумент по умолчанию для обобщенного определения `Safe<T>` не потребуется, либо что `Safe<T>` будет специализирован (см. #главу_16, “Специализация и перегрузка”) таким образом, что будет допускать инициализацию целочисленным значением. Однако определение функции-члена `error()` является ошибкой, даже когда шаблон не инстанцирован, поскольку использование `Danger<-1>` требует завершенного определения класса `Danger<-1>`, а генерация этого класса приводит к попытке определить массив с отрицательным размером. Интересно, что в то время как стандарт ясно указывает, что этот код некорректен, он также позволяет компилятору не диагностировать ошибку, если экземпляр шаблона на самом деле не используется. Следовательно, поскольку `Tricky<T,N>::error()` не используется ни для каких конкретных `Т` и `N`, компилятор не обязан выводить сообщение об ошибке в данном случае. Например, GCC и Visual C++ на момент написания данной книги эту ошибку не диагностировали.

Проанализируем теперь, что произойдет, если добавить следующее определение:
```c++
Tricky<int, -1> inst;
```

Это заставит компилятор выполнить (полное) инстанцирование `Tricky<int,-1>`, подставляя `int` вместо `Т` и `-1` вместо `N` в определении шаблона `Tricky<>`. Необходимы не все определения членов, но конструктор по умолчанию и деструктор (оба в данном случае объявляемые неявно) определенно вызываются, а следовательно, их определения должны быть так или иначе доступны (что так и есть в нашем примере, поскольку они генерируются неявно). Как пояснено выше, члены `Tricky<int, -1>` частично инстанцированы (то есть их объявления заменены): этот процесс потенциально может привести к ошибкам. Например, объявление `unsafe(Т(*р)[N])` создает тип массива с отрицательным количеством элементов, что является ошибкой. Аналогично член `anonymous` теперь вызывает ошибку, потому что тип `Danger<-1>` не может быть завершен. Напротив, определения членов `inclass()` и `struct Nested` еще не инстанцируются, и, таким образом, никаких ошибок от их необходимости для полного типа `Danger<-1>` (который содержит определение недопустимого массива, как мы уже упоминали ранее), не возникает.

Как уже указано, при инстанцировании шаблона на практике должны также предоставляться определения виртуальных членов. В противном случае могут возникнуть ошибки компоновки. Например:
```c++
template<typename Т>
class VirtualClass
{
	public:
		virtual ~VirtualClass(){}
		virtual T vmem(); // Вероятна ошибка при инстанцировании
							// без определения
};

int main()
{
	VirtualClass<int> inst;
}
```

Наконец, замечание об `operator->`. Рассмотрим код:
```c++
template<typename Т>
class С
{
	public:
		Т operator->();
};
```

Обычно `operator->` должен возвращать тип указателя или тип другого класса, к которому применим `operator->`. Это свидетельствует о том, что завершение `C<int>` вызовет ошибку, поскольку этот тип объявляет возвращаемый тип `operator->` как `int`. Поскольку определения такого рода основываются на некоторых определениях “естественных” шаблонов классов, правила языка сделаны более гибкими. От пользовательского оператора `operator->`, требуется возврат типа, к которому применим другой (например, встроенный) `operator->`, только если он действительно выбран процедурой разрешения перегрузки. Это утверждение остается истинным и тогда, когда оно не относится к шаблонам (хотя в таком контексте от него меньше пользы). Таким образом, здесь объявление не вызывает ошибки, даже несмотря на то, что в качестве возвращаемого типа подставляется тип `int`.

# Модель инстанцирования С++

Инстанцирование шаблона — это процесс, в результате которого из определенного шаблона путем подстановки его параметров генерируется обычный тип, функция или переменная. На первый взгляд может показаться, что здесь все довольно просто, однако на практике этот процесс обрастает множеством деталей.

## Двухфазный поиск























