
[[#Инстанцирование|Инстанцирование]] 14
1. [[#Инстанцирование по требованию|Инстанцирование по требованию]] 14.1
2. [[#Отложенное инстанцирование|Отложенное инстанцирование]] 14.2
	1. [[#Частичное и полное инстанцирование|Частичное и полное инстанцирование]] 14.2.1
	2. [[#Инстанцированные компоненты|Инстанцированные компоненты]] 14.2.2
3. [[#Модель инстанцирования С++|Модель инстанцирования С++]] 14.3
	1. [[#Двухфазный поиск|Двухфазный поиск]] 14.3.1
	2. [[#Точки инстанцирования|Точки инстанцирования]] 14.3.2
	3. [[#Модель включения|Модель включения]] 14.3.3
4. [[#Схемы реализации|Схемы реализации]] 14.4
	1. [[#Жадное инстанцирование|Жадное инстанцирование]] 14.4.1
	2. [[#Инстанцирование по запросу|Инстанцирование по запросу]] 14.4.2
	3. [[#Итеративное инстанцирование|Итеративное инстанцирование]] 14.4.3
5. [[#Явное инстанцирование|Явное инстанцирование]] 14.5
	1. [[#Ручное инстанцирование|Ручное инстанцирование]] 14.5.1
	2. [[#Объявления явного инстанцирования|Объявления явного инстанцирования]] 14.5.2
6. [[#Инструкции if времени компиляции|Инструкции if времени компиляции]] 14.6
7. [[#В стандартной библиотеке|В стандартной библиотеке]] 14.7

# Инстанцирование

Инстанцирование (instantiation) шаблонов — это процесс, при котором на основе обобщенного определения шаблонов генерируются типы и функции. В C++ концепция инстанцирования шаблонов играет фундаментальную роль, однако она несколько запутана. Одна из основных причин этой запутанности состоит в том, что определения генерируемых шаблоном элементов не сосредоточены в одном месте исходного кода. Местонахождение определения шаблона, его использования и определения аргументов — все это играет роль.

В данной главе объясняется, как организовать исходный код для надлежащего использования шаблонов. Кроме того, здесь представлены различные методы, которые используются в наиболее популярных компиляторах C++ для инстанцирования шаблонов. Хотя все эти методы должны быть семантически эквивалентны, полезно понимать основные принципы, лежащие в основе стратегии инстанцирования, которой придерживается ваш компилятор. С одной стороны, каждый механизм инстанцирования обладает своим набором мелких особенностей, с другой — он подвергается влиянию конечных спецификаций языка C++.

# Инстанцирование по требованию

Когда компилятор C++ встречает использование специализации шаблона, он создает ее, подставляя вместо параметров шаблона необходимые аргументы. Эти действия выполняются автоматически и не требуют каких бы то ни было указаний от пользовательского кода (или от определения шаблона). Это инстанцирование по требованию ставит шаблоны C++ особняком по отношению к ряду подобных функциональных возможностей в других ранних компилируемых языках (наподобие Ada или Eiffel; некоторые из этих языков требуют явных директив инстанцирования, в то время как другие используют механизмы диспетчеризации времени выполнения для полного устранения процесса инстанцирования). Это инстанцирование шаблона по требованию называют неявным (`implicit`) или автоматическим (`automatic`) инстанцированием. Шаблоны C++ стоят особняком по отношению к подобным возможностям других компилируемых языков программирования.

При инстанцировании по требованию компилятор обычно нуждается в доступе к полному определению (другими словами, не только к объявлению) шаблона и некоторых его членов в точке, где этот шаблон используется. Рассмотрим небольшой исходный текст.
```c++
template<typename Т> class С;    // #1 Только объявление

C<int>* р = 0;        // #2 Определение C<int> не требуется

template<typename Т>
class С
{
	public:
		void f();     // #3 Объявление члена
};                    // #4 Определение шаблона класса завершено

void g(C<int>& с)     // #5 Использование только объявления шаблона класса
{
	c.f();            // #6 Использование определения шаблона класса
}                     // требует определения С::f() в данной
					  // единице трансляции
template<typename Т>
void С<Т>::f()        // Требуемое объявление для #6
{
}
```

В точке `#1` исходного текста доступно только объявление шаблона, но не его определение (такое объявление иногда называют предварительным объявлением (forward declaration)). Как и для обычных классов, определение шаблона класса не обязано находиться в области видимости для объявления указателей или ссылок на данный тип (как это сделано в точке `#2`). Например, для указания типа, которому принадлежит параметр функции `g()`, не требуется полное определение шаблона `С`. Однако, как только компоненту понадобится информация о размере специализации шаблона, или при доступе к члену такой специализации, нужно, чтобы определение шаблона класса находилось полностью в области видимости. Этим объясняется, что в точке `#6` исходного кода должно быть доступно определение шаблона класса; в противном случае компилятор не в состоянии проверить наличие и доступность членов (ни закрытых, ни защищенных). Кроме того, необходимо также определение функции-члена, поскольку вызов в точке `#6` требует существования `C<int>::f()`.

Приведем еще одно выражение, требующее инстанцирования предыдущего шаблона класса, чтобы узнать размер конструкции `C<void>`:
```c++
C<void>* р = new C<void>;
```

В данном случае инстанцирование необходимо для того, чтобы компилятор мог определить размер объекта `C<void>`, который необходим выражению `new` для выяснения, какое количество памяти следует выделить. Возможно, вы заметили, что для данного конкретного шаблона тип аргумента `X`, который подставляется вместо параметра `Т`, не влияет на размер шаблона, поскольку в любом случае класс `С<Х>` будет пустым. Однако от компилятора не требуется избежать инстанцирования путем анализа определения шаблона (и все компиляторы на практике выполняют инстанцирование). Кроме того, в данном примере инстанцирование необходимо для того, чтобы определить, доступен ли конструктор по умолчанию для класса `C<void>`, а также убедиться, что в этом классе не объявлены операторы-члены `new` или [[delete|delete]].

Необходимость доступа к члену шаблона класса не всегда явно видна в исходном коде. Например, для разрешения перегрузки в C++ требуется, чтобы типы классов, которым принадлежат параметры функции-кандидата, находились в области видимости.
```c++
template<typename Т>
class С
{
	public:
		C(int); // Конструктор, который может быть вызван с одним
};              // параметром, может использоваться для неявных
				// преобразований
void candidate(C<double>);  // #1
void candidate(int) { }     // #2

int main()
{
	candidate(42);          // Могут быть вызваны обе функции,
}                           // объявления которых приведены выше
```

Вызов функции `candidate(42)` будет разрешен с помощью объявления `#2`. Однако объявление `#1` также может быть инстанцировано, чтобы проверить, подходит ли оно для разрешения вызова (благодаря тому, что конструктор с одним аргументом способен неявно преобразовать аргумент `42` в [[r-значение#r-значения|r-значение]] типа `C<double>`). Заметим, что компилятор может (но не обязан) выполнить инстанцирование, даже если способен обойтись при разрешении вызова и без него (в приведенном примере именно так и происходит, поскольку предпочесть неявное преобразование типов их точному совпадению невозможно). Заметим также, что инстанцирование `C<double>` может привести к ошибке (что, возможно, покажется удивительным)

# Отложенное инстанцирование

Приведенные к настоящему моменту примеры иллюстрируют требования, которые существенно не отличаются от требований при использовании обычных, не шаблонных классов. Во многих случаях нужно, чтобы [[Основные термины в области шаблонов#Полные и неполные типы|класс был полным, или завершенным]] (complete). В случае шаблона компилятор генерирует полное определение класса из определения шаблона класса.

В связи с этим возникает вопрос: какая часть шаблона инстанцируется? Можно было бы ответить так: ровно столько, сколько необходимо. Другими словами, при инстанцировании шаблонов компилятору следует быть максимально “ленивым”. Рассмотрим, что это означает.

## Частичное и полное инстанцирование

Как мы видели, иногда компилятору не требуется подстановка полного определения шаблона класса или функции. Например:
```c++
template<typename Т> Т f(Т р)
{
	return 2 * р;
}

decltype(f(2)) х = 2;
```

В этом примере тип, указанный как `decltype(f(2))`, не требует полного инстанцирования шаблона функции `f()`. Поэтому компилятору разрешена только подстановка объявления `f()`, но не ее “тела”. Иногда это называют частичным инстанцированием.

Аналогично, если экземпляр шаблона класса передается без необходимости иметь полный тип для этого экземпляра, компилятор не должен выполнять полное инстанцирование этого экземпляра шаблона класса. Рассмотрим следующий пример:
```c++
template<typename Т> class Q
{
	using Type = typename T::Type;
};

Q<int>* p = 0;           // OK: тело Q<int> не подставляется
```

Здесь полное инстанцирование `Q<int>` приводило бы к ошибке, поскольку `Т::Туре` не имеет смысла, когда `Т` представляет собой `int`. Но, поскольку `Q<int>` в данном примере не обязан быть полным типом, полное инстанцирование не выполняется, и код оказывается корректным (хотя и подозрительным).

У шаблонов переменных также различаются “полное” и “частичное” инстанцирование. Это иллюстрирует следующий пример:
```c++
template<typename Т> Т v = Т::default_value();
decltype(v<int>) s;      // OK: инициализатор v<int> не инстанцирован
```

Полное инстанцирование `v<int>` могло бы вызвать ошибку, но оно не является необходимым, если нам нужен только тип экземпляра шаблона переменной.

Интересно, что шаблоны псевдонимов этим различием не обладают: не существует двух способов их подстановки.

В C++, когда речь идет об “инстанцировании шаблона” без уточнения, идет речь о полном или частичном инстанцировании, подразумевается первое. То есть инстанцирование по умолчанию является полным инстанцированием.

## Инстанцированные компоненты

В процессе неявного (полного) инстанцирования шаблона класса инстанцируются все объявления его членов, но не соответствующие определения (т.е. члены инстанцируются частично). Из этого правила есть несколько исключений. Во-первых, если в шаблоне класса содержится безымянное объединение, члены определения этого объединения также инстанцируются. Другое исключение связано с виртуальными функциями-членами. При инстанцировании шаблона класса определения этих функций могут как инстанцироваться, так и нет. Во многих реализациях эти определения будут инстанцироваться в силу того, что внутренняя структура, обеспечивающая механизм виртуальных вызовов, требует, чтобы виртуальные функции существовали в виде объектов, доступных для связывания.

При инстанцировании шаблонов аргументы функции по умолчанию рассматриваются отдельно. В частности, они не инстанцируются, если только не вызывается именно та функция (или функция-член), в которой используются эти аргументы по умолчанию. Они не инстанцируются и в том случае, когда при вызове функции аргументы указываются явным образом, т.е. аргументы по умолчанию не используются.

Аналогично не инстанцируются спецификации исключений и инициализаторы членов по умолчанию, если они не требуются.

Приведем пример, иллюстрирующий все упомянутые случаи:
```c++
template<typename T>
class Safe
{
};

template<int N>
class Danger
{
	int arr[N];                     // OK, хотя некорректно при N<=0
};

template<typename T, int N>
class Tricky
{
	public:
		void noBodyHere(Safe<T>=3); // OK до тех пор, пока использование
									// значения по умолчанию не приведет
									//к ошибке
		void inclass()
		{
			Danger<N> noBoomYet;    // ОК до тех пор, пока inclass()
		}                           // не используется с N <= 0

		struct Nested
		{
			Danger<N> pfew;         // ОК до тех пор, пока Nested
		};                          // не используется с N<=0

		union                       // Благодаря безымянному объединению:
		{
			Danger<N> anonymous;    // OK до тех пор, пока Tricky не
			int align;              // инстанцируется с N<=0
		};

		void unsafe(T(*p)[N]);      // ОК до тех пор, пока Tricky не
									// инстанцируется с N<=0
		void error()
		{
			Danger < -1 > boom;     // Всегда ошибка (которую обнаруживают
		}                           // не все компиляторы)
};
```

Соответствующий стандарту компилятор C++ будет рассматривать эти определения шаблонов, чтобы проверить их синтаксис и общие семантические ограничения. При проверке ограничений, включающих параметры шаблонов, компилятор предполагает, что “все обстоит наилучшим образом”. Например, параметр `N` в члене `Danger::arr` может быть равным нулю или отрицательным (что привело бы к ошибке), однако предполагается, что это не так. Определения `inclass()`, `struct Nested` и безымянного объединения, таким образом, проблем не вызывают.

По той же причине объявление члена `unsafe (Т(*р)[N])` тоже не представляет проблемы до тех пор, пока вместо параметра шаблона `N` не подставляется конкретное значение.

Спецификация аргумента по умолчанию (`=3`) в объявлении члена `noBodyHere()` подозрительна, поскольку шаблон `Safe<>` не является инициализируемым целочисленным значением, однако предполагается, что аргумент по умолчанию для обобщенного определения `Safe<T>` не потребуется, либо что `Safe<T>` будет специализирован (см. #главу_16, “Специализация и перегрузка”) таким образом, что будет допускать инициализацию целочисленным значением. Однако определение функции-члена `error()` является ошибкой, даже когда шаблон не инстанцирован, поскольку использование `Danger<-1>` требует завершенного определения класса `Danger<-1>`, а генерация этого класса приводит к попытке определить массив с отрицательным размером. Интересно, что в то время как стандарт ясно указывает, что этот код некорректен, он также позволяет компилятору не диагностировать ошибку, если экземпляр шаблона на самом деле не используется. Следовательно, поскольку `Tricky<T,N>::error()` не используется ни для каких конкретных `Т` и `N`, компилятор не обязан выводить сообщение об ошибке в данном случае. Например, GCC и Visual C++ на момент написания данной книги эту ошибку не диагностировали.

Проанализируем теперь, что произойдет, если добавить следующее определение:
```c++
Tricky<int, -1> inst;
```

Это заставит компилятор выполнить (полное) инстанцирование `Tricky<int,-1>`, подставляя `int` вместо `Т` и `-1` вместо `N` в определении шаблона `Tricky<>`. Необходимы не все определения членов, но конструктор по умолчанию и деструктор (оба в данном случае объявляемые неявно) определенно вызываются, а следовательно, их определения должны быть так или иначе доступны (что так и есть в нашем примере, поскольку они генерируются неявно). Как пояснено выше, члены `Tricky<int, -1>` частично инстанцированы (то есть их объявления заменены): этот процесс потенциально может привести к ошибкам. Например, объявление `unsafe(Т(*р)[N])` создает тип массива с отрицательным количеством элементов, что является ошибкой. Аналогично член `anonymous` теперь вызывает ошибку, потому что тип `Danger<-1>` не может быть завершен. Напротив, определения членов `inclass()` и `struct Nested` еще не инстанцируются, и, таким образом, никаких ошибок от их необходимости для полного типа `Danger<-1>` (который содержит определение недопустимого массива, как мы уже упоминали ранее), не возникает.

Как уже указано, при инстанцировании шаблона на практике должны также предоставляться определения виртуальных членов. В противном случае могут возникнуть ошибки компоновки. Например:
```c++
template<typename Т>
class VirtualClass
{
	public:
		virtual ~VirtualClass(){}
		virtual T vmem(); // Вероятна ошибка при инстанцировании
							// без определения
};

int main()
{
	VirtualClass<int> inst;
}
```

Наконец, замечание об `operator->`. Рассмотрим код:
```c++
template<typename Т>
class С
{
	public:
		Т operator->();
};
```

Обычно `operator->` должен возвращать тип указателя или тип другого класса, к которому применим `operator->`. Это свидетельствует о том, что завершение `C<int>` вызовет ошибку, поскольку этот тип объявляет возвращаемый тип `operator->` как `int`. Поскольку определения такого рода основываются на некоторых определениях “естественных” шаблонов классов, правила языка сделаны более гибкими. От пользовательского оператора `operator->`, требуется возврат типа, к которому применим другой (например, встроенный) `operator->`, только если он действительно выбран процедурой разрешения перегрузки. Это утверждение остается истинным и тогда, когда оно не относится к шаблонам (хотя в таком контексте от него меньше пользы). Таким образом, здесь объявление не вызывает ошибки, даже несмотря на то, что в качестве возвращаемого типа подставляется тип `int`.

# Модель инстанцирования С++

Инстанцирование шаблона — это процесс, в результате которого из определенного шаблона путем подстановки его параметров генерируется обычный тип, функция или переменная. На первый взгляд может показаться, что здесь все довольно просто, однако на практике этот процесс обрастает множеством деталей.

## Двухфазный поиск

В главе [[Имена в шаблонах|“Имена в шаблонах”]], мы видели, что зависимые имена нельзя разрешить при синтаксическом анализе шаблонов. Поэтому в месте инстанцирования шаблона его определение еще раз просматривается компилятором. Однако независимые имена можно обработать при первом просмотре шаблона, выявив при этом многие ошибки. В результате мы приходим к концепции двухфазного поиска (two-phase lookup): первая фаза — синтаксический анализ шаблона, вторая — его инстанцирование.
1. На первом этапе, во время синтаксического анализа шаблона, обрабатываются независимые имена; на этой стадии анализ шаблона проводится с помощью правил обычного поиска (ordinary lookup rules), а также правил поиска, зависящего от аргументов (ADL), если они применимы в данном конкретном случае. Неквалифицированные зависимые имена (которые являются зависимыми, как зависимы имена функций при вызове с зависимыми аргументами) тоже просматриваются с помощью правил обычного поиска. Однако результат этого поиска не рассматривается как завершенный до тех пор, пока в процессе инстанцирования шаблона не будет проведен дополнительный поиск.
2. На втором этапе, выполняющемся при инстанцировании шаблона в точке инстанцирования (point of instantiation — POI), анализируются зависимые квалифицированные имена (в которых параметры шаблонов заменяются аргументами шаблонов для данного конкретного инстанцирования). Кроме того, выполняется дополнительный ADL для зависимых неквалифицированных имен, поиск которых на первом этапе выполнялся с помощью правил обычного поиска.

Для неквалифицированных зависимых имен первоначальный обычный поиск — пока еще неполный — используется для определения, является ли имя шаблоном. Рассмотрим следующий пример:
```c++
namespace N
{
	template<typename> void g(){}
	enum E { e };
}

template<typename> void f() {}

template<typename T> void h(T P)
{
	f<int>(p);     // #1
	g<int>(p);     // #2 Ошибка
}

int main()
{
	h(N::e);       // Вызов шаблона h с T = N::Е
}
```

В строке `#1`, увидев имя `f`, за которым следует `<`, компилятор должен решить, является ли `“<”` угловой скобкой или знаком “меньше”. Это зависит от того, известно ли, что имя `f` является шаблоном или нет; в нашем случае обычный поиск находит объявление имени `f`, которое действительно является шаблоном, так что синтаксический анализ успешно выполняется, считая `<` угловой скобкой.

Строка `#2`, однако, приводит к ошибке, потому что с помощью обычного поиска шаблон `g` не обнаруживается. Таким образом, `<` рассматривается как знак “меньше”, который в этом коде является синтаксической ошибкой. Если бы мы могли обойти эту проблему, то в конечном итоге нашли бы шаблон `N::g` с использованием ADL при инстанцировании `h` для `T=N::Е` (так как `N` — это пространство имен, связанное с `Е`), но все это невозможно до тех пор, пока мы не проанализируем успешно обобщенное определение `h`.

## Точки инстанцирования

Как уже было показано, в исходном коде, использующем шаблон, есть места, в которых компилятор C++ должен иметь доступ к объявлению или определению этого шаблона. ***Точка инстанцирования*** (point of instantiation — POI) создается в том случае, когда некоторая конструкция исходного кода ссылается на специализацию шаблона таким образом, что для создания этой специализации требуется инстанцирование определения соответствующего шаблона. Точка инстанцирования — это место кода, в которое можно вставить шаблон с подставленными аргументами. Например:
```c++
class MyInt
{
	public:
		MyInt(int i);
};

MyInt operator -(MyInt const&);

bool operator >(MyInt const&, MyInt const&);

using Int = MyInt;

template<typename T>
void f(T i)
{
	if(i > 0)
	{
		g(-i);
	}
}
										// #1
void g(Int)
{
										// #2
	f<Int>(42);                         // Точка вызова
										// #3
}
										// #4
```

Когда компилятор C++ встречает вызов шаблона функции `f<Int>(42)`, он знает, что нужно инстанцировать шаблон `f`, подставив вместо параметра `Т` тип `MyInt`. В результате создается точка инстанцирования. Точки `#2` и `#3` находятся совсем рядом с местом вызова, однако они не могут быть точками инстанцирования, потому что в языке C++ в этих точках нельзя вставить определение `::f<Int>(Int)`. Главное различие между точками `#1` и `#4` заключается в том, что в точке `#4` функция `g(Int)` находится в области видимости, поэтому становится разрешимым вызов `g(-i)`. Если бы точка `#1` была точкой инстанцирования, то этот вызов нельзя было бы разрешить, поскольку в этой точке функция `g(Int)` еще не видна. К счастью, в C++ определяется, что точка инстанцирования для ссылки на специализацию шаблона функции должна находиться сразу после ближайшего объявления или определения области видимости пространства имен, в котором содержится эта ссылка. В нашем примере это точка `#4`.

Возможно, вас удивит, что в этом примере вместо обычного типа `int` принимает участие тип `Mylnt`. Дело в том, что на втором этапе поиска имен, который проводится в точке инстанцирования, используется только ADL. Поскольку с типом `int` не связано никакое пространство имен, то при его применении поиск в точке инстанцирования не проводился бы и функция `g` не была бы обнаружена. Следовательно, если мы заменим объявление псевдонима типа `Int` следующим:
```c++
using Int = int;
```

то код из предыдущего примера перестанет компилироваться. Приведенный далее пример страдает от подобной проблемы:
```c++
template<typename Т>
void f1(Т х)
{
	g1(х);                      // #1
}

void g1(int)
{

}

int main()
{
	f1(7);                      // Ошибка: g1 не найдена!
}
								// #2 Точка инстанцирования f1<int>(int)
```

Вызов `f1(7)` создает точку инстанцирования для `f1<int>(int)` сразу за `main()` в точке `#2`. В этом инстанцировании ключевым вопросом является поиск функции `g1`. Когда определение шаблона `f1` встречается впервые, отмечается, что неквалифицированное имя `g1` является зависимым, поскольку это имя функции в вызове функции с зависимыми аргументами (тип аргумента `х` зависит от параметра шаблона `Т`). Таким образом, `g1` ищется в точке `#1` с помощью правил обычного поиска; однако `g1` в этот момент не является видимой. В точке `#2`, точке инстанцирования, функция ищется снова в связанных пространствах имен и классах, но тип аргумента является `int`, и он не имеет связанных пространств имен или классов. Таким образом, `g1` никогда не будет найдена, несмотря даже на то, что обычный поиск в точке инстанцирования нашел бы `g1`.

Точка инстанцирования для шаблонов переменных обрабатывается аналогично обработке шаблонов функций.

Для специализаций шаблонов классов ситуация иная, как иллюстрирует следующий пример:
```c++
template<typename Т>
class S
{
	public:
		Т m;
};
											// #1
unsigned long h()
{
											// #2
	return (unsigned long)sizeof(S<int>);
											// #3
}
											// #4
```

И вновь точки области видимости функции `#2` и `#3` не могут быть точками инстанцирования, потому что определение класса `S<int>` с областью видимости пространства имен не может в них находиться (шаблоны в общем случае не могут находиться в области видимости функции). Если следовать правилу для экземпляров шаблона функции, точка инстанцирования будет в `#4`, но тогда недопустимо выражение `sizeof(S<int>)`, потому что размер `S<int>` не может быть определен, пока не будет достигнута точка `#4`. Таким образом, точка инстанцирования для ссылки на сгенерированный экземпляр класса определяется как точка непосредственно перед ближайшим объявлением или определением области видимости пространства имен, содержащей ссылку на этот экземпляр. В нашем примере это точка `#1`.

Когда шаблон в действительности инстанцируется, может появиться необходимость в дополнительных инстанцированиях. Рассмотрим небольшой пример:
```c++
template<typename Т>
class S
{
	public:
		using I = int;
};

									// #1
template<typename T>
void f()
{
	S<char>::I var1 = 41;
	typename S<T>::I var2 = 42;
}

int main()
{
	f<double>();
}
									// #2: #2a, #2б
```

Нашим предыдущим рассмотрением уже установлено, что точка инстанцирования для `f<double>()` находится в точке `#2`. Шаблон функции `f()` также обращается к специализации класса `S<char>` с точкой инстанцирования, которая, таким образом, находится в точке `#1`. Он обращается также к `S<T>`, но, поскольку он до сих пор остается зависимым, мы в действительности не можем инстанцировать его в этой точке. Однако если мы инстанцируем `f<double> ()` в точке `#2`, то заметим, что нам также необходимо инстанцировать определение `S<double>`. Такие вторичные, или переходные, точки инстанцирования определены несколько иначе. Для шаблонов функций вторичные точки инстанцирования в точности те же, что и первичные точки инстанцирования. Для классов вторичная точка инстанцирования непосредственно предшествует (в ближайшей охватывающей области видимости пространства имен) первичной точке инстанцирования. В нашем примере это означает, что точка инстанцирования `f<double>()` может быть помещена в точке `#2б`, а прямо перед ней — в точке `#2а` — находится вторичная точка инстанцирования для `S<double>`. Обратите внимание на отличие описанной ситуации от точки инстанцирования для `S<char>`.

Единица трансляции часто содержит несколько точек инстанцирования для одного и того же экземпляра. Для экземпляров шаблона класса в каждой единице трансляции сохраняется только первая точка инстанцирования, а последующие игнорируются (они не рассматриваются в действительности как точки инстанцирования). Для экземпляров шаблонов функций и переменных все точки инстанцирования сохраняются. В любом случае правило одного определения требует, чтобы инстанцирования, происходящие в любой из сохраненных точек инстанцирования, были эквивалентны, но компилятор C++ не обязан проверять и диагностировать нарушения этого правила. Это позволяет компилятору C++ выбрать только одну точку инстанцирования шаблона, не являющегося шаблоном класса, для выполнения фактического инстанцирования без беспокойства о том, что другая точка инстанцирования может привести к другому инстанцированию, отличному от данного.

На практике большинство компиляторов откладывают фактическое инстанцирование большинства шаблонов функций до конца единицы трансляции. Некоторые инстанцирования не могут быть отложены, включая случаи, где инстанцирование необходимо для определения выводимого возвращаемого типа (см. #разделы_15_10_1 и #15_10_4), и случаи, когда функция является [[constexpr|constexpr-функцией]] и должна вычисляться для получения константного результата. Некоторые компиляторы инстанцируют встраиваемые функции при первом использовании для обеспечения правильного встраивания. Это фактически перемещает точки инстанцирования соответствующих специализаций шаблонов в конец единицы трансляции, который в стандарте C++ разрешается использовать как альтернативную точку инстанцирования.

## Модель включения

Где бы ни находилась точка инстанцирования, в этом месте каким-то образом должен быть обеспечен доступ к соответствующему шаблону. Для специализации класса это означает, что определение шаблона класса должно быть видимым в точке, которая находится раньше в данной единице трансляции. Для точек инстанцирования шаблонов функций и переменных (а также функций-членов и статических членов-данных шаблонов классов) это тоже необходимо. Обычно определения шаблонов просто добавляются в заголовочные файлы, которые с помощью директивы `#include` включаются в единицу трансляции, даже когда они представляют собой шаблоны, не являющиеся типами. Такая модель, применяемая к определениям шаблонов, называется моделью включения (inclusion model) и представляет собой единственную автоматическую модель исходных текстов для шаблонов, поддерживаемую текущим стандартом C++.

Хотя модель включения поощряет программистов размещать все определения шаблонов в заголовочных файлах, чтобы они были доступны и удовлетворяли любым точкам инстанцирования, которые могут возникнуть, можно явным образом управлять инстанцированиями с использованием ***объявлений явного инстанцирования*** (explicit instantiation declarations) и ***определений явного инстанцирования*** (explicit instantiation definitions) (см. #раздел_14_5). Это технически не тривиально, так что большую часть времени программисты предпочитают полагаться на механизм автоматического инстанцирования. Одной из задач реализации с автоматической схемой является возможность иметь точки инстанцирования для одной и той же специализации шаблона функции или переменной (или одной и той же функции-члена или статических членов-данных экземпляра шаблона класса) в нескольких единицах трансляции. Далее мы обсудим подходы к этой проблеме.

# Схемы реализации

В этом разделе рассматриваются некоторые способы, с помощью которых различные реализации C++ поддерживают модель включения. Все эти реализации основываются на двух классических компонентах: на компиляторе и компоновщике. Компилятор преобразует исходный код в объектные файлы, которые содержат машинный код и символические аннотации (перекрестные ссылки на другие объектные файлы и библиотеки). Компоновщик создает исполняемые программы или библиотеки, соединяя объектные файлы в одно целое и разрешая содержащиеся в них перекрестные ссылки. Все, о чем пойдет речь далее, относится именно к такой модели, хотя вполне возможны другие способы реализации языка C++ (которые не приобрели широкой популярности). Например, вполне можно представить себе интерпретатор C++.

Если специализация шаблона класса используется в нескольких единицах трансляции, компилятору придется повторить процесс инстанцирования в каждой из этих единиц. Количество возникающих в связи с этим проблем весьма незначительно, поскольку определения классов не генерируют непосредственно код низкого уровня. Эти определения используются только внутри реализации C++ для проверки и интерпретации различных других выражений и объявлений. В этом отношении множественное инстанцирование определения класса, по сути, не отличается от многократного включения определения класса (обычно с помощью включения заголовочного файла) в разные единицы трансляции.

Однако если происходит инстанцирование шаблона (невстраиваемой) функции, ситуация может измениться. Если использовать несколько определений обычных невстроенных функций, то это нарушит правило одного определения. Например, предположим, что компилируется и компонуется программа, состоящая из двух приведенных ниже файлов:
```c++
// ===== а.срр:
int main()
{   }

// == Ь.срр:
int main ()
{   }
```

Компиляторы C++ будут компилировать каждый модуль отдельно, причем без каких-либо проблем, потому что эти единицы трансляции, безусловно, являются корректными с точки зрения C++. Однако попытка связать эти два файла, скорее всего, вызовет протест компоновщика. Дело в том, что дублирование определений не допускается.

Рассмотрим теперь другой пример, в котором участвуют шаблоны.
```c++
// ===== t.hpp:
// Общий заголовочный файл (модель включения)
template<typename Т>
class S
{
	public:
		void f();
};

template<typename T>
void S::f()               // Определение члена
{   }

void helper(S<int>*);

// ===== a. cpp:
#include "t.hpp"
void helper(S<int>* s)
{
	s->f();               // #1 Первая точка инстанцирования S::f
}

// ==== b.cpp:
#include "t.hpp"
int main()
{
	S<int> s;
	helper(&s);
	s.f();                // #2 Вторая точка инстанцирования S::f
}
```

Если компоновщик рассматривает инстанцированные функции-члены шаблонов классов точно так же, как обычные функции или функции-члены, то компилятор должен гарантировать, что он сгенерирует код только в одной из двух точек инстанцирования: в точке `#1` или `#2`, но не в обеих. Чтобы достичь этого, компилятор должен перенести информацию из одной единицы трансляции в другую, а это никогда не требовалось от компиляторов C++ до введения шаблонов в этот язык программирования. Далее рассматриваются три популярных класса решений, получивших широкое распространение среди разработчиков реализаций языка C++.

Заметим, что такая же проблема возникает во всех связываемых объектах, возникающих в результате инстанцирования шаблонов: как в инстанцированных шаблонах обычных функций и функций-членов, так и в инстанцированных статических данных-членах и инстанцированных шаблонах переменных.

## Жадное инстанцирование

Первые компиляторы C++, которые сделали популярным так называемое жадное инстанцирование, были произведены компанией Borland. С тех пор этот подход стал одним из самых распространенных методов среди различных систем C++.

В процессе жадного инстанцирования предполагается, что компоновщик осведомлен о том, что некоторые объекты (в частности, подлежащие компоновке инстанцированные шаблоны) могут дублироваться в разных объектных файлах и библиотеках. Обычно компилятор помечает такие элементы особым образом. Когда компоновщик обнаруживает множественные инстанцирования, одно из них он оставляет, а остальные отбрасывает. В этом и заключается суть рассматриваемого подхода.

Теоретически жадное инстанцирование обладает некоторыми серьезными недостатками, перечисленными ниже.
>
> Компилятор может потратить время на генерацию и оптимизацию множества инстанцирований, из которых будет использоваться только одно.
> 
> Обычно компоновщики не проверяют идентичность двух инстанцирований, так как код, сгенерированный для разных экземпляров одной и той же специализации шаблона, может незначительно варьироваться, что вполне допустимо. Нельзя допустить, чтобы из-за этих небольших различий в работе компоновщика произошел сбой. (Причиной этих различий могут быть несущественные расхождения в состоянии компилятора в моменты инстанцирования.) Однако часто это приводит к тому, что компоновщик не замечает более существенных различий, например когда одно из инстанцирований скомпилировано со строгими математическими правилами работы с числами с плавающей точкой, а другое — с ослабленными высокопроизводительными правилами.
> 
> Потенциально объем всех объектных файлов может существенно превысить их объем при использовании иного подхода, поскольку один и тот же фрагмент кода дублируется несколько раз.

На практике оказывается, что эти недостатки не создают особых проблем. Возможно, так получается благодаря тому, что жадное инстанцирование очень выгодно отличается от альтернативных подходов в одном важном аспекте: оно сохраняет традиционную зависимость от исходного кода. В частности, из одной единицы трансляции генерируется только один объектный файл, и каждый объектный файл содержит скомпилированный код всех подлежащих компоновке определений из соответствующего исходного файла (включая инстанцированные определения). Другим важным преимуществом является то, что все экземпляры шаблона функции являются кандидатами для встраивания без применения дорогих механизмов оптимизации времени компоновки (на практике экземпляры шаблона функции часто представляют собой малые функции, встраивание которых приносит выгоду). Другие механизмы инстанцирования обрабатывают встраиваемые экземпляры шаблонов функций особым образом, чтобы гарантировать, что они могут быть преобразованы во встроенный код. Однако жадное инстанцирование позволяет преобразовывать во встраиваемые даже функции, не объявленные таковыми.

Наконец, стоит заметить, что механизм компоновки, позволяющий дублировать определения компонуемых элементов, обычно используется для обработки ***дублируемых встраиваемых функций*** и ***таблиц диспетчеризации виртуальных функций***. Если этот механизм недоступен, в качестве альтернативы эти элементы обычно генерируются с внутренним связыванием, но это приводит к увеличению объема генерируемого кода. Требование, чтобы встраиваемая функция имела единственный адрес, затрудняет реализацию альтернативных подходов соответствующим стандарту способом.

## Инстанцирование по запросу

В середине 1990-х годов компания Sun Microsystems выпустила реализацию своего компилятора C++ версии 4.0 с новым и интересным решением проблемы инстанцирования, которое мы называем инстанцированием по запросу (queried instantiation). Концептуально инстанцирование по запросу отличается удивительной простотой и элегантностью, являясь при этом наиболее современной схемой инстанцирования классов из всех рассматриваемых здесь. В этой схеме создается и поддерживается специальная база данных, совместно используемая при компиляции всех единиц трансляции, имеющих отношение к программе. В нее заносятся сведения об инстанцированных специализациях шаблонов, а также о том, от какого элемента исходного кода они зависят. Сами сгенерированные специализации также обычно сохраняются в этой базе данных. При достижении точки инстанцирования подлежащего компоновке элемента происходит одно из трех перечисленных ниже событий.
1. Соответствующая специализация отсутствует. В этом случае происходит инстанцирование, а полученная в результате специализация заносится в базу данных.
2. Специализация имеется в наличии, однако она устарела, поскольку с момента ее создания произошли изменения в исходном коде. В этой ситуации также происходит инстанцирование, а полученная в результате специализация заносится в базу данных вместо предыдущей.
3. В базе данных содержится подходящая не устаревшая специализация. Делать ничего не нужно.

Несмотря на концептуальную простоту описанной схемы, ее реализация связана с необходимостью решения некоторых практических задач.
>
> Далеко не просто поддерживать правильную взаимосвязь между структурными элементами базы данных, поскольку состояние исходного кода может меняться. Несмотря на то что не будет ошибкой принять третий случай за второй, это увеличит количество работы, которую необходимо выполнить компилятору (а значит, и время компиляции).
>
> Распространена ситуация, когда компиляторы выполняют параллельную компиляцию нескольких единиц трансляции, что также усложняет поддержку базы данных.

Несмотря на указанные трудности, схема может быть довольно эффективно реализована. Кроме того, в отличие, например, от жадного инстанцирования, которое может привести к большому количеству напрасно затраченной работы, при описанном решении практически отсутствуют патологические случаи, которые могли бы привести к излишней работе компилятора.

К сожалению, использование базы данных может также создать некоторые проблемы программисту. Причина большинства этих проблем заключается в том, что традиционная модель трансляции, унаследованная от большинства компиляторов С, больше не применима: в результате компиляции одной единицы трансляции теперь не создается отдельный объектный файл. Предположим, например, что нужно скомпоновать конечную программу. Для этого понадобится не только содержимое каждого объектного файла, связанного с различными единицами трансляции, но и тех объектных файлов, которые хранятся в базе данных. Аналогично в процессе создания бинарной библиотеки нужно убедиться в том, что инструмент, с помощью которого эта библиотека создается (обычно это компоновщик или архиватор), располагает сведениями из базы данных. По сути, любой инструмент, оперирующий с объектными файлами, должен иметь информацию о содержимом базы данных. Многие из этих проблем можно смягчить, не занося инстанцирование в базу данных, а размещая вместо этого их объектный код в объектный файл, вызвавший данное инстанцирование.

С библиотеками связана другая проблема. В одну и ту же библиотеку может быть упаковано несколько сгенерированных специализаций. При добавлении этой библиотеки в другой проект может понадобиться занести в базу данных нового проекта сведения об уже доступных инстанцированиях. Если этого не сделать и если в проекте создаются свои точки инстанцирования для специализаций, которые содержатся в библиотеке, инстанцирования могут дублироваться. Стратегия, которой следует придерживаться в такой ситуации, может состоять в применении той же технологии компоновки, что и при жадном инстанцировании: передать компоновщику сведения об имеющихся инстанцированиях, а затем избавиться от дубликатов (которые, однако, встречаются намного реже, чем в случае жадного инстанцирования). Другие варианты размещений исходных файлов, объектных файлов и библиотек могут вызвать новые проблемы, в частности отсутствие инстанцирований из-за того, что объектный код, содержащий нужное инстанцирование, не скомпонован с конечной исполняемой программой.

В конечном счете инстанцирование по запросу на рынке не выжило, и даже компилятор Sun теперь использует жадное инстанцирование.

## Итеративное инстанцирование

Первым компилятором, поддерживающим шаблоны C++, был `Cfront 3.0` — прямой потомок компилятора, разработанного Бьярне Страуструпом в процессе создания языка программирования C++. Одна из особенностей компилятора `Cfront`, ограничивающая его гибкость, заключалась в том, что он должен был обладать переносимостью на другие платформы. Это означает, что, во-первых, в качестве представления на всех целевых платформах используется язык С и, во-вторых, применяется локальный целевой компоновщик. В частности, при этом подразумевается, что компоновщик не способен обрабатывать шаблоны. Фактически компилятор `Cfront` генерировал инстанцирования шаблонов как обычные функции `С`, поэтому он должен был избегать повторных инстанцирований. Хотя исходная модель, на которой основан компилятор `Cfront`, отличалась от стандартной модели включения, можно добиться того, что используемая в этом компиляторе стратегия инстанцирования будет соответствовать модели включения. Таким образом, это первый компилятор, в котором было воплощено итеративное инстанцирование. Итерации компилятора `Cfront` описаны ниже.
1. Исходный код компилируется без инстанцирования каких бы то ни было связываемых специализаций.
2. Объектные файлы связываются с помощью предварительного компоновщика (prelinker).
3. Предварительный компоновщик вызывает компоновщик и анализирует сгенерированные сообщения об ошибках, чтобы определить, не вызваны ли они отсутствием инстанцирований; если причина ошибки именно в этом, предварительный компоновщик вызывает компилятор для обработки исходных файлов, содержащих необходимые определения шаблонов; при этом параметры компилятора настроены для генерирования отсутствующих инстанцирований.
4. Если сгенерированы какие-либо определения, повторяется пункт 3.

Повторение пункта 3 обусловлено тем, что на практике инстанцирование одного из подлежащих компоновке элементов может привести к необходимости инстанцировать шаблон в другом элементе, который еще не был обработан. Такой итеративный процесс в конечном счете сходится, и компоновщику удается создать завершенную программу.

Схема, положенная в основу исходного компилятора `Cfront`, обладает весьма серьезными недостатками.
>
> Время, затрачиваемое на создание исполняемого файла, увеличивается не только из-за работы предварительного компоновщика, но и за счет повторных компиляций и компоновок. Согласно отчетам некоторых пользователей систем, в основе которых находится компилятор `Cfront`, время создания исполняемых файлов возросло до “нескольких дней” по сравнению с тем, что раньше в альтернативных схемах это занимало “около часа”.
>
> Выдача сообщений об ошибках и предупреждений откладывается до этапа компоновки. Это особенно неприятно, когда компоновка занимает много времени и разработчику часами приходится ждать, пока будет обнаружена всего лишь опечатка в определении шаблона.
>
> Необходимо особо позаботиться о том, чтобы запомнить, где находится исходный код, содержащий то или иное определение (п. 1). В частности, компилятор `Cfront` использовал специальное хранилище, с помощью которого решались некоторые проблемы, что, по сути, напоминает использование базы данных при инстанцировании по запросу. Исходный компилятор `Cfront` не был приспособлен для поддержки параллельной компиляции.

Несмотря на перечисленные недостатки, принцип итерации в улучшенном виде был использован в двух системах компиляции, устранивших недостатки исходной реализации `Cfront`. Одна из них создана группой Edison Design Group (EDG), а вторая известна под названием HP аС++. На практике эти реализации работают довольно хорошо, и, хотя построение “с нуля” обычно занимает больше времени, чем альтернативные схемы, времена последующих построений вполне конкурентоспособны. Тем не менее итеративное инстанцирование используется только в относительно немногих компиляторах C++.

# Явное инстанцирование

Точку инстанцирования для специализации шаблона можно создать явным образом. Конструкция, с помощью которой это достигается, называется директивой явного инстанцирования (explicit instantiation directive). Синтаксически она состоит из ключевого слова `template`, за которым следует объявление инстанцируемой специализации. Например:
```c++
template<typename Т>
void f(Т)
{   }

// Четыре явных инстанцирования:
template void f<int>(int);
template void f<>(float);
template void f(long);
template void f(char);
```

Обратите внимание на то, что корректны все приведенные выше директивы инстанцирования. Аргументы шаблона могут быть выведены (см. #главу_15, “Вывод аргументов шаблона”).

Члены шаблонов классов также можно явно инстанцировать:
```c++
template<typename Т>
class S
{
	public:
		void f()
		{   }
};

template void S<int>::f();
template class S<void>;
```

Кроме того, можно явно инстанцировать все члены, входящие в состав специализации шаблона класса, путем явного инстанцирования специализации шаблона этого класса. Поскольку эти директивы явного инстанцирования гарантируют, что создается определение специализации именованного шаблона (или его членов), директивы явного инстанцирования более точно называть ***определениями явного инстанцирования*** (explicit instantiation definitions). Специализация явно инстанцируемого шаблона не должна быть явно специализированной и наоборот, потому что это будет означать, что два определения могут быть различными (нарушая правило одного определения).

## Ручное инстанцирование

Многие программисты на C++ замечали, что автоматическое инстанцирование шаблона отрицательно сказывается на времени построения. Это особенно верно в случае компиляторов, реализующих [[Инстанцирование в шаблонах#Жадное инстанцирование|жадное инстанцирование]], потому что одни и те же специализации шаблонов могут инстанцироваться и оптимизироваться во многих разных единицах трансляции.

Методика, применяемая для улучшения времени построения, состоит в ручном инстанцировании тех специализаций шаблонов, которые требуются программе, в единственном месте, и препятствовании инстанцированиям во всех других единицах трансляции. Один из переносимых способов обеспечить это препятствование — не предоставлять определение шаблона, за исключением единицы трансляции, где он инстанцируется явно. Например:
```c++
// ===== Единица трансляции 1:
template<typename Т> void f();  // Нет определения: предотвращает
								// инстанцирование в этой
								// единице трансляции
void g()
{
	f<int>();
}

// ==== Единица трансляции 2:
template<typename Т> void f()
{
	// Реализация
}

template void f<int>();         // Ручное инстанцирование

void g();

int main()
{
	g();
}
```

В первой единице трансляции компилятор не может видеть определение шаблона функции `f`, поэтому он не может и не будет выполнять инстанцирование `f<int>`. Вторая единица трансляции предоставляет определение `f<int>` через явное определение инстанцирования; без него программа не может быть скомпонована.

Ручное инстанцирование имеет явный недостаток: мы должны тщательно отслеживать инстанцируемые сущности. Для крупных проектов это быстро становится чрезмерным бременем, поэтому мы не рекомендуем применять этот способ. Мы работали над несколькими проектами, которые первоначально недооценили всю тяжесть такого подхода, и позже пришли к сожалению о принятом решение.

Однако ручное инстанцирование имеет также и несколько преимуществ, поскольку инстанцирование может быть настроено для потребностей конкретной программы. Очевидно, что при этом удается избежать накладных расходов, связанных с большими заголовками, так как они связаны с многократным инстанцированием одних и тех же шаблонов с одними и теми же аргументами в нескольких единицах трансляции. Кроме того, исходный код определения шаблона может поддерживаться скрытым, но тогда клиентской программой не могут быть созданы никакие дополнительные инстанцирования.

Часть бремени ручного инстанцирования может быть облегчена путем размещения определений шаблонов в третьем исходном файле, обычно с расширением `.tpp`. Для нашей функции `f` шаблон распадается на следующие части:
```c++
// ===== f.hpp:

template<typename Т> void f (); // Определения нет:
								// препятствует инстанцированию
								
// ==== f.tpp:
#include "f.hpp"

template<typename Т> void f()   // Определение
{
	// Реализация
}

// ===== f.cpp:
#include "f.tpp"

template void f<int>();         // Ручное инстанцирование
```

Такая структура обеспечивает определенную гибкость. Можно включить только файл `f.hpp`, чтобы получить объявление `f` без автоматического инстанцирования. Явное инстанцирование может быть при необходимости добавлено в `f.срр` вручную. Или, если ручное инстанцирование становится слишком обременительными, можно включать `f.tpp` для того, чтобы разрешить автоматическое инстанцирование.

## Объявления явного инстанцирования

Более целенаправленным подходом к ликвидации избыточных автоматических инстанцирований является использование объявления явного инстанцирования (explicit instantiation declaration), представляющего собой директиву явного инстанцирования, которой предшествует ключевое слово `extern`. Объявление явного инстанцирования в общем случае подавляет автоматическое инстанцирование специализации именованного шаблона, поскольку объявляет, что специализация именованного шаблона будет определена где-то в программе (с помощью определения явного инстанцирования). Мы говорим в общем случае, потому что имеется множество исключений.
>
> Встраиваемые функции все равно могут быть инстанцированы для того, чтобы их можно было встроить в код (но отдельный объектный код не генерируется).
> 
> Переменные с выведенными типами [[auto|auto]] или [[decltуре#decltype(auto) C++14|decltype (auto)]] и функции с выведенными возвращаемыми типами могут быть инстанцированы для того, чтобы определить их типы.
> 
> Переменные, значения которых используются как константные выражения, могут быть инстанцированы для вычисления их значений.
> 
> Переменные ссылочных типов могут быть инстанцированы для того, чтобы сущности, на которые они ссылаются, могли быть разрешены.
> 
> Шаблоны классов и шаблоны псевдонимов могут быть инстанцированы для того, чтобы проверить получающиеся в результате типы.

Используя объявления явного инстанцирования, мы можем предоставить определение шаблона для `f` в заголовке (`t.hpp`), а затем подавить автоматическое инстанцирование для часто используемых специализаций следующим образом:
```c++
// ==== t.hpp:

template<typename Т> void f()
{   }

extern template void f<int>{);     // Объявлен, но не определен
extern template void f<float>();   // Объявлен, но не определен

// ==== t.cpp:

template void f<int>();            // Определение
template void f<float>();          // Определение
```

Каждое объявление явного инстанцирования должно быть в паре с определением соответствующего явного инстанцирования, которое должно следовать за объявлением явного инстанцирования. Пропуск определения приведет к ошибке компоновщика.

Объявление явного инстанцирования может использоваться для ускорения компиляции или компоновки, когда во многих разных единицах трансляции часто используются определенные специализации. В отличие от ручного инстанцирования, при котором требуется вручную обновлять список определений явного инстанцирования всякий раз, когда требуется новая специализация, объявления явных инстанцирований могут быть введены в качестве оптимизации в любой точке. Однако преимущества во время компиляции могут оказаться не столь существенными, как при ручном инстанцировании, как потому что некоторые избыточные автоматические инстанцирования, скорее всего, будут встречаться, так и потому, что определения шаблонов по-прежнему анализируются как часть заголовочного файла.

# Инструкции if времени компиляции

в C++17 добавлен новый вид инструкций, который оказался чрезвычайно полезным при написании шаблонов: [[Программирование времени компиляции#Инструкция if времени компиляции|if времени компиляции]]. В нем также вводятся новые тонкости в процесс инстанцирования.

Приведенный далее пример иллюстрирует работу `if` времени компиляции:
```c++
template<typename Т> bool f(Т р)
{
	if constexpr(sizeof(Т) <= sizeof(long long))
	{
		return p > 0;
	}
	else
	{
		return p.compare(0) > 0;
	}
};

bool g(int n)
{
	return f(n); // OK
}
```

`if` времени компиляции представляет собой инструкцию [[if|if]], в которой за ключевым словом `if` непосредственно следует (как в приведенном примере) ключевое слово [[constexpr|constexpr]]. Следующее далее условие в скобках должно иметь константное логическое значение (разрешены неявные преобразования в `bool`). Таким образом, компилятору известно, какая из ветвей будет выбрана, а какая — отброшена. Особенно интересно, что во время инстанцирования шаблонов (включая обобщенные лямбда-выражения) отбрасываемые ветви не инстанцируются. Это необходимо, чтобы наш пример был корректным: мы выполняем инстанцирование `f(Т)` с `T=int`, что означает, что ветвь `else` отбрасывается. Если бы она не отбрасывалась, то она была бы инстанцирована, и мы бы получили ошибку в выражении `р.compare(0)` (которое является ошибочным, когда `р` представляет собой простое целое число).

До С++17 и его инструкции константного `if`, чтобы избежать данной ошибки при получении того же результата, требовалась явная специализация шаблона или перегрузка (см. #главу_16, “Специализация и перегрузка”).

Представленный выше пример может быть реализован на C++14 следующим образом:
```c++
template<bool b> struct Dispatch // Инстанцируется при Ь, равном
{                                // false, из-за наличия
	static bool f(T р)           // специализации для true
	{
		return р.compare(0) > 0;
	}
};

template<> struct Dispatch<true>
{
	static bool f(T p)
	{
		return p > 0;
	}
};

template<typename T> bool f(T p)
{
	return Dispatch < sizeof(T) <= sizeof(long long) > ::f(p);
}

bool g(int n)
{
	return f(n);                 //OK
};
```

Очевидно, что ***константный if*** является альтернативным выражением нашего намерения, причем выражением гораздо более четким и лаконичным. Однако он требует от реализаций языка уточнения единицы инстанцирования: в то время как ранее определения функций всегда инстанцировались как единое целое, теперь должна быть обеспечена возможность подавления инстанцирования их частей.

Еще одним удобным применением ***константного if*** является выражение рекурсии, необходимой для обработки пакетов параметров функции. Вспомним
пример.
```c++
template<typename Head, typename... Remainder>
void f(Head&& h, Remainder&&... r)
{
	doSomething(std::forward<Head>(h));
	
	if constexpr (sizeof...(r) != 0)
	{
		// Рекурсивная обработка остатка
		// (прямая передача аргументов):
		f(std::forward<Remainder>(r)...);
	}
}
```

Без инструкции `if constexpr` нам бы потребовалась дополнительная перегрузка шаблона `f()`, чтобы обеспечить завершение рекурсии.

Даже в контексте, не относящемся к шаблонам, `if constexpr` имеет несколько уникальное действие:
```c++
void h();
void g()
{
	if constexpr(sizeof(int) == 1)
	{
		h();
	)
}
```

На большинстве платформ условие в `g()` дает значение `false`, и поэтому вызов `h()` игнорируется. Как следствие, функции `h()` не обязательно быть определенной вообще (конечно, если она не используется в другом месте). Если в этом примере опустить ключевое слово [[constexpr|constexpr]], отсутствие определения `h()` будет часто приводить к ошибке времени компоновки.

# В стандартной библиотеке

Стандартная библиотека C++ включает ряд шаблонов, которые широко используются только с несколькими основными типами. Например, шаблон класса `std::basic_string` наиболее часто используется с `char` (потому [[string#std string|std::string]] и является псевдонимом типа `std::basic_string<char>`) или [[wchar_t|wchar_t]], хотя можно инстанцировать его и с другими символьными типами. Поэтому в реализациях стандартной библиотеки часто вводятся объявления явного инстанцирования для этих распространенных случаев. Например:
```c++
namespace std
{
	template<typename charT, typename traits = char_traits<charT>,
			 typename Allocator = allocator<charT>>
	class basic_string
	{
		...
	};
	
	extern template class basic_string<char>;
	extern template class basic_string<wchar_t>;
}
```

Исходные файлы реализации стандартной библиотеки будут содержать соответствующие определения явного инстанцирования, так что эти общие реализации могут использоваться всеми пользователями стандартной библиотеки. Часто подобные явные реализации имеются для различных классов потоков, например `basic_iostream`, `basic_istream` и так далее.

