
[[#Инстанцирование|Инстанцирование]] 14
1. [[#Инстанцирование по требованию|Инстанцирование по требованию]] 14.1
2. [[#Отложенное инстанцирование|Отложенное инстанцирование]] 14.2
	1. [[#Частичное и полное инстанцирование|Частичное и полное инстанцирование]] 14.2.1
	2. [[#Инстанцированные компоненты|Инстанцированные компоненты]] 14.2.2
3. [[#Модель инстанцирования С++|Модель инстанцирования С++]] 14.3
	1. [[#Двухфазный поиск|Двухфазный поиск]] 14.3.1
	2. [[#Точки инстанцирования|Точки инстанцирования]] 14.3.2
	3. [[#Модель включения|Модель включения]] 14.3.3
4. [[#Схемы реализации|Схемы реализации]] 14.4




# Инстанцирование

Инстанцирование (instantiation) шаблонов — это процесс, при котором на основе обобщенного определения шаблонов генерируются типы и функции. В C++ концепция инстанцирования шаблонов играет фундаментальную роль, однако она несколько запутана. Одна из основных причин этой запутанности состоит в том, что определения генерируемых шаблоном элементов не сосредоточены в одном месте исходного кода. Местонахождение определения шаблона, его использования и определения аргументов — все это играет роль.

В данной главе объясняется, как организовать исходный код для надлежащего использования шаблонов. Кроме того, здесь представлены различные методы, которые используются в наиболее популярных компиляторах C++ для инстанцирования шаблонов. Хотя все эти методы должны быть семантически эквивалентны, полезно понимать основные принципы, лежащие в основе стратегии инстанцирования, которой придерживается ваш компилятор. С одной стороны, каждый механизм инстанцирования обладает своим набором мелких особенностей, с другой — он подвергается влиянию конечных спецификаций языка C++.

# Инстанцирование по требованию

Когда компилятор C++ встречает использование специализации шаблона, он создает ее, подставляя вместо параметров шаблона необходимые аргументы. Эти действия выполняются автоматически и не требуют каких бы то ни было указаний от пользовательского кода (или от определения шаблона). Это инстанцирование по требованию ставит шаблоны C++ особняком по отношению к ряду подобных функциональных возможностей в других ранних компилируемых языках (наподобие Ada или Eiffel; некоторые из этих языков требуют явных директив инстанцирования, в то время как другие используют механизмы диспетчеризации времени выполнения для полного устранения процесса инстанцирования). Это инстанцирование шаблона по требованию называют неявным (`implicit`) или автоматическим (`automatic`) инстанцированием. Шаблоны C++ стоят особняком по отношению к подобным возможностям других компилируемых языков программирования.

При инстанцировании по требованию компилятор обычно нуждается в доступе к полному определению (другими словами, не только к объявлению) шаблона и некоторых его членов в точке, где этот шаблон используется. Рассмотрим небольшой исходный текст.
```c++
template<typename Т> class С;    // #1 Только объявление

C<int>* р = 0;        // #2 Определение C<int> не требуется

template<typename Т>
class С
{
	public:
		void f();     // #3 Объявление члена
};                    // #4 Определение шаблона класса завершено

void g(C<int>& с)     // #5 Использование только объявления шаблона класса
{
	c.f();            // #6 Использование определения шаблона класса
}                     // требует определения С::f() в данной
					  // единице трансляции
template<typename Т>
void С<Т>::f()        // Требуемое объявление для #6
{
}
```

В точке `#1` исходного текста доступно только объявление шаблона, но не его определение (такое объявление иногда называют предварительным объявлением (forward declaration)). Как и для обычных классов, определение шаблона класса не обязано находиться в области видимости для объявления указателей или ссылок на данный тип (как это сделано в точке `#2`). Например, для указания типа, которому принадлежит параметр функции `g()`, не требуется полное определение шаблона `С`. Однако, как только компоненту понадобится информация о размере специализации шаблона, или при доступе к члену такой специализации, нужно, чтобы определение шаблона класса находилось полностью в области видимости. Этим объясняется, что в точке `#6` исходного кода должно быть доступно определение шаблона класса; в противном случае компилятор не в состоянии проверить наличие и доступность членов (ни закрытых, ни защищенных). Кроме того, необходимо также определение функции-члена, поскольку вызов в точке `#6` требует существования `C<int>::f()`.

Приведем еще одно выражение, требующее инстанцирования предыдущего шаблона класса, чтобы узнать размер конструкции `C<void>`:
```c++
C<void>* р = new C<void>;
```

В данном случае инстанцирование необходимо для того, чтобы компилятор мог определить размер объекта `C<void>`, который необходим выражению `new` для выяснения, какое количество памяти следует выделить. Возможно, вы заметили, что для данного конкретного шаблона тип аргумента `X`, который подставляется вместо параметра `Т`, не влияет на размер шаблона, поскольку в любом случае класс `С<Х>` будет пустым. Однако от компилятора не требуется избежать инстанцирования путем анализа определения шаблона (и все компиляторы на практике выполняют инстанцирование). Кроме того, в данном примере инстанцирование необходимо для того, чтобы определить, доступен ли конструктор по умолчанию для класса `C<void>`, а также убедиться, что в этом классе не объявлены операторы-члены `new` или [[delete|delete]].

Необходимость доступа к члену шаблона класса не всегда явно видна в исходном коде. Например, для разрешения перегрузки в C++ требуется, чтобы типы классов, которым принадлежат параметры функции-кандидата, находились в области видимости.
```c++
template<typename Т>
class С
{
	public:
		C(int); // Конструктор, который может быть вызван с одним
};              // параметром, может использоваться для неявных
				// преобразований
void candidate(C<double>);  // #1
void candidate(int) { }     // #2

int main()
{
	candidate(42);          // Могут быть вызваны обе функции,
}                           // объявления которых приведены выше
```

Вызов функции `candidate(42)` будет разрешен с помощью объявления `#2`. Однако объявление `#1` также может быть инстанцировано, чтобы проверить, подходит ли оно для разрешения вызова (благодаря тому, что конструктор с одним аргументом способен неявно преобразовать аргумент `42` в [[значение#r-значения|r-значение]] типа `C<double>`). Заметим, что компилятор может (но не обязан) выполнить инстанцирование, даже если способен обойтись при разрешении вызова и без него (в приведенном примере именно так и происходит, поскольку предпочесть неявное преобразование типов их точному совпадению невозможно). Заметим также, что инстанцирование `C<double>` может привести к ошибке (что, возможно, покажется удивительным)

# Отложенное инстанцирование

Приведенные к настоящему моменту примеры иллюстрируют требования, которые существенно не отличаются от требований при использовании обычных, не шаблонных классов. Во многих случаях нужно, чтобы [[Основные термины в области шаблонов#Полные и неполные типы|класс был полным, или завершенным]] (complete). В случае шаблона компилятор генерирует полное определение класса из определения шаблона класса.

В связи с этим возникает вопрос: какая часть шаблона инстанцируется? Можно было бы ответить так: ровно столько, сколько необходимо. Другими словами, при инстанцировании шаблонов компилятору следует быть максимально “ленивым”. Рассмотрим, что это означает.

## Частичное и полное инстанцирование

Как мы видели, иногда компилятору не требуется подстановка полного определения шаблона класса или функции. Например:
```c++
template<typename Т> Т f(Т р)
{
	return 2 * р;
}

decltype(f(2)) х = 2;
```

В этом примере тип, указанный как `decltype(f(2))`, не требует полного инстанцирования шаблона функции `f()`. Поэтому компилятору разрешена только подстановка объявления `f()`, но не ее “тела”. Иногда это называют частичным инстанцированием.

Аналогично, если экземпляр шаблона класса передается без необходимости иметь полный тип для этого экземпляра, компилятор не должен выполнять полное инстанцирование этого экземпляра шаблона класса. Рассмотрим следующий пример:
```c++
template<typename Т> class Q
{
	using Type = typename T::Type;
};

Q<int>* p = 0;           // OK: тело Q<int> не подставляется
```

Здесь полное инстанцирование `Q<int>` приводило бы к ошибке, поскольку `Т::Туре` не имеет смысла, когда `Т` представляет собой `int`. Но, поскольку `Q<int>` в данном примере не обязан быть полным типом, полное инстанцирование не выполняется, и код оказывается корректным (хотя и подозрительным).

У шаблонов переменных также различаются “полное” и “частичное” инстанцирование. Это иллюстрирует следующий пример:
```c++
template<typename Т> Т v = Т::default_value();
decltype(v<int>) s;      // OK: инициализатор v<int> не инстанцирован
```

Полное инстанцирование `v<int>` могло бы вызвать ошибку, но оно не является необходимым, если нам нужен только тип экземпляра шаблона переменной.

Интересно, что шаблоны псевдонимов этим различием не обладают: не существует двух способов их подстановки.

В C++, когда речь идет об “инстанцировании шаблона” без уточнения, идет речь о полном или частичном инстанцировании, подразумевается первое. То есть инстанцирование по умолчанию является полным инстанцированием.

## Инстанцированные компоненты

В процессе неявного (полного) инстанцирования шаблона класса инстанцируются все объявления его членов, но не соответствующие определения (т.е. члены инстанцируются частично). Из этого правила есть несколько исключений. Во-первых, если в шаблоне класса содержится безымянное объединение, члены определения этого объединения также инстанцируются. Другое исключение связано с виртуальными функциями-членами. При инстанцировании шаблона класса определения этих функций могут как инстанцироваться, так и нет. Во многих реализациях эти определения будут инстанцироваться в силу того, что внутренняя структура, обеспечивающая механизм виртуальных вызовов, требует, чтобы виртуальные функции существовали в виде объектов, доступных для связывания.

При инстанцировании шаблонов аргументы функции по умолчанию рассматриваются отдельно. В частности, они не инстанцируются, если только не вызывается именно та функция (или функция-член), в которой используются эти аргументы по умолчанию. Они не инстанцируются и в том случае, когда при вызове функции аргументы указываются явным образом, т.е. аргументы по умолчанию не используются.

Аналогично не инстанцируются спецификации исключений и инициализаторы членов по умолчанию, если они не требуются.

Приведем пример, иллюстрирующий все упомянутые случаи:
```c++
template<typename T>
class Safe
{
};

template<int N>
class Danger
{
	int arr[N];                     // OK, хотя некорректно при N<=0
};

template<typename T, int N>
class Tricky
{
	public:
		void noBodyHere(Safe<T>=3); // OK до тех пор, пока использование
									// значения по умолчанию не приведет
									//к ошибке
		void inclass()
		{
			Danger<N> noBoomYet;    // ОК до тех пор, пока inclass()
		}                           // не используется с N <= 0

		struct Nested
		{
			Danger<N> pfew;         // ОК до тех пор, пока Nested
		};                          // не используется с N<=0

		union                       // Благодаря безымянному объединению:
		{
			Danger<N> anonymous;    // OK до тех пор, пока Tricky не
			int align;              // инстанцируется с N<=0
		};

		void unsafe(T(*p)[N]);      // ОК до тех пор, пока Tricky не
									// инстанцируется с N<=0
		void error()
		{
			Danger < -1 > boom;     // Всегда ошибка (которую обнаруживают
		}                           // не все компиляторы)
};
```

Соответствующий стандарту компилятор C++ будет рассматривать эти определения шаблонов, чтобы проверить их синтаксис и общие семантические ограничения. При проверке ограничений, включающих параметры шаблонов, компилятор предполагает, что “все обстоит наилучшим образом”. Например, параметр `N` в члене `Danger::arr` может быть равным нулю или отрицательным (что привело бы к ошибке), однако предполагается, что это не так. Определения `inclass()`, `struct Nested` и безымянного объединения, таким образом, проблем не вызывают.

По той же причине объявление члена `unsafe (Т(*р)[N])` тоже не представляет проблемы до тех пор, пока вместо параметра шаблона `N` не подставляется конкретное значение.

Спецификация аргумента по умолчанию (`=3`) в объявлении члена `noBodyHere()` подозрительна, поскольку шаблон `Safe<>` не является инициализируемым целочисленным значением, однако предполагается, что аргумент по умолчанию для обобщенного определения `Safe<T>` не потребуется, либо что `Safe<T>` будет специализирован (см. #главу_16, “Специализация и перегрузка”) таким образом, что будет допускать инициализацию целочисленным значением. Однако определение функции-члена `error()` является ошибкой, даже когда шаблон не инстанцирован, поскольку использование `Danger<-1>` требует завершенного определения класса `Danger<-1>`, а генерация этого класса приводит к попытке определить массив с отрицательным размером. Интересно, что в то время как стандарт ясно указывает, что этот код некорректен, он также позволяет компилятору не диагностировать ошибку, если экземпляр шаблона на самом деле не используется. Следовательно, поскольку `Tricky<T,N>::error()` не используется ни для каких конкретных `Т` и `N`, компилятор не обязан выводить сообщение об ошибке в данном случае. Например, GCC и Visual C++ на момент написания данной книги эту ошибку не диагностировали.

Проанализируем теперь, что произойдет, если добавить следующее определение:
```c++
Tricky<int, -1> inst;
```

Это заставит компилятор выполнить (полное) инстанцирование `Tricky<int,-1>`, подставляя `int` вместо `Т` и `-1` вместо `N` в определении шаблона `Tricky<>`. Необходимы не все определения членов, но конструктор по умолчанию и деструктор (оба в данном случае объявляемые неявно) определенно вызываются, а следовательно, их определения должны быть так или иначе доступны (что так и есть в нашем примере, поскольку они генерируются неявно). Как пояснено выше, члены `Tricky<int, -1>` частично инстанцированы (то есть их объявления заменены): этот процесс потенциально может привести к ошибкам. Например, объявление `unsafe(Т(*р)[N])` создает тип массива с отрицательным количеством элементов, что является ошибкой. Аналогично член `anonymous` теперь вызывает ошибку, потому что тип `Danger<-1>` не может быть завершен. Напротив, определения членов `inclass()` и `struct Nested` еще не инстанцируются, и, таким образом, никаких ошибок от их необходимости для полного типа `Danger<-1>` (который содержит определение недопустимого массива, как мы уже упоминали ранее), не возникает.

Как уже указано, при инстанцировании шаблона на практике должны также предоставляться определения виртуальных членов. В противном случае могут возникнуть ошибки компоновки. Например:
```c++
template<typename Т>
class VirtualClass
{
	public:
		virtual ~VirtualClass(){}
		virtual T vmem(); // Вероятна ошибка при инстанцировании
							// без определения
};

int main()
{
	VirtualClass<int> inst;
}
```

Наконец, замечание об `operator->`. Рассмотрим код:
```c++
template<typename Т>
class С
{
	public:
		Т operator->();
};
```

Обычно `operator->` должен возвращать тип указателя или тип другого класса, к которому применим `operator->`. Это свидетельствует о том, что завершение `C<int>` вызовет ошибку, поскольку этот тип объявляет возвращаемый тип `operator->` как `int`. Поскольку определения такого рода основываются на некоторых определениях “естественных” шаблонов классов, правила языка сделаны более гибкими. От пользовательского оператора `operator->`, требуется возврат типа, к которому применим другой (например, встроенный) `operator->`, только если он действительно выбран процедурой разрешения перегрузки. Это утверждение остается истинным и тогда, когда оно не относится к шаблонам (хотя в таком контексте от него меньше пользы). Таким образом, здесь объявление не вызывает ошибки, даже несмотря на то, что в качестве возвращаемого типа подставляется тип `int`.

# Модель инстанцирования С++

Инстанцирование шаблона — это процесс, в результате которого из определенного шаблона путем подстановки его параметров генерируется обычный тип, функция или переменная. На первый взгляд может показаться, что здесь все довольно просто, однако на практике этот процесс обрастает множеством деталей.

## Двухфазный поиск

В главе [[Имена в шаблонах|“Имена в шаблонах”]], мы видели, что зависимые имена нельзя разрешить при синтаксическом анализе шаблонов. Поэтому в месте инстанцирования шаблона его определение еще раз просматривается компилятором. Однако независимые имена можно обработать при первом просмотре шаблона, выявив при этом многие ошибки. В результате мы приходим к концепции двухфазного поиска (two-phase lookup): первая фаза — синтаксический анализ шаблона, вторая — его инстанцирование.
1. На первом этапе, во время синтаксического анализа шаблона, обрабатываются независимые имена; на этой стадии анализ шаблона проводится с помощью правил обычного поиска (ordinary lookup rules), а также правил поиска, зависящего от аргументов (ADL), если они применимы в данном конкретном случае. Неквалифицированные зависимые имена (которые являются зависимыми, как зависимы имена функций при вызове с зависимыми аргументами) тоже просматриваются с помощью правил обычного поиска. Однако результат этого поиска не рассматривается как завершенный до тех пор, пока в процессе инстанцирования шаблона не будет проведен дополнительный поиск.
2. На втором этапе, выполняющемся при инстанцировании шаблона в точке инстанцирования (point of instantiation — POI), анализируются зависимые квалифицированные имена (в которых параметры шаблонов заменяются аргументами шаблонов для данного конкретного инстанцирования). Кроме того, выполняется дополнительный ADL для зависимых неквалифицированных имен, поиск которых на первом этапе выполнялся с помощью правил обычного поиска.

Для неквалифицированных зависимых имен первоначальный обычный поиск — пока еще неполный — используется для определения, является ли имя шаблоном. Рассмотрим следующий пример:
```c++
namespace N
{
	template<typename> void g(){}
	enum E { e };
}

template<typename> void f() {}

template<typename T> void h(T P)
{
	f<int>(p);     // #1
	g<int>(p);     // #2 Ошибка
}

int main()
{
	h(N::e);       // Вызов шаблона h с T = N::Е
}
```

В строке `#1`, увидев имя `f`, за которым следует `<`, компилятор должен решить, является ли `“<”` угловой скобкой или знаком “меньше”. Это зависит от того, известно ли, что имя `f` является шаблоном или нет; в нашем случае обычный поиск находит объявление имени `f`, которое действительно является шаблоном, так что синтаксический анализ успешно выполняется, считая `<` угловой скобкой.

Строка `#2`, однако, приводит к ошибке, потому что с помощью обычного поиска шаблон `g` не обнаруживается. Таким образом, `<` рассматривается как знак “меньше”, который в этом коде является синтаксической ошибкой. Если бы мы могли обойти эту проблему, то в конечном итоге нашли бы шаблон `N::g` с использованием ADL при инстанцировании `h` для `T=N::Е` (так как `N` — это пространство имен, связанное с `Е`), но все это невозможно до тех пор, пока мы не проанализируем успешно обобщенное определение `h`.

## Точки инстанцирования

Как уже было показано, в исходном коде, использующем шаблон, есть места, в которых компилятор C++ должен иметь доступ к объявлению или определению этого шаблона. ***Точка инстанцирования*** (point of instantiation — POI) создается в том случае, когда некоторая конструкция исходного кода ссылается на специализацию шаблона таким образом, что для создания этой специализации требуется инстанцирование определения соответствующего шаблона. Точка инстанцирования — это место кода, в которое можно вставить шаблон с подставленными аргументами. Например:
```c++
class MyInt
{
	public:
		MyInt(int i);
};

MyInt operator -(MyInt const&);

bool operator >(MyInt const&, MyInt const&);

using Int = MyInt;

template<typename T>
void f(T i)
{
	if(i > 0)
	{
		g(-i);
	}
}
										// #1
void g(Int)
{
										// #2
	f<Int>(42);                         // Точка вызова
										// #3
}
										// #4
```

Когда компилятор C++ встречает вызов шаблона функции `f<Int>(42)`, он знает, что нужно инстанцировать шаблон `f`, подставив вместо параметра `Т` тип `MyInt`. В результате создается точка инстанцирования. Точки `#2` и `#3` находятся совсем рядом с местом вызова, однако они не могут быть точками инстанцирования, потому что в языке C++ в этих точках нельзя вставить определение `::f<Int>(Int)`. Главное различие между точками `#1` и `#4` заключается в том, что в точке `#4` функция `g(Int)` находится в области видимости, поэтому становится разрешимым вызов `g(-i)`. Если бы точка `#1` была точкой инстанцирования, то этот вызов нельзя было бы разрешить, поскольку в этой точке функция `g(Int)` еще не видна. К счастью, в C++ определяется, что точка инстанцирования для ссылки на специализацию шаблона функции должна находиться сразу после ближайшего объявления или определения области видимости пространства имен, в котором содержится эта ссылка. В нашем примере это точка `#4`.

Возможно, вас удивит, что в этом примере вместо обычного типа `int` принимает участие тип `Mylnt`. Дело в том, что на втором этапе поиска имен, который проводится в точке инстанцирования, используется только ADL. Поскольку с типом `int` не связано никакое пространство имен, то при его применении поиск в точке инстанцирования не проводился бы и функция `g` не была бы обнаружена. Следовательно, если мы заменим объявление псевдонима типа `Int` следующим:
```c++
using Int = int;
```

то код из предыдущего примера перестанет компилироваться. Приведенный далее пример страдает от подобной проблемы:
```c++
template<typename Т>
void f1(Т х)
{
	g1(х);                      // #1
}

void g1(int)
{

}

int main()
{
	f1(7);                      // Ошибка: g1 не найдена!
}
								// #2 Точка инстанцирования f1<int>(int)
```

Вызов `f1(7)` создает точку инстанцирования для `f1<int>(int)` сразу за `main()` в точке `#2`. В этом инстанцировании ключевым вопросом является поиск функции `g1`. Когда определение шаблона `f1` встречается впервые, отмечается, что неквалифицированное имя `g1` является зависимым, поскольку это имя функции в вызове функции с зависимыми аргументами (тип аргумента `х` зависит от параметра шаблона `Т`). Таким образом, `g1` ищется в точке `#1` с помощью правил обычного поиска; однако `g1` в этот момент не является видимой. В точке `#2`, точке инстанцирования, функция ищется снова в связанных пространствах имен и классах, но тип аргумента является `int`, и он не имеет связанных пространств имен или классов. Таким образом, `g1` никогда не будет найдена, несмотря даже на то, что обычный поиск в точке инстанцирования нашел бы `g1`.

Точка инстанцирования для шаблонов переменных обрабатывается аналогично обработке шаблонов функций.

Для специализаций шаблонов классов ситуация иная, как иллюстрирует следующий пример:
```c++
template<typename Т>
class S
{
	public:
		Т m;
};
											// #1
unsigned long h()
{
											// #2
	return (unsigned long)sizeof(S<int>);
											// #3
}
											// #4
```

И вновь точки области видимости функции `#2` и `#3` не могут быть точками инстанцирования, потому что определение класса `S<int>` с областью видимости пространства имен не может в них находиться (шаблоны в общем случае не могут находиться в области видимости функции). Если следовать правилу для экземпляров шаблона функции, точка инстанцирования будет в `#4`, но тогда недопустимо выражение `sizeof(S<int>)`, потому что размер `S<int>` не может быть определен, пока не будет достигнута точка `#4`. Таким образом, точка инстанцирования для ссылки на сгенерированный экземпляр класса определяется как точка непосредственно перед ближайшим объявлением или определением области видимости пространства имен, содержащей ссылку на этот экземпляр. В нашем примере это точка `#1`.

Когда шаблон в действительности инстанцируется, может появиться необходимость в дополнительных инстанцированиях. Рассмотрим небольшой пример:
```c++
template<typename Т>
class S
{
	public:
		using I = int;
};

									// #1
template<typename T>
void f()
{
	S<char>::I var1 = 41;
	typename S<T>::I var2 = 42;
}

int main()
{
	f<double>();
}
									// #2: #2a, #2б
```

Нашим предыдущим рассмотрением уже установлено, что точка инстанцирования для `f<double>()` находится в точке `#2`. Шаблон функции `f()` также обращается к специализации класса `S<char>` с точкой инстанцирования, которая, таким образом, находится в точке `#1`. Он обращается также к `S<T>`, но, поскольку он до сих пор остается зависимым, мы в действительности не можем инстанцировать его в этой точке. Однако если мы инстанцируем `f<double> ()` в точке `#2`, то заметим, что нам также необходимо инстанцировать определение `S<double>`. Такие вторичные, или переходные, точки инстанцирования определены несколько иначе. Для шаблонов функций вторичные точки инстанцирования в точности те же, что и первичные точки инстанцирования. Для классов вторичная точка инстанцирования непосредственно предшествует (в ближайшей охватывающей области видимости пространства имен) первичной точке инстанцирования. В нашем примере это означает, что точка инстанцирования `f<double>()` может быть помещена в точке `#2б`, а прямо перед ней — в точке `#2а` — находится вторичная точка инстанцирования для `S<double>`. Обратите внимание на отличие описанной ситуации от точки инстанцирования для `S<char>`.

Единица трансляции часто содержит несколько точек инстанцирования для одного и того же экземпляра. Для экземпляров шаблона класса в каждой единице трансляции сохраняется только первая точка инстанцирования, а последующие игнорируются (они не рассматриваются в действительности как точки инстанцирования). Для экземпляров шаблонов функций и переменных все точки инстанцирования сохраняются. В любом случае правило одного определения требует, чтобы инстанцирования, происходящие в любой из сохраненных точек инстанцирования, были эквивалентны, но компилятор C++ не обязан проверять и диагностировать нарушения этого правила. Это позволяет компилятору C++ выбрать только одну точку инстанцирования шаблона, не являющегося шаблоном класса, для выполнения фактического инстанцирования без беспокойства о том, что другая точка инстанцирования может привести к другому инстанцированию, отличному от данного.

На практике большинство компиляторов откладывают фактическое инстанцирование большинства шаблонов функций до конца единицы трансляции. Некоторые инстанцирования не могут быть отложены, включая случаи, где инстанцирование необходимо для определения выводимого возвращаемого типа (см. #разделы_15_10_1 и #15_10_4), и случаи, когда функция является [[constexpr|constexpr-функцией]] и должна вычисляться для получения константного результата. Некоторые компиляторы инстанцируют встраиваемые функции при первом использовании для обеспечения правильного встраивания. Это фактически перемещает точки инстанцирования соответствующих специализаций шаблонов в конец единицы трансляции, который в стандарте C++ разрешается использовать как альтернативную точку инстанцирования.

## Модель включения

Где бы ни находилась точка инстанцирования, в этом месте каким-то образом должен быть обеспечен доступ к соответствующему шаблону. Для специализации класса это означает, что определение шаблона класса должно быть видимым в точке, которая находится раньше в данной единице трансляции. Для точек инстанцирования шаблонов функций и переменных (а также функций-членов и статических членов-данных шаблонов классов) это тоже необходимо. Обычно определения шаблонов просто добавляются в заголовочные файлы, которые с помощью директивы `#include` включаются в единицу трансляции, даже когда они представляют собой шаблоны, не являющиеся типами. Такая модель, применяемая к определениям шаблонов, называется моделью включения (inclusion model) и представляет собой единственную автоматическую модель исходных текстов для шаблонов, поддерживаемую текущим стандартом C++.

Хотя модель включения поощряет программистов размещать все определения шаблонов в заголовочных файлах, чтобы они были доступны и удовлетворяли любым точкам инстанцирования, которые могут возникнуть, можно явным образом управлять инстанцированиями с использованием ***объявлений явного инстанцирования*** (explicit instantiation declarations) и ***определений явного инстанцирования*** (explicit instantiation definitions) (см. #раздел_14_5). Это технически не тривиально, так что большую часть времени программисты предпочитают полагаться на механизм автоматического инстанцирования. Одной из задач реализации с автоматической схемой является возможность иметь точки инстанцирования для одной и той же специализации шаблона функции или переменной (или одной и той же функции-члена или статических членов-данных экземпляра шаблона класса) в нескольких единицах трансляции. Далее мы обсудим подходы к этой проблеме.

# Схемы реализации





























