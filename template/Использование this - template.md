
# Использование this->

Для шаблонов классов, имеющих базовые классы, которые зависят от параметров шаблона, использование имени `х` само по себе не всегда эквивалентно применению `this->x`, даже если член `х` является наследуемым. Например:
```c++
template<typename Т>
class Base
{
	public:
		void bar();
};

template<typename T>
class Derived : Base<T>
{
	public:
		void foo()
		{
			bar();           // Вызов внешней bar() или ошибка
		}
};
```

В этом примере при разрешении имени `bar` в теле `foo()` никогда не рассматривается функция `bar()`, определенная в классе `Base`. Следовательно, либо будет получено сообщение об ошибке, либо будет вызвана другая функция `bar()` (например, глобальная функция `bar()` ).

Более подробно этот вопрос рассматривается в [[Имена в шаблонах#Зависимые базовые классы|Зависимые базовые классы]]. А пока что рекомендуем использовать следующее эмпирическое правило: всегда необходимо полностью квалифицировать любое имя, объявленное в базовом классе, который каким-либо образом зависит от параметра шаблона. Для этого можно использовать конструкции `this->` или `Base<T>::`.

