
# Шаблоны-члены

Члены классов тоже могут быть шаблонами. Это справедливо как для вложенных классов, так и для функций-членов. Применение и преимущества такой возможности можно еще раз продемонстрировать на примере шаблона класса `Stack<>`. Обычно стеки можно присваивать друг другу только в том случае, если они имеют одинаковый тип, что предполагает одинаковый тип их элементов. Однако стеку невозможно присвоить стек с элементами любого другого типа, даже если для типов элементов определено неявное преобразование типов:
```c++
Stack<int> intStack1, intStack2;        // Стеки для int
Stack<float> floatStack;                // Стек для float

intStackl = intStack2;                  // OK: стеки имеют одинаковые типы
floatStack = intStack1;                 // Ошибка: разные типы стеков
```

Оператор присваивания по умолчанию требует, чтобы с обеих сторон оператора использовался один и тот же тип, но если типы элементов у стеков различны, то это не так.

Однако если определить оператор присваивания в виде шаблона, то присваивание стеков с элементами, для которых определено соответствующее преобразование типов, станет возможным. Для этого необходимо объявить `Stack<>`, как показано ниже.
```c++
template<typename Т>
class Stack
{
	private:
		std::deque<T> elems;   // Элементы

	public:
		void push(T const&);   // Добавление элементов в стек
		void pop ();           // Снятие со стека
		T consts top() const;  // Возврат верхнего элемента
		
		bool empty() const     // Проверка пустоты стека
		{
			return elems.empty();
		}

		// Присваивание стека с элементами типа Т2
		template<typename Т2>
		Stacks operator= (Stack<T2> const&);
};
```

Были сделаны два изменения.
1. Добавлено объявление оператора присваивания для стеков с элементами другого типа Т2.
2. Теперь в качестве внутреннего контейнера для элементов стека используется дек [[deque|std::deque<>]]. Это следствие реализации нового оператора присваивания.

Реализация нового оператора присваивания показана ниже.
```c++
template<typename T>
template<typename T2>
Stack<T>& Stack<T>::operator= (Stack<T2> const& op2)
{
	Stack<T2> tmp(op2);    // Создание копии присваиваемого стека
	elems.clear();         // Удаление существующих элементов

	while (!tmp.empty()) // Копирование всех элементов
	{
		elems.push_front(tmp.top());
		tmp.pop();
	}
	
	return *this;
}
```

Прежде всего посмотрим на синтаксис определения шаблона-члена. Внутри шаблона с параметром `Т` определяется внутренний шаблон с параметром `Т2`:
```c++
template<typename Т>
template<typename Т2>
```

Казалось бы, в теле функции-члена можно просто обращаться ко всем необходимым данным присваиваемого стека `ор2`. Однако этот стек имеет другой тип (при инстанцировании шаблона класса для двух разных типов данных будут получены стеки двух разных типов), поэтому вы ограничены только использованием открытого интерфейса. Отсюда следует, что единственный способ обращения к элементам стека — это вызов `top()`. Однако для этого каждый элемент должен оказаться в вершине стека. Таким образом, сначала нужно сделать копию `ор2`, чтобы можно было удалять элементы при помощи вызовов `pop()`. Поскольку функция `top()` возвращает последний элемент, помещенный в стек, необходимо использовать контейнер, который поддерживает вставку элементов в противоположный конец коллекции. По этой причине здесь используется [[deque|дек std::deque<>]], у которого имеется функция `push_front()`, помещающая элемент в начало коллекции.

Для доступа ко всем членам `ор2` можно объявить все прочие экземпляры стеков друзьями:
```c++
template<typename Т>
class Stack
{
	private:
		std::deque<T> elems;    // Элементы

	public:
		void push(T consts);    // Добавление элементов в стек
		void pop();             // Снятие co стека
		T const& top() const;   // Возврат верхнего элемента
		
		bool empty() const      // Проверка пустоты стека
		{
			return elems.empty();
		}
		
		// Присваивание стека с элементами типа Т2
		template<typename Т2>
		Stacks operator= (Stack<T2> const&);
		
		// Для доступа к закрытым членам Stack<T2> для любого типа Т2:
		template<typename> friend class Stack;
};
```

Как можно видеть, поскольку имя параметра шаблона не используется, оно может быть опущено:
```c++
template<typename> friend class Stack;
```

После такого объявления возможна следующая реализация шаблонного оператора присваивания:
```c++
template<typename T>
template<typename T2>
Stack<T>& Stack<T>::operator= (Stack<T2> const& op2)
{
	elems.clear();               // Удаление существующих элементов
	elems.insert(elems.begin() , // Вставка в начало
				op2.elems.begin{) , // всех элементов из ор2
				op2.elems.end());
	
	return *this;
```






