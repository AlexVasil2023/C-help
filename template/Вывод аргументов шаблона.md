
[[#Вывод аргументов шаблона|Вывод аргументов шаблона]] 15
1. [[#Процесс вывода|Процесс вывода]] 15.1
2. [[#Выводимые контексты|Выводимые контексты]] 15.2
3. [[#Особые ситуации вывода|Особые ситуации вывода]] 15.3
4. [[#Списки инициализаторов|Списки инициализаторов]] 15.4
5. [[#Пакеты параметров|Пакеты параметров]] 15.5
	1. [[#Шаблоны оператора литерала|Шаблоны оператора литерала]] 15.5.1
6. [[#Ссылки на r-значения|Ссылки на r-значения]] 15.6
	1. [[#Правила свертки ссылок|Правила свертки ссылок]] 15.6.1
	2. [[#Передаваемые ссылки|Передаваемые ссылки]] 15.6.2
	3. [[#Прямая передача|Прямая передача]] 15.6.3
	4. [[#Сюрпризы вывода|Сюрпризы вывода]] 15.6.4
7. [[#Принцип SFINAE|Принцип SFINAE]] 15.7
	1. [[SFINAE#Непосредственный контекст|Непосредственный контекст]] 15.7.1
8. [[#Ограничения вывода|Ограничения вывода]] 15.8


# Вывод аргументов шаблона

Если при каждом вызове шаблона функции явным образом задавать аргументы шаблона (например,` concat<std::string, int> (s, 3)` ), то код может быстро стать громоздким. К счастью, компилятор C++ часто в состоянии автоматически определить, какими должны быть аргументы шаблона. Это достигается с помощью мощного механизма под названием ***вывод аргументов шаблона*** (template argument deduction).

В этой главе подробно объясняется, что происходит в процессе вывода аргументов шаблонов. Как это часто бывает в C++, с этим процессом связано множество правил, соблюдение которых обычно приводит к интуитивно понятному результату. Глубокое понимание материала, изложенного в этой главе, позволит избежать многих досадных неожиданностей.

Хотя вывод аргументов шаблона был впервые разработан для упрощения вызова шаблонов функций, он с тех пор был расширен для ряда других использований, включая определение типов переменных из их инициализаторов.

# Процесс вывода

В процессе вывода типы аргументов вызова функции сравниваются с соответствующими типами параметров шаблона функции, и компилятор пытается сделать вывод о том, что именно нужно подставить вместо одного или нескольких выведенных параметров. Анализ каждой пары “аргумент-параметр” проводится независимо, и, если выводы в конечном итоге отличаются, процесс вывода завершается неудачей. Рассмотрим следующий пример:
```c++
template<typename Т>
Т max (Т а, Т Ь)
{
	return b < а ? а : Ь;
}

auto g = max(1, 1.0);
```

Здесь первый аргумент вызова имеет тип `int`, из чего можно заключить, что в роли параметра `Т` в исходном шаблоне `max()` должен выступать тип `int`. Однако второй аргумент вызова имеет тип `double`, а это означает, что вместо параметра типа `Т` нужно подставить тип `double`. Этот вывод противоречит предыдущему. Заметим, что утверждение “вывод выполнить не удается” не означает, что программа некорректна. В конце концов может случиться так, что этот процесс удастся провести для другого шаблона с именем `max` ([[Шаблоны функций#Перегрузка шаблонов функций|шаблоны функций, как и обычные функции, можно перегружать]]; #главу_16, “Специализация и перегрузка”).

Даже если удалось вывести все параметры шаблона, это еще не означает, что вывод успешен. Бывает и так, что при подстановке выведенных аргументов в оставшуюся часть определения функции получается некорректная конструкция. Например:
```c++
template<typename Т>
typename T::ElementT at(T a, int i)
{
	return a[i];
}

void f(int* p)
{
	int x = at(p, 7);
}
```

Здесь `T` выводится как `int*` (тут имеется только один тип параметра, в котором появляется `Т`, так что, очевидно, никакой конфликт анализа невозможен). Однако подстановка `int*` вместо `Т` в возвращаемом типе `Т::ElementT`, очевидно, представляет собой некорректный код C++, и процесс вывода завершается неудачей.

Рассмотрим, как происходит процедура проверки соответствия параметра и аргумента. Опишем его в терминах соответствия типа `a` (выведенного из типа аргумента) параметризованному типу `p` (выведенному из объявления параметра вызова). Если параметр объявлен как ссылка, считаем, что `p` — это тип, на который делается ссылка, а `a` — тип аргумента. В противном случае `p` представляет собой объявленный тип параметра, а тип `a` получается из типа аргумента путем низведения (decaying) типов массива или функции к указателю на соответствующий тип. При этом квалификаторы верхнего уровня [[const|const]] и [[volatile|volatile]] игнорируются. Например:
```c++
template<typename Т> void f(Т);     // Параметризованный тип p
									// представляет собой тип Т
template<typename Т> void g(Т&) ;   // Параметризованный тип p также
									// представляет собой Т
double arr[20];
int const seven = 7;

f(arr);             // Передача по значению: T является double*
g(arr);             // Передача по ссылке: T является double[20]
f(seven);           // Передача по значению: T является int
g(seven);           // Передача по ссылке: T является int const
f(7);               // Передача по значению: T является int
g(7);               // Передача по ссылке: T является int => Ошибка: нельзя
					// передать 7 в int&
```

При вызове `f(arr)` тип массива `arr` низводится к типу `double*`, который представляет собой тип, выведенный для `Т`. В `f(seven)` квалификатор [[const|const]] убирается и, следовательно, `Т` выводится как `int`. Напротив, вызов `g(х)` приводит к выводу `Т` как типа `double[20]` (низведение не выполняется). Аналогично `g(seven)` имеет аргумент, являющийся [[значение#l-значение|l-значением]] типа `int const`, а, поскольку квалификаторы [[const|const]] и [[volatile|volatile]] не отбрасываются при сопоставлении ссылочных параметров, `Т` выводится как `int const`. Обратите, однако, внимание на то, что `g(7)` приводит к выводу `Т` как `int` (поскольку выражение [[значение#r-значения|r-значения]], не являющееся классом, никогда не имеет квалификаторы типа [[const|const]] или [[volatile|volatile]]), и вызов будет неудачным, так как аргумент `7` не может быть передан параметру типа `int&`.

Тот факт, что для аргументов, которые передаются по ссылке, низведение не выполняется, может привести к неожиданным результатам в тех случаях, когда эти аргументы являются строковыми литералами. Еще раз рассмотрим шаблон `max()`, объявленный со ссылками:
```c++
template<typename Т>
Т const& max(T const& а, Т const& b);
```

Разумно было бы ожидать, что в выражении `max("Apple", "Pie")` параметр `Т` будет выведен как тип `char const*`. Однако строка `"Apple"` имеет тип `char const [6]`, а строка `"Pie"` — тип `char const [4]`. Никакого низведения массива к указателю на массив не происходит (поскольку вывод типа выполняется на основе параметров, передаваемых по ссылке). Таким образом, вместо параметра `Т` нужно одновременно подставить и тип `char [6]`, и тип `char [4]`, а это, конечно же, невозможно. [[По значению или по ссылке#Работа со строковыми литералами и массивами|Более подробное обсуждение этой темы]].

# Выводимые контексты

Типу аргумента могут соответствовать значительно более сложные параметризованные типы, чем просто `Т`. Ниже приведено несколько (все еще не слишком сложных) примеров:
```c++
template<typename Т>
void f1(Т*);

template<typename Е, int N>
void f2(E(&)[N]);

template<typename T1, typename T2, typename T3>
void f3(T1(T2::*)(T3*));

class S
{
	public:
		void f(double*);
};

void g(int*** ррр)
{
	bool b[42];
	
	f1(ррр);              // T выводится как int**
	f2(b);                // Е выводится как bool, а N - как 42
	f3(&S::f);            // Выводится: T1 = void, Т2 = S и ТЗ = double
}
```

Сложные объявления типов составляются из более простых конструкций (деклараторов указателей, ссылок, массивов и функций, деклараторов указателей на члены, идентификаторов шаблонов и т.д.). Процесс определения нужного типа происходит в нисходящем порядке, начиная с конструкций высокого уровня и рекурсивно продвигаясь к составляющим их элементам. Уместно заметить, что этим путем можно подобрать тип для большинства конструкций объявлений типов; в этом случае они называются выводимым контекстом (deduced context). Однако некоторые конструкции выводимым контекстом не являются. К их числу относятся следующие.
>
> Квалифицированное имя типа. Например, имя типа наподобие `Q<T>::Х` никогда не используется для вывода параметра шаблона `Т`.
> 
> Выражения, не являющиеся типами, но которые при этом не являются нетиповыми параметрами (не являющимися типами). Например, ни имя типа наподобие `S<I+1>` никогда не используется для вывода `I`, ни параметр `Т` не выводится путем сравнения с параметром типа `int(&)[sizeof(S<T>)]`.

Эти ограничения не должны вызывать удивления, поскольку в общем случае вывод может оказаться неоднозначным (может даже оказаться, что подходящих типов бесконечно много), хотя ограничение на квалифицированные имена типов иногда легко просмотреть. Если в программе встречается невыводимый контекст, это еще не означает, что программа содержит ошибку или что анализируемый параметр не может принимать участия в выводе типа. Чтобы это проиллюстрировать, рассмотрим более сложный пример.
```c++
template<int N>
class X
{
	public:
		using I = int;
		void f(int)
		{   }
};

template<int N>
void fppm(void (X<N>::*p)(typename X<N>::I));

int main()
{
	fppm(&X<33>::f);            // Все в порядке: N выводится как 33
}
```

Конструкция `X<N>::I`, которая находится в шаблоне функции `fppm ()`, является невыводимым контекстом; однако использующийся в ней компонент `X<N>` члена класса с типом указателя на член класса является выводимым контекстом. Когда выведенный из этого компонента параметр `N` подставляется в невыводимый контекст, получается тип, совместимый с типом фактического аргумента (`&Х<33>:: f`). Таким образом, для этой пары “аргумент-параметр” вывод удается успешно выполнить до конца.

И наоборот, если параметр типа состоит только из выводимого контекста, то это еще не означает, что вывод не приведет к противоречиям. Например, предположим, что у нас имеются надлежащим образом объявленные шаблоны классов `X` и `Y`. Рассмотрим приведенный ниже код.
```c++
template<typename Т>
void f(X<Y<T>, Y<T>>);

void g()
{
	f(X<Y<int>, Y<int>>());      // OK
	f(X<Y<int>, Y<char>>());     // Ошибка: неудачный вывод
}
```

Проблема, связанная со вторым вызовом шаблона функции `f()`, заключается в том, что для параметра `Т` на основе двух аргументов функции выводятся разные типы, что приводит к противоречию. (В обоих вызовах аргументы функции являются временными объектами, полученными путем вызова конструктора по умолчанию для шаблона класса `X`.)

# Особые ситуации вывода

Возможны несколько ситуаций, в которых использующаяся для вывода пара `(Р, А)` получается не из аргументов вызова функции и параметров шаблона функции. Первая ситуация осуществляется, когда используется адрес шаблона функции. В этом случае `Р` — это параметризованный тип объявления шаблона функции, а `A` — тип функции, на которую ссылается инициализируемый указатель или указатель, которому присваивается значение. Например:
```c++
template<typename Т>
void f(Т, Т);
void (*pf)(char, char) = &f;
```

В этом примере `Р` — `void (Т, Т)`, а `A` — `void (char, char)`. Вывод успешен, при этом `Т` заменяется на `char`, a `pf` инициализируется адресом специализации `f<char>`.

Аналогично типы функций для `Р` и `A` используются и в некоторых других особых ситуациях.
>
> Определение частичного упорядочения между перегруженными шаблонами функций.
> 
> Соответствие явной специализации шаблону функции.
>
> Соответствие явного инстанцирования шаблону.
> 
> Соответствие шаблону специализации шаблона дружественной функции.
> 
> Соответствие шаблонов размещающих операторов `operator delete` или `operator delete[]` соответствующим шаблонам размещающих операторов `operator new` или `operator new []`.

Некоторые из этих тем, наряду с использованием вывода аргумента шаблона для частичной специализации шаблона класса, получат дальнейшее развитие в #главе_16, “Специализация и перегрузка”.

Еще одна особая ситуация связана с шаблоном оператора преобразования типа. Например:
```c++
class S
{
	public:
		template<typename Т> operator Т&
};
```

В этом случае пара `(Р, A)` получается таким образом, как если бы в нее входил аргумент того типа, к которому мы пытаемся выполнить преобразование, и тип параметра, возвращаемый оператором преобразования. Приведенный ниже код иллюстрирует один из возможных вариантов этой ситуации.
```c++
void f(int (&)[20]);
void g(S s)
{
	f(s);
}
```

В этом фрагменте делается попытка преобразовать `S` к типу `int(&)[20]`. Поэтому тип `А` — это `int[20]`, а тип `Р` — это `Т`. Процесс вывода выполняется успешно, и `Т` заменяется типом `int[20]`.

Наконец, отдельное рассмотрение требуется для вывода заместителя типа [[auto|auto]] (см. #раздел_15_10_4).

# Списки инициализаторов

Когда в качестве аргумента функции выступает список инициализации, такой аргумент не имеет определенного типа, так что в общем случае вывод из данной пары `(Р,А)` не выполняется за отсутствием `А`. Например:
```c++
#include <initializer_list>

template<typename Т> void f(Т p);
int main()
{
	f({1,2,3});                  // Ошибка: невозможно вывести T
}                                // из списка в фигурных скобках
```

Однако, если тип `Р` параметра после удаления ссылочности и квалификаторов верхнего уровня [[const|const]] и [[volatile|volatile]] эквивалентен `std::initializer_list<P0>` для некоторого типа `Р`, который имеет выводимую схему, вывод продолжается путем сравнения Р0 с типом каждого элемента в списке инициализаторов, и успешно завершается, только если все элементы имеют один и тот же тип:
```c++
#include <initializer_list>

template<typename T> void f(std::initializer_list<T>);
int main()
{
	f({2, 3, 5, 7, 9});                 //OK: T выводится как int
	f({'a','e',' i','o', 'u', 42});     // Ошибка: T выводится
}                                       // и как char, и как int
```

Аналогично, если тип параметра `Р` является ссылкой на тип массива с типом элементов `Р0` для некоторого типа `Р0`, имеющего выводимую схему, то вывод выполняется путем сравнения `Р0` с типом каждого элемента в списке инициализаторов, и является успешным, только если все элементы имеют один и тот же тип. Кроме того, если граница имеет выводимую схему (т.е. просто именует параметр шаблона, не являющийся типом), то эта граница выводится как количество элементов в списке.

# Пакеты параметров

Процесс вывода проверяет соответствие каждого аргумента каждому параметру для определения значений аргументов шаблона. Однако при выполнении вывода аргумента шаблона для вариативных шаблонов отношение “один к одному” между параметрами и аргументами больше не выполняется, потому что пакету параметров могут соответствовать несколько аргументов. В этом случае один и тот же пакет параметров (`Р`) сопоставляется нескольким аргументам (`A`), и каждое соответствие производит дополнительные значения для любого пакета параметров шаблонов в `Р`:
```c++
template<typename First, typename... Rest>
void f(First first, Rest... rest);
void g(int i, double j, int* k)
{
	f(i, j, k);  // Вывод First как int, Rest как {double, int*}
}
```

Здесь вывод первого параметра функции прост, поскольку он не включает каких-либо пакетов параметров. Второй параметр функции, `rest`, представляет собой пакет параметров функции. Его тип — раскрытие пакета (`Rest...`), схема которого имеет тип `Rest`: этот шаблон служит в качестве `Р`, для сравнения с типами `А` второго и третьего аргументов. При сравнении с первым таким `А` (тип `double`), первое значение в пакете параметров шаблона `Rest` выводится как `double`. Аналогично, когда сравнивается второй такой `А` (тип `int*`), второе значение в пакете параметров шаблона `Rest` выводится как `int*`. Таким образом, вывод определяет значение пакета параметров `Rest` как последовательность `{double, int*}`. Подстановка результатов этого вывода и вывода для первого параметра функции дает тип функции `void (int, double, int*)`, который соответствует типам аргументов в точке вызова.

Поскольку вывод для пакетов параметров функций использует для сравнения схему раскрытия, схема может быть произвольно сложной, а значения для нескольких параметров шаблона и пакетов параметров могут быть определены из каждого типа аргументов. Рассмотрим поведение вывода для представленных ниже функций `h1()` и `h2()`:
```c++
template<typename Т, typename U> class pair{};

template<typename T, typename... Rest>
void h1(pair<T, Rest> const& ...);

template<typename... Ts, typename... Rest>
void h2(pair<Ts, Rest> const& ...);

void foo(pair<int, float> pif, pair<int, double> pid,
			pair<double, double> pdd)
{
	h1(pif, pid);   // OK; T - int, Rest - {float, double}
	h2(pif, pid);   // OK: Ts - {int, int}, Rest - {float, double}
	h1(pif, pdd);   // Ошибка: T - int bp первого аргумента,
					// но double из второго
	h2(pif, pdd);   // OK: Ts - {int, double}, Rest - {float, double}
```

И для `h1()`, и для `h2()` `P` — это ссылочный тип, приведенный к неквалифицированной версии ссылки (`pair<T, Rest>` или `pair<Ts, Rest>` соответственно) для вывода типа каждого аргумента. Так как все параметры и аргументы являются специализациями шаблона класса [[pair|pair]], сравниваются аргументы шаблона. Для `h1()` первый аргумент шаблона (`Т`) не является пакетом параметров, поэтому его значение выводится независимо для каждого аргумента. Если выведенные типы отличаются, как во втором вызове `h1()`, вывод является неуспешным. Для второго аргумента шаблона [[pair|pair]] в `h1()` и `h2()` (`Rest`) и для первого аргумента [[pair|pair]] в `h2()` (`Ts`) вывод из каждого из типов аргументов в `А` определяет последовательные значения пакетов параметров шаблонов.

Вывод для пакетов параметров не ограничивается пакетами параметров функции, где из аргументов вызова получаются пары “аргумент-параметр”. Фактически этот вывод используется везде, где раскрытие пакета находится в конце списка параметров функции или списка аргументов шаблонов. Рассмотрим две аналогичные операции над простым типом [[tuple|Tuple]]:
```c++
template<typename... Types> class Tuple { };

template<typename... Types>
bool f1(Tuple<Types...>, Tuple<Types...>);

template<typename... Types1, typename... Types2>
bool f2(Tuple<Types1...>, Tuple<Types2...>);

void bar(Tuple<short, int, long> sv,
		 Tuple<unsigned short, unsigned, unsigned long> uv)
{
	f1(sv, sv); // OK: Types выполняется как {short, int, long}
	f2(sv, sv); // OK: Types1 выполняется как {short, int, long}
				// Types2 выводится как {short, int, long}

	f1(sv, uv); // Ошибка: Types выводится как {short, int, long}
				// из первого аргумента, но как {unsigned	
				// short, unsigned, unsigned long} из второго
	f2(sv, uv); // OK: Types1 Typesl выводится как {short, int, long},
				// Types2 выводится как {unsigned short,
				// unsigned, unsigned long}
```

И в `f1()`, и в `f2()` пакеты параметров шаблонов выводятся путем сравнения схемы раскрытия пакета, встроенного в тип [[tuple|Tuple]] (например, `Types` для `h1())` ) с каждым из аргументов шаблона типа [[tuple|Tuple]], предоставляемым аргументом вызова, и выведением последовательных значений для соответствующего пакета параметров шаблона. Функция `f1()` использует один и тот же пакет параметров шаблона `Types` в обоих параметрах функции, гарантируя, что вывод завершается успешно только тогда, когда аргументы вызова двух функций имеют ту же специализацию [[tuple|Tuple]], что и их тип. С другой стороны, функция `f2()` использует различные пакеты параметров для типов [[tuple|Tuple]] в каждом из своих параметров функции, так что типы аргументов вызова функции могут быть различными — при условии, что оба являются специализациями [[tuple|Tuple]]. 

## Шаблоны оператора литерала

Шаблоны оператора литерала (literal operator template) должны определять свои аргументы уникальным способом, иллюстрируемым следующим примером:
```c++
template<char...> int operator "" _В7();     // #1

...

int а = 121_В7;                              // #2
```

Здесь инициализатор в `#2` содержит пользовательский литерал, который превращается в вызов шаблона оператора литерала `#1` со списком аргументов шаблона `<' 1', ' 2 ', ' 1' >`. Таким образом, реализация оператора литерала, такая как
```c++
template<char... cs>
int operator"" _B7()
{
	std::array<char, sizeof...(cs)>       // Инициализация массива
						chars{cs...};     // переданными символами
	for (char c : chars)                  // и их использование (в
	{                                     // данном случае - печать)
		std::cout << "'" << c << "'";
	}
	
	std::cout << '\n';
	return ...;
}
```

выведет для литерала `121.5_В7` следующее:
```c++
'1' '2' '1' '.' '5'
```

Обратите внимание на то, что эта методика поддерживается только для числовых литералов, корректных даже без суффикса. Например:
```c++
auto b - 01.3_В7;       // OK: выводит <'O’, '1', '.', '3'>
auto с = 0xFF00_B7;     // OK: выводит <'O’, 'x', 'F', 'F', 'O', '0’>
auto d = 0815_В7;       // Ошибка: 8 не является корректным
						// восьмеричным литералом
auto е = hello_B7;      // Ошибка: идентификатор hello_B7 не определен
auto f = "hello"_B7;    // Ошибка: нет соответствия оператора _В7
```

В #разделе_25_6 описывается применение этой возможности для вычисления целочисленных литералов во время компиляции.

# Ссылки на r-значения

В C++11 вводятся ссылки на [[значение#r-значения|r-значения]] (rvalue references), которые позволяют применять новые методы работы, включая семантику перемещений и прямую передачу. В этом разделе описывается взаимодействие между ссылками на [[значение#r-значения|r-значения]] и выводом типов.

## Правила свертки ссылок

Программисты не могут объявить “ссылку на ссылку” непосредственно:
```c++
int const& г = 42;
int const&& ref2ref = i;      // Ошибка: ссылка на ссылку
```

Однако при создании типов путем подстановки параметров шаблонов, применении псевдонимов типов или конструкций [[decltуре|decltype]], такие ситуации допускаются. Например:
```c++
using RI = int&;
int i = 42;
RI r = i;
RI const& rr = r; // OK: rr имеет тип int&
```

Правила, которые определяют тип, получающийся при такой композиции, известны как правила свертки ссылок (reference collapsing). Во-первых, любые квалификаторы [[const|const]] или [[volatile|volatile]], применяемые поверх внутренней ссылки, просто отбрасываются (т.е. сохраняются только квалификаторы под знаком внутренней ссылки). Затем две ссылки сводятся к одной согласно табл., которую можно резюмировать как “если любая из ссылок является ссылкой на [[значение#l-значение|l-значение]], то таковым будет и результирующий тип; в противном случае получаем ссылку на [[значение#r-значения|r-значение]]”.

| **Внутренняя ссылка** | **Внешняя ссылка** | **Результирующая ссылка** |
| --------------------- | ------------------ | ------------------------- |
| &                     | &                  | &                         |
| &                     | &&                 | &                         |
| &&                    | &                  | &                         |
| &&                    | &&                 | &&                        |

Еще один пример показывает эти правила в действии:
```c++
using RCI = int const&;
RCI volatile&& r = 42;   // OK: r имеет тип int const&

using RRI = int&&;
RRI const&& rr = 42;     // OK: rr имеет тип int&&
```

Здесь [[volatile|volatile]] применяется поверх ссылочного типа `RCI` (псевдоним для `int const &`) и поэтому игнорируется. Затем поверх этого типа применяется ссылка на [[значение#r-значения|r-значение]], но, поскольку базовый тип представляет собой ссылку на [[значение#l-значение|l-значение]], а ссылки на [[значение#l-значение|l-значение]] имеют более высокий “приоритет” в правилах свертки ссылок, в конечном итоге получается тип `int const &` (или эквивалентный псевдоним `RCI`). Аналогично отбрасывается [[const|const]] поверх `RRI`, а применение ссылки на [[значение#r-значения|r-значение]] поверх получающейся ссылки на [[значение#r-значения|r-значение]] по-прежнему оставляет нас с типом ссылки на [[значение#r-значения|r-значение]] (позволяя связывать ее с таким [[значение#r-значения|r-значение]], как 42).

## Передаваемые ссылки

[[Семантика перемещения - Прямая передача|Вывод аргумента шаблона ведет себя особым образом, когда параметр функции представляет собой передаваемую ссылку]] (forwarding reference) (ссылку на [[значение#r-значения|r-значение]] на параметр шаблона данного шаблона функции). В этом случае вывод аргумента шаблона рассматривает не только тип аргумента вызова функции, но и выясняет, является этот аргумент [[значение#l-значение|l-значением]] или [[значение#r-значения|r-значением]]. В случаях, когда аргумент является [[значение#l-значение|l-значением]], тип, определяемый выводом аргумента шаблона, представляет собой ссылку на [[значение#l-значение|l-значение]] на тип аргумента, а рассмотренные выше правила свертки ссылок приводят к тому, что подставляемый параметр будет ссылкой на [[значение#l-значение|l-значение]]. В противном случае выведенный для параметра шаблона тип является просто типом аргумента (не ссылочным типом), и подставляемый параметр является ссылкой на [[значение#l-значение|r-значение]] на этот тип. Например:
```c++
template<typename Т> void f(Т&& р) ; // р - передаваемая ссылка

void g()
{
	int i;
	int const j = 0;
	
	f{i);   // Аргумент является l-значением; T выводится как
			// int&, а параметр р имеет тип int&
	f(j);   // Аргумент является l-значением; Т выводится как
			// int const&, а параметр р имеет тип int const&
	f(2);   // Аргумент является r-значением; Т выводится как
			// int, а параметр р имеет тип int&&
}
```

В вызове `f(i)` параметр шаблона `Т` выводится как `int&`, поскольку выражение `i` является [[значение#l-значение|l-значением]] типа `int`. Подстановка `int&` вместо `Т` в тип параметра `Т&&` требует свертки ссылки, и мы применяем правило `&+&&->&`, чтобы заключить, что результирующий параметр типа — `int&`, который идеально подходит для принятия [[значение#l-значение|l-значения]] типа `int`. Напротив, в вызове `f(2)`, аргумент `2` представляет собой [[значение#r-значения|r-значение]], и поэтому параметр шаблона выводится просто как тип [[значение#r-значения|r-значения]] (т.е. `int`). Для результирующего параметра функции, который представляет собой простой `int&&`, применение правил свертки ссылок не требуется (а параметр подходит для переданного аргумента).

Вывод `Т` как ссылочного типа может иметь некоторое интересное влияние на инстанцирование шаблона. Например, локальная переменная, объявленная с типом `Т`, после инстанцирования для [[значение#l-значение|l-значения]] имеет ссылочный тип и поэтому требует наличия инициализатора:
```c++
template<typename Т> void f(Т&&) // р - передаваемая ссылка
{
	Т х; // Для переданного l-значения х является ссылкой

	...
}
```

Это означает, что при определении функции `f()` выше необходимо быть осторожным при использовании типа `Т`, иначе сам шаблон функции не будет корректно работать с аргументами, являющимися [[значение#l-значение|l-значениями]]. Чтобы справиться с этой ситуацией, часто используется свойство типа [[remove_reference|std::remove_reference]] для гарантии, что `х` не является ссылкой:

## Прямая передача

Сочетание специальных правил вывода для ссылок на [[значение#r-значения|r-значения]] и правил свертки ссылок позволяет написать шаблон функции с параметром, который принимает практически любой аргумент и фиксирует его основные свойства (его тип и то, является он [[значение#l-значение|l-значением]] или [[значение#r-значения|r-значением]]). Шаблон функции может затем “передать” аргумент другой функции следующим образом:
```c++
class С
{
	...
};

void g(С&);
void g(С const&);
void g(C&&);

tempiate<typename T>
void forwardToG(T&& x)
{
	g(static_cast<T&&> (x) );  // Передача x в g()
}

void foo()
{
	C v;
	C const c;
	
	forwardToG(v);              // Вызов g(C&)
	forwardToG(c);              // Вызов g(C const&)
	forwardToG(C());            // Вызов g(C&&)
	forwardToG(std::move(v));   // Вызов g(C&&)
}
```

Проиллюстрированная здесь методика называется прямой передачей (perfect forwarding), потому что результат вызова `g()` косвенно через `forwardToG()` будет тем же, как если бы код вызывал `g()` непосредственно: не делается никаких дополнительных копий, и выбирается в точности та же перегрузка `g()`.

Применение [[static_cast|static_cast]] в функции `forwardToG()` требует некоторых дополнительных объяснений. В каждом инстанцировании `forwardToG()` параметр `х` будет иметь тип либо ссылки на [[значение#l-значение|l-значение]], либо ссылки на [[значение#r-значения|r-значение]]. Независимо от этого выражение `х` будет [[значение#l-значение|l-значением]] того типа, на который указывает ссылка [[static_cast|static_cast]] приводит `х` к исходному типу и [[значение|l- или r-“значимости”]]. Тип `Т&&` будет либо свернут к ссылке на [[значение#l-значение|l-значение]] (если исходный аргумент был [[значение#l-значение|l-значением]], заставляя `Т` стать ссылкой на [[значение#l-значение|l-значение]]) или ссылке на [[значение#r-значения|r-значение]] (если исходный аргумент был [[значение#r-значения|r-значением]]), так что результат применения [[static_cast|static_cast]] имеет тот же тип и [[значение|l- или r-“значимость”]], что и исходный аргумент, обеспечивая тем самым прямую передачу.

Стандартная библиотека C++ предоставляет шаблон функции [[forward|std::forward<>()]] в заголовочном файле `<utility>`, которая должна использоваться для корректной передачи вместо [[static_cast|static_cast]]. С помощью этого вспомогательного шаблона намерения программиста оказываются лучше документированы, чем при применении непрозрачного [[static_cast|static_cast]], он также препятствует таким ошибкам, как пропуск одного символа `&`. То есть приведенный выше пример более ясно записывается следующим образом:
```c++
#include <utility>

template<typename Т> void forwardToG(Т&& x)
{
	g(std::forward<T>(x));  // Передача x в g()
}
```

**===Прямая передача для вариативных шаблонов===**

Прямая передача хорошо сочетается с вариативными шаблонами, позволяя шаблону функции принимать любое количество аргументов вызова функции и передавать каждый из них в другую функцию:
```c++
template<typename... Ts> 
void forwardToG(Ts&&... xs)
{
	g(std::forward<Ts>(xs)...);   // Передача всех xs в g()
}
```

Аргументы в вызове `forwardToG()` (независимо) приводят к [[Вывод аргументов шаблона#Пакеты параметров|выводу последовательных значений пакета параметров]] `Ts`, так что сохраняются типы и [[значение|l- или r-“значимость”]]. [[Вглубь шаблонов#Раскрытие пакета|Раскрытие пакета]] в вызове `g()` выполняет передачу каждого из этих аргументов с использованием технологии прямой передачи, объясненной выше.

Несмотря на свое название, прямая передача по сути является не совсем “прямой”, в том смысле, что она не охватывает все интересные свойства выражения. Например, она не в состоянии выяснить, ни является ли [[значение#l-значение|l-значение]] значением битового поля, ни имеет ли выражение определенное константное значение. Последнее может вызвать проблемы, в частности, когда мы имеем дело с константой нулевого указателя, которая представляет собой константное значение целочисленного типа, равное нулю. Поскольку константное значение выражения при прямой передаче не захватывается, разрешение перегрузки в следующем примере будет вести себя по-разному для прямого и переадресованного вызова `g()`:
```c++
void g(int*);
void g(...);

template<typename T> 
void forwardToG(T&& x)
{
	g(std::forward<T>(x));    // Передача x в g()
}

void foo()
{
	g(0);                     // Вызов g(int*)
	forwardToG(0);            // Вызов g(...)
}
```

Это еще одна причина использовать значение [[nullptr_t|nullptr]] (введенное в C++11) вместо константы нулевого указателя:
```c++
g(nullptr);           // Вызов g(int*)
forwardToG(nullptr);  // Вызов g(int*)
```

Все наши примеры прямой передачи были сосредоточены на передаче аргументов функций при сохранении их точного типа и [[значение|l- или r-“значимости”]]. Та же проблема возникает при пересылке возвращаемого значения вызова в другую функцию с точно тем же типом и категорией значения, обобщением [[значение|l- и r-значений]], рассматривающимся в #приложении_Б, “Категории значений”. Конструкция [[decltуре|decltype]], введенная в C++11 обеспечивает применение показанной далее несколько многословной идиомы:
```c++
template<typename... Ts>
auto forwardToG(Ts&&... xs) -> decltype(g(std::forward<Ts>(xs)...))
{
	return g(std::forward<Ts>(xs) ...); // Передача всех xs в g()
}
```

Обратите внимание на то, что выражение в операторе `return` скопировано в тип [[decltуре|decltype]], так что вычисляется точный тип возвращаемого выражения. Кроме того, используется завершающий возвращаемый тип (trailing return type) функции (т.е. для указания возвращаемого типа перед именем функции ставится заместитель [[Вывод типа auto|auto]], а после него - `->`), так что пакет параметров функции xs находится в области видимости данного типа [[decltуре|decltype]]. Эта функция переадресации выполняет прямую передачу всех аргументов функции `g()`, а затем выполняет такую же прямую передачу результата вызова обратно в вызывающий код. 

C++14 вводит дополнительные возможности упрощения данного кода:
```c++
template<typename... Ts>
decltype(auto) forwardToG(Ts&& ... xs)
{
	return g(std::forward<Ts>(xs)...);   // Передача всех xs в g()
}
```

Использование [[decltуре#decltype(auto) C++14|decltype (auto)]] в качестве типа возвращаемого значения указывает, что компилятор должен вывести тип возвращаемого значения из определения функции (см. #разделы_15_10_1 и #15_10_3).

## Сюрпризы вывода

Результаты специальных правил вывода для ссылок на [[значение#r-значения|r-значения]] являются очень полезными для прямой передачи. Однако они могут оказаться неожиданными, потому что шаблоны функций обычно обобщают типы в сигнатуре функции, не учитывая, какие разновидности аргументов ([[значение#l-значение|l-значения]] или [[значение#r-значения|r-значения]]) она допускает. Рассмотрим следующий пример:
```c++
void int_lvalues(int&);   // Принимает l-значения типа int

template<typename T>
void lvalues(T&);         // Принимает l-значения любого типа

void int_rvalues(int&&);  // Принимает r-значения типа int

template<typename T>
void anything(T&&);      // Сюрприз: принимает l- и r-значения
						 // любого типа
```

Программисты, которые просто абстрагируют конкретные функции наподобие `int_rvalues` в их шаблонные эквиваленты, вероятно, будут удивлены тем фактом, что шаблон функции `anything` принимает [[значение#l-значение|l-значения]]. К счастью, это поведение вывода применяется только тогда, когда параметр функции, записанный в виде параметра шаблона `&&`, является частью шаблона функции, и именованный параметр шаблона объявляется этим шаблоном функции. Таким образом, данное правило вывода не применяется ни в одной из следующих ситуаций:
```c++
template<typename Т>
class X
{
	public:
		Х(Х&&);        // X не является параметром шаблона
		Х(Т&&);        // Этот конструктор не является шаблоном функции

	template<typename U>
		X(X<U>&&);     // Х<U> не является параметром шаблона
		
	template<typename U>
		X(U, Т&&);     // Т является параметром внешнего шаблона
};
```

Несмотря на удивительное поведение, которое дает это правило вывода, случаи, когда такое поведение вызывает проблемы, на практике встречается нечасто. Когда это происходит, можно использовать сочетание [[Программирование времени компиляции#SFINAE|SFINAE]] и свойство типа, такое как [[enable_if|std::enable_if]], для того, чтобы ограничить шаблон только [[значение#r-значения|r-значениями]]:
```c++
template<typename Т>
typename std::enable_if<!std::is_lvalue_reference<T>::value>::type
rvalues(T&&); // Принимает r-значения любого типа
```

# Принцип SFINAE

[[SFINAE#Принцип SFINAE| см. тут]] - сделать

# Ограничения вывода
























