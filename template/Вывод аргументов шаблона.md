
[[#Вывод аргументов шаблона|Вывод аргументов шаблона]] 15
1. [[#Процесс вывода|Процесс вывода]] 15.1
2. [[#Выводимые контексты|Выводимые контексты]] 15.2
3. [[#Особые ситуации вывода|Особые ситуации вывода]] 15.3


# Вывод аргументов шаблона

Если при каждом вызове шаблона функции явным образом задавать аргументы шаблона (например,` concat<std::string, int> (s, 3)` ), то код может быстро стать громоздким. К счастью, компилятор C++ часто в состоянии автоматически определить, какими должны быть аргументы шаблона. Это достигается с помощью мощного механизма под названием ***вывод аргументов шаблона*** (template argument deduction).

В этой главе подробно объясняется, что происходит в процессе вывода аргументов шаблонов. Как это часто бывает в C++, с этим процессом связано множество правил, соблюдение которых обычно приводит к интуитивно понятному результату. Глубокое понимание материала, изложенного в этой главе, позволит избежать многих досадных неожиданностей.

Хотя вывод аргументов шаблона был впервые разработан для упрощения вызова шаблонов функций, он с тех пор был расширен для ряда других использований, включая определение типов переменных из их инициализаторов.

# Процесс вывода

В процессе вывода типы аргументов вызова функции сравниваются с соответствующими типами параметров шаблона функции, и компилятор пытается сделать вывод о том, что именно нужно подставить вместо одного или нескольких выведенных параметров. Анализ каждой пары “аргумент-параметр” проводится независимо, и, если выводы в конечном итоге отличаются, процесс вывода завершается неудачей. Рассмотрим следующий пример:
```c++
template<typename Т>
Т max (Т а, Т Ь)
{
	return b < а ? а : Ь;
}

auto g = max(1, 1.0);
```

Здесь первый аргумент вызова имеет тип `int`, из чего можно заключить, что в роли параметра `Т` в исходном шаблоне `max()` должен выступать тип `int`. Однако второй аргумент вызова имеет тип `double`, а это означает, что вместо параметра типа `Т` нужно подставить тип `double`. Этот вывод противоречит предыдущему. Заметим, что утверждение “вывод выполнить не удается” не означает, что программа некорректна. В конце концов может случиться так, что этот процесс удастся провести для другого шаблона с именем `max` ([[Шаблоны функций#Перегрузка шаблонов функций|шаблоны функций, как и обычные функции, можно перегружать]]; #главу_16, “Специализация и перегрузка”).

Даже если удалось вывести все параметры шаблона, это еще не означает, что вывод успешен. Бывает и так, что при подстановке выведенных аргументов в оставшуюся часть определения функции получается некорректная конструкция. Например:
```c++
template<typename Т>
typename T::ElementT at(T a, int i)
{
	return a[i];
}

void f(int* p)
{
	int x = at(p, 7);
}
```

Здесь `T` выводится как `int*` (тут имеется только один тип параметра, в котором появляется `Т`, так что, очевидно, никакой конфликт анализа невозможен). Однако подстановка `int*` вместо `Т` в возвращаемом типе `Т::ElementT`, очевидно, представляет собой некорректный код C++, и процесс вывода завершается неудачей.

Рассмотрим, как происходит процедура проверки соответствия параметра и аргумента. Опишем его в терминах соответствия типа `a` (выведенного из типа аргумента) параметризованному типу `p` (выведенному из объявления параметра вызова). Если параметр объявлен как ссылка, считаем, что `p` — это тип, на который делается ссылка, а `a` — тип аргумента. В противном случае `p` представляет собой объявленный тип параметра, а тип `a` получается из типа аргумента путем низведения (decaying) типов массива или функции к указателю на соответствующий тип. При этом квалификаторы верхнего уровня [[const|const]] и [[volatile|volatile]] игнорируются. Например:
```c++
template<typename Т> void f(Т);     // Параметризованный тип p
									// представляет собой тип Т
template<typename Т> void g(Т&) ;   // Параметризованный тип p также
									// представляет собой Т
double arr[20];
int const seven = 7;

f(arr);             // Передача по значению: T является double*
g(arr);             // Передача по ссылке: T является double[20]
f(seven);           // Передача по значению: T является int
g(seven);           // Передача по ссылке: T является int const
f(7);               // Передача по значению: T является int
g(7);               // Передача по ссылке: T является int => Ошибка: нельзя
					// передать 7 в int&
```

При вызове `f(arr)` тип массива `arr` низводится к типу `double*`, который представляет собой тип, выведенный для `Т`. В `f(seven)` квалификатор [[const|const]] убирается и, следовательно, `Т` выводится как `int`. Напротив, вызов `g(х)` приводит к выводу `Т` как типа `double[20]` (низведение не выполняется). Аналогично `g(seven)` имеет аргумент, являющийся [[значение#l-значение|l-значением]] типа `int const`, а, поскольку квалификаторы [[const|const]] и [[volatile|volatile]] не отбрасываются при сопоставлении ссылочных параметров, `Т` выводится как `int const`. Обратите, однако, внимание на то, что `g(7)` приводит к выводу `Т` как `int` (поскольку выражение [[значение#r-значения|r-значения]], не являющееся классом, никогда не имеет квалификаторы типа [[const|const]] или [[volatile|volatile]]), и вызов будет неудачным, так как аргумент `7` не может быть передан параметру типа `int&`.

Тот факт, что для аргументов, которые передаются по ссылке, низведение не выполняется, может привести к неожиданным результатам в тех случаях, когда эти аргументы являются строковыми литералами. Еще раз рассмотрим шаблон `max()`, объявленный со ссылками:
```c++
template<typename Т>
Т const& max(T const& а, Т const& b);
```

Разумно было бы ожидать, что в выражении `max("Apple", "Pie")` параметр `Т` будет выведен как тип `char const*`. Однако строка `"Apple"` имеет тип `char const [6]`, а строка `"Pie"` — тип `char const [4]`. Никакого низведения массива к указателю на массив не происходит (поскольку вывод типа выполняется на основе параметров, передаваемых по ссылке). Таким образом, вместо параметра `Т` нужно одновременно подставить и тип `char [6]`, и тип `char [4]`, а это, конечно же, невозможно. [[По значению или по ссылке#Работа со строковыми литералами и массивами|Более подробное обсуждение этой темы]].

# Выводимые контексты

Типу аргумента могут соответствовать значительно более сложные параметризованные типы, чем просто `Т`. Ниже приведено несколько (все еще не слишком сложных) примеров:
```c++
template<typename Т>
void f1(Т*);

template<typename Е, int N>
void f2(E(&)[N]);

template<typename T1, typename T2, typename T3>
void f3(T1(T2::*)(T3*));

class S
{
	public:
		void f(double*);
};

void g(int*** ррр)
{
	bool b[42];
	
	f1(ррр);              // T выводится как int**
	f2(b);                // Е выводится как bool, а N - как 42
	f3(&S::f);            // Выводится: T1 = void, Т2 = S и ТЗ = double
}
```

Сложные объявления типов составляются из более простых конструкций (деклараторов указателей, ссылок, массивов и функций, деклараторов указателей на члены, идентификаторов шаблонов и т.д.). Процесс определения нужного типа происходит в нисходящем порядке, начиная с конструкций высокого уровня и рекурсивно продвигаясь к составляющим их элементам. Уместно заметить, что этим путем можно подобрать тип для большинства конструкций объявлений типов; в этом случае они называются выводимым контекстом (deduced context). Однако некоторые конструкции выводимым контекстом не являются. К их числу относятся следующие.
>
> Квалифицированное имя типа. Например, имя типа наподобие `Q<T>::Х` никогда не используется для вывода параметра шаблона `Т`.
> 
> Выражения, не являющиеся типами, но которые при этом не являются нетиповыми параметрами (не являющимися типами). Например, ни имя типа наподобие `S<I+1>` никогда не используется для вывода `I`, ни параметр `Т` не выводится путем сравнения с параметром типа `int(&)[sizeof(S<T>)]`.

Эти ограничения не должны вызывать удивления, поскольку в общем случае вывод может оказаться неоднозначным (может даже оказаться, что подходящих типов бесконечно много), хотя ограничение на квалифицированные имена типов иногда легко просмотреть. Если в программе встречается невыводимый контекст, это еще не означает, что программа содержит ошибку или что анализируемый параметр не может принимать участия в выводе типа. Чтобы это проиллюстрировать, рассмотрим более сложный пример.
```c++
template<int N>
class X
{
	public:
		using I = int;
		void f(int)
		{   }
};

template<int N>
void fppm(void (X<N>::*p)(typename X<N>::I));

int main()
{
	fppm(&X<33>::f);            // Все в порядке: N выводится как 33
}
```

Конструкция `X<N>::I`, которая находится в шаблоне функции `fppm ()`, является невыводимым контекстом; однако использующийся в ней компонент `X<N>` члена класса с типом указателя на член класса является выводимым контекстом. Когда выведенный из этого компонента параметр `N` подставляется в невыводимый контекст, получается тип, совместимый с типом фактического аргумента (`&Х<33>:: f`). Таким образом, для этой пары “аргумент-параметр” вывод удается успешно выполнить до конца.

И наоборот, если параметр типа состоит только из выводимого контекста, то это еще не означает, что вывод не приведет к противоречиям. Например, предположим, что у нас имеются надлежащим образом объявленные шаблоны классов `X` и `Y`. Рассмотрим приведенный ниже код.
```c++
template<typename Т>
void f(X<Y<T>, Y<T>>);

void g()
{
	f(X<Y<int>, Y<int>>());      // OK
	f(X<Y<int>, Y<char>>());     // Ошибка: неудачный вывод
}
```

Проблема, связанная со вторым вызовом шаблона функции `f()`, заключается в том, что для параметра `Т` на основе двух аргументов функции выводятся разные типы, что приводит к противоречию. (В обоих вызовах аргументы функции являются временными объектами, полученными путем вызова конструктора по умолчанию для шаблона класса `X`.)

# Особые ситуации вывода

Возможны несколько ситуаций, в которых использующаяся для вывода пара `(Р, А)` получается не из аргументов вызова функции и параметров шаблона функции. Первая ситуация осуществляется, когда используется адрес шаблона функции. В этом случае `Р` — это параметризованный тип объявления шаблона функции, а `A` — тип функции, на которую ссылается инициализируемый указатель или указатель, которому присваивается значение. Например:
```c++
template<typename Т>
void f(Т, Т);
void (*pf)(char, char) = &f;
```

В этом примере `Р` — `void (Т, Т)`, а `A` — `void (char, char)`. Вывод успешен, при этом `Т` заменяется на `char`, a `pf` инициализируется адресом специализации `f<char>`.

Аналогично типы функций для `Р` и `A` используются и в некоторых других особых ситуациях.
>
> Определение частичного упорядочения между перегруженными шаблонами функций.
> 
> Соответствие явной специализации шаблону функции.
>
> Соответствие явного инстанцирования шаблону.
> 
> Соответствие шаблону специализации шаблона дружественной функции.
> 
> Соответствие шаблонов размещающих операторов `operator delete` или `operator delete[]` соответствующим шаблонам размещающих операторов `operator new` или `operator new []`.



















