
[[#Очереди команд|Очереди команд]] 5


# Очереди команд

Для управления исполнением ядер на устройствах хост-программа создаёт специальные структуры данных, именуемые очередями команд (command queue). Примеры команд, направляемых в очередь: команды исполнения ядер, команды памяти (для перемещения данных в объекты памяти, из них или между ними), а также команды синхронизации, управляющие порядком исполнения команд.

Создаётся очередь команд путём вызова функции [[clCreateCommandQueue|clCreateCommandQueue()]] с указанием нужного контекста `context` , конкретного устройства `device` и свойств очереди `properties`.

Возвращает функция в случае успешного исполнения дескриптор очереди команд и статус исполнения `CL_SUCCESS` — через указатель `errcode_ret` ; в противном случае через этот указатель возвращается код ошибки (либо недействительности какого-либо из переданных параметров — `CL_INVALID_CONTEXT`, `CL_INVALID_DEVICE`, `CL_INVALID_QUEUE_PROPERTIES`, `CL_INVALID_VALUE`, либо нехватки памяти на хосте — `CL_OUT_OF_HOST_MEMORY`). Часто при вызове свойства очереди отсутствуют вообще, поскольку они нужны лишь в специальных случаях (и могут поддерживаться не всеми устройствами):

```c++
cl_command_queue que = clCreateCommandQueue(ctx, dev_id, 0, &ret);
```

Возможные значения свойств очереди: `CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE` — разрешить непоследовательное (out-of-order) исполнение — и `CL_QUEUE_PROFILING_ENABLE` — разрешить профилирование (замер времени исполнения) команд в очереди.

Команды исполняются между хостом и устройствами асинхронно: хост-программа получает управление после вызова функции помещения команды в очередь, не дожидаясь завершения исполнения команды. Относительно же друг друга команды могут исполняться по порядку (запускаются и завершаются в порядке расположения в очереди) или непоследовательно (запускаются в порядке следования, но не ждут завершения предыдущей команды). В последнем случае должны явно использоваться команды синхронизации. 

Начиная с OpenCL 2.0 функция [[clCreateCommandQueue|clCreateCommandQueue()]] объявлена «нежелательной», вместо неё предлагается использовать [[clCreateCommandQueueWithProperties|clCreateCommandQueueWithProperties()]].

После использования очереди команд должны освобождаться с помощью функции [[clReleaseCommandQueue|clReleaseCommandQueue()]]
```c++
cl_int clReleaseCommandQueue (cl_command_queue command_queue );
```

ей при вызове передаётся как параметр уже ненужная очередь команд `command_queue` .

Начиная с версии OpenCL 1.2 появляется также функция [[clRetainCommandQueue|clRetainCommandQueue()]]:
```c++
cl_int clRetainCommandQueue (cl_command_queue command_queue );
```

Получить информацию об очереди `command_queue` можно с помощью функции [[clGetCommandQueueInfo|clGetCommandQueueInfo]]

указывая вид информации `param_name` ; в остальном всё аналогично рассмотренной выше функции [[clGetContextInfo|clGetContextInfo()]]: её тоже следует вызывать дважды для каждого `param_name`.



















