
[[#Работа с кодом ядра|Работа с кодом ядра]]

# Работа с кодом ядра

Ядра в `OpenCL-программах` пока присутствуют в виде исходного текста: либо как отдельные файлы с расширением `.cl`, либо как текстовые строки в рамках самой программы. Процесс подготовки такого исходного текста к виду, в котором ядро может быть исполнено на устройстве, целиком лежит на программисте (в отличие от ситуации в `CUDA`, где ядра хотя и компилируются другим компилятором, но происходит это невидимым для пользователя образом).

Первым делом исходный текст ядра размещается в памяти, поскольку функция `OpenCL` [[clCreateProgramWithSource|clCreateProgramWithSource()]], начинающая весь процесс, ожидает в качестве одного из своих параметров указание на C-строки с текстом; если исходный текст находится в файле, его содержимое считывается в память. Другие параметры, которые понадобится указать при вызове — это контекст, параметры представления текста в виде массива указателей на строки (размер этого массива и сопутствующий массив длин строк) и указатель для возвращения кода ошибки.

Применяемый тут способ указания строк является достаточно гибким: можно поместить исходный текст в одну строчку, либо прочесть (или сформировать) исходный текст из нескольких строк. Если, например, используется первый вариант, то параметры вызова будут особенно просты:
```c++
cl_program prg = clCreateProgramWithSource(ctx, 1, &src, NULL, &err);
```

Здесь `ctx` — контекст, `1` — это количество C-строк текста (одна), `src` — указывает на единственный указатель на эту C-строку, а сама строка завершается нулевым символом, поскольку массив длин не указан (значение параметра `NULL`).

Далее программный объект подвергается «построению» с помощью вызова функции [[clBuildProgram|clBuildProgram()]]: компилируется и линкуется для получения исполняемого на устройстве кода.

Параметров, которые здесь передаются, довольно много, однако в простейшем случае можно обойтись построением программы по умолчанию, т.е., построить для всех устройств, без дополнительных параметров компиляции и линковки, а также без функции обратного вызова и её данных:
```c++
err = clBuildProgram(prg, 0, NULL, NULL, NULL, NULL);
```
Смысл этих параметров таков. Для построения исполняемого кода ядер необходимо указать программный объект `prog` , полученный на предыдущем шаге (здесь различаются и по-разному выделены имя фиктивного параметра `prog` в прототипе функции и реально используемая при вызове величина `prg`); задать — если это необходимо — список устройств `device_list` , для которых должно быть осуществлено построение, и количество этих устройств ``num_devices`` (иначе производится построение для всех устройств, связанных с программой); перечислить дополнительные опции `options` компиляции и линковки (фактически — параметры командной строки компилятора и линкера); задать — если требуется —  адрес нотифицирующей функции, которая будет вызвана после завершения построения с передаваемыми ей значениями `prog` и `udata` в качестве необходимых параметров.

Если адрес такой нотифицирующей функции не указывается и вместо него передаётся `NULL`, возврат из функции производится только после завершения построения.

В случае возникновения каких-либо ошибок (возвращаемых здесь в переменную с именем `err`) необходимо дополнительно вызвать функцию [[clGetProgramBuildInfo|clGetProgramBuildInfo()]] со специальным флагом `CL_PROGRAM_BUILD_LOG`, причём лучше всего дважды: сначала для определения размеров возвращаемого лога:
```c++
clGetProgramBuildInfo(prg, d_id, CL_PROGRAM_BUILD_LOG, 0, NULL, &l_size);
```

а затем — после выделения для него необходимой памяти — для получения собственно лога:
```c++
clGetProgramBuildInfo(prg, d_id, CL_PROGRAM_BUILD_LOG, l_size, log, NULL);
```

Вообще же эта функция используется для получения информации о процессе построения для конкретного устройства (статуса процесса, опций построения и содержимого лога).

В случае использования реализации OpenCL от Apple можно вывести лог построения на консоль путём установки переменной окружения `CL_LOG_ERRORS=stdout` или добавления этой информации в комадной строке запуска OpenCL-приложения.

При работе в системе Windows можно также использовать специальную утилиту `clcc.exe`, позволяющую компилировать ядра отдельно от самого приложения прямо с командной строки (подробности её использования можно будет найти далее); сообщения об ошибках будут выведены на консоль.

Важным шагом всей процедуры работы с ядрами программы будет создание объектов ядра для каждого присутствующего в исходном коде ядра с помощью [[clCreateKernel|clCreateKernel()]]:

Если ядро только одно, понадобится один вызов, где надо указать имя ядра (`kname`).
```c++
cl_kernel krnl = clCreateKernel(prg, kname, &err);
```

В случае нескольких ядер в программе делается столько вызовов этой функции, сколько имеется ядер в программе, — каждый со своим значением параметра имени ядра.

Поскольку ядрам почти всегда нужна дополнительная информация (это те параметры, которые перечислены при определении как параметры функции ядра), следует перед запуском каждого ядра передать необходимые значения этих параметров. Осуществляется это с помощью функции [[clSetKernelArg|clSetKernelArg()]], вызываемой требуемое число раз (возвращаемым значением является код ошибки или признак успешного выполнения).

Ограничения. Если какие-то параметры сопровождаются квалификатором `__constant`, то следует позаботиться о том, чтобы размеры отдельных объектов памяти не превышали значения `CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE`, а количество таких параметров — величины `CL_DEVICE_MAX_CONSTANT_ARGS` (чтобы не произошло выхода за пределы имеющейся константной памяти).

Запуск ядер на исполнение производится функцией [[clEnqueueNDRangeKernel|clEnqueueNDRangeKernel()]], кото-
рой в качестве одного из параметров указывается «размер задачи».

После использования объектов-ядер их полагается «отпустить» (реально уменьшается счётчик ссылок на каждый объект ядра) с помощью функции
```c++
cl_int clReleaseKernel (cl_kernel kernel );
```
