
[[#Определение наличия платформ и устройств|Определение наличия платформ и устройств]] 2

# Определение наличия платформ и устройств

Для опроса имеющихся OpenCL-платформ используется функция [[clGetPlatformIDs|clGetPlatformIDs()]]

Часто она вызывается приложением дважды. Первый вызов использует лишь указатель `num_platforms` на переменную, куда возвращается количество обнаруженных платформ;  параметры `num_entries` и `platforms` при этом принимают «неопределённые» значения 0 и `NULL` соответственно.

```c++
cl_uint nP;  
cl_uint status = clGetPlatformIDs(0, NULL, &nP);
```

Если обратиться к описанию функции [[clGetPlatformIDs|clGetPlatformIDs()]] в спецификации OpenCL `https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetclGetPlatformIDs.html` ,  то можно заметить, что возможно возвращение ошибки `CL_INVALID_VALUE` в случае передаваемых нулевого значения `num_entries` и при этом ненулевого значения `platforms`, что выглядит спорно, поскольку по приводимому там же описанию первый параметр задаёт количество идентификаторов для возвращения в массив, заданный вторым параметром, а, значит,   пользователь вполне может счесть допустимым подготовить массив для идентификаторов, но (скажем, временно) ничего не считывать туда.

Как только количество платформ становится известно, выделяется память под заданное число идентификаторов:
```c++
cl_platform_id *pfs = new cl_platform_id[nP];
```
и функция вызывается повторно, при этом передаётся указатель на массив величин типа `cl_platform_id` и его размер (в этих величинах); указатель `num_platforms` при этом уже   не нужен и его значение передаётся равным `NULL`:
```c++
status = clGetPlatformIDs(nP, pfs, NULL);
```

После этого функция [[clGetPlatformInfo|clGetPlatformInfo()]] позволяет получить более детальную информацию об OpenCL-платформе (профиль, версия, имя, изготовитель и список расширений)

Для заданной платформы `platform` указывается тип необходимой дополнительной информации `prm_name` (с помощью заранее предопределённых констант #CL_PLATFORM_PROFILE, #CL_PLATFORM_VERSION, #CL_PLATFORM_NAME, #CL_PLATFORM_VENDOR, #CL_PLATFORM_EXTENSIONS);  остальные параметры используются в описанном выше стиле «двойного вызова»:
```c++
size_t size;  
char *str;  

clGetPlatformInfo(pfs[i], ..., 0, NULL, &size);

str = new char [size];  
clGetPlatformInfo(pfs[i], ..., size, str, NULL);
```
Когда доступные OpenCL-платформы известны, можно проанализировать, какие в них имеются OpenCL-устройства. Для этого используется функция [[clGetDeviceIDs#clGetDeviceIDs|clGetDeviceIDs()]], аналогичная функции [[clGetPlatformIDs|clGetPlatformIDs()]], но принимающая дополнительные параметры:  конкретную платформу `platform` и желательный тип устройства ( #CL_DEVICE_TYPE_GPU,  #CL_DEVICE_TYPE_CPU и др. либо #CL_DEVICE_TYPE_ALL).

Для каждого устройства эту функцию обычно тоже вызывают дважды, например:
```c++
status = clGetDeviceIDs(pfs[i], CL_DEVICE_TYPE_ALL, 0, NULL, &nD); 

devs = new cl_device_id[nD]; 
status = clGetDeviceIDs(pfs[i], CL_DEVICE_TYPE_ALL, nD, devs, NULL);
```
Далее можно воспользоваться функцией [[clGetDeviceInfo#clGetDeviceInfo|clGetDeviceInfo()]] — чтобы получить сведения об имени, типе и изготовителе для каждого устройства, а также их многочисленных  дополнительных параметрах и возможностях — аналогично функции [[clGetPlatformInfo#clGetPlatformInfo()|clGetPlatformInfo()]]:  

Более профессиональной программой аналогичного назначения является `clinfo.c`.   Она написана (как утверждается) на C99, что позволяет откомпилировать её практически  для любой системной платформы. Кроме того, в ней предприняты меры для  «устойчивой»  работы в условиях недоступности каких-либо из опрашиваемых свойств. Следует также отметить, что её название совпадает с названием стандартной программы (clinfo) такого же назначения для систем Linux.
