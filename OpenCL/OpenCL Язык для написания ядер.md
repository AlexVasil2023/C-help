
[[#Язык для написания ядер|Язык для написания ядер]] 8
1. [[#Встроенные скалярные типы данных|Встроенные скалярные типы данных]] 8.1
2. [[#Встроенные векторные типы данных|Встроенные векторные типы данных]] 8.2
3. [[#Другие встроенные типы данных|Другие встроенные типы данных]] 8.3
4. [[#Векторные литералы|Векторные литералы]] 8.4
5. [[#Компоненты векторов|Компоненты векторов]] 8.5
6. [[#Преобразования и приведение типов|Преобразования и приведение типов]] 8.7
7. [[#Операторы|Операторы]] 8.8
8. [[#Квалификаторы|Квалификаторы]] 8.9
9. [[#Встроенные функции|Встроенные функции]] 8.10

# Язык для написания ядер

Исполняемые на OpenCL-устройствах ядра пишутся на языке программирования `OpenCL C` (OpenCL C Programming Language), который основывается на спецификации языка C 1999 года (т.н. C99) со специфическими расширениями и ограничениями. Расширения включают новые типы данных (в том числе векторные), ключевые слова, дополнительные квалификаторы, а также набор функций (математические, геометрические, отношения, чтения/записи для векторов и др.). Ограничения касаются: работы с указателями (из-за наличия разных адресных пространств), отсутствия возможности работать с битовыми полями, массивами переменной длины, рекурсией и спецификаторами класса хранения (`extern`, `static`, `auto`, `register`). Также недоступны предопределённые идентификаторы и ставшие привычными стандартные заголовочные файлы а, стало быть, и объявляемые в них функции.

Излагаемое далее соответствует спецификации `OpenCL 1.1` (если явно не указано иное), поскольку именно эта версия доступна для экспериментов в дисплейном классе 5-42.

# Встроенные скалярные типы данных

Список встроенных типов скалярных данных содержит как привычные в рамках C типы (`bool`, `char`, `unsigned char`, `short`, `unsigned short`, `int`, `unsigned int`, `long`, `unsigned long`, `float`, `void`), так и «сокращённые» варианты для беззнаковых типов (`uchar`, `ushort`, `uint`, `ulong`), а также дополнительно: `half` («облегчённый» вариант вещественных значений, занимающий 16 бит), `size_t` (целое без знака для результата операции `sizeof`), `ptrdiff_t` (целое со знаком для результата вычитания двух указателей), `intptr_t` (тип целое со знаком, такой, что указатель на `void` может быть преобразован к нему и обратно без изменений в значении указателя), `uintptr_t` (тип целое без знака, аналогичный по свойствам предыдущему). Все типы с суффиксом `_t` в именах имеют размер, определяемый значением свойства `CL_DEVICE_ADDRESS_BITS` у конкретного OpenCL-устройства (32 бита или 64 бита).

Использование в коде ядер синонимов для беззнаковых типов, вероятно, объясняется тем, что для подобных имён типов из одного слова легко образовать векторные варианты этих типов: `uint2`, `uint3`, `uint4`, `uint8`, `uint16`, — аналогично `float2`, `float3`, `float4` и т.д.

Большая часть встроенных скалярных типов имеет аналоги, определённые в заголовочных файлах `OpenCL` и используемые в качестве параметров функций API : `cl_char`, `cl_uchar`, `cl_short`, `cl_ushort`, `cl_int`, `cl_uint`, `cl_long`, `cl_ulong`, `cl_float`, `cl_half`.

Тип данных `half` должен соответствовать стандарту IEEE 754-2008. Числа этого типа используют один знаковый бит, 5 бит экспоненты и 10 бит мантиссы. Смещение экспоненты равно 1. В этом типе данных могут быть представлены обычные вещественные числа, а также денормализованные числа, бесконечности и не-числа (`NaN`).

Тип данных half может быть использован только для объявления указателя на буфер с такими величинами. Загрузка и выгрузка этих величин по указателю должна выполняться с использованием функций `vload_half`, `vload_halfn` , `vloada_halfn` и `vstore_half`, `vstore_halfn` , `vstorea_halfn` (здесь `n` обозначает одно из чисел 2,3,4,8,16).

Следует отметить, что тип `half (halfn)` определён только тогда, когда поддерживается расширение `cl_khr_fp16` (подробности излагаются далее).

# Встроенные векторные типы данных

В коде ядер поддерживаются векторные типы `charn`, `ucharn`, `shortn`, `ushortn`, i`ntn`, `uintn`, `longn`, `ulongn`, `floatn`, где `n` обозначает одно из чисел `2`, `3`, `4`, `8`, `16`. Соответствующие им типы для приложений называются `cl_charn`, `cl_ucharn`, `cl_shortn`, `cl_ushortn`, `cl_intn`, `cl_uintn`, `cl_longn`, `cl_ulongn`, `cl_floatn` (завершающее `n` по-прежнему обозначает `2`, `3`, `4`, `8` или `16`).

# Другие встроенные типы данных

Список дополнительных типов данных в коде ядер: `image2d_t` (двумерное изображение), `image3d_t` (трёхмерное изображение), `sampler_t` (т.н. сэмплер), `event_t` (событие). Подробнее типы изображения и сэмплеры обсуждаются ниже.

Замечание. Первые три типа определены, если устройство поддерживает объекты изображения, т.е., значение свойства `CL_DEVICE_IMAGE_SUPPORT` равно `CL_TRUE`.

Некоторые имена типов данных пока не используются, но зарезервированы на будущее, а потому не могут использоваться как имена типов (например, приводимые выше векторные типы, для которых `n` не есть `2`, `3`, `4`, `8`, `16`, а также некоторые другие; полный список имеет смысл посмотреть в спецификации `OpenCL` в разделе Reserved Data Types).

Данные, располагающиеся в памяти всегда являются выравненными на размер своего типа; для трёхкомпонентных векторов их размер и выравнивание совпадают с таковыми для четырёхкомпонентных.

# Векторные литералы

Они могут быть использованы для создания векторов из списка скаляров, векторов или их смеси. Векторный литерал может быть инициализатором вектора или просто выражением, но не может использоваться как [[rvalue|l-value]].

Векторный литерал записывается как векторный тип с круглыми скобками, за которым следует список параметров в круглых скобках. Это чем-то напоминает перегруженную функцию, только варианты, допустимые здесь, — набор аргументов, в котором все аргументы имеют один и тот же тип элемента, а общее число элементов равно количеству элементов результирующего вектора. Например, для `float4` допустимы такие варианты:
```c++
(float4)(float, float, float, float)
(float4)(float2, float, float)
(float4)(float, float2, float)
(float4)(float, float, float2)
(float4)(float2, float2)
(float4)(float3, float)
(float4)(float, float3)
(float4)(float)
```

В последнем случае показан вариант с одним скалярным параметром и этот параметр реплицируется на весь вектор.

Примеры:
```c++
float4 f = (float4)(1.0f, 2.0f, 3.0f, 4.0f);
uint4 u = (uint4)(1); // u будет равно (1, 1, 1, 1)
float4 g = (float4)((float2)(1.0f, 2.0f),(float2)(3.0f, 4.0f));
float4 h = (float4)(1.0f, (float2)(2.0f, 3.0f), 4.0f);
```

# Компоненты векторов

Компоненты векторных типов с двумя, тремя и четырьмя компонентами достижимы с помощью имён компонент `.x`, `.y`, `.z` и `.w`. Чем больше у вектора компонент, тем больше имён используется, начиная с `.x`.

Синтаксис выбора компонент позволяет быть выбранным сразу многим компонентам — просто перечислением их после точки — даже в случае присваивания:
```c++
float4 c;
c.xyzw = (float4)(1.0f, 2.0f, 3.0f, 4.0f);
c.z = 1.0f;
c.xy = (float2)(3.0f, 4.0f);
c.xyz = (float3)(3.0f, 4.0f, 5.0f);
```

Также синтаксис выбора компонент позволяет им быть переставленными или продублированными:
```c++
float4 pos = (float4)(1.0f, 2.0f, 3.0f, 4.0f);
float4 swiz = pos.wzyx; // swiz = (4.0f, 3.0f, 2.0f, 1.0f)
float4 dup = pos.xxyy; // dup = (1.0f, 1.0f, 2.0f, 2.0f)
```

В случае использования обозначения группы компонент в качестве [[rvalue|l-value]] не должно быть дублирования компонент, неправильной размерности векторов и несоответствия между числом компонент в группе и размерностью вектора справа:
```c++
pos.xx = (float2)(3.0f, 4.0f); // компонента ’x’ использована дважды

// Недопустимо --- компонента a.xxxxxxx не является допустимым типом
x = (float16)(a.xxxxxxx, b.xyz, c.xyz, d.xyz);

// Недопустимо, т.к. имеется рассогласование между float2 и float4
pos.xy = (float4)(1.0f, 2.0f, 3.0f, 4.0f);
```

Элементы вектора могут также адресоваться с помощью числового индекса (например, для 16-компонентного вектора можно применять в качестве индексов шестнадцатиричные цифры: `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `a`, `A`, `b`, `B`, `c`, `C`, `d`, `D`, `e`, `E`, `f`, `F`), при этом числовому индексу должен предшествовать символ `s` или `S`. Перемешивать имена компонент с числовыми индексами при этом нельзя, должно использоваться что-то одно.

Векторные типы данных также могут использовать суффиксы `.lo`, `.even`, `.hi`, `.odd` для считывания частей величин векторных типов или комбинирования частей в «больший» тип. Суффикс `.lo` относится к младшей половине вектора, суффикс `.hi` — к старшей. Суффиксы `.even` и `.odd` относятся к чётным или нечётным элементам векторов соответственно.

Иллюстрирующие сказанное примеры:
```c++
float4 vf;

float2 low = vf.lo;    // считывается vf.xy
float2 high = vf.hi;   // считывается vf.zw

float2 even = vf.even; // считывается vf.xz
float2 odd = vf.odd;   // считывается vf.yw
```

Ещё один пример из спецификации OpenCL, иллюстрирующий реализацию транспонирования матрицы `4 × 4` с помощью индексов и суффиксов:
```c++
// транспонировать матрицу 4x4
void transpose(float4 m[4])
{
	// матрица считывается в вектор float16
	float16 x = (float16)(m[0], m[1], m[2], m[3]);
	float16 t;

	// транспонирование
	t.even = x.lo; t.odd = x.hi;
	x.even = t.lo; x.odd = t.hi;

	// запись в исходную матрицу
	m[0] = x.lo.lo; // m[0][0], m[1][0], m[2][0], m[3][0]
	m[1] = x.lo.hi; // m[0][1], m[1][1], m[2][1], m[3][1]
	
	m[2] = x.hi.lo; // m[0][2], m[1][2], m[2][2], m[3][2]
 	m[3] = x.hi.hi; // m[0][3], m[1][3], m[2][3], m[3][3]
}
```

Ну, и напоследок надо сказать, что операция взятия адреса элемента вектора приведёт к возникновению ошибки компиляции.

# Преобразования и приведение типов

В языке OpenCL C между встроенными типами поддерживаются неявные преобразования типов (исключением являются типы `void` и `half` — если последний не поддерживается). Неявные преобразования между встроенными векторными типами не разрешены, а для указателей применяются правила, описанные в спецификации C99.

Приведение типа для встроенных скалярных типов выполняет соответствующее преобразование (кроме случаев `void` и `half`, если последний не поддерживается). Явные приведение типов между векторными типами невозможно. Преобразование скаляра к вектору может быть выполнено приведением типа скаляра к желательному векторному типу. При этом выполняются и необходимые арифметические преобразования. Для преобразования к встроенному целочисленному векторному типу будет использоваться округление к нулю, для преобразования к вещественным векторным типам — текущий режим округления. Приведение булевской величины к целочисленному вектору создаст вектор с компонентами, равными − 1 (все биты установлены), если булевская величина имеет истинное значение, или 0 — в противном случае.
```c++
float f = 1.0f;
float4 va = (float4)f;  // va-вектор типа float4 с элементами 
						// (f, f, f, f)

uchar u = 0xFF;
float4 vb = (float4)u;  // vb -- такой же вектор с элементами 
						// ((float)u,(float)u,(float)u,(float)u)

float f = 2.0f;
int2 vc = (int2)f;      // vc -- вектор типа int2 с элементами 
						// ((int)f, (int)f)
						
uchar4 vtrue = (uchar4)true; // vtrue -- вектор типа uchar4 с элементами
						// (0xff, 0xff, 0xff, 0xff)
```

Явные преобразования типов осуществляются набором функций с именами, подобными `convert_<ТипРезультата >(<Тип >)` для поддерживаемых типов — за исключением `bool`, `half`, `size_t`, `ptrdiff_t`, `intptr_t`, `uintptr_t` и `void`. При этом количество элементов в исходном и результирующем векторах должно быть одинаковым.

Поведение преобразования типов может быть модифицировано одним или двумя (необязательными) модификаторами, указывающими насыщение для выходящих за границы диапазона величин и округляющее поведение. Полная форма скалярной функции преобразования:
```c++
<ТипРезультата> convert_<ТипРезультата>[_sat][<_РежимОкругления>](<Тип >)
```

Полная форма векторной функции преобразования:
```c++
<ТипРезультата> convert_<ТипРезультата>n[_sat][<_РежимОкругления>](<Тип >)
```

Модификаторы режимов округления: **`_rte`** (к ближайшему чётному), **`_rtz`** (к нулю), **`_rtp`** (к плюс бесконечности), **`_rtn`** (к минус бесконечности).

По умолчанию (при отсутствии модификатора округления) применяется округление к нулю при преобразовании к целому значению и текущий режим округления — при преобразовании к вещественному значению. В настоящее время, правда, поддерживается только один режим округления к вещественным значениям — округление к ближайшему чётному.

Преобразование к целому в режиме насыщения ограничивает значения выходящих за разрешённый диапазон величин ближайшими представимыми из диапазона. Не-числа (`NaNs`) превращаются в 0.
```c++
short4 s;

// отрицательные величины "схлопываются" в 0
ushort4 u = convert_ushort4_sat(s);

// величины, большие CHAR_MAX, становятся CHAR_MAX
// величины, меньшие CHAR_MIN, становятся CHAR_MIN
char4 c = convert_char4_sat(s);
```

# Операторы

Арифметические операции сложения, вычитания, умножения и деления применимы к целым и вещественным скалярным величинам, а также к векторным. Взятие остатка (`%`) применимо только к целым скалярным и векторным величинам. Все арифметические операции дают результат того же встроенного типа, что и типы операндов — возможно, после преобразования типа. Если оба операнда — скаляры, результат операции — скаляр. Если один из операндов скаляр, а другой — вектор, то скаляр «расширяется» к вектору и операция осуществляется покомпонентно, давая вектор того же размера. Если оба операнда — векторы (должны быть одного типа), то результат получается покомпонентной операцией и даёт вектор такого же размера.

Деление целых, приводящее к величинам за пределами представимого диапазона, не генерирует исключительную ситуацию и даёт неопределённый результат; это же справедливо и для деления на `0` для целых. Для вещественных величин деление на `0` даёт либо плюс или минус бесконечность, либо `NaN` — как это предписывается стандартом IEEE-754.

Следует учитывать, что результаты операций над операндами со знаком и без знака приводят к результатам со знаком; операции с логическим результатом для скаляра дают `0` в случае `false`-результата и `1`, если результат — `true`. Для векторных типов получается `0`, если результат — `false`, и −`1` (т.е., все биты установлены), если результат — `true`.

Оператор `sizeof` выдаёт величину операнда в байтах — включая дополнительные байты, необходимые для правильного выравнивания. Результат определяется типом операнда и имеет специальный тип `size_t`.

Поведение `sizeof` применительно к величинам типов `bool`, `image2d_t`, i`mage3d_t`, `sampler_t` и `event_t` не стандартизовано и зависит от реализации.

К типу `half` никакие операции кроме `sizeof` неприменимы.

Векторные операции осуществляются покомпонентно; скалярные операнды приводятся к векторам.

# Квалификаторы

***===Квалификаторы адресного пространства===***

Поскольку OpenCL определяет раздельные адресные пространства, обозначаемые квалификаторами **`__global`**, **`__local`**, **`__constant`**, **`__private`**, указатели из одного адресного пространства не могут быть приведены к указателям из другого адресного пространства. Локальные переменные и аргументы функций располагаются в адресном пространстве `__private`. Параметры функции-ядра, являющиеся указателями, могут указывать только
на адресные пространства `__global`, `__local` или `__constant`. Аргументы функций, имеющие тип `image2d_t` или `image3d_t`, ссылаются на объекты памяти в адресном пространстве `__global`. Все переменные из области действия программы-ядра должны быть объявлены в адресном пространстве `__constant`.

Квалификатор `__local` используется для описания переменных, разделяемых всеми рабочими единицами в рабочей группе. Указатели на адресное пространство `__local` допустимы в качестве параметров функций, включая функции-ядра. Переменные, объявляемые в адресном пространстве `__local`, должны появляться в блоке функции-ядра, но не во вложенных блоках. Они выделяются для каждой рабочей группы, исполняющей ядро, и существуют только во время исполнения этого ядра рабочей группой; инициализировать их нельзя.

Адресное пространство `__constant` используется для описания переменных в глобальной памяти, доступных из ядра всех рабочим единицам во время его исполнения, — но только для чтения. Такие переменные должны инициализироваться и величины, используемые для инициализации, должны быть константами времени компиляции.

Переменные в функции ядра, не помеченные никаким квалификатором адресного пространства, считаются находящимися в адресном пространстве `__private`. Переменные, объявленные как указатели, считаются указывающими на пространство `__private`, если при них нет квалификатора адресного пространства.

***===Квалификаторы доступа===***

Объекты изображений, указываемые в качестве параметров функции ядра, могут быть объявлены доступными только для чтения (`__read_only`, `read_only`) или только для записи (`__write_only`, `write_only`). По умолчанию объекты изображений являются доступными только для чтения.

***===Квалификатор функций kernel===***

Этот квалификатор объявляет функцию ядром, которое исполняется приложением на OpenCL-устройствах. Ядро может быть вызвано также другим ядром как обыкновенная функция. Ядра, имеющие переменные из адресного пространства `__local`, могут быть вызваны с хоста с помощью функций [[clEnqueueNDRangeKernel|clEnqueueNDRangeKernel()]] и [[clEnqueueTask|clEnqueueTask()]].

# Встроенные функции

***===Функции для работы с рабочими единицами===***

Напомним, что каждая рабочая единица в `OpenCL` является частью `1-`, `2-`, `3-`мерной рабочей группы, которая, в свою очередь, — часть `1-`, `2-`, `3-`мерного набора рабочих групп (`NDRange`).

Для идентификации рабочих единиц в исходном коде ядер используются различные функции, позволяющие получать их индексы, а также размеры как рабочих групп, так и всего их набора по различным имеющимся измерениям.

Используемое число измерений, величина параметра `work_dim` при вызове функции [[clEnqueueNDRangeKernel|clEnqueueNDRangeKernel()]].
```c++
uint get_work_dim ()
```

Количество глобальных рабочих единиц по заданному измерению `dimindx`.
```c++
size_t get_global_size (uint dimindx)
```

Уникальный глобальный индекс рабочей единицы по заданному измерению `dimindx`.
```c++
size_t get_global_id (uint dimindx)
```

Количество локальных рабочих единиц по заданному измерению `dimindx`.
```c++
size_t get_local_size (uint dimindx)
```

уникальный локальный индекс рабочей единицы по заданному измерению `dimindx`.
```c++
size_t get_local_id (uint dimindx)
```

Количество рабочих групп, исполняющих ядро, по заданному измерению `dimindx`.
```c++
size_t get_num_groups (uint dimindx)
```

Идентификатор рабочей группы по заданному измерению `dimindx`.
```c++
size_t get_group_id (uint dimindx)
```

Величина смещения, указанная в параметре `global_work_offset`, — по заданному измерению `dimindx` — при вызове функции [[clEnqueueNDRangeKernel|clEnqueueNDRangeKernel()]].
```c++
size_t get_global_offset (uint dimindx)
```

***===Математические и некоторые другие функции===***

Несмотря на то, что в OpenCL C нет заголовочного файла `math.h`, большая часть функций, упоминаемых в нём (плюс ещё некоторые), доступны в коде ядер, причём они принимают в качестве параметров часто не только скалярные (`float`), но и векторные величины (`floatn` , где `n` = `2`, `3`, `4`, `8`, `16`). Кроме того, имеются варианты некоторых из этих функций с префиксами `half_` и `native_`: первые имеют ограниченную точность (16 бит) и малый диапазон (но работают быстрее); вызовы вторых отображаются в инструкции конкретного устройства, давая максимальный выигрыш в скорости — возможно, за счёт точности.

Среди других функций: целые (`abs`, `abs_diff`, `add_sat`, `clz`, `hadd`, `mad_hi`, `mad_sat`, `max`, `min`, `mul_hi`, `rhadd`, `rotate`, `sub_sat`, `upsample` и две «быстрые» — `mad24` и `mul24`); общие (`clamp`, `degrees`, `max`, `min`, `mix`, `radians`, `sign`, `step`, `smoothstep`); геометрические (`cross`, `dot`, `distance`, `length`, `normalize` и `fast_`-варианты трёх последних); функции отношения (работают со скалярными и векторными встроенными типами и формируют скалярный или векторный целочисленный результат со знаком); функция синхронизации `barrier` (все рабочие единицы в группе должны вызвать эту функцию — прежде чем любой из них будет разрешено продолжить исполнение кода после этой функции); функции загрузки `vloadn` и выгрузки `vstoren` (позволяют читать и записывать векторные типы данных по указателю памяти), а также их варианты с суффиксом `_half` и с дополнительными суффиксами режима округления и некоторые другие.

Более детальную информацию о них имеет смысл смотреть в спецификациях OpenCL (1.0 , 1.1 , 1.2 , 2.0 , 2.1 , 2.2 ).
