
[[#Контекст|Контекст]] 4

# Контекст

Как уже говорилось выше, контекст в `OpenCL` — это некоторое окружение, в котором исполняются специальные программные объекты `OpenCL` (т.н. ядра). Контекст включает в себя набор `OpenCL-устройств`, на которых будет производиться исполнение ядер, сами программные объекты с их исходными кодами и содержащимися там `OpenCL-функциями`, а также некоторый набор объектов памяти, видимых и хосту, и `OpenCL-устройствам`, — там содержатся величины, с которыми могут работать ядра.

***Контекст*** OpenCL создаётся с помощью одной из двух функций: [[clCreateContext|clCreateContext()]] или [[clCreateContextFromType|clCreateContextFromType()]]:

Помимо имени эти функции различаются только тем, что первая создаёт контекст для указанной последовательности устройств `devices`, используя заданное число устройств `num_devices`, а вторая — контекст для устройств определённого типа `device_type` (CPU, GPU, ускоритель; возможно также указание всех устройств или устройства по умолчанию) . В остальном они принимают совершенно одинаковые параметры: указатель `properties` на массив свойств контекста, указатель `pfn_notify` на функцию обратного вызова (со своим списком параметров), указатель `user_data` на пользовательские данные, если они будут необходимы для функции обратного вызова. Возможные ошибочные ситуации при вызове любой из функций создания контекста фиксируются в переменной типа `cl_int`, указатель на которую передаётся через последний параметр `errcode_ret `.

Несмотря на кажущееся довольно большим число параметров в этих функциях, реально их вызовы чаще всего не используют ни массив свойств контекста, ни функцию обратного вызова вместе с пользовательскими данными для неё, поэтому, скажем, создание контекста для конкретного устройства с уже известным дескриптором `device` может выглядеть так:
```c++
cl_context Ctx = clCreateContext(NULL, 1, &device, NULL, NULL, &err);
```

Здесь `err` — это переменная, куда в случае неудачи при создании контекста попадёт код ошибки (возможны: общие для обеих функций `CL_INVALID_PLATFORM`, `CL_INVALID_VALUE`, `CL_DEVICE_NOT_AVAILABLE`, `CL_OUT_OF_HOST_MEMORY`, а также `CL_INVALID_DEVICE` — для первой функции и `CL_DEVICE_NOT_FOUND`, `CL_INVALID_DEVICE_TYPE` — для второй).

```
Замечание. Реализация OpenCL от NVidia очень «не любит» вызов создания контекста по типу, если первый параметр в вызове функции  lCreateContextFromType() отсутствует:
```

```c++
cl_context Ctx = clCreateContextFromType(NULL, <Тип >, NULL, NULL, &err);
```

в этом случае возвращается ошибка -32 (`CL_INVALID_PLATFORM`). И формально это справедливо: ничего про платформу в этом вызове не указано, а потому контекст не создаётся... Хотя другие реализации `OpenCL` в данной ситуации используют ранее выбранную платформу — и код кажется вполне работоспособным!

Кстати, утилита `clinfo` от Oblomov тестирует поведение некоторых функций OpenCL API в «неблагоприятных» условиях (в отсутствие сведений о платформе), в том числе и функций получения контекста.

Правильный путь в таком случае — создать минимальный массив свойств контекста, где содержится только идентификатор платформы `cpPlatform` (он определяется ранее), и только потом вызывать создание контекста по типу, причём со свойствами контекста:
```c++
cl_context_properties props[] = {
		CL_CONTEXT_PLATFORM, 
		(cl_context_properties)cpPlatform,
		0
};

cl_context Ctx = clCreateContextFromType(props, <Тип >, NULL, NULL, &err);
```
По завершении работы с OpenCL-устройствами контекст — как и любой другой ресурс, для которого выделяется память, — полагается «освободить». Для этой цели используется функция [[clReleaseContext|clReleaseContext()]], которой следует передать идентификатор освобождаемого контекста.

Реально действия, осуществляемые при вызове этой функции, таковы: уменьшается на единицу счётчик использования контекста и — если его значение стало равным нулю (т.е., контекст уже никем не используется), а все объекты, связанные с этим контекстом (объекты памяти, очереди команд), ранее были «освобождены», — контекст удаляется. Возвращает функция `CL_SUCCESS` в случае успешного завершения либо `CL_INVALID_CONTEXT` в случае недействительного идентификатора контекста.

Начиная с OpenCL 1.2 появляется такая функция, как [[clRetainContext|clRetainContext()]], которую, как оказывается, неявно будут вызывать обе функции создания контекста.

Делает она не так много: увеличивает на единицу счётчик использования контекста. Необходимость в ней возникает из-за сторонних библиотек, которым контекст может быть передан как параметр. При этом, если основное приложение удаляет контекст, у сторонней библиотеки нет никакого способа узнать, что контекстом пользоваться уже нельзя. С помощью же этой функции указанная проблема легко решается: сторонняя библиотека, получая идентификатор контекста, вызывает функцию [[clRetainContext|clRetainContext()]], завершая работу с ним, — функцию [[clRetainContext|clReleaseContext().]] И теперь не имеет значения, откуда функция освобождения контекста вызвана в последний раз, контекст освобождается тогда, когда уже никем не используется.

Для получения сведений о контексте используется функция [[clGetContextInfo|clGetContextInfo()]]:

По заданному контексту `context` и выбранному виду информации `param_name` можно получить необходимое значение через указатель `param_value` ; однако, поскольку здесь — как и в случае функции [[clGetDeviceInfo|clGetDeviceInfo()]] — разные виды информации являются различными типами данных (со своими размерами), эту функцию тоже следует вызывать дважды для каждого вида информации (числа устройств, их списка и т.п.),
