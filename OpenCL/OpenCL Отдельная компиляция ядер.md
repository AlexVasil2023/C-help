
[[#Отдельная компиляция ядер]]

# Отдельная компиляция ядер

Из-за того, что ядра компилируются после запуска хост-программы — прямо в процессе её работы, — а ошибки такой компиляции должны проверяться отдельно (и без дополнительных действий о них ничего не будет известно!), существует опасность, что работа «плохо» написанной хост-программы не будет сопровождаться запуском необходимых ядер. В результате возможна ситуация, когда `OpenCL-программа` вроде бы успешно запускается, но получаемые с её помошью результаты кажутся как минимум странными. А иногда неправильность работы подобной программы можно вообще не заметить...

Чтобы быть абсолютно уверенными в том, что ядра откомпилировались без ошибок, следует обязательно проверять результаты компиляции — так, как это рекомендовано в предыдущем разделе. Кроме того, во время разработки кода самих ядер имеет смысл компилировать их отдельно, чтобы возможные синтаксические ошибки обнаруживались быстрее.

Для отдельной компиляции ядер удобно использовать специальную программу, которая даёт доступ к скрытому от нас компилятору ядер через упомянутые ранее фунции [[clCreateProgramWithSource|clCreateProgramWithSource()]], [[clBuildProgram|clBuildProgram()]], [[clGetProgramBuildInfo|clGetProgramBuildInfo()]].

Если ограничиться системой Windows, то роль такой программы вполне может исполнять `clcc — OpenCL Kernel Compiler` (http://sourceforge.net/projects/clcc/), поскольку даже её давно доступная версия 0.3 имеет минимально необходимые в таких случаях возможности: выдаёт информацию об OpenCL-устройствах и позволяет указать для компиляции конкретную платформу и конкретное устройство.
```c++
clcc -p <Платформа > -d <Устройство > <ИмяФайлаСЯдром >
```

Необходимые для этой строки значения идентификаторов платформы и устройства можно узнать с помощью «справочного» запуска этого программы (`clcc -i`). Подсказка по имеющимся возможностям — `clcc -h`.

Единственный её недостаток — она использует для анализа параметров командной строки функции библиотеки `Boost`, а потому её компиляция несколько осложнена подобной зависимостью. Существуют и более легковесные программы такого типа с открытым кодом:
```
1. oclc — Simple OpenCL offline compiler
https://github.com/lighttransport/oclc

1. oclc.c - Simple command-line OpenCL C compiler
https://gist.github.com/jrprice/abf644ef6032538655bf
```

Для того, чтобы эти программы можно было отличать друг от друга (поскольку авторами они названы одинаково), имена исполняемых файлов для них были выбраны, исходя из условных обозначений авторов (lt-oclc — для первой и jrprice-oclc — для второй).

Первая программа тоже позволяет указать, какое устройство и какой платформы использовать для компиляции ядер, а также даёт возможность получить сведения о платформах и устройствах. Дополнительно могут быть заданы опции компилятора `OpenCL` и специальные заголовочные файлы.

Более конкретно, она имеет такие опции командной строки:

`–verbose` - выдача информации о платформах/устройствах
`–platform=N` - указание конкретной платформы
`–device=N` - указание конкретного устройства
`–clopt=STRING` - опции компилятора OpenCL
`–header=FILENAME` - дополнительный заголовочный файл
`-с` - создание бинарного модуля ядра

Однако, надо сказать, что в случае наличия нескольких платформ `OpenCL` выдача информации выглядит не так хорошо, как в случае одной платформы. Во-первых, тогда платформы выглядят «сваленными в кучу», т.е., перечисляются без чёткого указания, где каждая начинается и заканчивается. Во-вторых, самое неприятное — это то, что устройства перечисляются только из самой первой платформы, а выбранное для компиляции устройство не сопровождается явно указанным номером выбранной платформы.

Командная строка для компиляции программы под Windows отдельно установленным компилятором g++ с использованием CUDA-реализации OpenCL:
```c++
g++ main.cc muda_device_ocl.cc OptionParser.cpp -o lt-oclc \
-DHAVE_OPENCL -I"%CUDA_INC_PATH%" -L"%CUDA_LIB_PATH%" -lOpenCL
```

Командная строка для компиляции программы под Linux может выглядеть ещё проще, учитывая тот факт, что заголовочные файлы и библиотека OpenCL обычно находятся в «стандартном» месте:
```c++
g++ main.cc muda_device_ocl.cc OptionParser.cpp -o lt-oclc \
-DHAVE_OPENCL -lOpenCL
```

Обратите внимание на то, что для нормальной компиляции программы должна быть определена величина `HAVE_OPENCL`. Помимо этого, возможны предупреждения при компиляции на 64-разрядных системах об используемых форматах при выводе некоторых величин с помощью [[print#printf|printf()]]. Для нормальной работы программы также имеет смысл исправить мелкие неточности в файле `muda_device_ocl.cc` в вызовах функции `clGetDeviceInfo()`:
>
> во-первых, при получении значения параметра `CL_DEVICE_VENDOR` последний параметр должен быть равен `&size_ret` 
> 
> во-вторых, при запросе размера глобальной памяти с помощью `CL_DEVICE_GLOBAL_MEM_SIZE` надо использовать `sizeof(cl_ulong)` вместо `sizeof(cl_uint)`,

поскольку именно таков тип переменной `uval`.

Для того, чтобы воспользоваться опцией `-c` (создание бинарного модуля ядра), надо исправить ошибку в методе `getModule()` класса `MUDADeviceOCL`: он должен возвращать булевское значение, но `true` не возвращается никогда (!), потому что в конце метода не стоит оператор возврата (`return true`;).

Вторая программа на фоне первой выглядит ещё проще, так как у неё — помимо исходного `.cl`-файла — можно указать только номер устройства для первой попавшейся платформы. Для того, чтобы она откомпилировалась, надо в ней добавить включение заголовочного файла `cl_ext.h` (иначе не найдётся определение `CL_DEVICE_DOUBLE_FP_CONFIG`) и операции приведения типа указателей (`char *`) перед именем функции `malloc()` в двух местах. Кроме того, по её тексту можно заметить, что размер исходного файла ограничен примерно 64 килобайтами, а способ открытия этого файла таков, что исходные тексты с Windows-окончаниями строк нормально компилироваться не будут (надо исправить режим открытия файла на `"rb"`).

Командная строка для компиляции программы под Windows отдельно установленным компилятором `g++` с использованием `CUDA-реализации OpenCL`:
```c++
g++ oclc.c -o jrprice-oclc \
	-I"%CUDA_INC_PATH%" -L"%CUDA_LIB_PATH%" -lOpenCL
```

Командная строка для компиляции программы под Linux:
```c++
g++ oclc.c -o jrprice-oclc -lOpenCL
```

Сообщения об ошибках в ядрах обе программы выдают практически одинаково, что позволяет использовать их для отладочной компиляции с выдачей найденных ошибок при ограниченном наборе устройств `OpenCL`.

Более профессиональные программы для отдельной компиляции ядер присутствуют в средствах разработки от `Intel (ioc/ioc64), AMD (CLOC), ARM (malisc)` ...

