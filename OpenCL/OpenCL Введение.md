
1. [[#Введение|Введение]] 
	1. [[#Используемая терминология|Используемая терминология]] 1.1
2. [[#Память|Память]] 1.2
3. [[#Работа OpenCL-приложения|Работа OpenCL-приложения]] 1.3

# Введение

В настоящее время мы наблюдаем значимые изменения в принципах построения вычислительной техники, поскольку центральные процессоры теперь содержат несколько ядер, а графические процессоры (GPU ) превратились из узко специализированных устройств в программируемые параллельные процессоры общего назначения.

Создание программ для подобных многоядерных CPU и GPU очевидным образом требует новых подходов и новых программных средств. Одним из таких средств является программная платформа OpenCL.

***OpenCL*** (Open Computing Language, открытый язык вычислений) — это открытый стандарт для параллельного программирования, предлагающий эффективный и переносимый способ использования возможностей разнородных вычислительных многоядерных платформ (CPU, GPU и др.). Он включает в себя программный интерфейс (API ) для координирования параллельных вычислений в среде разнородных процессоров и кроссплатформенный язык, используемый в определённом вычислительном окружении.

На конкретной системной платформе стандарт реализуется в виде исполняемых модулей (библиотек), достаточных для запуска пользовательских OpenCL-приложений. Разработка подобных приложений предполагает наличие также C/C++-компилятора системной платформы и набора необходимых заголовочных файлов.

## Используемая терминология

***OpenCL-приложение*** — это совокупность программного кода, исполняемого на хосте (host)  и OpenCL-устройствах (device). Под хостом обычно понимается центральный процессор (CPU ) вычислительного устройства (компьютера, планшета, телефона и т.п.), а устройства OpenCL (devices) — некоторый набор вычислительных единиц, соответствующий графическому процессору (GPU ), многоядерному CPU или другим процессорам с параллельной архитектурой, доступным из хост-программы.  

Исполнение OpenCL-приложения, таким образом, включает исполнение хост-программы (на хосте) и исполнение специального кода на одном или нескольких OpenCL-устройствах под управлением хост-программы.  

Программы, исполняемые на OpenCL-устройствах, содержат одно или несколько ядер (kernels — функции, помеченные специальным ключевым словом `__kernel` и являющиеся «точкой входа» в исполняемый на устройствах код), при необходимости — вспомогательные функции, вызываемые в тексте ядер, а также, возможно, константные данные.  

Исполняемые на OpenCL-устройствах ядра пишутся на языке OpenCL C, который основывается на спецификации языка C 1999 года (т.н. C99) со специфическими расширениями и ограничениями.  

Программная модель OpenCL-приложения — ***SIMD*** (Single Instruction Multiple Data) или SIMT (Single Instruction Multiple Threads): код ядра может быть исполнен одновременно на многих вычислительных единицах, каждая из которых работает со «своими» данными.  

В терминологии OpenCL каждая исполняемая копия кода ядра именуется ***work-item*** (мы будем использовать далее название «рабочая единица»), она характеризуется своими уникальными индексами: ***глобальным идентификатором*** (global ID) и ***локальным идентификатором*** (local ID). Этих индексов — два, поскольку локальный индекс характеризует конкретную рабочую единицу в рамках так называемой рабочей группы (work-group), а глобальный индекс уникально характеризует рабочую единицу независимо от принадлежности к какой-либо рабочей группе.

# Память

Ядрам в OpenCL доступно четыре вида памяти: ***глобальная***, ***константная***, ***локальная*** и ***приватная***. Все рабочие единицы имеют доступ к глобальной памяти на чтение и на запись. Входная информация переносится в глобальную память с хоста, а результаты вычислений из глобальной памяти возвращаются обратно на хост.  

***Константная память*** доступна всем рабочим единицам, но только для чтения. Выделяется и инициализируется этот вид памяти на хосте.  

***Локальная память*** — это область памяти, общая для всех рабочих единиц в рамках одной рабочей группы. Посредством неё рабочие единицы группы могут обмениваться информацией друг с другом.  

***Приватная память*** — область памяти для локальных переменных экземпляра ядра. Любая рабочая единица имеет свою копию каждой локальной переменной, которая доступна только ей, но не другим рабочим единицам.

# Работа OpenCL-приложения

Первоначально OpenCL-приложение опрашивает имеющиеся OpenCL-платформы. Из списка найденных платформ приложение выбирает какую-то одну — нужного типа (CPU, GPU и т.п.) — и создаёт контекст: некое окружение, в котором будут запускаться на исполнение ядра. Контекст включает в себя информацию о наборе устройств, существующих в рамках платформы, памяти, доступной устройствам, а также очереди команд (command queues), используемые для организации исполнения ядер или операций над объектами памяти.  

Взаимодействие хоста и устройств осуществляется с помощью команд, а для доставки этих команд устройствам и используются очереди команд. Одновременно с командой можно создать объект события (***event***). Такие объекты позволяют приложению проверять завершение исполнения команд, а потому могут использоваться для синхронизации.  

Для выделения памяти на устройствах создаются объекты памяти; свойства их (например, возможность чтения/записи) устанавливаются приложением.  

Программные объекты (program objects) создаются загрузкой исходного или бинарного представления одного или нескольких ядер и последующей процедурой построения (build) исполняемого кода.  

В результате возникают объекты ядер (kernel objects), которые — после указания параметров для ядер — могут быть отправлены на устройства для исполнения.  

Исполнение (после передачи ядрам необходимых параметров) осуществляется в рамках ***NDRange*** — одно-, двух- или трёхмерного индексного пространства рабочих единиц (workitem); его размерность обычно соответствует размерности входных или выходных данных.  Это индексное пространство подразделяется на рабочие группы (work-group) одинакового размера. В OpenCL предполагается, что размеры индексного пространства нацело делятся на соответствующие размеры рабочих групп. Если это не так, то индексное пространство дополняется по каждому измерению рабочими единицами — до выполнения этого условия. При этом в коде ядер дополнительных рабочих единиц достаточно просто не производить никаких действий

Размер рабочей группы обычно определяется возможностями вычислительных единиц (см. далее функцию #clGetDeviceInfo() с параметрами #CL_DEVICE_MAX_WORK_GROUP_SIZE,  #CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS и #CL_DEVICE_MAX_WORK_ITEM_SIZES)

Надо отметить, что имеется и другое ограничение на размер рабочей группы; это существенно для реализаций OpenCL с ограниченными ресурсами (например, на мобильных устройствах). Там реальный размер рабочей группы зависит от размера кода ядер и может быть получен вызовом функции `clGetKernelWorkGroupInfo()` с параметром `CL_KERNEL_WORK_GROUP_SIZE`.   Поэтому в программах при запуске ядер параметр т.н. локального размера часто вообще не указывают (NULL), оставляя его на усмотрение реализации.

Финальным шагом любого OpenCL-приложения — после завершения вычислений и возвращения результатов на хост — должно быть освобождение всех созданных объектов.
