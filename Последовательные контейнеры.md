# Последовательные контейнеры C++11 #

Последовательные контейнеры хранят свои элементы в строго линейном порядке. К последовательным контейнерам относятся хорошо известные структуры данных [[vector|вектор (vector)]], [[list|список (list)]], [[deque|очередь (deque)]], а также строка символов (**string**). Существуют также
некоторые последовательные контейнеры, которые могут отсутствовать в стандартной библиотеке С++: [[stack|стек (stack)]] и [[Array|массив (array)]].

В таблице указаны требования к последовательным контейнерам (обязательные операции):

| выражение          | возвращаемый тип          | утверждение/примечание состояние до/после                                                     |
| ------------------ | ------------------------- | --------------------------------------------------------------------------------------------- |
| X(n, t) X a(n, t); |                           | после: size() == n. создаёт последовательность с n копиями t.                                 |
| X(i, j) X a(i, j); |                           | после: size() == расстоянию между i и j. создаёт последовательность, равную диапазону [i, j). |
| a.insert(p, t)     | iterator                  | вставляет копию t перед p. возвращаемое значение указывает на вставленную копию.              |
| a.insert(p, n, t)  | результат не используется | вставляет n копий t перед p.                                                                  |
| a.insert(p, i, j)  | результат не используется | вставляет копии элементов из диапазона [i, j) перед p                                         |
| a.erase(q)         | результат не используется | удаляет элемент, указываемый q                                                                |
| a.erase(ql, q2)    | результат не используется | удаляет элементы в диапазоне [ql, q2)                                                         |
В таблице указаны операции, которые выражаются через обязательные операции контейнеров. В различных типах контейнеров эти операции могут отсутствовать, например, у контейнера типа вектор нет возможности вставлять элементы в начало контейнера.

Таблица необязательных операций последовательностей

| выражение       | возвращаемый тип                                | семантика исполнения   | контейнер                                            |
| --------------- | ----------------------------------------------- | ---------------------- | ---------------------------------------------------- |
| a.front()       | reference; const_reference<br>для постоянного a | *a.begin()             | [[vector\|vector]], [[list\|list]], [[deque\|deque]] |
| a.back()        | reference; const_reference<br>для постоянного a | *(--a. end())          | [[vector\|vector]], [[list\|list]], [[deque\|deque]] |
| a.push_front(t) | void                                            | a.insert(a.begin(), t) | [[list\|list]], [[deque\|deque]]                     |
| a.push_back(t)  | void                                            | a.insert(a.end(), t)   | [[vector\|vector]], [[list\|list]], [[deque\|deque]] |
| a.pop_front ()  | void                                            | a.erase(a.begin())     | [[list\|list]], [[deque\|deque]]                     |
| a.pop_back ()   | void                                            | a.erase(-- a.end())    | [[vector\|vector]], [[list\|list]], [[deque\|deque]] |
| a[n]            | reference; const_reference<br>для постоянного a | *(a.begin() + n)       | [[vector\|vector]], [[deque\|deque]]                 |
Каждый последовательный контейнер имеет свои преимущества и недостатки, поэтому выбор того или иного контейнера для использования должен диктоваться задачей.  Например, список обладает быстрым способом вставки новых элементов в любую позицию (за константное время), а у архитектура вектора определяет быстрый доступ к элементам (за константное время).

