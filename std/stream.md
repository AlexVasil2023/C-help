
[[#Введение|Введение]] 11.1 (STL)
1. [[#std ostream|ostream]] 11.2 (STL)
2. [[#std istream|istream]] 11.3 (STL)
3. [[#basic_ostream|basic_ostream]]



# Введение

Библиотека потоков ввода-вывода обеспечивает форматированный и неформатированный буферизованный ввод-вывод текстовых и числовых значений. Он расширяем для поддержки пользовательских типов точно так же, как встроенных типов и является типобезопасным.

Библиотека файловой системы предоставляет базовые средства для работы с файлами и каталогами.

`ostream` преобразует типизированные объекты в поток символов (байтов):
![[stl_17.png]]

`istream` преобразует поток символов (байтов) в типизированные объекты:
![[STL_18.png]]

Операции с `istream` и `ostream` описаны ниже. Операции являются типобезопасными, чувствительными к типу и расширяемыми для обработки пользовательских типов.

Другие формы взаимодействия с пользователем, такие как графический ввод-вывод, обрабатываются с помощью библиотек, которые не являются частью стандарта ISO и, следовательно, здесь не описаны.

Рассматриваемые потоки могут использоваться для двоичного ввода-вывода, использоваться для различных типов символов, зависеть от локали и использовать расширенные стратегии буферизации, но эти темы выходят за рамки данной книги.

Потоки могут использоваться для ввода в [[string|string]] и вывода из них, для форматирования в string буферы ( #§11_7_3), в области памяти ( #§11_7_4) и для файлового ввода-вывода ( #§11_9).

Все классы потоков ввода-вывода имеют деструкторы, которые освобождают все принадлежащие ресурсы (такие как буферы и файловые дескрипторы). То есть, они являются примерами применения идиомы "Получение ресурса - это инициализация".

## std::ostream

В `<ostream>` библиотеке потоков ввода-вывода определён вывод для каждого встроенного типа. Кроме того, легко определить вывод пользовательского типа ( #§11_5). Оператор `<<` (“put to”) используется в качестве оператора вывода в объекты типа `ostream`; [[cout|cout]] - это стандартный поток вывода, а `cerr` - стандартный поток для сообщений об ошибках. По умолчанию значения, записанные в [[cout|cout]], преобразуются в последовательность символов. Например, чтобы вывести десятичное число 10, мы можем записать:
```c++
cout << 10;
```

Это помещает символ 1, за которым следует символ 0, в стандартный поток вывода. Эквивалентно, мы могли бы написать:
```c++
int x {10};
cout << x;
```

Выходные данные различных типов могут быть объединены очевидным образом:
```c++
void h(int i)
{
	cout << "the value of i is ";
	cout << i;
	cout << '\n';
}
```

Для `h(10)` будет выведено:
```
the value of i is 10
```

Программисты быстро устают повторять название выходного потока при выводе нескольких связанных элементов. К счастью, результат выходного выражения сам по себе может быть использован для дальнейшего вывода. Например:
```c++
void h2(int i)
{
	cout << "the value of i is " << i << '\n';
}
```

Этот `h2()` выдает тот же результат, что и `h()`.

Символьная константа - это символ, заключенный в одинарные кавычки. Обратите внимание, что символ выводится как символ, а не как числовое значение. Например:
```c++
int b = 'b';        // note: char implicitly converted to int
char c = 'c';
cout << 'a' << b << c;
```

Целочисленное значение символа `’b’` равно `98` (в кодировке ASCII, используемой в реализации C++), так что это выведет `a98c`.

## std::istream

В `<istream>` стандартная библиотека предлагает `istream` потоки для ввода. Как и [[#std ostream|ostream]], `istream` работают с символьными строковыми представлениями встроенных типов и могут быть легко расширены для работы с пользовательскими типами.

Оператор `>>` (“get from”) используется в качестве оператора ввода; [[cin|cin]] - это стандартный поток ввода. Тип правого операнда `>>` определяет, какие входные данные принимаются и какова цель операции ввода. Например:
```c++
int i;
cin >> i; // read an integer into i

double d;
cin >> d; // read a double-precision floating-point number into d
```

В первом случае считывает число, например `1234`, из стандартного ввода в целочисленную переменную `i`, во втором - число с плавающей точкой, например `12.34e5`, в переменную с плавающей точкой двойной точности `d`.

Как и операции вывода, операции ввода могут быть связаны цепочкой, так что я мог бы эквивалентно написать:
```c++
int i;
double d;

cin >> i >> d; // read into i and d
```

В обоих случаях чтение целого числа завершается любым символом, который не является цифрой. По умолчанию `>>` пропускает начальные пробельные символы, поэтому подходящей полной последовательностью ввода будет
```
1234
12.34e5
```

Часто мы хотим прочитать последовательность символов. Удобный способ сделать это - прочитать в [[string|string]]. Например:
```c++
cout << "Please enter your name\n";

string str;
cin >> str;

cout << "Hello, " << str << "!\n";
```

Если вы введете `Eric`, ответ будет таким:
```c++
Hello, Eric!
```

Вы можете прочитать целую строку, используя функцию `getline()`. Например:
```c++
cout << "Please enter your name\n";

string str;
getline(cin,str);

cout << "Hello, " << str << "!\n";
```

С помощью этой программы ввод `Eric Bloodaxe` приводит к желаемому результату: `Hello, Eric Bloodaxe!`

Перевод строки, завершавший вводимую строку, отбрасывается, поэтому cin готов к
вводу следующей строки.

Использование форматированных операций ввода-вывода обычно менее подвержено ошибкам, более эффективно и требует меньше кода, чем манипулирование символами по одному. В частности, `istream` заботится об управлении памятью и проверке диапазона. Мы можем выполнять форматирование в памяти и вывод из нее, используя [[sstream#stringstream|stringstream]] или [[memory streams#memory streams|memory streams]].

Стандартные строки обладают приятным свойством расширяться, чтобы вместить то, что вы в них помещаете; вам не нужно предварительно вычислять максимальный размер. Итак, если вы введете пару мегабайт точек с запятой, функция `hello_line()` вернет вам страницы с точками с запятой.

## basic_ostream
#basic_ostream











