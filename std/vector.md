
1. [[#std vector|Вектор]] (STL 12.2)
	1. [[#Элементы|Элементы]] (STL 12.2.1)
	2. [[#Проверка диапазона|Проверка диапазона]] (STL 12.2.2)

# std::vector

Наиболее полезным контейнером стандартной библиотеки является `vector`. `vector` - это последовательность элементов заданного типа. Элементы хранятся в памяти последовательно. [[Классы#Контейнеры|Типичная реализация vector]] и будет состоять из дескриптора, содержащего указатели на первый элемент, на элемент следующий за последним и на элемент, следующий за выделенной памятью (или эквивалентную информацию, представленную в виде указателя плюс смещения):
![[vector_1.png]]

Кроме того, он содержит [[allocator#std allocator|аллокатор]] (здесь alloc), от которого `vector` может получать память для своих элементов. По умолчанию [[allocator#std allocator|аллокатор]] использует `new` и `delete` для получения и освобождения памяти. Используя немного продвинутый метод реализации, мы можем избежать хранения каких-либо данных для простых [[allocator#std allocator|аллокатор]] в объекте `vector`.

Мы можем инициализировать `vector` набором значений, соответствующих типу его элемента:
```c++
vector<Entry> phone_book = {
	{"David Hume",123456},
	{"Karl Popper",234567},
	{"Bertrand Arthur William Russell",345678}
};
```

Доступ к элементам возможен через индекс. Итак, предполагая, что мы определили `<<` для `Entry`, мы можем написать:
```c++
void print_book(const vector<Entry>& book)
{
	for (int i = 0; i!=book.size(); ++i)
		cout << book[i] << '\n';
}
```

Как обычно, индексация начинается с `0`, так что в `book[0]` содержится запись для `David Hume`. Функция-член `size()` возвращает количество элементов.

Элементы `vector` образуют диапазон, поэтому мы можем использовать [[for|цикл for]] для диапазонов:
```c++
void print_book(const vector<Entry>& book)
{
	for (const auto& x : book) 
		cout << x << '\n';
}
```

Когда мы определяем `vector`, мы задаем ему начальный размер (начальное количество элементов):
```c++
vector<int> v1 = {1, 2, 3, 4};  // size is 4
vector<string> v2;              // size is 0
vector<Shape*> v3(23);          // size is 23; initial element value: nullptr
vector<double> v4(32,9.9);      // size is 32; initial element value: 9.9
```

Явно указанный размер заключен в обычные круглые скобки, например, `(23)`, и обычно элементы инициализируются значением по умолчанию соответственно типу элемента (например, [[nullptr_t|nullptr]] для указателей и `0` для чисел). Если вам не нужно значение по умолчанию, вы можете указать начальное значение всех элементов в качестве второго аргумента (например, 9.9 для 32 элементов v4).

Начальный размер может быть изменен. Одной из наиболее полезных операций с `vector` является `push_back()`, которая добавляет новый элемент в конец вектора, увеличивая его размер на единицу. Например, предполагая, что мы определили `>>` для `Entry`, мы можем написать:
```c++
void input()
{
	for (Entry e; cin>>e; )
		phone_book.push_back(e);
}
```
Здесь считываем `Entry` из стандартного ввода в `phone_book` до тех пор, пока либо не будет достигнут конец ввода (например, конец файла), либо операция ввода не столкнется с ошибкой формата.

`vector` стандартной библиотеки реализован таким образом, что увеличение `vector` с помощью повторных `push_back()` является эффективным. Чтобы показать, как это делается, рассмотрим разработку простого `Vector`, используя представление, указанное на диаграмме выше:
```c++
template<typename T>
class Vector {
	allocator<T> alloc; 
	T* elem; 
	T* space;
	T* last; 
	
public:
	// ...
	int size() const { return space-elem; } 
	int capacity() const { return last-elem; } 
	
	// ...
	
	void reserve(int newsz); 
	
	// ...
	
	void push_back(const T& t); 
	void push_back(T&& t); 
};
```

`vector` стандартной библиотеки имеет методы `capacity()`, `reserve()` и `push_back()`. Функция `reserve()` используется пользователями `vector` и другими методами `vector`, чтобы зарезервировать место в памяти для большего количества элементов. Возможно, ему придется выделить новую память, и когда это произойдет, он переместит элементы в новое место. Когда функция `reserve()` перемещает элементы в новое, более крупное место, старые указатели на эти элементы теперь будут указывать на неправильное местоположение; они становятся недействительными и не должны использоваться. Учитывая `capacity()` и `reserve()`, реализация `push_back()` является тривиальной:
```c++
template<typename T>
void Vector<T>::push_back(const T& t)
{
	if (capacity()<=size())
		reserve(size()==0?8:2*size()); 

	construct_at(space,t); 
	++space;
}
```

Теперь выделение и перемещение элементов происходит нечасто. Раньше я использовал `reserve()`, чтобы попытаться повысить производительность, но это оказалось пустой тратой усилий: эвристика, используемая `vector`, в среднем лучше, чем мои предположения, поэтому теперь я явно использую `reserve()` только для того, чтобы избежать переаллокации элементов, когда я хочу использовать указатели на элементы.

`vector` может быть скопирован при присвоении и инициализации. Например:
```c++
vector<Entry> book2 = phone_book;
```

Копирование и перемещение `vector` реализуются [[Основные операции#Копирование и перемещение|конструкторами и операторами присваивания]]. Присваивание вектора предполагает копирование его элементов. Таким образом, после инициализации `book2`, `book2` и `phone_book` хранят отдельные копии каждой `Entry` в телефонной книге. Когда `vector` содержит много элементов, такие выглядящие невинно присваивания и инициализации могут быть дорогостоящими. Там, где копирование нежелательно, следует использовать [[Программы - STL#Указатели, Массивы и Ссылки|ссылки или указатели]] или [[Основные операции#Перемещение контейнеров|операции перемещения]].

`vector` стандартной библиотеки очень гибкий и эффективный. Используйте его в качестве контейнера по умолчанию; то есть используйте его, если у вас нет веской причины использовать какой-либо другой контейнер. Если вы избегаете `vector` из-за смутных опасений по поводу “эффективности”, измерьте его быстродействие сами. Наша интуиция чаще всего ошибается в вопросах эффективности использования контейнеров.

## Элементы

Как и все контейнеры стандартной библиотеки, `vector` - это контейнер элементов некоторого типа `T`, то есть `vector<T>`. Практически любой тип квалифицируется как тип элемента: встроенные числовые типы (такие как `char`, `int` и `double`), пользовательские типы (такие как `string`, `Entry`, `list<int>` и `Matrix<double,2>`) и указатели (такие как `const char*`,  `Shape*` и `double*`). Когда вы вставляете новый элемент, его значение копируется в контейнер. Например, когда вы помещаете целое число со значением 7 в контейнер, результирующий элемент действительно имеет значение 7. Элемент не является ссылкой или указателем на какой-либо объект, содержащий 7. Это позволяет создавать красивые, компактные контейнеры с быстрым доступом. Для людей, которые заботятся об объемах памяти и производительности во время выполнения, это очень важно.

Если у вас есть  [[Классы#Иерархии классов|иерархия классов]], которая полагается на виртуальные функции для получения полиморфного поведения, не храните объекты непосредственно в контейнере. Вместо этого храните указатель (или [[Умные указатели и контейнеры - STL|умный указатель]]). Например:
```c++
vector<Shape> vs; 
vector<Shape*> vps;
vector<unique_ptr<Shape>> vups;
```

## Проверка диапазона

`vector` стандартной библиотеки не гарантирует проверку диапазона. Например:
```c++
void silly(vector<Entry>& book)
{
	int i = book[book.size()].number;
}
```

Эта инициализация, скорее всего, поместит некоторое случайное значение в `i`, а не выдаст ошибку. Это нежелательно, и ошибки, связанные с выходом за пределы диапазона, являются распространенной проблемой. Поэтому, я часто использую простую адаптацию `vector` для проверки диапазона:
```c++
template<typename T>
struct Vec : std::vector<T> 
{
	using vector<T>::vector;    // use the constructors 
								//from vector (under the name Vec)
	T& operator[](int i) { return vector<T>::at(i); } // range check
								// range check const objects
	const T& operator[](int i) const { return vector<T>::at(i); } 

	auto begin() { return Checked_iter<vector<T>>{*this}; } 
	auto end() { return Checked_iter<vector<T>>{
										*this, vector<T>::end()};}
};
```

`Vec` наследует все от `vector`, за исключением операций с индексами, которые он переопределяет для проверки диапазона. Операция `at()` - это операция индекса `vector`, которая генерирует [[Обработка ошибок#Исключения|исключение типа out_of_range]], если ее аргумент находится вне диапазона vector.

Для `Vec` доступ вне диапазона вызовет исключение, которое пользователь может перехватить. Например:
```c++
void checked(Vec<Entry>& book)
{
	try {
			// will throw an exception
		book[book.size()] = {"Joe",999999};  
		...
	}
	catch (out_of_range&) {
		cerr << "range error\n";
	}
}
```

[[Обработка ошибок#Исключения|Исключение будет брошено, а затем перехвачено]]. Если пользователь не перехватит исключение, программа завершится четко определенным образом, а не продолжится или завершится с ошибкой неопределенным образом. Один из способов свести к минимуму неожиданности от неперехваченных исключений - использовать `main()` с [[try|try-block]] в качестве тела. Например:
```c++
int main()
try {
	// your code
}
catch (out_of_range&) {
	cerr << "range error\n";
}
catch (...) {
	cerr << "unknown exception thrown\n";
}
```

Этот код предоставляет обработчики исключений по умолчанию, так что, если нам не удается перехватить какое-либо исключение, выводится сообщение об ошибке в [[stream#std ostream|стандартном потоке вывода ошибок cerr]].

Почему стандарт не гарантирует проверку диапазона? Многие приложения, для которых критически важна производительность, используют `vector`, и проверка всех индексов влечет за собой увеличение затрат примерно на 10%. Очевидно, что эта стоимость может сильно варьироваться в зависимости от аппаратного обеспечения, оптимизаторов и использования индексов приложением. Однако опыт показывает, что такие накладные расходы могут привести к тому, что люди предпочтут гораздо более небезопасные встроенные массивы. Даже простой страх перед такими накладными расходами может привести к отказу от использования `vector`. По крайней мере, диапазон `vector` легко проверяется во время отладки, и мы можем создавать проверенные версии поверх непроверенных по умолчанию.

[[for|Цикл for]] для диапазонов позволяет избежать ошибок диапазона без каких-либо затрат за счет неявного доступа ко всем элементам в диапазоне. Пока их аргументы действительны, алгоритмы стандартной библиотеки гарантируют отсутствие ошибок диапазона.

Если вы используете `vector::at()` непосредственно в своем коде, вам не нужен мой обходной путь через `Vec`. Кроме того, некоторые стандартные библиотеки имеют реализации `vector` с проверкой диапазона, которые предлагают более полную проверку, чем `Vec`.


