[[#std array C++11]]
[[#valarray]]
[[#Array|Array]] 15.3.1(STL)


# std::array C++11
`std::array` – это контейнер, построенный поверх C-подобных массивов. Поддерживает общие контейнерные операции, такие как сортировка.
```c++
std::array<int, 3> a = {2, 1, 3}; 
std::sort(a.begin(), a.end()); // a == { 1, 2, 3 } 

for (int& x : a) 
	x *= 2; // a == { 2, 4, 6 }
```

# valarray

[[valarray|см. valarray]]

# Array

`array`, определенный в `<array>`, представляет собой последовательность элементов заданного типа фиксированного размера, где количество элементов задается во время компиляции. Таким образом, `array` может быть размещен вместе со своими элементами в стеке, в объекте или в статическом хранилище. Элементы располагаются в области, в которой определен `array`. `array` лучше всего понимать как встроенный массив с жестко привязанным к нему размером, без неявных, потенциально неожиданных преобразований в типы указателей и с несколькими предоставляемыми удобными функциями. Использование `array` не требует дополнительных затрат (времени или памяти) по сравнению с использованием встроенного массива. `array` не следует модели “обращения к элементам” контейнеров STL. Вместо этого массив непосредственно содержит свои элементы. Это не что иное, как более безопасная версия встроенного массива.

Это подразумевает, что `array` может и должен быть инициализирован списком инициализаторов:
```c++
array<int, 3> a1 = {1, 2, 3};
```

Количество элементов в инициализаторе должно быть равно или меньше количества элементов, указанного для `array`.

Количество элементов является обязательным, количество элементов должно быть постоянным выражением, количество элементов должно быть положительным, а тип элемента должен быть явно указан:
```c++
void f(int n)
{
	array<int> a0 = {1,2,3};                 // error: size not specified
	array<string,n> a1 = {"John's", "Queens' "}; // error: size not a
												 // constant expression
	array<string,0> a2;                  // error: size must be positive
	array<2> a3 = {"John's", "Queens' "}; // error: element type not stated
	// ...
}
```

Если вам нужно, чтобы количество элементов было переменным, используйте [[vector|vector]].

При необходимости `array` может быть явно передан функции в стиле `C`, которая ожидает указатель. Например:
```c++
void f(int* p, int sz);            // C-style interface

void g()
{
	array<int,10> a;

	f(a,a.size());                // error: no conversion
	f(a.data(),a.size());         // C-style use

	auto p = find(a,777);         // C++/STL-style use (a range is passed)
	// ...
}
```

Зачем нам использовать `array`, когда [[vector|vector]] намного более гибкий? `array` менее гибок, поэтому он проще. Иногда можно получить значительное преимущество в производительности за счет прямого доступа к элементам, размещенным в стеке, вместо того, чтобы выделять элементы в динамической памяти, получая к ним косвенный доступ через [[vector|vector]] (дескриптор), а затем освобождая их. С другой стороны, стек - это ограниченный ресурс (особенно в некоторых встроенных системах), и переполнение стека - это неприятно. Кроме того, существуют области применения, такие как безопасное управление в режиме реального времени, где аллокации в динамическую память запрещены. Например, использование [[delete|delete]] может привести к [[allocator#std allocator|фрагментации]] или [[Обработка ошибок#Инварианты|исчерпанию памяти]].

Зачем нам использовать `array`, когда мы могли бы использовать встроенный массив? `array` знает свой размер, поэтому его легко использовать с алгоритмами стандартной библиотеки, и его можно скопировать с помощью `=`. Например:
```c++
array<int,3> a1 = {1, 2, 3 };

auto a2 = a1;                 // copy
a2[1] = 5;
a1 = a2;                      // assign
```

Однако, главная причина моего предпочтения `array` заключается в том, что он избавляет меня от неожиданных и неприятных преобразований в указатели. Рассмотрим пример, включающий иерархию классов:
```c++
void h()
{
	Circle a1[10];
	array<Circle,10> a2;
	// ...
	
	Shape* p1 = a1;  // OK: disaster waiting to happen
	Shape* p2 = a2;  // error: no conversion of array<Circle,10> to Shape*
					 //	(Good!)
	p1[3].draw();    // disaster
}
```

Комментарий ”катастрофа" предполагает, что `sizeof(Shape) < sizeof(Circle)`, поэтому обращение по индексу `Circle[]` через `Shape*` дает неправильное смещение. Все стандартные контейнеры обеспечивают правильную итерацию по сравнению со встроенными массивами.


