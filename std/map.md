
[[#std map|std::map]] (12.5 STL)
[[#unordered_map|unordered_map]] (12.6 STL)

# std::map

Написание кода для поиска имени в списке пар (`name`, `number`) довольно утомительно. Кроме того, линейный поиск неэффективен для всех списков, кроме самых коротких. Стандартная библиотека предлагает сбалансированное двоичное дерево поиска (обычно красно-черное дерево), называемое map:
![[map.png]]

В других контекстах `map` известна как ассоциативный массив или словарь.

`map` стандартной библиотеки - это контейнер пар значений, оптимизированный для поиска и вставки. Мы можем использовать тот же список инициализации, что и для [[vector|vector]] и [[list|list]]:
```c++
map<string,int> phone_book {
	{"David Hume",123456},
	{"Karl Popper",234567},
	{"Bertrand Arthur William Russell",345678}
};
```

При использовании в качестве индекса значения своего первого типа (называемого ключом) `map` возвращает соответствующее значение второго типа (называемое значением или сопоставленным типом). Например:
```c++
int get_number(const string& s)
{
	return phone_book[s];
}
```

Другими словами, индексация по `map` - это, по сути, поиск, который мы назвали `get_number()`. Если `key` не найден, он вводится в `map` со значением по умолчанию для его `value`. Значение по умолчанию для целочисленного типа равно 0, и это просто разумное значение для представления недопустимого телефонного номера.

Если бы мы хотели избежать ввода недопустимых номеров в нашу телефонную книгу, мы могли бы использовать `find()` и `insert()` ( #§12_8) вместо `[]`.

# unordered_map

Стоимость поиска по `map` равна `O(log(n))`, где `n` - количество элементов в `map`. Это довольно хорошо. Например, для `map` с `1 000 000` элементов мы выполняем всего около `20` сравнений и косвенных указаний, чтобы найти элемент. Однако во многих случаях мы можем добиться большего успеха, используя поиск по хэшу, а не сравнение с использованием функции упорядочения, такой как `<`. Хэшированные контейнеры стандартной библиотеки называются “неупорядоченными”, поскольку для них не требуется функция упорядочивания:
![[unordered_map.png]]

Например, мы можем использовать `unordered_map` из `<unordered_map>` для нашей телефонной книги:
```c++
unordered_map<string,int> phone_book {
	{"David Hume",123456},
	{"Karl Popper",234567},
	{"Bertrand Arthur William Russell",345678}
};
```

Как и в случае с `map`, мы можем использовать оператор индекса для `unordered_map`:
```c++
int get_number(const string& s)
{
	return phone_book[s];
}
```

Стандартная библиотека предоставляет для [[string|string]] хэш-функцию по умолчанию, а также для других встроенных типов и типов стандартной библиотеки. При необходимости мы можем предоставить свои собственные. Возможно, наиболее распространенная потребность в пользовательской хэш-функции возникает, когда нам нужен неупорядоченный контейнер одного из наших собственных типов. Хэш-функция часто реализуется как [[Template_STL#Функциональные объекты|функциональный объект]]. Например:
```c++
struct Record {
	string name;
	int product_code;

	...
};

struct Rhash {
	size_t operator()(const Record& r) const
	{
		return hash<string>()(r.name) ^ hash<int>()(r.product_code);
	}
};

unordered_set<Record,Rhash> my_set; 
```

Разработка хороших хэш-функций - это искусство, и часто требуется знания данных, к которым они будут применяться. Создание новой хэш-функции путем объединения существующих хэш-функций с использованием исключающего ИЛИ (^) является простым и часто очень эффективным. Однако будьте осторожны, чтобы убедиться, что каждое значение, участвующее в хэше, действительно помогает различать значения. Например, если у вас не может быть нескольких названий для одного и того же кода продукта (или нескольких кодов продукта для одного и того же имени), объединение двух хэшей не дает никаких преимуществ.

Мы можем избежать явной передачи операции [[hash|hash]], определив ее как специализацию [[hash|hash]] стандартной библиотеки:
```c++
namespace std {
	template<> struct hash<Record> 
	{
		using argument_type = Record;
		using result_type = size_t;
		result_type operator()(const Record& r) const
		{
			return hash<string>()(r.name) ^ 
							hash<int>()(r.product_code);
		}
	};
}
```

Обратите внимание на различия между `map` и `unordered_map`:
> 
> Для `map` требуется функция упорядочивания (по умолчанию используется `<`), которая выдает упорядоченную последовательность.
> 
> Для `unordered_map` требуется функция равенства (по умолчанию `==`); она не поддерживает порядок между своими элементами.
 
Учитывая хорошую хэш-функцию, `unordered_map` работает намного быстрее, чем `map` для больших контейнеров. Однако в худшем случае поведение `unordered_map` с плохой хэш-функцией намного хуже, чем у `map`.


