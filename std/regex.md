
[[#Регулярные выражения]] 10.4 (STL)
	[[#Описание регулярных выражений|Описание регулярных выражений]] 10.4.2 (STL)
[[#std regex]]
[[#regex_match]]
[[#regex_search]]
[[#regex_replace]]
[[#regex_iterator]]
[[#regex_token_iterator]]


# Регулярные выражения 

***Регулярные выражения*** - это мощный инструмент для обработки текста. Они предоставляют способ простого и сжатого описания шаблонов в тексте (например, почтовый индекс США, такой как TX 77845, или дату в стиле ISO, такую как 2009-06-07) и эффективного поиска таких шаблонов. В `<regex>` стандартная библиотека обеспечивает поддержку регулярных выражений в виде класса [[#std regex|std::regex]] и его вспомогательных функций. Чтобы получить наглядное представление о библиотеке `regex`, давайте определим и напечатаем шаблон:
```c++
regex pat {R"(\w{2}\s*\d{5}(-\d{4})?)"};    // U.S. postal code pattern: 
											// XXddddd-dddd and variants
```

Люди, которые использовали регулярные выражения практически на любом языке, найдут `\w{2}\s*\d{5}(-\d{4})?` знакомый. Он задает шаблон, начинающийся с двух букв `\w{2}`, за которыми необязательно следует некоторый пробел `\s*`, за которым следуют пять цифр `\d{5}` и необязательно за ними следует тире и четыре цифры `-\d{4}`. Если вы не знакомы с регулярными выражениями, возможно, сейчас самое подходящее время узнать о них.

Чтобы записать шаблон, я использую сырой строковый литерал, начинающийся с `R"(` и заканчивающийся на `)"`. Это позволяет использовать обратную косую черту и кавычки непосредственно в строке. Сырые строки особенно подходят для регулярных выражений, поскольку они, как правило, содержат много обратных косых черт. Если бы я использовал обычную строку, определение шаблона было бы следующим:
```c++
regex pat {"\\w{2}\\s*\\d{5}(-\\d{4})?"}; // U.S. postal code pattern
```

В `<regex>` стандартная библиотека обеспечивает поддержку регулярных выражений:
>
> [[#regex_match|regex_match()]]: Сопоставление регулярного выражения со строкой (известного размера).
> 
> [[#regex_search|regex_search()]]: Поиск строки, соответствующей регулярному выражению, в (произвольно длинном) потоке данных.
> 
> [[#regex_replace|regex_replace()]]: Поиск и замена строк, соответствующих регулярному выражению, в (произвольно длинном) потоке данных.
> 
> [[#regex_iterator|regex_iterator]]: Перебор совпадений и вложенных совпадений.
> 
> [[#regex_token_iterator|regex_token_iterator]]: Выполняет итерацию по несоответствиям.

## Описание регулярных выражений

Библиотека регулярных выражений [[#std regex|regex]] может распознавать несколько вариантов обозначения регулярных выражений. Здесь я использую обозначение по умолчанию, вариант стандарта `ECMA`, используемый для `ECMAScript` (более известного как `JavaScript`). Синтаксис регулярных выражений основан на специальных символах:
Специальные символы регулярных выражений

| `.`  | Любой отдельный символ `(“подстановоч-<br>ный знак”)`               |
| ---- | ------------------------------------------------------------------- |
| `[`  | Начало класса символов                                              |
| `]`  | Конец класса символов                                               |
| `{`  | Начало количества вхождений                                         |
| `}`  | Конец количества вхождений                                          |
| `(`  | Начало группы, подмаски                                             |
| `)`  | Конец группы, подмаски                                              |
| `\`  | Экранирование спец символа (следующий символ имеет особое значение) |
| `*`  | Ни одного или более (suffix operation)                              |
| `+`  | Одно или более (suffix operation)                                   |
| `?`  | Опционально (одно или ни одного) (suffix operation)                 |
| `\|` | Альтернатива (или)                                                  |
| `^`  | Начало строки; отрицание                                            |
| `$`  | Конец строки                                                        |

Например, мы можем указать строку, начинающуюся с нуля или более `A`, за которой следует один или несколько `B`, за которыми следует необязательный `C`, как это:
```c++
^A*B+C?$
```

Примеры строк, соответствующие этому выражению:
```
AAAAAAAAAAAABBBBBBBBBC
BC
B
```

Примеры строк, не соответствующие выражению:
```c++
AAAAA // no B
AAAABC // initial space
AABBCC // too many Cs
```

Часть шаблона считается подшаблоном (который может быть извлечен отдельно из `smatch`), если она заключена в круглые скобки. Например:
```c++
\d+-\d+ // no subpatterns
\d+(-\d+) // one subpattern
(\d+)(-\d+) // two subpatterns
```

Шаблон может быть необязательным или повторяющимся (по умолчанию он повторяется ровно один раз) путем добавления суффикса:

| `{ n }`    | Ровно n раз                                         |
| ---------- | --------------------------------------------------- |
| `{ n, } n` | Или более раз                                       |
| `*`        | Ни одного или более, то есть {0,}                   |
| `1`        | Один или более, то есть {1,}                        |
| `?`        | `Необязательно (ни одного или один), то есть {0,1}` |

Например:
```c++
A{3}B{2,4}C*
```

Примеры соответствующих строк:
```
AAABBC
AAABBB
```

Примеры несоответствующих строк:
```
AABBC // too few As
AAABC // too few Bs
AAABBBBBCCC // too many Bs
```

Суффикс `?` после любого из обозначений повторения (`?`, `*`, `+` и `{ }`) делает сопоставитель шаблонов “ленивым” или “нежадным”. То есть при поиске шаблона он будет искать самое короткое совпадение, а не самое длинное. По умолчанию средство сопоставления шаблонов всегда ищет самое длинное совпадение; это известно как правило Макса Мунка. Рассмотрим:
```
ababab
```

Шаблону `(ab)+` соответствует весь `ababab`. Однако, `(ab)+?` соответствует только первое `ab`.

Наиболее распространенные классы символов имеют имена:

| `alnum`  | Любой буквенно-цифровой символ                                    |
| -------- | ----------------------------------------------------------------- |
| `alpha`  | Любой буквенный символ                                            |
| `blank`  | Любой пробельный символ, который не является разделителем строк   |
| `cntrl`  | Любой управляющий символ                                          |
| `d`      | Любая десятичная цифра                                            |
| `digit`  | Любая десятичная цифра                                            |
| `graph`  | Любой графический символ                                          |
| `lower`  | Любой символ в нижнем регистре                                    |
| `print`  | Любой печатаемый символ                                           |
| `punct`  | Любой знак препинания                                             |
| `s`      | Любой пробельный символ                                           |
| `space`  | Любой пробельный символ                                           |
| `upper`  | Любой символ в верхнем регистре                                   |
| `w`      | Любой символ слова (буквенно-цифровые символы плюс подчеркивание) |
| `xdigit` | Любой шестнадцатеричный цифровой символ                           |

В регулярном выражении имя символьного класса должно быть заключено в квадратные скобки `[::]`. Например, `[:digit:]` соответствует десятичной цифре. Кроме того, они должны использоваться в паре `[ ]`, определяющей класс символов. 

Для некоторых классов символов поддерживается сокращенная запись:

| `\d` | Десятичная цифра                                       | `[[:digit:]]`   |
| ---- | ------------------------------------------------------ | --------------- |
| `\s` | Пробел (пробел, табуляция и т.д.)                      | `[[:space:]]`   |
| `\w` | Буква (a-z) или цифра (0-9) или знак подчеркивания (_) | `[_[:alnum:]]`  |
| `\D` | Не `\d`                                                | `[^[:digit:]]`  |
| `\S` | Не `\s`                                                | `[^[:space:]]`  |
| `\W` | Не `\w`                                                | `[^_[:alnum:]]` |

Кроме того, языки, поддерживающие регулярные выражения, часто предоставляют:

| `\l` | Символ в нижнем регистре  | `[[:lower:]]`  |
| ---- | ------------------------- | -------------- |
| `\u` | Символ в верхнем регистре | `[[:upper:]]`  |
| `\L` | Не `\l`                   | `[^[:lower:]]` |
| `\U` | Не `\u`                   | `[^[:upper:]]` |

Для обеспечения переносимости, используйте полные имена классов символов, а не сокращённые.

В качестве примера рассмотрим написание шаблона, описывающего идентификаторы C++: символ подчеркивания или буква, за которой следует, возможно, пустая последовательность букв, цифр или подчеркиваний. Чтобы проиллюстрировать связанные с этим тонкости, я приведу несколько ложных попыток:
```c++
[:alpha:][:alnum:]* // wrong: characters from the set ":alpha" followed by ...
[[:alpha:]][[:alnum:]]* // wrong: doesn't accept underscore ( _ is not alpha)
([[:alpha:]]|_)[[:alnum:]]* // wrong: underscore is not part of alnum either
([[:alpha:]]|_)([[:alnum:]]|_)* // OK, but clumsy
[[:alpha:]_][[:alnum:]_]* // OK: include the underscore in the character classes
[_[:alpha:]][_[:alnum:]]* // also OK
[_[:alpha:]]\w* // \w is equivalent to [_[:alnum:]]
```

Наконец, вот функция, которая использует простейшую версию [[#regex_match|regex_match()]] для проверки того, является ли строка идентификатором:
```c++
bool is_identifier(const string& s)
{
	regex pat {"[_[:alpha:]]\\w*"}; // underscore or letter followed by 
						// zero or more underscores, letters, or digits
	return regex_match(s,pat);
}
```

Обратите внимание на удвоение обратной косой черты, чтобы включить обратную косую черту в обычный строковый литерал. Используйте необработанные строковые литералы, чтобы устранить проблемы со специальными символами. Например:
```c++
bool is_identifier(const string& s)
{
	regex pat {R"([_[:alpha:]]\w*)"};
	return regex_match(s,pat);
}
```

Вот несколько примеров шаблонов::
```c++
Ax*             // A, Ax, Axxxx
Ax+             // Ax, Axxx Not A
\d-?\d          // 1-2, 12 Not 1--2
\w{2}-\d{4,5}   // Ab-1234, XX-54321, 22-5432 Digits are in \w
(\d*:)?(\d+)    // 12:3, 1:23, 123, :123 Not 123:
(bs|BS)         // bs, BS Not bS
[aeiouy]        // a, o, u An English vowel, not x
[^aeiouy]       // x, k Not an English vowel, not e
[a^eiouy]       // a, ^, o, u An English vowel or ^
```

`group` (подшаблон), который потенциально может быть представлен с помощью `sub_match`, взят в круглые скобки. Если вам нужны круглые скобки, которые не должны определять подшаблон, используйте `(?:` вместо простой `(`. Например:
```c++
(\s|:|,)*(\d*)  // optional spaces, colons, and/or commas 
				// followed by an optional number
```

Предполагая, что нас не интересовали символы перед числом (предположительно разделители), мы могли бы написать:
```c++
(?:\s|:|,)*(\d*) // optional spaces, colons, and/or commas 
				// followed by an optional number
```

Это избавило бы механизм регулярных выражений от необходимости сохранять первые символы: вариант `(?:` имеет только один подшаблон.

Примеры группировки регулярных выражений

| `\d*\s\w+`          | Нет групп (подшаблонов)                                                                                  |
| ------------------- | -------------------------------------------------------------------------------------------------------- |
| `(\d*)\s(\w+)`      | Две группы                                                                                               |
| `(\d*)(\s(\w+))+`   | Две группы (группы не объединяются)                                                                      |
| `(\s*\w*)+`         | Одна группа; один или несколько вложенных шаблонов; только последний подшаблон сохраняется как sub_match |
| `<(.*?)>(.*?)</\1>` | Три группы; \1 означает “то же, что и в группе 1”.                                                       |

Этот последний шаблон полезен для синтаксического анализа XML. Он находит маркеры начала/конца тега. Обратите внимание, что я использовал нежадное совпадение (***ленивое совпадение***), `.*?`, для подшаблона между тегом и конечным тегом. Если бы я использовал обычный `.*,` этот ввод вызвал бы проблему:
```c++
Always look on the <b>bright</b> side of <b>life</b>.
```

Жадный поиск для первого подшаблона соответствовало бы первому `<` с последним `>`. Это было бы правильным поведением, но вряд ли то, чего хотел программист. 

# std::regex
#std_regex




# regex_match
#regex_match




# regex_search
#regex_search

Самый простой способ использования шаблона - это поиск соответствия в потоке:
```c++
int lineno = 0;

for (string line; getline(cin,line); ) {   // read into line buffer
	++lineno;
	smatch matches;                        // matched strings go here

	if (regex_search(line, matches, pat))  // search for pat in line
		cout << lineno << ": " << matches[0] << '\n';
}
```

`regex_search(line, matches, pat)` выполняет поиск в строке `line` всего, что соответствует регулярному выражению, хранящемуся в `pat`, и если он находит какие-либо совпадения, он сохраняет их в `matches`. Если совпадений не найдено, `regex_search(line, matches, pat)` возвращает значение `false`. Переменная `matches` имеет тип `smatch`. Буква `“s”` означает `”sub“` или `"string”`, а `smatch` - это [[vector|vector]] найденных совпаденией типа [[string|string]]. Первый элемент, который здесь `matches[0]`, является полным совпадением. Результатом `regex_search()` является набор совпадений, обычно представляемый в виде `smatch`:
```c++
void use()
{
	ifstream in("file.txt"); // input file
	if (!in) { // check that the file was opened
		cerr << "no file\n";
		return;
	}
	
	regex pat {R"(\w{2}\s*\d{5}(-\d{4})?)"}; // U.S. postal code pattern
	int lineno = 0;
	
	for (string line; getline(in, line); ) {
		++lineno;
		smatch matches; // matched strings go here

		if (regex_search(line, matches, pat)) {
			cout << lineno << ": " << matches[0] << '\n'; // the complete match

				// if there is a  sub-pattern  and if it is matched
			if (1<matches.size() && matches[1].matched) 
				cout << "\t: " << matches[1] << '\n'; // submatch
		}
	}
}
```

Эта функция читает файл в поисках почтовых индексов США, таких как TX77845 и DC 20500-0001. Тип `smatch` это контейнер результатов регулярных выражений. Здесь `matches[0]` - это весь шаблон, а `matches[1]` - необязательный четырехзначный подшаблон `(-\d{4})?`.

Символ новой строки, `\n`, может быть частью шаблона, поэтому мы можем выполнять поиск многострочных шаблонов. Очевидно, если хотим это сделать, то мы не должны читать строки по одной.

Синтаксис и семантика регулярных выражений разработаны таким образом, что регулярные выражения могут быть скомпилированы в конечные автоматы для эффективного выполнения `[Cox,2007]`. Тип [[#std regex|regex]] выполняет эту компиляцию во время выполнения.

# regex_replace
#regex_replace



# regex_iterator
#regex_iterator

Мы можем определить `regex_iterator` для перебора последовательности совпадений с шаблоном. Например, мы можем использовать `sregex_iterator` (`regex_iterator<string>`) для вывода всех слов, разделенных пробелами, в [[string|string]]:
```c++
void test()
{
	string input = "aa as; asd ++e^asdf asdfg";
	regex pat {R"(\s+(\w+))"};
	
	for (sregex_iterator p(input.begin(),input.end(),pat); 
									p!=sregex_iterator{}; ++p)
	cout << (*p)[1] << '\n';
}
```

Результат работы кода:
```c++
as
asd
asdfg
```

Мы пропустили первое слово, `aa`, потому что перед ним нет пробелов. Если мы упростим шаблон до `R"((\w+))",` то получим
```c++
aa
as
asd
e
asdf
asdfg
```

`regex_iterator` - это двунаправленный итератор, поэтому мы не можем напрямую выполнять итерацию по [[stream#std istream|istream]] (который предлагает только входной итератор). Кроме того, мы не можем выполнять запись через `regex_iterator`, и `regex_iterator` по умолчанию (`regex_iterator{}`) является единственно возможным концом последовательности.

# regex_token_iterator
#regex_token_iterator



