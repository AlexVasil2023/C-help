
# span

Традиционно ошибки диапазона были основным источником серьезных ошибок в программах на C и C++, приводящих к неправильным результатам, сбоям и проблемам безопасности. [[Контейнеры - STL|Использование контейнеров]], [[Алгоритмы - STL|алгоритмов]] и цикла [[for|for]] для диапазонов значительно уменьшило эту проблему, но можно сделать еще больше. Ключевым источником ошибок диапазона является то, что люди передают указатели (сырые или умные), а затем полагаются на соглашение, чтобы узнать количество элементов, на которые указывают. Лучший совет для кода вне дескрипторов ресурсов - предположить, что не более чем на один объект указывает `[CG: F.22]`, но без поддержки этот совет неосуществим. [[string_view|string_view]] стандартной библиотеки может помочь, но он доступен только для чтения и только для символов. Большинству программистов нужно больше. Например, при записи в буферы и считывании из них в программном обеспечении более низкого уровня, как известно, трудно поддерживать высокую производительность, избегая при этом ошибок диапазона (“перебег буфера”). `span` из `<span>` - это, по сути, пара (указатель, длина), обозначающая последовательность элементов:
![[span.png]]

`span` предоставляет доступ к непрерывной последовательности элементов. Элементы могут храниться многими способами, в том числе в [[vector|vector]] и встроенных массивах. Как и указатель, `span` не владеет символами, на которые он указывает. В этом он напоминает [[string_view|string_view]] и пару [[iterator#Типы итераторов|итераторов STL]].

Рассмотрим общий стиль интерфейса:
```c++
void fpn(int* p, int n)
{
	for (int i = 0; i<n; ++i)
		p[i] = 0;
}
```

Мы предполагаем, что `p` указывает на `n` целых чисел. К сожалению, это предположение является просто соглашением, поэтому мы не можем использовать его для написания цикла [[for|for]] для диапазона, а компилятор не может реализовать дешевую и эффективную проверку диапазона. Кроме того, наше предположение может быть неверным:
```c++
void use(int x)
{
	int a[100];          
	fpn(a,100);         // OK
	fpn(a,1000);        // oops, my finger slipped! (range error in fpn)
	fpn(a+10,100);      // range error in fpn
	fpn(a,x);           // suspect, but looks innocent
}
```

Мы можем добиться большего успеха, используя `span`:
```c++
void fs(span<int> p)
{
	for (int& x : p)
		x = 0;
}
```

Мы можем использовать `fs` следующим образом:
```c++
void use(int x)
{
	int a[100];
	fs(a);                // implicitly creates a span<int>{a,100}
	fs(a,1000);           // error: span expected
	fs({a+10,100});       // a range error in fs
	fs({a,x});            // obviously suspect
}
```

То есть обычный случай, когда `span` созданный непосредственно из массива, теперь безопасен (компилятор вычисляет количество элементов) и прост с точки зрения нотации. В других случаях вероятность ошибок снижается, а обнаружение ошибок упрощается, поскольку программисту приходится явно составлять `span`.

Обычный случай, когда `span` передается от функции к функции, проще, чем для интерфейсов (указатель, счетчик), и, очевидно, не требует дополнительной проверки:
```c++
void f1(span<int> p);

void f2(span<int> p)
{
	// ...
	f1(p);
}
```

Что касается контейнеров, когда для индексации используется `span` (например, `r[i]`), проверка диапазона не выполняется, и доступ вне диапазона является неопределенным поведением. Естественно, на практике можно реализовать это неопределенное поведение как проверку диапазона, но, к сожалению, мало кто это делает. Исходный `gsl::span` из библиотеки поддержки `Core Guidelines [CG]` выполняет проверку диапазона.



