
1. [[#Форматирование потока|Форматирование потока]] 11.6.1(STL)
2. [[#Форматирование в стиле printf()|Форматирование в стиле printf()]] 11.6.2(STL)
3. [[#std format|std::format]]
	1. [[#C++17]]
	2. [[#C++20]]
4. [[#Форматирование|Форматирование]]
	1. [[#format]]
	2. [[#result]]

# Форматирование потока

Простейшие элементы управления форматированием называются манипуляторами и находятся в `<ios>`, [[stream#std istream|istream]], [[stream#std ostream|ostream]] и [[manimp|iomanip]] (для манипуляторов, принимающих аргументы). Например, мы можем выводить целые числа в виде десятичных (по умолчанию), восьмеричных или шестнадцатеричных чисел:
```c++
cout << 1234 <<' ' << hex << 1234 <<' ' << oct << 1234 << dec << 1234 <<'\n';
```
```
// 1234 4d2 2322 1234
```

// Мы можем явно задать формат вы
```c++
constexpr double d = 123.456;
	cout << d << "; " // use the default format for d
			<< scientific << d << "; " // use 1.123e2 style format for d
			<< hexfloat << d << "; " // use hexadecimal notation for d
			<< fixed << d << "; " // use 123.456 style format for d
			<< defaultfloat << d <<'\n'; // use the default format for d
```

Соответственно вывод:
```
123.456; 1.234560e+002; 0x1.edd2f2p+6; 123.456000; 123.456
```

Точность - это целое число, определяющее количество цифр, используемых для отображения числа с плавающей запятой:
>
> ***Общий формат*** (defaultfloat) позволяет реализации выбрать формат, который представляет значение в таком стиле, который наилучшим образом сохраняет значение в доступном количестве знакомест. Точность определяет максимальное количество цифр.
> 
> ***Научный формат*** (scientific) представляет значение с одной цифрой перед десятичной точкой и показателем степени. Точность определяет максимальное количество цифр после десятичной точки.
> 
> ***Фиксированный формат*** (fixed) представляет значение в виде целой части, за которой следуют десятичная точка и дробная часть. Точность определяет максимальное количество цифр после десятичной точки. Значения с плавающей точкой округляются, а не просто усекаются, и функция `precision()` не влияет на вывод целых чисел. Например:
```c++
cout.precision(8);
cout << "precision(8):" << 1234.56789 <<' '<< 1234.56789 <<' '<< 123456 <<'\n';

cout.precision(4);
cout << "precision(4): " << 1234.56789 <<' '<< 1234.56789 <<' '<< 123456 <<'\n';
cout << 1234.56789 <<'\n';
```

Соответственно вывод:
```c++
precision(8): 1234.5679 1234.5679 123456
precision(4): 1235 1235 123456 1235
```

Эти манипуляторы с плавающей точкой являются “липкими”; то есть их эффекты сохраняются для последующих операций с плавающей точкой. То есть они предназначены в первую очередь для форматирования потоков значений.

Мы также можем указать размер поля, в которое должно быть помещено число, и его выравнивание в этом поле.

В дополнение к основным числам, `<<` также может обрабатывать время и даты: [[Chrono#std chrono duration|duration]], [[Chrono#std chrono time_point (Моменты времени)|time_point]] year_month_date, , `month` и `zoned_time` . Например:
```c++
cout << "birthday: " << November/28/2021 << '\n';
cout << << "zt: " << zoned_time{current_zone(), system_clock::now()} <<'\n';
```

Соответственно вывод
```c++
birthday: 2021-11-28
zt: 2021-12-05 11:03:13.5945638 EST
```

Стандарт также определяет `<<` для [[complex|complex]], [[bitset|bitset]] ( #§15_3_2), кодов ошибок и указателей. Потоковый ввод-вывод является расширяемым, поэтому мы можем  [[iostream#I/O пользовательских типов|определить `<<` для наших собственных (определяемых пользователем) типов]].

## Форматирование в стиле printf()

Было убедительно доказано, что `printf()` является самой популярной функцией в C и важным фактором ее успеха. Например:
```c++
printf("an int %g and a string '%s'\n",123,"Hello!");
```

Этот стиль “форматирования строки, за которой следуют аргументы” был заимствован в C из BCPL и используется многими языками. Естественно, `printf()` всегда была частью стандартной библиотеки C++, но она страдает от отсутствия безопасности типов и расширяемости для обработки пользовательских типов.

В `<format>` стандартная библиотека предоставляет типобезопасный, хотя и не расширяемый механизм форматирования в стиле `printf()`. Базовая функция [[#std format|format()]] выдает [[string|string]]:
```c++
string s = format("Hello, {}\n", val);
```

“Обычные символы” в форматируемой строке просто вставляются в выходной [[string|string]]. Форматируемая строка, разделенная символами `{` и `}`, указывает, как аргументы, следующие за строкой формата, должны быть вставлены в [[string|string]]. Самая простая строка формата - это пустая строка `{}`, которая принимает следующий аргумент из списка аргументов и печатает его в соответствии с его оператором `<<` по умолчанию (если таковое имеется). Итак, если `val` - это `"World"`, мы получаем культовое `"Hello, World\n"`. Если `val` равно `127`, мы получаем `"Hello, 127\n"`.

Наиболее распространенным использованием [[#format|format()]] является вывод его результата:
```c++
cout << format("Hello, {}\n", val);
```

Чтобы увидеть, как это работает, давайте сначала повторим примеры:
```c++
cout << format("{} {:x} {:o} {:d} {:b}\n", 1234,1234,1234,1234,1234);
```

Это дает тот же результат, что и в примере с целым числом, за исключением того, что я добавил `b` для двоичного файла, который напрямую не поддерживается [[stream#std ostream|ostream]]:
```
1234 4d2 2322 1234 10011010010
```

Перед директивой форматирования ставится двоеточие. Альтернативными вариантами целочисленного форматирования являются `x` для шестнадцатеричного, `o` для восьмеричного, `d` для десятичного и `b` для двоичного.

По умолчанию `format()` принимает свои аргументы по порядку. Однако мы можем указать произвольный порядок. Например:
```c++
cout << format("{3:} {1:x} {2:o} {0:b}\n", 000, 111, 222, 333);
```

Это выводит `333 6f 336 0`. Число перед двоеточием - это номер форматируемого аргумента. В лучших традициях C++ нумерация начинается с нуля. Данная запись позволяет нам форматировать аргумент более одного раза:
```c++
cout << format("{0:} {0:x} {0:o} {0:d} {0:b}\n", 1234); 
	// default, hexadecimal, octal, decimal, binary
```

Возможность помещать аргументы в выходные данные “не по порядку” высоко ценится людьми, создающими сообщения на разных естественных языках.

Форматы с плавающей запятой такие же, как и для [[stream#std ostream|ostream]]: `e` для `scientific`, `a` для `hex-float`, `f` для `fixed` и `g` для `default`. Например:
```c++
cout << format("{0:}; {0:e}; {0:a}; {0:f}; {0:g}\n",123.456); 
// default, scientific, hexfloat, fixed, default
```

Результат идентичен результату из [[stream#std ostream|ostream]], за исключением того, что шестнадцатеричному числу не предшествовал `0x`:
```
123.456; 1.234560e+002; 1.edd2f2p+6; 123.456000; 123.456
```

Точка предшествует указателю точности:
```c++
cout << format("precision(8): {:.8} {} {}\n", 1234.56789, 1234.56789, 123456);

cout << format("precision(4): {:.4} {} {}\n", 1234.56789, 1234.56789, 123456);

cout << format("{}\n", 1234.56789);
```

В отличие от потоков, спецификаторы не являются “липкими”, поэтому мы получаем:
```c++
precision(8): 1234.5679 1234.56789 123456
precision(4): 1235 1234.56789 123456 1234.56789
```

Как и в случае с потоковыми форматировщиками, мы также можем указать размер поля, в которое должно быть помещено число, и его выравнивание в этом поле.

Подобно форматировщикам потоков, `format()` также может обрабатывать время и даты ( #§16_2_2). Например:
```c++
cout << format("birthday: {}\n",November/28/2021);
cout << format("zt: {}", zoned_time{current_zone(), system_clock::now()});
```

Как обычно, форматирование значений по умолчанию идентично форматированию вывода потока по умолчанию. Однако `format()` предлагает мини-язык, содержащий около 60 спецификаторов формата, позволяющий очень детально управлять форматированием чисел и дат. Например:
```c++
auto ymd = 2021y/March/30 ;
cout << format("ymd: {3:%A},{1:} {2:%B},{0:}\n", ymd.year(), ymd.month(), ymd.day(), weekday(ymd));
```

Результат вывода:
```
ymd: Tuesday, March 30, 2021
```

Все строки формата времени и даты начинаются с `%`.

Гибкость, обеспечиваемая многими спецификаторами формата, может быть важна, но она сопряжена со многими возможностями для ошибок. Некоторые спецификаторы поставляются с необязательной семантикой или семантикой, зависящей от языка. Если ошибка форматирования обнаруживается во время выполнения, генерируется исключение `format_error`. Например:
```c++
string ss = format("{:%F}", 2); // error: mismatched argument; potentially
								// caught at compile time

string sss = format("{%F}", 2); // error: bad format; 
								// potentially caught at compile time
```

Примеры до сих пор имели постоянные форматы, которые можно проверить во время компиляции. Дополнительная функция `vformat()` использует переменную в качестве формата для значительного повышения гибкости и возможности возникновения ошибок во время выполнения:
```c++
string fmt = "{}";
cout << vformat(fmt, make_format_args(2)); // OK

fmt = "{:%F}";
cout << vformat(fmt, make_format_args(2)); // error: format and argument
											// mismatch; caught at run time
```

Наконец, средство форматирования также может выполнять запись непосредственно в буфер, определенный итератором. Например:
```c++
string buf;
format_to(back_inserter(buf), "iterator: {} {}\n", "Hi! ", 2022);
cout << buf; // iterator: Hi! 2022
```

Это становится интересным с точки зрения производительности, если мы используем буфер потока напрямую или буфер для какого-либо другого устройства вывода.

# std::format

`std::format` это новый способ форматирования текста, который
>
> отделяет форматирование от вывода
> 
> более типобезопасен
> 
> позволяет изменять порядок
## C++17
```c++
std::printf("%d baskets of %s", n, desc);
//OR
std::cout << n << " baskets of " << desc;
```
## C++20
```c++
std::cout << std::format("{} baskets of {}", n, desc);
```
# Форматирование

Подробное форматирование похоже на **printf**, но на самом деле основано на Python.
Общая форма такова
_fill-and-align sign `#` `0` width precision `L` type_
(каждая часть необязательна).
## format
```c++
std::string s;
// fill-and-align

s = std::format("{:6}",   123); //default
s = std::format("{:<6}",  123); //left
s = std::format("{:^6}",  123); //center
s = std::format("{:>6}",  123); //right

s = std::format("{:6}",  "abc"); //default
s = std::format("{:<6}", "abc"); //left
s = std::format("{:^6}", "abc"); //center
s = std::format("{:>6}", "abc"); //right

s = std::format("{:$^6}", "abc"); //fill with

// sign

s = std::format("{}",    123); //default
s = std::format("{}",   -123); //default

s = std::format("{:-}",  123); //same as def
s = std::format("{:-}", -123); //same as def

s = std::format("{:+}",  123); //always sign
s = std::format("{:+}", -123); //always sign

s = std::format("{: }",  123); //space if pos
s = std::format("{: }", -123); //space if pos
```
## result
```c++
// results...
// fill-and-align

assert(s == "   123"); // numbers >
assert(s == "123   ");
assert(s == " 123  "); // slightly <
assert(s == "   123");

assert(s == "abc   "); // strings <
assert(s == "abc   ");
assert(s == " abc  "); // slightly <
assert(s == "   abc");

assert(s == "$abc$$"); // fill with $

// sign

/* {} */ assert(s == "123");
/* {} */ assert(s == "-123");

/*{:-}*/ assert(s == "123");
/*{:-}*/ assert(s == "-123");

/*{:+}*/ assert(s == "+123");
/*{:+}*/ assert(s == "-123");

/*{: }*/ assert(s == " 123");
/*{: }*/ assert(s == "-123");
```



