
[[#Строки|Строки]] 10.2 (STL)
1. [[#Реализация string|Реализация string]] 10.2.1 (STL)
[[#basic_string]]
[[#std string]]

# Строки

Стандартная библиотека предоставляет тип `string` в дополнение к строковым литералам; `string` - это обычный ([[Concepts#концепт regular|концепт regular]]) тип для владения и манипулирования последовательностью символов различных типов. Тип `string` предоставляет множество полезных операций со строками, таких как конкатенация (объединение). Например:
```c++
string compose(const string& name, const string& domain)
{
	return name + @ + domain;
}

auto addr = compose("dmr","bell-labs.com");
```

Здесь `addr` инициализируется последовательностью символов `dmr@bell-labs.com`. “Сложение” строк подразумевает их объединение. Вы можете объединить строку, строковый литерал, строку в стиле C или символ со строкой. Стандартная строка имеет [[Основные операции#Копирование и перемещение|конструктор перемещения]], поэтому возврат даже длинных строк по значению эффективен.

Во многих приложениях наиболее распространенной формой конкатенации является добавление чего-либо в конец строки. Это напрямую поддерживается операцией `+=`. Например:
```c++
void m2(string& s1, string& s2)
{
	s1 = s1 + '\n'; // append newline
	s2 += '\n'; // append newline
}
```

Эти два способа добавления в конец строки семантически эквивалентны, но я предпочитаю последний, потому что он более четко описывает, что он делает, более лаконичен и, возможно, более эффективен.

Строка изменяема. В дополнение к `=` и `+=` поддерживаются операции инкдеса (с ис-
пользованием `[ ]`) и подстроки. Например:
```c++
string name = "Niels Stroustrup";

void m3()
{
	string s = name.substr(6,10); // s = "Stroustrup"
	name.replace(0,5,"nicholas"); // name becomes "nicholas Stroustrup"
	name[0] = toupper(name[0]); // name becomes "Nicholas Stroustrup"
}
```

Операция `substr()` возвращает строку, которая является копией подстроки, указанной в ее аргументах. Первый аргумент - это индекс в строке (позиция), а второй - длина подстроки. Поскольку индексация начинается с `0`, `s` принимает значение `Stroustrup`.

Операция `replace()` заменяет подстроку значением. В этом случае подстрокой, начинающейся с `0` и имеющей длину `5`, является `Niels`; она заменяется на `nicholas`. Наконец, я заменяю начальный символ его эквивалентом в верхнем регистре. Таким образом, конечное значение `name - Nicholas Stroustrup`. Обратите внимание, что заменяющая строка не обязательно должна быть того же размера, что и подстрока, которую она заменяет.

Среди множества полезных операций со строками - присваивание (с использованием `=`), индекс (с использованием `[ ]` или at(), как для [[vector|vector]]), сравнение (с использованием `==` и `!=`) и лексикографический порядок (с использованием `<`, `<=`, `>` и `>=`), итерирование (с использованием итераторов, [[begin|begin()]] и [[end|end()]] как для [[vector|vector]]), [[stream#std istream|ввод]] и [[sstream|потоки]].

Естественно, строки можно сравнивать друг с другом, со строками в стиле C и со строковыми литералами. Например:
```c++
string incantation;

void respond(const string& answer)
{
	if (answer == incantation) {
		// ... perform magic ...
	}
	else if (answer == "yes") {
		...
	}

	...
}
```

Если вам нужна строка в стиле C (массив символов, заканчивающийся нулем), `string` предлагает доступ только для чтения к содержащимся в нем символам (`c_str()` и `data()`). Например
```c++
void print(const string& s)
{
	printf("For people who like printf: %s\n",s.c_str()); 
		// s.c_str() returns a pointer to s' characters
		
	cout << "For people who like streams: " << s << '\n';
}
```

Строковый литерал по умолчанию является `const char*`. Чтобы получить литерал типа [[#std string|std::string]], используйте суффикс `s`. Например:
```c++
auto cat = "Cat"s; // a std::string
auto dog = "Dog"; // a C-style string: a const char*
```

Чтобы использовать суффикс `s`, вам необходимо использовать [[Основные операции#Пользовательские литералы|пространство имен std::literals::string_literals]].

## Реализация string

Реализация класса `string` - популярное и полезное упражнение. Однако для широкого применения наши бережно разработанные первые попытки редко соответствуют стандартному `string` по удобству или производительности. В наши дни `string` обычно реализуется с использованием оптимизации коротких строк. То есть короткие строковые значения сохраняются в самом объекте `string`, и только более длинные строки помещаются в динамическую память. Рассмотрим:
```c++
string s1 {"Annemarie"}; // short string
string s2 {"Annemarie Stroustrup"}; // long string
```

Расположение в памяти будет примерно таким:
![[String_1.png]]

Когда значение `string` изменяется с короткой на длинную строку (и наоборот), ее представление соответствующим образом корректируется. Сколько символов может содержать “короткая” строка? Это определено реализацией, но “около 14 символов” - неплохое предположение.

Фактическая производительность строк может критически зависеть от среды выполнения. В частности, в многопоточных реализациях выделение памяти может быть относительно дорогостоящим. Кроме того, при использовании большого количества строк разной длины может возникнуть фрагментация памяти. Это основные причины того, что оптимизация коротких строк стала повсеместной.

Для обработки нескольких наборов символов `string` на самом деле является псевдонимом для общего шаблона [[basic_string|basic_string]] с символьным типом [[Char|char]]:
```c++
template<typename Char>
class basic_string {
	// ... string of Char ...
};

using string = basic_string<char>;
```

Пользователь может определять строки произвольных типов символов. Например, предполагая, что у нас есть японский символ типа `Jchar`, мы можем написать:
```c++
using Jstring = basic_string<Jchar>;
```

Теперь мы можем выполнять все обычные строковые операции над `Jstring`, строкой японских символов.

# basic_string
#basic_string



# std::string
#std_string










