
[[#std tuple|std::tuple]]
[[#std tuple_size|std::tuple_size]]
[[#std tuple_element|std::tuple_element]]
[[#std makeTuple|std::makeTuple]]
[[#Кортежи C++11|Кортежи C++11]]
[[#Кортежи C++17|Кортежи C++17]]
[[#Кортежи|Кортежи]] 25(template)
1. [[#Базовый дизайн Tuple|Базовый дизайн Tuple]] 25.1
	1. [[#Хранилище|Хранилище]] 25.1.1
	2. [[#Создание кортежа|Создание кортежа]] 25.1.2
2. [[#Базовые операции кортежей|Базовые операции кортежей]] 25.2
	1. [[#Сравнение|Сравнение]] 25.2.1
	2. [[#Вывод|Вывод]] 25.2.2
3. [[#Алгоритмы для работы с кортежами|Алгоритмы для работы с кортежами]] 25.3
	1. [[#Кортежи как списки типов|Кортежи как списки типов]] 25.3.1
	2. [[#Добавление элементов в кортеж и удаление их оттуда|Добавление элементов в кортеж и удаление их оттуда]] 25.3.2
	3. [[#Обращение порядка элементов кортежа|Обращение порядка элементов кортежа]] 25.3.3
	4. [[#Индексные списки|Индексные списки]] 25.3.4
	5. [[#Обращение с использованием индексных списков|Обращение с использованием индексных списков]] 25.3.5
	6. [[#Тасование и выбор|Тасование и выбор]] 25.3.6
4. [[#Распаковка кортежей|Распаковка кортежей]] 25.4
5. [[#Оптимизация кортежей|Оптимизация кортежей]] 25.5
	1. [[#Кортежи и оптимизация пустого базового класса|Кортежи и оптимизация пустого базового класса]] 25.5.1 
	2. [[#get () с константным временем работы|get () с константным временем работы]] 25.5.2
6. [[#Индексы кортежа|Индексы кортежа]] 25.6


# std::tuple
#std_tuple




# std::tuple_size
#std_tuple_size



# std::tuple_element
#std_tuple_element


# std::makeTuple
#std_makeTuple



# Кортежи C++11
Кортежи представляют собой наборы неоднородных значений фиксированного размера.
```c++
// `playerProfile` имеет тип `std::tuple<int, const char*, const char*>`. 

auto playerProfile = std::make_tuple(51, "Frans Nielsen", "NYI"); 
std::get<0>(playerProfile); // 51 
std::get<1>(playerProfile); // "Frans Nielsen" 
std::get<2>(playerProfile); // "NYI"
```

# Кортежи C++17 #

Эта структура появилась в C++11. Они аналогичны массивам и представляют собой коллекции с фиксированной длиной. Кортежи можно использовать, чтобы вернуть несколько значений функции, например так:
```C++
#include <tuple> 

auto get() { 
	return std::make_tuple("fred", 42); 
}
```

Этот пример вернет кортеж с двумя членами. В C++14 версии появилась возможность использовать **auto** с возвращаемыми типами функций, чтобы сделать вызов функции более аккуратным. Для получения значений кортежа, при этом, будет требоваться **std::get**: 
```c++
auto t = get(); 
std::cout << std::get<0>(t) << std::endl;
```

Через **std::tie** можно привязать элементы кортежа к переменным, которые уже должны быть объявлены:
```c++
std::string name; 
int age; 

std::tie(name, age) = get();
```

Благодаря этому методу можно привязывать элементы кортежа к переменным без std::get и необходимости объявлять переменные заранее:
```c++
auto [name, age] = get(); 
std::cout << name << " is " << age << std::endl;
```

Этот метод также позволяет получить ссылки к элементам кортежа, что невозможно с [[tie|std::tie]]:
```c++
auto t2 = std::make_tuple(10, 20); 

auto& [first, second] = t2; 
first += 1; 

std::cout << "value is now " << std::get<0>(t2) << std::endl;
```

# Кортежи

В этой книге для иллюстрации возможностей шаблонов часто используются однородные (гомогенные) контейнеры и типы, подобные массивам. Такие однородные структуры расширяют концепцию массива в языках программирования С и C++ и часто используются во многих приложениях. В этих языках также есть гетерогенные образования, способные хранить данные — классы или структуры. В данной главе рассматриваются `кортежи (tuple)`, агрегирующие данные подобно классам или структурам. Например, кортеж, содержащий `int`, `double` и [[string|std::string]], подобен структуре с членами `int`, `double` и [[string|std::string]], с тем отличием, что к элементам кортежа можно обращаться по их индексам (`0`, `1`, `2`), а не с помощью имен. Этот позиционный интерфейс и возможность легко создавать кортежи из списков типов делают кортежи более подходящими для использования в шаблонном метапрограммировании, чем структуры.

Существует альтернативный взгляд на кортежи как на проявление списков типов в выполнимой программе. Например, в то время как список типов `Typelist<int, double, std::string`> описывает последовательность типов, содержащую `int`, `double` и [[string|std::string]], с которыми можно работать во время компиляции, `Tuple<int, double, std::string>` описывает хранилище для `int`, `double` и [[string|std::string]], с которым можно работать во время выполнения. Например, в следующей программе создается экземпляр такого кортежа:
```c++
template<typename... Types>
class Tuple
{
	... // Реализация обсуждается ниже
};

Tuple<int, double, std::string> t(17, 3.14, "Hello, World!");
```

В шаблонном метапрограммировании распространено использование списков типов для создания кортежей, которые могут применяться для хранения данных. Например, несмотря на то, что мы произвольно выбрали `int`, `double` и [[string|std::string]] как типы элементов в приведенном выше примере, мы могли бы создать набор типов, хранящихся в кортеже, с помощью метапрограммы.

В оставшейся части этой главы мы будем изучать реализацию и работу с шаблоном класса `Tuple`, который представляет собой упрощенную версию шаблона класса `std::tuple`.

# Базовый дизайн Tuple

## Хранилище

Кортежи содержат хранилища для каждого из типов в списке аргументов шаблона. Эти места хранения могут быть доступны с использованием шаблонной функции `get`, синтаксис применения которой `get<I>(t)` для получения `I-го` элемента кортежа `t`. Например, `get<0>(t)` для `t` из предыдущего примера возвращает ссылку на `int 17`, в то время как `get<1>(t)` возвращает ссылку на `double 3.14'.

Рекурсивная формулировка хранилища в кортеже основана на той идее, что кортеж, содержащий `N > 0` элементов, может храниться как единственный элемент (первый элемент, или голова списка) и кортеж, содержащий `N-1` элемент (хвост), с отдельным частным случаем кортежа без элементов. Таким образом, трехэлементный кортеж `Tuple<int, double, std::string>` может храниться как `int` и кортеж `Tuple<double, std::string>`. Этот двухэлементный кортеж сам может храниться как `double` и `Tuple<std::string>`, причем последний может храниться как `std::string` и `Tuple<>`. Фактически это такое же рекурсивное разложение, как и используемое в обобщенных версиях алгоритмов для списков типов, и фактическая реализация рекурсивного хранения кортежа разворачивается аналогично тому, как это делалось со списками типов:
```c++
template<typename... Types>
class Tuple;

// Рекурсивный случай:
template<typename Head, typename... Tail>
class Tuple<Head, Tail...>
{
	private:
		Head head;
		Tuple<Tail...> tail;
		
	public:
		// Конструкторы:
		Tuple()
		{
		}
		
		Tuple(Head const& head, Tuple<Tail...> const& tail)
			: head(head), tail(tail)
		{
		)

	...

		Head& getHead()
		{
			return head;
		}

		Head const& getHead() const
		{
			return head;
		}
		
		Tuple<Tail...>& getTail()
		{
			return tail;
		}
		
		Tuple<Tail...> const& getTail() const
		{
			return tail;
		}

		// Базовый случай:
		template<>
		class Tuple<>
		{
			// Хранилище не требуется
		};
};
```

В рекурсивном случае каждый экземпляр класса `Tuple` содержит член-данное `head`, который хранит первый элемент в списке, а также член-данное `tail`, который хранит оставшиеся элементы в списке. Базовый случай является просто пустым кортежем, который не имеет связанного с ним хранилища для данных.

Шаблон функции `get` проходит по этой рекурсивной структуре для извлечения запрошенного элемента:
```c++
// Рекурсивный случай:
template<unsigned N>
struct TupleGet
{
	template<typename Head, typename... Tail>
	static auto apply(Tuple<Head, Tail...> const& t)
	{
		return TupleGet < N - 1 >::apply(t.getTail());
	}
};

// Базовый случай:
template<>
struct TupleGet<0>
{
	template<typename Head, typename... Tail>
	static Head const& apply(Tuple<Head, Tail...> const& t)
	{
		return t.getHead();
	}
};

template<unsigned N, typename... Types>
auto get(Tuple<Types...> const& t)
{
	return TupleGet<N>::apply(t);
}
```

Обратите внимание на то, что шаблон функции `get` — это просто тонкая оболочка над вызовом статической функции-члена `TupleGet`. Этот метод фактически является [[Дальнейшее развитие - template#Частичная специализация шаблонов функций|обходным путем для отсутствующей частичной специализации шаблонов функций]], который мы используем для специализации значения `N`. В рекурсивном случае (`N > 0`) статическая функция-член `apply()` извлекает хвост текущего кортежа и уменьшает `N` для продолжения поиска запрошенного элемента далее в кортеже. Базовый случай (`N = 0`) возвращает голову текущего кортежа, завершая нашу реализацию.

## Создание кортежа

Помимо определенных к настоящему времени конструкторов:
```c++
Tuple()
{
}

Tuple(Head const& head, Tuple<Tail...> const& tail)
	: head(head), tail(tail)
{
}
```

мы должны иметь возможность создавать его как из набора независимых значений (по одному для каждого элемента), так и из другого кортежа. Копирующее конструирование из набора независимых значений берет первое из этих значений для инициализации элемента `head` (через его базовый класс), а затем передает оставшиеся значения базовому классу, представляющему хвост кортежа:
```c++
Tuple(Head const& head, Tail const& ... tail)
	: head(head), tail(tail...)
{
}
```

Этот код обеспечивает корректность нашего исходного примера `Tuple`:
```c++
Tuple<int, double, std::string> t (17, 3.14, "Hello, World!");
```

Однако это не самый обобщенный интерфейс: пользователи могут пожелать применить перемещающее конструирование для инициализации некоторых (но не всех) элементов или иметь элемент, созданный из значения иного типа. Таким образом, для инициализации кортежа мы должны использовать [[Вывод аргументов шаблона#Прямая передача|прямую передачу]]:
```c++
template<typename VHead, typename... VTail>
Tuple(VHead&& vhead, VTail&& ... vtail)
	: head(std::forward<VHead>(vhead)),
	  tail(std::forward<VTail>(vtail)...)
{
}
```

Затем мы реализуем поддержку построения кортежа из другого кортежа:
```c++
template<typename VHead, typename... VTail>
Tuple(Tuple<VHead, VTail...> const& other)
	: head(other.getHead()), tail(other.getTail())
{
}
```

Однако введения этого конструктора недостаточно, чтобы разрешить преобразования кортежей: для показанного выше кортежа `t` попытка создать еще один кортеж с совместимыми типами завершится ошибкой:
```c++
// Ошибка: нет преобразования Tuple<int, double, string> в long
Tuple<long int, long double, std::string> t2(t);
```

Проблема заключается в том, что шаблон конструктора, предназначенный для инициализации из набора независимых значений, оказывается лучшим соответствием, чем шаблон конструктора, который принимает кортеж. Для решения этой проблемы мы должны использовать [[enable_if#Отключение шаблонов с помощью enable_if<>|std::enable_if<>]] и [[Перегрузка свойств типов#Включение/отключение шаблонов функций|Включение/отключение шаблонов функций]]  для отключения обоих шаблонов функций-членов, когда длина хвоста не соответствует ожидаемой.
```c++
template<typename VHead, typename... VTail,
		typename = std::enable_if_t<sizeof...(VTail) == sizeof...(Tail)>>
Tuple(VHead && vhead, VTail && ... vtail)
	: head(std::forward<VHead>(vhead)),
	  tail(std::forward<VTail>(vtail)...) 
{ }

template<typename VHead, typename... VTail,
		typename = std::enable_if_t<sizeof...(VTail) == sizeof... (Tail)>>
Tuple(Tuple<VHead, VTail...> const& other)
	: head(other.getHead()), tail(other.getTail()) 
( }
```

Вы можете найти все объявления конструкторов в файле `tuples/tuple.hpp`.

Шаблон функции [[#std makeTuple|makeTuple()]] использует вывод для определения типов элементов возвращаемого кортежа `Tuple`, что облегчает создание кортежа из заданного набора элементов:
```c++
template<typename... Types>
auto makeTuple(Types&& ... elems)
{
	return Tuple<std::decay_t<Types>...>(std::forward<Types>(elems)...);
}
```

Здесь вновь используется прямая передача в сочетании со свойством [[decay|std::decay<>]] для преобразования строковых литералов и других обычных массивов в указатели и удаления [[const|const]] и ссылок. Например:
```c++
makeTuple(17, 3.14, "Hello, World!")
```

инициализирует
```c++
Tuple<int, double, char const*>
```

# Базовые операции кортежей

## Сравнение

Кортежи представляют собой структурные типы, содержащие другие значения. Для сравнения двух кортежей достаточно сравнить их элементы. Таким образом, можно написать определение оператора `operator==` для поэлементного сравнения двух определений:
```c++
// Базовый случай:
bool operator== (Tuple<> const&, Tuple<> const&)
{
	// Пустые кортежи всегда эквивалентны
	return true;
}

// Рекурсивный случай:
template<typename Head1, typename... Tail1,
		 typename Head2, typename... Tail2,
		 typename = std::enable_if_t<sizeof...(Tail1) == sizeof...
				(Tail2)>>
bool operator==(Tuple<Head1, Tail1...> const& lhs,
				Tuple<Head2, Tail2...> const& rhs)
{
	return  lhs.getHead() == rhs.getHead() &&
			lhs.getTail() == rhs.getTail();
}
```

Подобно многим алгоритмам для списков типов и кортежей поэлементное сравнение посещает элемент в голове списка, а затем рекурсивно проходит по хвосту, в конечном итоге доходя до базового случая. Операторы `!=`, `<`, `>`, `<=` и `>=` реализуются аналогично.

## Вывод

В этой главе мы будем создавать новые типы кортежей, поэтому полезно иметь возможность видеть эти кортежи в выполняемой программе. Оператор `operator<<` выводит любой кортеж, типы элементов которого могут быть выведены:
```c++
#include <iostream>

void printTuple(std::ostream& strm, Tuple<> const&,
				bool isFirst = true)
{
	strm << (isFirst ? ' (' : ' ) ' ) ;
}

template<typename Head, typename... Tail>
void printTuple(std::ostream& strm, Tuple<Head, Tail...> const& t,
				bool isFirst = true)
{
	strm << (isFirst ? "(" : ", ");
	strm << t.getHead();
	printTuple(strm, t.getTail(), false);
}

template<typename... Types>
std::ostream& operator<<(std::ostream& strm, Tuple<Types...> const& t)
{
	printTuple(strm, t);
	return strm;
}
```

Теперь легко как создавать кортежи, так и выводить их. Например, фрагмент
```c++
std::cout << makeTuple(1, 2.5, std::string("hello")) << '\n';
```

выводит
```c++
(1, 2.5, hello)
```

# Алгоритмы для работы с кортежами

Кортежи представляют собой контейнеры, которые обеспечивают возможность доступа и изменения каждого из их элементов (через `get`), а также создания новых кортежей (непосредственно или с помощью [[#std makeTuple|makeTuple()]] ) и разделения кортежей на голову и хвост (`getHead()` и `getTail()` ). Этих фундаментальных строительных блоков достаточно для создания набора алгоритмов для работы с кортежами, таких как добавление элементов в кортеж или их удаление из него, изменение порядка элементов в кортеже или выборка некоторого подмножества элементов из кортежа.

Алгоритмы для работы с кортежами особенно интересны, потому что они требуются и во время компиляции, и во время выполнения. Подобно [[Списки типов - template#Списки типов|работе со списками типов]], “Списки типов”, применение алгоритма к кортежу может привести к кортежу совершенно иного типа, который требуется для выполнения вычислений времени компиляции. Например, обращение кортежа `Tuple<int,double,string>` дает кортеж `Tuple<string,double, int>`. Однако подобно алгоритмам для гомогенного контейнера (например, [[reverse|std::reverse()]] для [[vector|std::vector]]) алгоритмы для кортежей фактически требуют выполнения кода во время выполнения программы, так что нам нужно не забывать об эффективности генерируемого кода.

## Кортежи как списки типов

Если игнорировать конкретные компоненты времени выполнения нашего шаблона `Tuple`, то мы увидим, что он имеет точно такую же структуру, что и шаблон [[typelist|Typelist]], [[Списки типов - template#Списки типов|разработанный в  “Списки типов”]]: он принимает любое количество параметров типа шаблона. Фактически с использованием небольшой частичной специализации можно превратить кортеж в полнофункциональный список типов:
```c++
// Определение, пуст ли контейнер:
template<>
struct IsEmpty<Tuple<>>
{
	static constexpr bool value = true;
};

// Извлечение первого элемента:
template<typename Head, typename... Tail>
class FrontT<Tuple<Head, Tail...>>
{
	public:
		using Type = Head;
};

// Удаление первого элемента:
template<typename Head, typename... Tail>
class PopFrontT<Tuple<Head, Tail...>>
{
	public:
		using Type = Tuple<Tail...>
};

// Добавление элемента в начало:
template<typename... Types, typename Element>
class PushFrontT<Tuple<Types...>, Element>
{
	public:
		using Type = Tuple<Element, Types...>;
};

// Добавление элемента в конец:
template<typename... Types, typename Element>
class PushBackT<Tuple<Types...>, Element>
{
	public:
		using Type = Tuple<Types..., Element>;
};
```

Теперь все алгоритмы, [[Списки типов - template#Списки типов|разработанные в главе “Списки типов”]], для списков типов, одинаково хорошо работают как с `Tuple`, так и с [[typelist|Typelist]], так что мы легко можем работать с типом кортежей. Например:
```c++
Tuple<int, double, std::string> t1(17, 3.14, "Hello, World!");
using T2 = PopFront<PushBack<decltype(t1), bool>>;
T2 t2(get<1>(t1), get<2>(t1), true);
std::cout << t2;
```

Этот фрагмент кода выводит:
```c++
(3.14, Hello, World!, 1)
```

Как мы вскоре увидим, алгоритмы для списков типов, применяемые к типам кортежей, часто используются для того, чтобы определить тип результата алгоритма для работы с кортежами.

## Добавление элементов в кортеж и удаление их оттуда

Возможность добавления элемента в начало или конец кортежа имеет важное значение для построения более сложных алгоритмов. Как и в случае со списками типов, вставка элемента в начало кортежа гораздо легче, чем вставка в его конец, так что мы начнем с `pushFront`:
```c++
template<typename... Types, typename V>
PushFront<Tuple<Types...>, V>
pushFront<Tuple<Types...> const& tuple, V const& value)
{
	return PushFront<Tuple<Types...>, V>(value, tuple);
}
```

Добавление нового элемента (с именем `value`) в начало существующего кортежа требует от нас сформировать новый кортеж со значением `value` в качестве его головы и существующего кортежа в качестве хвоста. Получающийся в результате кортеж имеет тип `Tuple<v, Types...>`. Однако мы решили использовать алгоритм `PushFront` для списков типов, чтобы продемонстрировать тесную связь между аспектами времени компиляции и времени выполнения алгоритмов для кортежей: `PushFront` времени компиляции вычисляет тип, который нам нужно построить, чтобы получить соответствующее значение времени выполнения.

Добавление нового элемента в конец существующего кортежа является более сложным, потому что оно требует рекурсивного обхода кортежа с построением по мере обхода модифицированного кортежа. Обратите внимание на то, как структура реализации `pushBack()` следует [[Списки типов - template#Добавление в список типов|рекурсивной формулировке `PushBack()` для списка типов]]:
```c++
// Вазовый случай
template<typename V>
Tuple<V> pushBack (Tuple<> const&, V const& value)
{
	return Tuple<V>(value);
}

// Рекурсивный случай
template<typename Head, typename... Tail, typename V>
Tuple<Head, Tail..., V>
pushBack(Tuple<Head, Tail...> const& tuple, V const& value)
{
	return Tuple<Head, Tail..., V>(tuple.getHead(),
									pushBack(tuple.getTail(), value));
}
```

Базовый случай, как и ожидалось, добавляет значение к кортежу нулевой длины, производя кортеж, содержащий только одно это значение. В рекурсивном случае мы формируем новый кортеж из текущего элемента в начале списка (`tuple.getHead()`) и результата добавления нового элемента к хвосту списка (рекурсивный вызов `pushBack`). Хотя мы решили выразить сконструированный тип как `Tuple<Head, Tail. . ., v>`, следует отметить, что это эквивалентно использованию `PushBack<Tuple<Head, Tail...>, V>` времени компиляции.

Реализовать `popFront()` очень легко:
```c++
template<typename... Types>
PopFront<Tuple<Types...>> popFront(Tuple<Types...> const& tuple)
{
	return tuple.getTail();
}
```

Теперь [[tuple (Кортежи)#Кортежи как списки типов|пример]] можно переписать следующим образом:
```c++
Tuple<int, double, std::string> t1(17, 3.14, "Hello, World!");
auto t2 = popFront(pushBack(t1, true));
std::cout << std::boolalpha << t2 << '\n';
```

Этот код выводит
```c++
(3.14, Hello, World!, true)
```

## Обращение порядка элементов кортежа

Порядок элементов кортежа может быть обращен с помощью другого рекурсивного алгоритма для кортежей, структура которого соответствует [[Списки типов - template#Обращение порядка типов в списке|обращению списка типов]]:
```c++
// Базовый случай
Tuple<> reverse (Tuple<> const& t)
{
	return t;
}

// Рекурсивный случай
template<typename Head, typename... Tail>
Reverse<Tuple<Head, Tail...>> reverse(Tuple<Head, Tail...> const& t)
{
	return pushBack(reverse(t.getTail()), t.getHead());
}
```

Базовый случай тривиален, в то время как рекурсивный случай обращает хвост списка и добавляет текущую голову списка к обращенному списку. Это означает, например, что
```c++
reverse(makeTuple(1, 2.5, std::string("hello")))
```
даст `Tuple<string, double, int>` co значениями `string("hello")`, `2.5` и `1`
соответственно.

Как и в случае со списками типов, теперь таким образом можно легко реализовать `рорВаск()` путем вызова `popFront()` для временно [[Списки типов - template#Обращение порядка типов в списке|обращенного списка с использованием РорВаск]]:
```c++
template<typename... Types>
PopBack<Tuple<Types...>> рорВаск(Tuple<Types...> const& tuple)
{
	return reverse(popFront(reverse(tuple)));
}
```

## Индексные списки

Рекурсивная формулировка обращения порядка элементов кортежа в предыдущем разделе корректна, но излишне неэффективна во время выполнения. Чтобы понять, в чем заключается проблема, рассмотрим простой класс, который подсчитывает количество своих копирований:
```c++
template<int N>
struct CopyCounter
{
	inline static unsigned numCopies = 0;
	
	CopyCounter()
	{
	}
	
	CopyCounter(CopyCounter const&)
	{
		++numCopies;
	}
};
```

Затем создадим и обратим кортеж экземпляров `CopyCounter`:
```c++
void copycountertest()
{
	Tuple<CopyCounter<0>, CopyCounter<1>, CopyCounter<2>,
			CopyCounter<3>, CopyCounter<4>>
	auto reversed = reverse(copies);
	
	std::cout << "0 :" << CopyCounter<0>:numCopies << " copies\n";
	std::cout << "1 :" << CopyCounter<1>:numCopies << " copies\n";
	std::cout << "2 :" << CopyCounter<2>:numCopies << " copies\n";
	std::cout << "3 :" << CopyCounter<3>:numCopies << " copies\n";
	std::cout << "4 :" << CopyCounter<4>:numCopies << " copies\n";
```

Вывод данной программы имеет следующий вид:
```c++
0: 5 copies
1: 8 copies
2: 9 copies
3: 8 copies
4: 5 copies
```

Очень большое количество копирований! В идеальной реализации обращения порядка элементов кортежа каждый элемент будет скопирован только один раз, из исходной позиции непосредственно в правильную позицию в результирующем кортеже. Мы могли бы достичь этой цели с помощью тщательного использования ссылок, включая применение ссылок для типов промежуточных аргументов, но это значительно усложнит нашу реализацию.

Для устранения излишних копирований при обращении порядка элементов в кортеже рассмотрим, как можно было бы реализовать эту операцию для одного кортежа известной длины (скажем, из 5 элементов, как в нашем примере). Мы могли бы просто использовать [[#std makeTuple|makeTuple()]] и `get()`:
```c++
auto reversed = makeTuple(get<4>(copies), get<3>(copies),
							get<2>(copies), get<1>(copies),
							get<0>(copies));
```

Эта программа дает тот результат, который нам нужен, при единственном копировании каждого элемента кортежа:
```c++
0: 1 copies
1: 1 copies
2: 1 copies
3: 1 copies
4: 1 copies
```

Индексные списки (`index lists`, именуемые также списками индексов или последовательностями индексов (`index sequences`); [[Списки типов - template#Оптимизация алгоритмов с помощью раскрытий пакетов|см. раздел]]) обобщают это понятие, захватывая множество индексов кортежа — в данном случае `4`, `3`, `2`, `1`, `0` — в пакет параметров, который позволяет получить последовательность вызовов `get` с помощью раскрытия пакета. Это дает возможность отделить вычисление индексов, которое может быть сколь угодно сложной шаблонной метапрограммой, от фактического применения этого индексного списка, где очень важна эффективность времени выполнения. Для представления индексных списков часто используется стандартный тип `std::integer_sequence` (введен в C++14).

## Обращение с использованием индексных списков

Чтобы выполнить обращение порядка элементов в кортеже с помощью индексных списков, сначала нам нужно иметь представление этих индексных списков. Такой список является типом, содержащим значения, используемые в качестве индексов в [[Списки типов - template#Оптимизация алгоритмов с помощью раскрытий пакетов|списке типов или гетерогенной структуре данных]]. Для нашего индексного списка мы будем [[Списки типов - template#Списки нетиповых параметров|использовать тип `Valuelist`, разработанный тут]]. Список индексов, соответствующий приведенному выше примеру обращения элементов кортежа, имеет вид
```c++
Valuelist<unsigned, 4, 3, 2, 1, 0>
```

Как получить этот список индексов? Один из подходов заключается в том, чтобы начать с создания списка с индексами от `0` до `N-1` включительно, где `N` — длина кортежа, используя простую шаблонную метапрограмму `MakelndexList`:
```c++
// Рекурсивный случай
template<unsigned N, typename Result = Valuelist<unsigned>>
struct MakelndexListT
	: MakeIndexListT<N-1,
					PushFront<Result, CTValue<unsigned, N-1>>>
{
};

// Базовый случай
template<typename Result>
struct MakelndexListT<O, Result>
{
	using Type = Result;
};

template<unsigned N>
using MakelndexList = typename MakeIndexListT<N>::Type;
```

Затем можно объединить эту операцию с `Reverse` для списков типов, чтобы создавать соответствующий список индексов:
```c++
using MylndexList = Reverse<MakeIndexList<5>>;
// Эквивалентно Valuelist<unsigned, 4, 3, 2, 1, 0>
```

Для фактического обращения индексы в списке должны быть захвачены пакетом нетиповых параметров. Это выполняется путем разделения реализации алгоритма `reverse()` для кортежа с индексами на две части:
```c++
template<typename... Elements, unsigned... Indices>
auto reverselmpl(Tuple<Elements...> const& t,
				 Valuelist<unsigned, Indices...>)
{
	return makeTuple(get<indices>(t)...);
}

template<typename... Elements>
auto reverse(Tuple<Elements...> const& t)
{
	return reverselmpl(t,
						Reverse<MakelndexList<sizeof...(Elements)>>());
}
```

В C++11 возвращаемые типы должны быть объявлены как
```c++
->decltype(makeTuple(get<indices>(t)...))
```

и
```c++
->decltype(reverselmpl(t,Reverse<MakeIndexList<sizeof...(Elements)>>()))
```

Шаблон функции `reverselmpl()` захватывает индексы из своего параметра `Valuelist` в пакет параметров `Indices`. Затем он возвращает результат вызова `makeTuple()` с аргументами, сформированными вызовом `get()` для кортежа со множеством захваченных индексов.

Сам по себе алгоритм [[reverse|reverse()]], как обсуждалось ранее, просто формирует соответствующее множество индексов и предоставляет его алгоритму `reverselmpl`. Работа с индексами выполняется с помощью шаблонного метапрограммирования, а потому не производит кода времени выполнения. Единственный код времени выполнения находится в шаблоне `reverselmpl`, который использует [[#std makeTuple|makeTuple()]] для построения результирующего кортежа за один шаг, и поэтому копирование элементов кортежа выполняется только однократно.

## Тасование и выбор

Шаблон функции `reverselmpl()`, используемый в предыдущем разделе для формирования кортежа с обращенным порядком элементов, фактически не содержит кода, специфичного для операции [[reverse|reverse()]]. Вместо этого он просто выбирает определенное множество индексов из существующего кортежа и использует его для формирования нового кортежа, [[reverse|reverse()]] обеспечивает набор индексов в обратном порядке, но многие алгоритмы могут быть построены на базовом алгоритме [[Select|select()]]:
```c++
template<typename... Elements, unsigned... Indices>
auto select(Tuple<Elements...> const& t,
			Valuelist<unsigned, Indices...>)
{
	return makeTuple(get<Indices>(t) ...);
}
```

Один простой алгоритм, который основан на [[Select|select()]], представляет собой операцию “размножения” над кортежем, принимая один элемент кортежа и реплицируя его для создания другого кортежа с некоторым количеством копий этого элемента. Например, код
```c++
Tuple<int, double, std::string> t1(42, 7.7, "hello");
auto a = splat<1, 4>(t);
std::cout << a << '\n';
```

генерирует кортеж `Tuple<double, double, double, double>`, в котором каждое значение является копией `get<1>(t)`, так что вывод этого фрагмента кода имеет вид
```c++
(7.7, 7.7, 7.7, 7.7)
```

В приведенной ниже метапрограмме, производящей реплицированное множество индексов, состоящее из `N` копий значения `I`, [[splat|splat ()]] представляет собой непосредственное применение `select()`:
```c++
template<unsigned I, unsigned N,
		typename IndexList = Valuelist<unsigned>>
class ReplicatedIndexListT;

template<unsigned I, unsigned N, unsigned... Indices>
class ReplicatedIndexListT<I, N, Valuelist<unsigned, Indices...>>
			: public ReplicatedIndexListT < I, N - 1,
					Valuelist<unsigned, Indices..., I >>
{
};

template<unsigned I, unsigned... Indices>
class ReplicatedIndexListT<I, 0, ValueList<unsigned, Indices...>>
{
	public:
		using Type = ValueList<unsigned, Indices...>;
};

template<unsigned I, unsigned N>
using ReplicatedIndexList = typename ReplicatedIndexListT<I, N>::Type;

template<unsigned I, unsigned N, typename... Elements>
auto splat(Tuple<Elements...> const& t)
{
	return select(t, ReplicatedIndexList<i, N> ());
}
```

Даже сложные алгоритмы для работы с кортежами могут быть реализованы в терминах шаблонных метапрограмм для списка индексов с последующим применением [[Select|select()]]. Например, можно использовать [[Списки типов - template#Сортировка вставками|сортировку вставками]], для сортировки кортежа на основе размеров типов элементов. При наличии такой функции [[sort|sort()]], которая принимает шаблонную метафункцию, сравнивающую типы элементов кортежа, в качестве компаратора, мы могли бы сортировать элементы кортежа по размеру с помощью кода наподобие следующего:
```c++
#include ccomplex>

template<typename T, typename U>
class SmallerThanT
{
	public:
		static constexpr bool value = sizeof(T) < sizeof(U);
};

void testTupleSort()
{
	auto t1 = makeTuple(17LL,std::complex<double>(42,77),'c',42,7.7);
	std::cout << tl << '\n';
	auto t2 = sort<SmallerThanT>
				(t1); // t2 является Tuple<int, long, std::string>
	std::cout << "Сортировка по размеру: " << t2 << '\n';
}
```

Вывод этого кода может иметь следующий вид:
```c++
(17, (42,77), с, 42, 7.7)
Сортировка по размеру: (с, 42, 7.7, 17, (42,77))
```

Фактическая реализация [[sort|sort()]]  включает применение `InsertionSort` в [[Select|select()]]:
```c++
// Оболочка-метафункция, сравнивающая элементы кортежа:
template<typename List, template<typename Т, typename U> class F>
class MetafunOfNthElementT
{
	public:
		template<typename T, typename U> class Apply;
		template<unsigned N, unsigned M>
		class Apply<CTValue<unsigned, M>, CTValue<unsigned, N>>
				: public F<NthElement<List,M>, NthElement<List,N>>{};
};

// Сортировка кортежа, основанная на сравнении типов элементов:
template<template<typename Т, typename U> class Compare,
		typename... Elements>
auto sort(Tuple<Elements...> const& t)
{
	return select(t,
				InsertionSort<MakelndexList<sizeof...(Elements)>,
								MetafunOfNthElementT<Tuple<Elements...>,
											Compare>::template Apply>());
}
```

Взгляните на использование `InsertionSort` внимательно: фактический сортируемый список типов является списком индексов, указывающих на элементы списка типов, построенного с помощью `MakelndexList<>`. Таким образом, результатом сортировки вставками является набор индексов, указывающих на элементы кортежа, который затем предоставляется алгоритму [[Select|select()]]. Однако, поскольку `InsertionSort` работает с индексами, он ожидает компаратор, который сравнивает два индекса. Принцип легче понять при рассмотрении сортировки индексов [[vector|std::vector]], выполняемой в следующем (не мегапрограммном!) примере:
```c++
#include <vector>
#include <algorithm>
#include <string>

int main()
{
	std::vector<std::string> strings = {"banana", "apple", "cherry"};
	std::vector<unsigned> indices = { 0, 1, 2 };
	std::sort(indices.begin(), indices.end(),
				[&strings] (unsigned i, unsigned j)
				{
					return strings[i] < strings[j];
				});
}
```

Здесь `indices` содержит индексы элементов вектора строк. Операция [[sort|sort()]] сортирует индексы, так что лямбда-выражение компаратора принимает два значения типа `unsigned` (вместо строк). Однако тело лямбда-выражения использует эти `unsigned` значения в качестве индексов элементов вектора строк, поэтому порядок фактически соответствует содержимому строк. По окончании сортировки `indices` содержит индексы элементов вектора строк, отсортированные на основе значений этих строк.

Наше использование `InsertionSort` для [[sort|sort()]] для кортежа применяет тот же подход. Шаблон адаптера `MetafunOfNthElementT` предоставляет шаблонную метафункцию (вложенный класс `Apply`), которая принимает два индекса (специализации `CTValue`) и использует `NthElement`, чтобы извлечь соответствующие элементы из его аргумента [[typelist|Typelist]]. В некотором смысле шаблон члена `Apply` “захватывает” список типов, предоставленный охватывающему его шаблону (`MetafunOfNthElementT`) таким же образом, как лямбда-выражение захватывает вектор строк из охватывающей области видимости. Затем `Apply` передает извлеченные типы базовой метафункции `F`, завершая адаптацию.

Обратите внимание на то, что все вычисления для сортировки выполняются во время компиляции, а результирующий кортеж формируется непосредственно, без излишнего копирования значений во время выполнения.

# Распаковка кортежей

Кортежи полезны для хранения набора связанных значений вместе в одном объекте, независимо от типов этих значений или от их количества. В определенный момент может потребоваться распаковать такой кортеж, например, передать его элементы функции в качестве отдельных аргументов. В качестве простого примера мы хотим взять кортеж и передать его элементы [[Вглубь шаблонов#Вариативные шаблоны|вариативной операции print()]]:
```c++
Tuple<std::string, char const*, int, char> t("Pi", "is roughly", 3, '\n');
print(t...); // Ошибка: невозможно распаковать кортеж - он
				// не является пакетом параметров
```

Как показано в примере, “очевидная” попытка распаковать кортеж не удается, потому что это не пакет параметров. Того же можно добиться с помощью списка индексов. Показанный ниже шаблон функции `apply()` принимает функцию и кортеж, а затем вызывает функцию с распакованными элементами кортежа:
```c++
template<typename F, typename... Elements, unsigned... Indices>
auto applyImp1(F f, Tuple<Elements...> const& t,
				Valuelist<unsigned, Indices...>)
->decltype(f(get<Indices>(t)...))
{
	return f (get<Indices>(t)...);
}

template<typename F, typename... Elements,
			unsigned N = sizeof...(Elements)>
auto apply(F f, Tuple<Elements...> const& t)
->decltype(applyImp1(f, t, MakeIndexList<N>()))
{
	return applyImp1(f, t, MakeIndexList<N>());
)
```

Шаблон функции `applyImp1()` принимает список индексов и использует его для распаковки элементов кортежа в список аргументов для его аргумента `f`, который представляет собой функциональный объект. Функция `apply()`, с которой работает пользователь, отвечает только за построение начального списка индексов. Вместе они позволяют нам распаковать кортеж для передачи в качестве аргументов `print()`:
```c++
Tuple<std::string, char const*, int, char>
		t("Pi", "примерно равно", 3, '\n');
apply(print, t); // OK: выводит "Pi примерно равно 3"
```

C++17 предоставляет подобную функцию, которая работает с любым “кортеже-образным” типом.

# Оптимизация кортежей

Кортеж является фундаментальным гетерогенным контейнером с большим количеством потенциальных способов использования. Поэтому имеет смысл обсудить, что можно сделать для оптимизации использования кортежей как во время выполнения (с точки зрения используемой памяти и времени работы), так и во время компиляции (количество инстанцирований шаблонов). В этом разделе рассматриваются несколько конкретных оптимизаций нашей реализации кортежа `Tuple`.

## Кортежи и оптимизация пустого базового класса

Наш кортеж `Tuple` использует больше памяти, чем это строго необходимо. Одна из проблем заключается в том, что член `tail` в конечном итоге будет пустым кортежем, потому что каждый непустой кортеж завершается пустым кортежем, а члены-данные всегда должны иметь размер, составляющий хотя бы один байт.

Для повышения эффективности использования памяти кортежем `Tuple` можно применить [[Шаблоны и наследование#Оптимизация пустого базового класса|оптимизацию пустого базового класса]] (`empty base class optimization — ЕВСО`), наследуя хвост вместо использования его в качестве члена. Например:
```c++
// Рекурсивный случай:
template<typename Head, typename... Tail>
class Tuple<Head, Tail...> : private Tuple<Tail...>
{
	private:
		Head head;
	public:
		Head& getHead() { return head; }
		Head const& getHead() const { return head; }
		Tuple<Tail...>& getTail() { return *this; }
		Tuple<Tail...> const& getTail() const { return *this; }
};
```

Это тот же подход, [[Шаблоны и наследование#Члены как базовые классы|который мы применяли к BaseMemberPair]]. К сожалению, на практике он имеет побочный эффект, заключающийся в обратном порядке инициализации элементов кортежа в конструкторах. Ранее, поскольку член `head` предшествовал члену `tail`, `head` инициализировался первым. В новой формулировке `Tuple` хвост содержится в базовом классе, поэтому он будет инициализирован до члена `head`.

Эта проблема может быть решена путем помещения члена `head` в собственный базовый класс, который предшествует в списке базовых классов хвосту. Непосредственная реализация этого решения вводит шаблон `TupleElt`, который используется для создания оболочки для каждого типа элемента, так что кортеж может его наследовать:
```c++
template<typename... Types>
class Tuple;

template<typename T>
class TupleElt
{
		T value;
	public:
		TupleElt() = default;
		
		template<typename U>
		TupleElt(U&& other) : value(std::forward<U>(other) {}

		T& get()
		{
			return value;
		}

		T const& get() const
		{
			return value;
		}
};

// Рекурсивный случай:
template<typename Head, typename... Tail>
class Tuple<Head, Tail...>
		: private TupleElt<Head>, private Tuple<Tail...>
{
	public:
		Head& getHead()
		{
			// Потенциальная неоднозначность
			return static_cast<TupleElt<Head> *>(this)->get();
		}
		
		Head const& getHead() const
		{
			// Потенциальная неоднозначность
			return static_cast<TupleElt<Head> const*>(this)->get();
		}
		
		Tuple<Tail...>& getTail()
		{
			return *this;
		}
		
		Tuple<Tail...> const& getTail() const
		{
			return *this;
		}
};

// Базовый случай:
template<>
class Tuple<>
{
	// Хранилище не требуется
};
```

Несмотря на то что этот подход решает проблему порядка инициализации, он добавляет новую (худшую) проблему: мы больше не можем извлекать элементы из кортежа, содержащего два элемента одного и того же типа, такого как `Tuple<int, int>`, потому что преобразование производного типа кортежа в базовый тип `TupleElt` для этого типа (например, `TupleElt<int>`) оказывается неоднозначным.

Чтобы избежать неоднозначности, мы должны гарантировать, что каждый базовый класс `TupleElt` является уникальным в пределах данного `Tuple`. Один из подходов заключается в том, чтобы закодировать “высоту” этого значения в кортеже, т.е. длину хвоста кортежа. Последний элемент в кортеже будет храниться с высотой `0`, предпоследний элемент будет храниться с высотой `1` и так далее:
```c++
template<unsigned Height, typename T>
class TupleElt
{
		Т value;
	public:
		TupleElt() = default;
		
		template<typename U>
		TupleElt(U&& other) : value(std::forward<U>(other)) {}
		
		T& get()
		{
			return value;
		}
		
		T const& get() const
		(
			return value;
		}
}
```

При наличии такого решения можно создавать `Tuple`, который использует оптимизацию пустого базового класса при сохранении порядка инициализации и поддержки нескольких элементов одного типа:
```c++
template<typename... Types>
class Tuple;

// Рекурсивный случай:
template<typename Head, typename... Tail>
class Tuple<Head, Tail...>
	: private TupleElt<sizeof...(Tail), Head>, private Tuple<Tail...>
{
		using HeadElt = TupleElt<sizeof...(Tail), Head>;
	public:
		Head& getHead()
		{
			return static_cast<HeadElt*>(this)->get();
		}
		
		Head const& getHead() const
		{
			return static_cast<HeadElt const*>(this)->get();
		}
		
		Tuple<Tail...>& getTail()
		{
			return *this;
		}
		
		Tuple<Tail...> const& getTail() const
		{
			return *this;
		}
};

// Базовый случай:
template<>
class Tuple<>
(
	// Хранилище не требуется
};
```

При использовании такой реализации приведенная ниже программа
```c++
#include <algorithm>
#include "tupleeltl.hpp"
#include "tuplestorage3.hpp"
#include <iostream>

struct A
{
	A()
	{
		std::cout << "A()" << '\n';
	}
};

struct В
{
	В ()
	{
		std::cout << "B()" << ' \n';
	}
};

int main()
{
	Tuple<A, char, A, char, B> t1;
	std::cout << sizeof(t1) << " bytes" << '\n';
};
```

выводит на консоль следующее:
```c++
А()
А()
B()
5 bytes
```

Оптимизация пустого базового класса убрала один байт (для пустого кортежа `Tuple<>`). Однако обратите внимание на то, что и `А`, и `В` являются пустыми классами, что намекает на еще одну возможность для применения этой оптимизации в `Tuple`. `TupleElt` можно несколько расширить и наследовать от типа элемента в случаях, когда это можно сделать безопасно, без внесения изменений в `Tuple`:
```c++
#include <type_traits>

template <unsigned Height, typename T,
			bool = std::is_class<T>::value && !std::is_final<T>::value>
class TupleElt;

template<unsigned Height, typename T>
class TupleElt<Height, T, false>
{
		T value;
	public:
		TupleElt() = default;
	
		template<typename U>
		TupleElt(U&& other) : value(std::forward<U>(other)) {}

		T& get()
		{
			return value;
		}

		T const& get() const
		{
			return value;
		}
};

template<unsigned Height, typename T>
class TupleElt<Height, T, true> : private T
{
	public:
		TupleElt() = default;

		template<typename U>
		TupleElt(U&& other) : T(std::forward<U>(other)) {}

		T& get()
		{
			return *this;
		}
		
		T const& get() const
		{
			return *this;
		}
};
```

Когда `TupleElt` предоставляется с классом, не являющимся `final`, он закрыто (`private`) наследует этот класс, чтобы обеспечить применение оптимизации пустого базового класса к сохраненному значению. При внесении этого изменения представленная ранее программа теперь выведет в консоль
```
А()
А()
В()
2 bytes
```

## get () с константным временем работы

Операция `get()` исключительно широко используется при работе с кортежами, но ее рекурсивная реализация требует линейного количества инстанцирований шаблонов, что может повлиять на время компиляции. К счастью, оптимизация пустого базового класса, представленная в предыдущем разделе, обеспечивает более эффективную реализацию `get`, которую мы сейчас рассмотрим.

Ключевым является понимание того, что [[Вывод аргументов шаблона#Вывод аргументов шаблона|вывод аргумента шаблона]] выводит аргументы шаблона для базового класса, когда параметр (тип базового класса) соответствует аргументу (типу производного класса). Таким образом, если мы можем вычислить высоту `Н` элемента, который хотим извлечь, то для извлечения элемента без ручного перебора всех индексов мы можем полагаться на преобразование специализации `Tuple` в `TupleElt<H, Т>` (где тип `Т` выводится):
```c++
template<unsigned Н, typename Т>
Т& getHeight(TupleElt<H, Т>& te)
{
	return te.get();
}

template<typename... Types>
class Tuple;

template<unsigned I, typename... Elements>
auto get(Tuple<Elements...>& t)
-> decltype(getHeight < sizeof...(Elements) - I - 1 > (t))
{
	return getHeight < sizeof... (Elements) - I - 1 > (t);
}
```

Поскольку `get<I>(t)` получает индекс `I` требуемого элемента (который отсчитывается с начала кортежа), в то время как фактически хранение данных в кортеже выполняется в терминах высоты `Н` (которая отсчитывается от конца кортежа), мы вычисляем `Н` из `I`. Фактический поиск выполняется выводом аргумента шаблона для вызова `getHeight()`: высота `Н` фиксирована, потому что она явно предоставлена в вызове, так что соответствие при выводе будет только у одного базового класса `TupleElt`, из которого будет выведен тип `Т`. Обратите внимание на то, что `getHeight()` должен быть объявлен другом `Tuple`, чтобы разрешить преобразование в закрытый базовый класс. Например:
```c++
// В рекурсивном случае шаблона класса Tuple:
template<unsigned I, typename... Elements>
friend auto get(Tuple<Elements...>& t)
-> decltype(getHeight < sizeof...(Elements) - I - 1 > (t) );
```

Обратите внимание на то, что эта реализация требует только константного количества инстанцирований шаблонов, поскольку тяжелая работа по выявлению соответствия индекса передана механизму вывода аргумента шаблона компилятора.

# Индексы кортежа

В принципе, можно также определить `operator[]` для доступа к элементам кортежа, аналогично тому, как [[vector|std::vector]] определяет оператор `operator[]`. Однако в отличие от [[vector|std::vector]] каждый элемент кортежа может иметь свой тип, поэтому `operator[]` для кортежа должен быть шаблоном, тип результата которого отличается в зависимости от индекса элемента. Это, в свою очередь, требует, чтобы каждый индекс имел собственный тип, так что тип индекса может использоваться для определения типа элемента.

[[Списки типов - template#Списки нетиповых параметров|Шаблон класса `CTValue`]], позволяет закодировать числовой индекс в типе. Мы можем использовать его для определения оператора индексации как члена `Tuple`:
```c++
template<typename Т, Т Index>
auto& operator[](CTValue<T, Index>)
{
	return get<Index>(*this);
}
```

Здесь мы используем значение переданного индекса в типе аргумента `CTValue`, чтобы выполнить соответствующий вызов `get<>()`.

Теперь можно использовать этот класс следующим образом:
```c++
auto t = makeTuple(0, '1', 2.2f, std::string}"hello"});
auto a = t[CTValue<unsigned, 2> {}];
auto b = t[CTValue<unsigned, 3> {}];
```

Здесь `а` и `b` будут инициализированы типом и значением третьего и четвертого элементов кортежа `Tuple t`.

Чтобы сделать использование константных индексов более удобным, можно реализовать [[constexpr|constexpr-оператор]] литерала (`literal operator with constexpr`) для вычисления числовых литералов времени компиляции непосредственно из обычных литералов с помощью суффикса `_с`:
```c++
#include "ctvalue.hpp"
#include <cassert>
#include <cstddef>

// Преобразование отдельного символа в соответствующее
// значение типа int во время компиляции:
constexpr int tolnt(char с)
{
	// Шестнадцатеричные буквы:
	if(с >= 'A' && с <= 'F')
	{
		return static_cast<int>(с) - static_cast<int>('А') + 10;
	}
	
	if(с >= 'а' && с <= 'f')
	{
		return static_cast<int>(с) - static_cast<int>('а') + 10;
	}
	
	// Прочие (отключаем '.' для литералов чисел с плавающей точкой):
	assert(с >= '0' && с <= '9');
	return static_cast<int>(с) - static_cast<int>('0');
}

// Анализ массива символов для преобразования в соответствующее
// целочисленное значение во время компиляции:
template<std::size_t N>
constexpr int parseInt(char const (&arr)[N])
{
	int base = 10;    // Обработка основания (10 по умолчанию)
	int offset = 0;   // Для пропуска префиксов наподобие Ох

	if(N > 2 && arr[0] == 'O' )
	{
		switch (arr[1])
		{
			case 'x':     // Префикс Ox или OX, шестнадцатеричное
			case 'X':     // значение
				base = 16;
				offset = 2;
				break;
				
			case 'b':     // Префикс Ob или OB (начиная с C++14)
			case 'В':     // бинарное значение
				base = 2;
				offset = 2;
				break;
				

			default:       // Префикс 0 — восьмеричное значение
				base = 8;
				offset = 1;
				break;
		}
	}

	// Итерация по всем цифрам и вычисление результата:
	int value = 0;
	int multiplier = 1;

	for(std::size_t i = 0; i < N - offset; ++i)
	{
		if(arr[N - 1 - i] != '\'') // Игнорируем разделение одинарными
									// кавычками (например, в 1'000)
		{
			value += toInt(arr[N - 1 - i]) * multiplier;
			multiplier *= base;
		}
	}
	
	return value;
}

// Оператор литерала: анализ целочисленного литерала
// с суффиксом _с как последовательности символов:
template<char... cs>
constexpr auto operator"" _c()
{
	return CTValue < int, parseInt<sizeof...(cs)>({cs...}) > {};
}
```

Здесь используется тот факт, что для числовых литералов можно применять [[Вывод аргументов шаблона#Шаблоны оператора литерала|оператор литерала для вывода каждого символа литерала как своего собственного параметра шаблона]]. Мы передаем символы во вспомогательную [[constexpr|constexpr]]-функцию `parselnt()`, которая вычисляет значение последовательности символов во время компиляции и выдает его как
`CTValue`. Например:
>
> 42__с дает CTValue<int, 42>
> 
> 0х815_с дает CTValue<int, 2069>
> 
> 0b1111'1111_с дает CTValue<int, 255>

Обратите внимание на то, что анализатор не обрабатывает литералы с плавающей точкой. Для них выдается ошибка времени компиляции, потому что функция времени выполнения не может использоваться в контексте времени компиляции.

Теперь мы можем использовать кортежи следующим образом:
```c++
auto t = makeTuple(O, '1', 2.2f, std::string{"hello"});
auto c = t[2_c];
auto d = t[3_c];
```

Этот подход использован в Boost.Hana, библиотеке метапрограммирования, пригодной для вычислений как с типами, так и со значениями.



