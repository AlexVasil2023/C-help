
[[#std tuple|std::tuple]]
[[#std tuple_size|std::tuple_size]]
[[#std tuple_element|std::tuple_element]]
[[#std makeTuple|std::makeTuple]]
[[#Кортежи C++11|Кортежи C++11]]
[[#Кортежи C++17|Кортежи C++17]]
[[#Кортежи|Кортежи]] 25(template)
1. [[#Базовый дизайн Tuple|Базовый дизайн Tuple]] 25.1
	1. [[#Хранилище|Хранилище]] 25.1.1
	2. [[#Создание кортежа|Создание кортежа]] 25.1.2
2. [[#Базовые операции кортежей|Базовые операции кортежей]] 25.2
	1. [[#Сравнение|Сравнение]] 25.2.1
	2. [[#Вывод|Вывод]] 25.2.2
3. [[#Алгоритмы для работы с кортежами|Алгоритмы для работы с кортежами]] 25.3
	1. [[#Кортежи как списки типов|Кортежи как списки типов]] 25.3.1
	2. [[#Добавление элементов в кортеж и удаление их оттуда|Добавление элементов в кортеж и удаление их оттуда]] 25.3.2
	3. [[#Обращение порядка элементов кортежа|Обращение порядка элементов кортежа]] 25.3.3


# std::tuple
#std_tuple




# std::tuple_size
#std_tuple_size



# std::tuple_element
#std_tuple_element


# std::makeTuple
#std_makeTuple



# Кортежи C++11
Кортежи представляют собой наборы неоднородных значений фиксированного размера.
```c++
// `playerProfile` имеет тип `std::tuple<int, const char*, const char*>`. 

auto playerProfile = std::make_tuple(51, "Frans Nielsen", "NYI"); 
std::get<0>(playerProfile); // 51 
std::get<1>(playerProfile); // "Frans Nielsen" 
std::get<2>(playerProfile); // "NYI"
```

# Кортежи C++17 #

Эта структура появилась в C++11. Они аналогичны массивам и представляют собой коллекции с фиксированной длиной. Кортежи можно использовать, чтобы вернуть несколько значений функции, например так:
```C++
#include <tuple> 

auto get() { 
	return std::make_tuple("fred", 42); 
}
```

Этот пример вернет кортеж с двумя членами. В C++14 версии появилась возможность использовать **auto** с возвращаемыми типами функций, чтобы сделать вызов функции более аккуратным. Для получения значений кортежа, при этом, будет требоваться **std::get**: 
```c++
auto t = get(); 
std::cout << std::get<0>(t) << std::endl;
```

Через **std::tie** можно привязать элементы кортежа к переменным, которые уже должны быть объявлены:
```c++
std::string name; 
int age; 

std::tie(name, age) = get();
```

Благодаря этому методу можно привязывать элементы кортежа к переменным без std::get и необходимости объявлять переменные заранее:
```c++
auto [name, age] = get(); 
std::cout << name << " is " << age << std::endl;
```

Этот метод также позволяет получить ссылки к элементам кортежа, что невозможно с [[tie|std::tie]]:
```c++
auto t2 = std::make_tuple(10, 20); 

auto& [first, second] = t2; 
first += 1; 

std::cout << "value is now " << std::get<0>(t2) << std::endl;
```

# Кортежи

В этой книге для иллюстрации возможностей шаблонов часто используются однородные (гомогенные) контейнеры и типы, подобные массивам. Такие однородные структуры расширяют концепцию массива в языках программирования С и C++ и часто используются во многих приложениях. В этих языках также есть гетерогенные образования, способные хранить данные — классы или структуры. В данной главе рассматриваются `кортежи (tuple)`, агрегирующие данные подобно классам или структурам. Например, кортеж, содержащий `int`, `double` и [[string|std::string]], подобен структуре с членами `int`, `double` и [[string|std::string]], с тем отличием, что к элементам кортежа можно обращаться по их индексам (`0`, `1`, `2`), а не с помощью имен. Этот позиционный интерфейс и возможность легко создавать кортежи из списков типов делают кортежи более подходящими для использования в шаблонном метапрограммировании, чем структуры.

Существует альтернативный взгляд на кортежи как на проявление списков типов в выполнимой программе. Например, в то время как список типов `Typelist<int, double, std::string`> описывает последовательность типов, содержащую `int`, `double` и [[string|std::string]], с которыми можно работать во время компиляции, `Tuple<int, double, std::string>` описывает хранилище для `int`, `double` и [[string|std::string]], с которым можно работать во время выполнения. Например, в следующей программе создается экземпляр такого кортежа:
```c++
template<typename... Types>
class Tuple
{
	... // Реализация обсуждается ниже
};

Tuple<int, double, std::string> t(17, 3.14, "Hello, World!");
```

В шаблонном метапрограммировании распространено использование списков типов для создания кортежей, которые могут применяться для хранения данных. Например, несмотря на то, что мы произвольно выбрали `int`, `double` и [[string|std::string]] как типы элементов в приведенном выше примере, мы могли бы создать набор типов, хранящихся в кортеже, с помощью метапрограммы.

В оставшейся части этой главы мы будем изучать реализацию и работу с шаблоном класса `Tuple`, который представляет собой упрощенную версию шаблона класса `std::tuple`.

# Базовый дизайн Tuple

## Хранилище

Кортежи содержат хранилища для каждого из типов в списке аргументов шаблона. Эти места хранения могут быть доступны с использованием шаблонной функции `get`, синтаксис применения которой `get<I>(t)` для получения `I-го` элемента кортежа `t`. Например, `get<0>(t)` для `t` из предыдущего примера возвращает ссылку на `int 17`, в то время как `get<1>(t)` возвращает ссылку на `double 3.14'.

Рекурсивная формулировка хранилища в кортеже основана на той идее, что кортеж, содержащий `N > 0` элементов, может храниться как единственный элемент (первый элемент, или голова списка) и кортеж, содержащий `N-1` элемент (хвост), с отдельным частным случаем кортежа без элементов. Таким образом, трехэлементный кортеж `Tuple<int, double, std::string>` может храниться как `int` и кортеж `Tuple<double, std::string>`. Этот двухэлементный кортеж сам может храниться как `double` и `Tuple<std::string>`, причем последний может храниться как `std::string` и `Tuple<>`. Фактически это такое же рекурсивное разложение, как и используемое в обобщенных версиях алгоритмов для списков типов, и фактическая реализация рекурсивного хранения кортежа разворачивается аналогично тому, как это делалось со списками типов:
```c++
template<typename... Types>
class Tuple;

// Рекурсивный случай:
template<typename Head, typename... Tail>
class Tuple<Head, Tail...>
{
	private:
		Head head;
		Tuple<Tail...> tail;
		
	public:
		// Конструкторы:
		Tuple()
		{
		}
		
		Tuple(Head const& head, Tuple<Tail...> const& tail)
			: head(head), tail(tail)
		{
		)

	...

		Head& getHead()
		{
			return head;
		}

		Head const& getHead() const
		{
			return head;
		}
		
		Tuple<Tail...>& getTail()
		{
			return tail;
		}
		
		Tuple<Tail...> const& getTail() const
		{
			return tail;
		}

		// Базовый случай:
		template<>
		class Tuple<>
		{
			// Хранилище не требуется
		};
};
```

В рекурсивном случае каждый экземпляр класса `Tuple` содержит член-данное `head`, который хранит первый элемент в списке, а также член-данное `tail`, который хранит оставшиеся элементы в списке. Базовый случай является просто пустым кортежем, который не имеет связанного с ним хранилища для данных.

Шаблон функции `get` проходит по этой рекурсивной структуре для извлечения запрошенного элемента:
```c++
// Рекурсивный случай:
template<unsigned N>
struct TupleGet
{
	template<typename Head, typename... Tail>
	static auto apply(Tuple<Head, Tail...> const& t)
	{
		return TupleGet < N - 1 >::apply(t.getTail());
	}
};

// Базовый случай:
template<>
struct TupleGet<0>
{
	template<typename Head, typename... Tail>
	static Head const& apply(Tuple<Head, Tail...> const& t)
	{
		return t.getHead();
	}
};

template<unsigned N, typename... Types>
auto get(Tuple<Types...> const& t)
{
	return TupleGet<N>::apply(t);
}
```

Обратите внимание на то, что шаблон функции `get` — это просто тонкая оболочка над вызовом статической функции-члена `TupleGet`. Этот метод фактически является [[Дальнейшее развитие - template#Частичная специализация шаблонов функций|обходным путем для отсутствующей частичной специализации шаблонов функций]], который мы используем для специализации значения `N`. В рекурсивном случае (`N > 0`) статическая функция-член `apply()` извлекает хвост текущего кортежа и уменьшает `N` для продолжения поиска запрошенного элемента далее в кортеже. Базовый случай (`N = 0`) возвращает голову текущего кортежа, завершая нашу реализацию.

## Создание кортежа

Помимо определенных к настоящему времени конструкторов:
```c++
Tuple()
{
}

Tuple(Head const& head, Tuple<Tail...> const& tail)
	: head(head), tail(tail)
{
}
```

мы должны иметь возможность создавать его как из набора независимых значений (по одному для каждого элемента), так и из другого кортежа. Копирующее конструирование из набора независимых значений берет первое из этих значений для инициализации элемента `head` (через его базовый класс), а затем передает оставшиеся значения базовому классу, представляющему хвост кортежа:
```c++
Tuple(Head const& head, Tail const& ... tail)
	: head(head), tail(tail...)
{
}
```

Этот код обеспечивает корректность нашего исходного примера `Tuple`:
```c++
Tuple<int, double, std::string> t (17, 3.14, "Hello, World!");
```

Однако это не самый обобщенный интерфейс: пользователи могут пожелать применить перемещающее конструирование для инициализации некоторых (но не всех) элементов или иметь элемент, созданный из значения иного типа. Таким образом, для инициализации кортежа мы должны использовать [[Вывод аргументов шаблона#Прямая передача|прямую передачу]]:
```c++
template<typename VHead, typename... VTail>
Tuple(VHead&& vhead, VTail&& ... vtail)
	: head(std::forward<VHead>(vhead)),
	  tail(std::forward<VTail>(vtail)...)
{
}
```

Затем мы реализуем поддержку построения кортежа из другого кортежа:
```c++
template<typename VHead, typename... VTail>
Tuple(Tuple<VHead, VTail...> const& other)
	: head(other.getHead()), tail(other.getTail())
{
}
```

Однако введения этого конструктора недостаточно, чтобы разрешить преобразования кортежей: для показанного выше кортежа `t` попытка создать еще один кортеж с совместимыми типами завершится ошибкой:
```c++
// Ошибка: нет преобразования Tuple<int, double, string> в long
Tuple<long int, long double, std::string> t2(t);
```

Проблема заключается в том, что шаблон конструктора, предназначенный для инициализации из набора независимых значений, оказывается лучшим соответствием, чем шаблон конструктора, который принимает кортеж. Для решения этой проблемы мы должны использовать [[enable_if#Отключение шаблонов с помощью enable_if<>|std::enable_if<>]] и [[Перегрузка свойств типов#Включение/отключение шаблонов функций|Включение/отключение шаблонов функций]]  для отключения обоих шаблонов функций-членов, когда длина хвоста не соответствует ожидаемой.
```c++
template<typename VHead, typename... VTail,
		typename = std::enable_if_t<sizeof...(VTail) == sizeof...(Tail)>>
Tuple(VHead && vhead, VTail && ... vtail)
	: head(std::forward<VHead>(vhead)),
	  tail(std::forward<VTail>(vtail)...) 
{ }

template<typename VHead, typename... VTail,
		typename = std::enable_if_t<sizeof...(VTail) == sizeof... (Tail)>>
Tuple(Tuple<VHead, VTail...> const& other)
	: head(other.getHead()), tail(other.getTail()) 
( }
```

Вы можете найти все объявления конструкторов в файле `tuples/tuple.hpp`.

Шаблон функции [[#std makeTuple|makeTuple()]] использует вывод для определения типов элементов возвращаемого кортежа `Tuple`, что облегчает создание кортежа из заданного набора элементов:
```c++
template<typename... Types>
auto makeTuple(Types&& ... elems)
{
	return Tuple<std::decay_t<Types>...>(std::forward<Types>(elems)...);
}
```

Здесь вновь используется прямая передача в сочетании со свойством [[decay|std::decay<>]] для преобразования строковых литералов и других обычных массивов в указатели и удаления [[const|const]] и ссылок. Например:
```c++
makeTuple(17, 3.14, "Hello, World!")
```

инициализирует
```c++
Tuple<int, double, char const*>
```

# Базовые операции кортежей

## Сравнение

Кортежи представляют собой структурные типы, содержащие другие значения. Для сравнения двух кортежей достаточно сравнить их элементы. Таким образом, можно написать определение оператора `operator==` для поэлементного сравнения двух определений:
```c++
// Базовый случай:
bool operator== (Tuple<> const&, Tuple<> const&)
{
	// Пустые кортежи всегда эквивалентны
	return true;
}

// Рекурсивный случай:
template<typename Head1, typename... Tail1,
		 typename Head2, typename... Tail2,
		 typename = std::enable_if_t<sizeof...(Tail1) == sizeof...
				(Tail2)>>
bool operator==(Tuple<Head1, Tail1...> const& lhs,
				Tuple<Head2, Tail2...> const& rhs)
{
	return  lhs.getHead() == rhs.getHead() &&
			lhs.getTail() == rhs.getTail();
}
```

Подобно многим алгоритмам для списков типов и кортежей поэлементное сравнение посещает элемент в голове списка, а затем рекурсивно проходит по хвосту, в конечном итоге доходя до базового случая. Операторы `!=`, `<`, `>`, `<=` и `>=` реализуются аналогично.

## Вывод

В этой главе мы будем создавать новые типы кортежей, поэтому полезно иметь возможность видеть эти кортежи в выполняемой программе. Оператор `operator<<` выводит любой кортеж, типы элементов которого могут быть выведены:
```c++
#include <iostream>

void printTuple(std::ostream& strm, Tuple<> const&,
				bool isFirst = true)
{
	strm << (isFirst ? ' (' : ' ) ' ) ;
}

template<typename Head, typename... Tail>
void printTuple(std::ostream& strm, Tuple<Head, Tail...> const& t,
				bool isFirst = true)
{
	strm << (isFirst ? "(" : ", ");
	strm << t.getHead();
	printTuple(strm, t.getTail(), false);
}

template<typename... Types>
std::ostream& operator<<(std::ostream& strm, Tuple<Types...> const& t)
{
	printTuple(strm, t);
	return strm;
}
```

Теперь легко как создавать кортежи, так и выводить их. Например, фрагмент
```c++
std::cout << makeTuple(1, 2.5, std::string("hello")) << '\n';
```

выводит
```c++
(1, 2.5, hello)
```

# Алгоритмы для работы с кортежами

Кортежи представляют собой контейнеры, которые обеспечивают возможность доступа и изменения каждого из их элементов (через `get`), а также создания новых кортежей (непосредственно или с помощью [[#std makeTuple|makeTuple()]] ) и разделения кортежей на голову и хвост (`getHead()` и `getTail()` ). Этих фундаментальных строительных блоков достаточно для создания набора алгоритмов для работы с кортежами, таких как добавление элементов в кортеж или их удаление из него, изменение порядка элементов в кортеже или выборка некоторого подмножества элементов из кортежа.

Алгоритмы для работы с кортежами особенно интересны, потому что они требуются и во время компиляции, и во время выполнения. Подобно [[Списки типов - template#Списки типов|работе со списками типов]], “Списки типов”, применение алгоритма к кортежу может привести к кортежу совершенно иного типа, который требуется для выполнения вычислений времени компиляции. Например, обращение кортежа `Tuple<int,double,string>` дает кортеж `Tuple<string,double, int>`. Однако подобно алгоритмам для гомогенного контейнера (например, [[reverse|std::reverse()]] для [[vector|std::vector]]) алгоритмы для кортежей фактически требуют выполнения кода во время выполнения программы, так что нам нужно не забывать об эффективности генерируемого кода.

## Кортежи как списки типов

Если игнорировать конкретные компоненты времени выполнения нашего шаблона `Tuple`, то мы увидим, что он имеет точно такую же структуру, что и шаблон [[typelist|Typelist]], [[Списки типов - template#Списки типов|разработанный в  “Списки типов”]]: он принимает любое количество параметров типа шаблона. Фактически с использованием небольшой частичной специализации можно превратить кортеж в полнофункциональный список типов:
```c++
// Определение, пуст ли контейнер:
template<>
struct IsEmpty<Tuple<>>
{
	static constexpr bool value = true;
};

// Извлечение первого элемента:
template<typename Head, typename... Tail>
class FrontT<Tuple<Head, Tail...>>
{
	public:
		using Type = Head;
};

// Удаление первого элемента:
template<typename Head, typename... Tail>
class PopFrontT<Tuple<Head, Tail...>>
{
	public:
		using Type = Tuple<Tail...>
};

// Добавление элемента в начало:
template<typename... Types, typename Element>
class PushFrontT<Tuple<Types...>, Element>
{
	public:
		using Type = Tuple<Element, Types...>;
};

// Добавление элемента в конец:
template<typename... Types, typename Element>
class PushBackT<Tuple<Types...>, Element>
{
	public:
		using Type = Tuple<Types..., Element>;
};
```

Теперь все алгоритмы, [[Списки типов - template#Списки типов|разработанные в главе “Списки типов”]], для списков типов, одинаково хорошо работают как с `Tuple`, так и с [[typelist|Typelist]], так что мы легко можем работать с типом кортежей. Например:
```c++
Tuple<int, double, std::string> t1(17, 3.14, "Hello, World!");
using T2 = PopFront<PushBack<decltype(t1), bool>>;
T2 t2(get<1>(t1), get<2>(t1), true);
std::cout << t2;
```

Этот фрагмент кода выводит:
```c++
(3.14, Hello, World!, 1)
```

Как мы вскоре увидим, алгоритмы для списков типов, применяемые к типам кортежей, часто используются для того, чтобы определить тип результата алгоритма для работы с кортежами.

## Добавление элементов в кортеж и удаление их оттуда

Возможность добавления элемента в начало или конец кортежа имеет важное значение для построения более сложных алгоритмов. Как и в случае со списками типов, вставка элемента в начало кортежа гораздо легче, чем вставка в его конец, так что мы начнем с `pushFront`:
```c++
template<typename... Types, typename V>
PushFront<Tuple<Types...>, V>
pushFront<Tuple<Types...> const& tuple, V const& value)
{
	return PushFront<Tuple<Types...>, V>(value, tuple);
}
```

Добавление нового элемента (с именем `value`) в начало существующего кортежа требует от нас сформировать новый кортеж со значением `value` в качестве его головы и существующего кортежа в качестве хвоста. Получающийся в результате кортеж имеет тип `Tuple<v, Types...>`. Однако мы решили использовать алгоритм `PushFront` для списков типов, чтобы продемонстрировать тесную связь между аспектами времени компиляции и времени выполнения алгоритмов для кортежей: `PushFront` времени компиляции вычисляет тип, который нам нужно построить, чтобы получить соответствующее значение времени выполнения.

Добавление нового элемента в конец существующего кортежа является более сложным, потому что оно требует рекурсивного обхода кортежа с построением по мере обхода модифицированного кортежа. Обратите внимание на то, как структура реализации `pushBack()` следует [[Списки типов - template#Добавление в список типов|рекурсивной формулировке `PushBack()` для списка типов]]:
```c++
// Вазовый случай
template<typename V>
Tuple<V> pushBack (Tuple<> const&, V const& value)
{
	return Tuple<V>(value);
}

// Рекурсивный случай
template<typename Head, typename... Tail, typename V>
Tuple<Head, Tail..., V>
pushBack(Tuple<Head, Tail...> const& tuple, V const& value)
{
	return Tuple<Head, Tail..., V>(tuple.getHead(),
									pushBack(tuple.getTail(), value));
}
```

Базовый случай, как и ожидалось, добавляет значение к кортежу нулевой длины, производя кортеж, содержащий только одно это значение. В рекурсивном случае мы формируем новый кортеж из текущего элемента в начале списка (`tuple.getHead()`) и результата добавления нового элемента к хвосту списка (рекурсивный вызов `pushBack`). Хотя мы решили выразить сконструированный тип как `Tuple<Head, Tail. . ., v>`, следует отметить, что это эквивалентно использованию `PushBack<Tuple<Head, Tail...>, V>` времени компиляции.

Реализовать `popFront()` очень легко:
```c++
template<typename... Types>
PopFront<Tuple<Types...>> popFront(Tuple<Types...> const& tuple)
{
	return tuple.getTail();
}
```

Теперь [[tuple (Кортежи)#Кортежи как списки типов|пример]] можно переписать следующим образом:
```c++
Tuple<int, double, std::string> t1(17, 3.14, "Hello, World!");
auto t2 = popFront(pushBack(t1, true));
std::cout << std::boolalpha << t2 << '\n';
```

Этот код выводит
```c++
(3.14, Hello, World!, true)
```

## Обращение порядка элементов кортежа





















