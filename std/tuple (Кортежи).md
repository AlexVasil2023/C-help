
[[#std tuple|std::tuple]]
[[#std tuple_size|std::tuple_size]]
[[#std tuple_element|std::tuple_element]]
[[#std make_pair|std::make_pair]]
[[#Кортежи C++11|Кортежи C++11]]
[[#Кортежи C++17|Кортежи C++17]]
[[#Кортежи|Кортежи]] 25(template)


# std::tuple
#std_tuple




# std::tuple_size
#std_tuple_size



# std::tuple_element
#std_tuple_element


# std::make_pair

#std_make_pair



# Кортежи C++11
Кортежи представляют собой наборы неоднородных значений фиксированного размера.
```c++
// `playerProfile` имеет тип `std::tuple<int, const char*, const char*>`. 

auto playerProfile = std::make_tuple(51, "Frans Nielsen", "NYI"); 
std::get<0>(playerProfile); // 51 
std::get<1>(playerProfile); // "Frans Nielsen" 
std::get<2>(playerProfile); // "NYI"
```

# Кортежи C++17 #

Эта структура появилась в C++11. Они аналогичны массивам и представляют собой коллекции с фиксированной длиной. Кортежи можно использовать, чтобы вернуть несколько значений функции, например так:
```C++
#include <tuple> 

auto get() { 
	return std::make_tuple("fred", 42); 
}
```

Этот пример вернет кортеж с двумя членами. В C++14 версии появилась возможность использовать **auto** с возвращаемыми типами функций, чтобы сделать вызов функции более аккуратным. Для получения значений кортежа, при этом, будет требоваться **std::get**: 
```c++
auto t = get(); 
std::cout << std::get<0>(t) << std::endl;
```

Через **std::tie** можно привязать элементы кортежа к переменным, которые уже должны быть объявлены:
```c++
std::string name; 
int age; 

std::tie(name, age) = get();
```

Благодаря этому методу можно привязывать элементы кортежа к переменным без std::get и необходимости объявлять переменные заранее:
```c++
auto [name, age] = get(); 
std::cout << name << " is " << age << std::endl;
```

Этот метод также позволяет получить ссылки к элементам кортежа, что невозможно с [[tie|std::tie]]:
```c++
auto t2 = std::make_tuple(10, 20); 

auto& [first, second] = t2; 
first += 1; 

std::cout << "value is now " << std::get<0>(t2) << std::endl;
```

# Кортежи

В этой книге для иллюстрации возможностей шаблонов часто используются однородные (гомогенные) контейнеры и типы, подобные массивам. Такие однородные структуры расширяют концепцию массива в языках программирования С и C++ и часто используются во многих приложениях. В этих языках также есть гетерогенные образования, способные хранить данные — классы или структуры. В данной главе рассматриваются `кортежи (tuple)`, агрегирующие данные подобно классам или структурам. Например, кортеж, содержащий `int`, `double` и [[string|std::string]], подобен структуре с членами `int`, `double` и [[string|std::string]], с тем отличием, что к элементам кортежа можно обращаться по их индексам (`0`, `1`, `2`), а не с помощью имен. Этот позиционный интерфейс и возможность легко создавать кортежи из списков типов делают кортежи более подходящими для использования в шаблонном метапрограммировании, чем структуры.

Существует альтернативный взгляд на кортежи как на проявление спи­
сков типов в выполнимой программе. Например, в то время как список типов
Typelist<int, double, std: : string> описывает последовательность типов,
содержащую int, double и std: : string, с которыми можно работать во вре­
мя компиляции, Tuplecint,double,std::string> описывает хранилище
для int, double и std: : string, с которым можно работать во время выпол­
нения. Например, в следующей программе создается экземпляр такого кортежа:































