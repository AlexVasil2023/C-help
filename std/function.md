
1. [[#std function|std::function]]
2. [[#function|function]] 16.3.3(STL)

# std::function

`std::function` - шаблон стандартной библиотеки С++11 , который обобщает идею указателя на функцию. В то время как указатели на функции могут указывать только на функции, объект `std::function` может ссылаться на любой вызываемый объект, т.е. на все, что может быть вызвано как функция. Так же как при создании указателя на функцию вы должны указать тип функции, на которую указываете (т.е. сигнатуру функции, на которую хотите указать), вы должны указать тип функции, на которую будет ссылаться создаваемый объект `std::function`. Это делается с помощью параметра шаблона `std::function`. Например, для объявления объекта `std::function` с именем `func`, который может ссылаться на любой вызываемый объект, действующий так, как если бы ero сигнатура была
```c++
bool(const std::unique_ptr<Widget> &,       // Сигнатура C++11 для
     const std::unique_ptr<Widget>& )       // функции сравнения
                                            // std::unique_ptr<Widget>
```
следует написать следующее:
```c++
std::function<bool(const std::unique_ptr<Widqet>& ,
                   const std::unique_ptr<Widqet>&)> func;
```

# function

В стандартной библиотеке `function` - это тип, содержащий любой объект, который вы можете вызвать с помощью оператора вызова `()`. То есть объект типа `function` является [[Template_STL#Функциональные объекты|функциональным объектом]]. Например:
```c++
int f1(double);
function<int(double)> fct1 {f1};        // initialize to f1

int f2(string);
function fct2 {f2};         // fct2's type is function<int(string)>

// fct3's type is function<void(Shape*)>
function fct3 = [](Shape* p) { p->draw(); }; 
```

Для `fct2` я позволяю вывести тип `function` из инициализатора: `int(string)`.

Очевидно, что `function` полезны для обратных вызовов ([[callback|callback]]), для передачи операций в качестве аргументов, для передачи функциональных объектов и т.д. Однако это может привести к некоторым накладным расходам во время выполнения по сравнению с прямыми вызовами. В частности, для объекта `function`, размер которого не вычисляется во время компиляции, может произойти выделение динамической памяти с серьезными негативными последствиями для приложений, критически важных для производительности. Готовится решение для `C++23`: `move_only_function`.

Другая проблема заключается в том, что `function`, будучи объектом, не участвует в перегрузке. Если вам нужно перегрузить функциональные объекты (включая лямбда-выражения), рассмотрите [[variant#variant|вариант overloaded]].

