
[[#std variant C++17|std::variant C++17]]
[[#Контролируемые объединения|Контролируемые объединения]] 26 (Template)
1. [[#Хранилище|Хранилище]] 26.1
2. [[#Дизайн|Дизайн]] 26.2




# std::variant C++17

Концепция “вариант” может показаться знакомой тем, кто имел дело с Visual Basic. Вариант – это типобезопасное объединение [[union|union]], которое в заданный момент времени содержит значение одного из альтернативных типов (причем, здесь не может быть ссылок, массивов или [[void|void]]).  
```c++
std::variant<int, double> v{ 12 };
std::get<int>(v); // == 12
std::get<0>(v); // == 12

v = 12.0;

std::get<double>(v); // == 12.0
std::get<1>(v); // == 12.0
```

Простой пример: допустим, есть некоторые данные, где возраст человека может быть представлен в виде целого числа или в виде строки с датой рождения. Можно представить такую информацию при помощи варианта, содержащего беззнаковое целое число или строку. Присваивая целое число переменной, мы задаем значение, а затем можем извлечь его при помощи [[get|std::get]], вот так:
```c++
std::variant<uint32_t, std::string> age;
age = 51; 

auto a = std::get<uint32_t>(age);
```

Если попытаться использовать член, который не задан таким образом, то программа выбросит исключение:
```c++
try { 	
	std::cout << std::get<std::string>(age) << std::endl;
}catch ( std::bad_variant_access &ex ) { 	
	std::cout << "Doesn't contain a string" << std::endl;
}
```

Зачем использовать `std::variant`, а не обычное объединение? В основном потому, что объединения присутствуют в языке прежде всего ради совместимости с C и не работают с объектами, не относящимися к POD-типам. Отсюда, в частности, следует, что в объединение не так-то просто поместить члены с копиями пользовательских конструкторов копирования и деструкторов. С `std::variant` таких ограничений нет.

# Контролируемые объединения

Кортежи, разработанные в предыдущей главе, объединяют значения некоторого списка типов в одно значение, обеспечивая примерно такую же функциональность, как и простая структура. С учетом этой аналогии естественно задаться вопросом, чему же соответствует объединение ([[union|union]]), которое содержит единственное значение, но это значение имеет тип, выбранный из некоторого множества возможных типов. Например, поле базы данных может содержать целое число, значение с плавающей точкой, строку или бинарный объект, но в любой момент времени оно может содержать значение только одного из этих типов.

В этой главе мы разработаем шаблон класса `Variant`, который динамически хранит значение одного из заданного набора возможных типов, аналогичный шаблону стандартной библиотеки C++17 `std::variant<>`. `Variant` — это контролируемое объединение (`discriminated union`), т.е. оно знает, какое из его возможных типов значений в настоящее время активно, и обеспечивает лучшую безопасность типов, чем эквивалентное объединение C++. Сам `Variant` является вариативным шаблоном, принимающим список типов, который может иметь активное значение. Например, переменная
```c++
Variant<int, double, string> field;
```

может хранить `int`, `double` или [[string|string]], но в каждый момент времени — только одно из этих значений. Поведение `Variant` иллюстрируется следующей программой:
```c++
#include "variant.hpp"
#include <iostream>
#include <string>

int main()
{
	Variant<int, double, std::string> field(17);
	
	if(field.is<int>())
	{
		std::cout << "Field хранит целое значение "
				  << field.get<int>() << '\n';
	}

	field = 42;             // Присваивание значения того же типа
	field = "hello";        // Присваивание значения иного типа

	std::cout << "Теперь field хранит строку '"
			  << field.get<std::string>() << ”'\n";
}
```

Вывод этого кода имеет следующий вид:
```c++
Field хранит целое значение 17
Теперь field хранит строку 'hello'
```

Переменной типа `Variant` может быть присвоено значение любого из его типов. Мы можем проверить, содержит ли переменная в настоящее время значение типа `Т` с помощью функции-члена `is<T>()`, а затем получить сохраненное значение с помощью функции-члена `get<T>()`.

# Хранилище

Первый главный аспект дизайна нашего типа `Variant` представляет собой управление хранением активного значения, т.е. значения, которое в настоящий момент хранится в переменной. Различные типы, вероятно, имеют различные размеры и выравнивание. Кроме того, типу `Variant` необходимо хранить дискриминатор (`discriminator`), указывающий, какой из возможных типов является типом активного значения. Один простой (хотя и неэффективный) механизм хранения непосредственно использует [[tuple (Кортежи)|кортеж]]:
```c++
template<typename... Types>
class Variant
{
	public:
		Tuple<Types...> storage;
		unsigned char discriminator;
}
```

Здесь дискриминатор действует как динамический индекс в кортеже. Допустимое значение имеет только тот элемент кортежа, статический индекс которого равен текущему значению дискриминатора, так что когда `discriminator` равен `0`, `get<0>` (`storage`) обеспечивает доступ к активному значению; когда `discriminator` равен `1`, доступ к активному значению обеспечивает `get<1>` (`storage`), и т. д.

Мы могли бы построить базовый вариант операций `is<T>()` и `get<T>()` поверх кортежа. Однако это довольно неэффективное решение, поскольку сам `Variant` при этом требует количество памяти, равное сумме размеров типов всех возможных значений, даже если одновременно будет активен только один из них.

Лучший подход использует перекрытие памяти для всех возможных типов. Мы могли бы осуществить его путем [[tuple (Кортежи)#Хранилище|рекурсивного развертывания контролируемого объединения на голову и хвост]], но с помощью объединения, а не класса:
```c++
template<typename... Types>
union VariantStorage;

template<typename Head, typename... Tail>
union VariantStorage<Head, Tail...>
{
	Head head;
	VariantStorage<Tail...> tail;
};

template<>
union VariantStorage<>
{
};
```

Здесь объединение гарантированно имеет достаточный размер и выравнивание, чтобы позволить хранение любого из типов в `Types` в любой момент времени. К сожалению, с таким объединением довольно трудно работать, потому что большинство методов, которые мы будем использовать для реализации `Variant`, будут применять наследование, которое для объединения является недопустимым.

Вместо этого мы предпочитаем низкоуровневое представление хранилища: массив символов, размер которого достаточен для хранения любых типов, и с выравниванием, подходящим для любого из типов, используемый нами как буфер для хранения активного значения. Шаблон класса `VariantStorage` реализует этот буфер вместе с дискриминатором:
```c++
#include <new>        // Для std::launder()

template<typename... Types>
class VariantStorage
{
		using LargestT = LargestType<Typelist<Types...>>;
		alignas(Types...) unsigned char buffer[sizeof(LargestT)];
		unsigned char discriminator = 0;
	
	public:
		unsigned char getDiscriminator() const
		{
			return discriminator;
		}
		
		void setDiscriminator(unsigned char d)
		{
			discriminator = d;
		}
	
		void* getRawBuffer()
		{
			return buffer;
		}
		
		const void* getRawBuffer() const
		{
			return buffer;
		}
		
		template<typename T>
		T* getBufferAs()
		{
			return std::launder(reinterpret_cast<T*>(buffer));
		}
		
		template<typename T>
		T const* getBufferAs() const
		{
			return std::launder(reinterpret_cast<T const*>(buffer));
		}
};
```

Здесь мы используем [[Списки типов - template#Поиск наилучшего соответствия|разработанную метапрограмму LargestType для вычисления размера буфера]], гарантируя достаточный его размер для любого из типов значений. Аналогично раскрытие пакета `alignas` гарантирует, что буфер будет иметь выравнивание, подходящее для любого из типов. Вычисленный нами размер буфера, по сути, представляет собой машинное представление показанного выше объединения. Мы можем получить доступ к указателю на буфер с помощью `getBuffer()` и манипулировать с памятью путем явного приведения типов, размещающего `new` (для создания новых значений) и явного вызова деструкторов (для уничтожения созданных значений). Если вы незнакомы с [[launder|std::launder()]], используемым в `getBufferAs ()`, то пока что достаточно знать, что он возвращает неизмененным свой аргумент. Мы поясним его роль, когда будем говорить об операторах присваивания для нашего шаблона Variant.

# Дизайн

Теперь, когда у нас есть решение проблемы хранения для контролируемых объединений, мы проектируем сам тип `Variant`. Как и с типом [[tuple (Кортежи)#Кортежи|Tuple]], мы используем наследование для предоставления поведения для каждого типа в списке `Types`. Однако в отличие от `Types` эти базовые классы не имеют хранилища. Вместо этого каждой из базовых классов использует [[Шаблоны и наследование#Странно рекурсивный шаблон проектирования|Странно рекурсивный шаблон проектирования]] (Curiously Recurring Template Pattern — CRTP), для доступа к общему хранилищу через наиболее производный тип.

Шаблон класса `VariantChoice`, определенный ниже, предоставляет базовые операции, необходимые для работы с буфером, когда активным значением объединения является (или будет) значение типа `Т`:
```c++
#include "findindexof.hpp"

template<typename T, typename... Types>
class VariantChoice
{
		using Derived = Variant<Types...>;
		
		Derived& getDerived()
		{
			return *static_cast<Derived*>(this);
		}
		
		Derived const& getDerived() const
		{
			return *static_cast<Derived const*>(this);
		}
	
	protected:
		// Вычисление дискриминатора для данного типа
		constexpr static unsigned Discriminator =
			FindIndexOfT<Typelist<Types...>, T>::value + 1;
	
	public:
		VariantChoice() { }
		VariantChoice(T const& value); // Cm. variantchoiceinit.hpp
		VariantChoice(T&& value);      // Cm. variantchoiceinit.hpp
		bool destroy();                // Cm. variantchoicedestroy.hpp
		Deriveds operator=(T const& value) ;// Cm. variantchoiceassign.hpp
		Deriveds operator=(T&& value); // Cm. variantchoiceassign.hpp
};
```

Пакет параметров шаблона `Types` будет содержать все типы в `Variant`. Это позволяет нам сформировать тип `Derived` (для CRTP) и таким образом обеспечить операцию нисходящего приведения `getDerived()`. Второе интересное применение `Types` заключается в том, чтобы найти размещение конкретного типа `Т` в списке `Types`, чего мы добиваемся с помощью метафункции `FindlndexOfT`:
```c++
template<typename List, typename T, unsigned N = 0,
			bool Empty = IsEmpty<List>::value>
struct FindlndexOfT;

// Рекурсивный случай:
template<typename List, typename T, unsigned N>
struct FindlndexOfT<List, T, N, false>
	: public IfThenElse < std::is_same<Front<List>, T>::value,
	std::integral_constant<unsigned, N>,
	FindlndexOfT < PopFront<List>, T, N + 1 >>
{
};

// Базовый случай:
template<typename List, typename Т, unsigned N>
struct FindlndexOfT<List, T, N, true>
{
};
```

Это значение индекса используется для вычисления значения дискриминатора, соответствующего `Т`; мы вернемся к конкретным значениям дискриминатора позже.

Скелет `Variant`, приведенный ниже, иллюстрирует взаимоотношения `Variant`, `VariantStorage` и `VariantChoice`:
```c++
template<typename... Types>
class Variant
	: private VariantStorage<Types... >,
	private VariantChoice<Types, Types...>...
{
	template<typename T, typename... OtherTypes>
	friend class VariantChoice;  // Включение CRTP
	...	
};
```

Как упоминалось ранее, каждый `Variant` имеет единственный, общий базовый класс `VariantStorage`. Кроме того, он имеет некоторое количество базовых классов `VariantChoice`, которые получаются из следующих [[Вглубь шаблонов#Множественные и вложенные раскрытия пакетов|раскрытий вложенных пакетов]]:
```c++
VariantChoice<Types, Types...>...
```

В этом случае у нас есть два раскрытия: внешнее раскрытие производит базовый класс `VariantChoice` для каждого типа `Т` в `Types` путем раскрытия первой ссылки на `Types`. Внутреннее раскрытие второго вхождения `Types` дополнительно проходит все типы в `Types` для каждого базового класса `VariantChoice`. Для
```c++
Variant<int, double, std::string>
```

этот дает следующее множество базовых классов `VariantChoice`:
```c++
VariantChoice<int, int, double, std::string>,
VariantChoice<double, int, double, std::string>,
VariantChoice<std::string, int, double, std::string>
```






