
[[#std allocator|Аллокаторы]] (12.7 STL)

# std::allocator

По умолчанию контейнеры стандартной библиотеки выделяют пространство с помощью [[new|new]]. Операторы [[new|new]] и [[delete|delete]] предоставляют динамическую память (также называемую кучей), в которой могут храниться объекты произвольного размера и контролируемого пользователем срока жизни. Это влечет за собой накладные расходы времени и памяти, которые могут быть устранены во многих особых случаях. Таким образом, контейнеры стандартной библиотеки предоставляют возможность устанавливать аллокаторы с определенной семантикой там, где это необходимо. Специальные аллокаторы используются для решения широкого спектра проблем, связанных с производительностью (например, пул аллокаторов), безопасностью (аллокаторы, которые очищают память при удалении), аллокацией по потокам и неоднородными архитектурами памяти (аллокация в определенных областях памяти с соответствующими типами указателей). Здесь не место обсуждать эти важные, но очень специализированные и часто
продвинутые методы. Однако я приведу один пример, подкреплённый реальной проблемой, решением которой был пул аллокаторов.

Важная, долго работающая система использовала очередь событий (см. #§18_4), используя [[vector|vector]] в качестве объекта событий, которые передавались как [[shared_ptr|shared_ptr]]. Таким образом, последний пользователь события неявно удалил бы его:
```c++
struct Event 
{
	vector<int> data = vector<int>(512);
};

list<shared_ptr<Event>> q;
void producer()
{
	for (int n = 0; n!=LOTS; ++n) {
		lock_guard lk {m}; // m is a mutex
		q.push_back(make_shared<Event>());
		cv.notify_one(); // cv is a condition_variable
	}
}
```

С логической точки зрения это сработало прекрасно. Это логически просто, поэтому код надежен и удобен в обслуживании. К сожалению, это привело к массовой фрагментации. После того, как 100 000 событий были переданы 16 производителям и 4 потребителям, было израсходовано более 6 ГБ памяти.

Традиционным решением проблем фрагментации является переписывание кода для использования пула аллокаторов. Пул аллокаторов - это аллокатор, который управляет объектами одного фиксированного размера и выделяет пространство для многих объектов одновременно, а не использует отдельные аллокации. К счастью, C++ предлагает прямую поддержку для этого. Пул аллокаторов определен в подпространстве имен `pmr` (“полиморфный ресурс памяти”) пространства имён `std`:
```c++
pmr::synchronized_pool_resource pool; // make a pool

struct Event 
{
	// let Events use the pool
	vector<int> data = vector<int>{512,&pool}; 
};

list<shared_ptr<Event>> q {&pool}; // let q use the pool
void producer()
{
	for (int n = 0; n!=LOTS; ++n) {
		scoped_lock lk {m}; // m is a mutex
		q.push_back(
			allocate_shared<
					Event,
					pmr::polymorphic_allocator<Event>
			>{&pool});
		cv.notify_one();
	}
}
```

Теперь, после того, как 100 000 событий были переданы 16 производителям и 4 потребителям, было израсходовано менее 3 МБ памяти. Это оптимизация примерно в 2000 раз! Естественно, объем фактически используемой памяти (в отличие от памяти, потраченной впустую из-за фрагментации) остается неизменным. После устранения фрагментации использование памяти со временем стало стабильным, так что система могла работать в течение нескольких месяцев.

Методы, подобные этому, применялись с хорошими результатами с первых дней существования C++, но, как правило, они требовали переписывания кода для использования специализированных контейнеров. Теперь стандартные контейнеры опционально принимают аргументы аллокатора. По умолчанию контейнеры используют [[new|new]] и [[delete|delete]].

Другие ресурсы полиморфной памяти включают
>
> ***==unsynchronized_polymorphic_resource==***; похож на `polymorphic_resource` но может использоваться только одним потоком.
>
> ***==monotonic_polymorphic_resource==***; быстрый аллокатор, который освобождает свою память только при ее уничтожении и может использоваться только одним потоком.

Полиморфный ресурс должен быть получен из memory_resource и определять элементы `allocate()`, `deallocate()` и `is_equal()`. Идея заключается в том, чтобы пользователи создавали свои собственные ресурсы для настройки кода.








