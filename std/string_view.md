
[[#Строковые представления]] 10.3  (STL)
[[#std string_view C++17]]

# Строковые представления

Наиболее распространенное использование последовательности символов - это передача ее какой-либо функции для чтения. Это может быть достигнуто путем передачи строки по значению, по ссылке или виде строки в стиле C. Во многих системах существуют дополнительные альтернативы, такие как строковые типы, не предлагаемые стандартом. Во всех этих случаях возникают дополнительные сложности при передаче подстроки. Чтобы решить эту проблему, стандартная библиотека предлагает `string_view`; `string_view` - это, по сути, пара (указатель, длина), обозначающая последовательность символов:
![[String_View_1.png]]

`string_view` предоставляет доступ к непрерывной последовательности символов. Символы могут быть храниться разными способами, в том числе в виде [[string#std string|string]] и в виде строки в стиле C. `string_view` подобен указателю или ссылке в том смысле, что ему не принадлежат символы, на которые он указывает. В этом он напоминает пару итераторов STL.

Рассмотрим простую функцию, объединяющую две строки:
```c++
string cat(string_view sv1, string_view sv2)
{
	string res {sv1}; // initialize from sv1
	return res += sv2; // append from sv2 and return
}
```

Мы можем вызвать функцию `cat()`:
```c++
string king = "Harold";
auto s1 = cat(king, "William");         // HaroldWilliam: string and const char*
auto s2 = cat(king, king);              // HaroldHarold: string and string
auto s3 = cat("Edward", "Stephen"sv);   // EdwardStephen: const char * 
										// and string_view
auto s4 = cat("Canute"sv, king);        // CanuteHarold
auto s5 = cat({&king[0],2}, "Henry"sv); // HaHenry
auto s6 = cat({&king[0],2}, {&king[2],4}); // Harold
```

Функция `cat()` имеет три преимущества перед `compose()`, который принимает `const string&` аргументы:
>
> Его можно использовать для последовательностей символов, управляемых различными способами.
> 
> Мы можем легко передать подстроку.
> 
>  Нам не нужно создавать string для передачи строкового аргумента в стиле C

Обратите внимание на использование суффикса `sv` (“string view”). Чтобы использовать его, нам нужно сделать его видимым:
```c++
using namespace std::literals::string_view_literals; // §6.6
```

Зачем беспокоиться о суффиксе? Причина в том, что когда мы передаем `"Edward"`, нам нужно создать `string_view` из `const char*`, а это требует подсчета символов. Для `"Stephen"sv` длина вычисляется во время компиляции.

`string_view` определяет диапазон, поэтому мы можем перемещаться по его символам. Например:
```c++
void print_lower(string_view sv1)
{
	for (char ch : sv1)
		cout << tolower(ch);
}
```

Одним из существенных ограничений `string_view` является то, что его символы доступны только для чтения. Например, вы не можете использовать `string_view` для передачи символов функции, которая изменяет свой аргумент на нижний регистр. Для этого вы могли бы рассмотреть возможность использования [[span|span]].

Думайте о `string_view` как о своего рода указателе; чтобы его использовать, он должен указывать на что-то:
```c++
string_view bad()
{
	string s = "Once upon a time";
	return {&s[5],4}; // bad: returning a pointer to a local
}
```

Здесь возвращаемый [[string|string]] будет уничтожен до того, как мы сможем его использовать.

Поведение при доступе к `string_view` за пределами диапазона не определено. Если вам нужна гарантированная проверка диапазона, используйте `at()`, которая бросит исключение `out_of_range` при попытке доступа за пределы диапазона, или [[string_span#gsl string_span|gsl::string_span]].

# std::string_view C++17#
#std_string_view

Ссылается на строку, но не владеет ей. Полезно для предоставления абстракции поверх строк (например, для синтаксического анализа).
```c++
// обычные строки
std::string_view cppstr{ "foo" };

// wide-строки
std::wstring_view wcstr_v{ L"baz" };

// массивы символов
char array[3] = {'b', 'a', 'r'};
std::string_view array_v(array, std::size(array));

std::string str{ "   trim me" };
std::string_view v{ str };
v.remove_prefix(std::min(v.find_first_not_of(" "), v.size()));
str; //  == "   trim me"
v; // == "trim me"
```

