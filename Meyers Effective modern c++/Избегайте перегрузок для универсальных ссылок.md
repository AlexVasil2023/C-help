# Избегайте перегрузок для универсальных ссылок

Предположим, что вам надо написать функцию, которая принимает в качестве параметра имя, записывает в журнал текущие дату и время, а затем добавляет имя в глобальную структуру данных. Вы могли бы начать с функции, которая имеет примерно следующий вид:

```c++
std::multiset<std::striпg>пames;           // Глобальная структура данных
void logAndAdd(const std::string& name)
{
	auto поw =                             // Получение текущего времени
		std::chroпo::system_clock::поw();

	log(пow, "logAndAdd");                 // Создание журнальной записи
	пames.emplace(пame);                   // Добавление паmе в глобальную
										   // структуру данных
```

Этот код не является неразумным, но он не такой эффективный, каким мог бы быть. Рассмотрим три потенциальных вызова:

```c++
std::string petName("Darla");
logAndAdd (petName);                      // lvalue типа std::striпg
logAndAdd (std::string("Persephone"));    // rvalue типа std::striпg
logAndAdd ("Patty Doq");                  // Строковый литерал
```

В первом вызове параметр `nаmе` функции `logAпdAdd` связывается с переменной `petName`. Внутри `logAпdAdd` параметр `nаmе` в конечном итоге передается в вызов `names.emplace`. Поскольку `nаmе` является [[lvalue|lvalue]], он копируется в `names`. Избежать этого копирования невозможно, так как [[lvalue|lvalue]] (`petName`) передается в функцию `logAndAdd`.

Во втором вызове параметр `name` связывается с `rvalue` (временный объект [[string|std::string]], явно созданный из строки `"Persephoпe"`) . Параметр `nаmе` сам по себе является [[lvalue|lvalue]], так что он копируется в `names`, но мы отдаем себе отчет, что, в принципе, это значение может быть перемещено в `names`. В этом вызове мы платим за копирование, но мы должны быть способны сделать то же с помощью перемещения.

В третьем вызове параметр `nаmе` опять связывается с [[rvalue|rvalue]], но в этот раз со временным объектом `std::striпg`, который неявно создается из `"Patty Dog"` . Как и во втором вызове, `nаmе` копируется в `names`, но в этот раз аргумент, изначально переданный в `logAпdAdd`, был строковым литералом. Если бы строковый литерал непосредственно передавался в [[emplace|emplace]], в создании временного объекта [[string|std::string]] не было бы необходимости вообще. Вместо этого функция [[emplace|emplace]] использовала бы строковый литерал для создания объекта [[string|std::string]] непосредственно в [[multiset|std::multiset]]. Таким образом, в этом третьем вызове мы платим за копирование [[string|std::string]], при том что нет причин платить даже за перемещение, не говоря уже о копировании.

Неэффективность второго и третьего вызовов `logAndAdd` можно устранить, переписав эту функцию так, чтобы она принимала [[Отличие универсальных ссылок от rvalue-ссылок|универсальную ссылку]] и согласно [[Использование move и forward|разделу]], передавала ее с помощью [[forward|std::forward]] функции [[emplace|emplace]] . Результат говорит сам за себя:

```c++
tamplate<typename Т>
void logAndAdd(T&& name)
{
	auto now = std::chrono::system_clock::now();
	log(now, "logAndAdd");
	names.emplace(std::forward<Т>(name));
}

std::string petName("Darla");                   // Как и ранее

logAndAdd (petNaшe);                            // Как и ранее, копирова­
                                                // ние lvalue в multiset
                                                
logAndAdd(std::string("Persephone"));           // Перемещение rvalue
                                                // вместо копирования
                                                
logAndAdd("Patty Dog");                        // Соэдание std::string
                                               // в multiset вместо
                                               // копирования временного
                                               // std::string
```

Получена оптимальная эффективность!

Если бы это был конец истории, мы могли бы остановиться и гордо удалиться, но я не сказал вам, что клиенты не всегда имеют непосредственный доступ к именам, требующимся `logAndAdd`. Некоторые клиенты имеют только индекс, который `logAndAdd` использует для поиска соответствующего имени в таблице. 

Для поддержки таких клиентов выполняется перегрузка функции `logAndAdd`:

```c++
std::string nameFromidx(int idx);        // Возвращает имя,
										 // соответствующее idx
void logAndAdd(int idx)                  // Новая перегрузка
{
	auto now = std::chrono::system_clock::now();
	log(now, "logAndAdd");
	names.emplace(nameFromidx(idx));
```

Разрешение перегрузки работает, как и следовало ожидать:

```c++
std::string petName("Darla");                // Как и ранее

logAndAdd(petName);                          // Как и ранее, эти вызовы
logAndAdd(std::string("Persephone"));        // приводят к испольэова­
logAndAdd("PattyDog");                       // нию перегрузки для Т&&

logAndAdd(22);                               // Вызов int -перегруэки
```

На самом деле разрешение работает, как ожидается, только если вы не ожидаете слишком многого. Предположим, клиент имеет переменную типа [[short|short]], хранящую индекс, и передает ее функции `logAndAdd`:

```c++
short nameidx;
...                          // Дает значение переменной name idx
logAndAdd(nameidx);          // Ошибка !
```

Комментарий в последней строке, может быть, не слишком понятен, так что позвольте мне пояснить, что же здесь произошло.

Имеется две перегрузки `logAndAdd`. Одна из них, принимающая универсальную ссылку, может вывести тип `Т` как `short`, тем самым приводя к точному соответствию. Перегрузка с параметром `int` может соответствовать аргументу `short` только с повышением. Согласно обычным правилам разрешения перегрузки точное соответствие побеждает соответствие с повышением, так что вызывается перегрузка для универсальной ссылки.

В этой перегрузке параметр `name` связывается с переданным значением типа `short`. Таким образом, `name` передается с помощью [[forward|std::forward]] функции-члену [[emplace|emplace]] объекта `names` ( std::multiset<std::string>) , которая, в свою очередь, послушно передает его конструктору [[string|std::string]]. Но конструктора [[string|std::string]], который принимал бы значение `short`, не существует, так что вызов конструктора [[string|std::string]] в вызове `multiset::emplace` в вызове `logAndAdd` неудачен. Все дело в том, что перегрузка для универсальной ссылки точнее соответствует аргументу типа `short`, чем перегрузка для `int`.

Функции, принимающие универсальные ссылки, оказываются самыми жадными в С++. Они в состоянии выполнить инстанцирование с точным соответствием практически для любого типа аргумента ([[Познакомьтесь с случаями некорректной работы прямой передачи|несколько видов аргументов, для которых это не так]]). Именно поэтому сочетание перегрузки и универсальной ссылки почти всегда является плохой идеей: перегрузка для универсальных ссылок годится для гораздо большего количества типов аргументов, чем обычно ожидает разработчик перегрузок. 

Простой способ свалиться в эту яму - написать конструктор с прямой передачей. Небольшое изменение функции `logAndAdd` демонстрирует эту проблему. Вместо написания свободной функции, которая принимает либо [[string|std::string]], либо индекс, который можно использовать для поиска [[string|std::string]], представим себе класс `Person` с конструкторами, которые выполняют те же действия:

```c++
class Person{
	public:
		template<typename Т>
		explicit Person(T&& n)          // Конструктор с прямой передачей
        :name(std::forward<T>(n)){ }    // инициализирует члены-данные

		explicit Person(int idx)        // Конструктор с параметром int
        :name(nameFromidx(idx)){ }
        ...

	private :
		std::string name;
};
```

Как и в случае с `logAndAdd`, передача целочисленного типа, отличного от `int` (например, [[size|std::size_t]], [[short|short]], [[long|long]] и т.п.), будет вызывать перегрузку конструктора для универсальной ссылки вместо перегрузки для [[int|int]], и это будет вести к ошибкам компиляции. Однако проблема гораздо хуже, поскольку в `Person` имеется больше перегрузок, чем видит глаз. [[Генерация специальных функций-членов|Поясняется]], что при соответствующих условиях С++ будет генерировать как копирующие, так и перемещающие конструкторы, и это так и будет, даже если класс содержит шаблонный конструктор, который при инстанцировании в состоянии дать сигнатуру копирующего или перемещающего конструктора. Если таким образом генерируются копирующий и перемещающий конструкторы для `Person`, класс `Person` будет выглядеть, по сути, следующим образом:

```c++
class Person{
	public:
		template<typename Т>        // Конструктор с прямой передачей
		explicit Person (T&& n)
		:name(std::forward<T>(n)){}
		
		explicit Person(int idx);  // Конструктор от int
		Person(const Person& rhs); // Копирующий конструктор
								   // !(сгенерирован компилятором)
		Person(Person&& rhs);      // Перемещающий конструктор
								   // ( сгенерирован компилятором)
);
```

Это приводит к поведению, интуитивно понятному, только если вы потратили на работу с компиляторами и общение с их разработчиками столько времени, что забыли, каково это - быть человеком:

```c++
Person р("Nапсу");
auto cloneOfP(p);                // Создание нового объекта Person из р ;
                                 // этот код не компилируется '
```

Здесь мы пытаемся создать объект `Person` из другого объекта `Person`, что представляется очевидным случаем копирующего конструирования (`р` является `lvalue`, так что можно выбросить из головы все фантазии на тему копирования с помощью операции перемещения). Но этот код не вызывает копирующий конструктор - он вызывает конструктор с прямой передачей. Затем эта функция будет пытаться инициализировать член-данные [[string|std::string]] объекта `Person` значением из объекта `Person (р)`. Класс [[string|std::string]] не имеет конструктора, получающего параметр типа `Person`, так что ваш компилятор будет вынужден просто развести руками и наказать вас длинными и непонятными сообщениями об ошибках.

"Но почему, - можете удивиться вы, - вызывается конструктор с прямой передачей, а не копирующий конструктор? Мы же инициализируем `Person` другим объектом Person!" Да, это так, но компиляторы приносят присягу свято соблюдать правила С++, а правила, имеющие отношение к данной ситуации, - это правила разрешения вызовов перегруженных функций.

Компиляторы рассуждают следующим образом: `cloneOfP` инициализируется неконстантным `lvalue (р)`, а это означает, что шаблонный конструктор может быть инстанцирован для получения неконстантного [[rvalue|lvalue]] типа `Person`. После такого инстанцирования класс `Person` выглядит следующим образом:

```c++
class Person {
	public:
		explicit Person(Person& n)             // Инстанцирован из
		:name(std::forward<Persoп&>(n)){}      // шаблона с прямой
											   // передачей

		explicit Person(int idx);              // Как и ранее
		Persoп(const Person& rhs);             // Копирующий конструктор
                                            // (сгенерирован компилятором)
);
```

В инструкции

```c++
auto cloneOfP(p);
```

`р` может быть передан либо копирующему конструктору, либо инстанцированному шаблону. Вызов копирующего конструктора для точного соответствия типа параметра требует добавления к `р` модификатора [[const|const]]; вызов инстанцированного шаблона никаких добавлений не требует. Таким образом, перегрузка, сгенерированная из шаблона, представляет собой лучшее соответствие, так что компиляторы делают то, для чего предназначены: генерируют вызов той функции, которая соответствует наилучшим образом. "Копирование" неконстантных [[rvalue|lvalue]] типа `Person`, таким образом, осуществляется конструктором с прямой передачей, а не копирующим конструктором.

Если мы немного изменим пример, так, чтобы копируемый объект был константным, то увидим совершенно иную картину:

```c++
const Person cp("Nancy");               // Теперь объект константный
auto cloneOfP(ер);                      // Вызов копирующего конструктора
```

Поскольку копируемый объект теперь объявлен как [[const|const]], он в точности соответствует типу параметра, получаемого копирующим конструктором. Шаблонизированный конструктор также может быть инстанцирован таким образом, чтобы иметь ту же сигнатуру:

```c++
class Person {
	public :
		explicit Person(const Person& n); // Инстанцирован из шаблона
		Person(const Person& rhs);        // Копирующий конструктор
                                          // (сгенерирован компилятором)
};
```

Но это не имеет значения, поскольку одно из правил разрешения перегрузок в С++ гласит, что в ситуации, когда инстанцирование шаблона и нешаблонная функция (т.е. "нормальная" функция) имеют одинаково хорошее соответствие, предпочтение отдается нормальной функции. Поэтому все козыри оказываются на руках копирующего конструктора (нормальной функции) с той же самой сигнатурой.

(Если вам интересно, почему компиляторы создают копирующий конструктор, если они могут инстанцировать шаблонный конструктор с той же сигнатурой, [[Генерация специальных функций-членов|см]])

Взаимодействие между конструкторами с прямой передачей и сгенерированными компилятором операциями копирования и перемещения становится еще более сложным, когда в картину включается наследование. В частности, обычные реализации копирующих и перемещающих операций производного класса ведут себя совершенно неожиданно. Взгляните на следующий код:

```c++
class SpecialPerson : public Person
	public:
		SpecialPerson (const SpecialPerson& rhs) // Копирующий
			: Person(rhs)          // конструктор; вызывает конструктор
		{ ... }                    // базового класса с прямой передачей!

		SpecialPerson(SpecialPerson&& rhs)           // Перемещающий
			:Person(std::move(rhs)) // конструктор; вызывает конструктор
		{ ... }                     // базового класса с прямой передачей
);
```

Как указывают комментарии, копирующий и перемещающий конструкторы производного класса не вызывают копирующий и перемещающий конструкторы базового класса; они вызывают конструктор базового класса с прямой передачей! Чтобы понять, почему, обратите внимание, что функции производного класса используют аргументы типа `SpecialPerson` для передачи в базовый класс, после чего в игру вступает разрешение перегрузок для конструкторов в классе `Person`. В конечном итоге код не будет компилироваться, потому что у [[string|std::string]] нет никакого конструктора, принимающего `SpecialPersoп`.

Я надеюсь, что теперь я убедил вас, что перегрузка для параметров, являющихся универсальными ссылками, - это то, чего лучше избегать, насколько это возможно. Но если перегрузка для универсальной ссылки - плохая идея, то что же делать, если вам нужна функция, которая выполняет передачу большинства типов аргументов, но при этом должна обрабатывать некоторые из них особым образом? Это яйцо может быть разбито массой способов. 

> - Перегрузка для универсальных ссылок почти всегда приводит к тому, что данная перегрузка вызывается чаще, чем вы ожидаете.
> 
> - Особенно проблематичны конструкторы с прямой передачей, поскольку они обычно соответствуют неконстантным [[rvalue|lvalue]] лучше, чем копирующие конструкторы, и моrут перехватывать вызовы из производного класса копирующих и перемещающих конструкторов базового класса.


