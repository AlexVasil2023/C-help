# Предпочитайте объявление псевдонимов применению typedef

Я уверен, что мы можем сойтись на том, что применение контейнеров STL - хорошая идея, и я надеюсь, что хорошей идеей является применение [[unique_ptr|std::unique_ptr]], но думаю, что ни один из вас не увлечется многократным написанием типов наподобие `std::unique_ptr<std::unordered_map<std::string, std::string>>`. 
Избежать такой медицинской трагедии несложно, достаточно использовать [[typedef|typedef]]:
```c++
typedef
std::unique_ptr<std::unordered_map<std::string, std::string>> UPtrMapSS 
```
Но [[typedef|typedef]] слишком уж какой-то девяносто восьмой . . . Конечно, он работает и в С++11, но стандарт С++11 предлагает еще и объявление псевдонима (alias declaration):
```c++
using UPtrMapSS = std::unique_ptr<std::unordered_map<std::string, std::string>>;
```
С учетом того, что [[typedef|typedef]] и объявление псевдонима делают в точности одно и то же, разумно задаться вопросом "А есть ли какое-то техническое основание для того, чтобы предпочесть один способ другому?"

Да, есть, но перед тем как я его укажу, замечу, что многие программисты считают объявление псевдонима более простым для восприятия при работе с типами, включающими указатели на функции:
```c++
// FP является синонимом дпя указателя на функцию, принимающую
// int и const std::string& и ничего не возвращающую
typedef void (*FP)(int, const std::string&);

// То же самое, но как объявление псевдонима
using FP = void(*)(int, const std::string&) ;
```
Конечно, ни одна из разновидностей не оказывается существенно проще другой, а ряд программистов тратит немало времени для того, чтобы верно записать синонимы для типов указателей на функции, так что пока что убедительных причин для предпочтения объявления псевдонима пока что нет.

Однако убедительная причина все же существует, и называется она - шаблоны. В частности, объявления псевдонимов могут быть шаблонизированы (и в этом случае они называются шаблонами псевдонимов), в то время как [[typedef|typedef]] нет. Это дает программистам на С++11 простой механизм для выражения того, что в С++98 можно было выразить только хакерскими способами, с помощью [[typedef|typedef]], вложенных в шаблонные [[struct|struct]]. Рассмотрим, например, определение синонима для связанного списка, который использует пользовательский распределитель памяти **MyAlloc**. В случае шаблонов псевдонимов это просто:
```c++
// MyAllocList<T> является синонимом дпя std::list<T, MyAlloc<T>>:
tamplate<typename Т>
using МyAllocList = std::list<T, MyAlloc<T>>;

// Клиентский код
MyAllocList<Widget> lw;
```

В случае [[typedef|typedef]]:
```c++
// MyAllocList<T>::type - синоним для std::list<T, MyAlloc<T>>:
teшplate<typename Т>
struct МyAllocList {
	typedef std::list<T, MyAlloc<T>> type;
};

// Клиентский код
MyAllocList<Widget>::type lw;
```
Все еще хуже. Если вы хотите использовать [[typedef|typedef]] в шаблоне для создания связанного списка, хранящего объекты типа, указанного параметром шаблона, имя, указанное в [[typedef|typedef]], следует предварять ключевым словом [[typename|typename]]:
```c++
template<typename Т>
class Widget {                               // Widget<T> содержит
	private:                                 // MyAllocList<T>,
		typename MyAllocList<T>::type list;  // как член-данные
);
```
Здесь `MyAllocList<T>::type` ссылается на тип, который зависит от параметра типа шаблона (`Т`). Тем самым `MyAllocList<T>::type` является зависимым типом (dependent type), а одно из многих милых правил С++ требует, чтобы имена зависимых типов пред­варялись ключевым словом [[typename|typename]].

Если `MyAllocList` определен как шаблон псевдонима, это требование использования ключевого слова [[typename|typename]] убирается (как и громоздкий суффикс `::type`):
```c++
template<typename Т>
using MyAllocList = std::list<T, MyAlloc<T>>;        // Как и ранее

template<typename Т>
class Widget {
	private :
		МyAllocList<Т>list;                          // Ни typename,
													 // ни ::type
);
```
Для вас `MyAllocList<T>` (т.е. использование шаблона псевдонима) может выглядеть как зависимый от параметра шаблона `T`, как и `MyAllocList<T>::type` (т.е. как и использование вложенного [[typedef|typedef]]), но вы не компилятор. Когда компилятор обраба­тывает шаблон `Widget` и встречает использование `MyAllocList <T>` (т.е. использование шаблона псевдонима), он знает, что `MyAllocList <T>` является именем типа, поскольку `MyAllocList` является шаблоном псевдонима: он обязан быть именем типа. Тем самым `MyAllocList<T>` оказывается независимым типом, и спецификатор [[typename|typename]] не является ни требуемым, ни разрешенным.

С другой стороны, когда компилятор видит `MyAllocList <Т>::tуре` (т.е. использование вложенных [[typedef|typedef]]) в шаблоне `Widget`, он не может знать наверняка, что эта конструкция именует тип, поскольку это может быть специализация `MyAllocList`, с которой он еще не встречался и в которой `MyAllocList <T>::type` ссылается на нечто, отличное от типа. Это звучит глупо, но не вините компиляторы за то, что они рассматривают такую возможность. В конце концов, это люди пишут такой код.

Например, некая заблудшая душа вполне в состоянии написать следующее:
```c++
class Wine {...};

ternplate<>                          // Специализация MyAllocList в
class MyAllocList<Wine>              // которой Т представляет собой Wine
	private :
		enum class WineType          // См. в разделе 3.4 информацию об
			{ White, Red, Rose } ;   // "enшn class"
			
		WineType type;               // В этом классе type представляет
									 // собой данные-член 1
};
```
Как видите, `MyAllocList<Wine>::type` не является типом. Если `Widget` инстанцирован с `Wine`, `MyAllocList<T>::type` в шаблоне `Widget` представляет собой данные-член, а не тип. Ссылается ли `MyAllocList<T>::type` на тип в шаблоне `Widget`, зависит от того, чем является `Т`, а потому компиляторы требуют, чтобы вы точно указывали, что это тип, предваряя его ключевым словом [[typename|typename]].

Если вы занимаетесь метапрограммированием с использованием шаблонов (template metaprogramming ТМР), то вы, скорее всего, сталкивались с необходимостью получать параметры типов шаблонов и создавать из них новые типы. Например, для некоторого заданного типа `T` вы можете захотеть удалить квалификатор [[const|const]] или квалификатор ссылки, содержащийся в `Т`, например преобразовать `const std::string&` в `std::string`. Вы можете также захотеть добавить [[const|const]] к типу или преобразовать его в [[rvalue|lvalue-ccылкy]], например, превращая `Widget` в `const Widget` или в `Widget &`. (Если вы еще не занимались ТМР, это плохо, потому что, если вы действительно хотите быть эффективным про­граммистом на С++, вы должны быть знакомы как минимум с основами этого аспекта С++. Вы можете увидеть примеры ТМР в действии, включая различные преобразования типов, о которых я упоминал, см. [[move|тут]] и [[Знакомство с альтернативами перегрузки для универсальных ссылок#Знакомство с альтернативами перегрузки для универсальных ссылок|тут]]).

С++11 дает вам инструменты для такого рода преобразований в виде свойств типов (`type traits`), набора шаблонов в заголовочном файле `<type_traits>`. В нем вы найдете десятки свойств типов; не все из них выполняют преобразования типов, но те, которые это делают, предлагают предсказуемый интерфейс. Для заданного типа `Т`, к которому вы хотели бы применить преобразование, результирующий тип имеет вид `std::преобразование<Т>::type`, например:
```c++
std::remove_const<T>::type               // Дает Т из const Т
std::remove_reference<T>::type           // Дает Т из Т& и Т&&
std::add_lvalue_reference<T>::type       // Дает Т& из Т
```
Комментарии просто резюмируют, что делают эти преобразования, так что не принимайте их слишком буквально. Перед тем как использовать их в своем проекте, я настоятельно советую ознакомиться с их точной спецификацией.

В любом случае я не стремлюсь обеспечить вас учебником по свойствам типов. Вместо этого я прошу вас обратить внимание на то, что каждое преобразование завершается `::type`. Если вы применяете их к параметру типа в шаблоне (что практически всегда является их применением в реальном коде), то вы также должны предварять каждое их применение ключевым словом [[typename|typename]]. Причина обоих этих синтаксических требований заключается в том, что свойства типов в C++11 реализованы как вложенные [[typedef|typedef]] внутри шаблонных структур [[struct|struct]]. Да, это так - они реализованы с помощью технологии, о которой я говорю, что она уступает шаблонам псевдонимов!

Тому есть исторические причины, но здесь мы их опустим, поскольку Комитет по стандартизации с опозданием признал, что шаблоны псевдонимов оказываются лучшим способом реализации, и соответствующие шаблоны включены в С++14 для всех преобразований типов C++11. Псевдонимы имеют общий вид: для каждого преобразования C++11 `std::преобразование<Т>::type` имеется соответствующий шаблон псевдонима С++14 с именем `std::преобразование_t`. Вот примеры, поясняющие, что я имею в виду:
```c++
std::remove_const<T>::type         // C++11: const Т -> Т
std::remove_const_t<T>             // Эквивалент в С++14

std::remove_reference<T>::type     // C++11: Т & / Т & & -> Т
std::remove_reference_t<T>         // Эквивалент в С++14

std::add_lvalue_reference<T>::type // C++11: Т -> Т&
std::add_lvalue_reference_t<T>     // Эквивалент в С++14
```
Конструкции С++11 остаются в силе в С++14, но я не знаю, зачем вам может захотеться их использовать. Даже если у вас нет компилятора С++14, написание таких шаблонов псевдонимов самостоятельно - детская игра. Требуются только языковые возможности С++11, и даже ребенок сможет написать такие шаблоны. Если у вас есть доступ к электронной копии стандарта С++14, то все становится еще проще - вы можете просто скопировать необходимый код оттуда и вставить в свою программу. Вот вам для начала:
```c++
template <class Т>
using remove_const_t = typename remove_const<T>::type;

template <class Т>
using remove_reference_t = typename remove_reference<T>::type;

template <class Т>
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;
```

> * В отличие от объявлений псевдонимов, [[typedef|typedef]] не поддерживает шаблонизацию.
> 
> * Шаблоны псевдонимов не требуют суффикса `::tуре`, а в шаблонах - префикса [[typename|typename]], часто требуемого при обращении к [[typedef|typedef]].
> 
> * С++14 предлагает шаблоны псевдонимов для всех преобразований свойств типов C++11.
















