# Ограничения шаблонов, получающих универсальные ссылки

Ключевым моментом диспетчеризации дескрипторов является существование (неперегруженной) функции в качестве клиентского API. Эта единственная функция распределяет работу между функциями реализации. Обычно создать такую неперегруженную функцию диспетчеризации несложно, но второй пример, [[Избегайте перегрузок для универсальных ссылок|рассмотренный]], в котором рассматривался конструктор класса `Person` с прямой передачей, является исключением. Компиляторы могут самостоятельно генерировать копирующие и перемещающие конструкторы, так что, если даже мы напишем один конструктор и используем в нем диспетчеризацию дескрипторов, некоторые вызовы конструкторов могут быть обработаны сгенерированными компиляторами функциями, которые обходят систему диспетчеризации дескрипторов.

По правде говоря, реальная проблема не в том, что генерируемые компиляторами функции иногда обходят диспетчеризацию дескрипторов; на самом деле она в том, что они не всегда ее обходят. Вы практически всегда хотите, чтобы копирующий конструктор класса обрабатывал запрос на копирование [[rvalue|lvalue]] этого типа, но, как [[Избегайте перегрузок для универсальных ссылок|показано тут]], предоставление конструктора, принимающего универсальную ссылку, приводит к тому, что при копировании неконстантных [[rvalue|lvalue]] вызывается конструктор с универсальной ссылкой, а не копирующий конструктор. В этом разделе также поясняется, что когда базовый класс объявляет конструктор с прямой передачей, именно этот конструктор обычно вызывается при традиционной реализации производным классом копирующего и перемещающего конструкторов, несмотря на то что корректным поведением является вызов копирующих и перемещающих конструкторов.

Для подобных ситуаций, в которых перегруженная функция, принимающая универсальную ссылку, оказывается более "жадной", чем вы хотели, но недостаточно жадной, чтобы действовать как единственная функция диспетчеризации, метод диспетчеризации дескрипторов оказывается не тем, что требуется. Вам нужна другая технология, и эта технология - [[enable_if|std::еnаblе_if]].

[[enable_if|std::еnаblе_if]] дает вам возможность заставить компиляторы вести себя так, как если бы определенного шаблона не существовало. Такие шаблоны называют отключенными (disaЫed). По умолчанию все шаблоны включены, но шаблон, использующий [[enable_if|std::еnаblе_if]], включен, только если удовлетворяется условие, определенное [[enable_if|std::еnаblе_if]]. В нашем случае мы хотели бы включить конструктор `Person` с прямой передачей, только если передаваемый тип не является `Person`. Если переданный тип `Person`, то мы хотели бы отключить конструктор с прямой передачей (т.е. заставить компилятор его игнорировать), поскольку при этом для обработки вызова будет применен копирующий или перемещающий конструктор, а это именно то, чего мы хотим, когда один объект типа `Person` инициализируется другим объектом того же типа.

Способ выражения этой идеи не слишком сложен, но имеет отталкивающий синтаксис, в особенности если вы не встречались с ним ранее. Имеются некоторые шаблоны, располагающиеся вокруг части условия [[enable_if|std::еnаblе_if]], так что начнем с него. Вот объявление конструктора с прямой передачей класса `Person`, который показывает не более чем необходимо для простого использования [[enable_if|std::еnаblе_if]]. Я покажу только объявление этого конструктора, поскольку применение [[enable_if|std::еnаblе_if]] не влияет на реализацию функции. 

Реализация остается [[Избегайте перегрузок для универсальных ссылок|той же]]:

```c++
class Person{
	public:
		template<typename Т,
		typename = typename std::еnаblе_if<усповие>::type>
	explicit Person(T&& n);
};
```

Вынужден с прискорбием сообщить, что для того, чтобы разобраться, что происходит, следует проконсультироваться с другими источниками информации.
(В процессе вашего поиска поищите как [[enable_if|std::еnаblе_if]], так и волшебную аббревиатуру [[SFINAE|"SFINAE"]], поскольку именно эта технология позволяет работать [[enable_if|std::еnаblе_if]].) Здесь я хочу сосредоточиться на выражении условия, которое управляет тем, является ли конструктор включенным.

Условие, которое мы хотим указать, - что тип `Т` не является `Person`, т.е. что шаблонизированный конструктор может быть включенным, только если `T` является типом, отличным от `Person`. Благодаря свойствам шаблонов мы можем определить, являются ли два типа одним и тем же ([[is_same|std::is_same]]) , так что создается впечатление, что интересующее нас условие можно записать как `! std::is_same<Person, Т>::value`. (Обратите внимание на символ `"!"` в начале выражения. Мы хотим, чтобы типы `Person` и `Т` не совпадали.) Это близко к тому, что нам надо, но не совсем верно, поскольку, как [[Свертывание ссылок|поясняет]] , тип, выведенный для универсальной ссылки, инициализированной [[rvalue|lvalue]], всегда является [[rvalue|lvаluе-ссылкой]]. Это означает, что в коде наподобие

```c++
Person p("Nancy");
auto cloneOfP(p);               // Инициализация с помощью lvalue
```

тип `Т` в универсальном конструкторе будет выведен как `Person&`. Типы `Person` и `Person&` - разные, и результат [[is_same|std::is_same]] отражает этот факт: значение `std::is_same<Person, Person&>::value` ложно.

Если разобраться, что означает, что шаблонный конструктор в классе `Person` должен быть включен только тогда, когда `Т` не является `Person`, то мы поймем, что, глядя на `Т`, мы хотим игнорировать следующее.

> - **Ссылки**. С точки зрения определения, должен ли быть включен конструктор с универсальной ссылкой, типы `Person`, `Person&` и `Person&&` должны рассматриваться как идентичные типу `Person`.
> - **Модификаторы const и volatile**. С той же точки зрения типы `const Person`, `volatile Person` и `const volatile Person` должны рассматриваться как идентичные типу `Person`.

Это означает, что нам нужен способ удалить все ссылки, [[const|const]] и [[volatile|volatile]] из типа `Т` перед тем как выяснять, совпадает ли он с типом `Person`. И вновь на выручку приходит стандартная библиотека, предоставляя шаблон [[decay|std::decay]]. Тип `std::decay<T>::type` представляет собой то же самое, что и тип `Т`, но из него удалены все ссылки и квалификаторы [[const|const]] и [[volatile|volatile]]. (Я немного вас обманул, потому что [[decay|std::decay]], кроме того, [[Вывод типа шаблона|превращает массивы и типы функций в указатели]], но для наших целей можно считать, что [[decay|std::decay]] ведет себя так, как я описал.) Условие, которое должно выполняться для включения рассматриваемого конструктора, имеет вид

```c++
!std::is_same<Person, typename std::decay<T>::type>::value
```

т.е. `Person` не совпадает с типом `Т`, без учета всех ссылок и квалификаторов [[const|const]] и [[volatile|volatile]]. (Как [[Предпочитайте объявление псевдонимов  применению typedef|поясняется]], ключевое слово `typename` перед [[decay|std::decay]] необходимо, поскольку тип `std::decay<T>::type` зависит от параметра шаблона `Т`.)

Вставка этого условия в шаблон [[enable_if|std::еnаblе_if]] выше, а также форматирование результата для того, чтобы проще понять взаимоотношения между частями кода, дает следующее объявление конструктора с прямой передачей класса `Person`:

```c++
class Person {
	public :
		template<
			typename Т,
			typename = typename std::enable_if<
				!std::is_same<Person,
						typename std::dесау<Т>::type
                        >::value
             >::type
        >
		explicit Person (T&& n);
};
```

Если вы никогда ранее не видели ничего подобного, не пугайтесь. Есть причина, по которой я оставил этот метод напоследок. Если для того, чтобы избежать смешивания универсальных ссылок и перегрузки вы можете использовать один из прочих методов (а это почти всегда возможно), вы должны это сделать. Тем не менее, если вы привыкнете к функциональному синтаксису и множеству угловых скобок, это не так плохо. Кроме того, это позволяет получить поведение, к которому вы стремитесь. С учетом приведенного выше объявления построение объекта `Person` из другого объекта `Person` ([[rvalue|lvalue или rvalue]], с квалификатором [[const|const]] или без него, с квалификатором [[volatile|volatile]] или без него) никогда не вызовет конструктор, принимающий универсальную ссылку.

Мы добились успеха? Дело сделано?
Пока что нет. Не спешите праздновать. [[Избегайте перегрузок для универсальных ссылок|Раздел]] все еще посылает нам свои приветы.

Предположим, что класс, производный от `Person`, реализует операции копирования и перемещения традиционным способом:

```c++
class SpecialPerson : public Person {
	public:
		SpecialPerson(const SpecialPerson& rhs) // Копирующий
        :Person(rhs)                // конструктор; вызывает конструктор
        {...}                       // базового класса с прямой передачей!

		SpecialPerson(SpecialPerson&& rhs)      // Перемещающий
		:Person(std::move(rhs))     // конструктор; вызывает конструктор
        {...}                       // базового класса с прямой передачей!
};
```

Это тот же код, который вы видели ранее, в конце предыдущего раздела, включая комментарии, увы, оставшиеся справедливыми. Копируя или перемещая объект `SpecialPerson`, мы ожидаем, что части базового класса будут скопированы или перемещены с помощью копирующего или, соответственно, перемещающего конструктора базового класса. Однако в этих функциях мы передаем объекты `SpecialPerson` конструкторам базового класса, а поскольку `SpecialPerson` не совпадает с `Person` (даже после применения [[decay|std::decay]]), конструктор с универсальной ссылкой в базовом классе оказывается включенным и без проблем проходит проверку на идеальное совпадение с аргументом `SpecialPerson`. Это точное соответствие лучше преобразования производного класса в базовый, необходимого для связывания объекта `SpecialPerson` с параметром `Person` в копирующем и перемещающем конструкторах класса `Person`, так что при имеющемся коде копирование и перемещение объектов `SpecialPerson` будет использовать для копирования и перемещения частей базового класса конструктор с универсальной ссылкой класса `Person`! Это чудное ощущение дежавю [[Избегайте перегрузок для универсальных ссылок|раздела]]...

Производный класс просто следует обычным правилам реализации копирующего и перемещающего конструкторов производного класса, поэтому решение этой проблемы находится в базовом классе и, в частности, в условии, которое контролирует включение конструктора с универсальной ссылкой класса `Person`. Теперь мы понимаем, что надо включать шаблонный конструктор не для любого типа аргумента, отличного от `Person`, а для любого типа аргумента, отличного как от `Person`, так и от типа, производного от `Person`.

Вас уже не должно удивлять обилие всяческих полезных шаблонов в стандартной библиотеке, так что известие о наличии шаблона, который определяет, является ли один класс производным от другого, вы должны воспринять с полным спокойствием. Он называется [[is_base_of|std::is_base_of]]. Значение `std::is_base_of<T1, T2>::value` истинно, если `Т2` класс, производный от `T1`. Пользовательские типы рассматриваются как производные от самих себя, так что `std::is_base_of<T, Т>::value` истинно, если `Т` представляет собой пользовательский тип. (Если `Т` является встроенным типом, `std::is_base_of<T, T>::value` ложно.) Это удобно, поскольку мы хотим пересмотреть наше условие, управляющее отключением конструктора с универсальной ссылкой класса `Person` таким образом, чтобы этот конструктор был включен, только если тип `Т` после удаления всех ссылок и квалификаторов [[const|const]] и [[volatile|volatile]] не являлся ни типом `Person`, ни классом, производным от `Person`. Применение [[is_base_of|std::is_base_of]] вместо [[is_same|std::is_same]] дает нам то, что требуется:

```c++
class Person {
	public:
		template<
			typename Т,
			typename = typename std::enable_if<
				!std::is_base_of<Person,
								 typename std::decay<T>::type
                                >::value
            >::type
        >
		explicit Person (T&& n ) ;
);
```

Вот теперь работа завершена. Вернее, завершена при условии, что мы пишем код на С++11. При использовании С++14 этот код будет работать, но мы можем использовать псевдонимы шаблонов для [[enable_if|std::еnаblе_if]] и [[decay|std::decay]], чтобы избавиться от хлама в виде [[typename|typename]] и `::tуре`, получая несколько более приятный код:

```c++
class Person {                                  // С++14
	public:
		template<
			typename Т,
			typename = std::enable_if_t<        // Меньше кода здесь
				!std::is_base_of<Person,        // Меньше кода здесь
							     std::decay_t<T>// И здесь
                                >::value
            >                                   // И здесь
        >
		explicit Person(T&& n);
);
```

Мы видели, как использовать [[enable_if|std::еnаblе_if]] для выборочного отключения конструктора с универсальной ссылкой класса `Person` для типов аргументов, которые мы хотим обрабатывать с помощью копирующего и перемещающего конструкторов, но мы еще не видели, как применить его для того, чтобы отличать целочисленные аргументы от не являющихся таковыми. В конце концов, таковой была наша первоначальная цель; проблема неоднозначности конструктора была всего лишь неприятностью, подхваченной по дороге.

Все, что нам нужно сделать - это добавить перегрузку конструктора `Person` для обработки целочисленных аргументов и сильнее ограничить шаблонный конструктор так, чтобы он был отключен для таких аргументов. 

```c++
class Person{
	public:
		template<
			typename Т,
			typename std::enable_if_t<
				! std::is_base_of<Person, std::decay_t<T>>::value
				&&
				! std::is_integral<std::remove_reference_t<Т>>::value
            >
		explicit Persoп(T&& n)         // Конструктор для std::striпg и
		:name(std::forward<T>(n))      // аргументов, приводимых к
		{...}                          // std::striпg
		
		explicit Person (int idx)      // Конструктор для
		:name(nameFromidx(idx))        // целочисленных аргументов
		{...}

		...              // Копирующий и перемещающий конструкторы и т.д.
	
	private :
		std::striпg паmе;
};
```

этот подход не только справляется с работой, но и делает это с чрезвычайным апломбом. Применение прямой передачи предполагает высокую эффективность, а управление сочетанием универсальных ссылок и перегрузки вместо их запрета позволяет применять этот метод в обстоятельствах (таких, как разработка конструкторов), когда перегрузка неизбежна.




















