# Используйте std::weak_ptr для std::shared_ptr - подобных указателей, которые могут быть висячими

Парадоксально, но может быть удобно иметь интеллектуальный указатель, работающий как [[shared_ptr|std::shared_ptr]], но который не участвует в совместном владении ресурсом, на который указывает (друтими словами, указатель наподобие [[shared_ptr|std::shared_ptr]], который не влияет на счетчик ссылок объекта). Эта разновидность интеллектуального указателя должна бороться с проблемой, неизвестной указателям [[shared_ptr|std::shared_ptr]]: возможностью того, что объект, на который он указывает, был уничтожен. Истинный интеллектуальный указатель в состоянии справиться с этой проблемой, отслеживая, когда он становится висячим, т.е. когда объект, на который он должен указывать, больше не существует. Именно таковым и является интеллектуальный указатель `std::weak_ptr.

Вы можете удивиться, зачем может быть нужен указатель `std::weak_ptr`. Вы, вероятно, удивитесь еще больше, когда познакомитесь с его API. Указатель `std::weak_ptr` не может быть ни разыменован, ни проверен на "нулевость': Дело в том, что `std::weak_ptr` не является автономным интеллектуальным указателем. Это - дополнение к [[shared_ptr|std::shared_ptr]].

Их взаимосвязь начинается с самого рождения: указатели `std::weak_ptr` обычно создаются из указателей [[shared_ptr|std::shared_ptr]]. Они указывают на то же место, что и инициализирующие их указатели [[shared_ptr|std::shared_ptr]], но не влияют на счетчики ссылок объекта, на который указывают:
```c++
auto spw =                            // После создания spw счетчик
	std::make_shared<Widget>();       // ссылок указываемого Widget
                                      // равен 1. (0 std::make_shared
...
std::weak_ptr<Widget>wpw(spw);        // wpw указывает на тот же
								      //  Widget, что и spw. Счетчик
                                      // ссылок остается равным 1
...
spw = nullptr;                        // Счетчик ссылок равен О, и
                                      // Widget уничтожается.
                                      // wpw становится висячим
```
О висячем `std::weak_ptr` говорят, что он просрочен (`expired`). Вы можете проверить это непосредственно:
```c++
if (wpw.expired()) ... // Если wpw не указывает на объект.
```
Но чаше всего вам надо не просто проверить, не просрочен ли указатель `std::weak_ptr`, но и, если он не просрочен (т.е. не является висячим), обратиться к объекту, на который он указывает. Это проще сказать, чем сделать. Поскольку у указателей `std::weak_ptr` нет операций разыменования, нет и способа написать такой код. Даже если бы он был, разделение проверки и разыменования могло бы привести к состоянию гонки: между вызовом `expired` и разыменованием другой поток мог бы переприсвоить или уничтожить последний [[shared_ptr|std::shared_ptr]], указывающий на объект, тем самым приводя к уничтожению самого объекта. В этом случае ваше разыменование привело бы к неопределенному поведению.

Что вам нужно - так это атомарная операция, которая проверяла бы просроченность указателя `std::weak_ptr` и, если он не просрочен, предоставляла вам доступ к указываемому объекту. Это делается путем создания указателя [[shared_ptr|std::shared_ptr]] из указателя `std::weak_ptr`. Операция имеет две разновидности, в зависимости от того, что должно произойти в ситуации, когда `std::weak_ptr` оказывается просроченным при попытке создания из него [[shared_ptr|std::shared_ptr]]. Одной разновидностью является `std::weak_ptr::lock`, которая возвращает [[shared_ptr|std::shared_ptr]]. Этот указатель нулевой, если `std::weak_ptr` просрочен:
```c++
std::shared_ptr<Widget>spw1               // Если wpw просрочен,
	= wpw.lock();                         // spw1 - нулевой
auto spw2 = wpw.lock();                   // То же самое, но с auto
```
Второй разновидностью является конструктор [[shared_ptr|std::shared_ptr]], принимающий `std::weak_ptr` в качестве аргумента. В этом случае, если `std::weak_ptr` просрочен, генерируется исключение:
```c++
std::shared_ptr<Widget>spwЗ(wpw);          // Если wpw просрочен, гене-
										   // рируется std::bad_weak_ptr­
```
Но вас, вероятно, интересует, зачем вообще нужен `std::weak_ptr`. Рассмотрим фабричную функцию, которая производит интеллектуальные указатели на объекты только для чтения на основе уникальных значений идентификаторов. В соответствии с [[unique_ptr|советом]] , касающегося возвращаемых типов фабричных функций, она возвращает [[unique_ptr|std::unique_ptr]]:
```c++
std::unique_ptr<const Widget>loadWidget(WidgetID id);
```
Если `loadWidget` является дорогостоящим вызовом (например, из-за файловых операций ввода-вывода или обращения к базе данных), а идентификаторы часто используются повторно, разумной оптимизацией будет написание функции, которая делает то же, что и `loadWidget`, но при этом кеширует результаты. Засорение кеша всеми затребованными `Widget` может само по себе привести к проблемам производительности, так что другой разумной оптимизацией является удаление кешированных `Widget`, когда они больше не используются.

Для такой кеширующей фабричной функции возвращаемый тип [[unique_ptr|std::unique_ptr]] не является удачным выбором. Вызывающий код, определенно, получает интеллектуальные указатели на кешированные объекты, и время жизни полученных объектов также определяется вызывающим кодом. Однако кеш также должен содержать указатели на эти же объекты. Указатели кеша должны иметь возможность обнаруживать свое висячее состояние, поскольку когда клиенты фабрики заканчивают работу с объектом, возвращенным ею, этот объект уничтожается, и соответствующая запись кеша становится висячей. Следовательно, кешированные указатели должны представлять собой указатели `std::weak_ptr`, которые могут обнаруживать, что стали висячими. Это означает, что возвращаемым типом фабрики должен быть [[shared_ptr|std::shared_ptr]], так как указатели `std::weak_ptr` могут обнаруживать, что стали висячими, только когда время жизни объектов управляется указателями [[shared_ptr|std::shared_ptr]].

Вот как выглядит быстрая и неаккуратная реализация кеширующей версии `loadWidget`:
```c++
std::shared_ptr<const Widget>fastLoadWidget(WidgetID id)
{
	static std::unordered_map<WidgetID,
		std::weak_ptr<const Widget>>cache;
		
	auto objPtr                   // objPtr является std::shared_ptr
		= cache[id].lock();       // для кешированного объекта и
								  // нулевым указателем для объекта,
								  // отсутствующего в кеше

	if(!objPtr) {                     // При отсутствии в кеше
		objPtr = loadWidget(id);      // объект загружается
		cache[id] = objPtr;           // и кешируется
	}
	
	return objPtr;
}
```
Эта реализация использует один из контейнеров С++11, представляющий собой хеш­таблицу ([[unordered_map|std::unordered_map]]), хотя здесь и не показаны хеширование `WidgetID` и функции сравнения, которые также должны присутствовать в коде.

Реализация `fastLoadWidget` игнорирует тот факт, что кеш может накапливать просроченные указатели `std::weak_ptr`, соответствующие объектам `Widget`, которые больше не используются (а значит, были уничтожены). Реализация может быть улучшена, но вместо того чтобы тратить время на вопрос, который не привнесет ничего нового в понимание интеллектуальных указателей `std::weak_ptr`, давайте рассмотрим второе применение этих указателей: шаблон проектирования `Observer` (Наблюдатель). Основными компонентами этого шаблона являются субъекты (объекты, которые могут изменяться) и наблюдатели (объекты, уведомляемые при изменении состояний). В большинстве реализаций каждый субъект содержит член-данные, хранящие указатели на его наблюдателей. Это упрощает для субъектов проблемы уведомления об изменении состояний. Субъекты не заинтересованы в управлении временем жизни своих наблюдателей (т.е. тем, когда они должны быть уничтожены), но они очень заинтересованы в том, чтобы, если наблюдатель был уничтожен, субъекты не пытались к нему обратиться. Разумным проектом может быть следующий - каждый субъект хранит контейнер указателей `std::weak_ptr` на своих наблюдателей, тем самым позволяя субъекту определять, не является ли указатель висящим, перед тем как его использовать.

В качестве последнего примера применения `std::weak_ptr` рассмотрим структуру данных с объектами `А`, `В` и `С` в ней, где `А` и `С` совместно владеют `В`, а следовательно, хранят указатели [[shared_ptr|std::shared_ptr]] на нее:
![[Shared_1.png]]
Предположим, что было бы также полезно иметь указатель из `B` на `А`. Какую разновидность интеллектуального указателя следует использовать в этом случае?
![[Shared_2.png]]
Есть три варианта.
>
> - Обычный указатель. При таком подходе, если уничтожается `А`, а `C` продолжает указывать на `В`, `В` будет содержать указатель на `А`, который становится висящим. `В` не в состоянии этого определить, а потому `В` может непреднамеренно этот указатель разыменовать. В результате получается неопределенное поведение.
> 
> - Указатель [[shared_ptr|std::shared_ptr]]. В этом случае `А` и `В` содержат указатели [[shared_ptr|std::shared_ptr]] один на другой. Получающийся цикл [[shared_ptr|std::shared_ptr]](`А` указывает на `В`, а `В` указывает на `А`) предохраняет и `А`, и `В` от уничтожения. Даже если `А` и `В` недостижимы из других структур данных программы (например, поскольку `С` больше не указывает на `В`), счетчик ссылок каждого из них равен единице. Если такое происходит, `А` и `В` оказываются потерянными для всех практических применений: программа не в состоянии к ним обратиться, а их ресурсы не моrут быть освобождены.
> 
> - Указатель `std::weak_ptr`. Это позволяет избежать обеих описанных выше проблем. Если уничтожается `А`, указатель в `B` становится висящим, но `В` в состоянии это обнаружить. Кроме того, хотя `А` и `В` указывают друг на друга, указатель в `В` не влияет на счетчик ссылок `А`, а следовательно, не может предотвратить удаление `А`, когда на него больше не указывает ни один [[shared_ptr|std::shared_ptr]].

Очевидно, что наилучшим выбором является `std::weak_ptr`. Однако стоит отметить, что необходимость применения указателей `std::weak_ptr` для предотвращения потенциальных циклов из указателей [[shared_ptr|std::shared_ptr]] не является очень распространенным явлением. В строго иерархических структурах данных, таких как деревья, дочерними узлами обычно владеют их родительские узлы. При уничтожении родительского узла должны уничтожаться и его дочерние узлы. В общем случае связи от родительских к дочерним узлам лучше представлять указателями [[unique_ptr|std::unique_ptr]]. Обратные связи от дочерних узлов к родительским можно безопасно реализовывать, как обычные указатели, поскольку дочерний узел никогда не должен иметь время жизни, большее, чем время жизни его родительского узла. Таким образом, отсутствует риск того, что дочерний узел разыменует висячий родительский указатель.

Конечно, не все структуры данных на основе указателей строго иерархичны, и когда приходится сталкиваться с такими неиерархичными ситуациями, как и с ситуациями наподобие кеширования или реализации списков наблюдателей, знайте, что у вас есть такой инструмент, как `std::weak_ptr`.

С точки зрения эффективности `std::weak_ptr`, по сути, такой же, как и [[shared_ptr|std::shared_ptr]]. Объекты `std::weak_ptr` имеют тот же размер, что и объекты [[shared_ptr|std::shared_ptr]], они используют те же управляющие блоки, что и указатели [[shared_ptr|std::shared_ptr]], а операции, такие как создание, уничтожение и присваивание, включают атомарную работу со счетчиком ссылок. Вероятно, это вас удивит, поскольку в начале этого раздела я писал, что указатели `std::weak_ptr` не участвуют в подсчете ссылок. Но это не совсем то, что я написал. Я написал, что указатели `std::weak_ptr` не участвуют в совместном владении объектами, а следовательно, не влияют на счетчик ссылок указываемого объекта. На самом деле в управляющем блоке имеется второй счетчик ссылок, и именно с ним и работают указатели `std::weak_ptr`. [[make_unique#Предпочитайте использование std make_unique и std make_shared непосредственному использованию оператора new|Более подробно]].

> - Используйте `std::weak_ptr` как [[shared_ptr|std::shared_ptr]] - oбpaзныe указатели, которые могут быть висячими.
> 
> - Потенциальные применения `std::weak_ptr` включают хеширование, списки наблюдателей и предупреждение циклов указателей [[shared_ptr|std::shared_ptr]].
>  


