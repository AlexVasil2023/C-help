# Свертывание ссылок

[[move#Азы std move и std forward|Говорилось]], что, когда аргумент передается в шаблонную функцию, выведенный для параметра шаблона тип указывает, является ли аргумент [[rvalue|lvalue или rvalue]]. В разделе не было упомянуто, что это происходит только тогда, когда аргумент используется для инициализации параметра, являющегося универсальной ссылкой. Вместе эти наблюдения об универсальных ссылках и кодировании [[rvalue|lvalue/rvalue]] означают, что для шаблона

```c++
template<typename Т>
void func(T&& param);
```

выведенный параметр шаблона `Т` будет включать информацию о том, был ли переданный в `param` аргумент [[rvalue|lvalue или rvalue]].

Механизм этого кодирования прост. Если в качестве аргумента передается [[rvalue|lvalue]], `T` выводится как [[rvalue|lvаluе-ссылка]]. При передаче [[rvalue|rvalue]] вывод типа приводит к тому, что `T` не является ссылкой. (Обратите внимание: [[rvalue|lvalue]] кодируются как [[rvalue|lvаluе-ссылки]], но [[rvalue|rvalue]] кодируются как не ссылки.) Следовательно:

```c++
Widget widgetFactory();              // Функция, возвращающая rvalue
Widget w;                            // Переменная (lvalue)
func(w);                             // Вызов функции с lvalue; тип T
									 // представляет собой Widget&
func(widgetFactory());               // Вызов функции с rvalue; тип T
                                     // представляет собой Widget
```
В обоих вызовах `func` передается `Widget`, но так как один `Widget` является [[rvalue|lvalue]], а второй представляет собой [[rvalue|rvalue]], для параметра шаблона `Т` выводятся разные типы. Это, как вы вскоре увидите, и определяет, чем становятся универсальные ссылки: [[rvalue|rvalue- или lvаluе-ссылками]]; а кроме того, это механизм, лежащий в основе работы [[forward|std::forward]].

Прежде чем более внимательно рассмотреть [[forward|std::forward]] и универсальные ссылки, мы должны заметить, что ссылка на ссылку в С++ не существует. Попытайтесь объявить ее, и компилятор вынесет вам строгий выговор:

```c++
int х;
auto& & rx = х;           // Ошибка! Объявлять ссылки на ссылки нельзя
```

Но рассмотрим, что произойдет, если передать [[rvalue|lvalue]] шаблону функции, принимающему универсальную ссылку:

```c++
template<typename Т>
void func(T&& param);                            // Как и ранее
func(w);                                         // Вызов func с lvalue;
												 // Т выводится как Widget&
```

Если мы возьмем тип, выведенный для `Т` (т.е. `Widget&` ) и используем его для инстанцирования шаблона, то получим следующее:

```c++
void func(Widget& && param);
```

Ссылка на ссылку! Но компиляторы не возражают. Из [[Отличие универсальных ссылок от rvalue-ссылок|раздела]] мы знаем, что, поскольку универсальная ссылка `param` инициализируется с помощью [[rvalue|lvalue]], тип `param` должен быть [[rvalue|lvаluе-ссылкой]], но как компилятор получит результат взятия выведенного типа для `T` и подстановки его в шаблон, который представляет собой конечную сигнатуру функции?

```c++
void func(Widget& param);
```

Ответ заключается в свертывании ссылок (reference collapsing). Да, вам запрещено объявлять ссылки на ссылки, но компиляторы могут создавать их в определенных контекстах, среди которых - инстанцирование шаблонов. Когда компиляторы генерируют ссылки на ссылки, свертывание ссылок определяет, что будет дальше.

Существуют два вида ссылок ([[rvalue|lvalue и rvalue]]), так что имеются четыре возможные комбинации "ссылка на ссылку" (lvalue на lvalue, lvalue на rvalue, rvalue на lvalue и rvalue на гvalue). Если ссылка на ссылку возникает в контексте, где это разрешено (например, во время инстанцирования шаблона}, то ссылки сворачиваются в единственную ссылку согласно следующему правилу:

> Если любая из ссылок является [[rvalue|lvаluе-ссылкой]], результат представляет собой [[rvalue|lvalue-ccылкy]]. В противном случае (т.е. когда обе ссылки являются [[rvalue|rvаluе-ссылками]]) результат представляет собой [[rvalue|гvаluе-ссылку]].

В нашем приведенном выше примере подстановка выведенного типа `Widget&` в шаблон `func` дает [[rvalue|rvalue-ccылкy на lvalue-ccылкy]], и правило свертки ссылок гласит, что результатом является [[rvalue|lvalue-ccылкa]].

Свертывание ссылок является ключевой частью механизма, обеспечивающего работу [[forward|std::forward]]. [[Использование move и forward|Как пояснялось]], [[forward|std::forward]] применяется к параметрам, являющимся универсальными ссылками, так что обычно его применение имеет следующий вид:

```c++
template<typename Т>
void f(T&& fParam)
{
	...                                  // Некоторая работа
	someFunc(std::forward<T>(fParam));   // Передача fParam в
}                                        // someFunc
```

Поскольку `fParam` представляет собой универсальную ссылку, мы знаем, что параметр типа `T` будет кодировать информацию о том, являлся ли переданный `f` аргумент (т.е. выражение, использованное для инициализации `fParam`} [[rvalue|lvalue или rvalue]]. Работа [[forward|std::forward]] заключается в приведении `fParam` ([[rvalue|lvalue]]) к [[rvalue|rvalue]] тогда и только тогда, когда `Т` гласит, что переданный в `f` аргумент был [[rvalue|rvalue]], т.е. если `Т` не является ссылочным типом.

Вот как можно реализовать [[forward|std::forward]], чтобы он выполнял описанные действия:

```c++
template<typename Т>                     // В пространстве имен std
Т&& forward(typename
			remove_reference<T>::type& param)
{
	return static_cast<T&&>(param);
}
```

Этот код не совсем отвечает стандарту (я опустил несколько деталей интерфейса), но отличия не играют роли для понимания того, как ведет себя [[forward|std::forward]].

Предположим, что аргумент, переданный `f`, является [[rvalue|lvalue]] типа `Widget`. Тип `Т` будет выведен как `Widget&`, а вызов [[forward|std::forward]] инстанцирует `std::forward<Widget &>`. Подстановка `Widget&` в реализацию [[forward|std::forward]] дает следующее:

```c++
Widget& && forward(typename
			remove_reference<Widget&>::type& param)
{ return static_cast<Widget& &&>(param); }
```

Свойство типа `std::remove_ reference<Widget&>::type` дает `Widget` ([[Предпочитайте объявление псевдонимов  применению typedef|см.]]), так что [[forward|std::forward]] превращается в

```c++
Widget& && forward(Widget& param)
{ return static_cast <Widget& &&>(param); }
```

К возвращаемому типу и приведению также применяется сворачивание ссылок, и результат представляет собой последнюю версию [[forward|std::forward]] для вызова:

```c++
Widget& forward(Widget& param)                // В пространстве
{ return static_cast<Widget&> (param); }      // имен std
```

Как можно видеть, когда в шаблон функции `f` передается аргумент [[rvalue|lvalue]], [[forward|std::forward]] инстанцируется для получения и возврата [[rvalue|lvаluе-ссылки]]. Приведение внутри [[forward|std::forward]] не делает ничего, поскольку тип `param` уже представляет собой `Widget&`, так что приведение его к `Widget&` ни на что не влияет. Таким образом, lvаluе арrумент, переданный [[forward|std::forward]], вернет [[rvalue|lvаluе-ссылку]]. По определению [[rvalue|lvаluе-ссылки]] являются [[rvalue|lvalue]], так что передача [[rvalue|lvalue]] в [[forward|std::forward]] приводит к возврату [[rvalue|lvalue]], как и предполагалось.

Предположим теперь, что передаваемый `f` аргумент является [[rvalue|rvalue]] типа `Widget`. В этом случае выведенный тип параметра типа `Т` шаблона `f` будет просто `Widget`. Вызов [[forward|std::forward]] внутри `f`, таким образом, будет представлять собой `std::forward<Widget>`. Подстановка `Widget` вместо `Т` в реализации [[forward|std::forward]] дает следующее:

```c++
Widget&& forward(typename
			remove_reference<Widget>::type& param)
{ return static_cast<Widget&&> (param); }
```

Применение [[remove_reference|std::remove_reference]] к типу `Widget`, не являющемуся ссылкой, дает тот же тип, что и переданный (`Widget`), так что [[forward|std::forward]] превращается в

```c++
Widget&& forward(Widget& param)
{ return static_cast<Widget&&>(param);  }
```

Здесь нет ссылок на ссылки, так что нет и свертывания ссылок, и это последняя инстанцированная версия [[forward|std::forward]] для этого вызова.

Так как [[rvalue|rvаluе-ссылки]], возвращаемые из функции, определены как [[rvalue|rvalue]], в этом случае [[forward|std::forward]] превратит параметр `fParam` ([[rvalue|lvalue]]) функции `f` в [[rvalue|rvalue]]. Конечным результатом является то, что `rvаluе-аргумент`, переданный функции `f`, будет передан функции `someFunc` как [[rvalue|rvalue]], и это именно то, что и должно было произойти.

Наличие в С++14 [[remove_reference|std::remove_reference_t]] делает возможным реализовать [[forward|std::forward]] немного более лаконично:

```c++
template<typename Т>                          // C++14; в
Т&& forward(remove_reference_t<Т>& param)     // пространстве
{                                             // имен std
	return static_cast<T&&> (param);
}
```

Свертывание ссылок происходит в четырех контекстах. Первый и наиболее распространенный - инстанцирование шаблонов. Второй - генерация типов для переменных [[auto|auto]]. Детали, по сути, те же, что и для шаблонов, поскольку вывод типа для [[auto|аutо­]] переменных, по сути, совпадает с выводом типов для шаблонов ([[Вывод типа auto|см.]]). Рассмотрим еще раз пример, приводившийся ранее в данном разделе:

```c++
template<typename Т>
void func(T&& pararn);

Widget widgetFactory();            // Функция , возвращающая rvalue
Widget w;                          // Переменная (lvalue)
func(w);                           // Вызов функции с lvalue; тип T
								   // представляет собой Widget&
func(widgetFactory());             // Вызов функции с rvalue; тип T
								   // представляет собой Widget
```

Это можно имитировать в виде [[auto|auto]]. Объявление

```c++
auto&& w1 = w;
```

инициализирует `w1` с помощью [[rvalue|lvalue]], выводя, таким образом, для [[auto|auto]] тип `Widget&`. Подстановка `Widget&` вместо [[auto|auto]] в объявление для `w1` дает код со ссылкой на ссылку

```c++
Widget& && w1 = w;
```

который после сворачивания ссылок принимает вид

```c++
Widget& w1 = w;
```

В результате `w1` представляет собой [[rvalue|lvalue-ccылкy]].
С другой стороны, объявление

```c++
Widget&& w2 = widgetFactory();
```

Здесь нет ссылок на ссылки, так что процесс завершен; `w2` представляет собой [[rvalue|rvalue­-ccылкy]].

Теперь мы в состоянии по-настоящему понять [[Отличие универсальных ссылок от rvalue-ссылок|универсальные ссылки]]. Универсальная ссылка не является новой разновидностью ссылок, в действительности это [[rvalue|rvalue-ccылкa]] в контексте, в котором выполняются два условия.

> - Вывод типа отличает [[rvalue|lvalue от rvalue]]. lvalue тип `T` выводится как имеющее тип `Т&`, в то время как rvalue тип `T` дает в качестве выведенного тип `Т`.
> - Происходит свертывание ссылок.

Концепция универсальных ссылок полезна тем, что избавляет вас от необходимости распознавать наличие контекстов сворачивания, мысленного вывода различных типов для [[rvalue|lvalue и rvalue]] и применения правила свертывания ссылок после мысленной подстановки выведенных типов в контексты, в которых они встречаются.

Я говорил, что имеется четыре контекста, но мы рассмотрели только два из них: инстанцирование шаблонов и генерацию типов [[auto|auto]]. Третьим является генерация и использование [[typedef|typedef]] и объявлений псевдонимов ([[Предпочитайте объявление псевдонимов  применению typedef|см.]]. Если во время создания или вычисления [[typedef|typedef]] возникают ссылки на ссылки, для их устранения применяется сворачивание ссылок. Предположим, например, что у нас есть шаблон класса `Widget` с внедренным [[typedef|typedef]] для типа [[rvalue|rvаluе-ссылки]]

```c++
template<typename Т>
class Widget {
	public:
		typedef Т&& RvalueRefToT;
};
```

и предположим, что мы инстанцируем `Widget` с помощью типа [[rvalue|lvаluе-ссылки]]:

```c++
Widget<int&> w;
```

Подстановка `int&` вместо `Т` в шаблоне `Widget` дает нам следующую конструкцию [[typedef|typedef]]:

```c++
typedef int& && RvalueRefToT;
```

Сворачивание ссылок приводит этот код к

```c++
typedef int& RvalueRefToT;
```

Теперь ясно, что имя, которое мы выбрали для [[typedef|typedef]], вероятно, не настолько описательно, как мы надеялись: `RvalueRefToT` представляет собой [[typedef|typedef]] для [[rvalue|lvalue-ccылкu]], когда `Widget` инстанцируется типом [[rvalue|lvаluе-ссылки]].

Последним контекстом, в котором имеет место сворачивание ссылок, является использование [[decltype(auto)|decltуре]]. Если во время анализа типа, включающего [[decltype(auto)|decltуре]], возникает ссылка на ссылку, она устраняется сворачиванием ссылок. ([[decltуре|Информацию о decltype]])

> - Сворачивание ссылок встречается в четырех контекстах: инстанцирование шаблона, генерация типа [[auto|auto]], создание и применение [[typedef|typedef]] и объявлений псевдонимов, и [[decltype(auto)|decltype]].
> - Когда компиляторы генерируют ссылку на ссылку в контексте сворачивания ссылок, результатом становится единственная ссылка. Если любая из исходных ссылок является lvаluе-ссылкой, результатом будет lvalue-ccылкa; в противном случае это будет rvalue-ccылкa.
> - Универсальные ссылки представляют собой rvаluе-ссылки в контекстах, в которых вывод типов отличает lvalue от rvalue и происходит сворачивание ссылок.



