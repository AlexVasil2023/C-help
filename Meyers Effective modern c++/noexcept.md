# Если функции не генерируют исключений, объявляйте их как noexcept

В С++98 спецификации исключений были довольно темпераментными созданиями. От вас требовалось собрать информацию обо всех типах исключений, которые могла генерировать функция, так что при изменении реализации функции могла потребовать изменения и спецификация исключений. Изменение спецификации исключения могло нарушить клиентский код, так как вызывающий код мог зависеть от исходной спецификации исключений. Компиляторы обычно не предлагали никакой помощи в поддержании согласованности между реализациями функций, спецификациями исключений и клиентским кодом. Большинство программистов в конечном итоге сочло, что спецификации исключений в С++98 не стоят затрачиваемых на них усилий и ими лучше не пользоваться вовсе. Во время работы над С++11 было достигнуто согласие, что действительно важная информация о поведении функций в смысле исключений - это информация, может ли вообще такое исключение быть сгенерировано. Либо функция может генерировать исключение, либо гарантируется, что это невозможно. Именно эта дихотомия лежит в основе спецификаций исключений С++11, которые, по сути, заменили спецификации исключений С++98. (Спецификации исключений в стиле С++98 остаются корректными, но не рекомендуются к употреблению.) В С++11 безусловный модификатор `noexcept` применяется к функциям, которые гарантированно не могут генерировать исключения.

Должна ли функция быть объявлена таким образом - вопрос проектирования интерфейса. Поведение генерирующих исключения функций представляет большой интерес для клиентов. Вызывающий код может запросить статус `noexcept` функции, и результат этого запроса может повлиять на безопасность в смысле исключений или эффективность вызывающего кода. Таким образом, является ли функция объявленной как `noexcept`, представляет собой столь же важную часть информации, как и является ли функция-член объявленной как [[const|const]]. Отсутствие объявления функции как `noexcept`, когда вы точно знаете, что она не в состоянии генерировать исключения, - не более чем просто плохая спецификация интерфейса.

Но есть и дополнительный стимул для применения `noexcept` к функциям, которые не генерируют исключений: это позволяет компиляторам генерировать лучший объектный код. Чтобы понять, почему это так, рассмотрим разницу между способами, которыми С++98 и С++11 сообщают о том, что функция не может генерировать исключения. Пусть имеется функция `f`, которая обещает вызывающему коду, что тот никогда не получит исключения. Вот как выглядят два способа это выразить:
```c++
int f(int х) throw ( );    // f не генерирует исключений : С++98
int f(int х) noexcept;     // f не генерирует исключений : C++11
```
Если в о время выполнения некоторое исключение покинет `f`, тем самым будет нарушена спецификация исключений `f`. При спецификации исключений С++98 стек вызовов сворачивается до вызывающего `f` кода, и после некоторых действий, не имеющих значения для данного рассмотрения, выполнение программы прекращается. При спецификации исключений С++11 поведение времени выполнения несколько иное: стек только, возможно, сворачивается перед завершением выполнения программы.

Разница между сворачиванием стека и возможным сворачиванием оказывает на удивление большое влияние на генерацию кода. В случае функции, объявленной как `noexcept`, оптимизаторам не надо ни поддерживать стек в сворачиваемом состоянии, ни гарантировать, что объекты в такой функции будут уничтожены в порядке, обратном созданию, если вдруг такую функцию покинет исключение. Функции со спецификацией `throw( )` не
имеют такой гибкости оптимизации, как и функции без спецификаций вообще. 

Ситуацию можно резюмировать следующим образом:
```c++
RetType function (params) noexcept;      // Наиболее оптимизируема
RetType function (params) throw ( );     // Менее оптимизируема
RetType function (params );              // Менее оптимизируема
```
Этого одного достаточно для того, чтобы объявлять функции, о которых точно известно, что они не генерируют исключений, как `noexcept`.

Для некоторых функций все оказывается еще более интересным. Выдающимся примером являются операции перемещения. Предположим, что у вас имеется код С++98, использующий `std::vector<Widget>`. Объекты типа `Widget` время от времени добавляются в [[vector|std::vector]] с помощью функции [[push_back|push_back]]:
```c++
std::vector<Widget> vw;
...
Widget w;
...                                      // Работа с w
vw.push_back(w);                         // Добавление w к vw
```
Предположим, что этот код отлично работает, и нет никакой необходимости изменять его для С++11. Однако вы хотите воспользоваться тем фактом, что семантика перемещения С++11 может улучшить производительность старого кода при участии типов, допускающих перемещающие операции. Вы уверены, что класс `Widget` такие операции имеет - либо потому, что вы написали их самостоятельно, либо потому, что вы убедились в осуществлении условий для их автоматической генерации ([[Генерация специальных функций-членов|см.]]).

Когда в [[vector|std::vector]] добавляется новый элемент, может оказаться, что в [[vector|std::vector]] для него не хватает места, т.е. что размер [[vector|std::vector]] равен его емкости. Когда такое случается, [[vector|std::vector]] выделяет новый, больший по размеру блок памяти для хранения своих элементов и переносит элементы из старого блока в новый. В С++98 перенос осуществляется с помощью копирования каждого элемента из старой памяти в новую с последующим удалением объекта в старой памяти. Этот подход позволяет [[push_back|push_back]] обеспечить строгую гарантию безопасности исключений: если исключение будет сгенерировано в процессе копирования элементов, то состояние [[vector|std::vector]] останется неизменным, поскольку ни один элемент в старом блоке памяти не будет удален, пока все элементы не будут успешно скопированы в новое место в памяти.

В С++11 естественной оптимизацией была бы замена копирования элементов [[vector|std::vector]] перемещениями. К сожалению, это ведет к риску нарушения строгой гарантии [[push_back|push_back]]. Если `n` элементов перемещены из старого блока памяти в новый и при перемещении `n+1` -го элемента генерируется исключение, операция [[push_back|push_back]] не может быть завершена. Но при этом исходный [[vector|std::vector]] находится в измененном состоянии: `n` его элементов уже перемещены. Восстановление их исходных состояний может оказаться невозможным, поскольку попытка перемещения каждого объекта обратно в исходное местоположение в памяти также может привести к генерации исключения.

Это серьезная проблема, поскольку поведение старого кода может зависеть от строгой гарантии безопасности функции [[push_back|push_back]]. Следовательно, реализации С++11 не могут молча заменить операции копирования внутри [[push_back|push_back]] операциями перемещения, если только точно не известно, что операции перемещения не генерируют исключений. В таком случае замена копирований перемещениями должна быть безопасной, и единственным побочным эффектом этой замены будет повышение быстродействия.

Функция [[push_back|std::vector::push_back]] использует преимущество этой стратегии ("перемести, если можешь, но копируй, если должен"), и это не единственная функция стандартной библиотеки, поступающая таким образом. Другие функции, обеспечивающие строгую гарантию безопасности исключений в С++98 (например, [[reserve|std::vector::reserve]], [[insert|std::deque::insert]] и др.), ведут себя точно так же. Все эти функции заменяют вызовы копирующих операций в С++98 вызовами перемещающих операций в С++11, только если известно, что перемещающие операции не генерируют исключений. Но как функция может узнать, генерирует ли исключения операция перемещения? Ответ очевиден: она
должна проверить, объявлена ли операция как `noexcept`.

Функции [[swap|swap]] являются еще одним случаем, когда модификатор `noexcept` особенно желателен. Функция [[swap|swap]] является ключевым компонентом множества реализаций алгоритмов STL и обычно использует операторы копирующего присваивания. Ее широкое применение делает оптимизацию на основе `noexcept` особенно важной. Интересно, что то, является ли функция [[swap|swap]] в стандартной библиотеке `noexcept`, иногда зависит от того, являются ли таковыми функции [[swap|swap]], определенные пользователями. Например, объявления [[swap|swap]] в стандартной библиотеке для массивов и [[pair|std::pair]] имеют следующий вид:
```c++
template <class Т, size_t N>
void swap(T (&а)[N],                           // См . ниже
	Т (&b) [N]) noexcept (noexcept (swap(*a, *b)));
	
template <class T1, class Т2>
struct pair {
	...
	void swap(pair& р) noexcept (noexcept (swap(first, p.first)) &&
								 noexcept (swap(second, p.second)));
	...
};
```
Эти функции являются условно `noexcept`: являются ли они `noexcept`-функциями, зависит от того, являются ли таковыми инструкции в конструкции `noexcept`. Для двух заданных массивов `Widget`, например, их обмен с помощью функции [[swap|swap]] будет считаться `noexcept` только в том случае, если таковыми будут операции обмена отдельных элементов; т.е. если функция [[swap|swap]] для `Widget` объявлена как `noexcept`. Таким образом, автор функции [[swap|swap]] класса `Widget` определяет, будет ли операция обмена массивов `Widget` рассматриваться как `noexcept`. Это, в свою очередь, определяет, будут ли таковыми другие операции обмена, такие как [[swap|swap]] для массива массивов `Widget`. Аналогично, является ли операция [[swap|swap]] двух объектов [[pair|std::pair]], содержащих `Widget`, не генерирующей исключений, зависит от того, является ли таковой операция [[swap|swap]] для `Widget`. Тот факт, что обмен высокоуровневых структур данных в общем случае может быть `noexcept`, только если таковым является обмен их более низкоуровневых составляющих, должен мотивировать вас объявлять функции [[swap|swap]] как `noexcept` везде, где только это возможно.

Я надеюсь, вы достаточно заинтересовались возможностями оптимизации, которые предоставляет `noexcept`. Увы, должен умерить ваш энтузиазм. Оптимизация важна, но корректность важнее. В начале этого раздела я отмечал, что `noexcept` является частью интерфейса функции, так что вы должны объявлять функцию как `noexcept`, только если вы готовы обеспечивать это свойство в течение длительного срока. Если вы объявите функцию как `noexcept`, а позже измените ваше решение, то ваши перспективы окажутся невеселыми. Удаление `noexcept` из объявления функции (т.е. изменение ее интерфейса) ведет к риску нарушения клиентского кода. Можно также изменить реализацию так, что генерация исключения будет возможна, не меняя при этом (теперь уже некорректную) спецификацию исключений. В этом случае, если исключение попытается покинуть вашу функцию, программа завершит работу. Вы можете также подчиниться существующей реализации, забыв о своем желании ее изменить. Ни один из перечисленных вариантов привлекательным не выглядит.

Дело в том, что большинство функций нейтральны по отношению к исключениям. Такие функции сами по себе исключений не генерируют, но это могут делать функции, вызываемые ими. Когда такое происходит, нейтральная функция позволяет сгенерированному исключению пройти дальше, к обработчику, находящемуся выше по цепочке вызовов. Нейтральные по отношению к исключениям функции никогда не являются `noexcept`, поскольку их могут покидать такие "проходящие" исключения. Поэтому большинство функций совершенно корректно не используют спецификацию `noexcept`.

Некоторые функции, однако, имеют естественные реализации, которые не генерируют никаких исключений, а еще некоторое их количество (в основном операции перемещения и обмена), будучи `noexcept`, могут дать столь значительный выигрыш, что их стоит реализовывать как `noexcept`, насколько это возможно. Когда вы можете уверенно сказать, что за пределы функции не должно выйти ни одно исключение, вы, определенно, должны объявить ее как `noexcept`.

Пожалуйста, обратите внимание на мои слова о том, что некоторые функции имеют естественную реализацию `noexcept`. Изменение реализации функции только для того, чтобы объявить ее как `noexcept`, - это хвост, виляющий собакой. Если простая реализация функции может приводить к исключениям (например, путем вызова функции, которая может сгенерировать исключение), то попытка скрыть это исключение от вызывающего кода (например, перехватывая все исключения и заменяя их кодами состояния или специальными возвращаемыми значениями) усложнит не только реализацию вашей функции, но обычно и код в точке вызова. Например, вызывающая функция, как может оказаться, должна проверять код состояния или наличие специальных возвращаемых значений. Стоимость времени выполнения таких усложнений (например, дополнительных ветвлений, вызовов функций, которые будут влиять на кеши команд, и т.п.) легко может превысить ускорение, которое вы надеялись получить благодаря `noexcept`; кроме того, такой исходный код труднее понимать и поддерживать. Ничего хорошего из этого не получается.

Для некоторых функций отсутствие исключений настолько важно, что они являются `noexcept` по умолчанию. В С++98 считается плохим стилем разрешать генерировать исключения функциям освобождения памяти (т.е. операторам operator delete и operator delete[]) и деструкторам, а в C++11 это правило стиля стало правилом языка. По умолчанию все функции освобождения памяти и все деструкторы - как пользовательские, так и генерируемые компиляторами - неявно являются `noexcept`. Поэтому необходимости явно объявлять их таковыми нет. (Это ничему не повредит, это просто необычно.) Единственная ситуация, когда деструктор не является неявно объявленным как `noexcept` - это когда член-данные класса (включая унаследованные члены и содержащиеся внутри других членов-данных) имеет тип, который явно указывает, что его деструктор может генерировать исключения (например, объявленный как `noexcept(false)`). Такие деструкторы являются редкостью. Их нет в стандартной библиотеке, и если деструктор объекта, используемого стандартной библиотекой (например, как элемент контейнера или переданный алгоритму аргумент), генерирует исключение, поведение программы является неопределенным.

Стоит отметить, что некоторые проектировщики библиотечных интерфейсов различают функции с широкими контрактами от функций с узкими контрактами. Функция с широким контрактом не имеет предусловий. Такая функция может быть вызвана независимо от состояния программы и не накладывает никаких ограничений на аргументы, передаваемые ей вызывающим кодом". Функции с широким контрактом никогда не демонстрируют неопределенного поведения.

Функции без широких контрактов имеют узкие контракты. Если предусловия для таких функций нарушены, их результаты являются неопределенными.

Если вы пишете функцию с широким контрактом и знаете, что ее не покинут никакие исключения, легко следовать совету из данного раздела и объявить ее как `noexcept`. Для функций с узкими контрактами ситуация сложнее. Предположим, например, что вы пишете функцию `f`, принимающую параметр [[string|std::string]], и пусть естественная реализация `f` никогда не генерирует исключений. Это предполагает, что функция `f` должна быть объявлена как `noexcept`.

Предположим теперь, что `f` имеет предусловие: длина ее строкового параметра [[string|std::string]] не должна превышать 32 символа. Если `f` вызывается со строкой [[string|std::string]], длина которой больше 32 символов, поведение будет неопределенным, поскольку нарушение предусловия по определению приводит к неопределенному поведению. Функция `f` не обязана проверять это предусловие, так как функции могут считать свои предусловия выполненными. (За обеспечение выполнения таких предположений отвечает вызывающий код.) Тогда даже при наличии предусловия объявление `f` как `noexcept` выглядит целесообразным:
```c++
void f(const std::string& s) noexcept;  // Предусловие :
										// s.length() <= 32
```
Но предположим, что разработчик `f` решил проверять нарушения предусловия. Такая проверка не обязательна, но она и не запрещена; более того, проверка предусловия может быть полезной, например, в процессе системного тестирования. Отладка сгенерированного исключения в общем случае проще, чем попытки отследить причину неопределенного поведения. Но как следует сообщать о нарушении предусловий, чтобы проверки (или клиентский обработчик ошибок) могли его обнаружить? Простейший подход - генерация исключения "предусловие нарушено": но если `f` объявлена как `noexcept`, это может быть невозможным; генерация исключения приведет к завершению программы. По этой причине разработчики библиотек, различающие широкие и узкие контракты, в общем случае резервируют `noexcept` для функций с широкими контрактами.

Рассмотрим следующий совершенно корректный код:
```c++
void setup();                 // Функции, определенные в другом месте
void cleanup();

void doWork() noexcept
{
	setup();                  // Настройка для выполнения некоторой работы
	...                       // Выполнение работы
	cleanup();                // Очистка после выполнения работы
}
```
Здесь функция `doWork` объявлена как `noexcept`, несмотря на то, что она вызывает функции `setup` и `cleanup` без такого модификатора. Это кажется противоречием, но ведь может быть так, что функции `setup` и `cleanup` документированы как не генерирующие исключений, пусть при этом они и не объявлены как `noexcept`. Для такого их объявления могут иметься некоторые веские причины. Например, они могут быть частью библиотеки, написанной на языке программирования С. (Даже у функций стандартной библиотеки С, перемещенных в пространство имен `std`, отсутствуют спецификации исключений; например, [[strlen|std::strlen]] не объявлена как `noexcept`). Они также могут быть частью стандартной библиотеки С++98, в которой решено не использовать спецификации исключений С++98 и которая еще не пересмотрена на предмет использования возможностей С++11.

Поскольку для функций, объявленных как `noexcept`, имеются законные основания полагаться на код, не имеющий гарантии `noexcept`, С++ допускает существование такого кода, и компиляторы в общем случае не выдают при этом никаких предупреждений о нем.

>
> * `noexcept` является частью интерфейса функции, а это означает, что вызывающий код может зависеть от наличия данного модификатора.
> 
> * Функции, объявленные как `noexcept`, предоставляют большие возможности оптимизации, чем функции без такой спецификации.
>
> * Спецификация `noexcept` имеет особое значение для операций перемещения, обмена, функций освобождения памяти и деструкторов.
> 
> * Большинство функций нейтральны по отношению к исключениям, а не являются `noexcept` - функциями.
>



