
[[#std move C++11|std::move C++11]]
[[#Азы std move и std forward|Азы std::move и std::forward]]

# std::move C++11

Указывает, что переданный объект может быть перемещен из одного объекта в другой без копирования.

Выполнение перемещения – это просто приведение аргумента к rvalue:
```c++
template <typename T> 
typename remove_reference<T>::type&& move(T&& arg) { 
	return static_cast<typename remove_reference<T>::type&&>(arg); 
}
```

# Азы std::move и std::forward
Полезно подойти к `std::move` и `std::forward` с точки зрения того, чего они не делают. `std::move` ничего не перемещает. `std::forward` ничего не передает. Во время выполнения они не делают вообще ничего. Они не генерируют выполнимый код - ни одного байта.

`std::move` и `std::forward` являются всего лишь функциями (на самом деле - шаблонами функций), которые выполняют приведения. `std::move` выполняет безусловное приведение своего аргумента к [[rvalue|rvalue]], в то время как `std::forward` выполняет приведение только при соблюдении определенных условий. Это все. Пояснения приводят к новому множеству вопросов, но, по сути, история на этом завершена.

Чтобы сделать историю более конкретной, рассмотрим пример реализации `std::move` в С++11. Она не полностью соответствует деталям стандарта, но очень близка к этому.

```c++
template<typename Т>                      // В пространстве имен std
typename remove_reference<T>::type&&
move(T&& param)
{
	using ReturnType =                   // Объявление псевдонима
	typename remove_reference<T>::type&&;
	
	return static_cast<ReturnType>(param);
}
```
Я выделил здесь две части кода. Одна - имя функции, потому что спецификация возвращаемого типа достаточно запутанна, и я бы не хотел, чтобы вы в ней заблудились. Вторая - приведение, которое составляет сущность функции. Как вы можете видеть, `std::move` получает ссылку на объект (чтобы быть точным - [[Отличие универсальных ссылок от rvalue-ссылок|универсальную ссылку]]) и возвращает ссылку на тот же объект.

Часть `&&` возвращаемого типа функции предполагает, что `std::move` возвращает [[rvalue|rvalue]]-ccылкy, но, как [[Свертывание ссылок|поясняется]], если тип `T` является [[rvalue|lvаluе]]-ссылкой, `Т&&` становится [[rvalue|lvalue]]-ссылкой. Чтобы этого не произошло, к `Т` применяется [[Предпочитайте объявление псевдонимов  применению typedef|свойство типа]]  [[remove_reference|std::remove_reference]], тем самым обеспечивая применение `"&&"` к типу, не являющемуся ссылкой. Это гарантирует, что `std::move` действительно возвращает [[rvalue|rvаluе]]-ссылку, и это важно, поскольку [[rvalue|rvаluе]]-ссылки, возвращаемые функциями, являются [[rvalue|rvаluе]]. Таким образом, `std::move` приводит свой аргумент к [[rvalue|rvаluе]], и это все, что
она делает.

В качестве небольшого отступления скажем, что `std::move` можно реализовать в С++14 меньшими усилиями. Благодаря [[Знакомство с decltуре|выводу возвращаемого типа функции]] и шаблону псевдонима [[remove_reference|std::remove_reference_t]]  `std::move` можно записать следующим образом:
```c++
template<typename Т>                        // С++14; находится в
decltype(auto) move(T&& param)              // пространстве имен std
[
	using ReturnType = ramove_reference_t<T>&&;
	
	return static_cast<ReturnType>(param);
```

Легче для восприятия, не так ли?

Поскольку `std::move` ничего не делает, кроме приведения своего аргумента к [[rvalue|rvalue]], были предложения дать этому шаблону другое имя, например `rvalue_cast`. Как бы там ни было, у нас имеется имя `std::move`, так что нам важно запомнить, что это имя `std::move` делает и чего не делает. Итак, оно выполняет приведение. И оно ничего не переносит.

Конечно, [[rvalue|rvalue]] являются кандидатами на перемещение, поэтому применение `std::move` для объекта сообщает компилятору, что объект предназначается для перемещения. Вот почему `std::move` имеет такое имя: чтобы легко распознавать объекты, которые могут быть перемещены.

По правде говоря, [[rvalue|rvalue]] обычно являются всего лишь кандидатами для перемещения. Предположим, что вы пишете класс, представляющий аннотации. Конструктор класса получает параметр `std::string`, представляющий аннотацию, и копирует значение параметра в член-данные. С учетом информации вы [[Subtlety#Рассмотрите передачу по значению для копируемых параметров, которые лeгкo перемещаются и всегда копируются|объявляете параметр как передаваемый по значению]]:

```c++
class Annotatioп {
	public:
		explicit Annotation(std::strinq text);     // Параметр
												   // копируемый, так что
											// он передается по значению
};
```

Но конструктору `Annotation` требуется только прочесть значение `text`. Ему не нужно его модифицировать. В соответствии с освященной веками традицией использования [[const|const]] везде, где только можно, вы переписываете свое объявление, делая `text` константой:

```c++
class Annotation{
	public:
		explicit Annotation(const std::string text);
};
```

Чтобы избежать дорогостоящей операции копирования `text` в член-данные, вы оставляете в силе совет из [[Subtlety#Рассмотрите передачу по значению для копируемых параметров, которые лeгкo перемещаются и всегда копируются|раздела]] и применяете `std::move` к `text`, тем самым получая `rvalue`:

```c++
class Annotation{
	public:
		explicit Annotation(const std::string text)
		: value (std::move(text));         // "Перемещение" text в value;
		{...}                              // этот код не делает того,
		...                                // что от него ожидается !
	private:
		std::string value;
};
```

Этот код компилируется. Этот код компонуется. Этот код выполняется. Этот код устанавливает значение члена-данных `value` равным содержимому строки `text`. Единственное, что отличает этот код от идеальной реализации ваших намерений, - то, что `text` не перемещается в `value`, а копируется. Конечно, `text` приводится к `rvalue` с помощью `std::move`, но `text` объявлен как `const std::string`, так что перед приведением `text` являлся [[rvalue|lvalue]] типа `const std::string`, так что результатом приведения является [[rvalue|rvalue]] типа `const std::string`, и на протяжении всех этих действий константность сохраняется.

Рассмотрим, как компиляторы определяют, какой из конструкторов [[string|std::string]] должен быть вызван. Есть две возможности:

```c++
class string {              // std::string в действительности представляет
	public:                 // собой typedef для std::basic_string<char>
		...
		string(const string& rhs);        // Копирующий конструктор
		string(string&& rhs);             // Перемещающий конструктор
};
```

В списке инициализации членов конструктора `Annotation` результатом `std::move(text)` является [[rvalue|rvalue]] типа `const std::string`. Это [[rvalue|rvalue]] нельзя передать перемещающему конструктору [[string|std::string]], поскольку перемещающий конструктор получает [[rvalue|rvalue]]-ссылку на неконстантную [[string|std::string]]. Однако это [[rvalue|rvalue]] может быть передано копирующему конструктору, поскольку [[rvalue|lvalue]]-ccылкy на [[const|const]] разрешено связывать с константным [[rvalue|rvalue]]. Таким образом, инициализация члена использует копирующий конструктор [[string|std::string]], несмотря на то что `text` был приведен к [[rvalue|rvalue]]! Такое поведение имеет важное значение для поддержания корректности [[const|const]]. Перемещение значения из объекта в общем случае модифицирует этот объект, так что язык программирования должен не разрешать передавать константные объекты в функции (такие, как перемещающие конструкторы), которые могут их модифицировать.

Из этого примера следует извлечь два урока. Во-первых, не объявляйте объекты как константные, если хотите иметь возможность выполнять перемещение из них. Запрос перемещения к константным объектам молча трансформируется в копирующие операции. Во-вторых, `std::move` не только ничего не перемещает самостоятельно, но даже не гарантирует, что приведенный этой функцией объект будет иметь право быть перемещенным. Единственное, что точно известно о результате применения `std::move` к объекту - это то, что он является [[rvalue|rvalue]].

История с `std::forward` подобна истории с `std::move`, но тогда как `std::move` выполняет безоговорочное приведение своего аргумента в [[rvalue|rvalue]], `std::forward` делает это только при определенных условиях. `std::forward` является условным приведением. Чтобы понять, когда приведение выполняется, а когда нет, вспомним, как обычно используется `std::forward`. Наиболее распространенным сценарием является тот, когда шаблон функции получает параметр, представляющий собой универсальную ссылку, и который передается другой функции:

```c++
void process(const Widget& lvalArg);      // Обработка lvalue
void process(Widget&& rvalArg);           // Обработка rvalue

template<typename Т>                      // шаблон, передающий
void logAndProcess(T&& param)             // param на обработку
{
	auto now =                            // Получает текущее время
		std::chrono::system_clock::now();
		
	makeLogEntry("Bызoв 'process'", now);
	process(std::forward<T>(param));
}
```

Рассмотрим два вызова `logAndProcess`, один с [[rvalue|lvalue]], а другой - с [[rvalue|rvalue]]:

```c++
Widget w;

logAndProcess(w);                           // Вызов с lvalue
logAndProcess(std::move(w));                // Вызов с rvalue
```

В функции `logAndProcess` параметр `param` передается функции `process`. Функция `process` перегружена для [[rvalue|lvalue]] и [[rvalue|rvalue]]. Вызывая `logAndProcess` с [[rvalue|lvalue]], мы, естественно, ожидаем, что [[lvalue|lvalue]] будет передано функции `process` как [[rvalue|lvalue]], а вызывая `logAndProcess` с [[rvalue|rvalue]], мы ожидаем, что будет вызвана перегрузка `process` для [[rvalue|rvalue]].

Однако `param`, как и все параметры функций, является [[rvalue|lvalue]]. Каждый вызов `process` внутри `logAndProcess` будет, таким образом, вызывать перегрузку `process` для [[rvalue|lvalue]]. Для предотвращения такого поведения нам нужен механизм для приведения `param` к [[rvalue|rvalue]] тогда и только тогда, когда аргумент, которым инициализируется `param` аргумент, переданный `logAndProcess`, был [[rvalue|rvalue]]. Именно этим и занимается `std::forward`. Вот почему `std::forward` представляет собой условное приведение: эта функция выполняет приведение к [[rvalue|rvalue]] только тогда, когда ее аргумент инициализирован [[rvalue|rvalue]].

Вы можете удивиться, откуда `std::forward` может знать, был ли ее аргумент инициализирован [[rvalue|rvalue]]? Например, как в приведенном выше коде `std::forward` может сказать, был ли `param` инициализирован с помощью [[rvalue|lvalue]] или [[rvalue|rvalue]]? Краткий ответ заключается в том, что эта информация кодируется в параметре `Т` шаблона `logAndProcess`. Этот параметр передается `std::forward`, которая восстанавливает закодированную информацию. [[Свертывание ссылок|Детальное описание того, как работает данный механизм]].

Учитывая, что и `std::move`, и `std::forward` сводятся к приведению и единственная разница между ними лишь в том, что `std::move` всегда выполняет приведение, в то время как `std::forward` только иногда, вы можете спросить, не можем ли мы обойтись без `std::move` и просто использовать везде `std::forward`. С чисто технической точки зрения ответ утвердительный: `std::forward` может сделать все. Необходимости в `std::move` нет. Конечно, ни одна из этих функций не является действительно необходимой, потому что мы могли бы просто вручную написать требуемое приведение, но, я надеюсь, мы сойдемся во мнении, что это будет как минимум некрасиво.

Привлекательными сторонами `std::move` являются удобство, снижение вероятности ошибок и большая ясность. Рассмотрим класс, в котором мы хотели бы отслеживать количество вызовов перемещающего конструктора. Все, что нам надо, - это счетчик, объявленный как `static`, который увеличивался бы при каждом вызове перемещающего конструктора. Полагая, что единственными нестатическими данными класса является `std::string`, вот как выглядит обычный (т.е. использующий `std::move`) способ реализации перемещающего конструктора:

```c++
class Widget{
	public:
		Widget(Widget&& rhs)
			:s(std::move(rhs.s))
		{ ++moveCtorCalls; }

	private :
		static std::size_t moveCtorCalls;
		std::string s;
};
```

Чтобы реализовать то же поведение с помощью `std::forward`, код должен был бы выглядеть следующим образом:

```c++
class Widget {
	public:
		Widget(Widget&& rhs)                      // Безусловная,
			:s(std::forward<std::string>(rhs.s))  // нежела тельная
			{ ++moveCtorCalls;}                   // реализация
		
		...
};
```
Заметим сначала, что `std::move` требует только аргумент функции (`rhs.s`) , в то время как `std::forward` требует как аргумент функции (`rhs.s`) , так и аргумент типа шаблона ([[string|std::string]]) . Затем обратим внимание на то, что тип, который мы передаем [[forward|std::forward]], должен быть не ссылочным, поскольку таково [[Свертывание ссылок|соглашение по кодированию]], что передаваемый аргумент является [[rvalue|rvalue]]. Вместе это означает, что `std::move` требует меньшего ввода текста по сравнению с `std::forward` и избавляет от проблем передачи типа аргумента, указывающего, что передаваемый аргумент является [[rvalue|rvalue]]. `std::move` устраняет также возможность передачи неверного типа (например, `std::string&`, что привело бы к тому, что член-данные `s` был бы создан с помощью копирования, а не перемещения).

Что еще более важно, так это то, что использование `std::move` выполняет безусловное приведение к [[rvalue|rvalue]], в то время как использование `std::forward` означает приведение к [[rvalue|rvalue]] только ссылок, связанных с [[rvalue|rvalue]]. Это два совершенно различных действия. Первое из них обычно настраивает перемещение, в то время как второе просто передает объект другой функции способом, сохраняющим исходную характеристику объекта ([[rvalue|lvalue]] или [[rvalue|rvalue]]). Поскольку эти действия совершенно различны, наличие двух разных функций (и разных имен функций) является преимуществом, позволяющим их различать.

> - `std::move` выполняет безусловное приведение к [[rvalue|rvalue]]. Сама по себе эта функция не перемещает ничего.
> 
> - `std::forward` приводит свой аргумент к [[rvalue|rvalue]] только тогда, когда этот аргумент связан с [[rvalue|rvalue]].
> 
> - Ни `std::move`, ни `std::forward` не выполняют никаких действий времени выполнения.






