# Вывод типа шаблона

можно рассматривать шаблон функции как имеющий следующий вид:
```c++
template<typename Т>
void f(ParamType param);
```
Вызов может выглядеть следующим образом:
```c++
f(expr);     //Вызов f с некоторым выражением
```
В процессе компиляции компилятор использует [[expr|expr]] для вывода двух типов: типа **Т** и типа **ParamType**. Эти типы зачастую различны, поскольку **Pa ramType** часто содержит "украшения", например [[const|const]] или квалификаторы ссылки. Например, если шаблон объявлен как
```c++
ternplate<typename Т>
void f(const Т& param);   //ParamType - const Т&
```
и мы осуществляем вызов
```c++
int хО;
f (х);                  // Вызов f с параметром int
```
то **Т** выводится как `int`, а **ParamType** как `const int &`.
Вполне естественно ожидать, что тип, выведенный для **Т** , тот же, что и тип переданного функции аргумента, т.е. что **Т** это тип выражения [[expr|expr]]. В приведенном выше при­мере это так: `х` значение типа `int` и **Т** выводится как `int`. Но вывод не всегда работает таким образом. Тип, выведенный для **T**, зависит не только от типа [[expr|expr]], но и от вида **ParamType**. Существует три случая.
> 1. **ParamType** представляет собой указатель или ссылку, но не универсальную ссылку. (Универсальные ссылки не являются ни ссылками lvalue, ни ссылками rvalue.)
> 2. **ParamType** является универсальной ссылкой.
> 3. **ParamType** не является ни указателем, ни ссылкой.

Следовательно, нам надо рассмотреть три сценария вывода. Каждый из них основан на нашем общем виде шаблонов и их вызова:
```c++
ternplate<typename Т>
void f(ParamType pararn);

f (expr);                //Вывод Т и ParamType из expr
```
## Случай 1. ParamType является указателем или ссылкой, но не универсальной ссылкой
Простейшая ситуация - когда **ParamType** является ссылочным типом или типом указателя, но не универсальной ссылкой. В этом случае вывод типа работает следующим образом.
1. Если типом [[expr|expr]] является ссылка, ссылочная часть игнорируется.
2. Затем выполняется сопоставление типа [[expr|expr]] с **ParamType** для определения **T**.
Например, если у нас имеются шаблон
```c++
template<typename Т>
void f(T& param);        // param представляет собой ссыпку
```
и объявления переменных
```c++
int х = 27 ;                // х имеет тип int
const int сх = х;           // сх имеет тип const int
const int& rx = х;          // rx является ссыпкой на х как на const int
```
то выводимые типы для **param** и **Т** в различных выводах будут следующими:
```c++
f(х);                       // Т - int, тип param - int&
f(cx);                      // Т - const int, тип param - coпst int&
f(rx);                      // Т - const int, тип param - coпst int&
```
Во втором и третьем вызовах обратите внимание, что, поскольку **сх** и **rx** объявлены как константные значения, **Т** выводится как `const int`, тем самым приводя к типу параметра `const int &`. Это важно для вызывающего кода. Передавая константный объект параметру-ссылке, он ожидает, что объект останется неизменным, т.е. что параметр будет представлять собой ссылку на `const` . Вот почему передача константного объекта в шаблон, получающий параметр **Т&** безопасна: константность объекта становится частью выведенного для **Т** типа.
В третьем примере обратите внимание, что несмотря на то, что типом **rx** является ссылка, тип **T** выводится как не ссылочный. Вот почему при выводе типа игнорируется
"ссылочность" **rx**.
Все эти примеры показывают ссылочные параметры, являющиеся [[rvalue|lvalue]], но вывод типа точно так же работает и для ссылочных параметров [[rvalue|rvalue]]. Конечно, [[rvalue|rvalue]] аргументы могут передаваться только ссылочным параметрам, являющимся [[rvalue|rvalue]], но это ограничение никак не влияет на вывод типов.
Если мы изменим тип параметра **f** с **Т&** на **const Т&**, произойдут небольшие изменения, но ничего удивительного не случится. Константность **сх** и **rx** продолжает соблюдаться, но поскольку теперь мы считаем, что **param** является ссылкой на `const`, `const` как часть выводимого типа **T** не требуется:
```c++
template<typename Т>
void f(const Т& param) ;    // param является ссыпкой на const

int х = 27 ;                // х имеет тип int
const int сх = х;           // сх имеет тип const int
const int& rx = х;          // rx является ссыпкой на х как на const int

f(х);                       // Т - const int, тип param - const int&
f(cx);                      // Т - const int, тип param - coпst int&
f(rx);                      // Т - const int, тип param - coпst int&
```
Как и ранее, "ссылочность" **rx** при выводе типа игнорируется.
Если бы **param** был указателем (или указателем на `const`), а не ссылкой, все бы работало, по сути, точно так же:
```c++
template<typename Т>
void f(T* param);           // Теперь param является указателем

int х = 27 ;                //Как и ранее
const int *рх = &х ;        // рх - указатель на х, как на const int

f(&х);                      //Т - iпt, тип param - int*
f(рх);                      //Т - const int, тип param - const int*
```
Сейчас вы можете обнаружить, что давно усердно зеваете, потому что все это очень скучно, правила вывода типов в С++ работают так естественно для ссылок и указателей, что все просто очевидно! Это именно то, что вы хотите от системы вывода типов.
## Случай 2. ParamType является универсальной ссылкой
Все становится менее очевидным в случае шаблонов, принимающих параметры, яв­ляющиеся универсальными ссылками. Такие параметры объявляются как ссылки **rvalue** (т.е. в шаблоне функции, принимающем параметр типа **T**, объявленным типом универ­сальной ссылки является **Т&&**), но ведут себя иначе при передаче арrументов, являющих­ся **lvalue**. 
* Если [[expr|expr]] представляет собой **lvalue**, как **Т**, так и **ParamType** выводятся как **lvаluе**  ссылки. Это вдвойне необычно. Во-первых, это единственная ситуация в выводе типа шаблона, когда **Т** выводится как ссылка. Во-вторых, хотя **ParamType** объяв­лен с использованием синтаксиса **rvаluе-ссылки**, его выводимым типом является **lvаluе-ссылка**.
* Если [[expr|expr]] представляет собой **rvalue**, применяются "обычные" правила (из случая l).
Примеры
```c++
template<typename Т>
void f(T&& param);             // param является универсальной ссылкой

int х = 27;                    // Как и ранее
const int сх = x;              // Как и ранее

const int& rx = х;             // Как и ранее
f(х);                          //х - lvalue, так что Т - iпt&
                               // #тип pararn также является iпt&
f(сх);                         // сх - lvalue, так что Т - const iпt & ,
                               // тип pararn также является coпst iпt&
f(rx) ;                        // rx - lvalue, так что Т - const iпt&,
                               // тип pararn также является const iпt&
f(27);                         // 27 - rvalue, так что Т - int,
                               // следовательно, тип param - iпt&&
```
Ключевым моментом является то, что правила вывода типов для параметров, являющихся универсальными ссылками, отличаются от таковых для параметров, являющихся **lvalue** или **rvаluе-ссылками**. В частности, когда используются универсальные ссылки, вывод типов различает аргументы, являющиеся **lvalue**, и аргументы, являющиеся **rvalue**. Этого никогда не происходит для неуниверсальных ссылок.
## Случай 3. ParamType не является ни указателем, ни ссылкой
Когда `ParamType` не является ни указателем, ни ссылкой, мы имеем дело с передачей по значению:
```c++
ternplate<typeпarne Т>
void f(T pararn) ;               //param передается по значению
```
Это означает, что `param` будет копией переданного функции - совершенно новым объектом. Тот факт, что `param` будет совершенно новым объектом, приводит к правилам, которые регулируют вывод **Т** из [[expr|expr]].
* Как и ранее, если типом [[expr|expr]] является ссылка, ссылочная часть игнорируется.
* Если после отбрасывания ссылочной части [[expr|expr]] является [[const|const]], это также игнорируется. Игнорируется и модификатор [[volatile|volatile]] (объекты volatile являются редкостью и в общем случае используются только при реализации драйверов устройств.)
Таким образом, получаем следующее:
```c++
int х = 27;                       // Как и ранее
const int сх = х;                 // Как и ранее
const int& rx = х;                // Как и ранее

f(х);                             // Типами и Т, и pararn являются int
f(сх);                            // Типами и Т, и pararn вновь являются iпt
f(rx);                            // Типами и Т, и param опять являются iпt
```
Обратите внимание, что даже несмотря на то, что `сх` и `rx` представляют константные значения, `param` не является [[const|coпst]]. Это имеет смысл `param` представляет собой объект, который полностью независим от **сх** и **rx**, это копия **сх** или **rx**. Тот факт, что **сх** и **rx** не могут быть модифицированы, ничего не говорит о том, может ли быть модифициро­ван `param`. Вот почему константность [[expr|expr]] (как и [[volatile|volatile]], если таковой модификатор присутствует) игнорируется при выводе типа `param`: то, что [[expr|expr]] не может быть модифицировано, не означает, что таковой должна быть и его копия.
Важно понимать, что [[const|coпst]] (и [[volatile|volatile]]) игнорируются только параметрами, переда­ваемыми по значению. Как мы уже видели, для параметров, которые являются ссылками или указателями на **const**, константность [[expr|expr]] при выводе типа сохраняется. Но рас­смотрим случай, когда [[expr|expr]] представляет собой [[const|const]] -указатель на константный объект, а передача осуществляется по значению:
```c++
template<typename Т>
void f(Т param);                   // param передается по значению

const char* const ptr =            // ptr - константный указатель на
           "Fun with pointers";    // константный объект

f(ptr);                            // Передача arg типа const char* const
```
Здесь [[const|const]] справа от звездочки объявляет `ptr` константным: `ptr` не может ни указывать на другое место в памяти, ни быть обнуленным. ([[const|const]] слева от звездочки гласит, что `ptr` указывает на то, что (строка символов) является [[const|const]], а следовательно, не может быть изменено.) Когда `ptr` передается в функцию `f`, биты, составляющие указатель, копи­руются в `param`. Как таковой сам указатель (`ptr`) будет передан по значению. В соответ­ствии с правилом вывода типа при передаче параметров по значению константность `ptr` будет проигнорирована, а выведенным для `param` типом будет [[const|const]] `char*`, т.е. изменяемый указатель на константную строку символов. Константность того, на что указывает `ptr`, в процессе вывода типа сохраняется, но константность самого `ptr` игнорируется при создании нового указателя `param`.
# Аргументы - массивы





























