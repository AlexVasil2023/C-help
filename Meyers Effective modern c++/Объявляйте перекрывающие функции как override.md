#override
# Объявляйте перекрывающие функции как override

Мир объектно-ориентированного программирования С++ вращается вокруг классов, наследования и виртуальных функций. Среди наиболее фундаментальных идей этого мира - та, что реализации виртуальных функций в производных классах перекрывают (`override`) реализации их коллег в базовых классах. Понимание того, насколько легко все может пойти наперекосяк при перекрытии функций, попросту обескураживает.

Очень часто термин "перекрытие" путают с термином "перегрузка", хотя они совершенно не связаны друг с другом. Перекрытие виртуальной функции - это то, что делает возможным вызов функции производного класса через интерфейс базового класса:
```c++
class Base {
	public :
		virtual void doWork();                // Виртуальная функция
											  // базового класса
);

class Derived : public Base {
	public:
		virtual void doWork();                // Перекрывает Base::doWork
											  // Ключевое слово virtual
											  // здесь не обязательное
};

std::unique_ptr<Base>upb =                   // Указатель на базовый класс
	std::make_unique<Derived>();             // указывает на объект
											 // производного класса ;
											 // см. std::make_unique
											 // в разделе 4.4
											 
upb->doWork();                             // Вызов doWork через указатель
										   // на базовый класс ; вызывается
										   // функция производного класса
```
Для осуществления перекрытия требуется выполнение нескольких условий.
> - Функция базового класса должна быть виртуальной.
> 
> - Имена функций в базовом и производном классах должны быть одинаковыми (за исключением деструктора).
> 
> - Типы параметров функций в базовом и производном классах должны быть одинаковыми.
> 
> - Константность функций в базовом и производном классах должна совпадать.
> 
> - Возвращаемые типы и спецификации исключений функций в базовом и производном классах должны быть совместимыми.

К этим ограничениям, являющимся частью С++98, С++11 добавляет еще одно.
> - Ссылочные квалификаторы функций должны быть идентичными. Ссылочные квалификаторы функции-члена являются одной из менее известных возможностей С++11, так что не удивляйтесь, если вы до сих пор ничего о них не слышали. Они позволяют ограничить использование функции-члена только объектами [[rvalue|lvalue]] или только объектами [[rvalue|rvalue]]. Для использования этих квалификаторов функции-члены не обязаны быть виртуальными.

```c++
class Widget {
	public:
		...
		void doWork() &;         // Эта версия doWork применима, только
								 // если *this представляет собой lvalue
								 
		void doWork() &&;        // Эта версия doWork применима , только
								 // если * this представляет собой rvalue
};

...
Widget makeWidget();             // Фабричная функция (возвращает rvalue)
Widget w;                        // Обычный объект (lvalue)
...
w.doWork();                      // Вызов Widget::doWork для lvalue
                                 // (т.е. Widget::doWork & )

makeWidget().doWork();           // Вызов Widget::doWork для rvalue
                                 // (т.е. Widget::doWork && )
```
Если виртуальная функция в базовом классе имеет ссылочный квалификатор, то производный класс, перекрывающий эту функцию, должен иметь тот же ссылочный квалификатор. Если это не так, объявленные функции все еще остаются в производном классе, но они ничего не перекрывают в базовом классе.

Все эти требования к перекрытию означают, что маленькие ошибки могут привести к большим последствиям. Код, содержащий ошибки перекрытия, обычно корректен, но делает совсем те то, что хотел программист. Поэтому в данном случае нельзя полагаться на уведомления компиляторов о том, что вы что-то делаете неверно. Например, приведенный далее код является абсолютно законным и, на первый взгляд, выглядит разумным, но в нем нет перекрытия виртуальной функции - нет ни одной функции производного класса, связанной с функцией базового класса. Сможете ли вы самостоятельно определить, в чем заключается проблема в каждом конкретном случае (т.е. почему каждая функция производного класса не переопределяет функцию базового класса с тем же именем)?
```c++
class Base {
	public :
		virtual void mfl() const;
		virtual void mf2(int х);
		virtual void mf3() &;
		void mf4() const;
};

class Derived : public Base {
	public :
		virtual void mf1();
		virtual void mf2(unsigned int х);
		virtual void mf3() &&;
		void mf4() const;
);
```

> - `mf1` объявлена как [[const|const]] в классе `Base`, но в классе `Derived` этого модификатора нет.
>
> - `mf2` получает аргумент типа `int` в классе `Base`, но в классе `Derived` она получает аргумент типа `unsigned int`.
>
> - `mfЗ` определена с квалификатором [[rvalue|lvalue]] в классе `Base` и с квалификатором [[rvalue|rvalue]] в классе `Derived`.
>
> - `mf4` не объявлена в классе `Base` как [[virtual|virtual]].

Вы можете подумать "На практике все это вызовет предупреждения компилятора, так что мне не о чем беспокоиться': Может быть, это и так. А может быть, и не так. В двух из проверенных мною компиляторах код был принят без единой жалобы - в режиме, когда все предупреждения были включены. (Другие компиляторы выдавали предупреждения о некоторых из проблем, но не обо всех одновременно.)

Поскольку очень важно правильно объявить производный класс перекрывающим, но при этом очень легко ошибиться, C++11 дает вам возможность явно указать, что функ­ция производного класса предназначена для того, чтобы перекрывать функцию из базового класса: ее можно объявить как `override`. Применяя это ключевое слово к приведенному выше примеру, мы получим следующий производный класс:
```c++
class Derived : public Base {
	public :
		virtual void mf1() override;
		virtual void mf2(unsigned int х) override;
		virtual void mf3() && override;
		void mf4() const override;
);
```
Этот код компилироваться не будет, поскольку теперь компиляторы знают о том, что эти функции предназначены для перекрытия функций из базового класса, а потому могут определить наличие описанных нами проблем. Это именно то, что нам надо, и потому вы должны объявлять все свои перекрывающие функции как `override`.

Код с использованием `override`, который будет успешно скомпилирован, выглядит следующим образом (в предположении, что нашей целью является перекрытие функциями в классе `Derived` всех виртуальных функций в классе `Base`) :
```c++
class Base {
	public :
		virtual void mfl() const;
		virtual void mf2(int х);
		virtual void mf3() &;
		virtual void mf4() const;
};

class Derived : public Base {
	public :
		virtual void mf1() const override;
		virtual void mf2(int х) override;
		virtual void mf3() & override;
		virtual void mf4() const override;  // Слово virtual не мешает, но
);                                          // и не является обязательным
```
Обратите внимание, что в этом примере часть работы состояла в том, чтобы объявить `mf4` в классе `Base` как виртуальную функцию. Большинство ошибок, связанных с перекрытием, совершаются в производном классе, но можно сделать такую ошибку и в базовом классе.

Стратегия использования ключевого слова `override` во всех перекрытиях производного класса способна на большее, чем просто позволить компиляторам сообщать, когда функции, которые должны быть перекрытиями, ничего не перекрывают. Они также могут помочь вам оценить последствия предполагаемого изменения сигнатуры виртуальной функции в базовом классе. Если производные классы везде используют `override`, вы можете просто изменить сигнатуру и перекомпилировать систему. Вы увидите, какие повреждения нанесли своей системе (т.е. сколько классов перестали компилироваться), и после этого сможете принять решение, стоит ли изменение сигнатуры таких хлопот. Без `override` вы должны были бы надеяться на наличие достаточно всеобъемлющих тестов, поскольку, как мы видели, виртуальные функции, которые предназначены перекрывать функции базового класса, но не делают этого, не приводят ни к какой диагностике со стороны компилятора.

В С++ всегда имелись ключевые слова, но С++11 вводит два контекстных ключевых слова (`contextual keywords`) `override` и [[final|final]]. Эти ключевые слова являются зарезервированными, но только в некоторых контекстах. В случае `override` оно имеет зарезервированное значение только тогда, когда находится в конце объявления функции-члена. Это значит, что если у вас есть старый код, который уже использовал имя `override`, его не надо изменять при переходе к С++11:
```c++
class Warning               // Потенциально старый класс из С++98
	public :
		...
		void override();    // Корректно как в С++98, так и в C++11
		                    // (с тем же смыслом)
};
```
Это все, что следует сказать об `override`, но это не все, что следует сказать о ссылочных квалификаторах функций-членов. Я обещал, что поговорю о них позже, и вот сейчас как раз и настало это "позже".

Если мы хотим написать функцию, которая принимает только аргументы, являющиеся [[rvalue|lvalue]], мы объявляем параметр, который представляет собой неконстантную [[rvalue|lvalue]]-ссылку:
```c++
void doSomething(Widget& w);     // Принимает только lvalue Widget
```
Если же мы хотим написать функцию, которая принимает только аргументы, являющиеся [[rvalue|rvalue]], мы объявляем параметр, который представляет собой [[rvalue|rvalue]]-ccылкy:
```c++
void doSomething(Widget&& w);     // Принимает только rvalue Widget
```
Ссылочные квалификаторы функции-члена позволяют проводить такое же различие для объектов, функции-члены которых вызываются, т.е. `*this`. Это точный аналог модификатора [[const|const]] в конце объявления функции-члена, который указывает, что объект, для которого вызывается данная функция-член (т.е. `*this`), является [[const|const]].

Необходимость в функциях-членах со ссылочными квалификаторами нужна не так уж часто, но может и возникнуть. Предположим, например, что наш класс `Widget` имеет член-данные [[vector|std::vector]], и мы предлагаем функцию доступа, которая обеспечивает клиентам к нему непосредственный доступ:
```c++
class Widget {
	public:
		using DataType = std::vector<double>; 
		
		DataType& data () { return values; }
		...
	
	private:
		DataType values;
};
```
Вряд ли это наиболее инкапсулированный дизайн, который видел свет, но оставим этот вопрос в стороне и рассмотрим, что происходит в следующем клиентском коде:
```c++
Widget w;
auto valsl = w.data();          // Копирует w.values в valsl
```
Возвращаемый тип `Widget::data` представляет собой [[rvalue|lvalue]]-ссылку (чтобы быть точным - `std::vector<double>&`), а поскольку [[rvalue|lvalue]]-ссылки представляют собой [[rvalue|lvalue]], мы инициализируем `valsl` из [[rvalue|lvalue]]. Таким образом, `valsl` создается копирующим конструктором из `w.values`, как и утверждает комментарий.

Теперь предположим, что у нас имеется фабричная функция, которая создает `Widget`:
```c++
Widget makeWidget();
```
и мы хотим инициализировать переменную с помощью [[vector|std::vector]] в `Widget`, возвращенном из `makeWidget`:
```c++
auto vals2 = makeWidget().data();        // Копирование значений в
                                         // Widget в vals2
```
И вновь `Widgets::data` возвращает [[rvalue|lvalue]]-ссылку, и вновь [[rvalue|lvalue]]-ссылка представляет собой [[rvalue|lvalue]], так что наш новый объект (`vals2`) опять является копией, построенной из  `values` в объекте `Widget`. Однако в этот раз `Widget` представляет собой временный объект, возвращенный из `makeWidget` (т.е. представляет собой [[rvalue|rvalue]]), так что копирование в него [[vector|std::vector]] представляет собой напрасную трату времени. Предпочтительнее выполнить перемещение, но, поскольку `data` возвращается как [[rvalue|lvalue]]-ссылка, правила С++ требуют, чтобы компиляторы генерировали код для копирования. (Имеется некоторый маневр для оптимизации на основе правила "как если бы", но было бы глупо полагаться та то, что ваш компилятор найдет способ им воспользоваться.)

Нам необходим способ указать, что, когда `data` вызывается для `Widget`, являющегося [[rvalue|rvalue]], результат также будет представлять собой [[rvalue|rvalue]]. Использование ссылочных квалификаторов для перегрузки `data` для `Widget`, являющихся [[rvalue|lvalue]] и [[rvalue|rvalue]], делает это возможным:
```c++
class Widget
	public :
		using DataType = std::vector<double>;
		
		DataType& data()&                   // Для lvalue Widget,
			{ return values; }              // возвращает lvalue
		
		DataType&& data()&&                 // Для rvalue Widget,
			{ return std::move(values); }   // возвращает rvalue

		...

	private :
		DataType values;
};
```
Обратите внимание на разные возвращаемые типы перегрузок `data`. Перегрузка для [[rvalue|lvalue]]-ссылки возвращает [[rvalue|lvalue]]-ccылкy (т.е. [[rvalue|lvalue]]), а перегрузка для [[rvalue|rvalue]]-ссылки возвращает [[rvalue|rvalue]]-ccылкy (которая, как возвращаемый тип функции, является [[rvalue|rvalue]]). Это означает, что клиентский код ведет теперь себя так, как мы и хотели:
```c++
auto vals1 = w.data();               // Вызывает lvаluе - перегрузку
                                     // Widget::data, vals1
                                     // создается копированием

auto vals2 = makeWidget().data();    // Вызывает rvаluе - перегрузку
                                     // Widget::data, vals2
                                     // создается перемещением
```
Это, конечно, хорошо, но не позвольте теплому сиянию этого хэппи-энда отвлечь вас от истинной цели этого раздела. Эта цель в том, чтобы убедить вас, что всякий раз, когда вы объявляете в производном классе функцию, предназначенную для перекрытия виртуальной функции базового класса, вы не забывали делать это с использованием ключевого слова `override`.

Кстати, если функция-член использует ссылочный квалификатор, все перегрузки этой функции также должны использовать его. Это связано с тем, что перегрузки без этих квалификаторов могут вызываться как для объектов [[rvalue|lvalue]], так и для объектов [[rvalue|rvalue]]. Такие перегрузки будут конкурировать с перегрузками, имеющими ссылочные квалификаторы, так что все вызовы функции будут неоднозначными.

> - Объявляйте перекрывающие функции как `override`.
>
> - Ссылочные квалификаторы функции-члена позволяют по-разному рассматри­вать [[rvalue|lvalue]]- и [[rvalue|rvalue]]-объекты (`*this`).


