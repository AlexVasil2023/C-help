# Предпочитайте итераторы const_iterator итераторам iterator

 Итераторы `const_iterator` представляют собой SТL-эквивалент указателя на [[const|const]]. Они указывают на значения, которые не могут быть изменены. Стандартная практика применения [[const|const]] там, где это только возможно, требует применения `const_iterator` везде, где нужен итератор, но не требуется изменять то, на что этот итератор указывает.
 
Это верно как для С++98, так и для C++11, но в С++98 поддержка `const_iterator` носит половинчатый характер. Такие итераторы не так легко создавать, а если у вас уже имеется такой итератор, его использование весьма ограничено. Предположим, например, что вы хотите выполнить в `std::vector<int>` поиск первого встречающегося значения `1983` (год, когда название языка программирования "С с классами" сменилось на С++), а затем вставить в это место значение `1998` (год принятия первого ISО-стандарта С++). Если в векторе нет значения `1983`, вставка выполняется в конец вектора. При использовании итераторов `iterator` в С++98 сделать описанное просто:
```c++
std::vector<int>values;

std::vector<int>::iterator it = 
			std::find(values.begin(), values.end(), 1983);
values.insert(it, 1998);
```
Но `iterator` - в данном случае не совсем верный выбор, поскольку этот код не изменяет объект, на который указывает `iterator`. Переделка кода для использования `const_iterator` должна быть тривиальной задачей", но не в С++98. Вот один из подходов, концептуально надежный, но все еще не совсем корректный:
```c++
typedef std::vector<int>::iterator IterT;
std::vector<int>::const_iterator ConstiterT;

std::vector<int>values;

ConstiterT ci = 
       std::find(static_cast<ConstiterТ>(values.begin()),
			static_cast<ConstiterT>(values.end()),
			1983);

values.insert(static_cast<IterТ>(ci), 1998);   // Может не
                                               // компилироваться!
```
Конструкции [[typedef|typedef]] применять, конечно, необязательно, но они облегчают написание приведений. (Если вы удивляетесь, почему я использую [[typedef|typedef]], а не следую собственному совету из [[Предпочитайте объявление псевдонимов  применению typedef|см.]] и не применяю объявлений псевдонимов, то я напомню, что в этом примере демонстрируется код С++98, а объявления псевдонимов - новая возможность в С++11.)

Приведения в вызове [[find|std::find]] присутствуют потому, что `values` является неконстантным контейнером, а в С++98 нет простого способа получить константный итератор из неконстантного контейнера. Приведения не являются строго необходимыми, так как можно получить `const_iterator` другими способами (например, вы можете связать `values` с переменной, являющейся ссылкой на константный объект, а затем использовать ее в своем коде вместо values), но к какому бы способу вы ни прибегли, процесс получения `const_iterator`, указывающего на элементы неконстантного контейнера, включает определенное количество "кривизны".

После того как вы получаете `const_iterator`, ситуация ничуть не улучшается, поскольку в С++98 местоположения для вставки (и удаления) могут указывать только неконстантные итераторы `iterator`. Итераторы `const_iterator` для этого неприменимы. Вот почему в приведенном выше коде я выполняю приведение `const_iterator` (который я с таким трудом получил из [[find|std::find]]) в `iterator`: передача `const_iterator` в функцию `insert` не будет компилироваться.

Честно говоря, показанный мной код может не скомпилироваться, поскольку не существует переносимого преобразования `const_iterator` в `iterator`, даже с помощью [[static_cast|static_cast]]. Может не сработать даже семантическая кувалда [[reinterpret_cast|reinterpret_cast]]. (Это не ограничение С++98. Это справедливо и для C++11. `const_iterator` просто не преобразуется в `iterator` - неважно, насколько простым кажется такое преобразование.) Есть несколько переносимых способов сгенерировать `iterator`, который указывает на тоже, на что и `const_iterator`, но они не очевидны, не универсальны и не стоят того, чтобы рассматривать их в данной книге. Кроме того, я надеюсь, что теперь понятна моя позиция: `const_iterator` причиняли так много неприятностей в С++98, что редко стоили того, чтобы о них беспокоиться и их использовать. По большому счету программисты всегда использовали `const` не где это только возможно, а только там, где это практично, а в С++98 `const_iterator` особо практичным не является.

Все изменилось с появлением C++11. Теперь `const_iterator` легко получить и легко использовать. Функции-члены контейнера [[cbegin|cbegin]] и [[cend|cend]] возвращают `const_iterator` даже для неконстантных контейнеров, а функции-члены STL, которые применяют итераторы для указания позиций (например, `insert` и `erase`), в действительности используют итераторы `const_iterator`. Переделка кода С++98, который использовал `iterator`, в код с `const_iterator` в С++11 воистину тривиальна:
```c++
std::vector<int> values;                          // Как и ранее
...
auto it = std::find(values.cbegin(),              // Используем cbegin
					values.cend(), 1983);         // и cend

values.insert(it ,1998);
```
Теперь код, использующий `const_iterator`, стал действительно практичным!

Почти единственной ситуацией, в которой поддержка С++11 для `const_iterator` оказывается недостаточной, является ситуация, когда вы хотите написать максимально обобщенный библиотечный код. Такой код принимает во внимание то, что некоторые контейнеры и контейнерообразные структуры данных предоставляют функции [[begin|begin]] и [[end|end]] (а также [[cbegin|cbegin]], [[cend|cend]], [[rbegin|rbegin]] и т.д.) как функции, не являющиеся членами. Это происходит, например, в случае встроенных массивов или при использовании некоторых библиотек сторонних производителей с интерфейсами, состоящими только из свободных функций. Максимально обобщенный код использует функции, не являющиеся членами,
а не предполагает наличие функций-членов.

Например, мы можем обобщить код, с которым только что работали, в шаблон
`findAndinsert` следующим образом:
```c++
template<typename С, typename V>
void findAndlnsert (C& container,         // В container находит
				const V& targetVal,       // первое значение
				const V& insertVal)       // targetVal, эатем
{                                         //вставляет insertVal
	using std::cbegin;
	using std::cend;
	
	auto it = std::find(cbegin(container),    // Не член cbegin
						cend(container),      // Не член cend
						targetVal);
						
	container.insert(it, insertVal);
}
```
Этот код прекрасно работает в С++14, но, к сожалению, не в С++11. Из-за недосмотра в процессе стандартизации в С++11 добавлены не являющиеся членами функции [[begin|begin]] и [[end|end]], но не были добавлены [[cbegin|cbegin]], [[cend|cend]], [[rbegin|rbegin]], [[rend|rend]], [[crbegin|crbegin]] и [[crend|crend]]. С++14 исправляет это упущение.

Если вы используете С++11, хотите написать максимально обобщенный код и ни одна из используемых вами библиотек не предоставляет отсутствующие шаблоны для [[cbegin|cbegin]] и подобных функций, не являющихся шаблонами, можете легко написать собственные реализации. Например, вот как выглядит реализация функции [[cbegin|cbegin]], не являющейся членом:
```c++
template <class С>
auto cbegin(const С& container) ->decltype (std::begin(container))
{
	return std::begin(container);
}
```
Вы удивлены тем, что эта функция [[cbegin|cbegin]] не вызывает функцию-член [[cbegin|cbegin]], не так ли? Я тоже был удивлен. Но давайте подумаем логически. Этот шаблон [[cbegin|cbegin]] принимает аргументы любого типа, представляющего контейнерообразную структуру данных `С`, и обращается к этому аргументу через ссылку на константный объект `contaiпer`. Если `С` - обычный тип контейнера (например, `std::vector<iпt>`), то `container` будет ссылкой на [[соnst|соnst]]-версию этого контейнера (например, `coпst std::vector<int> &`). Вызов функции [[begin|begin]], не являющейся членом (и предоставленной С++11), для константного контейнера дает константный итератор `coпst_iterator`, и именно этот итератор и возвращает наш шаблон. Преимущества такой реализации в том, что она работает даже для контейнеров, которые предоставляют функцию-член [[begin|begin]] (которую функция С++11 [[begin|begin]], не являющаяся членом, вызывает для контейнеров), но не имеют функции-члена [[cbegin|cbegiп]]. Таким образом, вы можете использовать эту свободную функцию [[cbegin|cbegin]] с контейнерами, поддерживающими единственную функцию-член [[begin|begin]].

Этот шаблон работает и в случае, когда `С` представляет собой встроенный массив. При этом `container` становится ссылкой на константный массив. C++11 предоставляет для массивов специализированную версию функции [[begin|begin]], не являющейся членом, которая возвращает указатель на первый элемент массива. Элементы константного массива являются константами, так что указатель, который возвращает свободная функция [[begin|begin]], возвращает для константного массива указатель на константу, который фактически и является `coпst_iterator` для массива. (Для понимания, [[Вывод типа шаблона|как специализировать шаблон для встроенных массивов]], которые получают в качестве параметров ссылки на массивы.) Но вернемся к основам. Суть этого раздела заключается в том, чтобы призвать вас использовать `coпst_iterator` везде, где возможно. Фундаментальный мотив для этого - применение [[const|const]] всегда, когда это имеет смысл - существовал и до С++11, но в С++98 этот принцип при работе с итераторами был непрактичным. В С++11 это сугубо практический совет, а в С++14 к тому же "доведены до ума" некоторые мелочи, остававшиеся незавершенными в С++11.

> - Предпочитайте использовать `const_iterator` вместо `iterator` там, где это можно.
> -
> - В максимально обобщенном коде предпочтительно использовать версии функций [[begin|begin]], [[end|end]], [[rbegin|rbegin]] и прочих, не являющиеся членами.

















