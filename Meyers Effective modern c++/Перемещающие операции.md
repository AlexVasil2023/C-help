# Считайте, что перемещающие операции отсутствуют, дороги или не используются

Семантика перемещения, пожалуй, самая главная возможность С++11. Вам наверняка приходилось слышать, что "перемещение контейнеров теперь такое же дешевое, как и копирование указателей" или что "копирование временных объектов теперь настолько эффективно, что избегать его равносильно преждевременной оптимизации': Понять такие настроения легко. Семантика перемещения действительно является очень важной возможностью. Она не просто позволяет компиляторам заменять дорогостоящие операции копирования относительно дешевыми перемещениями, но и требует от них этого (при выполнении надлежащих условий). Возьмите ваш код С++98, перекомпилируйте его с помощью компилятора и стандартной библиотеки С++11 и - о чудо! - ваша программа заработает быстрее.

Начнем с наблюдения, что многие типы не поддерживают семантику перемещения. Вся стандартная библиотека С++98 была переработана с целью добавления операций перемещения для типов, в которых перемещение могло быть реализовано быстрее копирования, и реализации компонентов библиотеки были пересмотрены с целью использования преимуществ новых операций; однако есть вероятность, что вы работаете с кодом, который не был полностью переделан под C++11. Для типов в ваших приложениях (или в используемых вами библиотеках), в которые не были внесены изменения для С++11, мало пользы от наличия поддержки перемещения компилятором. Да, С++11 готов генерировать перемещающие операции для классов, в которых они отсутствуют, но это происходит только для классов, в которых не объявлены копирующие операции, перемещающие операции или деструкторы ([[Генерация специальных функций-членов|см.]]). Члены-данные базовых классов типов, в которых перемещения отключены (например, путем удаления перемещающих операций; [[Предпочитайте удаленные функции закрытым неопределенным|см.]]) также подавляют перемещающие операции, генерируемые компиляторами. Для типов без явной поддержки перемещения и типов, которые не могут претендовать на перемещающие операции, генерируемые компилятором, нет оснований ожидать что С++11 обеспечит повышение производительности по сравнению с С++98.

Даже типы с явной поддержкой перемещений не могут обеспечить все, на что вы надеетесь. Например, все контейнеры стандартной библиотеки С++11 поддерживают перемещение, но было бы ошибкой считать, что перемещение является дешевой операцией для всех контейнеров. Для одних контейнеров это связано с тем, что нет никакого действительно дешевого способа перемещения их содержимого. Для других - с тем, что действительно дешевые перемещающие операции предлагаются контейнерами с оговорками, которым не удовлетворяют конкретные элементы контейнера.

Рассмотрим новый контейнер C++11 - [[Array|std::array]]. Контейнер [[Array|std::array]], по сути, представляет собой встроенный массив с SТL-интерфейсом. Он фундаментально отличается от других стандартных контейнеров, которые хранят свое содержимое в динамической памяти. Объекты таких типов контейнеров концептуально содержат (в качестве членов-данных) только указатель на динамическую память, хранящую содержимое контейнера. (Действительность более сложна, но для наших целей эти отличия не играют роли.) Наличие такого указателя позволяет перемещать содержимое всего контейнера на константное время: просто копируя указатель на содержимое контейнера из исходного контейнера в целевой и делая указатель исходного контейнера нулевым:

![[widg.png]]

```c++
std::vector<Widget>vw1;
// Размещение данных в vwl

// Перемещение vw1 в vw2. Выполняется
// за константное время, изменяя
// только указатели в vw1 и vw2
auto vw2 = std::move(vw1);
```

Объекты [[Array|std::array]] не содержат такого указателя, поскольку данные, содержащиеся в [[Array|std::array]], хранятся непосредственно в объекте [[Array|std::array]]:

![[widg2.png]]

```c++
std::array<Widget, 10000>aw1;
// Размещение данных в vw1

// Перемещение vw1 в vw2. Выполняется
// за линейное время. Все элементы
// aw1 перемещаются в aw2
auto aw2 = std::move(aw1);
```

Обратите внимание, что все элементы из `aw1` перемещаются в `aw2`. В предположении, что `Widget` представляет собой тип, операция перемещения которого выполняется быстрее операции копирования, перемещение [[Array|std::array]] элементов `Widget` будет более быстрым, чем копирование того же [[Array|std::array]]. Поэтому [[Array|std::array]] предлагает поддержку перемещения. И копирование, и перемещение [[Array|std::array]] имеют линейное время работы, поскольку должен быть скопирован или перемещен каждый элемент контейнера. Это весьма далеко от утверждения "перемещение контейнеров теперь такое же дешевое, как и копирование указателей", которое иногда приходится слышать.

С другой стороны, [[string|std::string]] предлагает перемещение за константное время и копирование - за линейное. Создается впечатление, что в этом случае перемещение быстрее копирования, но это может и не быть так. Многие реализации строк используют оптимизацию малых строк (small string optimization - SSO). При использовании SSO "малые" строки (например, размером не более 15 символов) хранятся в буфере в самом объекте [[string|std::string]]; выделение динамической памяти не используется. Перемещение малых строк при использовании реализации на основе SSO не быстрее копирования, поскольку трюк с копированием только указателя на данные, который в общем случае обеспечивает повышение эффективности, в данном случае не применим.

Мотивацией применения SSO является статистика, указывающая, что короткие строки являются нормой для многих приложений. С помощью внутреннего буфера для хранения содержимого таких строк устраняется необходимость динамического выделения памяти для них, и это, как правило, дает выигрыш в эффективности. Следствием этого выигрыша является то, что перемещение оказывается не быстрее копирования" . Хотя для любителей наполовину полного стакана можно сказать, что для таких строк копирование не медленнее, чем перемещение.

Даже для типов, поддерживающих быстрые операции перемещения, некоторые кажущиеся очевидными ситуации могут завершиться созданием копий. [[noexcept|Тут поясняется]], что некоторые контейнерные операции в стандартной библиотеке предполагают строгие гарантии безопасности исключений и что для гарантии того, что старый код С++98, зависящий от этой гарантии, не станет неработоспособным при переходе на С++11, операции копирования могут быть заменены операциями перемещения, только если известно, что последние не генерируют исключений. В результате, даже если тип предоставляет перемещающие операции, более эффективные по сравнению с соответствующими копирующими операциями, и даже если в определенной точке кода перемещающая операция целесообразна (например, исходный объект представляет собой [[rvalue|rvalue]]), компиляторы могут быть вынуждены по-прежнему вызывать копирующие операции, поскольку соответствующая перемещающая операция не объявлена как [[noexcept|noexcept]].

Таким образом, имеется ряд сценариев, в которых семантика перемещения С++11 непригодна.

> - **Отсутствие перемещающих операций**. Объект, из которого выполняется перемещение, не предоставляет перемещающих операций. Запрос на перемещение, таким образом, превращается в запрос на копирование.
> - **Перемещение не быстрее**. Объект, из которого выполняется перемещение, имеет перемещающие операции, которые не быстрее копирующих.
> - **Перемещение неприменимо**. Контекст, в котором должно иметь место перемещение, требует операцию, не генерирующую исключения, но операция перемещения не объявлена как [[noexcept|noexcept]].

Стоит упомянуть также еще один сценарий, когда семантика перемещения не приводит к повышению эффективности.

> - **Исходный объект является lvalue**. За очень малыми исключениями ([[Использование move и forward|см., например]]) только [[rvalue|rvalue]] могут использоваться в качестве источника перемещающей операции.

Но название этого раздела предполагает отсутствие перемещающих операций, их дороговизну или невозможность использования. Это типично для обобщенного кода, например, при написании шаблонов, поскольку вы не знаете всех типов, с которыми придется работать. В таких условиях вы должны быть настолько консервативными в отношении копирования объектов, как будто вы работаете с С++98, - до появления семантики перемещения. Это также случай "нестабильного" кода, т.е. кода, в котором характеристики используемых типов относительно часто изменяются.

Однако зачастую вам известно, какие типы использует ваш код, и вы можете положиться на неизменность их характеристик (например, на поддержку ими недорогих перемещающих операций). В этом случае вам не надо делать такие грустные предположения. Вы просто изучаете детали поддержки операций перемещения, используемых вашими типами. Если эти типы предоставляют недорогие операции перемещения и если вы используете объекты в контекстах, в которых эти операции будут вызываться, можете безопасно положиться на семантику перемещений при замене копирующих операций их менее дорогими перемещающими аналогами.

> - Считайте, что перемещающие операции отсутствуют, дороги или не используются.
> 
> - В коде с известными типами или поддержкой семантики перемещения нет необходимости в таких предположениях.

