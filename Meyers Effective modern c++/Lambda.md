# Лямбда-выражения

Лямбда-выражения, иногда называемые просто `лямбдами (lambdas)`, существенно изменили правила игры в программировании на С++. Это несколько удивительно, так как они не внесли в язык никаких новых возможностей выражения идей. Все, на что способны лямбда-выражения, вы в состоянии сделать вручную, разве что ценой немного больших усилий по вводу с клавиатуры. Но лямбда-выражения представляют собой очень удобное средство создания функциональных объектов, оказывающее огромное влияние на повседневную разработку программного обеспечения на С++. Без лямбда-выражений алгоритмы `"_if"` из STL (например, [[find|std::find_if]], [[remove|std::remove_if]], [[count|std::count_if]] и др.) обычно работают с самыми тривиальными предикатами, но при доступности лямбда-выражений применение этих алгоритмов резко возрастает. То же самое верно и для алгоритмов, настраиваемых с помощью пользовательской функции сравнения (например, [[sort|std::sort]], [[nth_element|std::nth_element]], [[lower_bound|std::lower_bound]] и др.). Вне STL лямбда-выражения позволяют быстро создавать пользовательские удалители для [[unique_ptr|std::unique_ptr]] и [[shared_ptr|std::shared_ptr]] и делают столь же простыми спецификации предикатов для переменных условий в потоковом API (см. [[Parallel computing#Применяйте фьючерсы void для одноразовых сообщений о событиях|раздел]].). Помимо использования в объектах стандартной библиотеки, лямбда-выражения облегчают определение функций обратного вызова "на лету", функций адаптации интерфейса и контекстно-зависимых функций для разовых вызовов. Лямбда-выражения действительно делают С++ более приятным языком программирования.

Терминология, связанная с лямбда-выражениями, может обескуражить. Лямбда-выражение является именно тем, что написано: выражением. Это часть исходного текста. В приведенном ниже фрагменте выделенная полужирным шрифтом часть представляет собой лямбда-выражение.

```c++
std::find_if(container.begin(), container.end(),
				[] (int val) { return О < val && val < 10; });
```

> - **Замыкание (closure)** представляет собой объект времени выполнения, создаваемый лямбда-выражением. В зависимости от режима захвата замыкания хранят копии ссылок на захваченные данные. В приведенном выше вызове [[find|std::find_if]] замыкание представляет собой объект, передаваемый во время выполнения в [[find|std::find_if]] в качестве третьего аргумента.
> - **Класс замыкания** (closure class) представляет собой класс, из котороrо инстанцируется замыкание. Каждое лямбда-выражение заставляет компиляторы генерировать уникальный класс замыкания. Инструкции внутри лямбда-выражения становятся выполнимыми инструкциями функций-членов их класса замыкания.

Лямбда-выражения часто используются для создания замыкания, которое применяется только в качестве аргумента функции. Именно этот случай представлен в приведенном выше примере [[find|std::find_ if]]. Однако в общем случае замыкания могут копироваться, так что обычно можно иметь несколько замыканий типа замыкания, соответствующего одному лямбда-выражению. Например, в коде

```c++
{
	int х;                                // х - локальная переменная
	...
	auto c1 =                             // c1 - копия замыкания,
		[х](int у) {                      // сгенерированного
			return х * у > 55; };         // лямбда-выражением
	auto с2 = c1;                         // с2 копия c1
	auto сЗ = с2;                         // сЗ - копия с2 
}
```

c1, с2 и сЗ являются копиями замыкания, порожденного лямбда-выражением.

Неформально вполне приемлемо размытие границы между лямбда-выражениями, замыканиями и классами замыканий. Но в последующих разделах очень часто важно различать, что существует во время компиляции (лямбда-выражения и классы замыканий), что - во время выполнения (замыкания) и как они соотносятся одно с другим.

# Синтаксис
## Лямбда-выражения без явного списка параметров шаблона (возможно, нестандартного)
---
> - `[captures]` `front-attr` ﻿(optional) `(params)` `specs` ﻿(optional) `exception` ﻿(optional) `back-attr` ﻿(optional) `trailing-type` ﻿(optional) `requires` ﻿(optional) `{ body }`               ==(1)==
> 
> - `[captures﻿] { body }`  ==до с++23==                                                                                         ==(2)==
> 
> - `[captures]` `front-attr` ﻿(optional) `trailing-type` ﻿(optional) `{ body }`  ==начиная с C ++23==                                                                                                                                        ==(2)==
>
> - `[captures]` `front-attr` ﻿(optional) `exception` `back-attr` ﻿(optional) `trailing-type` ﻿(optional) `{body}` ==начиная с C ++23==                                                                                  ==(3)==
>
> - `[captures﻿]` `front-attr` (optional) `specsexception` (optional) `back-attr` ﻿(optional) `trailing-type` ﻿(optional) `{body}`   ==начиная с C ++23==                                                      ==(4)==
---
## Лямбда-выражения с явным списком параметров шаблона (всегда общим) (начиная с C ++ 20)
---
> - `[captures]` `<tparams>` `t-requires` ﻿(optional) `front-attr` ﻿(optional) `(params)` `specs` ﻿(optional) `exception` ﻿(optional) `back-attr` ﻿(optional) `trailing-type` ﻿(optional) `requires` ﻿(optional) `{body}`                                                                                                                 ==(1)==
>
> - `[captures]` `<tparams>` `t-requires` ﻿(optional) `{body}`   ==до с++23==                                ==(2)==
>
> - `[captures]` `<tparams>` `t-requires` ﻿(optional) `front-attr` ﻿(optional) `trailing-type` ﻿(optional) `{body}`   ==начиная с C ++23==                                                                              ==(2)==
>
> - `[captures]` `<tparams>` `t-requires` ﻿(optional) `front-attr` ﻿(optional) `exception` `back-attr` ﻿(optional) `trailing-type` ﻿(optional) `{body}`   ==начиная с C ++23==                         ==(3)==
>
> - `[captures]` `<tparams>` `t-requires` ﻿(optional) `front-attr` ﻿(optional) `specs` `exception` ﻿(optional) `back-attr` ﻿(optional) `trailing-type` ﻿(optional) `{body}`   ==начиная с C ++23==                                                                                                                                                   ==(4)==
---

1 лямбда-выражение со списком параметров.
2-4 лямбда-выражение без списка параметров.
2 Простейший синтаксис. back-attr не может быть применен.
обратная привязка 
3,4) может применяться только при наличии какой-либо из спецификаций и исключения.

---
- captures 
	- список из нуля или более записей, разделенных запятыми, необязательно начинающийся с записи по умолчанию.
	- Подробное описание захватов ниже.
	- Лямбда -выражение может использовать переменную, не фиксируя ее, если переменная
		- является нелокальной переменной или имеет статический или время изни в локальном потоке (в этом случае переменная не может быть захвачена), или
		- это ссылка, которая была инициализирована с помощью постоянного выражения.
	- Лямбда -выражение может считывать значение переменной, не фиксируя его, если переменная
		- имеет **const** интегральный или перечислительный тип и был инициализирован с помощью постоянного выражения, или
		- является **constexpr** и не имеет изменяемых членов.
- tparams
	- Непустой список параметров шаблона, разделенных запятыми, используемый для предоставления имен шаблонным параметрам универсального лямбда-выражения (см. `ClosureType::operator()` Ниже).
- t-requires
	- Добавляет ограничения к `tparams`. Если t-requires заканчивается последовательностью спецификаторов атрибутов, атрибуты в последовательности обрабатываются как атрибуты в `front-attr`.
- front-attr. ==начиная с C ++ 23==
	- Последовательность спецификаторов атрибутов применяется к `operator()` типа `closure` (и, таким образом, `[[noreturn]]` атрибут может быть использован).
- params
	- Список параметров `operator()` типа `closure`. Оно может иметь явный параметр объекта ==начиная с C ++23==
- specs
	- Список следующих спецификаторов, каждый спецификатор допускается не более одного раза в каждой последовательности.

| **Specifier**                              | **Effect**                                                                                                                                                                                                                                     |
| ------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| mutable                                    | Позволяет `body` изменять объекты, захваченные с помощью копирования и вызывать их неконстантные функции-члены. <br>Не может использоваться, если присутствует явный параметр объекта ==начиная с C ++23==                                     |
| constexpr       <br>(==начиная с C ++17==) | Явно указывает, что `operator()` является функцией `constexpr`. <br>Если `operator()` удовлетворяет всем требованиям функции `constexpr`, то `operator()` будет иметь значение `constexpr`, даже если `constexpr` отсутствует.                 |
| consteval  <br>(==начиная с C ++20==)      | Указывает, что `operator()` является непосредственной функцией.<br>`consteval` и `constexpr` не могут быть указаны одновременно.                                                                                                               |
| static  <br>(==начиная с C ++23==)         | Указывает, что `operator()` является статической функцией-членом.<br>`static` и `mutable` не могут быть указаны одновременно.<br>Не могут использоваться, если значение `captures` не является пустым или присутствует явный параметр объекта. |
- exception
	- Предоставляет спецификацию `динамического исключения` или (==до C++20==) спецификатор `noexcept` для `operator()` типа `closure`.
- back-attr
	- Последовательность спецификаторов атрибутов применяется к типу `operator()` типа `closure` (и, следовательно, `[[noreturn]]` атрибут не может быть использован).
- trailing-type
	- `-> ret`, где `ret` указывает возвращаемый тип.
- requires
	- (==начиная с C++20==) Добавляет ограничения к `operator()` типа `closure`.
- body
	- Тело функции

Если [[auto|auto]] используется в качестве типа параметра или предоставлен явный список параметров шаблона (начиная с C++20), лямбда-выражение является _универсальным лямбда-выражением_.
# Лямбда-функции (лямбда-выражения) C++11 

Лямбда-выражения позволяют программистам ускорить написание кода. Под лямбда-выражениями понимают специальный способ записи функторов. Например, функтор **sum** и лямбда-функции в следующем примере эквивалентны по использованию и поведению:
```c++
// то же, что и [](int x, int y) -> int{ int result = x + y; return result; }
auto lambda = [](int x, int y) { return x + y; }

struct sum{
    int opertator()(int x, int y){ return x+y;}
};
```

У них есть список захвата (capture list):

> - `[]`- ничего не захватывает.
> - `[ = ]`- захват локальных объектов по значению.
> - `[ & ]`- захват локальных объектов по ссылке.
> - `[this]` - захват указателя this по значению.
> - `[a, &b]` - захват объекта a по значению, b – по ссылке.

```c++
int x = 1; 

auto getX = [=]{ return x; }; 
getX(); // == 1 

auto addX = [=](int y) { return x + y; }; 
addX(1); // == 2 

auto getXRef = [&]() -> int& { return x; }; 
getXRef(); // int& к `x`
```

По умолчанию объекты, захваченные по значению, не могут быть изменены внутри лямбда-выражения, так как созданный компилятором метод помечен как `const`. Ключевое слово `mutable` позволяет изменять их.
```c++
int x = 1; 

auto f1 = [&x] { x = 2; }; // OK: x является ссылкой и изменяет оригинал 

auto f2 = [x] { x = 2; }; // Ошибка: лямбда-выражение может выполнять только const-операции с захваченным значением 

// vs.
auto f3 = [x] () mutable { x = 2; }; // OK: лямбда-выражение может выполнять любые операции с захваченным значением
```

# Обобщенные лямбда-выражения C++14

C++14 теперь позволяет использовать спецификатор типа **`auto`** в списке параметров, создавая полиморфные лямбды.
```c++
auto identity = [](auto x) { return x; };

int three = identity(3); // == 3
std::string foo = identity("foo"); // == "foo"
```

# Инициализация лямбда-захватов C++14

Позволяет создавать лямбда-захваты, инициализированные произвольными выражениями при создании лямбды.
```c++
int factory(int i) { return i * 10; }
auto f = [x = factory(2)] { return x; }; // возвращает 20

auto generator = [x = 0] () mutable {
   // без `mutable` не скомпилируется
   // поскольку мы изменяем x при каждом вызове
  return x++;
};

auto a = generator(); // == 0
auto b = generator(); // == 1
auto c = generator(); // == 2
```

# Constexpr лямбды

До C++17 лямбды не были совместимы с _constexpr_. Теперь лямбды можно писать внутри _constexpr_ выражений, а также можно объявлять сами лямбды как _constexpr_.  
Примечание: даже если спецификатор _constexpr_ не указан, лямбда все равно будет _constexpr_, если это возможно.  
Пример с лямбдой внутри _constexpr_ функции:
```c++
// С++17
constexpr int Func(int x){  
	auto f = [x]() { return x * x; };  
	return x + f();
}

int main(){  
	constexpr int v = Func(10);  
	static_assert(v == 110);  
	
	return 0;
}
```
Пример с _constexpr_ лямбдой:  
  ```c++
// C++17
int main(){  
	constexpr auto squared = [](int x) { return x * x; };  
	constexpr int s = squared(5);  
	static_assert(s == 25);  
	
	return 0;
}
```
Пример Лямбды с использованием `constexpr`.
```c++
auto identity = [] (int n) constexpr { return n; };
static_assert(identity(123) == 123);

constexpr auto add = [] (int x, int y) {
  auto L = [=] { return x; };
  auto R = [=] { return y; };
  return [=] { return L() + R(); };
};

static_assert(add(1, 2)() == 3);

constexpr int addOne(int n) {
  return [n] { return n + 1; }();
}

static_assert(addOne(1) == 2);
```

# Захват this в лямбдах

Ранее захват `this` в лямбдах происходил только по ссылке. Теперь лямбда-выражения могут захватывать члены класса по значению при помощи _*this_:
```c++
class SomeClass
{
	public:  
		int m_x = 0;  
		
		void f() const  
		{
			std::cout << m_x << '\n';  
		}  
		
		void g()  
		{
			m_x++;  
		}  
		
		// С++14  
		void Func()  
		{    
			// const копия *this    
			auto lambda1 = [self = *this](){ self.f(); };    
			// non-const копия *this    
			auto lambda2 = [self = *this]() mutable { self.g(); };    
			
			lambda1();    
			lambda2();  
		}  
		
		// С++17  
		void FuncNew()  
		{    
			// const копия *this    
			auto lambda1 = [*this](){ f(); };     
			// non-const копия *this    
			auto lambda2 = [*this]() mutable { g(); };    
			
			lambda1();    
			lambda2();  
		}
};
```
```c++
struct MyObj {
	int value{ 123 }; 
	
	auto getValueCopy() { 
		return [*this] { return value; }; 
	} 

	auto getValueRef() { 
		return [this] { return value; }; 
	} 
}; 

MyObj mo; 
auto valueCopy = mo.getValueCopy(); 
auto valueRef = mo.getValueRef(); 

mo.value = 321; 

valueCopy(); // 123 
valueRef(); // 321
```

# Сокращенный шаблон функции

## Лямбда-функции C++20
Общие лямбды были введены в C++14, где [[auto|auto]] использовался в качестве параметра функции.
## C++14
```c++
// lambda definition
auto addTwo = [](auto first, auto second)
{
    return first + second; 
};
```

В C++20, аналогично тому, как [[auto|auto]] использовался в лямбдах, [[auto|auto]] теперь можно использовать в качестве параметра функции для получения шаблона функции.  
В C++20 добавлены сокращенные шаблоны функций, используемые для сокращения шаблонной версии функции.
## C++
```c++
template< typename T >
T addTwo(T first, T second)
{
     return first + second; 
}
```
## C++20
```c++
// this is a template, without the word 'template'!
auto addTwo(auto first, auto second)
{
    return first + second;  
}
```
(Для ясности - именно `auto` используемый в качестве параметра - даже всего лишь одного из параметров - делает его шаблоном.)

Глядя на это с точки зрения концепций, [[auto|auto]] действует как самая неограниченная концепция.

# Closure type
Лямбда-выражение представляет собой выражение `prvalue` уникального неназванного типа класса, не являющегося [[union|объединением]], не являющегося [[aggregate|агрегатом]], известного как `closure type`, который объявляется (для целей ADL) в наименьшей области блока, области класса или области пространства имен, которая содержит лямбда-выражение.
`closure type` является структурным типом тогда и только тогда, когда `captures` пуст (==начиная с C++20==).
Тип замыкания имеет следующие члены, они не могут быть явно созданы, явно специализированы или (==начиная с C++14==) названы в объявлении `friend`:
```c++
ClosureType::operator()(params)

ret operator()(params) { body }  // (могут присутствовать статические и const
								//   см. Ниже)

template<template-params>        //(начиная c C++14)  
ret operator()(params) { body }  //(могут присутствовать общие лямбда-выражения,
								 //    static и const, см. Ниже)
```

Выполняет тело лямбда-выражения при вызове. При обращении к переменной обращается к ее захваченной копии (для объектов, захваченных с помощью `copy`) или к исходному объекту (для объектов, захваченных по ссылке).
Список параметров `operator()` является `params`, если он указан, в противном случае список параметров пуст.
Возвращаемый тип `operator()` - это тип, указанный в завершающем типе.
Если не указан завершающий тип, автоматически выводится `operator()`.
Если в лямбда-спецификаторах не использовалось ключевое слово `mutable`, или не присутствует явный параметр объекта (==начиная с C++23==), cv-квалификатор `operator()` является **const**, и объекты, которые были захвачены с помощью **copy**, не поддаются модификации изнутри этого `operator()`. Явный квалификатор **const** не допускается. `operator()` никогда не бывает виртуальным и не может иметь квалификатор `volatile`.
> `operator()` всегда является `constexpr`, если он удовлетворяет требованиям `функции constexpr`. Это также `constexpr`, если ключевое слово `constexpr` использовалось в лямбда-спецификаторах.   ==(начиная с C ++17)==
> `operator()` является непосредственной функцией, если в лямбда-спецификаторах использовалось ключевое слово `consteval`.    ==(начиная с C ++ 20)==
> `operator()` является статической функцией-членом, если в лямбда-спецификаторах использовалось ключевое слово `static`.   ==(начиная с C++23)==
> `operator()` является явной функцией-членом объекта если `params` содержит явный параметр объекта.  ==(начиная с C++23)==

Для каждого параметра в `params`, тип которого указан как [[auto|auto]], в `template-params` добавляется изобретенный параметр шаблона в порядке появления. Изобретенный параметр шаблона может быть пакетом параметров, если соответствующий функциональный элемент `params` является пакетом параметров функции.

==Начиная с C++14==
```c++
// универсальная лямбда, operator() - это шаблон с двумя параметрами
auto glambda = [](auto a, auto&& b) { return a < b; };
bool b = glambda(3, 3.14);         // OK
 
// универсальная лямбда, operator() - это шаблон с одним параметром
auto vglambda = [](auto printer)
{
    return [=](auto&&... ts) // общая лямбда, ts - это пакет параметров
    { 
		 printer(std::forward<decltype(ts)>(ts)...);
        // нулевая лямбда (не принимает параметров):
        return [=] { printer(ts...); };
    }
;};
 
auto p = vglambda([](auto v1, auto v2, auto v3)
{
    std::cout << v1 << v2 << v3;
});
 
auto q = p(1, 'a', 3.14); // выводит 1a3.14
q();                      // выводит 1a3.14
```

Если в определении лямбды используется явный список параметров шаблона, этот список параметров шаблона используется с `operator()`. Для каждого параметра в `params`, тип которого указан как [[auto|auto]], дополнительный изобретенный параметр шаблона добавляется в конец списка параметров шаблона:

==начиная с C++20==
```c++
// универсальная лямбда, operator() - это шаблон с двумя параметрами
auto glambda = []<class T>(T a, auto&& b) { return a < b; };
 
// универсальная лямбда, operator() - это шаблон с одним пакетом параметров
auto f = []<typename... Ts>(Ts&&... ts)
{
    return foo(std::forward<Ts>(ts)...);
};
```

Спецификация исключения `exception` в лямбда-выражении применяется к `operator()`.
Для целей поиска по имени, определения типа и значения этого указателя и для доступа к нестатическим членам класса тело `operator()` рассматривается в контексте лямбда-выражения.

```c++
struct X
{
    int x, y;
    int operator()(int);
    void f()
    {
        // контекстом следующего лямбда-выражения является функция-член X::f
        [=]() -> int
        {
            return operator()(this->x + y); // X::operator()(this->x + (*this).y)
                                            // this has type X*
        };
    }
};
```

# ClosureType::operator ret(\*)(params)()
## нестандартные лямбда-выражения без захвата
---

| using F = ret(\*)(params);  <br>operator F() const noexcept;           | ==(до C++17)==         |
| ---------------------------------------------------------------------- | ---------------------- |
| using F = ret(\*)(params);  <br>constexpr operator F() const noexcept; | ==(начиная с C ++17)== |

---
## общий лямбда-код без захвата
---

| template\<template-params> using fptr_t = /\* см. ниже \*/;<br>template\<template-params>  <br>operator fptr_t\<template-params>() const noexcept;           | ==(начиная с C ++ 14)==  <br>==(до C ++ 17)== |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------- |
| template\<template-params> using fptr_t = /\* см. ниже \*/;<br>template\<template-params>  <br>constexpr operator fptr_t\<template-params>() const noexcept; | ==(начиная с C ++17)==                        |
Эта определяемая пользователем функция преобразования определяется только в том случае, если список захвата лямбда-выражения пуст и не имеет явного параметра объекта (==начиная с C++23==). Это общедоступная, `constexpr`,(==начиная с C++17==) невиртуальная, неявная, const noexcept функция-член объекта closure.
Эта функция является непосредственной функцией, если оператор вызова функции (или специализация, для универсальных лямбда-выражений) является непосредственной функцией.
Общий лямбда-код без захвата имеет определяемый пользователем шаблон функции преобразования с тем же списком параметров шаблона, что и `operator()`.

==начиная с C++14==
```c++
void f1(int (*)(int)) {}
void f2(char (*)(int)) {}
void h(int (* )(int)){}  // #1
void h(char (*)(int)) {} // #2
 
auto glambda = [](auto a) { return a; };
f1(glambda); // OK
f2(glambda); // error: not convertible
h(glambda);  // OK: calls #1 since #2 is not convertible
 
int& (*fpi)(int*) = [](auto* a) -> auto& { return *a; }; // OK
```

Значение, возвращаемое функцией преобразования, является указателем на функцию с привязкой к языку C++, которая при вызове имеет тот же эффект, что и вызов оператора вызова функции типа `closure` для экземпляра типа `closure`, созданного по умолчанию.
Значение, возвращаемое функцией преобразования (шаблоном), является указателем на функцию с привязкой к языку C++, которая при вызове имеет тот же эффект, что и:
- для нестандартных лямбда-выражений, вызывающих `operator()` для экземпляра типа закрытия, созданного по умолчанию.
- для универсальных лямбда-выражений, вызывающих соответствующую специализации универсального лямбда-выражения `operator()` для созданного по умолчанию экземпляра типа `closure`.

Значение, возвращаемое функцией преобразования (шаблоном), равно
- если `operator()` является статическим, то создается указатель на этот `operator()` с привязкой к языку C++,
- в противном случае указатель на функцию с привязкой к языку C++, которая при вызове имеет тот же эффект, что и:
    - для нестандартных лямбда-выражений, вызывающих `operator()` для экземпляра типа закрытия, созданного по умолчанию.
    - для универсальных лямбда-выражений, вызывающих соответствующую специализации универсального лямбда-выражения `operator()` для созданного по умолчанию экземпляра типа `closure`.

Эта функция является `constexpr`, если оператор вызова функции (или специализации, для универсальных лямбда-выражений) является `constexpr`.

```c++
auto Fwd = [](int(*fp)(int), auto a) { return fp(a); };
auto C = [](auto a) { return a; };
static_assert(Fwd(C, 3) == 3);  // OK
 
auto NC = [](auto a) { static int s; return a; };
static_assert(Fwd(NC, 3) == 3); // error: no specialization can be
                                // constexpr because of static s
```

Если `operator()` имеет спецификацию исключения, не вызывающего выбрасывания, то указатель, возвращаемый этой функцией, имеет тип указателя на функцию `noexcept`.

https://en.cppreference.com/w/cpp/language/lambda#Lambda_capture

## Избегайте режимов захвата по умолчанию

В С++ 1 1 имеются два режима захвата: по ссылке и по значению. Захват по умолчанию по ссылке может привести к висячим ссылкам. Захват по умолчанию по значению соблазняет считать, что вы не подвержены этой проблеме (это не так), и думать, что ваши замыкания являются самодостаточными автономными замыканиями (но они могут и не быть таковыми).

Так выглядят основные положения данного раздела. Если вы в большей степени творец, чем ремесленник, вы, вероятно, захотите узнать побольше - так давайте начнем с опасности захвата по ссылке.

Захват по ссылке приводит к тому, что замыкание содержит ссылку на локальную переменную или на параметр, доступный в области видимости, где определено лямбда-выражение. Если время жизни замыкания, созданного из лямбда-выражения, превышает время жизни локальной переменной или параметра, ссылка в замыкании оказывается висячей. Предположим, например, что у нас есть контейнер с функциями фильтрации, каждая из которых принимает [[int|int]] и возвращает `bool`, указывающий, удовлетворяет ли переданное значение фильтру:

```c++
using FilterContainer = std::vector<std::function<bool (int)>>;
FilterContainer filters;                   // Функции фильтрации
```

Мы можем добавить фильтр для чисел, кратных 5, следующим образом:

```c++
filters.emplace_back(                // См. emplace_back
	[] (int value) { return value % 5 == О; }
);
```

Однако может быть так, что нам нужно вычислять делитель во время выполнения, т.е. мы не можем жестко "прошить" значение 5 в лямбда-выражении. Поэтому добавление фильтра может выглядеть следующим образом:

```c++
void addDivisorFilter()
{
	auto calc1 = cornputeSorneValue1();
	auto calc2 = cornputeSorneValue2();
	auto divisor = computeDivisor(calc1, calc2);
	
	filters.emplace_back(           // Опасно! Ссылка на divisor повиснет!
		[&] (int value) { return value % divisor == О; }
};
```

Этот код - бомба замедленного действия. Лямбда-выражение ссылается на локальную переменную `divisor`, но эта переменная прекращает свое существование после выхода из `addDivisorFilter`. Этот выход осуществляется сразу после выхода из `filters.emplace_back`, так что добавленная в `filters` функция, по сути, является мертворожденной. Применение этого фильтра ведет к неопределенному моменту практически с момента создания.

Та же проблема имеет место и при явном захвате `divisor` по ссылке,

```c++
filters.emplace_back(
	[&divisor] (int value)             // Опасно! Ссылка на
	{ return value % divisor == 0; }   // divisor все равно
);                                     // повисает!
```

но при явном захвате проще увидеть, что жизнеспособность лямбда-выражения зависит от времени жизни `divisor`. Кроме того, использование имени `divisor` напоминает нам о необходимости убедиться, что `divisor` существует как минимум столько же времени, сколько и замыкание лямбда-выражения. Это более конкретное напоминание, чем обобщенное "убедитесь, что ничего не висит", о чем гласит конструкция `[&]`.

Если вы знаете, что замыкание будет использовано немедленно (например, будучи переданным в алгоритм STL) и не будет копироваться, нет никакого риска, что ссылки, которые оно хранит, переживут локальные переменные и параметры в среде, где создано это лямбда-выражение. Вы могли бы утверждать, что в этом случае нет риска получить висячие ссылки, а следовательно, нет причин избегать режима захвата по ссылке по умолчанию. Например, наше фильтрующее лямбда-выражение может использоваться только как аргумент в алгоритме С++11 [[all_of|std::all_of]], который проверяет, все ли элементы диапазона удовлетворяют условию:

```c++
template<typename С>
void workWithContainer(const С& container)
{
	auto calc1 = computeSomeValue1();            // Как и ранее
	auto calc2 = computeSomeValue2();            // Как и ранее
	auto divisor = computeDivisor(calc1, calc2); // Как и ранее

	// Тип элементов в контейнере:
	using ContElemT = typename C::value_type;

	using std::begin;                            // Для обобщенности;
	using std::end;

	if(std::all_of(                              // Все значения
		begin(container),                        // в контейнере
		end (container),                         // кратны divisor?
		[&] (const ContElemT& value)
		{ return value % divisor == О; } )
	) {
	...                                          // Да
	} else {
                                                 // Как минимум одно - нет
	}
}
```

Да, все так, это безопасно, но эта безопасность довольно неустойчива. Если выяснится, что это лямбда-выражение полезно в других контекстах (например, как функция, добавленная в контейнер `filters`) и будет скопировано и вставлено в контекст, где это замыкание может пережить `divisor`, вы вновь вернетесь к повисшим ссылкам, и в выражении захвата не будет ничего, что напомнило бы вам о необходимости анализа времени жизни `divisor`.

С точки зрения долгосрочной перспективы лучше явно перечислять локальные переменные, от которых зависит лямбда-выражение.

Кстати, возможность применения [[auto|auto]] в спецификации параметров лямбда-выражений в С++14 означает, что приведенный выше код можно записать проще при использовании С++14. Определение псевдонима типа `ContElemT` можно убрать, а условие `if` может быть переписано следующим образом:

```c++
if(std::all_of(begin(container), end(container),
	[&] (const auto& value)
	{ return value % divisor ==	О; } ) )
```

Одним из способов решения нашей проблемы с локальной переменной `divisor` может быть применение режима захвата по умолчанию по значению, т.е. мы можем добавить лямбда-выражение к `filters` следующим образом:

```c++
filters.emplace_back(                           // Теперь
	[=] (int value)                             // divisor
{ return value % divisor == 0; }                // не может
);                                              // зависнуть
```

Для данного примера этого достаточно, но в общем случае захват по умолчанию по значению не является лекарством от висящих ссылок, как вам могло бы показаться. Проблема в том, что если вы захватите указатель по значению, то скопируете его в замыкания, возникающие из лямбда-выражения, но не сможете предотвратить освобождение объекта, на который он указывает (и соответственно, повисания), внешним кодом.

"Этого не может случиться! - возразите вы. - я работаю только с интеллектуальными указателями. Обычные указатели используют только несчастные программисты на С++98': Это может быть правдой, но это не имеет значения, потому что на самом деле вы используете обычные указатели, а они могут быть удалены. Да, в современном стиле программирования на С++ в исходном коде это незаметно, но это так.

Предположим, что одна из задач, которые могут решать `Widget`, добавление элементов в контейнер фильтров:

```c++
class Widget {
	public:
		...                        // Конструкторы и т.п.
		void addFilter () const;   // Добавление элемента в filters
	
	private:
		int divisor;               // Используется в фильтре
};

//Widget::addFilter может быть определен следующим образом:
void Widget::addFilter() const
{
	filters.emplace_back(
		[=] (int value) { return value % divisor == 0; }
	);
}
```

Для блаженно непосвященных код выглядит безопасным. Лямбда-выражение зависит от `divisor`, но режим захвата по умолчанию по значению гарантирует, что `divisor` копируется в любое замыкание, получающееся из лямбда-выражения, так ведь?

Нет. Совершенно не так. Ужасно не так! Смертельно не так!

Захваты применяются только к нестатическим локальным переменным (включая параметры), видимым в области видимости, в которой создано лямбда-выражение. В теле `Widget::addFilter` переменная `divisor` не является локальной переменной, это - член-данные класса `Widget`. Она не может быть захвачена. Если отменить режим за.хвата по умолчанию, код компилироваться не будет:

```c++
void Widget::addFilter() const
{
	filters.emplace_back(         // Ошибка! divisor недоступна!
		[] (int value) { return value % divisor == 0; }
	);
}
```

Кроме того, если сделана попытка явного захвата `divisor` (по значению или по ссылке-значения не имеет), захват не компилируется, поскольку `divisor` не является локальной переменной или параметром:

```c++
void Widget::addFilter() const
{
	filters.emplace_back(             // Ошибка ! Нет захватываемой
		[divisor] (int value)         // локальной переменной divisor!
		{ return value % divisor ==	О; }
	);
}
```

Если захват по умолчанию по значению не захватывает `divisor`, а без захвата по умолчанию по значению код не компилируется, то что же происходит?

Объявление связано с неявным использованием обычного указателя: `this`. Каждая нестатическая функция-член получает указатель `this`, и вы используете этот указатель всякий раз при упоминании члена-данных этого класса. В любой функции-члене `Widget`, например, компиляторы внутренне заменяют каждое использование `divisor` на `this>divisor`. В версии `Widget::addFilter` с захватом по умолчанию по значению

```c++
void Widget::addFilter() const
{
	filters.emplace_back (
		[=] (int value) { return value % divisor == О; }
	);
}
```

`this>divisor` захватывается указатель `this` объекта `Widget`, а не `divisor`. Компиляторы рассматривают этот код так, как будто он написан следующим образом:

```c++
void Widget::addFilter() const
{
	auto currentObjectptr = this;
	filters.emplace_back (
		[currentObjectptr] (int value)
		{ return value % currentObjectptr->divisor == 0; }
	);
}
```

Понимание этого равносильно пониманию того, что жизнеспособность замыканий, вытекающих из этого лямбда-выражения, связана со временем жизни объекта `Widget`, копии указателя `this` которого в них содержатся. В частности, рассмотрим код, который использует только интеллектуальные указатели:

```c++
using FilterContainer =                    // Как и ранее
	std::vector<std::function<bool(int)>>;
	
FilterContainer filters;                   // Как и ранее
void doSomeWork()
{
	auto pw =                              // Создание Widget ;
		std::make_unique<Widget>();        // std::make_unique 
	
	pw- >addFilter();                      // Добавление фильтра
                                           // с Widget::divisor
} // Уничтожение Widget; filters хранит висячий указатель!
```

Когда выполняется вызов `doSomeWork`, создается фильтр, зависящий от объекта `Widget`, созданного [[make_unique|std::make_unique]], т.е. фильтр, который содержит копию указателя на этот `Widget` - указатель `this` объекта `Widget`. Этот фильтр добавляется в `filters`, но по завершении работы `doSomeWork` объект `Widget` уничтожается, так как [[unique_ptr|std::unique_ptr]] управляет его временем жизни. С этого момента `filters` содержит элемент с висячим указателем.

Эта конкретная проблема может быть решена путем создания локальной копии члена-данных, который вы хотите захватить, и захвата этой копии:

```c++
void Widget::addFilter() const
{
	auto divisorCopy = divisor;                 // Копирование
	filters.emplace_back(                       // члена-данных
		[divisorCopy] (int value)               // Захват копии
		{ return value % divisorCopy == 0; }    // Ее использование
	);
};
```

Чтобы быть честным, скажу, что при таком подходе захват по умолчанию по значению также будет работать:

```c++
void Widget::addFilter() const
{
	auto divisorCopy = divisor;                 // Копирование
	filters.emplace_back(                       // члена-данных
		[=] (int value)                         // Захват копии
		{ return value % divisorCopy == 0; }    // Ее использование
	);
};
```

но зачем искушать судьбу? Режим захвата по умолчанию делает возможным случайный захват `this`, когда вы думаете, в первую очередь, о захвате `divisor`.

В С++14 имеется лучший способ захвата члена-данных, заключающийся в использовании [[Lambda#Синтаксис|обобщенного захвата лямбда-выражения]]:

```c++
void Widget::addFilter() const
{
	filters.emplace_back(                       // C++14
		[divisor = divisor] (int value)         // Копирование divisor
		                                        // в замыкание
		{ return value % divisor == 0; }        // Использование копии
	);
};
```

Однако такого понятия, как режим захвата по умолчанию для обобщенного захвата лямбда-выражения, не существует, так что даже в С++14 остается актуальным совет данного раздела - избегать режимов захвата по умолчанию.

Дополнительным недостатком режимов захвата по умолчанию является то, что они могут предполагать самодостаточность соответствующих замыканий и их изолированность от изменений внешних данных. В общем случае это не так, поскольку лямбда-выражения могут зависеть не только от локальных переменных и параметров (которые могут быть захвачены), но и от объектов со статическим временем хранения. Такие объекты определены в глобальной области видимости или области видимости пространства имен или объявлены как [[static|static]] внутри классов, функций или файлов. Эти объекты могут использоваться внутри лямбда-выражений, но не могут быть захвачены. Тем не менее спецификация режима захвата по умолчанию может создать именно такое впечатление.

Рассмотрим преобразованную версию функции `addDivisorFilter`, с которой мы встречались ранее:

```c++
void addDivisorFilter()
{
	static auto calc1
		= computeSomeValue1();          // Статический

	static auto calc2
		= computeSomeValue2();          // Статический

	static auto divisor =               // Статический
		computeDivisor(calc1, calc2);
		
	filters.emplace_back(
		[=] (int value)                // Ничего не захватывает
		{ return value % divisor == 0; }   // Ссылка на статическую
	);                                 // переменную
	
	++divisor;                         // Изменение divisor
}
```

Случайный читатель этого кода может быть прощен за то, что, видя `[ = ]` может подумать "Отлично, лямбда-выражение делает копию всех объектов, которые использует, и поэтому оно является самодостаточным": Но это не так. Это лямбда-выражение не использует никакие нестатические локальные переменные, поэтому ничего не захватывается. Вместо этого код лямбда-выражения обращается к статической переменной `divisor`. Когда в конце каждого вызова `addDivisorFilter` выполняется увеличение `divisor`, все
лямбда-выражения, которые были добавлены в `filters` с помощью данной функции, будут демонстрировать новое поведение (соответствующее новому значению `divisor`) . С практической точки зрения это лямбда-выражение захватывает `divisor` по ссылке, а это выглядит противоречащим объявленному захвату по умолчанию по значению. Если держаться подальше от захвата по умолчанию по значению, можно уменьшить риск неверного понимания такого кода.

> - Захват по умолчанию по ссылке может привести к висячим ссылкам.
> 
> - Захват по умолчанию по значению восприимчив к висячим указателям (особенно к `this`) и приводит к ошибочному предположению о самодостаточности лямбда-выражений.

## Используйте инициализирующий захват для перемещения объектов в замыкания

Иногда ни захват по значению, ни захват по ссылке не является тем, что вы хотите. Если у вас имеется объект, который можно только перемещать (например, [[unique_ptr|std::unique_ptr]] или [[future|std::future]]) и который вы хотите передать замыканию, С++11 не предлагает вам никакого способа для этого. Если у вас есть объект, который гораздо дешевле переместить, чем копировать (например, большинство контейнеров стандартной библиотеки), и вы хотели бы передать его в замыкание, то гораздо эффективнее переместить его, чем копировать. И вновь С++11 не предоставляет вам способа сделать это.

Но только C++11. С++14 - совершенно другая история. Он предлагает непосредственную поддержку перемещения объектов в замыкания. Если ваш компилятор соответствует стандарту С++14, радуйтесь и читайте дальше. Если же вы работаете с компиляторами С++11, вы тоже должны радоваться и читать дальше - потому что и в С++11 имеются способы приблизиться к перемещающему захвату.

Отсутствие перемещающего захвата было признано недостатком даже при принятии C++11. Казалось бы, простейшим путем было его добавление в С++14, но Комитет по стандартизации пошел иным путем. Он добавил новый механизм, который настолько гибкий, что захват путем перемещения является всего лишь одним из вариантов его работы. Новая возможность называется инициализирующим захватом (`init capture`). Он может делать почти все, что могут делать захваты в С++11, и еще многое. Единственное, что нельзя выразить с помощью инициализирующего захвата (и от чего, [[Lambda#Лямбда-выражения|как поясняется]], вам надо держаться подальше), - это режим захвата по умолчанию. (Для ситуаций, охватываемых захватами С++11, инициализирующий захват несколько многословнее, так что там, где справляется захват С++11, совершенно разумно использовать именно его.)

Применение инициализирующего захвата делает возможным указать:
1. имя члена-данных в классе замыкания, сгенерированном из лямбда-выражения, и
2. выражение инициализации этого члена-данных.

Вот как можно использовать инициализирующий захват для перемещения [[unique_ptr|std::unique_ptr]] в замыкание:

```c++
class Widget {                        // Некоторый полезный тип
	public:
		...
		bool isValidated() const;
		bool isProcessed() const;
		bool isArchived() const;
	
	private:
};

auto pw = std::make_unique<Widget>(); // Создание Widget;
									  // std::make_unique
...                                   // Настройка *pw
auto fuпc = [pw = std::move(pw)]      // Инициализация члена
	{ return pw->isValidated()        // в замыкании с помощью
		&& pw->isArchived(); };       // std::move(pw)
```

`pw = std::move(pw)` - инициализирующий захват. Слева от знака равенства `"="` находится имя члена-данных в классе замыкания, который вы определяете, а справа - инициализирующее выражение. Интересно, что область видимости слева от `"="` отличается от области видимости справа. Область видимости слева - это область видимости класса замыкания. Область видимости справа - та же, что и определяемого лямбда-выражения. В приведенном выше примере имя `pw` слева от `"="` ссылается на члены-данные в классе замыкания, в то время как имя `pw` справа ссылается на объект, объявленный выше лямбда-выражения, т.е. на переменную, инициализированную вызовом
[[make_unique|std::make_unique]]. Так что `pw = std::move(pw)` означает "создать член-данные `pw` в замыкании и инициализировать этот член-данные результатом применения [[move|std::move]] к локальной переменной `pw`.

Как обычно, код в теле лямбда-выражения находится в области видимости класса замыкания, так что использованные в нем `pw` относятся к члену-данным класса замыкания.

Комментарий `"настройка *pw"` в этом примере указывает, что после создания `Widget` с помощью [[make_unique|std::make_unique]] и до того, как интеллектуальный указатель [[unique_ptr|std::unique_ptr]] на этот `Widget` будет захвачен лямбда-выражением, `Widget` некоторым образом модифицируется. Если такая настройка не нужна, т.е. если объект `Widget`, созданный с помощью [[make_unique|std::make_unique]], находится в состоянии, приrодном для захвата лямбда-выражением, локальная переменная `pw` не нужна, поскольку член-данные класса замыкания может быть непосредственно инициализирован с помощью [[make_unique|std::make_unique]]:

```c++
auto func = [pw = std::make_unique<Widget>()] // Инициализация
	{ return pw->isValidated()                // члена -данных в замыкании
			&& pw->isArchived(); 
	};                                   // результатом вызова make_unique
```

Из этоrо должно быть ясно, что понятие захвата в С++14 значительно обобщено по сравнению с С++11, поскольку в С++11 невозможно захватить результат выражения. Поэтому еще одним названием инициализирующеrо захвата является обобщенный захват лямбда-выражения (**generalized lambda capture**). 

Но что если один или несколько используемых вами компиляторов не поддерживают инициализирующий захват С++14? Как выполнить перемещающий захват в языке, в котором нет поддержки перемещающеrо захвата?

Вспомните, что лямбда-выражение - это просто способ генерации класса и создания объекта этоrо типа. Нет ничего, что можно сделать с лямбда-выражением и чего нельзя было бы сделать вручную. Например, код на С++14, который мы только что рассмотрели, может быть записан на С++11 следующим образом:

```c++
class IsValAndArch {
	public:
		using DataType = std::unique_ptr<Widget>;
		
		explicit IsValAndArch(DataType &&ptr) // Применение std::move
			:pw(std::move(ptr)) {}
			
		bool operator()() const
			{ return pw->isValidated() && pw->isArchived(); }		
	private:
		DataType pw;
};

auto func = IsValAndArch(std::make_unique<Widget>());
```

Это требует больше работы, чем написание лямбда-выражения, но это не меняет тоrо факта, что если вам нужен класс C++11, поддерживающий перемещающую инициализацию своих членов-данных, то ваше желание отделено от вас лишь некоторым временем за клавиатурой.

Если вы хотите придерживаться лямбда-выражений (с учетом их удобства это, вероятно, так и есть), то перемещающий захват можно эмулировать в С++11 с помощью

1. перемещения захватываемого объекта в функциональный объект с помощью [[bind|std::bind]] и
2. передачи лямбда-выражению ссылки на захватываемый объект.

Если вы знакомы с [[bind|std::bind]], код достаточно прост. Если нет, вам придется немного привыкнуть к нему, но игра стоит свеч.

Предположим, вы хотите создать локальный [[vector|std::vector]], разместить в нем соответствующее множество значений, а затем переместить его в замыкание. В С++14 это просто:

```c++
std::vector<double> data;             // Объект, перемещаемый в замыкание
...                                   // Наполнение данными
auto func = [data = std::move(data)]  // Инициализирующий захват
	{ /* Использование данных */};
```

Тип объекта, который перемещается (`std::vector<double>`), имя этого объекта (`data`) и выражение инициализации для инициализирующего захвата ( `std::move(data)`). Далее следует эквивалент этого кода на С++11:

```c++
std::vector<double> data;                // Как и ранее
...                                      // Как и ранее
auto func = std::bind(                   // Эмуляция в С++11
	[] (const std::vector<double>&data)  // инициализирующего
	{ /* Использование данных */ },      // захвата
	std::move(data)
);
```

Подобно лямбда-выражениям, [[bind|std::biпd]] создает функциональные объекты. Я называю функциональные объекты, возвращаемые [[bind|std::biпd]], biпd-объектами. Первый аргумент [[bind|std::bind]] - вызываемый объект. Последующие аргументы представляют передаваемые этому объекту значения.

Вind-объект содержит копии всех аргументов, переданных [[bind|std::bind]]. Для каждого [[rvalue|lvаluе-аргумента]] соответствующий объект в bind-объекте создается копированием. Для каждого [[rvalue|rvalue]] он создается перемещением. В данном примере второй аргумент представляет собой [[rvalue|rvalue]] (как результат применения [[move|std::move]]), так что `data` перемещается в biпd-объект. Это перемещающее создание является сутью эмуляции перемещающего захвата, поскольку перемещение [[rvalue|rvalue]] в biпd-объект и есть обходной путь для перемещения [[rvalue|rvalue]] в замыкание С++11.

Когда bind-объект "вызывается" (т.е. выполняется его оператор вызова функции), сохраненные им аргументы, первоначально переданные в [[bind|std::bind]], передаются в вызываемый объект. В данном примере это означает, что когда вызывается bind-объект `func`, лямбда-выражению, переданному в [[bind|std::bind]], в качестве аргумента передается созданная в `func` перемещением копия `data`.

Это лямбда-выражение то же самое, что и использованное нами в C++14, за исключением добавленного параметра `data`. Этот параметр представляет собой [[rvalue|lvalue-ссылку]] на копию `data` в bind-объекте. (Это не [[rvalue|rvalue-ccылкa]], поскольку, хотя выражение, использованное для инициализации копии `data` (`std::move(data)`), является [[rvalue|rvalue]], сама по себе копия `data` представляет собой [[rvalue|lvalue]].) Таким образом, применение `data` внутри лямбда-выражения будет работать с копией `data` внутри bind-объекта, созданной перемещением.

По умолчанию функция-член `operator()` в классе замыкания, сгенерированном из лямбда-выражения, является [[const|const]]. Это приводит к тому, что все члены-данные в замыкании в теле лямбда-выражения являются константными. Однако созданная перемещением копия `data` внутри bind-объекта не является константной, так что, чтобы предотвратить модификацию этой копии `data` внутри лямбда-выражения, параметр лямбда-выражения объявляется как указатель на [[const|const]]. Если лямбда-выражение было объявлено как [[mutable|mutablе]], `operator()` в его классе замыкания не будет объявлен как [[const|const]], так что целесообразно опустить [[const|const]] в объявлении параметра лямбда-выражения:

```c++
auto func =                         
	std::bind(                                  // Эмуляция в C++11
		[] (std::vector<double>&data) mutable   // инициализирующего
		{ /* uses of data */ },                 // захвата для лямбда­
		std::move(data)                         // выражения, объяв-­
	);                                          // ленного mutable
```

Поскольку bind-объект хранит копии всех аргументов, переданных [[bind|std::bind]], bind-объект в нашем примере содержит копию замыкания, произведенного из лямбда-выра­жения, являющегося первым аргументом этого объекта. Следовательно, время жизни замыкания совпадает со временем жизни bind-объекта. Это важно, поскольку это означает, что, пока существует замыкание, существует и bind-объект, содержащий объект, захваченный псевдоперемещением.

Если вы впервые столкнулись с [[bind|std::bind]], вам может понадобиться учебник или справочник по C++11, чтобы все детали этого обсуждения встали на свои места в вашей голове. Вот основные моменты, которые должны быть понятными.

> - Невозможно выполнить перемещение объекта в замыкание С++11, но можно выполнить перемещение объекта в bind-объект С++11.
> 
> - Эмуляция захвата перемещением в С++11 состоит в перемещении объекта в bind-объект с последующей передачей перемещенного объекта в лямбда-выражение по ссылке.
> 
> - Поскольку время жизни bind-объекта совпадает с таковым для замыкания, можно рассматривать объекты в bind-объекте так, как будто они находятся в замыкании.

В качестве второго примера применения [[bind|std::bind]] для эмуляции перемещающего захвата рассмотрим пример кода С++14, который мы видели ранее и который создает [[unique_ptr|std::unique_ptr]] в замыкании:

```c++
auto func = [pw = std::make_unique<Widget>()] // Как и ранее,
	{ return pw->isValidated()                // создает pw
		&& pw->isArchived(); };               // в замыкании
```

А вот как выглядит его эмуляция на С++11:

```c++
auto func = std::bind(
	[] (const std::unique_ptr<Widget>& pw)
	{return pw->isValidated()
		&& pw->isArchived(); },
	std::make_unique<Widget>()
);
```

в данном разделе поясняется, что в С++11 имеются ситуации, когда может пригодиться [[bind|std::bind]], и это одна из них. (В С++14 такие возможности, как инициализирующий захват и параметры [[auto|auto]], устраняют такие ситуации.)

> - Для перемещения объектов в замыкания используется инициализирующий захват С++14.
> 
> - В С++11 инициализирующий захват эмулируется с помощью написания классов вручную или применения [[bind|std::bind]].

## Используйте параметры decltype для auto&& для передачи с помощью std::forward

Одной из самых интересных возможностей С++14 являются обобщенные лямбда-выражения - лямбда-выражения, в спецификации параметров которых используется ключевое слово [[auto|auto]]. Реализация этой возможности проста: `operator ( )` в классе замыкания лямбда-выражения является шаблоном. Например, для лямбда-выражения

```c++
auto f = [](auto х) {return normalize(х); };
```

оператор вызова функции класса замыкания имеет следующий вид:

```c++
class SomeCompilerGeneratedClassName {
	public:
		template<typename Т>            // См. возвращаемый тип auto
		auto operator () (Т х) const
		{ return normalize(x); }
										// Прочая функциональность
}                                       // класса замыкания
```

В этом примере единственное, что делает лямбда-выражение с параметром `х` - это передает его функции `normalize`. Если `normalize` рассматривает значения [[rvalue|lvalue]] не так, как значения [[rvalue|rvalue]], это лямбда-выражение написано некорректно, поскольку оно всегда передает функции `normalize` [[rvalue|lvalue]] (параметр `х`) , даже если переданный в лямбда-выражение аргумент представляет собой [[rvalue|rvalue]].

Корректным способом написания лямбда-выражения является прямая передача `х` в `normalize`. Это требует внесения в код двух изменений. Во-первых, `х` должен [[Отличие универсальных ссылок от rvalue-ссылок|быть универсальной ссылкой]], а во-вторых, он должен передаваться в `normalize` с использованием [[Использование move и forward|std::forward]]. Концептуально это требует тривиальных изменений:

```c++
auto f = [](auto&& х)
{ return normalize(std::forward<???>(x)); };
```

Однако между концепцией и реализацией стоит вопрос о том, какой тип передавать в [[forward|std::forward]], т.е. вопрос определения того, что должно находиться там, где я написал "???".

Обычно, применяя прямую передачу, вы находитесь в шаблонной функции, принимающей параметр типа `T`, так что вам надо просто написать `std::forward<T>`. В обобщенном лямбда-выражении такой параметр типа `T` вам недоступен. Имеется `T` в шаблонизированном операторе `operator ( )` в классе замыкания, сгенерированном лямбда-выражением, но сослаться на него из лямбда-выражения невозможно, так что это никак не помогает.

[[Свертывание ссылок|тут]] поясняется, что если lvalue-аргумент передается параметру, являющемуся универсальной ссылкой, то типом этого параметра становится lvalue-ссылка. Если же передается [[rvalue|rvalue]], параметр становится [[rvalue|rvаluе-ссылкой]]. Это означает, что вне лямбда-выражения мы можем определить, является ли переданный аргумент [[rvalue|lvalue или rvalue]], рассматривая тип параметра `х`. Ключевое слово [[decltуре|decltype]] дает нам возможность сделать это. Если было передано [[rvalue|lvalue]], `decltype(х)` даст тип, являющийся [[rvalue|lvаluе-ссылкой]]. Если же было передано [[rvalue|rvalue]], `decltуре(х)` даст тип, являющийся [[rvalue|rvаluе ссылкой]].

[[Свертывание ссылок|Поясняется также]], что при вызове [[forward|std::forward]] соглашения требуют, чтобы для указания [[rvalue|lvalue]] аргументом типа была [[rvalue|lvalue-ccылкa]], а для указания [[rvalue|rvalue]] - тип, не являющийся ссылкой. В нашем лямбда-выражении, если `х` привязан к [[rvalue|lvalue]], `decltуре(х)` даст [[rvalue|lvalue-ccылкy]]. Это отвечает соглашению. Однако, если `х` привязан к [[rvalue|rvalue]], `decltуре(х)` вместо типа, не являющегося ссылкой, даст [[rvalue|rvalue-ccылкy]]. Но взглянем на пример реализации [[forward|std::forward]] в С++14:

```c++
template<typename Т>                        // В пространстве
Т&& forward(remove_reference_t<T>& param)   // имен std
{
	return static_cast<T&&> (param);
}
```

Если клиентский код хочет выполнить прямую передачу  [[rvalue|rvalue]] типа `Widget`, он обычно инстанцирует [[forward|std::forward]] типом `Widget` (т.е. типом, не являющимся ссылочным), и шаблон [[forward|std::forward]] дает следующую функцию:

```c++
Widget&& forward (Widget& param)            // Инстанцирование для
{                                           // std::forward, когда
	return static_cast<Widqet&&> (param);   // Т является Widget
}
```

Но рассмотрим, что произойдет, если код клиента намерен выполнить прямую передачу того же самого [[rvalue|rvalue]] типа `Widget`, но вместо следования соглашению об определении `Т` как не ссылочного типа определит его как [[rvalue|rvаluе-ссылку]], т.е. рассмотрим, что случится, если `Т` определен как `Widget &&`. После начального инстанцирования [[forward|std::forward]] и применения [[remove_reference|std::remove_reference_t]], но до [[Свертывание ссылок|свертывания ссылок  std::forward]] будет выглядеть следующим образом:

```c++
Widqet&& && forward(Widqet& param)           // Инстанцирование
{                                            // std::forward nри
	return static_cast<Widqet&& &&> (param); // Т, равном Widget&&
}                                            // (до сворачивания ссьuюк)
```

Применение правила сворачивания ссылок о том, что [[rvalue|rvаluе-ссылка]] на [[rvalue|rvаluе-ссылку]] становится одинарной [[rvalue|rvаluе-ссылкой]], приводит к следующему инстанцированию:

```c++
Widget&& forward(Widget& param)             // Инстанцирование
{                                           // std::forward при
	return static_cast<Widget&&>(param);    // Т, равном Widget&&
}                                           // (после сворачивания ссьmок)
```

Если вы сравните это инстанцирование с инстанцированием, получающимся в результате вызова [[forward|std::forward]] с `T`, равным `Widget`, то вы увидите, что они идентичны. Это означает, что инстанцирование [[forward|std::forward]] типом, представляющим собой [[rvalue|rvаluе-ссылку]], дает тот же результат, что и инстанцирование типом, не являющимся ссылочным.

Это чудесная новость, так как `decltype(х)` дает [[rvalue|rvаluе-ссылку]], когда в качестве аргумента для параметра `х` нашего лямбда-выражения передается [[rvalue|rvalue]]. Выше мы установили, что, когда в наше лямбда-выражение передается [[rvalue|lvalue]], `decltуре(х)` дает соответствующий соглашению тип для передачи в [[forward|std::forward]], и теперь мы понимаем, что для [[rvalue|rvalue]] `decltype(х)` дает тип для передачи [[forward|std::forward]], который не соответствует соглашению, но тем не менее приводит к тому же результату, что и тип, соответствующий соглашению. Так что как для [[rvalue|lvalue]], так и для [[rvalue|rvalue]] передача `decltype(х)` в [[forward|std::forward]] дает нам желаемый результат. Следовательно, наше лямбда-выражение с прямой передачей может быть записано следующим образом:

```c++
auto f = [] (auto&& х)
	{ return normalize(std::forward<decltype(x)> (x)); };
```

Чтобы это лямбда-выражение принимало любое количество параметров, нам, по сути, надо только шесть точек, поскольку лямбда-выражения в С++14 могут быть с переменным числом аргументов:

```c++
auto f = [] (auto&&... xs)
	{ return normalize(std::forward<decltype(xs)>(xs) ...); };
```

> Используйте для параметров `аutо&&` при их прямой передаче с помощью [[forward|std::forward]] ключевое слово [[decltуре|decltype]].

## Предпочитайте лямбда-выражения применению std::bind

[[bind|std::bind]] в C++11 является преемником [[bind|std::bind1st]] и [[bind|std::bind2nd]] из С++98, но неформально этот шаблон является частью стандартной библиотеки еще с 2005 года. Именно тогда Комитет по стандартизации принял документ, известный как TRl, который включал спецификацию `bind`. (В TRl `bind` находился в отдельном пространстве имен, так что обращаться к нему надо было как к [[bind|std::tr1::bind]], а не к [[bind|std::bind]], а кроме того, некоторые детали его интерфейса были иными.) Эта история означает, что некоторые программисты имеют за плечами десятилетний опыт использования [[bind|std::bind]]. Если вы один из них, вы можете не быть склонными отказываться от столь долго верой и правдой служившего вам инструмента. Это можно понять, и все же в данном случае лучше его сменить, поскольку лямбда-выражения С++11 почти всегда являются лучшим выбором, чем [[bind|std::biпd]]. Что касается С++14, то здесь лямбда-выражения являются настоящим кладом.

В этом разделе предполагается, что вы хорошо знакомы с [[bind|std::bind]]. Если это не так, вы, вероятно, захотите получить базовые знания о нем, прежде чем продолжить чтение. Что ж, это похвально, тем более что никогда не знаешь, не встретишься ли с применением [[bind|std::bind]] в коде, который придется читать или поддерживать.

Наиболее важная причина, по которой следует предпочитать лямбда-выражения, заключается в их большей удобочитаемости. Например, предположим, что у нас есть функция для настройки будильника:

```c++
usiпg Time = std::chroпo::steady_clock::time_point;

eпum class Sound {Веер, Sireп, Whistle} ;

usiпg Duratioп = std::chroпo::steady_clock::duration;

// В момент t издать звук s продолжительностью d
void setAlarm (Time t, Sound s, Duration d);
```

Далее предположим, что в некоторой точке программы мы определили, что хотим, чтобы будильник был отключен в течение часа, после чего подал сигнал продолжительностью 30 с. Сам звук остается неопределенным. Мы можем написать лямбда-выражение, которое изменяет интерфейс setAlarm так, что необходимо указать только звук:

```c++
// setSoundL ("L" означает "лямбда-выражение") - функциональный
// объект, позволяющий указать сигнал будильника, который должен
// звучать через час в течение 30 с
auto setSoundL = 
	[](Sound s)
		{              // Делает доступными компоненты std::chrono
			using namespace std::chrono;

			setAlarm (steady_clock::now() + hours(1), // Будильник через
			s,                                       // час, звучит
	        seconds(ЗO));                            // 30 секунд
		};
```

Я выделил вызов `setAlarm` в лямбда-выражении. Он выглядит, как обычный вызов функции, и даже читатель с малым опытом в лямбда-выражениях может понять, что переданный лямбда-выражению параметр `s` передается в качестве аргумента функции `setAlarm`.

В С++14 этот код можно упростить, используя стандартные суффиксы для секунд (*s*), миллисекунд (*ms*), часов (*h*) и других единиц, основанных на поддержке пользовательских литералов в С++14. Эти суффиксы определены в пространстве имен `std::literals`, так что приведенный выше код переписывается как

```c++
auto setSoundL = 
	[] (Sound s)
		{
			using namespace std::chrono;
			using namespace std::literals;        // Суффиксы С++14

			setAlarm(steady_clock::now() + 1h,    // С++ 1 4 , смысл
			s,                                    // тот же, что
			ЗОs);                                 // и выше
		};
```

Наша первая попытка написать соответствующий вызов std::bind приведена ниже.

Она содержит ошибки, которые мы вскоре исправим, но главное - что правильный код более сложен, и даже эта упрощенная версия приводит к ряду важных вопросов:

```c++
using namespace std::chrono;                 // Как и ранее
using namespace std::literals;
using namespace std::placeholders;           // Необходимо для "1"

auto setSoundВ =                             // "В" означает "bind"
	std::bind(setAlarm,
		steady_clock::now() + 1h,            // Ошибка! См. ниже
		_1,
		30s);
```

Я хотел бы выделить вызов `setAlarm`, как делал это в лямбда-выражении, но здесь нет вызова, который можно было бы выделить. Читатели этого кода просто должны знать, что вызов `setSoundB` приводит к вызову `setAlarm` со временем и продолжительностью, указанными в вызове [[bind|std::bind]]. Для непосвященных заполнитель `"_1"` выглядит магически, но даже знающие читатели должны в уме отобразить число в заполнителе на позицию в списке параметров [[bind|std::bind]], чтобы понять, что первый аргумент вызова `setSoundB` передается в `setAlarm` в качестве второго аргумента. Тип этого аргумента в вызове [[bind|std::bind]] не определен, так что читатели должны проконсультироваться с объявлением `setAlarm`, чтобы выяснить, какой аргумент передается в `setSoundB`.

Но, как я уже говорил, этот код не совсем верен. В лямбда-выражении очевидно, что выражение `"steady_clock::now() + 1h"` представляет собой аргумент `setAlarm`. Оно будет вычислено при вызове `setAlarm`. Это имеет смысл: мы хотим, чтобы будильник заработал через час после вызова `setAlarm`. Однако в вызове [[bind|std::bind]] выражение `"steady_clock::now() + 1h"` передается в качестве аргумента в [[bind|std::bind]], а не в `setAlarm`. Это означает, что выражение будет вычислено при вызове std::bind и полученное время будет храниться в сгенерированном bind-объекте. В результате будильник сработает через час после вызова [[bind|std::bind]], а не через час после вызова `setAlarm`!

Решение данной проблемы требует указания для [[bind|std::bind]] отложить вычисление выражения до вызова `setAlarm`, и сделать это можно с помощью вложения еще двух вызовов [[bind|std::bind]] в первый:

```c++
auto setSoundВ =
	std::bind(setAlarm,
		std::bind(std::plus<>(),
			std::bind(steady_clock::now), 1h),
		_1,
		ЗОs);
```

Если вы знакомы с шаблоном [[plus|std::plus]] из С++98, вас может удивить то, что между угловыми скобками не указан тип, т.е. что код содержит `"std::plus<>"`, а не `"std::plus<type>"`. В C++14 аргумент типа шаблона для шаблонов стандартных операторов в общем случае может быть опущен, так что у нас нет необходимости указывать его здесь. С++11 такой возможности не предоставляет, так что в С++11 эквивалентный лямбда-выражению [[bind|std::bind]] имеет следующий вид:

```c++
using namespace std::chrono;          // Как и ранее
using namespace std::placeholders;

auto setSoundB =
	std::bind(setAlarm,
		std::bind(std::plus<steady_clock::time_point>(),
			std::bind(steady_clock::now),
			hours(1)),
		_1,
		seconds(30));
```

При перегрузке `setAlarm` возникают новые вопросы. Предположим, что перегрузка получает четвертый параметр, определяющий громкость звука:

```c++
enum class Volume {Normal, Loud, LoudPlusPlus};

void setAlarm(Time t, Sound s, Duration d, Volume v);
```

Лямбда-выражение продолжает работать, как и ранее, поскольку разрешение перегрузки выбирает трехаргументную версию `setAlarm`:

```c++
auto setSoundL =                           // Как и ранее
	[](Sound s)
	{
		using namespace std::chrono;
		setAlarm(steady_clock::now() + 1h, // ОК, вызывает
				s,	                       // setAlarm с тремя
				ЗОs);                      // аргументами
	};
```

Вызов же [[bind|std::bind]] теперь не компилируется:

```c++
auto setSoundВ =                          // Ошибка! Какая из
	std::bind(setAlarm,                   // функций setAlarm?
		std::bind(std::plus<>(),
			std::bind(steady_clock::now),
			1h),
	_1,
	ЗОs);
```

Проблема в том, что у компиляторов нет способа определить, какая из двух функций `setAlarm` должна быть передана в [[bind|std::bind]]. Все, что у них есть - это имя функции, а одно имя приводит к неоднозначности.

Чтобы вызов [[bind|std::bind]] компилировался, `setAlarm` должна быть приведена к корректному типу указателя на функцию:

```c++
using SetAlarmЗParamType = void (*) (Time t, Sound s, Duration d);

auto setSoundВ =          // Теперь все в порядке
	std::bind(static_cast<SetAlarmЗParamType>(setAlarm),
		std::bind(std::plus<>(),
			std::biпd(steady_clock::now),
			1h),
		_1,
		ЗОs);
```

Но это привносит еще одно различие между лямбда-выражениями и [[bind|std::bind]]. Внутри оператора вызова функции для `setSoundL` (т.е. оператора вызова функции класса замыкания лямбда-выражения) вызов `setAlarm` представляет собой обычный вызов функции, который может быть встроен компиляторами:

```c++
setSoundL(Sound::Siren);        // Тело setAlarm может быть встроено
```

Однако вызов [[bind|std::bind]] получает указатель на функцию `setAlarm`, а это означает,
что внутри оператора вызова функции `setSoundB` (т.е. оператора вызова функции bind объекта) имеет место вызов `setAlarm` с помощью указателя на функцию. Компиляторы менее склонны к встраиванию вызовов функций, выполняемых через указатели, а это означает, что вызовы `setAlarm` посредством `setSoundB` будут встроены с куда меньшей вероятностью, чем вызовы посредством `setSoundL`:

```c++
setSoundВ(Sound::Siren);      // Тело setAlarm вряд ли будет встроено
```

Таким образом, вполне возможно, что применение лямбда-выражений приводит к генерации более быстрого кода, чем применение std::bind. Пример `setAlarm` включает только простой вызов функции. Если вы хотите сделать что-то более сложное, то перевес в пользу лямбда-выражений только увеличится. Рассмотрим, например, такое лямбда-выражение С++14, которое выясняет, находится ли аргумент между минимальным (`lowVal`) и максимальным (`highVal`) значениями, где `lowVal` и `highVal` являются локальными переменными.

```c++
auto betweenL =
	[lowVal, highVal]
	(const auto& val)
	{ return lowVal <= val && val <= highVal; };
```

[[bind|std::bind]] может выразить то же самое, но эта конструкция является примером кода, безопасного ТОЛЬКО потому, ЧТО никто не в СОСТОЯНИИ его понять:

```c++
using namespace std::placeholders;              // Как и ранее
auto betweenВ =                                 // С++14
	std::bind(std::logical_and<>(),
		std::bind(std::less_equal<>(), lowVal, 1),
		std::bind(std::less_equal<>(), 1, highVal));
```

В С++11 мы должны указывать сравниваемые типы, и вызов [[bind|std::bind]] принимает следующий вид:

```c++
auto betweenВ =                                 // С++11
	std::bind(std::logical_and<bool>(),
		std::bind(std::less_equal<int>(), lowVal, 1),
		std::bind(std::less_equal<int>(), 1, highVal));
```

Конечно, в С++11 лямбда-выражение не может получать параметр [[auto|auto]], так что здесь тоже надо указывать тип:

```c++
auto betweenL =                                // С++11
	[lowVal, highVal]
	(int val)
	{ return lowVal <= val && val <= highVal; };
```

В любом случае, я надеюсь, все согласятся, что лямбда-версия не только более короткая, но и более понятная и легче поддерживаемая.

Ранее я отмечал, что для тех, у кого нет опыта работы с [[bind|std::bind]], заполнители (например, `_1`, `_2` и др.) выглядят магией. Но непонятно не только поведение заполнителей.

Предположим, у нас есть функция для создания сжатых копий `Widget`

```c++
enum class CompLevel{ Low, Normal, High};      // Уровень сжатия

Widget compress(const Widget& w,               // Создание сжатой
				CompLevel lev);                // копии w
```

и мы хотим создать функциональный объект, который позволяет нам указывать, насколько сильно должен быть сжат конкретный объект `Widget w`. Представленное ниже применение [[bind|std::bind]] создает такой объект:

```c++
Widget w;

using namespace std::placeholders;
auto compressRateB = std::bind( compress, w, _1);
```

Теперь, когда мы передаем `w` в [[bind|std::bind]], он должен храниться для последующего вызова `compress`. Он сохраняется в объекте `compressRateB`, но как именно - по значению или по ссылке! Это важно, потому что, если `w` изменяется между вызовами [[bind|std::bind]] и `compressRateB`, хранение `w` по ссылке будет отражать это изменение, в то время как сохранение по значению - нет.

Ответ заключается в том, что оно хранится по значению, но единственный способ узнать это - просто запомнить: в вызове [[bind|std::bind]] нет никаких признаков этого. Сравните этот подход с лямбда-выражением, в котором захват `w` по значению или по ссылке выполняется явно:

```c++
auto compressRateL =                       // Захват w по значению;
	[w] (CompLevel lev)                    // lev передается по значению
	{ return compress(w, lev); };
```

Не менее явно в лямбда-выражения передаются и параметры. Здесь очевидно, что параметр `lev` передается по значению. Таким образом,

```c++
compressRateL(CompLevel::High);          // arg передается по значению
```

Но как аргумент передается в объект, получающийся с помощью [[bind|std::bind]]?

```c++
compressRateB (CompLevel::High);         // Как передается arg?
```

И вновь единственный способ знать, как работает [[bind|std::bind]] - это запомнить. (Ответ заключается в том, что все аргументы, передаваемые bind-объектам, передаются по ссылке, поскольку оператор вызова функции для таких объектов использует прямую передачу.)

По сравнению с лямбда-выражениями код, использующий [[bind|std::bind]], менее удобочитаемый, менее выразителен и, возможно, менее эффективен. В С++14 нет обоснованных случаев применения std::bind. Однако в С++11 применение [[bind|std::bind]] может быть оправдано в двух ограниченных ситуациях.

> - **Захват перемещением.** Лямбда-выражения С++11 не предоставляют возможности захвата перемещением, но его можно эмулировать с помощью комбинации лямбда-выражения и [[bind|std::bind]]. 
>
> - **Полиморфные функциональные объекты.** Поскольку оператор вызова функции bind-объекта использует прямую передачу, он может принимать аргументы любого типа ([[Познакомьтесь с случаями некорректной работы прямой передачи|с учетом ограничений на прямую передачу]]). Это может быть полезным, когда вы хотите связать объект с шаблонным оператором вызова функции. Например, для класса

```c++
class PolyWidget {
	public:
		template<typename Т>
		void operator()(const Т& param) const;
);
```

[[bind|std::bind]] может связать `PolyWidget` следующим образом:

```c++
PolyWidget pw;

auto boundPW = std::bind(pw, _1);
```

После этого `boundPW` может быть вызван с разными типами аргументов:

```c++
boundPW(1930);          // Передача int в PolyWidget::operator()
boundPW(nullptr);       // Передача nullptr в PolyWidget::operator()
boundPW("Rosebud");     // Передача строкового литерала
```

Выполнить это с помощью лямбда-выражений С++11 невозможно. Однако в С++14 этого легко достичь с помощью лямбда-выражения с параметром [[auto|auto]]:

```c++
auto boundPW = [pw] (const auto& param)         // С++14
				{ pw(param); };
```

Конечно, это крайние случаи, и они встречаются все реже, поскольку поддержка С++14 лямбда-выражений компиляторами становится все более распространенной.

Когда [[bind|bind]] был неофициально добавлен в С++ в 2005 году, это было существенным усовершенствованием по сравнению с его предшественником 1998 года. Однако добавление поддержки лямбда-выражений в C++11l привело к устареванию [[bind|std::bind]], а с момента появления С++14 для него, по сути, не осталось применений.

> - Лямбда-выражения более удобочитаемы, более выразительны и могут быть более эффективными по сравнению с [[bind|std::bind]].
> - Только в С++11 [[bind|std::bind]] может пригодиться для реализации перемещающего захвата или для связывания объектов с шаблонными операторами вызова функции.





























