# Делайте константные функции-члены безопасными в смысле потоков

Если мы работаем в области математики, нам может пригодиться класс, представляющий полиномы. В этом классе было бы неплохо иметь функцию для вычисления корней полинома, т.е. значений, при которых значение полинома равно нулю. Такая функция не должна модифицировать полином, так что ее естественно объявить как [[const|const]]:
```c++
class Polynomial{
	public :
		using RootsType =            // Структура данных, хранящая
				std::vector<double>; // значения, где полином равен нулю
		...
		RootsType roots() const;
}
```
Вычисление корней - трудная дорогостоящая операция, так что мы не хотим их вычислять до того, как они реально потребуются. Но если они нам требуются, то, определенно, требуются не один раз. Поэтому мы будем кешировать корни полиномов, если нам приходится их вычислять, и реализуем `roots` так, чтобы функция возвращала кешированное значение. Вот как выглядит такой подход:
```c++
class Polynomial {
	public:
		using RootsType = std::vector<double>;

		RootsType roots () const {
			if (!rootsAreValid){           // Если кеш некорректен,
										   // вычисляем корни и сохраняем
										   // их в in rootVals
				rootsAreValid = true;
			}
			return rootVals;
		}

	private:
		mutable bool rootsAreValid{ false } ; // См . инициализаторы
		mutable RootsType rootVals { };
};
```
Концептуально `roots` не изменяет объект `Polynomial`, с которым работает, но в качестве части кеширующих действий может потребоваться изменение `rootVals` и `rootsAreValid`. Это классический случай использования [[mutable|mutable]], и именно поэтому эти данные-члены объявлены с данным модификатором
.
Представим теперь, что два потока одновременно вызывают `roots` для объекта
`Polynomial`:
```c++
Polynomial р;
...
/* ----- Поток 1 ------- */             /* ------- Поток 2 ------- */
auto rootsOfP = p.roots();              auto valsGivingZero = p.roots();
```
Этот клиентский код совершенно разумен. Функция `roots` является константной функцией-членом, и это означает, что она представляет операцию чтения. Выполнение операций чтения несколькими потоками одновременно без синхронизации вполне безопасно. Как минимум предполагается, что это так. В данном случае это не так, поскольку в функции `roots` один или оба эти потока могут попытаться изменить члены-данные `rootsAreValid` и `rootVals`. Это означает, что данный код может одновременно читать и записывать одни и те же ячейки памяти без синхронизации, а это - определение гонки данных. Такой код имеет неопределенное поведение.

Проблема заключается в том, что функция `roots` объявлена как [[const|const]], но не является безопасной с точки зрения потоков. Объявление [[const|const]] является корректным как в С++11, так и в С++98 (вычисление корней полинома не изменяет сам полином), так что коррекция нужна для повышения безопасности потоков.

Простейший способ решения проблемы обычно один: применение `mutex`:
```c++
class Polynomial {
	public:
		using RootsType = std::vector<double>;

		RootsType roots() const
		{
			std::lock_guard<std::mutex> g(m); // Блокировка мьютекса
			if (!rootsAreValid) {             // Если кеш некорректен
				...                           // Вычисление корней
				rootsAreValid = true;
			}
			
			return rootVals;
		}		                              // Разблокирование

	private:
		mutable std::mutex m;
		mutable bool rootsAreValid{ false };
		mutable RootsType rootVals{ };
};
```
Мьютекс [[mutex|std::mutex]] `m` объявлен как [[mutable|mutable]], поскольку его блокировка и разблокирование являются неконстантными функциями, а в противном случае в константной функции-члене `roots` мьютекс `m` рассматривается как константный объект.

Следует отметить, что поскольку [[mutex|std::mutex]] не может быть ни скопирован, ни перемещен, побочным эффектом добавления `m` к `Polynomial` является то, что `Polynomial` теряет возможность копирования и перемещения.

В некоторых ситуациях мьютекс является излишеством. Например, если все, что вы делаете, - это подсчитываете, сколько раз вызывается функция-член, то часто более дешевым средством является счетчик [[atomic|std::atomic]] ([[Parallel computing#Используйте std аtomic для параллельности, volatile - для особой памяти|т.е. счетчик, для которого гарантируется атомарность операций]]). (Действительно ли это более дешевое средство, зависит от аппаратного обеспечения и реализации мьютексов в вашей стандартной
библиотеке.) Вот как можно использовать [[atomic|std::atomic]] для подсчета вызовов:
```c++
class Point {                         // двумерная точка
	public:
		...
		double distanceFromOrigin()   // См. описание noexcept
				const noexcept
		{
			++callCount;              // Атомарный инкремент

			return std::hypot(x, у);  // std::hypot - новинка C++11
		}
		
	private:
		mutable std::atomic<unsigned> callCount{ О };
		double х, у;
};
```
Как и [[mutex|std::mutex]], [[atomic|std::atomic]] невозможно копировать и перемещать, так что наличие `callCount` в `Point` означает, что `Point` также невозможно и перемещать. 

Поскольку операции над переменными [[atomic|std::atomic]] зачастую менее дорогостоящи, чем захват и освобождение мьютекса, вы можете соблазниться использовать [[atomic|std::atomic]] больше, чем следует. Например, в классе, кеширующем дорогостоящее для вычисления значение `int`, вы можете попытаться использовать вместо мьютекса пару переменных [[atomic|std::atomic]]:
```c++
class Widget
	public:
		...
		int magicValue() const
		{
			if(cacheValid) return cachedValue;
			else {
				auto val1 = expensiveComputation1();
				auto val2 = expensiveComputation2();
				
				cachedValue = val1 + val2;            // Часть 1
				cachevalid = true;                    // Часть 2
				
				return cachedValue;
			}
		}
	private:
		mutable std::atomic<Ъool>cacheValid{ false );
		mutable std::atomic<int>cachedValue;
};
```
Этот способ работает, но иногда выполняет существенно большую работу, чем требуется. Рассмотрим такой сценарий.

> * Поток вызывает `Widget::magicValue`, видит, что `cacheValid` равно `false`, выполняет два дорогостоящих вычисления и присваивает их сумму переменной `cachedValue`.
> 
> * В этот момент второй поток вызывает `Widget::magicValue`, также видит, что значение `cacheValid` равно `false`, а потому выполняет те же дорогостоящие вычисления, что и только что завершивший их первый поток. (Этот "второй поток" на самом деле может быть несколькими другими потоками.)

Чтобы справиться с этой проблемой, можно пересмотреть порядок присваиваний значений переменным `cachedValue` и `cacheValid`, но вы вскоре поймете, что (1) вычислять `val1` и `val2` перед тем, как `cacheValid` устанавливается равным `true`, по-прежнему могут несколько потоков, тем самым провалив цель нашего упражнения, и (2) на самом деле все может быть еще хуже:
```c++
class Widget {
	public :
		...
		int magicValue() const
		{
			if(cacheValid) return cachedValue;
			else {
				auto val1 = expensiveComputation1();
				auto val2 = expensiveComputation2();

				cacheValid = true;                  // Часть 1
				return cachedValue = val1 + val2;   // Часть 2
			}
		}
};
```
Представим, что значение `cacheValid` равно `false`. Тогда возможно следующее.

> * Один поток вызывает `Widget::magicValue` и выполняет код до точки, где переменная `cacheValid` устанавливается равной `true`.
>
> * В этот момент второй поток вызывает `Widget::magicValue` и проверяет значение `cacheValid`. Увидев, что оно равно `true`, поток возвращает `cachedValue`, несмотря на то, что первый поток еще не выполнил присваивание этой переменной. Таком образом, возвращенное значение оказывается некорректным.

Для единственной переменной или ячейки памяти, требующей синхронизации, применение [[atomic|std::atomic]] является адекватным решением, но как только у вас имеется две и более переменных или ячеек памяти, которыми надо оперировать как единым целым, вы должны использовать мьютекс. Для `Widget::magicValue` это выглядит следующим образом:
```c++
class Widget
	public:
		int magicValue() const
		{
			std::lock_guard<std::mutex>guard (m);     // Блокировка m
			
			if (cacheValid) return cachedValue;
			else {
				auto val1 = expensiveComputation1();
				auto val2 = expensiveComputation2();

				cachedValue = val1 + val2;
				cacheValid = true;

				return cachedValue;
			}
		}                                            // Разблокирование m

	private :
		mutable std::mutex m;
		mutable int cachedValue;
		mutable bool cacheValid{ false );
);

```
Сейчас данный раздел основывается на предположении, что несколько потоков могут одновременно выполнять константную функцию-член объекта. Если вы пишете константную функцию-член там, где это не так - т.е. там, где вы можете гарантировать, что эта функция-член объекта никогда не будет выполняться более чем одним потоком - безопасность с точки зрения потоков является несущественной. Например, совершенно неважно, являются ли безопасными с точки зрения потоков функции-члены классов, разработанные исключительно для однопоточного применения. В таких случаях вы можете избежать расходов, связанных с мьютексами и [[atomic|std::atomic]], а также побочного эффекта, заключающегося в том, что содержащие их классы становятся некопируемыми и неперемещаемыми. Однако такие сценарии, в которых нет потоков, становятся все более редкими и, вероятно, дальше будут становиться только все более редкими. Безопаснее считать, что константные функции-члены будут участвовать в параллельных вычислениях, и именно поэтому следует гарантировать безопасность таких функций с точки зрения потоков.

> - Делайте константные функции-члены безопасными с точки зрения потоков, если только вы не можете быть уверены, что они гарантированно не будут использоваться в контексте параллельных вычислений.
> 
> -Использование переменных [[atomic|std::atomic]] может обеспечить более высокую по сравнению с мьютексами производительность, но они годятся только для работы с единственной переменной или ячейкой памяти.

