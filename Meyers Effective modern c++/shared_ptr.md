1. [[#Используйте `std shared_ptr` для управления ресурсами путем совместноrо владения]]
2. [[atomic#Особенности типа std shared_ptr (до стандарта C++ 20)|Особенности типа std shared_ptr (до стандарта C++ 20)]]
	1. [[atomic#Атомарные операции над типом std shared_ptr|Атомарные операции над типом std::shared_ptr]] 




# Используйте `std::shared_ptr` для управления ресурсами путем совместноrо владения

Программисты на языках программирования со сборкой мусора показывают пальцами на программистов на С++ и смеются над ними, потому что те озабочены предотвращением утечек ресурсов. "Какой примитив! - издеваются они. - Вы что, застряли в 1960-х годах и в Lisp? Управлять временем жизни ресурсов должны машины, а не люди': Разработчики на С++ не остаются в долгу: "Вы имеете в виду, что единственным ресурсом является память, а время освобождения ресурса должно быть принципиально неопределимо? Спасибо, мы предпочитаем обобщенность и предсказуемость деструкторов!" Впрочем, в нашей браваде есть немного бахвальства. Сборка мусора в действительности достаточно удобна. Почему же не получается взять лучшее из двух миров - систему, которая работает автоматически (как сборка мусора) и к тому же применима ко всем ресурсам и имеет предсказуемое время выполнения (подобно деструкторам)?

Интеллектуальный указатель `std::shared_ptr` представляет собой способ, которым С++11 объединяет эти два мира. Объект, доступ к которому осуществляется через указатели `std::shared_ptr`, имеет время жизни, управление которым осуществляется этими указателями посредством совместного владения. Никакой конкретный указатель `std::shared_ptr` не владеет данным объектом. Вместо этого все указатели `std::shared_ptr`, указывающие на него, сотрудничают для обеспечения гарантии, что его уничтожение произойдет в точке, где он станет более ненужным. Когда последний указатель `std::shared_ptr`, указывающий на объект, прекратит на него указывать (например, из-за того, что этот `std::shared_ptr` будет уничтожен или перенаправлен на другой объект), этот `std::shared_ptr` уничтожит объект, на который он указывал. Как и в случае сборки мусора, клиентам не надо самим беспокоиться об управлении временем жизни объектов, на которые они указывают, но, как и при работе с деструкторами, время уничтожения объекта оказывается строго определенным.

Указатель `std::shared_ptr` может сообщить, является ли он последним указателем, указывающим на ресурс, с помощью счетчика ссылок, значения, связанного с ресурсом и отслеживающего, какое количество указателей `std::shared_ptr` указывает на него. Конструкторы `std::shared_ptr` увеличивают этот счетчик (обычно увеличивают - см. ниже), деструкторы `std::shared_ptr` уменьшают его, а операторы копирующего присваивания делают и то, и другое. (Если `sp1` и `sp2` являются указателями `std::shared_ptr`, указывающими на разные объекты, присваивание `sp1 = sp2;` модифицирует `sp1` так, что он указывает на объект, на который указывает `sp2`. Конечным результатом присваивания является то, что счетчик ссылок для объекта, на который изначально указывал `sp1`, уменьшается, а значение счетчика для объекта, на который указывает `sp2`, увеличивается.) Если `std::shared_ptr` после выполнения декремента видит нулевой счетчик ссылок, это означает, что на ресурс не указывает больше ни один `std::shared_ptr`, так что наш интеллектуальный указатель освобождает этот ресурс.

Наличие счетчиков ссылок влияет на производительность.

> - Размер `std::shared_ptr` в два раза больше размера обычноrо указателя, поскольку данный интеллектуальный указатель содержит обычный указатель на ресурс и другой обычный указатель на счетчик ссылок.
> 
> - Память для счетчика ссылок должна выделяться динамически. Концептуально счетчик ссылок связан с объектом, на который он указывает, однако сам указываемый объект об этом счетчике ничего не знает. В нем нет места для хранения счетчика ссылок. (Приятным следствием этого является то, что интеллектуальный указатель `std::shared_ptr` может работать с объектами любого типа (в том числе встроенных типов).) В [[make_unique#Предпочитайте использование std make_unique и std make_shared непосредственному использованию оператора new|разделе]] поясняется, что можно избежать стоимости динамического выделения при создании указателя `std::shared_ptr` с помощью вызова [[make_shared|std::make_shared]], однако имеются ситуации, когда функция [[make_shared|std::make_shared]] неприменима. В любом случае счетчик ссылок хранится в динамически выделенной памяти.
> 
> - Инкремент и декремент счетчика ссылок должны быть атомарными, поскольку могут присутствовать одновременное чтение и запись в разных потоках. Например, `std::shared_ptr`, указывающий на ресурс в одном потоке, может выполнять свой деструктор (тем самым уменьшая количество ссылок на указываемый им ресурс), в то время как в другом потоке указатель `std::shared_ptr` на тот же объект может быть скопирован (а следовательно, увеличивает тот же счетчик ссылок). Атомарные операции обычно медленнее неатомарных, так что несмотря на то, что обычно счетчики ссылок имеют размер в одно слово, следует рассматривать их чтение и запись как относительно дорогостоящие операции.


Возбудил ли я ваше любопытство, когда написал, что конструкторы `std::shared_ptr` "обычно" увеличивают счетчик ссылок для указываемого объекта? При создании `std::shared_ptr`, указывающего на объект, всегда добавляется еще один интеллектуальный указатель `std::shared_ptr`, так почему же счетчик ссылок может увеличиваться не всегда?

Из-за перемещающего конструирования - вот почему. Перемещающее конструирование указателя `std::shared_ptr` из другого `std::shared_ptr` делает исходный указатель нулевым, а это означает, что старый `std::shared_ptr` перестает указывать на ресурс в тот же момент, в который новый `std::shared_ptr` начинает это делать. В результате изменение значения счетчика ссылок не требуется. Таким образом, перемещение `std::shared_ptr` оказывается быстрее копирования: копирование требует увеличения счетчика ссылок, а перемещение - нет. Это справедливо как для присваивания, так и для конструирования, так что перемещающее конструирование быстрее копирующего конструирования, а перемещающее присваивание быстрее копирующего присваивания.

Подобно [[unique_ptr|std::unique_ptr]], `std::shared_ptr` в качестве механизма удаления ресурса по умолчанию использует `delete`, но поддерживает и пользовательские удалители. Однако дизайн этой поддержки отличается от дизайна для [[unique_ptr|std::unique_ptr]]. Для [[unique_ptr|std::unique_ptr]] тип удалителя является частью типа интеллектуального указателя. Для `std::shared_ptr` это не так:

```c++
auto loggingDel = [](Widget *pw)           // Пользовательский удалитель
{
	makeLogEntry(pw);
	delete pw;
};

std::unique_ptr<                           // Тип удалителя является
	Widget, decltype(loggingDel)           // частью типа указателя
	> upw(new Widget, loggingDel);
    
std::shared_ptr<Widget>                    // Тип удалителя не является
	spw(new Widget, loggingDel);           // частью типа указателя
```

Дизайн `std::shared_ptr` более гибок. Рассмотрим два указателя `std::shared_ptr<Widget>`, каждый со своим пользовательским удалителем разных типов (например, из-за того, что пользовательские удалители определены с помощью лямбда-выражений):

```c++
auto customDeleter1 = [](Widget* pw) {...}      // Пользовательские
auto customDeleter2 = [](Widget* pw) {...}      // удалители
												// разных типов
												
std::shared_ptr<Widget> pw1(new Widget, customDeleter1);
std::shared_ptr<Widget> pw2(new Widget, customDeleter2);
```

Поскольку `pw1` и `pw2` имеют один и тот же тип, они могут быть помещены в контейнер объектов этого типа:

```c++
std::vector<std::shared_ptr<Widget>> vpw {pw1, pw2};
```

Они также могут быть присвоены один другому и переданы функции, принимающей параметр типа `std::shared_ptr<Widget>`. Ни одно из этих действий не может быть выполнено с указателями [[unique_ptr|std::unique_ptr]], которые отличаются типами пользовательских удалителей, так как эти типы влияют на тип самого [[unique_ptr|std::unique_ptr]].

Другим отличием от [[unique_ptr|std::unique_ptr]] является то, что указание пользовательского удалителя не влияет на размер объекта `std::shared_ptr`. Независимо от удалителя объект `std::shared_ptr` имеет размер, равный размеру двух указателей. Это хорошая новость, но она должна привести вас в замешательство. Пользовательские удалители могут быть функциональными объектами, а функциональные объекты могут содержать любое количество данных, а значит, быть любого размера. Как же `std::shared_ptr` может обращаться к удалителю произвольного размера, не используя при этом дополнительной памяти?

А он и не может. Ему приходится использовать дополнительную память, но эта память не является частью объекта `std::shared_ptr`. Она располагается в динамической памяти или, если создатель `std::shared_ptr` воспользуется поддержкой со стороны `std::shared_ptr` пользовательских распределителей памяти, там, где выделит память такой распределитель. Ранее я отмечал, что объект `std::shared_ptr` содержит указатель на счетчик ссылок для объекта, на который он указывает. Это так, но это немного не так, поскольку счетчик ссылок является частью большей структуры данных, известной под названием управляющий блок (`control Blосk`). Управляющий блок имеется для каждого объекта, управляемого указателями `std::shared_ptr`. Управляющий блок в дополнение к счетчику ссылок содержит копию пользовательского удалителя, если таковой был указан. Если указан пользовательский распределитель памяти, управляющий блок содержит и его копию. Управляющий блок может также содержать дополнительные данные, включающие, [[make_unique#Предпочитайте использование std make_unique и std make_shared непосредственному использованию оператора new|как поясняется]], вторичный счетчик ссылок, известный как слабый счетчик, но в данном разделе мы его игнорируем. Мы можем представить память, связанную с объектом `std::shared_ptr<T>`, как имеющую следующий вид:

![[shared_ptr.png]]

Управляющий блок объекта настраивается функцией, создающей первый указатель `std::shared_ptr` на объект. Как минимум это то, что должно быть сделано. В общем случае функция, создающая указатель `std::shared_ptr` на некоторый объект, не может знать, не указывает ли на этот объект некоторый другой указатель `std::shared_ptr`, так что при создании управляющего блока должны использоваться следующие правила:

> - Функция [[make_shared|std::make_shared]] ([[make_unique#Предпочитайте использование std make_unique и std make_shared непосредственному использованию оператора new|см.]]) всегда создает управляющий блок. Она производит новый объект, на который будет указывать интеллектуальный указатель, так что в момент вызова [[make_shared|std::make_shared]] управляющий блок для этого объекта, определенно, не существует.
> 
> - Управляющий блок создается тогда, когда указатель `std::shared_ptr` создается из указателя с исключительным владением (т.е. [[unique_ptr|std::unique_ptr]] или [[auto_ptr|std::auto_ptr]]). Указатели с исключительным владением не используют управляющие блоки, так что никакого управляющего блока для указываемого объекта не существует. (Как часть своего построения `std::shared_ptr` осуществляет владение указываемым объектом, так что указатель с исключительным владением становится нулевым.)
> 
> - Когда конструктор `std::sharedptr` вызывается с обычным указателем, он создает управляющий блок. Если вы хотите создать `std::shared_ptr` из объекта, у которого уже имеется управляющий блок, вы предположительно передаете в качестве аргумента конструктора `std::shared_ptr` или [[weak_ptr|std::weak_ptr]] ([[weak_ptr|см.]]), а не обычный указатель. Конструкторы `std::shared_ptr`, принимающие в качестве аргументов указатели `std::shared_ptr` или [[weak_ptr|std::weak_ptr]], не создают новые управляющие блоки, поскольку могут воспользоваться управляющими блоками, на которые указывают переданные им интеллектуальные указатели.

Следствием из этих правил является то, что создание более одного `std::shared_ptr` из единственного обычного указателя дает вам бесплатный билет для путешествия в неопределенное поведение, поскольку в результате указываемый объект будет иметь несколько управляющих блоков. Несколько управляющих блоков означают несколько счетчиков ссылок, а несколько счетчиков ссылок означают, что объект будет удален несколько раз (по одному для каждого счетчика ссылок). И все это значит, что приведенный ниже код плох, ужасен, кошмарен:

```c++
auto pw = new Widget;               // pw - обычный указатель
...
std::shared_ptr<Widget>
	spw1(pw, loggingDel);           // Создание управляющего блока для *pw
...
std::shared_ptr<Widget>            // Создание второго
	spw2(pw, loggingDel);          // управляющего блока для *pw!
```

Создание обычного указателя `pw`, указывающего на динамически выделенный объект, - плохое решение, поскольку оно противоречит главному совету всей главы: предпочитайте интеллектуальные указатели обычным указателям. Строка, в которой создается `pw`, представляет собой стилистическую мерзость, но она по крайней мере не приводит к неопределенному поведению. 

Далее вызывается конструктор для `spw1`, которому передается обычный указатель, так что этот конструктор создает управляющий блок (и тем самым счетчик ссылок) для того, на что он указывает. В данном случае это `*pw` (т.е. объект, на который указывает `pw`). Само по себе это не является чем-то страшным, но далее с тем же обычным указателем вызывается конструктор для `spw2`, и он также создает управляющий блок (а следовательно, и счетчик ссылок) для `*pw`. Объект `*pw`, таким образом, имеет два счетчика ссылок, каждый из которых в конечном итоге примет нулевое значение, и это обязательно приве­дет к попытке уничтожить объект `*pw` дважды. Второе уничтожение и будет ответственно за неопределенное поведение.

Из этого можно вынести как минимум два урока, касающиеся применения `std::shared_ptr`. Во-первых, пытайтесь избегать передачи обычных указателей конструктору `std::shared_ptr`. Обычной альтернативой этому является применение функции [[make_shared|std::make_shared]], но в примере выше мы использовали пользовательские удалители, а это невозможно при использовании [[make_shared|std::make_shared]]. Во-вторых, если вы вынуждены передавать обычный указатель конструктору `std::shared_ptr`, передавайте непосредственно результат оператора `new`, а не используйте переменную в качестве посредника. Если первую часть кода переписать следующим образом

```c++
std::shared_ptr<Widget>
	spw1(new Widget,             // Непосредственное использование new
	loggingDel);
```

то окажется гораздо труднее создать второй `std::shared_ptr` из того же обычного указателя. Вместо этого, автор кода, создающего `spw2`, естественно, будет использовать в качестве аргумента инициализации `spw1` (т.е. будет вызывать копирующий конструктор `std::shared_ptr`), и это не будет вести ни к каким проблемам:

```c++
std::shared_ptr<Widget>         // spw2 использует тот же
spw2(spw1);                     // управляющий блок, что и spw1
```

Особенно удивительный способ, которым применение переменных с обычными указателями в качестве аргументов конструкторов `std::shared_ptr` может привести к множественным управляющим блокам, включает указатель `this`. Предположим, что наша программа использует указатели `std::shared_ptr` для управления объектами `Widget` и у нас есть структура данных, которая отслеживает объекты `Widget`, которые были обработаны:

```c++
std::vector<std::shared_ptr<Widget>> processedWidgets;
```

Далее, предположим, что `Widget` имеет функцию-член, выполняющую эту обработку:

```c++
class Widget{
	public:
		...
		void process();
};
```

Вот вполне разумно выглядящий подход к написанию `Widget::process`:

```c++
void Widget::process()
{
	...                                    // Обработка Widget
	processedWidgets.emplace_back(this);   // Добавление в список
	                                       // обработанных Widget ;
                                           // это неправильно!
}
```

Комментарий о неправильности кода относится не к использованию [[emplace_back|emplace_back]], а к передаче `this` в качестве аргумента. Этот код будет компилироваться, но он передает обычный указатель (`this`) контейнеру указателей `std::shared_ptr`. Конструируемый таким образом указатель `std::shared_ptr` будет создавать новый управляющий блок для указываемого `Widget` (т.е. для объекта `*this`). Это не выглядит ужасным до тех пор, пока вы не понимаете, что, если имеются указатели `std::shared_ptr` вне функции-члена, которые уже указывают на этот объект `Widget`, вам не избежать неопределенного поведения.

API `std::shared_ptr` включает средство для ситуаций такого рода. Вероятно, его имя - наиболее странное среди всех имен стандартной библиотеки:
[[еnаblе_shared_from_this|std::еnаblе_shared_from_this]]. Это шаблон базового класса, который вы наследуете, если хотите, чтобы класс, управляемый указателями `std::shared_ptr`, был способен безопасно создавать `std::shared_ptr` из указателя `this`. В нашем примере `Widget` будет унаследован от [[еnаblе_shared_from_this|std::еnаblе_shared_from_this]] следующим образом:

```c++
class Widget:public std::enable_shared_from_this<Widget> 
{
	public:
		void process();
};
```

Как я уже говорил, [[еnаblе_shared_from_this|std::еnаblе_shared_from_this]] является шаблоном базового класса. Его параметром типа всегда является имя производного класса, так что класс `Widget` порождается от `std::еnаblе_shared_from_this<Widget>`. Если идея производного класса, порожденного от базового класса, шаблонизированного производным, вызывает у вас головную боль, попытайтесь об этом не думать. Этот код совершенно законный, а соответствующий шаблон проектирования хорошо известен, имеет стандартное имя, хотя и почти такое же странное, как [[еnаblе_shared_from_this|std::еnаblе_shared_from_this]]. Это имя - `Странно повторяющийся шаблон`(The Curiously Recurring Teтplate Pattern - CRTP). 

Шаблон [[еnаblе_shared_from_this|std::еnаblе_shared_from_this]] определяет функцию-член, которая создает `std::shared_ptr` для текущего объекта, но делает это, не дублируя управляющие блоки. Это функция-член `shared_from_this`, и вы должны использовать ее в функциях-членах тогда, когда вам нужен `std::shared_ptr`, который указывает на тот же объект, что и указатель `this`. Вот как выглядит безопасная реализация `Widget::process:

```c++
void Widget::process()
{
	// Как и ранее, обработка Widget
	...
	// Добавляем std::shared_ptr, указывающий на
	// текущий объект, в processedWidgets
	
	processedWidgets.emplace_back(shared_from_this());
}
```

Внутри себя `shared_from_this` ищет управляющий блок текущего объекта и создает новый `std::shared_ptr`, который использует этот управляющий блок. Дизайн функции полагается на тот факт, что текущий объект имеет связанный с ним управляющий блок. Чтобы это было так, должен иметься уже существующий указатель `std::shared_ptr` (например, за пределами функции-члена, вызывающей `shared_from_this`) , который указывает на текущий объект. Если такого `std::shared_ptr` нет (т.е. если текущий объект не имеет связанного с ним управляющего блока), результатом будет неопределенное поведение, хотя обычно `shared_from_this` генерирует исключение.

Чтобы препятствовать клиентам вызывать функции-члены, в которых используется `shared_from_this`, до того как на объект будет указывать указатель `std::shared_ptr`, классы, наследуемые от [[еnаblе_shared_from_this|std::enable_shared_from_this]] , часто объявляют свои конструкторы как `private` и заставляют клиентов создавать объекты путем вызова фабричных функций, которые возвращают указатели `std::shared_ptr`. Например, класс `Widget` может выглядеть следующим образом:

```c++
class Widget: public std::enable_shared_from_this<Widget>
{
public:
								// Фабричная функция, пересылающая
								// аргументы закрытому конструктору :
	template<typename ... Ts>
	static std::shared_ptr<Widget> create(Ts&& ... params);
	...
	void process();             // Как и ранее
	...
private:
								// Конструкторы
};
```

В настоящее время вы можете только смутно припоминать, что наше обсуждение управляющих блоков было мотивировано желанием понять, с какими затратами связано применение `std::shared_ptr`. Теперь, когда мы понимаем, как избегать создания слишком большого количества управляющих блоков, вернемся к нашей первоначальной теме.

Управляющий блок обычно имеет размер в несколько слов, хотя пользовательские удалители и распределители памяти могут его увеличить. Обычная реализация управляющего блока оказывается более интеллектуальной, чем можно было бы ожидать. Она применяет наследование, и при этом даже имеются виртуальные функции. (Все это требуется для того, чтобы обеспечить корректное уничтожение указываемого объекта.) Это означает, что применение указателей `std::shared_ptr` берет на себя также стоимость механизма виртуальной функции, используемой управляющим блоком.

Возможно, после того как вы прочли о динамически выделяемых управляющих блоках, удалителях и распределителях неограниченного размера, механизме виртуальных функций и атомарности работы со счетчиками ссылок, ваш энтузиазм относительно `std::shared_ptr` несколько угас. Это нормально.

Они не являются наилучшим решением для любой задачи управления ресурсами. Но для предоставляемой ими функциональности цена `std::shared_ptr` весьма разумна. В типичных условиях, когда использованы удалитель и распределитель памяти по умолчанию, а `std::shared_ptr` создается с помощью [[make_shared|std::make_shared]], размер управляющего блока составляет около трех слов, и его выделение, по сути, ничего не стоит. (Оно встроено в выделение памяти для указываемого им объекта. [[make_unique#Предпочитайте использование std make_unique и std make_shared непосредственному использованию оператора new|Дополнительная информация]].) Разыменование `std::shared_ptr` не более дорогостояще, чем разыменование обычного указателя. Выполнение операций, требующих работы со счетчиком ссылок (например, копирующий конструктор или копирующее присваивание, удаление) влечет за собой одну или две атомарные операции, но эти операции обычно отображаются на отдельные машинные команды, так что, хотя они могут быть дороже неатомарных команд, они все равно остаются отдельными машинными командами. Механизм виртуальных функций в управляющем блоке обычно используется только однажды для каждого объекта, управляемого указателями `std::shared_ptr`: когда происходит уничтожение объекта.

В обмен на эти весьма скромные расходы вы получаете автоматическое управление временем жизни динамически выделяемых ресурсов. В большинстве случаев применение `std::shared_ptr` значительно предпочтительнее, чем ручное управление временем жизни объекта с совместным владением. Если вы сомневаетесь, можете ли вы позволить себе использовать `std::shared_ptr`, подумайте, точно ли вам нужно обеспечить совместное владение. Если вам достаточно или даже может быть достаточно исключительного владения, лучшим выбором является [[unique_ptr|std::unique_ptr]]. Его профиль производительности близок к таковому для обычных указателей, а "обновление" [[unique_ptr|std::unique_ptr]] до `std::shared_ptr` выполняется очень легко, так как указатель `std::shared_ptr` может быть создан из указателя `std::unique_ptr`.

Обратное неверно. После того как вы включили управление временем жизни ресурса с помощью `std::shared_ptr`, обратной дороги нет. Даже если счетчик ссылок равен единице, нельзя вернуть владение ресурсом для того, чтобы, скажем, им управлял [[unique_ptr|std::unique_ptr]]. Контракт владения между ресурсом и указателями `std::shared_ptr`, которые указывают на ресурс, написан однозначно - "пока смерть не разлучит нас': Никаких разводов и раздела имущества не предусмотрено.

Есть еще кое-что, с чем не могут справиться указатели `std::shared_ptr`, - массивы. Это еще одно их отличие от указателей [[unique_ptr|std::unique_ptr]]. Класс `std::shared_ptr` имеет API, предназначенное только для работы с указателями на единственные объекты. Не существует `std::shared_ptr<T[]>`. Время от времени "крутые" программисты натыкаются на мысль использовать `std::shared_ptr<T>` для указания на массив, определяя пользовательский удалитель для выполнения освобождения массива (т.е. `delete[]`). Это можно сделать и скомпилировать, но это ужасная идея. С одной стороны, класс `std::shared_ptr` не предоставляет оператор `operator[]`, так что индексирование указываемого массива требует неудобных выражений с применением арифметики указателей. С другой стороны, `std::shared_ptr` поддерживает преобразование указателей на производные классы в указатели на базовые классы, которое имеет смысл только для одиночных объектов, но при применении к массивам оказывается открытой дырой в системе типов. (По этой причине API `std::unique_ptr<T[]>` запрещает такие преобразования.) Что еще более важно, учитывая разнообразие альтернатив встроенным массивам в С++11 (например, [[Array|std::array]], [[vector|std::vector]], [[string|std::string]]), объявление интеллектуального указателя на тупой массив всегда является признаком плохого проектирования.

> - `std::shared_ptr` предоставляет удобный подход к управлению временем жизни произвольных ресурсов, аналогичный сборке мусора.
> 
> - По сравнению с [[unique_ptr|std::unique_ptr]] объекты `std::shared_ptr` обычно в два раза больше, привносят накладные расходы на работу с управляющими блоками и требуют атомарной работы со счетчиками ссылок.
> 
> - Освобождение ресурсов по умолчанию выполняется с помощью оператора `delete`, однако поддерживаются и пользовательские удалители. Тип удалителя не влияет на тип указателя `std::shared_ptr`.
> 
> - Избегайте создания указателей `std::shared_ptr` из переменных, тип которых - обычный встроенный указатель.

# Особенности типа std::shared_ptr (до стандарта C++ 20)

см. [[atomic#Особенности типа std shared_ptr (до стандарта C++ 20)|Особенности типа std::shared_ptr (до стандарта C++ 20)]]


