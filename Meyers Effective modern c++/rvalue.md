
[[#Ссылки rvalue C++11]]
[[#Rvalue - ссылки, семантика перемещений и прямая передача]]
1. [[template значение|Категории значений]] Б
	1. [[#Традиционные l- и r-значения|Традиционные l- и r-значения]] Б.1
		1. [[template значение#Преобразования l-значений в r-значения|Преобразования l-значений в r-значения]] Б.1.1
	2. [[template значение#Категории значений, начиная с C++11|Категории значений, начиная с C++11]] Б.2
		2. [[template значение#Временная материализация|Временная материализация]]  Б.2.1
	3. [[template значение#Проверка категорий значений с помощью decltype|Проверка категорий значений с помощью decltype]] Б.3
	4. [[template значение#Ссылочные типы|Ссылочные типы]] Б.4
	5. [[template значение#gl-значение|gl-значение]]
	6. [[template значение#pr-значения|pr-значения]]
	7. [[template значение#x-значения|x-значения]]
	8. [[template значение#l-значение|l-значение]]
	9. [[template значение#r-значения|r-значения]]

# Ссылки rvalue C++11

Наиболее важной особенностью С++11, вероятно, является семантика перемещения, а основой семантики перемещения является отличие **rvаlue**-выражений от lvаluе-выражений. Поэтому **rvalue** указывают объекты, которые могут быть перемещены, в то время как **lvalue** в общем случае перемещены быть не могут. Концептуально (хотя и не всегда на практике), **rvalue** соответствуют временным объектам, возвращаемым из функций, в то время как **lvalue** соответствуют объектам, на которые вы можете ссылаться по имени, следуя указателю или **lvalue**-ссылке.

Полезной эвристикой для выяснения, является ли выражение **lvalue**, является ответ на вопрос, можно ли получить его адрес. Если можно, то обычно это **lvalue**. Если нет, это обычно **rvalue**. Приятной особенностью этой эвристики является то, что она помогает помнить, что тип выражения не зависит от того, является ли оно **lvalue** или **rvalue**. Иначе говоря, для данного типа **Т** можно иметь как **lvalue** типа **Т**, так и **rvalue** типа **Т**. Особенно важно помнить это, когда мы имеем дело с параметром **rvalue** ссылочного типа, поскольку сам по себе параметр является **lvalue**:
```c++
class Widget {
	public:
		Widget (Widqet&& rhs); // rhs является lvalue, хотя
								//и имеет ссылочный тип rvalue
};
```

Здесь совершенно корректным является взятие адреса `rhs` в перемещающем конструкторе `Widget`, так что `rhs` представляет собой **lvalue**, несмотря на то что его тип - ссылка **rvalue**. (По сходным причинам все параметры являются **lvalue**.)
```c++
void someFunc (Widget w) ;   // Параметр w функции someFunc
							 //передается по значению
							 
Widget wid;                  //wid - объект класса Widget

someFunc (wid) ;             //В этом вызове someFunc w
							// является копией wid, созданной
							// копирующим конструктором
							
someFunc (std::move(wid));   // В этом вызове SomeFunc w
							 // является копией wid, созданной
							 // перемещающим конструктором
```

Копии **rvalue** в общем случае конструируются перемещением, в то время как копии **lvalue** обычно конструируются копированием. Следствием является то, что если вы зна­ете только то, что объект является копией друrого объекта, то невозможно сказать, на­сколько дорогостоящим является создание копии. В приведенном выше коде, например, нет возможности сказать, насколько дорогостоящим является создание параметра `w`, без знания того, какое значение передано функции someFunc - **rvalue** или **lvalue**. (Вы также должны знать стоимости перемещения и копирования `Widget`.)

В вызове функции выражения, переданные в источнике вызова, являются аргументами функции. Эти аргументы используются для инициализации параметров функции. В первом вызове someFunc, показанном выше, аргументом является `wid`. Во втором вызове аргументом является `std ::move(wid)`. В обоих вызовах параметром является `w`. Разница между аргументами и параметрами важна, поскольку параметры являются **lvalue**, но аргументы, которыми они инициализируются, могут быть как **rvalue**, так и **lvalue**. Это особенно актуально во время прямой передачи, при которой аргумент, переданный функ­ции, передается другой функции так, что при этом сохраняется его "правосторонность" или "левосторонность".

Автоматическое определение типа со значениями **lvalue** и **rvalue**:
```c++
int x = 0; // `x` – lvalue типа `int`
int& xl = x; // `xl` – lvalue типа `int&`
int&& xr = x; // Ошибка компиляции: `x` – lvalue
int&& xr2 = 0; // `xr2` – lvalue типа `int&&`
auto& al = x; // `al` – lvalue типа `int&`
auto&& al2 = x; // `al2` – lvalue типа `int&`
auto&& ar = 0; // `ar` – lvalue типа `int&&`
```

# Rvalue - ссылки, семантика перемещений и прямая передача

На первый взгляд, семантика перемещения и прямой передачи кажется довольно простой.

> - **Семантика перемещения** позволяет компиляторам заменять дорогостоящие операции копирования менее дорогими перемещениями. Так же, как копирующие конструкторы и копирующие операторы присваивания дают вам контроль над тем, что означает копирование объектов, так и перемещающие конструкторы и перемещающие операторы присваивания предоставляют контроль над семантикой перемещения. Семантика перемещения позволяет также создавать типы, которые могут только перемещаться, такие как [[unique_ptr|std::unique_ptr]], [[future|std::future]] или [[thread#std::thread|std::thread]].
> 
> - **Прямая передача** делает возможным написание шаблонов функций, которые принимают произвольные аргументы и передают их другим функциям так, что целевые функции получают в точности те же аргументы, что и переданные исходным функциям. 
 

[[rvalue|Rvаluе]]-ссылки представляют собой тот клей, который соединяет две эти довольно разные возможности. Это базовый механизм языка программирования, который делает возможными как семантику перемещения, так и прямую передачу.

С ростом опыта работы с этими возможностями вы все больше понимаете, что ваше первоначальное впечатление было основано только на пресловутой вершине айсберга. Мир семантики перемещения, прямой передачи и [[rvalue|rvalue]]-ссылок имеет больше нюансов, чем кажется на первый взгляд. Например, [[move|std::move]] ничего не перемещает, а прямая передача оказывается не совсем прямой. Перемещающие операции не всеrда дешевле копирования, а когда и дешевле, то не всегда настолько, как вы думаете; кроме того, они не всегда вызываются в контексте, где перемещение является корректным. Конструкция `type&&` не всегда представляет [[rvalue|rvalue]]-ccылкy.

В этой главе особенно важно всегда иметь в виду, что параметр всегда является [[rvalue|lvalue]], даже если ero тип - [[rvalue|rvalue]]-ccылкa. Иными словами, в фрагменте 
```c++
void f(Widget&& w);
```

параметр `w` представляет собой [[rvalue|lvalue]], несмотря на то что его тип - [[rvalue|rvalue]]-ссылка на `Widget`. (Если это вас удивляет, вернитесь к обзору [[rvalue|lvalue и rvalue]], который содержится во введении.)
