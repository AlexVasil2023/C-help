# Вывод типа auto

Если вы прочли раздел о выводе типов шаблонов, вы знаете почти все, что следует
знать о выводе типа [[auto|auto]], поскольку за одним любопытным исключением вывод типа [[auto|auto]] представляет собой вывод типа шаблона. Но как это может быть? Вывод типа ша­блона работает с шаблонами, функциями и параметрами, а [[auto|auto]] не имеет дела ни с одной из этих сущностей.
Да, это так, но это не имеет значения. Существует прямая взаимосвязь между выводом типа шаблона и выводом типа [[auto|auto]]. Существует буквальное алгоритмическое преоб­разование одного в другой.
В предыдущем разделе вывод типа шаблона пояснялся с использованием обобщенного шаблона функции
```c++
template<typename Т>
void f(ParamType param) ;
```
и обобщенного вызова
```c++
f(expr);                        // Вызов f с некоторым выражением
```
При вызове `f` компиляторы используют [[expr|expr]] для вывода типов `T` и `ParamType`. Когда переменная объявлена с использованием ключевого слова [[auto|auto]], оно играет роль `Т` в шаблоне, а спецификатор типа переменной действует как `ParamType`. Это проще показать, чем описать, так что рассмотрим следующий пример:
```c++
auto х = 27;
```
Здесь спецификатором типа для `х` является [[auto|auto]] само по себе. С другой стороны, в объ­ явлении
```c++
const auto сх = х;
```
спецификатором типа является `const auto`. А в объявлении
```c++
const auto& rx = х;
```
спецификатором типа является `const auto &`. Для вывода типов для `х`, `сх` и `rx` в приведенных примерах компилятор действует так, как если бы для каждого объявления имелся шаблон, а также вызов этого шаблона с соответствующим инициализирующим выражением:
```c++
template<typename Т>                          // Концептуальный шаблон для
void func_for_х(Т param);                     // вывода типа х

func_for_x(27);                               // Концептуальный вызов : выве-
                                              // денный тип param является
                                              // типом х

template<typename Т>                          // Концептуальный шаблон для
void func_for_cx(const Т param);              // вывода типа сх

func_for_cx(x);                               // Концептуальный вызов : выве-
                                              // денный тип param является
                                              // типом СХ

template<typename Т>                          // Концептуальный шаблон для
void func_for_rx(const Т& param);             // вывода типа rx

func_for_rx(x);                               // Концептуальный вызов : выве-
                                              // денный тип param является
                                              // типом rx
```
Как я уже говорилось, вывод типов для [[auto|auto]] представляет собой (с одним исключением, которое мы вскоре рассмотрим) то же самое, что и вывод типов для шаблонов.
[[Вывод типа шаблона|Вывод типов шаблонов]] был разделен на три случая, основанных на характеристиках `ParamType`, спецификаторе типа `param` в обобщенном шаблоне функции. В объявлении переменной с использованием [[auto|auto]] спецификатор типа занимает место `ParamType`, так что у нас опять имеются три случая.

> 1. Спецификатор типа представляет собой ссылку или указатель, но не универсальную ссылку.
> 2. Спецификатор типа представляет собой универсальную ссылку.
> 3. Спецификатор типа не является ни ссылкой, ни указателем.

Мы уже встречались со случаями 1 и 3:
```c++
auto х = 27;                // Случай 3 (х не указатель и не ссылка)
const auto сх = х;          // Случай 3 (сх не указатель и не ссыпка)
const auto& rx = х;         // Случай 1 (rx - неуниверсальная ссылка)
```
Случай 2 работает, как и ожидалось:
```c++
auto&& urefl = х;           // х - int и lvalue, так что тип urefl - int&
auto&& uref2 = сх;          // сх - const int и lvalue, так что тип
                            // uref2 - const int&
auto&& uref3 = 27;          // 2 7 - int и rvalue, так что тип
                            // uref 3 - int&&
```
[[Вывод типа шаблона|Раздел "Вывод типа шаблона"]] завершился обсуждением того, как имена массивов и функций превраща­ются в указатели для спецификаторов типа, не являющихся ссылками. То же самое происходит и при выводе типа **auto**:
```c++
const char name[] =          // Тип name - const char[13] 
				"R. N. Briggs";
auto arr1 = name;            // Тип arr1 - const char*
auto& arr2 = name;           // Тип arr2 - const char(&)[13]

void someFunc (int, douЬle); // someFunc - функция, ее тип
							 // void (int, douЬle)

auto func1 = someFunc;       // Тип func1 - void(*)(int, douЬle)
auto &func2 = someFunc;      // Тип func2 - void(&)(int, douЬle)
```
Как можно видеть, вывод типа **auto** работает подобно выводу типа шаблона. По сути это две стороны одной медали.
Они отличаются только в одном. Начнем с наблюдения, что если вы хотите объявить `int` с начальным значением 27, С++98 предоставляет вам две синтаксические возможности:
```c++
int x1 = 27;
int х2(27);
```
С++ 11, поддерживая старые варианты инициализации, добавляет собственные:
```c++
int х3 = {27};
int х4{27};
```
Таким образом, у нас есть четыре разных синтаксиса, но результат один: переменная типа `int` со значением 27.
Но, как поясняется в разделе 2.1 , объявление переменных с использованием ключевого слова **auto** вместо  фиксированных типов обладает определенными преимуществами, поэтому в приведенных выше объявлениях имеет смысл заменить `int` на `auto`. Простая замена текста приводит к следующему коду:
```c++
auto x1 = 27;
auto х2(27);
auto х3 = {27};
auto х4{27};
```
Все эти объявления компилируются, но их смысл оказывается не тем же, что и у объяв­лений, которые они заменяют. Первые две инструкции в действительности объявляют переменную типа `int` со значением 27. Вторые две, однако, определяют переменную типа `std::initializer list <int>`, содержащую единственный элемент со значением 27!
```c++
auto x1 = 27;                        // Тип int, значение 27
auto х2(27);                         // То же самое
auto хЗ = {27};                      // std::initializer_list<int>, значение (27}
auto х4{27};                         // То же самое
```
Это объясняется специальным правилом вывода типа для `auto`. Когда инициализатор для переменной, объявленной как `auto`, заключен в фигурные скобки, выведенный тип - [[initializer_list|std::initializer_list]]. Если такой тип не может быть выведен (например, из-за того, что значения в фигурных скобках относятся к разным типам), код будет отвергнут:
```c++
auto х5 = {1, 2, 3.0};               // Ошибка ! Невозможно вывести Т
                                     // для std::initializer_list<T>
```
Как указано в комментарии, в этом случае вывод типа будет неудачным, но важ­но понимать, что на самом деле здесь имеют место два вывода типа. Один из них вытекает из применения ключевого слова `auto`: тип `х5` должен быть выведен. Поскольку инициализатор `х5` находится в фигурных скобках, тип `х5` должен быть выведен как [[initializer_list|std::initializer_list]]. Но [[initializer_list|std::initializer_list]] - это шаблон. Конкретизация представляет собой создание `std::initializer_list<T>` с некоторым типом `Т`, а это означает, что тип `Т` также должен быть выведен. Такой вывод относится ко второй раз­новидности вывода типов - выводу типа шаблона. В данном примере этот второй вывод неудачен, поскольку значения в фигурных скобках не относятся к одному и тому же типу.
Рассмотрение инициализаторов в фигурных скобках является единственным отличием вывода типа `auto` от вывода типа шаблона. Когда объявленная с использованием ключевого слова `auto` переменная инициализируется с помощью инициализатора в фигурных скобках, выведенный тип представляет собой конкретизацию [[initializer_list|std::initializer_list]]. Но если тот же инициализатор передается шаблону, вывод типа оказывается неудачным, и код отвергается:
```c++
auto х = {11, 23, 9};                 // Тип х - std::initializer_list<int>

template<typename Т>                  // Объявление шаблона с параметром
void f(Т param);                      // эквивалентно объявлению х

f({11, 23, 9)}                        // Ошибка вывода типа для Т
```
Однако, если вы укажете в шаблоне, что `раrаm` представляет собой `std::initializer_list<T>` для некоторого неизвестного `T`, вывод типа шаблона сможет определить, чем является `Т`:
```c++
template<typename Т>
void f(std::initializer_list<T> initList);

f({11, 23, 9});                        // Вывод int в качестве типа Т, а тип
                                       // initList - std::initializer_list<int>
```
Таким образом, единственное реальное различие между выводом типа **auto** и [[Вывод типа шаблона|выводом типа шаблона]] заключается в том, что **auto** предполагает, что инициализатор в фигурных скобках представляет собой [[initializer_list|std::initializer_list]], в то время как вывод типа шаблона этого не делает.
Вы можете удивиться, почему вывод типа **auto** имеет специальное правило для ини­циализаторов в фигурных скобках, в то время как вывод типа шаблона такого правила не имеет. Увы, я не в состоянии найти убедительное объяснение. Но "закон есть закон", и это означает, что вы должны помнить, что если вы объявляете переменную с использованием ключевого слова **auto** и инициализируете ее с помощью инициализатора в фигурных скобках, то выводимым типом всегда будет [[initializer_list|std::initializer_list]]. Особенно важно иметь это в виду, если вы приверженец философии унифицированной инициализации - заключения и нициализирующих значе­ний в фигурные скобки как само собой разумеющегося стиля. Классической ошибкой в С++11 является случайное объявление переменной [[initializer_list|std::initializer_list]] там, где вы намеревались объявить нечто иное. Эта ловушка является одной из причин, по которым некоторые разработчики используют фигурные скобки в инициализаторах только тог­да, когда обязаны это делать. (Когда именно вы обязаны так поступать, мы рассмотрим в [[Переход к c++11, c++14#Различие между { } и ( ) при создании объектов|разделе]]).
Что касается С++11, то на этом история заканчивается, но для С++14 это еще не конец. С++14 допускает применение [[auto|auto]] для указания того, что возвращаемый тип функ­ции должен быть выведен (см. [[decltуре|decltуре]]), а кроме того, [[Лямбда-выражения|Лямбда-выражения]] С++14 могут использовать **auto** в объявлениях параметров. Однако такое применение **auto** использует вывод типа шаблона, а не вывод типа **auto**. Таким образом, функция с возвращаемым типом **auto**, которая возвращает инициализатор в фигурных скобках, компилироваться не будет:
```c++
auto createInitList()
{
	return {1, 2, 3);                   // Ошибка : невозможно вывести
	                                    // ТИП ДЛЯ { 1 , 2, 3 )
}
```
То же самое справедливо и тогда, когда **auto** используется в спецификации типа парамет­ра в [[Лямбда-выражения|Лямбда-выражении]] С++14:
```c++
std::vector<int> v;

auto resetV = [&v](const auto& newValue) {v = newValue;};        // C++l4

resetV ({1, 2, З});              // Ошибка : невозможно вывести
                                 // ТИП ДЛЯ {1, 2, 3)
```

* Вывод типа [[auto|auto]] обычно такой же, как и [[Вывод типа шаблона|вывод типа шаблона]], но вывод типа [[auto|auto]], в отличие от [[Вывод типа шаблона|вывода типа шаблона]], предполагает, что инициализатор в фигурных скобках представляет [[initializer_list|std::initializer_list]].
* [[auto|auto]] в возвращаемом типе функции или параметре [[Лямбда-выражения|Лямбда-выражения]] влечет применение [[Вывод типа шаблона|вывода типа шаблона]], а не вывода типа **auto**.

