# Используйте std::move для rvalue - ссылок, а std::forward для универсальных ссылок 

[[rvalue|Rvаluе-ссылки]] связываются только с объектами, являющимися кандидатами для перемещения. Если у вас есть параметр, представляющий собой [[rvalue|rvalue-ссылку]], вы знаете, что связанный с ним объект может быть перемещен:
```c++
class Widget {
Widget(Widget&& rhs);               // rhs, определенно, ссылается на
									// объект, который можно перемещать
};
```

В этом случае вы захотите передавать подобные объекты другим функциям таким образом, чтобы разрешить им использовать преимущества "правосторонности". Способ, которым это можно сделать, - привести параметры, связываемые с такими объектами, к [[rvalue|rvalue]]. Как поясняется [[move#Азы std move и std forward|тут]], [[move|std::move]] не просто это делает, это та задача, для которой создана эта функция:

```c++
class Widget {
	public :
		Widget(Widget&& rhs)            // rhs является rvalue-ccылкoй
			: name(std::move(rhs.name))
			, р(std::move(rhs.р))
		{ ... }
		...	
	private:
		std::string name;
		std::shared_ptr<SomeDataStructure>р;
};
```
С другой стороны, [[Отличие универсальных ссылок от rvalue-ссылок|универсальная ссылка]] может быть связана с объектом, который разрешено перемещать. Универсальные ссылки должны быть приведены к [[rvalue|rvalue]] только тогда, когда они были инициализированы с помощью [[rvalue|rvalue]], [[move#Азы std move и std forward|именно это и делает функция std::forward]]:

```c++
class Widget{
	public:
		template<typename Т>
		void setName(T&& newName)                // newName является
		{name = std::forward<Т>(newName); }      // универсальной ссылкой
};
```

Короче говоря, [[rvalue|rvalue-ссылки]] при их передаче в другие функции должны быть безусловно приведены к [[rvalue|rvalue]] (с помощью [[move|std::move]]), так как они всегда связываются с [[rvalue|rvalue]], а универсальные ссылки должны приводиться к при их передаче условно (с помощью [[forward|std::forward]]), поскольку они только иногда связываются с [[rvalue|rvalue]].

[[move#Азы std move и std forward|Тут]] поясняется, что можно добиться верного поведения [[rvalue|rvalue-ссылок]] и с помощью [[forward|std::forward]], но исходный текст при этом становится многословным, подверженным ошибкам и неидиоматичным, так что вы должны избегать применения [[forward|std::forward]] с [[rvalue|rvаluе-ссылкам]]. Еще худшей является идея применения [[move|std::move]] к универсальным ссылкам, так как это может привести к неожиданному изменению значений [[rvalue|lvalue]] (например, локальных переменных):

```c++
class Widget{
	public:
		template<typename Т>
		void setName(T&& newName)          // Универсальная ссылка.
		{ name = std::move(newName); }     // Компилируется, но это
										   // очень плохое решение!		
		...

	private:
		std::string name;
		std::shared_ptr<SomeDataStructure>р;
};

std::string getWidgetName();               // Фабричная функция
Widget w;
auto n = getWidgetName();                  // n локальная переменная
w.setName(n);                              // Перемещение n в w!
                                           // Значение n теперь неизвестно
```

Здесь локальная переменная `n` передается функции `w.setName`. Вызывающий код можно простить за предположение о том, что эта функция по отношению к `n` является операцией чтения. Но поскольку `setName` внутренне использует [[move|std::move]] для безусловного приведения своего ссылочного параметра к [[rvalue|rvalue]], значение `n` может быть перемещено в `w.name`, и `n` вернется из вызова `setName` с неопределенным значением. Этот вид поведения может привести программиста к отчаянию - если не к прямому насилию.

Можно возразить, что `setName` не должен был объявлять свой параметр как универсальную ссылку. Такие ссылки не могут быть константными ([[Отличие универсальных ссылок от rvalue-ссылок|см.]]), но `setName`, безусловно, не должен изменять свой параметр. Вы могли бы указать, что если перегрузить `setName` для константных значений [[rvalue|lvalue и rvalue]], то этой проблемы можно было бы избежать, например, таким образом:

```c++
class Widget {
	public :
		void setName(const std::string& newName)    // Устанавливается
		{ name = newName; }                         // из const lvalue

		void setName (std::string&& newName)        // Устанавливается
		{ std::move(newName); }                     // из rvalue
};
```

В данном случае это, безусловно, сработает, но у метода есть и недостатки. Во-первых, требуется вводить исходный текст большего размера (две функции вместо одного шаблона). Во-вторых, это может быть менее эффективным. Например, рассмотрим следующее применение `setName`:

```c++
w.setName("Adela Nova k");
```

При наличии версии `setName`, принимающей универсальную ссылку, функции `setName` будет передан строковый литерал `"Adela Nova k"`, в котором он будет передан оператору присваивания для [[string|std::string]] внутри `w`. Таким образом, член-данные `name` объекта `w` будет присвоен непосредственно из строкового литерала; никакого временного объекта [[string|std::string]] создаваться не будет. Однако в случае перегруженных версий `setName` будет создан временный объект [[string|std::string]], с которым будет связан параметр функции `setName`, и этот временный объект [[string|std::string]] будет перемещен в член-данные объекта `w`. Таким образом, вызов `setName` повлечет за собой выполнение одного конструктора [[string|std::string]] (для создания временного объекта), одного перемещающего оператора присваивания [[string|std::string]] (для перемещения `newName` в `w.name`) и одного деструктора [[string|std::string]] (для уничтожения временного объекта). Это практически наверняка более дорогостоящая последовательность операций, чем вызов только одного оператора присваивания [[string|std::string]], принимающего указатель `const char*`. Дополнительная стоимость может варьироваться от реализации к реализации, и стоит ли беспокоиться о ней, зависит от приложения и библиотеки; однако, скорее всего, в ряде случаев замена шаблона, получающего универсальную ссылку, парой функций, перегруженных для [[rvalue|lvalue и rvalue-ccылoк]], приведет к дополнительным затратам времени выполнения.

Однако наиболее серьезной проблемой с перегрузкой для [[rvalue|lvalue и rvalue]] является не объем или идиоматичность исходного кода и не производительность времени выполнения. Это - плохая масштабируемость проекта. `Widget::setName` принимает только один параметр, так что необходимы только две перегрузки. Но для функций, принимающих большее количество параметров, каждый из которых может быть как [[rvalue|lvalue, так и rvalue]], количество перегрузок растет в соответствии с показательной функцией: `п` параметров требуют 2-х перегрузок. И это еще не самый худший случай. Некоторые функции (на самом деле - шаблоны функций) принимают неограниченное количество параметров, каждый из которых может быть как [[rvalue|lvalue, так и rvalue]]. Типичными представителями таких функций являются [[make_shared|std::make_shared]] и, начиная с С++14, [[make_unique|std::make_unique]]. Попробуйте написать объявления их наиболее часто используемых перегрузок:

```c++
template<class Т, class ... Args>             // Из стандарта C++11
shared_ptr<T> make_shared(Args&& ... args);

template<class Т, class ... Args>             // Из стандарта С++14
unique_ptr<T> make_unique(Args&& ... args);
```

Для функций наподобие указанных перегрузка для [[rvalue|lvalue и rvalue]] не является приемлемым вариантом: единственным выходом является применение универсальных ссылок. А внутри таких функций, уверяю вас, к универсальным ссылкам при их передаче другим функциям следует применять [[forward|std::forward]]. Вот то, что вы должны делать.

Ну хорошо, обычно должны. В конечном итоге. Но не обязательно изначально. В некоторых случаях вы захотите использовать привязку объекта к [[rvalue|rvalue-ccылкe]] или универсальной ссылке более одного раза в одной функции, и вы захотите гарантировать, что перемещения не будет, пока вы явно не укажете его выполнить. В этом случае вы захотите применить [[move|std::move]] (для [[rvalue|rvalue-ccылoк]]) или [[forward|std::forward]] (для универсальных ссылок) только к последнему использованию ссылки, например:

```c++
template<typename Т>                        // text - универсальная
void setSignText(T&& text)                  // ссылка
{
	sign.setText(text);                     // Используем text, но не
										    // изменяем его

auto now = std::chrono::system_clock::now(); // Получение текущего времени

signHistory.add(now, std::forward<T>(text)); // Условное приведение
                                             // text к rvalue
```

Здесь мы хотим гарантировать, что значение `text` не изменится вызовом `sign.setText`, поскольку мы хотим использовать это значение при вызове `signHistory.add`. Следовательно, [[forward|std::forward]] применяется только к последнему использованию универсальной ссылки.

Для [[move|std::move]] применяются те же рассуждения (т.е. надо применить [[move|std::move]] к [[rvalue|rvalue-ccылкe]] только при ее последнем использовании), но важно отметить, что в некоторых редких случаях вы захотите вызвать [[move_ if_noexcept|std::move_ if_noexcept]] вместо [[move|std::move]]. Чтобы узнать, когда и почему, [[noexcept|см.]].

Если вы имеете дело с функцией, осуществляющей возврат по значению, и возвращаете объект, привязанный к [[rvalue|rvalue-ccылкe]] или универсальной ссылке, вы захотите применять [[move|std::move или std::forward]] при возврате ссылки. Чтобы понять, почему, рассмотрим функцию operator+ для сложения двух матриц, где о левой матрице точно известно, что она является [[rvalue|rvalue]] (а следовательно, может повторно использовать свою память для хранения суммы матриц):

```c++
мatrix                                       // Возврат по значению
operator+ (мatrix&& lhs, const Matrix& rhs)
{
	lhs += rhs;
    return std::move(lhs);                  // Перемещение lhs в
}                                           // возвращаемое значение
```

С помощью приведения `lhs` к [[rvalue|rvalue]] в инструкции `return` (с помощью [[move|std::move]]) `lhs` будет перемещен в местоположение возвращаемого функцией значения. Если опустить вызов [[move|std::move]],

```c++
Matrix                                     // Как и ранее above
operator+ (Matrix&& lhs, const Matrix& rhs)
{
	lhs += rhs ;
	returп lhs;                            // Копирование lhs в
}                                          // возвращаемое значение
```

то тот факт, что `lhs` представляет собой [[rvalue|lvalue]], заставит компиляторы вместо перемещения копировать его в местоположение возвращаемого функцией значения. В предположении, что тип `Matrix` поддерживает перемещающее конструирование, более эффективное, чем копирующее, применение [[move|std::move]] в инструкции `return` дает более эффективный код.

Если тип `Matrix` не поддерживает перемещения, приведение его к [[rvalue|rvalue]] не повредит, поскольку [[rvalue|rvalue]] будет просто скопировано копирующим конструктором `Matrix` ([[move#Азы std move и std forward|см.]]). Если `Matrix` позже будет переделан так, что станет поддерживать перемещение, `operator+` автоматически использует данное преимущество при следующей компиляции. В таком случае ничто не будет потеряно (и возможно, многое будет приобретено) при применении [[move|std::move]] к [[rvalue|rvаluе-ссылкам]], возвращаемым из функций, которые осуществляют возврат по значению.

Для универсальных ссылок и [[forward|std::forward]] ситуация схожа. Рассмотрим шаблон функции `reduceAndCopy`, который получает возможно сократимую дробь `Fraction`, сокращает ее, а затем возвращает копию сокращенной дроби. Если исходный объект представляет собой [[rvalue|rvalue]], его значение должно быть перенесено в возвращаемое значение (избегая тем самым стоимости создания копии), но если исходный объект - [[rvalue|lvalue]], должна быть создана фактическая копия:

```c++
template<typeпameТ>
Fraction                                    // Возврат по значению
reduceAndCopy(T&& frac)                     // Универсальнал ссылка
{
	frac.reduce();
	return std::forward<T>(frac);           // Перемещение rvalue и
}                                           // копирование lvalue в
										    // возвращаемое значение
```

Если опустить вызов [[forward|std::forward]], `frac` будет в обязательном порядке копироваться в возвращаемое значение `reduceAndCopy`.

Некоторые программисты берут приведенную выше информацию и пытаются распространить ее на ситуации, в которых она неприменима. Они рассуждают следующим образом: "если использование [[move|std::move]] для параметра, являющегося [[rvalue|rvаluе-ссылкой]] и копируемого в возвращаемое значение, превращает копирующий конструктор в перемещающий, то я могу выполнить ту же оптимизацию для возвращаемых мною локальных переменных". Другими словами, они считают, что если дана функция, возвращающая локальную переменную по значению, такая, как следующая:

```c++
Widget makeWidget()             // "Коnирующал" версил makeWidget
{
	Widqet w;                   // Переменная
								// Настройка w
	
	return w;                   // "Копирование" w в возвращаемое значение
}
```

то они могут "оптимизировать" ее, превратив "копирование" в перемещение:

```c++
Widget makeWidget()            // Перемещающая версия makeWidget
{
	Widget w ;
	...
	return std::move(w);       // Перемещение w в возвращаемое
}							   // значение ( не делайте этого ! )
```

Мое обильное использование кавычек должно подсказать вам, что эти рассуждения не лишены недостатков. Но почему? Да потому что Комитет по стандартизации уже прошел этот путь и давно понял, что "копирующая" версия `makeWidget` может избежать необходимости копировать локальную переменную `w`, если будет создавать ее прямо в памяти, выделенной для возвращаемого значения функции. Это оптимизация, известная как оптимизация возвращаемого значения (`return value optimization - RVO`) и с самого начала благословленная стандартом С++.

Формулировка такого благословения - сложное дело, поскольку хочется разрешить такое отсутствие копирования только там, где оно не влияет на наблюдаемое поведение программы. Перефразируя излишне сухой текст стандарта, это благословение на отсутствие копирования (или перемещения) локального объекта в функции, выполняющей возврат по значению, дается компиляторам, если тип локального объекта совпадает с возвращаемым функцией и локальный объект представляет собой возвращаемое значение. С учетом этого вернемся к "копирующей" версии `makeWidget`:

```c++
Widget makeWidget()             // "Копирующая" версия makeWidget
{
	Widget w;
	...
	return w;                   // "Копирование" w в возвращаемое значение
}
```

Здесь выполняются оба условия, и вы можете доверять мне, когда я говорю вам, что каждый приличный компилятор С++ будет использовать RVO для того, чтобы избежать копирования `w`. Это означает, что "копирующая" версия `makeWidget` на самом деле копирования не выполняет.

Перемещающая версия `makeWidget` делает только то, о чем говорит ее имя (в предположении наличия перемещающего конструктора `Widget`) она перемещает содержимое `w` в местоположение возвращаемого значения `makeWidget`. Но почему компиляторы не используют `RVO` для устранения перемещения, вновь создавая `w` в памяти, выделенной для возвращаемого значения функции? Ответ прост: они не могут. Условие предусматривает, что `RVO` может быть выполнена, только если возвращается локальный объект, но в перемещающей версии `makeWidget` это не так. Посмотрим еще раз на инструкцию `return`:

```c++
return std::move(w);
```

То, что здесь возвращается, не является локальным объектом `w`; это ссылка на `w` результат `std::move(w)`. Возврат ссылки на локальный объект не удовлетворяет условиям, требующимся для применения `RVO`, так что компиляторы вынуждены перемещать `w` в местоположение возвращаемого значения функции. Разработчики, пытаясь с помощью применения [[move|std::move]] к возвращаемой локальной переменной помочь компиляторам оптимизировать код, на самом деле ограничивают возможности оптимизации, доступные их компиляторам!

Но `RVO` это всего лишь оптимизация. Компиляторы не обязаны устранять операции копирования и перемещения даже тогда, когда это им позволено. Возможно, вы параноик и беспокоитесь о том, что ваши компиляторы будут выполнять операции копирования, просто потому, что они могут это делать. А может, вы настолько глубоко разбираетесь в ситуации, что в состоянии распознать случаи, когда компиляторам трудно применять `RVO`, например когда различные пути выполнения в функции возвращают разные локальные переменные. (Компиляторы должны генерировать код для построения соответствующей локальной переменной в памяти, выделенной для возвращаемого значения функции, но как компиляторы смогут определить, какая локальная переменная должна использоваться?) В таком случае вы можете быть готовы заплатить цену перемещения как гарантию того, что копирование выполнено не будет. Иначе говоря, вы можете продолжать думать, что применение [[move|std::move]] к возвращаемому локальному объекту разумно просто потому, что при этом вы спокойны, зная, что вам не придется платить за копирование.

В этом случае применение [[move|std::move]] к локальному объекту все равно остается плохой идеей. Часть стандарта, разрешающая применение `RVO`, гласит далее, что если условия для применения `RVO` выполнены, но компиляторы предпочитают не выполнять удаление копирования, то возвращаемый объект должен рассматриваться как [[rvalue|rvalue]]. По сути, стандарт требует, чтобы, когда оптимизация `RVO` разрешена, к возвращаемому локальному объекту либо применялось удаление копирования, либо неявно применялась функция [[move|std::move]]. Так что в "копирующей" версии `makeWidget`

```c++
Widget makeWidget()             // Как и ранее
{
	Widget w;
	...
	return w;
}
```

компиляторы должны либо устранить копирование `w`, либо рассматривать функцию, как если бы она была написана следующим образом:

```c++
Widget makeWidget()
{
	Widget w;
	...
	return std::move(w);       // Рассматривает w как rvalue, поскольку
}                              // удаление копирования не выполняется
```

Ситуация аналогична для параметров функции, передаваемых по значению. Они не имеют права на удаление копирования при их возврате из функции, но компиляторы должны рассматривать их в случае возврата как [[rvalue|rvalue]]. В результате, если ваш исходный текст выглядит как

```c++
Widget makeWidget(Widget w)       // Передаваемый по значению параметр
{                                 // имеет тот же тип, что и
	...                           // возвращаемый тип функции
	return w;
}
```

компиляторы должны рассматривать его, как если бы он был написан как

```c++
Widget makeWidget(Widget w)
{
	...
	return std::move(w);          // w рассматривается как rvalue
}
```

Это означает, что, используя [[move|std::move]] для локального объекта, возвращаемого функцией по значению, вы не можете помочь компилятору (он обязан рассматривать локальный объект как [[rvalue|rvalue]], если не выполняет удаления копирования), но вы, определенно, в состоянии ему помешать (препятствуя `RVO`). Есть ситуации, когда применение [[move|std::move]] к локальной переменной может быть разумным (т.е. когда вы передаете ее функции и знаете, что больше вы ее использовать не будете), но эти ситуации не включают применение [[move|std::move]] в качестве части инструкции `return`, которая в противном случае претендовала бы на оптимизацию `RVO`, или возврат параметра, передаваемого по значению.

> - Применяйте [[move|std::move]] к [[rvalue|rvаluе-ссылкам]], а [[forward|std::forward]] - к универсальным ссылкам, когда вы используете их в последний раз.
> 
> - Делайте то же для rvalue- и универсальных ссылок, возвращаемых из функций по значению.
> 
> - Никогда не применяйте [[move|std::move и std::forward]] к локальным объектам, которые могут быть объектом оптимизации возвращаемого значения.

