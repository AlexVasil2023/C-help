# Предпочитайте nullptr значениям 0 и NULL
Дело вот в чем: литерал 0 представляет собой `int`, а не указатель. Если С++ встретит 0 в контексте, где может использоваться только указатель, он интерпретирует 0 как нулевой указатель, но это - запасной выход. Фундаментальная стратегия С++ состоит в том, что 0 - это значение типа `int`, а не указатель.

С практической точки зрения то же самое относится и к `NULL`. В случае `NULL` имеется некоторая неопределенность в деталях, поскольку реализациям позволено придавать `NUll` целочисленный тип, отличный от `int` (например, `long`). Это не является распространенной практикой, но в действительности не имеет значения, поскольку вопрос не в точном типе `NUll`, а в том, что ни 0, ни `NUll` не имеют тип указателя.

В С++98 основным следствием этого факта было то, что перегрузка с использованием типов указателей и целочисленных типов могла вести к сюрпризам. Передача 0 или `NUll` таким перегрузкам никогда не приводила к вызову функции с указателем:
```c++
void f (int);                         // Три nерегрузки функции f
void f (bool);
void f (void*);

f(0);                                 // Вызов f (int), не f (void*)
f (NULL) ;                            // Может не компилироваться, но обычно
                                      // вызывает f(int) и никогда - f(void*)
```
Неопределенность в отношении поведения `f(NULL)` является отражением свободы, пре­доставленной реализациям в отношении типа `NULL`. Если `NULL` определен, например, как `0L` (т.е. 0 как значение типа `long`), то вызов является неоднозначным, поскольку преобразо­вания `long` в `int`, `long` в `bool` и `0L` в `void*` рассматриваются как одинаково подходящие. Интересно, что этот вызов является противоречием между видимым смыслом исходного текста ("вызываем `f` с нулевым указателем `NULL`») и фактическим смыслом ("вызываем `f` с некоторой разновидностью целых чисел - не указателем"). Это противоречащее интуиции поведение приводит к рекомендации программистам на С++98 избегать перегрузки типов указателей и целочисленных типов. Эта рекомендация остается в силе и в С++11, поскольку, несмотря на рекомендации данного раздела, некоторые разработчики, определенно, продолжат применять 0 и `NULL`, несмотря на то что `nullptr` является лучшим выбором.

Преимущество `nullptr` заключается в том, что это значение не является значением целочисленного типа. Честно говоря, он не имеет и типа указателя, но его можно рассмат­ривать как указатель любого типа. Фактическим типом `nullptr` является [[nullptr_t|std::nullptr_t]], ну, а тип [[nullptr_t|std::nullptr_t]] циклически определяется как тип значения `nullptr`. Тип [[nullptr_t|std::nullptr_t]] неявно преобразуется во все типы обычных указателей, и именно это де­лает `nullptr` действующим как указатель всех типов.

Вызов перегруженной функции `f` с `nullptr` приводит к вызову перегрузки `void*` (т.е. перегрузки с указателем), поскольку `nullptr` нельзя рассматривать как что-то целочисленное:
```c++
f(nullptr);                    // Вызов f(void*)
```
Использование `nullptr` вместо `0` или `NULL`, таким образом, позволяет избежать сюрпризов перегрузки, но это не единственное его преимущество. Оно позволяет также по­высить ясность кода, в особенности при применении аutо-переменных. Предположим, например, что у нас есть следующий исходный текст:
```c++
auto result = findRecord ( /* Аргументы */ ) ;
if (result == 0) {
	...
}
```
то здесь нет никакой неоднозначности: `result` должен иметь тип указателя.

Особенно ярко сияет `nullptr`, когда на сцене появляются шаблоны. Предположим, что у вас есть несколько функций, которые должны вызываться только при блокировке соответствующего мьютекса. Каждая функция получает указатель определенного вида:
```c++
int f1(std::shared_ptr<Widget> spw);          // Вызывается только при
double f2(std::unique_ptr<Widget> upw);       // блокировке соответ-
bool f3(Widget* pw);                          // ствующего мьютекса
```
Вызывающий код с передачей нулевых указателей может выглядеть следующим об­ разом:
```c++
std::mutex f1m, f2m, f3m;                    // Мьютексы для fl, f2 и f3
using MuxGuard =                             // C++11 typedef; см. раздел 3.3
		std::lock_guard<std::mutex>;

{
	MuxGuard g(flm);                         // Блокировка мьютекса для f1
	auto result = f1(O);                     // Передача 0 функции f1
}                                            // Разблокирование мьютекса
...
{
	MuxGuard g(f2m);                         // Блокировка мьютекса для f2
	auto result = f2(NULL);	                 // Передача NULL функции f2
}                                            // Разблокирование мьютекса
...
{
	MuxGuard g(f3m);                         // Блокировка мьютекса для f3
	auto result = f3(nullptr);               // Передача nullptr функции f3
}                                            // Разблокирование мьютекса
```
То, что в первых двух вызовах не был передан `nullptr`, грустно; тем не менее код рабо­тает, а это чего-то да стоит. Однако повторяющиеся действия еще более грустны. Они просто беспокоят. Во избежание дублирования такого вида и предназначаются шаблоны, так что давайте превратим эти действия в шаблон.

```c++
template<typename FuncType,
		 typename MuxType,
		 typename PtrType>
auto lockAndCall(FuncType func,
				MuxType& mutex,
				PtrType ptr) -> decltype (func (ptr))
{
	using MuxGuard = std::lock_guard<MuxType>;
	
	MuxGuard g(mutex);
	return func(ptr);
}
```
Если возвращаемый тип этой функции (`auto ...->decltype (func(ptr))` заставляет вас чесать затылок, обратитесь к [[decltуре|разделу "Знакомство с decltуре"]], в котором объясняется происходящее. Там вы узнаете, что в С++14 возвращаемый тип можно свести к простому `decltype(auto)`:
```c++
template<typename FuncType,
		 typename MuxType,
		 typename PtrType>
decltype(auto) lockAndCall(FuncType func,
				MuxType& mutex,
				PtrType ptr)
{
	using MuxGuard = std::lock_guard<MuxType>;
	
	MuxGuard g(mutex);
	return func(ptr);
}
```
Для данного шаблона `lockAndCall` (любой из версий), вызывающий код может иметь следующий вид:
```c++
auto result1 = lockAndCall(f1, flm, 0);              // Ошибка!
auto result2 = lockAndCall(f2, f2m, NULL);           // Ошибка!
auto resultЗ = lockAndCall(fЗ, fЗm, nullptr);        // ОК
```
Такой код можно написать, но, как показывают комментарии, в двух случаях из трех этот код компилироваться не будет. В первом вызове проблема в том, что когда `0` передается в `lockAndCall`, происходит вывод соответствующего типа шаблона. Типом `0` является, был и всегда будет `int`, как и тип параметра `ptr` в инстанцировании данного вызова `lockAndCall`. К сожалению, это означает, что в вызов `func` в `lockAndCall` передается `int`, а этот тип несовместим с параметром `std::shared_ptr<Widget>`, ожидаемым функцией `f1`. Значение `0`, переданное в вызове `lockAndCall`, призвано представлять нулевой указатель, но на самом деле передается заурядный `int`. Попытка передать этот `int` функции `f1` как `std::shared_ptr<Widget>` представляет собой ошибку типа. Вызов `lockAndCall` с `0` оказывается неудачным, поскольку в шаблоне функции, которая требует аргумент типа `std::shared_ptr<Widget>`, передается значение `int`.

Анализ вызова с переданным `NULL` по сути такой же. Когда в функцию `lockAndCall` передается `NULL`, для параметра `ptr` выводится целочисленный тип, и происходит ошибка, когда целочисленный тип передается функции `f2`, которая ожидает аргумент типа `std::unique ptr<Widget>`.

В противоположность первым двум вызовам вызов с `nullptr` никакими неприятностями не отличается. Когда функции `lockAndCall` передается `nullptr`, выведенным типом `ptr` является `std::nullptrt`. При передаче `ptr` в функцию `fЗ` выполняется неявное преобразование `std::nullptr_t` в `Widget*`, поскольку [[nullptr_t|std::nullptr_t]] неявно преобразуется во все типы указателей.

Тот факт, что вывод типа шаблона приводит к "неверным" типам для `0` и `NULL` (т.е. к их истинным типам, а не к представлению с их использованием нулевых указателей), является наиболее убедительной причиной для использования `nullptr` вместо `0` или `NULL`, когда вы хотите представить нулевой указатель. При применении `nullptr` шаблоны не представляют собой никаких особых проблем. Вместе с тем фактом, что `nullptr` не приводят к неприятностям при разрешении перегрузки, которым подвержены `0` и `NULL`, все это приводит к однозначному выводу - если вам нужен нулевой указатель, используйте `nullptr`, но не `0` и не `NULL`.

> * Предпочитайте применение `nullptr` использованию `0` или `NULL`.
>
> * Избегайте перегрузок с использованием целочисленных типов и типов указателей.



