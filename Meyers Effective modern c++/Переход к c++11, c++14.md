## Различие между { } и ( ) при создании объектов

В зависимости от вашей точки зрения выбор синтаксиса для инициализации объек­тов в С++11 либо очень богатый, либо запутанный и беспорядочный. Как правило, инициализирующие значения указываются с помощью круглых скобок, знака равенства или фигурных скобок:
```c++
int х(О);                          // Инициализатор в круглых скобках
int у = О;                         // Инициализатор после "="
int z{О};                          // Инициализатор в фигурных скобках
```
Во многих случаях можно использовать знак равенства и фигурные скобки одновременно:
```c++
int z = {О} ;          // Инициализатор использует "=" и фигурные скобки
```
В оставшейся части данного раздела я в основном буду игнорировать синтаксис, в котором одновременно используются знак равенства и фигурные скобки, поскольку С++ обычно трактует его так же, как и версию только с фигурными скобками.

Сторонники "полного беспорядка" указывают на то, что применение знака равенства для инициализации часто сбивает с толку новичков в С++, которые считают, что имеют дело с присваиванием, хотя на самом деле это не так. Для встроенных типов наподобие `int` эта разница носит чисто академический характер, но в случае пользовательских типов очень важно отличать инициализацию от присваивания, поскольку при этом вызываются различные функции:
```c++
Widget w1;                    // Вызов конструктора по умолчанию
Widget w2 = w1;               // Не присваивание, а копирующий конструктор
w1 = w2;                      // Присваивание; вызов оператора operator=()
```
Даже при наличии нескольких синтаксисов инициализации существовали определенные ситуации, когда в С++98 не было возможности выразить желаемую инициализацию. Например, было невозможно прямо указать, что контейнер **STL** должен быть создан содержащим определенный набор значений (например, 1, 3 и 5).

Для устранения путаницы из-за нескольких синтаксисов инициализации и решения проблемы охвата всех сценариев инициализации С++11 вводит унифицированную иници­ализацию (**uпiform initializatioп**): единый синтаксис инициализации, который может, как минимум концептуально, использоваться везде и выражать все. Он основан на фигурных скобках, и по этой причине я лично предпочитаю термин "фигурная инициализация" (**braced initialization**). Унифицированная инициализация - это идея. Фигурная инициа­лизация - это синтаксическая конструкция.

Фигурная инициализация позволяет выразить то, что было невозможно выразить ранее. С помощью фигурных скобок легко указать начальное содержимое контейнера: 
```c++
std::vector<int>v{1, 3, 5};        // v иэначально содержит 1, 3, 5
```
Фигурные скобки могут также использоваться для указания значений инициализации по умолчанию для нестатических членов-данных. Эта возможность - новая в С++11 - может использоваться с синтаксисом "=" но не с круглыми скобками:
```c++
class Widget{
	...
	private:
		int х{О};              // ОК, эначение х по умолчанию равно О
        int у = О;             // Тоже ОК
		int z(O);              // Ошибка !	
};
```
С другой стороны, некопируемые объекты (например, [[atomic|std::atomic]]) могут быть инициализированы с помощью фигурных или круглых скобок, но не с по мощью знака равенства:
```c++
std::atomic<int> ai1{О};       // ОК
std::atomic<int> ai2(0);       // ОК
std::atomic<int> ai3 = О;      // Ошибка !
```
Легко понять, почему фигурная инициализация названа "унифицированной''. Из трех способов обозначения выражений инициализации только фигурные скобки могут использоваться везде.

Новая возможность фигурной инициализации заключается в том, что она запрещает неявные сужающие преобразования среди встроенных типов. Если значение выражения в фигурном инициализаторе не может быть гарантированно выражено типом инициали­зируемого объекта, код не компилируется:
```c++
douЫe х, у, z;
...
int suml{х + у + z };          // Ошибка ! Сумма double может
                               // не выражаться с помощью int
```
Инициализация с использованием круглых скобок и знака равенства не выполняет про­верку сужающего преобразования, поскольку это может привести к неработоспособности большого количества старого кода:
```c++
int sum2 (x + y + z);          // ОК (значение выражения усекается до int)
int sum3 = x + y + z;          //
```
Обращает на себя внимание еще одна особенность фигурной инициализации - она не подвержена наиболее неприятному анализу в С++. Побочным эффектом правила С++, согласно которому все, что в ходе синтаксического анализа может рассматриваться как объявление, должно рассматриваться как таковое, является так называемый наиболее неприятный анализ, который чаще всего досаждает разработчикам, когда они хотят создать объект по умолчанию, а в результате получают объявление функции. Корень проблемы кроется в том, что если вы хотите вызвать конструктор с аргументом, вы делаете это примерно следующим образом:
```c++
Widget w1(lO);             // Вызов конструктора Widget с аргументом 10
```
Но если вы пытаетесь вызвать конструктор `Widget` без аргументов с помощью аналогич­ного синтаксиса, то фактически объявляете функцию вместо объекта:
```c++
Widget w2();               // Синтаксический анализ рассматривает зто как
                           // объявление функции w2, возвращающей Widget
```
Функции не могут быть объявлены с использованием фигурных скобок для списка пара­метров, так что конструирование объекта по умолчанию с применением фигурных скобок такой проблемы не вызовет:
```c++
Widget wЗ {};              // Вызов конструктора Widget без аргументов
```
Таким образом, в пользу фигурной инициализации имеется много "за". Это синтаксис, который может использоваться в самых разнообразных контекстах, предотвращающий неявные сужающие преобразования и не подверженный неприятностям с синтаксиче­ским анализом С++. Тройное "за"! Так почему бы не озаглавить раздел просто "Исполь­зуйте синтаксис фигурной инициализации"?

Основной недостаток фигурной инициализации - временами сопровождающее ее удивительное поведение. Такое поведение вырастает из необыкновенно запутанных вза­имоотношений между фигурной инициализацией, [[initializer_list|std::initializer_ list]] и разрешением перегрузки конструкторов. Их взаимодействие может привести к коду, который, как кажется, должен делать что-то одно, а в результате делает что-то совсем другое. Напри­мер, в [[auto#Вывод типа auto|Вывод типа auto]] поясняется, что когда переменная, объявленная как `auto`, имеет инициализатор в фигурных скобках, то выводимым типом является [[initializer_list|std::initializer_ list]], несмотря на то, что другой способ объявления переменной с тем же инициализатором даст более ожидаемый тип. В результате чем больше вам нравится `auto`, тем меньше энтузиазма вы должны проявить по отношению к фигурной инициализации.

В вызовах конструктора круглые и фигурные скобки имеют один и тот же смысл, пока в конструкторах не принимают участие параметры [[initializer_list|std::initializer_ list]]:
```c++
class Widget {
	public:
		Widget(int i, bool Ь);       // Конструкторы не имеют параметров
		Widget(int i, double d);     // std::initializer_list
};

Widget w1 (1O, true);                // Вызов первого конструктора
Widget w2 {10, true};                // Вызов первого конструктора
Widget w3 (10, 5.0);                 // Вызов второго конструктора
Widget w4 {10, 5.0};                 // Вызов второго конструктора
```
Если же один или несколько конструкторов объявляют параметр типа [[initializer_list|std::initializer_ list]], вызовы, использующие синтаксис фигурной инициализации, строго предпочитают перегрузки, принимающие [[initializer_list|std::initializer_ list]]. Строго. Если у компилятора есть любой способ истолковать вызов с фигурным инициализатором как конструктор, принимающий [[initializer_list|std::initializer_ list]], он использует именно это толкование. Если класс `Widget` выше дополнить конструктором, принимающим, например, `std::initializer_list<long double>`
```c++
class Widget (
	public:
		Widget(int i, bool Ь);                           // Как и ранее
		Widget(int i, double d);                         // Как и ранее
		Widget (std::initializer_list<long double> il);  // Добавлен
};

```
то `w2` и `w4` будут созданы с помощью нового конструктора, несмотря на то что тип элементов [[initializer_list|std::initializer_ list]] (в данном случае - `long double`) хуже соответствует обоим аргументам по сравнению с конструкторами, не принимающими [[initializer_list|std::initializer_ list]]! Смотрите сами:
```c++
Widget w1(1O, true);              // Использует круглые скобки и, как и
                                  // ранее, вызывает первый конструктор

Widget w2{10, true};              // Использует фигурные скобки, но теперь
                                  // вызывает третий конструктор
                                  // (10 и true преобразуются в long double)

Widget wЗ(10, 5.О);               // Использует круглые скобки и, как и
                                  // ранее, вьGывает второй конструктор
                                  
Widget w4{10, 5.0};               // Использует фигурные скобки, НО теперь
                                  // вызывает третий конструктор
                                  // (10 и 5.0 преобразуются в long double)
```
Даже то, что в обычной ситуации представляет собой копирующий или перемещающийконструктор, может быть перехвачено конструктором с [[initializer_list|std::initializer_ list]];
```c++
class Widget{
	public:
		Widget(int i, bool Ь);                         // Как ранее
		Widget(int i, double d);                       // Как ранее	
		Widget(std::initializer_list<long double> il); // Как ранее	
		operator float() const;     // Преобразование во float	
};

Widget w5(w4);                      // Использует круглые скобки, вызывает
                                    // копирукщий конструктор

Widget w6{w4};                      // Использует фигурные скобки, вызов
                                    // конструктора с std::initializer_list
                                    // (w4 преобразуется во float, а float
                                    // преобразуется в long douЬle)
                                    
Widget w7(std::move(w4));            // Использует круглые скобки, вызывает
                                    // перемещающий конструктор
                                    
Widget w8{std::move(w4)};            // Использует фигурные скобки, ВЫЗОВ
								    // конструктора с std::initializer_list
                                    // (все, как для w6)
```
Определение компилятором соответствия фигурных инициализаторов конструкто­рам с [[initializer_list|std::initializer_ list]] настолько строгое, что доминирует даже тогда, когда конструктор с [[initializer_list|std::initializer_ list]] с наилучшим соответствием не может быть вызван, например:
```c++
class Widget {
	public:
		Widget(int i, bool b);       // Как ранее
        Widget(int i, double d);     // Как ранее
		Widget(std::initializer_list<bool> il); // Теперь тип
									 // элемента - bool
					                 // Нет функций неявного преобразования
}

Widget w{10, 5.0};                   // Ошибка ! Требуется сужающее преобразование
```
Здесь компилятор игнорирует первые два конструктора (второй из которых в точности соответствует обоим типам аргументов) и пытается вызвать конструктор, получающий аргумент типа `std::initializer_list<bool>`. Вызов этого конструктора требует преобразования значений `int(10)` и `double(5.О)` в `bool`. Оба эти преобразования являются сужающими (`bool` не может в точности представить ни первое, ни второе значения), а так как сужающие преобразования запрещены в фигурных инициализаторах, вызов является некорректным, и код отвергается.

И только если нет никакой возможности преобразовать типы аргументов в фигурном инициализаторе в типы в [[initializer_list|std::initializer_ list]], компилятор возвращается к нормальному разрешению перегрузки. Например, если мы заменим конструктор с `std::initializer_list<bool>` конструктором, принимающим `std::initializer_list<std::string>`, то кандидатами на вызов вновь станут конструкторы, не принимаю­щие [[initializer_list|std::initializer_ list]] (поскольку нет никакого способа преобразовать `int` и `bool` в `std::string`:
```c++
class Widget{
	public:
		Widget(int i, bool b);        // Как ранее
		Widget(int i, double d);      // Как ранее
		// Теперь тип элементов std::initializer_list - std::string:
		Widget(std::initializer_list<std::string> il);
		// Нет функций неявного преобразования
};

Widget w1(10, true);                 // Круглые скобки, первый конструктор
Widget w2{10, true};                 // Фигурные скобки, первый конструктор
Widget w3(10, 5.0);                  // Круглые скобки, второй конструктор
Widget w4{10, 5.0};                  // Фигурные скобки, второй конструктор
```
Это приводит нас к завершению изучения фигурных инициализаторов и пере­грузки конструкторов, но есть еще один интересный предельный случай, который хотелось бы рассмотреть. Предположим, что вы используете пустые фигурные скобки для создания объекта, который поддерживает конструктор по умолчанию и конструктор с [[initializer_list|std::initializer_ list]]. Что при этом будут означать пустые фигурные скобки? Если они означают "без аргументов", будет вызван конструктор по умолчанию, но если они означают "пустой std::initializer_list", то будет вызван конструктор с [[initializer_list|std::initializer_ list]] без элементов.

Правило заключается в том, что будет вызван конструктор по умолчанию. Пустые
фигурные скобки означают отсутствие аргументов, а не пустой [[initializer_list|std::initializer_ list]]:
```c++
class Widget {
	puЬlic:
		// Конструктор по умолчанию:
		Widget();
		
		// Конструктор с std::initializer_list
		Widget(std::initializer_list<int> il);
		
		// Нет функций неявного преобразования
};

Widget w1;                           // Вызов конструктора по умолчанию
Widget w2{};                         // Вызов конструктора по умолчанию
Widget w3();                         // Трактуется как объявление функции!
```
Если вы хотите вызвать конструктор с пустым [[initializer_list|std::initializer_ list]], то это можно сделать, передавая пустые фигурные скобки в качестве аргумента конструктора в круглых или фигурных скобках, окружающих передаваемые вами:
```c++
Widget w4({});                       // Вызов конструктора с пустым
									 // std::initializer_list
Widget w5({}};                       // То же самое
```
Сейчас, когда кажущиеся магическими правила фигурной инициализации, [[initializer_list|std::initializer_ list]] и перегрузки конструкторов переполняют ваш мозг, вы можете удивиться, какое большое количество информации влияет на повседневное программи­рование. На самом деле даже больше, чем вы думаете, потому что одним из классов, на которые все это оказывает непосредственное влияние, является [[vector|std::vector]]. Класс [[vector|std::vector]] имеет конструктор без [[initializer_list|std::initializer_ list]], который позволяет вам указать начальный размер контейнера и значение, присваиваемое каждому из его эле­ментов; но при этом имеется также конструктор, принимающий [[initializer_list|std::initializer_ list]] и позволяющий указать начальные значения контейнера. Если вы создаете [[vector|std::vector]] числового типа (например, `std::vector<int>`) и передаете ему два аргумента, то при использовании круглых и фигурных скобок вы получите совершенно разные результаты:
```c++
std::vector<int>v1(10, 20);             // Используется конструктор без
                                        // std::initializer list: создает
                                        // std::vector с 10 элементами;
                                        // значение каждого равно 20
                                        
std::vector<int>v2{10, 20};             // Используется конструктор с
                                        // std::initializer_list : создает
										// std::vector с 2 элементами со
                                        // значениями 10 и 20
```
Но давайте сделаем шаг назад от [[vector|std::vector]], а также от деталей применения круглых скобок, фигурных скобок и правил перегрузки конструкторов. Имеется два основных вывода из этого обсуждения. Во-первых, как автор класса вы должны быть осведомлены о том, что если ваш набор перегружаемых конструкторов включает один или несколько конструкторов, использующих [[initializer_list|std::initializer_ list]], то клиентский код с фигурной инициализацией может рассматривать только перегрузки с [[initializer_list|std::initializer_ list]].

В результате лучше проектировать конструкторы так, чтобы перегрузка не зависела от того, используете вы круглые или фигурные скобки. Другими словами, вынесите уроки из того, что сейчас рассматривается как ошибка дизайна интерфейса класса [[vector|std::vector]], и проектируйте свои классы так, чтобы избегать подобных ошибок.

Следствием этого является то, что если у вас есть класс без конструктора [[initializer_list|std::initializer_ list]] и вы добавляете таковой, то клиентский код, использующий фигурную инициализацию, может обнаружить, что вызовы, разрешавшиеся с использованием конструкторов без [[initializer_list|std::initializer_ list]], теперь разрешаются в новые функции. Конечно, такое может случиться в любой момент при добавлении новой функции ко множеству перегруженных функций: вызов, который разрешался в одну из старых функций, теперь может приводить к вызову новой. Разница в данном случае в том, что перегрузки с [[initializer_list|std::initializer_ list]] не только конкурируют с другими перегрузками, но практически полностью перекрывают для них возможность быть рассмотренными в качестве по­тенциальных кандидатов. Поэтому такое добавление должно выполняться только после тщательного обдумывания.

Второй урок заключается в том, что в качестве клиента класса вы должны тщательно вы­бирать между круглыми и фигурными скобками при создании объектов. Большинство раз­работчиков в конечном итоге выбирают один вид скобок как применяемый по умолчанию, а другой - только при необходимости. Применение по умолчанию фигурных скобок привле­кает их непревзойденным диапазоном применимости, запретом применения сужающих преобразований и их иммунитетом к особенностям синтаксического анализа. Такие люди понимают, что в некоторых случаях (например, при создании вектора [[vector|std::vector]] с заданными размером и начальным значением элемента) необходимо использовать круглые скобки. С другой стороны, немало программистов используют в качестве выбора по умолчанию круглые скобки. Они привлекательны своей согласованностью с синтаксическими традициями С++98, тем, что позволяют избегать проблем с выводом [[auto|auto]] как [[initializer_list|std::initializer_list]], и уверенностью, что вызовы при создании объектов не приведут к случайным вызовам кон­структоров с [[initializer_list|std::initializer_list]]. Эти программисты признают, что иногда следует использовать именно фигурные скобки (например, при создании контейнера с определенными значениями). Нет определенного превалирующего мнения о том, какой подход лучше, поэто­му могу посоветовать только выбрать один из них и постоянно ему следовать.

Если вы автор шаблона, противостояние в применении круглых и фигурных скобок может быть особенно неприятным, потому что в общем случае невозможно сказать, какие скобки должны использоваться. Предположим, например, что вы хотите создать объект произвольного типа с произвольным количеством аргументов. Использование шаблонов с переменным количеством параметров позволяет сделать это концептуально достаточно просто:
```c++
template<typename Т,                   // Тип создаваемого объекта
         typename... Ts>               // Типы используемых аргументов
void doSomeWork(Ts&&... params)
{
	//Создание локального объекта Т из params...
}
```
Есть два способа превратить строку псевдокода в реальный код (см. [[Использование move и forward|инфор­мацию о std::forward]]):

```c++
Т localObject(std::forward<Ts>(params)...);         // Круглые скобки
Т localObject{std::forward<Ts>(params)...};         // Фигурные скобки
```
Рассмотрим следующий вызывающий код:
```c++
std::vector<int> v;
	...
doSomeWork<std::vector<int>>(1O, 20);
```
Если `doSomeWork` использует при создании объекта `localObject` круглые скобки, в результате будет получен [[vector|std::vector]] с 10 элементами. Если же `doSomeWork` использует фигурные скобки, то результатом будет [[vector|std::vector]] с двумя элементами. Какой из этих вариантов корректен! Автор `doSomeWork` не может этого знать. Это может знать
только вызывающий код.

Это именно та проблема, которая встает перед функциями стандартной библиотеки [[make_unique|std: : make_unique]] и [[make_shared|std : :make_shared]] ([[make_unique#Предпочитайте использование std make_unique и std make_shared непосредственному использованию оператора new|см.]] ). Эти функции решают проблему, используя круглые скобки и документируя это решение как части своих интерфейсов.

> * Фигурная инициализация является наиболее широко используемым синтаксисом инициализации, предотвращающим сужающие преобразования и нечувствительным к особенностям синтаксического анализа С++.
>
> * В процессе разрешения перегрузки конструкторов фигурные инициализаторы соответствуют параметрам [[initializer_list|std : : initializer_list]], если это возможно, даже если другие конструкторы обеспечивают лучшее соответствие.
>
> * Примером, в котором выбор между круглыми и фигурными скобками приводит к зна­чительно отличающимся результатам, является создание `std::vесtоr<числовой_тип>` с двумя аргументами.
>
> * Выбор между круглыми и фигурными скобками для создания объектов внутри ша­блонов может быть очень сложным.

