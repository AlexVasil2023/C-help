# При использовании идиомы указателя на реализацию определяйте специальные функции-члены в файле реализации
Если вам приходилось бороться со слишком большим временем построения приложения, вы, вероятно, знакомы с идиомой `Pimpl` (poiпter to implementation, указатель на реализацию). Это методика, при которой вы заменяете члены-данные класса указателем на класс (или структуру) реализации, помещаете в него члены-данные, использовавшиеся в основном классе, и обращаетесь к ним опосредованно через указатель. Предположим, например, что наш `Widget` имеет следующий вид:
```c++
class Widget{                      // В заголовочном файле "widget.h"
	public:
		Widget();

	private :
		std::string name;
		std::vector<double>data;
		
		Gadget gl, g2, gЗ;         // Gadget - некий пользовательский тип
};
```
Поскольку члены-данные `Widget` имеют типы [[string|std::string]], [[vector|std::vector]] и `Gadget`,
для компиляции `Widget` должны присутствовать соответствующие заголовочные файлы, а это означает, что клиенты `Widget` должны включать с помощью директивы `#include` заголовочные файлы `string`, `vector` и `gadget.h`. Эти заголовочные файлы увеличивают время компиляции клиентов `Widget`, а также делают этих клиентов зависящими от содержимого указанных заголовочных файлов. Если содержимое заголовочного файла изменяется, клиенты `Widget` должны быть перекомпилированы. Стандартные заголовочные файлы `string` и `vector` меняются не слишком часто, но заголовочный файл `gadget.h` вполне может оказаться подвержен частым изменениям.

Применение идиомы `Pimpl` в С++98 могло выполняться с помощью замены членов­-данных `Widget` обычным указателем на объявленную, но не определенную структуру:
```c++
class Widget{           // Все еще в заголовочном файле "widget.h"
	public:
		Widget();
		-Widget();      // Деструктор необходим (см. ниже)
	
	private :
		struct Impl;    // Объявление структуры реализации
		Impl *pimpl;    // и указателя на нее
};
```
Поскольку `Widget` больше не упоминает типы [[string|std::string]], [[vector|std::vector]] и Gadget, клиенты `Widget` больше не обязаны включать соответствующие заголовочные файлы для этих типов. Это ускоряет компиляцию, а кроме того, означает, что если что-то в заголовочных файлах будет изменено, это не затронет клиенты `Widget`.

Тип, который был объявлен, но не определен, называется неполным типом. `Widget::Impl` является таким неполным типом. С неполным типом можно сделать очень немногое, но в это немногое входит объявление указателя на него. Идиома `Pimpl` использует эту возможность.

Первая часть идиомы `Pimpl` - объявление члена-данных, который представляет собой указатель на неполный тип. Вторая часть заключается в динамическом создании и уничтожении объекта, хранящего члены-данные, использующиеся в исходном классе. Соответствующий код находится в файле реализации, например для `Widget` - в файле `widget.срр`:
```c++
#include "widget.h"                // Файл реализации "widget.cpp"
#include "gadget.h"
#include <string>
#include <vector>

struct Widget::Impl {             // Определение Widget::Impl
	std::string name;             // с членами -данными, ранее
	std::vector<double> data;     // находившимися в Widget
	Gadget gl, g2, gЗ;
};

Widget::Widget()                  // Создание членов-данных
: pImpl (new Impl)                // для данного объекта Widget
{}

Widget::~Widget()                 // Уничтожение членов-данных
{ delete pimpl; }                 // для данного объекта
```
Здесь я привожу директивы `#include`, чтобы было ясно, что общие зависимости от заголовочных файлов для [[string|std::string]], [[vector|std::vector]] и `Gadget` никуда не исчезли и продолжают существовать. Однако эти зависимости перемещены из файла `widget.h` (видимого и используемого всеми клиентами класса `Widget`) в файл `widget.сpp` (видимый и используемый только реализацией `Widget`). Я также подчеркнул код динамического выделения и освобождения объекта `Impl`. Необходимость освобождения этого объекта при уничтожении `Widget` приводит к необходимости деструктора `Widget`.

Но я показал код С++98. Он использует обычные указатели, обычные операторы `new` и `delete`, и вообще весь он слишком сырой. Вся текущая глава построена на идее о том, что интеллектуальные указатели куда предпочтительнее обычных указателей, и если мы хотим динамически создавать объект `Widget::Impl` в конструкторе `Widget` и должны уничтожать его вместе с `Widget`, то для нас отлично подойдет интеллектуальный указатель [[unique_ptr|std::unique_ptr]]. Заменяя обычный указатель `pimpl` указателем [[unique_ptr|std::unique_ptr]], мы получим следующий код для заголовочного файла
```c++
class Widget {                          // В файле "widget.h"
	public:
		Widget();

	private :
		struct Impl;
		std::unique_ptr<Impl> pimpl;   // Интеллектуальный указатель
};
```
и для файла реализации:
```c++
#include "widget.h"                       // В файле "widget.cpp"
#include "gadget.h"
#include <string>
#include <vector>

struct Widget::Impl {                    // Как и ранее
	std::string name;
	std::vector<double> data;
	Gadget gl, g2, gЗ;
};

Widget::Widget()
	:pimpl(std::make_unique<Impl>())    // создаем std::unique_ptr
{}
```
Вы заметили, что деструктора `Widget` больше нет? Дело в том, что нет никакого кода, который требуется в нем разместить. [[unique_ptr|std::unique_ptr]] автоматически удаляет то, на что указывает, когда он сам (указатель) уничтожается, так что нам не требуется ничего удалять вручную. Это одна из привлекательных сторон интеллектуальных указателей: они устраняют необходимость утруждать свои руки вводом кода для освобождения ресурсов вручную.

Этот код компилируется, но, увы, это не самый тривиальный клиент!
```c++
#include "widget.h"
Widget w;                                     // Ошибка !
```
Получаемое вами сообщение об ошибке зависит от используемого компилятора, но в общем случае текст упоминает что-то о применении [[sizeof|sizeof]] или [[delete|delete]] к неполному типу. Эти операции не входят в число тех, которые можно делать с такими типами.

Эта явная неспособность идиомы `Pimpl` использовать [[unique_ptr|std::unique_ptr]] вызывает тревогу, поскольку указатели [[unique_ptr|std::unique_ptr]] разрекламированы как поддерживающие неполные типы, и идиома `Pimpl` - один из наиболее распространенных случаев применения [[unique_ptr|std::unique_ptr]]. К счастью, этот код легко сделать работающим. Все, что для этого требуется, - понимание причины проблемы.

Проблема возникает из-за кода, который генерируется при уничтожении `w` (например, при выходе переменной за пределы области видимости). В этой точке вызывается ее деструктор. Если определение класса использует [[unique_ptr|std::unique_ptr]], мы не объявляем деструктор, так как нам нечего в него поместить. [[Генерация специальных функций-членов|В соответствии с обычными правилами генерации специальных функций-членов компиляторами]]  этот деструктор создается вместо нас компилятором. В этот деструктор компилятор вносит код вызова деструктора члена-данных `pimpl` класса `Widget`. `pimpl` представляет собой указатель
`std::unique_ptr<Widget::Impl>`, т.е. указатель [[unique_ptr|std::unique_ptr]], использующий удалитель по умолчанию. Удалитель по умолчанию является функцией, которая применяет оператор [[delete|delete]] к обычному указателю внутри [[unique_ptr|std::unique_ptr]]. Однако перед тем как использовать [[delete|delete]], реализации удалителя по умолчанию в С++11 обычно применяют [[static_assert|static_assert]], чтобы убедиться, что обычный указатель не указывает на неполный тип. Когда компилятор генерирует код для деструкции `Widget w`, он в общем случае сталкивается с неудачным [[static_assert|static_assert]], что и приводит к выводу сообщения об ошибке. Это
сообщение обычно связано с точкой, в которой происходит уничтожение `w`, поскольку деструктор `Widget`, подобно всем генерируемым компиляторами специальным функциям-членам, неявно является [[inline|inline]]. Сообщение часто указывает на строку, в которой создается `w`, поскольку она представляет собой исходный текст, явно создающий объект, приводящий впоследствии к неявной деструкции.

Для исправления ситуации надо просто обеспечить полноту типа `Widget::Impl`
в точке, где генерируется код, уничтожающий `std::unique_ptr<Widget::Impl>`. Тип становится полным, когда его определение становится видимым, а `Widget::Impl` определен в файле `widget.срр`. Ключом к успешной компиляции является требование, чтобы компилятор видел тело деструктора `Widget` (т.е. место, где компилятор будет генерировать код для уничтожения члена-данных [[unique_ptr|std::unique_ptr]]) только внутри `widget.срр`, после определения `Widget::Impl`. Добиться этого просто. Объявим деструктор `Widget` в `widget.h` но не будем определять его там:
```c++
class Widget {                     // Как и ранее, в файле "widget.h"
	public:
		Widget();
		~Widget();                 // Только объявление
	...
	
	private :                     // Как и ранее
		struct Impl;
		std::unique_ptr<Impl>pimpl;
};
```
Определим его в `widget.срр` после определения `Widget::Impl`:
```c++
#include "widget.h"               // Как и ранее, в файле "widget.cpp"
#include "gadget.h"
#include <string>
#include <vector>

struct Widget::Impl {             // Как и ранее, определение
	std::string name;             // Widget::Impl
	std::vector<double> data;
	Gadget gl, g2, gЗ;
};

Widget::Widget()                            // Как и ранее
	:pimpl(std::make_unique<Impl>())
{}

Widget::~Widget()                           // Определение ~Widget
{}
```
Это хорошо работает и требует небольшого набора текста, но если вы хотите подчеркнуть, что генерируемый компилятором деструктор работает верно, что единственная причина его объявления - генерация его определения в файле реализации `Widget`, то вы можете определить тело деструктора как `= default`:
```c++
Widget::~Widget () = default;        // Тот же результат, что и выше
```
Классы, использующие идиому `Pimpl`, являются естественными кандидатами на поддержку перемещения, поскольку генерируемые компилятором операции перемещения делают именно то, что требуется: выполняют перемещение [[unique_ptr|std::unique_ptr]]. [[Генерация специальных функций-членов|Как поясняется]], объявление деструктора `Widget` препятствует генерации компилятором операций перемещения, так что, если вы хотите обеспечить их поддержку, вы должны объявить их самостоятельно. Поскольку генерируемые компилятором версии ведут себя так, как надо, соблазнительно реализовать их следующим образом:
```c++
class Widget{                               // В "widget.h"
	public:
		Widget();
		~Widget();

		Widget(Widget&& rhs) = default;     // Идея верна,
		Widget& operator=(Widqet&& rhs) = default; // код - нет '
		...
	private:                                // Как и ранее
		struct Impl;
		std::unique_ptr<Impl>pimpl;
);
```
Этот подход приводит к тем же проблемам, что и объявление класса без деструктора, и по той же самой причине. Генерируемый компилятором оператор перемещающего присваивания должен уничтожить объект, на который указывает pimpl, перед тем как присвоить указателю новое значение, но в заголовочном файле `Widget` указатель `pimpl` указывает на неполный тип. Ситуация отличается для перемещающего конструктора. Проблема в том, что компиляторы обычно генерируют код для уничтожения `pimpl` в том случае, когда в перемещающем конструкторе генерируется исключение, а уничтожение
`plmpl` требует, чтобы тип `Impl` был полным.

Поскольку проблема точно такая же, как и ранее, то и решение ее такое же - перенос определений перемещающих операций в файл реализации:
```c++
class Widget {                            // В файле "widget.h"
	public :
		Widget();
		~Widget();
		Widget(Widget&& rhs);             // Только объявления
		Widget& operator= (Wiclqet&& rhs);
		...
	private:                              // Как и ранее
		struct Impl;
			std::unique_ptr<Impl>pimpl;
		);


#include <string>                        // В файле "widget.cpp"
struct Widget::Impl{ ... }               // Как и ранее

Widget::Widget()                         // as before
	:pimpl(std::make_unique<Impl>())
{}

Widget::~Widget() = default;             // Как и ранее

// Определения:
Widqet::Widqet (Widget&& rhs) = default;
Widqet& Widqet::operator=(Widget&& rhs)=default;
```
Идиома `Pimpl` представляет собой способ снижения зависимости между реализацией класса и его клиентами, но концептуально идиома не меняет то, что представляет собой класс. Исходный класс `Widget` содержал члены-данные [[string|std::string]], [[vector|std::vector]] и `Gadget`, так что в предположении, что объекты `Gadget`, как и объекты [[stringstd::string]] и [[vector|std::vector]], могут копироваться, имеет смысл в поддержке классом `Widget` копирующих операций. Мы должны написать эти функции самостоятельно, поскольку компиляторы не генерируют копирующие операции для классов с типами, поддерживающими только перемещение (наподобие [[unique_ptr|std::unique_ptr]]) и даже если бы они генерировались, то такие функции выполняли бы копирование только указателя [[unique_ptr|std::unique_ptr]] (т.е. выполняли бы мелкое копирование), а мы хотим копировать то, на что указывает этот указатель (т.е. выполнять глубокое копирование).

В соответствии с ритуалом, который нам теперь хорошо знаком, мы объявляем функции в заголовочном файле и реализуем их в файле реализации:
```c++
class Widget {                                 // В файле "widget.h "
	public:
		...                                    // Прочее, как ранее
		Widqet (const Widqet& rhs);            // Только
		Widqet& operator=(const Widqet& rhs);  // объявления
	
	private:                                   // Как и ранее
		struct Impl;
		std::unique_ptr<Impl>pImpl;
};

#include "widget.h"                            // В "widget.cpp"
...
struct Widget::Impl { ... };                   // Как и ранее
Widget::~Widget () = default;                  // Прочее, как и ранее

Widqet::Widqet(const Widget& rhs)              // Копирующий конструктор
	:рImрl(nullptr)
{ if(rhs.pImpl) pImpl =  std::make_unique<Impl>(*rhs.pImpl); }
											   // Копирующее присваивание:
Widget& Widget::operator= (const Widget& rhs)
{
	if(!rhs.рImрl) рImрl.reset();
	else if (!рImрl) рImрl = std::make_unique<Impl>(*rhs.pImpl);
	else *pImpl = *rhs.pImpl;

	return *this;
}
```
Реализация достаточно проста, хотя мы и должны обрабатывать случаи, в которых параметр `rhs` или, в случае копирующего оператора присваивания, `*this` был перемещен, а потому содержит нулевой указатель `pimpl`. В общем случае мы используем тот факт, что компиляторы создают копирующие операции для `Impl`, и эти операции копируют каждое поле автоматически. Так что мы реализуем копирующие операции `Widget` путем вызова копирующих операций `Widget::Impl`, сгенерированных компилятором. В обеих функциях обратите внимание, как мы применяем [[make_unique| std::make_unique]] непосредственной работе с `new`.

При реализации идиомы `Pimpl` используемым интеллектуальным указателем является [[unique_ptr|std::unique_ptr]], поскольку указатель `pimpl` внутри объекта (например, внутри `Widget`) имеет исключительное владение соответствующим объектом реализации (например, объектом `Widget::Impl` ) . Интересно также отметить, что если бы мы использовали для `pimpl` указатель [[shared_ptr|std::shared_ptr]] вместо [[unique_ptr|std::unique_ptr]] (т.е. если бы значения в структуре `Impl` могли совместно использоваться несколькими `Widget`) , то нашли бы, что советы из данного раздела больше не применимы. Нам бы не потребовалось объявлять деструктор в `Widget`, а без пользовательского деструктора компиляторы с удовольствием генерировали бы операции перемещения, которые делали бы именно то, что от них требуется. То есть при следующем коде в файле `widget.h`
```c++
class Widget {                      // В файле "widget.h"
	public:
		Widget();
									// Нет объявлений деструктора
									// и перемещающих операций
	private:
		struct Impl;

		std::shared_ptr<Impl> pimpl; // std::shared_ptr
									 // вместо std::unique_ptr
};
```
и приведенном далее коде клиента, который включает заголовочный файл `widget.h`
```c++
Widget w1;
auto w2(std::move(w1));            // Перемещающее конструирование w2
w1 = std::move(w2);                // Перемещающее присваивание w1
```
все компилировалось бы и работало именно так, как мы рассчитывали: `w1` был бы создан конструктором по умолчанию, его значение было бы перемещено в `w2`, а затем это значение, в свою очередь, было бы перемещено в `w1`, после чего и `w1`, и `w2` были бы уничтожены (тем самым приводя к уничтожению объекта `Widget::Impl`) .

Различие в поведении указателей [[unique_ptr|std::unique_ptr]] и [[shared_ptr|std::shared_ptr]] для `pimpl` вытекает из различий путей, которыми эти интеллектуальные указатели поддерживают пользовательские удалители. Для [[unique_ptr|std::unique_ptr]] тип удалителя является частью типа интеллектуального указателя, и это позволяет компилятору генерировать меньшие структуры данных времени выполнения и более быстрый код. Следствием этой более высокой эффективности является то, что указываемые типы должны быть полными, когда используются специальные функции-члены, генерируемые компиляторами (например, деструкторы или перемещающие операции). В случае [[shared_ptr|std::shared_ptr]] тип удалителя не является частью типа интеллектуального указателя. Это требует больших структур данных времени выполнения и несколько более медленного кода, но зато указываемые типы не обязаны быть полными при применении специальных функций-членов, генерируемых компиляторами.

При применении идиомы `Pimpl` в действительности нет никакого компромисса между характеристиками [[unique_ptr|std::unique_ptr]] и [[shared_ptr|std::shared_ptr]], поскольку отношения между классами наподобие `Widget` и `Widget::Impl` представляют собой исключительное владение, и это делает единственно верным выбором в качестве инструмента интеллектуальный указатель [[unique_ptr|std::unique_ptr]]. Тем не менее стоит знать, что в других ситуациях - ситуациях, в которых осуществляется совместное владение (а следовательно, правильным выбором является [[shared_ptr|std::shared_ptr]]), нет необходимости прыгать через горящие обручи определений функций, которую влечет за собой применение [[unique_ptr|std::unique_ptr]].

> - Идиома `Pimpl` уменьшает время построения приложения, снижая зависимости компиляции между клиентами и реализациями классов.
> 
> - Для указателей `plmpl` типа [[unique_ptr|std::unique_ptr]] следует объявлять специальные функции-члены в заголовочном файле, но реализовывать их в файле реализации. Поступайте так, даже если реализации функций по умолчанию являются приемлемыми.
> 
> - Приведенный выше совет применим к интеллектуальному указателю [[unique_ptr|std::unique_ptr]], но не к [[shared_ptr|std::shared_ptr]].






































