# Как просмотреть выведенные типы
Выбор инструментов для просмотра результатов вывода типа зависит от фазы про­цесса разработки программного обеспечения, на которой вы хотите получить эту инфор­мацию. Мы рассмотрим три возможности: получение информации о выводе типа при редактировании кода, во время компиляции и во время выполнения.
## Редакторы IDE
Редакторы исходных текстов в **IDE** часто показывают типы программных сущностей (например, переменных, параметров, функций и т.п.), когда вы, например, помещаете указатель мыши над ними. Например, пусть у вас есть код
```c++
const int theAnswer = 42;
auto х = theAnswer;
auto у = &theAnswer;
```

Редактор, скорее всего, покажет, что выведенный тип `х` представляет собой `int`, а выведенный тип `у - const int *`.
Чтобы это сработало, ваш код должен быть в более-менее компилируемом состоянии, поскольку такого рода информация поставляется среде разработки компилятором С++ (или как минимум его клиентской частью}, работающим в IDE. Если компилятор не в состоянии получить достаточно информации о вашем коде, чтобы выполнить вывод типа, вы не сможете увидеть выведенные типы.
Для простых типов наподобие `int` информация из IDE в общем случае вполне точна. Однако, как вы вскоре увидите, когда приходится иметь дело с более сложными типами, информация, выводимая IDE, может оказаться не особенно полезной.
## Диагностика компилятора
Эффективный способ заставить компилятор показать выведенный тип - использо­вать данный тип так, чтобы это привело к проблемам компиляции. Сообщение об ошибке практически обязательно будет содержать тип, который к ней привел.
Предположим, например, что мы хотели бы узнать типы, выведенные для `х` и `у` из предыдущего примера. Сначала мы объявляем шаблон класса, но не определяем его. Чего то такого вполне хватит:
```c++
template<typename Т>
class TD;
```
Попытки инстанцировать этот шаблон приведут к сообщению об ошибке, поскольку ин­станцируемый шаблон отсутствует. Чтобы увидеть типы `х` и `у`, просто попробуйте ин­станцировать TD с их типами:
```c++
TD<decltype(x)> хТуре;                   // Сообщение об ошибке будет
TD<decltype(y)> уТуре;                   // содержать типы х и у
```
Я использую имена переменных вида `variableNameType`, чтобы проще найти интере­сующую меня информацию в сообщении об ошибке. Мой компилятор для приведенного выше кода сообщает, в частности, следующее (я выделил интересующую меня информа­цию о типах):
```c++
error: aggregate 'TD<int> хТуре' has incomplete type and
cannot Ье defined
error: aggregate 'TD<const int *> уТуре' has incomplete type
and cannot Ье defined
```
Другой компилятор выдает ту же информацию, но в несколько ином виде:
```c++
error: 'хТуре' uses undefined class 'TD<int>'
error: 'уТуре' uses unde fined class 'TD<const int *>'
```
Если н е учитывать разницу в оформлении, все протестированные мною компиляторы при использовании этого метода генерировали сообщения об ошибках с интересующей меня информацией о типах.
## Вывод времени выполнения
Подход с использованием функции вывода для отображения сведений о типе может быть использован только во время выполнения программы, зато он предоставляет пол­ ный контроль над форматированием вывода. Вопрос в том, чтобы создать подходящее для вывода текстовое представление информации. "Без проблем, - скажете вы. - Нам на помощь придут [[typeid|typeid]] и `std::type_info::name`: В наших поисках информации о выведенных для `х` и `у` типах можно написать следующий код:
```c++
std::cout << typeid(x).name() << '\n';                // Выведенные типы
std::cout << typeid(y).name() << '\n';                // для х и у
```
Этот подход основан на том факте, что вызов [[typeid|typeid]] для такого объекта, как `х` или `у`, дает объект `std::type_info`, а он имеет функцию-член `name`, которая дает С-строку (т.е. `const char*`), представляющую имя типа.
Не гарантируется, что вызов `std::type_info::name` вернет что-то разумное, но его реализации изо всех сил пытаются быть полезными. Уровень этой полезности варьируется от компилятора к компилятору. Компиляторы GNU и Clang, например, сообща­ют, что тип `х` - это "i'; а тип `у` - "PKi". Эти результаты имеют смысл, если вы будете знать, что "i" у данных компиляторов означает "int"; а "рк" - "указатель на константу":
(Оба компилятора поддерживают инструмент `c++filt`, который расшифровывает эти имена.) Компилятор Microsoft генерирует менее зашифрованный вывод: "int" для `х` и " int const * " для `у`.
Поскольку это корректные результаты для типов `х` и `у`, вы можете подумать, что за­дача получения информации о типах решена, но не делайте скоропалительных выводов.
Рассмотрим более сложный пример:
```c++
template<typename Т>                     // Шаблонная функция,
void f(const Т& param);                  // вызываемая далее
 
std::vector<Widget> createVec();         // Фабричная функция

const auto vw = createVec();             // Инициализация vw возвратом
										 // фабричной функции
										 
if(!vw.empty())
	f(&vw[O]);                           // Вызов f
```
Этот код, включающий пользовательский тип (`Widget`) , контейнер `STL` ([[vector|std::vector]]) и переменную [[auto|auto]] (vw) , является более представительным и интересным примером. Было бы неплохо узнать, какие типы выводятся для параметра типа шаблона `Т` и для параметра `param` функции `f`.
Воспользоваться `typeid` в этой задаче достаточно просто. Надо всего лишь добавить немного кода в функцию `f` для вывода интересующих нас типов:
```c++
template<typename Т>
void f(const Т& param)
{
	using std::cout;

	// Вывод в nоток cout типа Т :
	cout << "Т = " << typeid(T).name() << '\n';


	// Вывод в лоток cout типа param:
	cout << "param = " << typeid(param).name() << '\n' ;
}
```
Выполнимые файлы, полученные с помощью компиляторов **GNU** и **Clang**, дают сле­дующий результат:
```c++
Т     = PKбWidget
param = PK6Widget
```
Мы уже знаем, что в этих компиляторах `РК` означает указатель на константу, так что вся загадка - в цифре 6. Это просто количество символов в следующем за ней имени класса (`Widget`) . Таким образом, данные компиляторы сообщают нам, что и `Т`, и `param` имеют один и тот же тип - `const Widget *`.
Компилятор Microsoft согласен:
```c++
Т      = class Widget const *
param  = class Widget const *
```
Три независимых компилятора дают одну и ту же информацию, что свидетельствует о том, что эта информация является точной. Но давайте посмотрим более внимательно. В шаблоне `f` объявленным типом `param` является тип `const Т&`. В таком случае не кажется ли вам странным, что и `Т`, и `param` имеют один и тот же тип? Если тип `Т`, например, представляет собой `int`, то типом `param` должен быть `const int &` совершенно другой тип.
К сожалению, результат `std::type_info::name` ненадежен. Например, в данном случае тип, который все три компилятора приписывают `param`, является неверным. Кроме того, он по сути обязан быть неверным, так как спецификация `std::type_info::name` разрешает, чтобы тип рассматривался как если бы он был передан в шаблонную функ­цию по значению. Как поясняется в [[Вывод типа шаблона|разделе]] , это означает, что если тип является ссылкой, его "ссылочность" игнорируется, а если тип после удаления ссылочности оказывается [[const|const]] (или [[volatile|volatile]]) , то соответствующие модификаторы также игнорируются. Вот почему информация о типе `param` - который на самом деле представляет собой `const Widget* const&` выводится как `const Widget*`. Сначала удаляется ссылочность, а затем у получившегося указателя удаляется константность.
Не менее печально, что информация о типе, выводимая редакторами IDE, также ненадежна - или как минимум ненадежно полезна. Для этого же примера мой редактор IDE сообщает о типе `T` как (я не придумываю!):
```c++
const std::_Simple types<std::_Wrap_alloc<std::_Vec_base_types<Widge t ,
std::allocator<W1dget>>::Alloc>::value type>::value_type *
```
Тот же редактор IDE показывает, что тип `param` следующий:
```c++
const std::Simple_types<. . .>::value_type *const &
```
Это выглядит менее страшно, чем тип `Т`, но троеточие в средине типа сбивает с толку, пока вы не поймете, что это редактор IDE попытался сказать "Я опускаю все, что являет­ся частью типа `T`": Ваша среда разработки, быть может, работает лучше моей - если вы достаточно везучий.
Если вы склонны полагаться на библиотеки больше, чем на удачу, то будете рады узнать, что там, где `std::tуре_info::name` и **IDE** могут ошибаться, библиотека **Boost Typelndex** (часто именуемая как **Boost.Typelndex**) приведет к успеху. Эта библиотека не является частью стандарта С++, но точно так же частью стандарта не являются ни IDE, ни шаблоны наподобие рассмотренного выше `TD`. Кроме того, тот факт, что библиотеки Boost (доступные по адресу boost . org } являются кроссплатформенными, с открытым исходным кодом и с лицензией, разработанной так, чтобы быть приемлемой даже для самых параноидальных юристов, означает, что код с применением библиотек **Boost** переносим практически так же хорошо, как и код, основанный на стандартной биб­лиотеке.
Вот как наша функция `f` может выдать точную информацию о типах с использовани­ем **Boost.Typelndex**:
```c++
#include <boost/type_index.hpp>

template<typename Т>
void f(const Т& param)
{
	using std::cout;
	using Ьoost::typeindex::type_id_with_cvr;

	// Вывод информации о Т
	cout << "Т = "
		<< type_id_with_cvr<T>().pretty_name()
		<< '\n';

	// Вывод информации о типе param
	cout << "param = "
		<< type_id_with_cvr<decltype(param)>().pretty_пame()
		<< '\n';
}
```
Как это работает? Шаблон функции `boost::typeindex::type_id_with_cvr` получает аргумент типа (тип, о котором мы хотим получить информацию) и не удаляет [[const|const]], [[volatile|volatile]] или квалификатор ссылки (о чем и говорит "with_cvr" в имени шаблона). Результатом является объект `boost::typeindex::type_index`, функция-член `pretty_name` которого дает `std::string` с удобочитаемым представлением типа.
При такой реализации `f` обратимся вновь к вызову, который давал нам неверную ин­формацию о типе `param` при использовании `typeid`:
```c++
std::vector<Widget> createVec();       // Фабричная функция

const auto vw = createVec();           // Инициализация vw с помощью
									   // фабричной функции
									   
if(!vw.empty()){
	f(&vw[O]);                         // Вызов f
}
```
После компиляции с помощью компиляторов GNU и Clang Boost.Typelndex дает следую­щий (точный) результат:
```c++
Т         = Widget const *
param     = Widget const * const &
```
Применение компилятора Microsoft дает по сути то же самое:
```c++
Т        = class Widget const *
pararn   = class Widget const * const &
```
Такое единообразие - это хорошо, но важно помнить, что редакторы IDE, сообще­ния об ошибках компилятора и библиотеки наподобие Boost.Typelпdex являются всего лишь инструментами, которые можно использовать для выяснения того, какие типы выводит ваш компилятор. Это может быть полезно, но не может заменить понимания ин­формации о выводе типов, приведенной в ранее.

> + Выводимые типы часто можно просмотреть с помощью редакторов IDE, сообще­ний об ошибках компиляции и с использованием библиотеки Boost.Typelпdex.
> + Результаты, которые выдают некоторые инструменты, могут оказаться как неточ­ными, так и бесполезными, так что понимание правил вывода типов в С++ являет­ся совершенно необходимым.









