# Предпочитайте удаленные функции закрытым неопределенным

Если вы предоставляете код другим разработчикам и хотите предотвратить вызов ими некоторой функции, обычно вы просто ее не объявляете. Нет объявления функции - нечего и вызывать. Но иногда С++ объявляет функции вместо вас, и если вы хотите предотвратить вызов таких функций клиентами вашего кода, придется постараться.

Эта ситуация возникает только для "специальных функций-членов", т.е. функций членов, которые при необходимости С++ генерирует автоматически. [[Генерация специальных функций-членов|Эти функции рассматриваются более подробно]], а пока что мы будем беспокоиться только о копирующем конструкторе и копирующем операторе присваивания. Эта глава во многом посвящена распространенным практикам С++98, для которых есть более эффективная замена в С++11, а в С++98, когда вы хотите подавить применение функции-члена, это почти всегда копирующий конструктор, оператор присваивания или они оба.

Подход С++98 для предотвращения применения этих функций состоит в объявлении их как [[private|private]] без предоставления определений. Например, вблизи с основанием иерархии потоков ввода-вывода в стандартной библиотеке С++ находится шаблонный класс `basic_ios`. Все классы потоков наследуют (возможно, косвенно) этот класс. Копирование потоков ввода-вывода нежелательно, поскольку не совсем очевидно, что же должна делать такая операция. Объект `istream`, например, представляет поток входных значений, одни из которых могут уже быть считаны, а другие могут потенциально быть считаны позже. Если копировать такой поток, то должно ли это повлечь копирование всех счи­танных значений, а также значений, которые будут считаны в будущем? Простейший способ разобраться в таких вопросах - объявить их несуществующими. Именно это де­лает запрет на копирование потоков.

Чтобы сделать классы потоков некопируемыми, `basic_ios` в С++98 объявлен следующим образом (включая комментарии):
```c++
template <class charT, class traits = char_traits<charT> >
class basic_ios : puЬlic ios_base {
	public:
		...
	private:
		basic_ios(const basic_ios& );                // Не определен
		basic_ios& operator= (const basic_ios & );   // Не определен
};
```
Объявление этих функций как [[private|private]] предотвращает их вызов клиентами. Умышленное отсутствие их определений означает, что если код, все еще имеющий к ним доступ (т.е. функции-члены или друзья класса), ими воспользуется, то компоновка (редактирование связей) будет неудачной из-за отсутствия определений функций.

В С++ 1 1 имеется лучший способ достичь по сути того же самого: воспользоваться конструкцией "= delete": чтобы пометить копирующий конструктор и копирующее присваивание как удаленные функции. Вот та же часть `basic_ios` в С++11:
```c++
template <class charT, class traits = char_traits<charT> >
class basic_ios : public ios_base {
	public :
		...
		basic_ios(const basic_ios &) = delete;
		basic_ios& operator=(const basic_ios &) = delete ;
};
```
Отличие удаления этих функций от их объявления как [[private|private]] может показаться больше вопросом вкуса, чем чем-то иным, но на самом деле в это заложено больше, чем вы думаете. Удаленные функции не могут использоваться никоим образом, так что даже код функции-члена или функций, объявленных как [[friend|friend]], не будет компилироваться, если попытается копировать объекты basic_ios. Это существенное улучшение по сравнению с поведением С++98, где такое некорректное применение функций не диагностируется до компоновки.

По соглашению удаленные функции объявляются как [[public|public]], а не [[private|private]]. Тому есть причина. Когда код клиента пытается использовать функцию-член, С++ проверяет доступность до проверки состояния удаленности. Когда клиентский код пытается использовать функцию, объявленную как [[private|private]], некоторые компиляторы жалуются на то, что это закрытая функция, несмотря на то что доступность функции никак не влияет на возможность ее использования. Стоит принять это во внимание при пересмотре старого кода и замене не определенных функций-членов, объявленных как [[private|private]], удаленными, поскольку объявление удаленных функций как [[public|public]] в общем случае приводит к более корректным сообщениям об ошибках.

Важным преимуществом удаленных функций является то, что удаленной может быть любая функция, в то время как быть [[private|private]] могут только функции-члены. Предположим, например, что у нас есть функция, не являющаяся членом, которая принимает целочисленное значение и сообщает, является ли оно "счастливым числом":
```c++
bool isLucky(int number};
```
То, что С++ является наследником С, означает, что почти любой тип, который можно рассматривать как отчасти целочисленный, будет неявно преобразовываться в `int`, но некоторые компилируемые вызовы могут не иметь смысла:
```c++
if (isLucky('а')) ...                // Является ли 'а' счастливым числом?
if (isLucky(true)) ...               // Является ли true счастливым числом?
if (isLucky(З.5)) ...                // Следует ли вьшолнить усечение до 3
                                     // перед проверкой на "счастливость" ?
```
Если счастливые числа действительно должны быть только целыми числами, хотелось бы предотвратить такие вызовы, как показано выше.

Один из способов достичь этого - создание удаленных перегрузок для типов, которые мы хотим отфильтровывать:
```c++
bool isLucky(int number);            // Исходная функция
bool isLucky(char) = delete;         // Отвергаем символы
bool isLucky(bool) = delete;         // Отвергаем булевы значения
bool isLucky(double) = delete;       // Отвергаем double и float
```
(Комментарий у перегрузки с `double`, который гласит, что отвергаются как `double`, так и `float`, может вас удивить, но ваше удивление исчезнет, как только вы вспомните, что при выборе между преобразованием `float` в `int` и `float` в `double` С++ предпочитает преобразование в `double`. Вызов `isLucky` со значением типа `float` приведет к вызову перегрузки с типом `double`, а не `int`. Вернее, постарается привести. Тот факт, что данная перегрузка является удаленной, не позволит скомпилировать такой вызов.)

Хотя удаленные функции использовать нельзя, они являются частью вашей программы. Как таковые они принимаются во внимание при разрешении перегрузки. Вот почему при указанных выше объявлениях нежелательные вызовы `isLucky` будут отклонены:
```c++
if (isLucky('а')) ...                // Ошибка ! Вызов удаленной функции
if (isLucky(true)) ...               // Ошибка !
if (is1ucky(3.5f)) ...               // Ошибка !
```
Еще один трюк, который могут выполнять удаленные функции (а функции-члены, объявленные как [[private|private]] - нет), заключается в предотвращении использования инстанцирований шаблонов, которые должны быть запрещены. Предположим, например, что нам нужен шаблон, который работает со встроенными указателями:
```c++
template<typename Т>
void processPointer (T* ptr);
```
В мире указателей есть два особых случая. Один из них - указатели [[void*|void*]], поскольку их нельзя разыменовывать, увеличивать или уменьшать и т.д. Второй - указатели [[char*|char*]], поскольку они обычно представляют указатели на С-строки, а не на отдельные символы. Эти особые случаи часто требуют особой обработки; будем считать, что в случае шаблона `processPointer` эта особая обработка заключается в том, чтобы отвергнуть вызовы с такими типами (т.е. должно быть невозможно вызвать `processPointer` с указателями типа [[void*|void*]] или [[char*|char*]] ).

Это легко сделать. Достаточно удалить эти инстанцирования:
```c++
template<>
void processPointer<void>(void*) = delete;

template<>
void processPointer<char>(char*) = delete;
```
Теперь, если вызов `processPointer` с указателями [[void*|void*]] или [[|char*]] является некорректным, вероятно, таковым же является и вызов с указателями `const void*` или `const char*`, так что эти инстанцирования обычно также следует удалить:
```c++
template<>
void processPointer<const void> (const void*) = delete;

template<>
void processPointer<const char> (const char*) = delete;
```
И если вы действительно хотите быть последовательными, то вы также удалите перегрузки `const volatile void*` и `const volatile char *`, а затем приступите к работе над перегрузками для указателей на другие стандартные типы символов: [[wchar_t|wchar_t]], [[char16_t|char16_t]] и [[char32_t|char32_t]].

Интересно, что если у вас есть шаблон функции внутри класса и вы попытаетесь отключить некоторые инстанцирования, объявляя их [[private|private]] (в духе классического соглашения С++98), то у вас ничего не получится, потому что невозможно дать специализации шаблона функции-члена другой уровень доступа, отличный от доступа в главном шаблоне. Например, если `processPointer` представляет собой шаблон функции-члена в `Widget` и вы хотите отключить вызовы для указателей [[void*|void*]], то вот как будет выглядеть (не компилируемый) подход С++98:
```c++
class Widget
	public :
		...
		template<typename Т>
		void processPointer (T* ptr)
			{ ... }
	
	private:
		template<>                              // Ошибка!
		void processPointer<void> (void*);
};
```
Проблема заключается в том, что специализации шаблона должны быть написаны в области видимости пространства имен, а не области видимости класса. Эта проблема не возникает для удаленных функций, поскольку они не нуждаются в другом уровне доступа. Они могут быть удалены за пределами класса (а следовательно, в области видимости пространства имен):
```c++
class Widget {
	public:
		...
		template<typenarne Т>
		void processPointer (T *ptr)
		{ ... )
);
		 
template<>                          // Все еще public, но удаленная
void Widget::processPointer<void> (void*) = delete;
```
Истина заключается в том, что практика С++98 объявления функций [[private|private]] без их определения в действительности была попыткой добиться того, для чего на самом деле созданы удаленные функции С++11. Будучи всего лишь имитацией, подход С++98 работает не так хорошо, как вещь, которую он имитирует. Он не работает вне классов, не всегда работает внутри классов, а когда работает, то может не работать до компоновки. Так что лучше придерживаться удаленных функций.

> - Предпочитайте удаленные функции закрытым функциям без определений.
> 
> - Удаленной может быть любая функция, включая функции, не являющиеся членами, и инстанцирования шаблонов.









