
[[#Объявление auto|Объявление auto]]
	[[#Предпочитайте auto явному объявлению типа|Предпочитайте auto явному объявлению типа]]
	[[#Если auto выводит нежелательный тип, используйте явно типизированный инициализатор|Если auto выводит нежелательный тип, используйте явно типизированный инициализатор]]
[[#auto C++11|auto C++11]]
[[#auto C++14|auto C++14]]
[[#Новые правила вывода типа auto при фигурной инициализации C++17|Новые правила вывода типа auto при фигурной инициализации C++17]]
[[#Вывод типа auto|Вывод типа auto]] 1.4.4(STL)
[[#Особые случаи вывода auto|Особые случаи вывода auto]] 15.10.4(template)

# Объявление auto

Концептуально объявление **auto** настолько простое, насколько может быть, но все же сложнее, чем выглядит. Его применение экономит исходный текст, вводимый про­граммистом, но при этом предупреждает появление вопросов корректности и произво­дительности, над которыми вынужден мучиться программист при ручном объявлении типов. Кроме того, некоторые выводы типов **auto**, хотя и послушно соблюдают предписанные алгоритмы, дают результаты, некорректные с точки зрения программиста. Когда такое происходит, важно знать, как привести **auto** к верному ответу, поскольку возврат к указанию типов вручную - альтернатива, которой чаще всего лучше избегать.

## Предпочитайте auto явному объявлению типа

Легко и радостно написать

```c++
int х ;
```

Стоп! Я забыл инициализировать `х`, так что эта переменная имеет неопределенное значение. Может быть. Но она может быть инициализирована и нулем - в зависимости от контекста. Жуть!
Ну, ладно. Давайте лучше порадуемся объявлению локальной переменной, инициали­зированной разыменованием итератора:

```c++
template<typename it>             // Некий алгоритм, работающий с
void dwim(it b, it е)             // элементами из диапазона от b до e
{
	while(b != е)
		typename std::iterator_traits<it>::value_type
			currValue = *b;
	}
}
```

Жуть. `typename std::iterator_traits<it>::value_type` - просто чтобы записать тип значения, на которое указывает итератор? 

Попробую объявить локальную переменную, тип которой такой же, как у лямбда-выражения. Но его тип известен только компилятору.Мы дождались С++11, в котором все эти проблемы решены с помощью ключевого слова `auto`. Тип переменных, объявленных как `auto`, выводится из их инициализатора, так что они обязаны быть инициализированными. Это значит - прощай проблема неинициализированных переменных:

```c++
int x1;                  //Потенциально неинициализированная переменная
auto х2;                 // Ошибка Требуется инициализатор
auto хЗ = О;             // Все отлично, переменная х корректно определена
```

Нет проблем и с объявлением локальной переменной, значением которой является разы­менование итератора:

```c++
template<typename It>               // Все, как и ранее
void dwim(It b, It е)
{
	while(b != е){
		auto currValue = *b;
	}
}		
```

А поскольку `auto` использует [[Вывод типа auto|вывод типов]], он может представлять типы, известные только компиляторам:
```c++
auto derefUPLess =                        // Функция сравнения
[](const std::unique_ptr<Widget>& p1,     // объектов Widget, на
const std::uпique_ptr<Widget>& р2)        // которые указывают
{ returп *p1 < *р2; );                    // std::unique_ptr
```
В С++14 все еще круче, потому что параметры лямбда-выражений также могут включать `auto`:

```c++
auto derefLess =                           // Функция сравнения в С++14
[](const auto& p1,                         // для значений на которые
const auto& р2)                            // указывает что угодно
{ return *pl < *р2; );                     // указателеобразное 
```

Несмотря на всю крутость вы, вероятно, думаете, что можно обойтись и без `auto` для объявления переменной, которая хранит лямбда-выражение, поскольку мы можем исполь­зовать объект [[function|std::function]]. Это так, можем, но, возможно, это не то, что вы на самом деле подразумеваете. 

Поскольку лямбда-выражения дают вызываемые объекты, замыкания могут хра­ниться в объектах `std::function`. Это означает, что можно объявить С++11 -версию `derefUPLess` без применения `auto` следующим образом:

```c++
std::function<Ьool(const std::unique_ptr<Widqet>& ,
                   const std::unique_ptr<Widqet>&)>
derefUPLess = [](const std::unique_ptr<Widget>& p1,
                 const std::unique_ptr<Widget>& р2)
	{ return *p1 < *p2; }
```

Важно понимать, что, даже если оставить в стороне синтаксическую многословность и необ­ходимость повторения типов параметров, использование [[function|std::function]] не то же самое, что использование `auto`. Переменная, объявленная с использованием `auto` и хранящая замыкание, имеет тот же тип, что и замыкание, и как таковая использует только то количество памяти, которое требуется замыканию. Тип переменной, объявленной как [[function|std::function]] и хранящей замыкание, представляет собой конкретизацию шаблона [[function|std::function]], которая имеет фиксированный размер для каждой заданной сигнатуры. Этот размер может быть не адекватным для замыкания, которое требуется хранить, и в этом случае конструктор [[function|std::function]] будет выделять для хранения замыкания динамическую память. В результате объект [[function|std::function]] использует больше памяти, чем объект, объявленный с помощью `auto`. Кроме того, из-за деталей реализации это ограничивает возможности встраивания и приводит к косвенным вызовам функции, так что вызовы замыкания через объект [[function|std::function]] обычно выполняются медленнее, чем вызовы посредством объекта, объявленного как `auto`. Другими словами, подход с использованием [[function|std::function]] в общем случае более громоздкий, требующий больше памяти и более медленный, чем подход с помощью `auto`, и к тому же может приводить к генерации исключений, связанных с не­хваткой памяти. Ну и, как вы уже видели в примерах выше, написать `"auto"` гораздо проще, чем указывать тип для инстанцирования [[function|std::function]]. В соревновании между `auto` и [[function|std::function]] для хранения замыкания побеждает `auto`. (Подобные аргументы можно привести и в пользу предпочтения `auto` перед [[function|std::function]] для хранения результатов вы­зовов `std::Ьind`, но все равно в [[Lambda#Обобщенные лямбда-выражения C++14|разделе]] я делаю все, чтобы убедить вас использовать вместо `std::bind` [[Lambda|Лямбда-выражения]]".)

Преимущества `auto` выходят за рамки избегания неинициализированных перемен­ных, длинных объявлений переменных и возможности непосредственного хранения замыкания. Кроме того, имеется возможность избежать того, что я называю проблемой "сокращений типа" (type shortcuts). Вот кое-что, что вы, вероятно, уже видели, а возможно, даже писали:

```c++
std::vector<int> v;

unsigned sz = v.size();
```

Официальный возвращаемый тип `v.size()` - `std::vector<int>::size_type`, но об этом знает не так уж много разработчиков. `std::vector<int>::size_type` определен как беззнаковый целочисленный тип, так что огромное количество программистов считают, что unsigned вполне достаточно, и пишут исходные тексты, подобные показанному выше. Это может иметь некоторые интересные последствия. В 32-разрядной Windows, например, и `unsigned`, и `std::vector<int>::size_type` имеют один и тот же размер, но в 64-разрядной Windows `unsigned` содержит 32 бита, а `std::vector<int>::size_type` - 64 бита. Это означает, что код, который работал в 32-разрядной Windows, может вести себя некор­ректно в 64-разрядной Windows. И кому хочется тратить время на подобные вопросы при переносе приложения с 32-разрядной операционной системы на 64-разрядную?

Применение `auto` гарантирует, что вам не придется этим заниматься:

```c++
auto sz = v.size();           // Тип sz - std::vector<int>::size_type
```

Все еще не уверены в разумности применения `auto`? Тогда рассмотрите следующий код.

```c++
std::unordered_map<std::string, int> m;
...
for (const std::pair<std::string, int>& р : m)
{
	// Что-то делаем с р
}
```

Выглядит вполне разумно . . . но есть одна проблема. Вы ее не видите?

Чтобы разобраться, что здесь не так, надо вспомнить, что часть [[unordered_map|std::unordered_map]], содержащая ключ, является константной, так что тип [[pair|std::раir]] в хеш-таблице (которой является [[unordered_map|std::unordered_map]]) вовсе не `std::pair<std::string, int>`, а `std::pair<const std::string, int>`. Но переменная `р` в приведенном выше цикле объявлена иначе. В результате компилятор будет искать способ преобразовать объекты `std::pair<const std::string, int>` (хранящиеся в хеш-таблице) в объекты `std::pair<std::string, int>` (объявленный тип `р`). Этот способ - создание временного объекта типа, требуемого `р`, чтобы скопировать в него каждый объект из `m` с последующим связыванием ссылки `р` с этим временным объектом. В конце каждой итерации цикла времен­ный объект уничтожается. Если этот цикл написан вами, вы, вероятно, будете удивлены его поведением, поскольку почти наверняка планировали просто связывать ссылку `р` с каждым элементом в `m`.

Такое непреднамеренное несоответствие легко лечится с помощью `auto`:
```c++
for(const auto& p : m)
{
	...                                       // Как и ранее
}
```
Это не просто более эффективно - это еще и менее многословно. Кроме того, этот код имеет очень привлекательную особенность - если вы возьмете адрес `р`, то можете быть уверены, что получите указатель на элемент в `m`. В коде, не использующем `auto`, вы получите указатель на временный объект - объект, который будет уничтожен в конце итерации цикла.

Два последних примера - запись `unsigned` там, где вы должны были написать `std::vector<int>::size_type`, и запись `std::pair<std::string, int>` там, где вы должны были написать `std::pair<const std::string, int>`, - демонстрируют, как явное указание типов может привести к неявному их преобразованию, которое вы не хотели и не ждали. Если вы используете в качестве типа целевой переменной `auto`, вам не надо беспокоиться о несоответствиях между типом объявленной переменной и типом инициализирующего ее выражения.

Таким образом, имеется несколько причин для предпочтительного применения `auto` по сравнению с явным объявлением типа. Но `auto` не является совершенным. Тип для каждой переменной, объявленной как `auto`, выводится из инициализирующего ее выражения, а некоторые инициализирующие выражения имеют типы, которые не предполагались и нежелательны. Условия, при которых возникают такие ситуации, и что при этом можно сделать, рассматриваются в [[Вывод типа auto|разделе "Вывод типа auto"]] и [[auto#Если auto выводит нежелательный тип, используйте явно типизированный инициализатор|разделе "Если auto выводит нежелательный тип, используйте явно типизированный инициализатор"]], поэтому здесь я не буду их рассматривать. Вместо этого я уделю внимание другому вопросу, который может вас вол­новать при использовании `auto` вместо традиционного объявления типа - удобочитае­мость полученного исходного текста.

Применение `auto` - возможность, а не требование. Если, в соответствии с вашими профессиональными представлениями, ваш код будет понятнее или легче сопровождаемым или лучше в каком-то ином отно­шении при использовании явных объявлений типов, вы можете продолжать их использовать. Но имейте в виду, что С++ - не первый язык, принявший на вооружение то, что в мире языков программирования известно как вывод типов (`type inference`). Другие процедурные статически типизированные языки программирования (например, С#, D, Scala, Visual Basic) обладают более или менее эквивалентными возможностями, не гово­ря уже о множестве статически типизированных функциональных языков (например, ML, Haskell, OCaml, F# и др.). В частности, это объясняется успехом динамически типизированных языков программирования, таких как Perl, Python и Ruby, в которых явная типизация переменных - большая редкость. Сообщество разработчиков программного обеспечения имеет обширный опыт работы с выводом типов, и он продемонстрировал, что в такой технологии нет ничего мешающего созданию и поддержке крупных приложений промышленного уровня.

Некоторых разработчиков беспокоит тот факт, что применение `auto` исключает воз­можность определения типа при беглом взгляде на исходный текст. Однако возможно­сти IDE показывать типы объектов часто устраняют эту проблему (даже если принять во внимание обсуждавшиеся в [[Как просмотреть выведенные типы|разделе]] вопросы, связанные с выводом типов в IDE), а во многих случаях абстрактный взгляд на тип объекта столь же полезен, как и точный тип. Зачастую достаточно, например, знать, что объект является контейнером, счетчиком или интеллектуальным указателем, не зная при этом точно, каким именно контейнером, счетчиком или указателем. При правильном подборе имен переменных такая абстракт­ная информация о типе почти всегда оказывается под рукой.

Суть дела заключается в том, что явно указываемые типы зачастую мало что дают, кроме того что открывают возможности для ошибок - в плане как корректности, так и произво­дительности программ. Кроме того, типы `auto` автоматически изменяются при изменении типов инициализирующих их выражений, а это означает облегчение выполнения рефакторинга при использовании `auto`. Например, если функция объявлена как возвращающая `int`, но позже вы решите, что `long` вас больше устраивает, вызывающий код автоматически обно­вится при следующей компиляции (если результат вызова функции хранится в переменной, объявленной как `auto`). Если результат хранится в переменной, объявленной как `int`, вы должны найти все точки вызова функции и внести необходимые изменения.

> *Переменные, объявленные как `auto`, должны быть инициализированы; в общем случае они невосприимчивы к несоответствиям типов, которые могут привести к проблемам переносимости или эффективности; могут облегчить процесс рефак­торинга; и обычно требуют куда меньшего количества ударов по клавишам, чем переменные с явно указанными типами.
> * Переменные, объявленные как `auto`, могут быть подвержены неприятностям, описанным в [[Вывод типа auto|разделе]] и разделе 2.2.

## Если auto выводит нежелательный тип, используйте явно типизированный инициализатор

В [[auto#Объявление auto|разделе]] поясняется, что применение **auto** для объявления переменных предоставляет ряд технических преимуществ по сравнению с явным указанием типов, но ино­гда [[#Вывод типа auto|вывод типа auto]] идет налево там, где вы хотите направо. Предположим, например, что у меня есть функция, которая получает `Widget` и возвращает `std::vector<bool>`, где каждый `bool` указывает, обладает ли `Widget` определенным свойством:
```c++
std::vector<bool> features(const Widget& w);
```
Предположим далее, что пятый бит указывает наличие высокого приоритета у `Widget`. Мы можем написать следующий код.
```c++
Widget w;
...
bool highPriority = features(w)[5];          // Имеет ли w высокий
                                             // приоритет?
...
processWidget(w, highPriority);              // Обработка w в соответ­
                                             // ствии с приоритетом
```
В этом коде нет ничего неверного. Он корректно работает. Но если мы внесем кажущееся безобидным изменение и заменим явный тип `highPriority` типом `auto`
```c++
auto highPriority = features(w)[5];          // Имеет ли w высокий
                                             // приоритет?
```
то ситуация изменится. Код будет продолжать компилироваться, но его поведение боль­ше не будет предсказуемым:
```c++
processWidget(w, highPriority);               // Неопределенное поведение !
```
Как указано в комментарии, вызов `processWidget` теперь имеет неопределенное поведение. Но почему? Ответ, скорее всего, вас удивит. В коде, использующем `auto`, тип `highPriority` больше не является `bool`. Хотя концептуально `std::vector<bool>` хранит значения `bool`, `operator[]` у `std::vector<bool>` не возвращает ссылку на элемент кон­тейнера (то, что `std::vector::operator[]` возвращает для всех типов за исключением `bool`). Вместо этого возвращается объект типа `std::vector<bool>::reference` (класса, вложенного в `std::vector<bool>`).

Тип `std::vector<bool>::reference` существует потому, что `std::vector<bool>` определен как хранящий значения `bool` в упакованном виде, по одному биту на каждое значение. Это создает проблему для оператора `operator[]` класса `std::vector<bool>`, поскольку `operator[]` класса `std::vector<T>` должен возвращать `Т&`, но С++ запрещает ссылаться на отдельные биты. Будучи не в состоянии вернуть `bool&`, `operator[]` класса `std::vector<bool>` возвращает объект, который действует подобно `bool&`. Для успешной работы объекты `std::vector<bool>::reference` должны быть применимы по сути во всех контекстах, где применим `bool&`. Среди прочих возможностей `std::vector<bool>::reference` обладает неявным преобразованием в `bool`. (Не в `bool&`, а именно в `bool`. Пояснение всего набора методов, используемых `std::vector<bool>::reference` для эмуляции поведения `bool&`, завело бы нас слишком далеко, так что я просто замечу, что это неявное преобразование является только одним из камней в существенно большей мозаике.)

С учетом этой информации посмотрим еще раз на следующую часть исходного кода:
```c++
bool highPriority = features(w)[5];          // Явное объявление типа
                                             // highPriority
```
Здесь `features` возвращает объект `std::vector<bool>`, для которого вызывается `operator[]`. Этот оператор возвращает объект типа `std::vector<bool>::reference`, который затем неявно преобразуется в значение типа `bool`, необходимое для инициали­зации `highPriority`. Таким образом, `highPriority` в конечном итоге получает значение пятого бита из `std::vector<bool>`, возвращенного функцией `features`, так, как и предполагалось.

Но что же произойдет, если переменная `highPriority` будет объявлена как `auto`?
```c++
auto highPriority = features(w)[5];           // Вывод типа highPriority
```
Функция `features`, как и ранее, возвращает объект типа `std::vector<bool>`, и, как и ранее, выполняется его `operator[]`. Оператор возвращает объект типа `std::vector<bool>::reference`, но дальше привычный ход событий изменяется, так как `auto` приводит к выводу типа переменной `highPriority`. Теперь переменная `highPriority` не получает значение пятого бита `std::vector<bool>`, возвращенного вызовом `features`.

Полученное ею значение зависит от того, как реализован тип `std::vector<bool>::reference`. Одна из реализаций таких объектов состоит в том, чтобы содержать указа­тель на машинное слово с интересующим нас битом и смещение этого бита в слове. Рассмотрим, что это означает для инициализации `highPriority`, в предположении, что имеет место именно такая реализация `std::vector<bool>::reference`.

Вызов `features` возвращает временный объект `std::vector<bool>`. Этот объект не имеет имени, но для упрощения нашего рассмотрения я буду называть его `temp`. Для `temp` вызывается `operator[]`, в результате чего возвращается объект `std::vector<bool>::reference`, содержащий указатель на слово в структуре данных, хранящей интересующий нас бит (эта структура находится под управлением `temp`), плюс смещение в слове, соответствующее пятому биту. Переменная `highPriority` представ­ляет собой копию этого объекта `std::vector<bool>::reference`, так что `highPrioritу` тоже содержит указатель на слово в `temp` плюс смещение, соответствующее пятому биту. В конце инструкции объект `temp` уничтожается, так как это объект временный. В результате переменная `highPriority` содержит висячий указатель, что и дает неопределенное поведение при вызове `processWidget`:
```c++
processWidget(w, highPriority);      // Неопределенное поведение
                                     // highPriority содержит
                                     // висячий указатель 
```
Класс `std::vector<bool>::reference` является примером прокси-класса (`proxy class`), т.е. класса, цель которого - эмуляция и дополнение поведения некоторого другого типа. Прокси-классы применяются для множества разных целей. Например, `std::vector<bool>::reference` нужен для того, чтобы создать иллюзию, что `operator[]` класса `std::vector<bool>` возвращает ссылку на бит, а интеллектуальные указатели стандартной библиотеки являются прокси классами, которые добавляют к обычным указателям управление ресурсами. Полезность прокси-классов - давно установленный и не вызывающий сомнения факт. Фактически шаблон проектирования "Прокси" - один из наиболее давних членов пантеона шаблонов проектирования программного обеспечения.

Одни прокси-классы спроектированы так, чтобы быть очевидными для клиентов. Это, например, такие классы, как [[shared_ptr|std::shared_ptr]] и [[unique_ptr|std::unique _ptr]]. Другие прокси-классы спроектированы для более-менее невидимой работы. Примером такого "невидимого" прокси-класса является `std::vector<bool>::reference`, как и его собрат `std::Ьitset::reference` из класса `std::Ьitset`.

В этом же лагере находятся и некоторые классы библиотек С++, применяющих технологию, известную как шаблоны выражений (expression templates). Такие библиотеки изна­чально разрабатывались для повышения эффективности кода для числовых вычислений. Например, для заданного класса `Matrix` и объектов `m1`, `m2`, `mЗ` и `m4` класса `Matrix`, выражение
```c++
Matrix sum = m1 + m2 + mЗ + m4;
```
может быть вычислено более эффективно, если `operator+` для объектов `Matrix` возвращает не сам результат, а его прокси-класс. Иначе говоря, `operator+` для двух объектов `Matrix` должен возвращать объект прокси-класса, такого как `Sum<Matrix, Matrix>`, а не объект `Matrix`. Как и в случае с `std::vector<bool>::reference` и `bool`, должно иметься неявное преобразование из прокси-класса в `Matrix`, которое позволит инициализиро­вать `sum` прокси-объектом, полученным из выражения справа от знака "='. (Тип этого объекта будет традиционно кодировать все выражение инициализации, т.е. быть чем-то наподобие `Sum<Sum<Sum<Matrix, Matrix>, Matrix>, Matrix>`. Определенно, это тип, от которого следует защитить клиентов.)

В качестве общего правила "невидимые" прокси-классы не умеют хорошо работать вместе с `auto`. Для объектов таких классов зачастую не предусматривается существование более длительное, чем одна инструкция, так что создание переменных таких типов, как правило, нарушает фундаментальные предположения проекта библиотеки. Это справедливо для `std::vector<bool>::reference`, и мы видели, как нарушение предположений ведет к неопределенному поведению.

Следовательно, надо избегать кода следующего вида:
```c++
auto someVar = выражение с типом "невидимого " прокси-класса;
```
Но как распознать, когда используется прокси-объект? Программное обеспечение, использующее невидимый прокси, вряд ли станет его рекламировать. Ведь эти прокси объекты должны быть невидимыми, по крайней мере концептуально! И если вы обнару­жите их, то действительно ли следует отказываться от `auto` и массы преимуществ, про демонстрированных для него в [[auto#Предпочитайте auto явному объявлению типа|разделе "Предпочитайте auto явному объявлению типа"]]?

Давайте сначала зададимся вопросом, как найти прокси. Хотя "невидимые" прокси классы спроектированы таким образом, чтобы при повседневном применении "летать вне досягаемости радара программиста", использующие их библиотеки часто документируют такое применение. Чем лучше вы знакомы с основными проектными решениями используемых вами библиотек, тем менее вероятно, что вы пропустите такой прокси незамеченным.

Там, где документация слишком краткая, на помощь могут прийти заголовочные файлы. Возможность сокрытия прокси-объектов в исходном коде достаточно редка. Обыч­но прокси-объекты возвращаются из функций, которые вызываются клиентами, так что сигнатуры этих функций отражают существование прокси-объектов. Например, вот как выглядит `std::vector<bool>::operator[]`:
```c++
namespace std {                                  //Из стандарта С++
	template <class Allocator>
	class vector<bool, Allocator> {
		puЬlic:
			...
			class reference { ... };
			
			reference operator [] (size_type n);
	};
}
```
В предположении, что вы знаете, что `operator[]` у `std::vector<T>` обычно возвращает `Т&`, необычный возвращаемый тип у `operator[]` в данном случае должен навести вас на мысль о применении здесь прокси-класса. Уделяя повышенное внимание используе­мым интерфейсам, часто можно выявить наличие прокси-классов. 

На практике многие разработчики обнаруживают применение прокси-классов только тогда, когда пытаются отследить источник таинственных проблем при компиляции или отладить никак не проходящий тесты модуль. Независимо от того, как вы его обнаружили, после того как выясняется, что `auto` определен как выведенный тип прокси-клас­са вместо "проксифицируемого" типа, решение не требует отказа от `auto`. Само по себе ключевое слово `auto` проблемой не является. Проблема в том, что `auto` выводит не тот тип, который вам нужен. Решение заключается в том, чтобы обеспечить вывод другого типа. Способ достижения этого заключается в том, что я называю идиомой явной типи­зации инициализатора.

Идиома явной типизации инициализатора включает объявление переменной с ис­пользованием `auto`, но с приведением инициализирующего выражения к тому типу, который должен вывести `auto`. Например, вот как можно использовать эту идиому, чтобы заставить `highPriority` стать переменной типа `bool`:
```c++
auto highPriority = static_cast<Ьool>(features(w)[5]);
```
Здесь `features(w)[5]` продолжает, как и ранее, возвращать объект типа `std::vector<bool>::reference`, но приведение изменяет тип выражения на `bool`, который `auto` затем выводит в качестве типа переменной `highPriority`. Во время выполнения программы объект `std::vector<bool>::reference`, который возвращается вызовом `std::vector<bool>::operator[]`, преобразуется в значение `bool` и в качестве части преобразования выполняется разыменование все еще корректного указателя на `std::vector<bool>`, возвращенного вызовом `features`. Это позволяет избежать неопределенного поведения, с которым мы сталкивались ранее. Затем к битам, на которые указывает указатель, применяется индексация с индексом 5 и полученное значение типа `bool` используется для инициализации переменной `highPriority`.

В примере с `Matrix` идиома явно типизированного инициализатора выглядит следующим образом:
```c++
auto surn = static_cast<Мatrix> (m1 + m2 + mЗ + m4) ;
```
Применение идиомы не ограничивается инициализаторами, производимыми прокси классами. Она может быть полезной для того, чтобы подчеркнуть, что вы сознательно создаете переменную типа, отличного от типа, генерируемого инициализирующим выражением. Предположим, например, что у вас есть функция для вычисления некоторого значения отклонения:
```c++
double calcEpsilon();                 // Возвращает значение отклонения
```
Очевидно, что `calcEpsilon` возвращает значение `douЫe`, но предположим, что вы знае­те, что для вашего приложения точности `float` вполне достаточно и для вас существенная разница в размерах между `float` и `douЬle`. Вы можете объявить переменную типа `float` для хранения результата функции `calcEpsilon`
```c++
float ер = calcEpsilon();            // Неявное преобразование
                                     // douЫe -> float
```
но это вряд ли выражает мысль "я намеренно уменьшаю точность значения, возвращен­ного функцией': Зато это делает идиома явной типизации инициализатора:
```c++
auto ер = static_cast<float>(calcEpsilon());
```
Аналогичные рассуждения применяются, если у вас есть выражение с плавающей точкой, которое вы преднамеренно сохраняете как целочисленное значение. Предположим, что вам надо вычислить индекс элемента в контейнере с итераторами произвольного досту­па (например, [[vector|std::vector]], [[deque|std::deque]] или [[Array|std::array]]} и вы получаете значение типа `douЬle` между 0.0 и 1.0, указывающее, насколько далеко от начала контейнера располо­жен этот элемент (0.5 указывает на середину контейнера). Далее, предположим, что вы уверены в том, что полученный индекс можно разместить в `int`. Если ваш контейнер - `с`, а значение с плавающей точкой - `d`, индекс можно вычислить следующим образом:
```c++
int index = d * (c.size() - 1);
```
Но здесь скрыт тот факт, что вы преднамеренно преобразуете `double` справа от знака "=" в `int`. Идиома явно типизированного инициализатора делает этот факт очевидным:
```c++
auto index = static_cast<int>(d * (c.size() - 1));
```
> - "Невидимые" прокси-типы могут привести `auto` к выводу неверного типа инициализирующего выражения.
> - Идиома явно типизированного инициализатора заставляет `auto` выводить тот тип, который нужен вам

# auto C++11
Переменные с типом `auto` выводятся компилятором в зависимости от типа их инициализатора.

```c++
auto a = 3.14; // double 
auto b = 1; // int 
auto& c = b; // int& 
auto d = { 0 }; // std::initializer_list<int> 
auto&& e = 1; // int&& 
auto&& f = b; // int& 
auto g = new auto(123); // int* 
const auto h = 1; // const int 
auto i = 1, j = 2, k = 3; // int, int, int 
auto l = 1, m = true, n = 1.61; // ошибка - " l "выводится как int,
								//" m` является bool 
auto o; // ошибка - `o` требует инициализатора
```

Это существенно улучшает читаемость:
```c++
std::vector<int> v = ...; 
std::vector<int>::const_iterator cit = v.cbegin(); 
// vs. 
auto cit = v.cbegin();
```

Функции также могут выводить возвращаемый тип с помощью `auto`
```c++
template <typename X, typename Y>
auto add(X x, Y y) -> decltype(x + y) {
  return x + y;
}

add(1, 2); // == 3
add(1, 2.0); // == 3.0
add(1.5, 1.5); // == 3.0
```
# auto C++14

При использовании типа `auto` для возвращаемого значения в C++14, компилятор попытается вывести тип самостоятельно.
```c++
// тип возвращаемого значения `int`.
auto f(int i) {
 return i;
}

template <typename T>
auto& f(T& t) {
  return t;
}

// Возвращает ссылку на выведенный тип
auto g = [](auto& x) -> auto& { return f(x); };
int y = 123;
int& z = g(y); // ссылка на `y`
```

# Новые правила вывода типа auto при фигурной инициализации C++17

Изменился вывод `auto` при использовании универсального синтаксиса инициализации. Раньше для `auto x{ 3 }` тип выводился как `std::initializer_list<int>`, сейчас выводится `int`.

```c++
auto x1{ 1, 2, 3 }; // ошибка: несколько элементов 
auto x2 = { 1, 2, 3 }; // присваивание: decltype(x2) is std::initializer_list<int> 
auto x3{ 3 }; // тип выводится из типа элемента: decltype(x3) is int 
auto x4{ 3.0 }; // тип выводится из типа элемента: decltype(x4) is double
```

# Вывод типа auto

Если вы прочли раздел о выводе типов шаблонов, вы знаете почти все, что следует
знать о выводе типа [[auto|auto]], поскольку за одним любопытным исключением вывод типа [[auto|auto]] представляет собой вывод типа шаблона. Но как это может быть? Вывод типа ша­блона работает с шаблонами, функциями и параметрами, а [[auto|auto]] не имеет дела ни с одной из этих сущностей.

Да, это так, но это не имеет значения. Существует прямая взаимосвязь между выводом типа шаблона и выводом типа [[auto|auto]]. Существует буквальное алгоритмическое преоб­разование одного в другой.

В предыдущем разделе вывод типа шаблона пояснялся с использованием обобщенного шаблона функции
```c++
template<typename Т>
void f(ParamType param) ;
```

и обобщенного вызова
```c++
f(expr);                        // Вызов f с некоторым выражением
```

При вызове `f` компиляторы используют [[expr|expr]] для вывода типов `T` и `ParamType`. Когда переменная объявлена с использованием ключевого слова [[auto|auto]], оно играет роль `Т` в шаблоне, а спецификатор типа переменной действует как `ParamType`. Это проще показать, чем описать, так что рассмотрим следующий пример:
```c++
auto х = 27;
```

Здесь спецификатором типа для `х` является [[auto|auto]] само по себе. С другой стороны, в объ­ явлении
```c++
const auto сх = х;
```

спецификатором типа является `const auto`. А в объявлении
```c++
const auto& rx = х;
```

спецификатором типа является `const auto &`. Для вывода типов для `х`, `сх` и `rx` в приведенных примерах компилятор действует так, как если бы для каждого объявления имелся шаблон, а также вызов этого шаблона с соответствующим инициализирующим выражением:
```c++
template<typename Т>                // Концептуальный шаблон для
void func_for_х(Т param);           // вывода типа х

func_for_x(27);                     // Концептуальный вызов : выведенный
                                    // тип param является типом х

template<typename Т>                // Концептуальный шаблон для
void func_for_cx(const Т param);    // вывода типа сх

func_for_cx(x);                     // Концептуальный вызов : выведенный
                                    // тип param является типом СХ

template<typename Т>                // Концептуальный шаблон для
void func_for_rx(const Т& param);   // вывода типа rx

func_for_rx(x);                     // Концептуальный вызов : выведенный
                                    // тип param является типом rx
```

Как я уже говорилось, вывод типов для [[auto|auto]] представляет собой (с одним исключением, которое мы вскоре рассмотрим) то же самое, что и вывод типов для шаблонов.

[[Вывод типа шаблона|Вывод типов шаблонов]] был разделен на три случая, основанных на характеристиках `ParamType`, спецификаторе типа `param` в обобщенном шаблоне функции. В объявлении переменной с использованием [[auto|auto]] спецификатор типа занимает место `ParamType`, так что у нас опять имеются три случая.

> 1. Спецификатор типа представляет собой ссылку или указатель, но не универсальную ссылку.
> 2. Спецификатор типа представляет собой универсальную ссылку.
> 3. Спецификатор типа не является ни ссылкой, ни указателем.


Мы уже встречались со случаями 1 и 3:
```c++
auto х = 27;                // Случай 3 (х не указатель и не ссылка)
const auto сх = х;          // Случай 3 (сх не указатель и не ссыпка)
const auto& rx = х;         // Случай 1 (rx - неуниверсальная ссылка)
```

Случай 2 работает, как и ожидалось:
```c++
auto&& urefl = х;           // х - int и lvalue, так что тип urefl - int&
auto&& uref2 = сх;          // сх - const int и lvalue, так что тип
                            // uref2 - const int&
auto&& uref3 = 27;          // 2 7 - int и rvalue, так что тип
                            // uref 3 - int&&
```

[[Вывод типа шаблона|Раздел "Вывод типа шаблона"]] завершился обсуждением того, как имена массивов и функций превраща­ются в указатели для спецификаторов типа, не являющихся ссылками. То же самое происходит и при выводе типа **auto**:
```c++
const char name[] =          // Тип name - const char[13] 
				"R. N. Briggs";
auto arr1 = name;            // Тип arr1 - const char*
auto& arr2 = name;           // Тип arr2 - const char(&)[13]

void someFunc (int, douЬle); // someFunc - функция, ее тип
							 // void (int, douЬle)

auto func1 = someFunc;       // Тип func1 - void(*)(int, douЬle)
auto &func2 = someFunc;      // Тип func2 - void(&)(int, douЬle)
```

Как можно видеть, [[#Вывод типа auto|вывод типа auto]] работает подобно выводу типа шаблона. По сути это две стороны одной медали.

Они отличаются только в одном. Начнем с наблюдения, что если вы хотите объявить `int` с начальным значением 27, С++98 предоставляет вам две синтаксические возможности:
```c++
int x1 = 27;
int х2(27);
```

С++ 11, поддерживая старые варианты инициализации, добавляет собственные:
```c++
int х3 = {27};
int х4{27};
```

Таким образом, у нас есть четыре разных синтаксиса, но результат один: переменная типа `int` со значением 27.

Но, как поясняется в [[Пользовательские типы#Введение|Пользовательские типы - Введение]], объявление переменных с использованием ключевого слова **auto** вместо  фиксированных типов обладает определенными преимуществами, поэтому в приведенных выше объявлениях имеет смысл заменить `int` на `auto`. Простая замена текста приводит к следующему коду:
```c++
auto x1 = 27;
auto х2(27);
auto х3 = {27};
auto х4{27};
```

Все эти объявления компилируются, но их смысл оказывается не тем же, что и у объяв­лений, которые они заменяют. Первые две инструкции в действительности объявляют переменную типа `int` со значением 27. Вторые две, однако, определяют переменную типа `std::initializer list <int>`, содержащую единственный элемент со значением 27!
```c++
auto x1 = 27;                        // Тип int, значение 27
auto х2(27);                         // То же самое
auto хЗ = {27};                      // std::initializer_list<int>, значение (27}
auto х4{27};                         // То же самое
```

Это объясняется специальным правилом вывода типа для `auto`. Когда инициализатор для переменной, объявленной как `auto`, заключен в фигурные скобки, выведенный тип - [[initializer_list|std::initializer_list]]. Если такой тип не может быть выведен (например, из-за того, что значения в фигурных скобках относятся к разным типам), код будет отвергнут:
```c++
auto х5 = {1, 2, 3.0};               // Ошибка ! Невозможно вывести Т
                                     // для std::initializer_list<T>
```

Как указано в комментарии, в этом случае вывод типа будет неудачным, но важ­но понимать, что на самом деле здесь имеют место два вывода типа. Один из них вытекает из применения ключевого слова `auto`: тип `х5` должен быть выведен. Поскольку инициализатор `х5` находится в фигурных скобках, тип `х5` должен быть выведен как [[initializer_list|std::initializer_list]]. Но [[initializer_list|std::initializer_list]] - это шаблон. Конкретизация представляет собой создание `std::initializer_list<T>` с некоторым типом `Т`, а это означает, что тип `Т` также должен быть выведен. Такой вывод относится ко второй раз­новидности вывода типов - выводу типа шаблона. В данном примере этот второй вывод неудачен, поскольку значения в фигурных скобках не относятся к одному и тому же типу.

Рассмотрение инициализаторов в фигурных скобках является единственным отличием вывода типа `auto` от вывода типа шаблона. Когда объявленная с использованием ключевого слова `auto` переменная инициализируется с помощью инициализатора в фигурных скобках, выведенный тип представляет собой конкретизацию [[initializer_list|std::initializer_list]]. Но если тот же инициализатор передается шаблону, вывод типа оказывается неудачным, и код отвергается:
```c++
auto х = {11, 23, 9};                 // Тип х - std::initializer_list<int>

template<typename Т>                  // Объявление шаблона с параметром
void f(Т param);                      // эквивалентно объявлению х

f({11, 23, 9)}                        // Ошибка вывода типа для Т
```

Однако, если вы укажете в шаблоне, что `раrаm` представляет собой `std::initializer_list<T>` для некоторого неизвестного `T`, вывод типа шаблона сможет определить, чем является `Т`:
```c++
template<typename Т>
void f(std::initializer_list<T> initList);

f({11, 23, 9});                        // Вывод int в качестве типа Т, а тип
                                       // initList - std::initializer_list<int>
```

Таким образом, единственное реальное различие между выводом типа **auto** и [[Вывод типа шаблона|выводом типа шаблона]] заключается в том, что **auto** предполагает, что инициализатор в фигурных скобках представляет собой [[initializer_list|std::initializer_list]], в то время как вывод типа шаблона этого не делает.
Вы можете удивиться, почему [[#Вывод типа auto|вывод типа auto]] имеет специальное правило для ини­циализаторов в фигурных скобках, в то время как вывод типа шаблона такого правила не имеет. Увы, я не в состоянии найти убедительное объяснение. Но "закон есть закон", и это означает, что вы должны помнить, что если вы объявляете переменную с использованием ключевого слова **auto** и инициализируете ее с помощью инициализатора в фигурных скобках, то выводимым типом всегда будет [[initializer_list|std::initializer_list]]. Особенно важно иметь это в виду, если вы приверженец философии унифицированной инициализации - заключения и нициализирующих значе­ний в фигурные скобки как само собой разумеющегося стиля. Классической ошибкой в С++11 является случайное объявление переменной [[initializer_list|std::initializer_list]] там, где вы намеревались объявить нечто иное. Эта ловушка является одной из причин, по которым некоторые разработчики используют фигурные скобки в инициализаторах только тог­да, когда обязаны это делать. (Когда именно вы обязаны так поступать, мы рассмотрим в [[Переход к c++11, c++14#Различие между { } и ( ) при создании объектов|разделе]]).
Что касается С++11, то на этом история заканчивается, но для С++14 это еще не конец. С++14 допускает применение [[auto|auto]] для указания того, что возвращаемый тип функ­ции должен быть выведен (см. [[decltуре|decltуре]]), а кроме того, [[Лямбда-выражения|Лямбда-выражения]] С++14 могут использовать **auto** в объявлениях параметров. Однако такое применение **auto** использует вывод типа шаблона, а не вывод типа **auto**. Таким образом, функция с возвращаемым типом **auto**, которая возвращает инициализатор в фигурных скобках, компилироваться не будет:
```c++
auto createInitList()
{
	return {1, 2, 3);                   // Ошибка : невозможно вывести
	                                    // ТИП ДЛЯ { 1 , 2, 3 )
}
```
То же самое справедливо и тогда, когда **auto** используется в спецификации типа парамет­ра в [[Lambda#Лямбда-выражения||Лямбда-выражении]] С++14:
```c++
std::vector<int> v;

auto resetV = [&v](const auto& newValue) {v = newValue;};        // C++l4

resetV ({1, 2, З});              // Ошибка : невозможно вывести
                                 // ТИП ДЛЯ {1, 2, 3)
```

* Вывод типа `auto` обычно такой же, как и [[Вывод типа шаблона|вывод типа шаблона]], но вывод типа [[auto|auto]], в отличие от [[Вывод типа шаблона|вывода типа шаблона]], предполагает, что инициализатор в фигурных скобках представляет [[initializer_list|std::initializer_list]].
* [[auto|auto]] в возвращаемом типе функции или параметре [[Lambda#Лямбда-выражения|Лямбда-выражения]] влечет применение [[Вывод типа шаблона|вывода типа шаблона]], а не вывода типа **auto**.

# Особые случаи вывода auto

Существует несколько особых ситуаций для (простых в прочих случаях) правил вывода [[auto|auto]]. Во-первых, когда инициализатор переменной представляет собой список инициализаторов. Соответствующий вывод для вызова функции может потерпеть неудачу, потому что мы не можем вывести параметр типа шаблона из аргумента, который представляет собой список инициализаторов:
```c++
template<typename Т>
void deduceT(Т);

deduceT({ 2, 3, 4});    // Ошибка
deduceT({ 1 });         // Ошибка
```

Однако если наша функция имеет более точно определенный параметр, как здесь:
```c++
template<typename Т>
void deducelnitList(std::initializer_list<T>);

...

deducelnitList({ 2, 3, 5, 7 });    // OK: T выводится как int
```

то вывод оказывается успешным. Следовательно, переменная `auto`, инициализированная копированием (т.е. с помощью инициализации с использованием `=`) со списком инициализации, определяется в терминах этого более точного параметра:
```c++
auto primes = { 2, 3, 5, 7 };   // primes имеет тип
								// std::initializer_list<int>
deduceT(primes);                // T выводится как
								// std::initializer_list<int>
```

До C++17 соответствующая непосредственная инициализация переменных `auto` (т.е. без `=`) обрабатывалась таким же способом, но в C++17 это было изменено для лучшего соответствия поведению, ожидаемому большинством программистов:
```c++
auto oops { 0, 8, 15 };   // Ошибка в С++17
auto val { 2 );           // OK: val имеет тип int в С++17
```

До С++17 обе инициализации были корректны, и обе инициализировали и `oops`, и `val` как переменные типа `initializer_list<int>`.

Интересно, что возврат списка инициализаторов в фигурных скобках для функции с выводимым типом-заместителем недопустим:
```c++
auto subtleError()
{
	return { 1, 2, 3 };    // Ошибка
}
```

Дело в том, что список инициализаторов в области видимости функции является объектом, который указывает на лежащий в его основе объект массива (со значениями элементов, указанными в списке), и который исчезает, когда функция возвращает значение. Допуск такой конструкции будет способствовать образованию висячих ссылок.

Во-вторых, особая ситуация возникает, когда несколько объявлений переменных разделяют одно и то же ключевое слово `auto`, как показано ниже:
```c++
auto first = container.begin(), last = container.end();
```

В таких случаях вывод осуществляется независимо для каждого объявления. Другими словами, имеется найденный для `first` параметр типа шаблона `Т1`, и другой параметр типа шаблона `Т2` для `last`. Только если оба вывода успешны, и выводы `Т1` и `Т2` дают одинаковый тип, эти объявления являются корректными.

Это может приводить к некоторым интересным ситуациям:
```c++
char с;
auto *ср = &с, d = с;  // ОК
auto е=с, f = с + 1; // Ошибка: несоответствие выводов char и int
```

Здесь две пары переменных объявляются с помощью общего спецификатора [[auto#Объявление auto|auto]]. Объявления `ср` и `d` выводят для [[auto|auto]] один и тот же тип `char`, так что это корректный код. Однако объявления `е` и `f` приводят к выводу `char` и `int` из-за повышения к `int` при вычислении `с+1`, и это несоответствие приводит к ошибке.

В чем-то схожая особая ситуация может также возникнуть с заместителями для выводимых возвращаемых типов. Рассмотрим следующий пример:
```c++
auto f(bool b)
{
	if (b)
	{
		return 42.0;   // Выводит возвращаемый тип double
	}
	else
	{
		return 0;      // Ошибка: конфликт вывода
	}
I
```

В этом случае вывод для каждого оператора `return` выполняется отдельно, но если выводятся различные типы, то программа является некорректной. Если возвращаемое выражение рекурсивно вызывает ту же функцию, выполнение вывода невозможно, и программа является некорректной — если только возвращаемый тип не был ранее определен с помощью другого вывода. Это означает, что следующий код некорректен:
```c++
auto f(int n)
{
	if(n > 1)
	{
		return n * f(n - 1); // Ошибка: тип f(n-1) неизвестен
	}
	else
	{
		return 1;
	}
}
```

Однако следующий эквивалентный код вполне работоспособен:
```c++
auto f(int n)
{
	if(n <= 1)
	{
		return 1;           // Возвращаемый тип выводится как int
	}
	else
	{
		return n*f(n-1);    // OK: тип f(n-1) является int, и
							// таковым же является тип n*f(n-1)
	}
}
```

Выводимые возвращаемые типы имеют еще один особый случай, когда отсутствуют выводимые типы переменных или выводимые типы параметров, не являющихся типами:
```c++
auto f1()  { } // ОК: возвращаемый тип - void
auto f2()
{
	return;    // OK: возвращаемый тип - void
}
```

И `f1()`, и `f2()` корректны и имеют возвращаемый тип `void`. Однако если схема возвращаемого типа не может соответствовать `void`, такие случаи являются некорректными:
```c++
auto* f3() {} // Ошибка: auto* не может быть выведено как void
```

Как ожидается, любое использование шаблона функции с выводимым типом возвращаемого значения требует немедленного инстанцирования этого шаблона для уверенного определения возвращаемого типа. Что, однако, имеет удивительное следствие, когда дело доходит до [[SFINAE|SFINAE]]. Рассмотрим следующий пример:
```c++
template<typename Т, typename U>
auto addA(T t, U u) -> decltype(t + u)
{
	return t + u;
}

void addA(...);

template<typename T, typename U>
auto addB(T t, U u) -> decltype(auto)
{
	return t + u;
}

void addB(...);

struct X
{   };

// OK: AddResultA представляет собой void
using AddResultA = decltype(addA(X(), X() ) );

// Ошибка: инстанцирование addB<X> некорректно
using AddResultB = decltype(addB(X(), X() ) ) ;
```

Здесь использование `decltype (auto)` вместо `decltype (t+u)` для `addB()` вызывает ошибку в процессе разрешения перегрузки: тело функции шаблона `addB()` для определения ее возвращаемого типа должно быть полностью инстанцировано. Это инстанцирование не находится в [[SFINAE#Непосредственный контекст|непосредственном контексте]] вызова `addB()` и поэтому не подпадает под фильтр [[SFINAE|SFINAE]], а приводит к ошибке. Поэтому важно помнить, что выводимые возвращаемые, типы не являются просто сокращением для сложного явно определенного возвращаемого типа, и должны использоваться с осторожностью (т.е. с пониманием, что они не должны вызываться в сигнатурах других шаблонов функций, чтобы можно было рассчитывать на свойства [[SFINAE|SFINAE]]).

