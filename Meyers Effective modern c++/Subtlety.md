# Тонкости

Для каждого общего метода или возможности С++ имеются условия, когда его применение является разумным, и обстоятельства, в которых его не следует применять. Обычно описание того, когда имеет смысл применение некоторого общего метода или возможности, достаточно простое, но в данной главе описываются два исключения из этого правила: общий метод (передача по значению) и общая возможность (размещение (emplacement)). Решение об их применении зависит от такого большого количества факторов, что лучший совет, какой я могу дать, сводится к рассмотрению возможности их применения. Тем не менее оба они являются важными составляющими эффективного современного программирования на С++, и приведенная в разделах этой главы информация необходима для принятия вами решения об их применении в своих программах.

## Рассмотрите передачу по значению для копируемых параметров, которые лeгкo перемещаются и всегда копируются

Некоторые параметры функций предназначаются для копирования. Например, функция-член `addName` может копировать свой параметр в закрытый контейнер. Для эффективности такая функция должна копировать аргументы, являющиеся [[rvalue|lvalue]], но перемещать аргументы, являющиеся [[rvalue|rvalue]]:

```c++
class Widget { 
	public: 
		void addName(const std::strinq& newName)       // lvalue; 
		{ names.push_back(newName); } 
		
		void addName(std::strinq&& newName)            // rvalue; 
		{ names.push_back(std::move(newName));         // перемещаем

	...
	private: 
		std::vector names;
};
```

Этот способ работает, но требует двух функций, выполняющих, по сути, одни и те же действия. Это несколько раздражает: надо объявить две функции, реализовать две функции, документировать две функции и наконец поддерживать также две функции! 

Кроме того, две функции будут и в объектном коде, что при определенных обстоятельствах тоже может напрягать. В данном конкретном случае обе функции, вероятно, будут встраиваемыми, так что этот вопрос не встанет, но если функции не встраиваемые, то в объектном коде будут они обе. 

Альтернативный подход заключается в том, чтобы сделать `addName` шаблоном функции, получающей  [[Отличие универсальных ссылок от rvalue-ссылок|универсальную ссылку]]:

```c++
class Widget { 
	public: 
		template <typename T>      // Получаем как lvalue, 
		void addName (T&& newName) // так и rvalue; lvalue 
		{                          // копируем, rvalue перемещаем
			name.push_back(std::forward<T>(newName));
		}
};
```

Это приводит к уменьшению количества исходного текста, с которым приходится работать, но применение универсальных ссылок влечет за собой другие сложности. Будучи шаблоном, реализация `addName` обычно должна располагаться в заголовочном файле. В объектном коде такой подход может дать несколько функций, так как инстанцирование будет выполняться по-разному не только для [[rvalue|lvalue и rvalue]], но и для [[string|std::string]] и типов, преобразуемых в [[string|std::string]]. В то же время имеются типы аргументов, которые [[Познакомьтесь с случаями некорректной работы прямой передачи|не могут быть переданы с помощью универсальной ссылки]], и если клиент передаст аргументы некорректного типа, сообщения компилятора об ошибках могут быть приводящими в трепет ([[Знакомство с альтернативами перегрузки для универсальных ссылок#Знакомство с альтернативами перегрузки для универсальных ссылок|см.]]). 

Было бы неплохо, если бы имелся способ написания функций наподобие `addName`, таких, чтобы [[rvalue|lvalue]] копировались, [[rvalue|rvalue]] перемещались, при этом (в исходном тексте и объектном коде) имелась бы только одна функция и при этом можно было избежать неприятностей, связанных с универсальными ссылками. И такой способ есть. Все, что от вас требуется, - забыть об одном из первых правил, с которыми вы познакомились как программист на С++. Это правило, гласящее, что следует избегать передачи пользовательских типов по значению. Для параметров наподобие `newName` в функциях наподобие `addName` передача по значению может быть вполне разумной стратегией. Перед тем как начать выяснение, почему передача по значению может быть хорошим решением для `newName` и `addName`, посмотрим, как она может быть реализована:

```c++
class Widget { 
	public: 
		void addName(std::string newName)               // lvalue или
		{ names.push_back(std::move(newName)); };       // rvalue;
														// перемещаем его
}
```

Единственной неочевидной частью этого кода является применение [[move|std::move]] к параметру `newName`. Обычно [[move|std::move]] используется с rvаluе-ссылками, но в данном случае мы знаем, что `newName` представляет собой объект, полностью независимый от того, что передает вызывающая функция, так что изменение `newName` не влияет на вызывающую функцию, и это последнее применение `newName`, так что его перемещение никак не влияет на остальную часть функции.

Тот факт, что существует только одна функция `addName`, поясняет, как мы избегаем дублирования кода - как исходного, так и объектного. Мы не используем универсальную ссылку, так что данный подход не ведет к увеличению заголовочных файлов, странным неприятностям или непонятным сообщениям об ошибках. Но что можно сказать об эффективности такого дизайна? Мы же выполняем передачу по значению. Не слишком ли она дорога? 

В С++98 можно держать пари, что так и есть. Независимо от того, что передает вызывающая функция, параметр `newName` создается с помощью копирующего конструктора. Однако в С++11 `newName` будет создаваться с помощью копирующего конструирования только для [[rvalue|lvalue]]. В случае [[rvalue|rvalue]] этот объект создается с помощью перемещающего конструктора. Вот, взгляните:

```c++
Widget w;
...
std::string name ("Bart");
w.addName(name);                       // Вызов addName с lvalue
...
w.addName(name + "Jenne");             // Вызов add
Name с rvalue
```

В первом вызове `addName` (при передаче `name`) параметр `newName` инициализируется значением [[rvalue|lvalue]]. Поэтому объект `newName` создается путем копирования, так же, как это было бы в С++98. Во втором вызове `newName` инициализируется объектом [[string|std::string]], полученным в результате вызова оператора `operator+` для [[string|std::string]] (т.е. выполнения операции добавления). Этот объект представляет собой [[rvalue|rvalue]], и `newName`, таким образом, создается перемещением.

Итак, [[rvalue|lvalue]] копируются, а [[rvalue|rvalue]] перемещаются, как мы и хотели. Здорово, правда? Здорово, но есть несколько моментов, которые следует иметь в виду. Для облегчения понимания вспомним три рассмотренные версии функции `addName`:

```c++
class Widget {       // Подход 1: перегрузка для lvalue и rvalue 
	public: 
		void addName (const std::string& newName)
		{ names.push_back(newName); } 
		
		void addName (std::string&& newName) 
		{ names.push_back(std::move (newName)); }
		...
		
	private: 
		std::vector names;
}; 

class Widget {            // Подход 2: применение универсальной ссылки
	public: 
		template <typename T> 
		void addName(T&& newName) 
		{ names.push_back(std::forward(newName)); }
};		

class Widget {                // Подход 3: передача по значению 
	public: 
	void addName(std::string newName) 
	{ names.push_back(std::move (newName)); }
};
```

Я буду говорить о первых двух версиях как о "подходе с передачей ссылки", поскольку они обе передают параметры по ссылке. 

Вот два сценария вызова, которые мы рассмотрели:

```c++
Widget w; 
...
std::string name ("Bart"); 
w.addName(name);                         // Передача lvalue 
...
w.addName (name + "Jenne");              // Передача rvalue
```

Давайте теперь рассмотрим стоимость (в операциях копирования и перемещения) добавления имени в `Widget` для приведенных сценариев и каждой из трех рассмотренных реализаций `addName`. Мы будем игнорировать оптимизирующие возможности компиляторов по удалению копирований и перемещений, поскольку такая оптимизация зависит от контекста и компилятора и с практической точки зрения на суть анализа не влияет.

> **Переrрузка**. Независимо от передачи [[rvalue|lvalue или rvalue]] аргумент вызывающей функции связан со ссылкой по имени `newName`. Это ничего не стоит в смысле операций копирования и перемещения. В перегрузке для [[rvalue|lvalue]] `newName` копируется в `Widget::names`. В перегрузке для [[rvalue|rvalue]] объект перемещается. Итоговая стоимость: одно копирование для [[rvalue|lvalue]], одно перемещение для [[rvalue|rvalue]].

> **Применение универсальной ссылки**. Как и в случае перегрузки, аргумент вызывающей функции связан со ссылкой `newName`. Эта операция бесплатна. Благодаря использованию [[forward|std::forward]] lvalue-apryмeнты [[string|std::string]] копируются в `Widget::names`, в то время как rvalue-apryмeнты [[string|std::string]] перемещаются. Итоговая стоимость для аргументов [[string|std::string]] такая же, как и при перегрузке: одно копирование для [[rvalue|lvalue]], одно перемещение для [[rvalue|rvalue]]. 
> 
> [[Использование move и forward|Поясняется]], что если вызывающая функция передает аргумент, отличный от [[string|std::string]], он будет передан в конструктор [[string|std::string]], и это может привести к нулевому количеству копирований и перемещений [[string|std::string]]. Таким образом, функции, получающие универсальные ссылки, оказываются уникально эффективными. Однако это не влияет на выполняемый нами анализ, так что для простоты мы будем предполагать, что вызывающая функция всегда передает аргументы [[string|std::string]]. 

> **Передача по значению.** Независимо от передачи [[rvalue|lvalue или rvalue]] должен быть сконструирован параметр `newName`. Если передано [[rvalue|lvalue]], это стоит одно копирование, если передано [[rvalue|rvalue]] - одно перемещение. В теле функции `newName` безусловно перемещается в `Widget::names`. Итоговая стоимость, таким образом, равна одному копированию и одному перемещению для [[rvalue|lvalue]] и двум перемещениям для [[rvalue|rvalue]]. По сравнению с подходом с передачей ссылки мы получаем одно лишнее перемещение как для [[rvalue|lvalue]], так и для [[rvalue|rvalue]].

Рассмотрите передачу по значению для копируемых параметров, которые легко перемещаются и всегда копируются.

Оно сформулировано таким образом не без причины. Точнее, не без четырех причин.

1. Вы должны всего лишь рассмотреть использование передачи по значению. Да, при этом требуется написать всего лишь одну функцию. Да, при этом в объектном коде генерируется только одна функция. Да, вы избегаете проблем, связанных с применением универсальных ссылок. Но стоимость этого решения выше, чем стоимость альтернативных вариантов, и, как вы увидите далее, в некоторых случа ях есть стоимость, которую мы еще не рассматривали. 
2. Рассмотрите передачу по значению только для копируемых параметров. Параметры, не соответствующие этому условию, должны иметь типы, являющиеся только перемещаемыми, поскольку если они не копируемые, а функция всегда делает копию, такая копия должна создаваться с помощью перемещающего конструктора. Вспомним, что преимущества передачи по значению перед перегрузкой заключаются в том, что при передаче по значению достаточно написать только одну функцию. Но для только перемещаемых типов нет необходимости предоставлять перегрузку для [[rvalue|lvalue]], поскольку копирование [[rvalue|lvalue]] влечет вызов копирующего конструктора, который у таких типов отсутствует. Это означает, что требуется поддержка только аргументов, являющихся [[rvalue|rvalue]], и в таком случае решение на основе "переrрузки" требует только одну переrрузку, принимающую rvalue-ccылкy. Рассмотрим класс с данными-членом [[unique_ptr|std::unique_ptr]] и функцию установки для неrо. Тип [[unique_ptr|std::unique_ptr]] является только перемещаемым типом, так что подход с использованием "перегрузки" состоит из единственной функции.

```c++
class Widget {
	public: 
		void setPtr(std::unique_ptr&& ptr) 
		{ р = std::move(ptr); } 
	
	private: 
		std::unique_ptr<std::string> р; 
};
```

Вызывающая функция может использовать ее следующим образом:

```c++
Widget w; 
...
w.setPtr(std::make_unique<std::string>("Modern с++"));
```

Здесь [[rvalue|rvalue]] [[unique_ptr|std::unique_ptr]], возвращаемое из [[make_unique|std::make_unique]] ([[Избегайте перегрузок для универсальных ссылок|см.]]), передается по ссылке в `setPtr`, где оно перемещается в данные член `р`. Общая стоимость составляет одно перемещение. 

Если бы `setPtr` принимала параметры по значению,

```c++
class Widget {
	public: 
		void setptr(std::unique_ptr<std::string> ptr) 
		{ р = std::move(ptr); }
	...
};
```

то тот же вызов создавал бы параметр `ptr` перемещением, а затем `ptr` был бы перемещен в данные-член `р`. Общая стоимость составила бы два перемещения в два раза больше, чем при подходе с "перегрузкой':

3. Передачу по значению стоит рассматривать только для параметров с недорогим перемещением. Когда перемещение дешевое, стоимость дополнительного перемещения может быть приемлемой, но если это не так, то излишнее перемещение становится аналогичным излишнему копированию, а важность устранения излишнего копирования и была основной причиной появления правила С++98 о нежелательности применения передачи по значению

4. Вы должны рассматривать передачу по значению только для параметров, которые всегда копируются. Чтобы увидеть, почему это важно, предположим, что перед копированием параметра в контейнер `names` функция `addName` проверяет, не слишком ли короткое (или длинное) имя передано. Если это так, запрос на добавление имени игнорируется. Реализация с передачей по значению может быть написана следующим образом:

```c++
class Widget { 
	public: 
		void addName(std::string newName) 
		{ 
			if ((newName.length() >= minLen) && 
				(newName.length() <= maxLen)) 
			{
				names.push_back(std::move(newName));
			}
		}
		...
		
	private: 
		std::vector<std::string> names; 
};
```

Эта функция берет на себя создание и уничтожение `newName`, даже если в `names` ничего не добавляется. Это цена, которую подход с передачей по ссылке платить не должен.

Даже когда вы имеете дело с функцией, выполняющей безусловное копирование копируемого типа с дешевым перемещением, бывают моменты, когда передача по значению может оказаться неприемлемой. Это связано с тем, что функция может копировать параметр двумя способами: с помощью конструирования (т.е. с помощью копирующего конструктора или перемещающего конструктора) и с помощью присваивания (т.е. с помощью оператора копирующего или перемещающего присваивания). Функция `addName` использует конструирование: ее параметр `newName` передается функции `vector::push_back`, и внутри этой функции `newName` конструируется копированием в новом элементе в конце вектора `std::vector`. Для функций, которые используют конструирование для копирования своего параметра, анализ, который мы видели ранее, завершен: использование передачи по значению приводит к дополнительному перемещению как для [[rvalue|lvаluе]] аргументов, так и для [[rvalue|rvаluе]]-аргументов.

Когда параметр копируется с использованием присваивания, ситуация становится более сложной. Предположим, например, что у нас есть класс, представляющий пароли. Поскольку пароль может изменяться, мы предоставляем функцию установки `changeTo`. Используя стратегию передачи по значению, реализовать `Password` можно следующим образом:

```c++
class Password { 
	public: 
		explicit Password(std::string pwd)   // Передача по значению;
		: text(std::move(pwd)){ }            // конструирование text 
		
		void changeTo(std::string newPwd)    // Передача по значению;
		{ text = std::move(newPwd); }        // присваивание text 
		
	private: 
		std::string text;                    // Текст пароля
};
```

Хранение паролей в виде обычного текста приведет специалистов по безопасности в неистовство, но мы их проигнорируем и рассмотрим следующий код:

```c++
std::string initPwd("Supercalifragilisticexpialidocious"); 
Password p(initPwd);
```

Здесь нет никаких сюрпризов: `р.text` конструируется с использованием заданного пароля, а применение передачи по значению в конструкторе приводит к стоимости перемещающего конструирования `std::string`, которое может оказаться излишним при применении перегрузки или прямой передачи. Все в порядке.

Пользователь этой программы может быть не столь оптимистичным насчет пароля, так как слово "Supercalifragilisticexpialidocious" можно найти в словаре. А потому он предпринимает действия, которые ведут к выполнению следующего кода:

```c++
std::string newPassword = "Beware the Jabberwock"; 
p.changeTo(newPassword);
```

Лучше новый пароль старого или нет - вопрос сложный, но это проблемы пользователя. Нашей же проблемой является то, что необходимость функции `changeTo` использовать присваивание (а не конструирование) для копирования параметра `newPwd`, вероятно, приведет к росту стоимости стратегии передачи параметра по значению.

Аргумент, переданный функции `changeTo`, представляет собой [[rvalue|lvalue]] (`newPassword`), так что, когда конструируется параметр `newPwd`, вызывается копирующий конструктор [[string|std::string]]. Этот конструктор выделяет память для хранения нового пароля. Затем `newPwd` присваивается с перемещением переменной `text`, что приводит к освобождению памяти, которая ранее принадлежала этой переменной `text`. Таким образом, в `changeTo` выполняются два действия по управлению динамической памятью: одно выделяет память для хранения нового пароля, а второе освобождает память, в которой хранился старый пароль.

Но в данном случае старый пароль ("Supercalifragilisticexpialidocious") длиннее нового ("Beware the Jabberwock"), так что нет необходимости в выделении и освобождении памяти вовсе. Если бы использовался подход с перегрузкой, вероятно, никакие выделения и освобождения не выполнялись бы:

```c++
class Password {
	public: 
		...
		void changeTo(const std::string& newPwd) // Перегрузка для 
		{                                        // lvalue 
			text = newPwd;          // При text.capacity() >= newPwd.size( )
			                        // можно использовать память text
		}
		...

	private:
		std::string text;           // Как вьШJе
};
```

В этом сценарии стоимость передачи по значению включает дополнительное выделение и освобождение памяти - стоимость, которая, скорее всего, превысит стоимость операции по перемещению [[string|std::string]] на порядки.

Интересно, что если старый пароль короче нового, то обычно невозможно избежать при присваивании действий по выделению и освобождению памяти, и в этом случае передача по значению будет выполняться практически с той же скоростью, что и передача по ссылке. Таким образом, стоимость копирования параметров с помощью присваивания может зависеть от объектов, участвующих в присваивании! Этот вид анализа применим к любому типу параметров, который хранит данные в динамически выделенной памяти. Не все типы таковы, но многие - включая [[string|std::string]] и [[vector|std::vector]] обладают этим свойством.

Это потенциальное увеличение стоимости в общем случае применимо только к передаче аргументов, являющихся [[rvalue|lvalue]], поскольку необходимость выделения и освобождения памяти обычно возникает только тогда, когда выполняется истинное копирование (не перемещение). В случае rvаluе-аргументов перемещений почти всегда достаточно.

Получается, что дополнительная стоимость передачи по значению (по сравнению с передачей по ссылке) для функций, копирующих параметр с использованием присваивания, зависит от передаваемого типа, соотношения [[rvalue|lvalue- и rvalue-]] apryмeнтoв и от того, использует ли тип динамическую память (и, если использует, то от реализации операторов присваивания для данного типа и вероятности того, что память, связанная с целевым объектом присваивания, как минимум того же размера, что и память присваиваемого объекта). В случае [[string|std::string]] она также зависит от того, использует ли реализация оптимизацию малых строк ([[Перемещающие операции|SSO]]), и если использует, то помещаются ли присваиваемые значения в буфер [[Перемещающие операции|SSO]].

Так что, как я говорил, при копировании параметров с помощью присваивания анализ стоимости передачи по значению становится весьма сложным. Обычно наиболее практичный подход состоит в стратегии презумпции виновности ("виновен, пока не доказано иное"), в соответствии с которым вы используете перегрузку или универсальную ссылку, а не передачу по значению, пока не будет показано, что передача по значению дает приемлемо эффективный код для используемого вами типа параметра.

Итак, для программного обеспечения, которое должно быть насколько это возможно быстрым, передача по значению может оказаться неподходящей стратегией, поскольку важным может быть даже устранение дешевых перемещений. Кроме того, не всегда понятно, сколько же перемещений имеют место на самом деле. В примере `Widget::addName` передача по значению приводит только к одной лишней операции перемещения; однако предположим, что `Widget::addName` вызывает `Widget::validateName`, в которую параметр также передается по значению. (Возможно, имеется причина для того, чтобы всегда копировать параметр, например, для хранения его в структуре данных всех проверенных значений.) Предположим также, что функция `validateName` вызывает третью функцию с передачей ей параметра по значению . . .

Как видите, название раздела не зря такое неопределенное. Когда имеется цепочка вызовов функций, каждая из которых использует передачу по значению, поскольку "его стоимость составляет только одно недорогое перемещение": стоимость всей цепочки может стать такой, что вы не сможете спокойно ее терпеть. При использовании передачи по ссылке вы избегаете такого накопления накладных расходов.

Есть еще одно соображение, не имеющее отношения к производительности, но которое стоит иметь в виду. Передача по значению, в отличие от передачи по ссылке, подвержена проблеме срезки. Эта проблема хорошо известна в С++98 и многократно проанализирована во множестве книг, так что я не буду подробно на ней останавливаться. Но если вам нужна функция, которая должна принимать параметры типа базового класса и любых производных от него типов, то вы не должны объявлять параметр этого типа как передаваемый по значению, так как при этом будут "срезаться" характеристики объекта производного класса, передаваемого функции:

```c++
class Widget { ... };                           // Базовый класс 
class SpecialWidget: public Widget { ... };     // Производный класс 

void processWidget (Widqet w);       // Функция для любого вида Widget, 
									 // включая производные типы;
...									 // подвержена проблеме срезки
SpecialWidget sw; 
...
processWidget(sw);                   // processWidget видит Widget, 
                                     // а не SpecialWidget!
```

Если вы не знакомы с проблемой срезки, поищите информацию в Интернете или по интересуйтесь у друзей; информации о ней предостаточно. Вы узнаете, что срезка - это еще одна причина (помимо проблемы эффективности), по которой передача по значению имеет такую плохую репутацию в С++98. Как видите, имеются веские причины для того, чтобы вбивать в головы новичкам в программировании на С++: не передавайте объекты пользовательских типов по значению!

С++11 не отменяет мудрость С++98, касающуюся передачи по значению. В общем случае передача по значению по-прежнему влечет за собой снижение производительности, которого следует избегать, и по-прежнему может приводить к срезке. Новым в С++11 является различие аргументов, являющихся [[rvalue|lvalue и rvalue]]. Реализация функций, которые используют преимущества семантики перемещения для [[rvalue|rvalue]] копируемых типов, требует либо перегрузки, либо применения универсальных ссылок, и оба эти подхода имеют свои недостатки. В частном случае копируемых легко перемещаемых типов, передаваемых в функцию, которая всегда их копирует и где срезка не является проблемой, передача по значению может быть простой в реализации альтернативой, почти столь же эффективной, как и ее конкуренты с передачей по ссылке, но при этом не отягощенной их недостатками.

> Для копируемых и легко перемещаемых параметров, которые всегда копируются, передача по значению может быть почти столь же эффективной, как и передача по ссылке, более простой в реализации и генерировать меньший объектный код.
>
>Для lvalue-apryмeнтoв передача по ссылке (например, копирующее конструирование}, за которой следует перемещающее присваивание, может оказаться существенно более дорогостоящей, чем передача по ссылке с последующим копирующим присваиванием.
>
>Передача по значению подвержена проблеме срезки, так что обычно не годится для типов параметров базовых классов.

## Рассмотрите применение размещения вместо вставки

Если у вас есть, скажем, контейнер, хранящий строки [[string|std::string]], представляется логичным, что при добавлении нового элемента с помощью функции вставки (т.е. `insert`, `push_front`, `push_back` или для [[forward_list|std::forward_list]] - `insert_after`) тип передаваемого функции элемента представляет собой [[string|std::string]]. В конце концов, именно этот тип хранится в контейнере.

Несмотря на всю логичность, это не всегда верно. Рассмотрим следующий код:

```c++
std::vector<std::string> vs;                // Контейнер std: : string 
vs.push_back("xyzzy");                      // Добавление строкового литерала
```

Здесь контейнер хранит строки [[string|std::string]], но в действительности вы передаете в функцию `push_back` строковый литерал, т.е. последовательность символов в двойных кавычках. Строковый литерал не является [[string|std::string]], и это означает, что переданный вами в функцию `push_back` аргумент имеет тип, отличный от типа элементов, хранящихся в контейнере.

Функция `push_back` класса [[vector|std::vector]] перегружена для [[rvalue|lvalue и rvalue]] следующим образом:

```c++
template <class T,                              // Из стандарта
			class Allocator = allocator<T>>     // C++11

class vector {
	public: 
		...
		void push_back(const Т& х);             // Вставка lvalue
		void push_back(T&& х);                  // Вставка rvalue
}; 
```

В вызове

```c++
vs.push_back("xyzzy") ;
```

компиляторы видят несоответствие между типом аргумента (`const char[6]`) и типом параметра, получаемого функцией `push_back` (ссылка на [[string|std::string]]). Они разрешают это несоответствие путем генерации кода для создания временного объекта [[string|std::string]] из строкового литерала и передачи этого временного объекта функции `push_back`. Другими словами, они рассматривают вызов так, как будто он записан следующим образом:

```c++
vs.push_back(std::string("xyzzy"));        // Создание временного 
// объекта std::string и передача его функции push_back
```

Этот код компилируется и выполняется, и все расходятся счастливыми и довольными. Все, кроме свихнувшихся на производительности программистов, которые обнаруживают, что этот код не настолько эффективен, насколько должен быть.

Они понимают, что для создания нового элемента в контейнере, содержащем строки [[string|std::string]], должен быть вызван конструктор [[string|std::string]], но приведенный выше код делает не один вызов конструктора, а два, а также вызывает деструктор [[string|std::string]]. Вот что происходит во время выполнения вызова `push_back`.

1. Из строкового литерала "xyzzy" создается временный объект [[string|std::string]]. Этот
объект не имеет имени; назовем его `temp`. Создание `temp` представляет собой первое конструирование [[string|std::string]]. Поскольку это временный объект, `temp` представляет собой [[rvalue|rvalue]].

2. Объект `temp` передается в [[rvalue|rvаluе]]-перегрузку `push_back`, где он связывается с параметром `х`, представляющим собой [[rvalue|rvalue-ccылкy]]. Затем в памяти [[vector|std::vector]] создается копия `х`. Это второе конструирование действительно создает новый объект внутри [[vector|std::vector]]. (Конструктор, использованный для копирования `х` в [[vector|std::vector]], представляет собой перемещающий конструктор, поскольку `х`, будучи [[rvalue|rvаluе-ссылкой]], приводится к [[rvalue|rvalue]] перед копированием. [[Использование move и forward|Информация о приведении параметров, являющихся rvаluе-ссылками, в rvalue]])

3. Непосредственно после возврата из `push_back` уничтожается объект `temp`, при этом вызывается деструктор [[string|std::string]].

Фанаты производительности не в состоянии помочь, но замечают, что если бы был способ взять строковый литерал и непосредственно передать его в код шага 2, который конструирует объект [[string|std::string]] внутри [[vector|std::vector]], то можно было бы избежать конструирования и удаления `temp`. Это могло бы оказаться максимально эффективным подходом.

Поскольку вы программист на С++, шанс, что вы фанат производительности, явно выше среднего. Если вы не из таких, то, пожалуй, все равно им симпатизируете. (Если же производительность вас не интересует, может, вы просто ошиблись дверью? `Python` находится дальше по коридору . . . ) Так что я рад сообщить вам, что есть способ сделать имен­но то, что требуется для достижения максимальной эффективности в вызове `push_back`. Это - не вызывать `push_back`. Функция `push_back` неправильная. Вам нужна функция `emplace_back`.

Функция `emplace_back` делает именно то, что мы хотим: использует переданный аргумент для конструирования [[string|std::string]] непосредственно внутри [[vector|std::vector]], не прибегая ни к каким временным объектам:

```c++
vs.emplace_Ьack("xyzzy");          // Создает std::string в vs
                                   // непосредственно из "xyzzy
```

`emplace_back` использует прямую передачу, так что до тех пор, пока вы не столкнетесь с одним из [[Познакомьтесь с случаями некорректной работы прямой передачи|ограничений прямой передачи]], можете передавать любое количество аргументов с любой комбинацией типов. Например, если вы хотите создать [[string|std::string]] в `vs` с помощью конструктора [[string|std::string]], получающего символ и количество его повторений, то вы пишете следующий исходный текст:

```c++
vs.emplace_back(50, 'х');               // Вставка std::string из
										// 50 символов 'х'
```

Функция `emplace_back` доступна во всех стандартных контейнерах, которые поддерживают `push_back`. Аналогично каждый стандартный контейнер, который поддерживает `push_front`, поддерживает и `emplace_front`. И каждый стандартный контейнер, поддерживающий `insert` (т.е. все контейнеры, кроме [[forward_list|std::forward_ list]] и [[Array|std::array]]), поддерживает `emplace`. Ассоциативные контейнеры предоставляют [[emplace_hint|emplace_hint]] в качестве дополнения к функциям `insert`, которые получают итератор "подсказки", а у [[forward_list|std::forward_list]] имеется [[emplace_after|emplace_after]], соответствующий его [[insert_after|insert_after]].

Что позволяет функциям размещения превзойти функции вставки, так это их более гибкий интерфейс. Функции вставки получают вставляемые объекты, в то время как функции размещения получают аргументы конструктора вставляемых объектов. Это отличие позволяет функциям размещения избегать создания и уничтожения временных объектов, которые могут требоваться функциям вставки.

Поскольку функции размещения может быть передан аргумент типа, хранимого в контейнере (аргумент, таким образом, заставляет функцию выполнить копирующее или перемещающее конструирование), размещение может использоваться даже тогда, когда функция вставки не требует временного объекта. В таком случае вставка и размещение делают, по сути, одно и то же. Например, для

```c++
std::string queenOfDisco ("Donna Summer");
```

оба приведенных далее вызова корректны, и оба приводят к одному и тому же результату:

```c++
vs.push_Ьack(queenOfDisco);          // Копирующее конструирование
                                     // queenOfDisco в конце vs
vs.emplace_Ьack(queenOfDisco);       // То же самое
```

Таким образом, размещающие функции могут делать все то же самое, что и функции вставки. Иногда они делают это более эффективно и как минимум теоретически не должны делать менее эффективно. Так почему же мы не используем их все время?

Потому что теоретически разницы между теорией и практикой нет, а практически - есть. При текущих реализациях стандартной библиотеки имеются ситуации, когда, как и ожидается, размещение превосходит вставку, но - увы! - есть ситуации, когда вставка работает быстрее. Такие ситуации непросто охарактеризовать, поскольку они зависят от типов передаваемых аргументов, используемых контейнеров, местоположения вставки или размещения в контейнере, безопасности исключений конструкторов типов, содержащихся в контейнере, и для контейнеров, в которых запрещены дубликаты (т.е. [[set|std::set]], [[map|std::map]], [[unordered_set|std::unordered_set]], [[unordered_map|std::unordered_map]]), от того, содержится ли уже в контейнере вставляемое значение. А потому следует пользоваться обычным советом по повышению производительности: для определения того, какой метод работает быстрее, надо сравнивать их реальную производительность в конкретных условиях.

Это, конечно, не очень приятно, так что вы будете рады узнать, что есть эвристический алгоритм, который может помочь вам определить ситуации, когда, скорее всего, имеет смысл использовать функции размещения. Если все приведенные далее утверждения справедливы, размещение почти наверняка будет опережать вставку.

> **Добавляемое значение конструируется в контейнере, а не присваивается.** Пример, с которого начат данный раздел (добавление [[string|std::string]] со значением "xyzzy" в [[vector|std::vector]] `vs`), демонстрирует значение, добавляемое в конец вектора `vs` - в место, где пока что нет никакого объекта. Таким образом, новое значение должно быть сконструировано в [[vector|std::vector]]. Если мы пересмотрим пример так, что новая строка [[string|std::string]] будет направляться в местоположение, уже занятое объектом, это будет совсем другая история:

```c++
std::vector<std::string> vs;                // Как и ранее
...                                         // Добавление элементов в vs
vs.emplace(vs.Ьegin(), "xyzzy");            // Добавление "xyzzy" в начало vs
```

При таком коде только редкие реализации будут конструировать добавляемый объект [[string|std::string]] в памяти, занятой `vs[0]`. Большинство реализаций используют перемещающее присваивание в указанное место. Но перемещающее присваивание требует наличия перемещаемого объекта, а это означает, что необходимо создание временного объекта. Поскольку основное преимущество размещения над вставкой заключается в том, что не создаются и не уничтожаются временные объекты, при добавлении значения в контейнер с помощью присваивания преимущества размещения исчезают.

Увы, выполняется ли добавление значения в контейнер путем конструирования или перемещения, в общем случае зависит от реализации. И вновь на помощь может прийти эвристика.

Контейнеры на основе узлов почти всегда используют для добавления новых значений конструирование, а большинство стандартных контейнеров являются именно таковыми. Исключениями являются [[vector|std::vector]], [[deque|std::deque]] и [[string|std::string]]. (Контейнер [[Array|std::array]] также не является таковым, но он не поддерживает ни вставку, ни размещение, поэтому упоминать о нем здесь нет смысла.) В контейнерах, не основанных на узлах, можно рассчитывать на использование функцией `emplace_back` для размещения нового значения конструирования вместо присваивания; то же самое можно сказать и о функции `emplace_front` контейнера [[deque|std::deque]].

> Типы передаваемых аргументов отличаются от типа, хранящеrося в контейнере. И вновь, преимущество размещения по сравнению со вставкой в общем случае связано с тем фактом, что его интерфейс не требует создания и уничтожения временного объекта при передаче аргументов типа, отличного от типа, хранящегося в контейнере. Когда в контейнер `container<T>` добавляется объект типа `Т`, нет причин ожидать, что размещение окажется быстрее вставки, поскольку для удовлетворения интерфейсу вставки не требуется создание временного объекта.

> Маловероятно, что контейнер отвергнет новое значение как дубликат. Это означает, что либо контейнер разрешает наличие дубликатов, либо большинство передаваемых значений уникальны. Это важно, поскольку для того, чтобы определить наличие дубликата, реализации размещения обычно создают узел с новым значением, а затем сравнивают его с имеющимися узлами контейнера. Если добавляемое значение в контейнере отсутствует, узел встраивается в контейнер. Однако, если такое значение уже есть в контейнере, размещение прерывается, а узел уничтожается, так что впустую расходуется стоимость создания и уничтожения объекта. Такие узлы для функций размещения создаются более часто, чем для функций вставки.

Приведенные вызовы, с которыми мы уже сталкивались в данном разделе, удовлетворяют всем перечисленным критериям. Они работают быстрее соответствующих вызовов `push_back`.

```c++
vs.emplace_back("xyzzy");           // Конструирует новое значение в конце
									// контейнера; тип аргумента отличен от
									// типа, хранимого в контейнере;
									// контейнер не отвергает дубликаты
vs.emplace_back(SO, 'х');           // То же самое
```

При принятии решения об использовании функций размещения стоит иметь в виду еще пару вопросов. Первый из них связан с управлением ресурсами. Предположим, что у вас есть контейнер с объектами `std::shared_ptr<Widget>`
```c++
std::list<std::shared_ptr<Widget>> ptrs;
```

и вы хотите добавить [[shared_ptr|std::shared_ptr]], который должен быть освобожден с помощью пользовательского удалителя. В разделе [[make_unique#Предпочитайте использование std make_unique и std make_shared непосредственному использованию оператора new|поясняется]], что по возможности вы должны использовать для создания [[shared_ptr|std::shared_ptr]] функцию [[make_shared|std::make_shared]], но в нем же указано, что существуют ситуации, когда это невозможно. Одна из таких ситуаций - когда вы хотите указать пользовательский удалитель. В этом случае для получения обычного указателя, которым будет управлять интеллектуальный указатель [[shared_ptr|std::shared_ptr]], вы должны непосредственно использовать оператор `new`.

Если пользовательский удалитель представляет собой функцию

```c++
void killWidget (Widget* pWidget);
```

то код, использующий функцию вставки, может выглядеть следующим образом:

```c++
ptrs.push_Ьack(std::shared_ptr<Widget> (new Widget, killWidget));
```

Он может также принять и такой вид, означающий то же самое:

```c++
ptrs.push_Ьack( {new Widget, killWidget} );
```

В любом случае перед вызовом `push_back` будет создан временный объект [[shared_ptr|std::shared _ptr]]. Параметром `push_back` является ссылка на [[shared_ptr|std::shared_ptr]], так что должен быть объект, на который ссылается этот параметр.

Функция `emplace_back` должна избегать создания временного объекта [[shared_ptr|std::shared_ptr]], но в этом случае ценность временного объекта гораздо выше его стоимости. Рассмотрим следующую потенциальную последовательность событий.

1. В любом из приведенных выше вызовов конструируется временный объект `std::shared_ptr<Widget>`, хранящий простой указатель, являющийся результатом операции `"new Widget"`: Назовем этот объект `temp`.
2. Функция `push_back` получает `temp` по ссылке. В процессе выделения памяти для узла списка, который должен содержать копию `temp`, генерируется исключение нехватки памяти.
3. При выходе исключения за пределы `push_back` объект `temp` уничтожается. Поскольку это единственный интеллектуальный указатель [[shared_ptr|std::shared_ptr]], указывающий на управляемый им объект `Widget`, он автоматически удаляет последний, в данном случае с помощью вызова `killWidget`.

Несмотря на происшедшую генерацию исключения нет никаких утечек: `Widget`, созданный с помощью `"new Widget"` в вызове `push_back`, освобождается деструктором объекта [[shared_ptr|std::shared_ptr]], который был создан для управления им (объектом `temp`). Все отлично.

Рассмотрим теперь, что произойдет при вызове `emplace_back` вместо `push_back`:

```c++
ptrs.emplace_Ьack(new Widget, killWidget);
```

1. Обычный указатель, являющийся результатом выполнения `"new Widget"`, передается с помощью прямой передачи в точку внутри `emplace_back`, где выделяется память для узла списка. При попытке выделения памяти генерируется исключение нехватки памяти.
2. При выходе исключения за пределы `emplace_back` обычный указатель, который был единственным средством доступа к `Widget` в динамической памяти, оказывается потерянным. Происходит утечка `Widget` (и всех ресурсов, которыми владеет этот объект).

В этом сценарии все совсем не отлично, и класс [[shared_ptr|std::shared_ptr]] в этом не повинен. Та же самая проблема возникнет при использовании [[unique_ptr|std::unique_ptr]] с пользовательским удалителем. По существу, эффективность классов управления ресурсами, таких как [[shared_ptr|std::shared_ptr]] и [[unique_ptr|std::unique_ptr]], основана на немедленной передаче ресурсов (таких, как обычные указатели, возвращаемые оператором `new`) конструкторам управляющих ресурсами объектов. Тот факт, что функции наподобие [[make_shared|std::make shared]] и [[make_unique|std::make_unique]] автоматизируют этот процесс, является одной из причин, по которым эти функции так важны.

В вызовах функций вставки контейнеров, хранящих управляющие ресурсами объекты (например, `std::list<std::shared_ptr<Widget>`), типы параметров функций в общем случае гарантируют, что между захватом ресурса (например, использованием оператора `new`) и конструированием управляющего ресурсом объекта ничего не происходит. В функциях размещения прямая передача откладывает создание управляющих ресурсами объектов до тех пор, пока они не смогут быть сконструированы в памяти контейнера, и тем самым открывают окно, генерация исключения в котором может привести к утечке ресурсов. Все стандартные контейнеры подвержены этой проблеме. При работе с контейнерами, хранящими управляющие ресурсами объекты, вы должны принять меры, гарантирующие, что при выборе функции размещения вместо функции вставки вы не заплатите за повышение эффективности безопасностью исключений.

Откровенно говоря, вы в любом случае не должны передавать выражения наподобие `"new Widget"` в функции `emplace_back` и `push_back`, как и в большинство любых других функций, поскольку  это ведет к [[make_unique#Предпочитайте использование std make_unique и std make_shared непосредственному использованию оператора new|возможным проблемам с безопасностью исключений]], одну из которых мы только что рассмотрели. Для предотвращения неприятностей требуется, чтобы получение указателя от `"new Widget"` и превращение его в управляющий ресурсом объект выполнялось в одной инструкции, а уже затем этот объект передавался как [[rvalue|rvalue]] функции, которой вы хотели изначально передавать `"new Widget"`: ([[make_unique#Предпочитайте использование std make_unique и std make_shared непосредственному использованию оператора new|Более детально этот подход рассмотрем тут]]].) Таким образом, код, использующий `push_back`, должен быть записан скорее как

```c++
std::shared_ptr<Widqet> spw(new Widqet,       // Создание Widget и
							killWidqet);      // передача его spw
ptrs.push_back(std::move(spw));               // Добавление spw
											  // как rvalue
```

Версия с использованием `emplace_back` аналогична:

```c++
std::shared_ptr<Widget> spw(new Widget, killWidget);
ptrs.emplace_back(std::move(spw));
```

В любом случае данный подход включает стоимость создания и удаления `spw`. С учетом того, что мотивацией для применения функций размещения вместо функций вставки является устранение стоимости создания и уничтожения временного объекта типа, хранящегося в контейнере (а `spw` концептуально и является таким объектом), функции размещения вряд ли превзойдут функции вставки при добавлении в контейнер объектов, управляющих ресурсами (если вы будете следовать хорошо проверенной практике и гарантировать, что между захватом ресурса и превращением его в управляющий объект не будет выполняться никаких действий).

Вторым важным аспектом функций размещения является их взаимодействие с конструкторами, объявленными как [[explicit|explicit]]. Предположим, что вы создаете контейнер
объектов регулярных выражений С++11:

```c++
std::vector<std::regex> regexes;
```

Отвлекшись на ссору ваших коллег о том, как часто следует проверять свой `Facebook`, вы случайно написали следующий, казалось бы, бессмысленный код:

```c++
regexes.eшplace_Ьack(nullptr);
```

Вы не заметили ошибку при вводе, компилятор скомпилировал его без замечаний, так что вам пришлось потратить немало времени на отладку. В какой-то момент вы обнаружили, что вставляете в контейнер регулярных выражений нулевой указатель. Но как это возможно? Указатели не являются регулярными выражениями, и если вы попытаетесь написать что-то вроде

```c++
std::regex r = nullptr;                     // Ошибка ! Не компилируется !
```

компилятор отвергнет такой код. Интересно, что будет отвергнут и вызов `push_back`
вместо `emplace_back`:

```c++
regexes.push_Ьack(nullptr);                  // Ошибка ! Не компилируется !
```

Такое любопытное поведение поясняется тем, что объекты [[regex|std::regex]] могут быть построены из символьных строк. Это делает корректным такой полезный код, как

```c++
std::regex upperCaseWord(" [A-Z] +");
```

Создание [[regex|std::regex]] из символьной строки может иметь достаточно высокую стоимость, так что для минимизации вероятности непреднамеренных расходов конструктор [[regex|std::regex]], принимающий указатель `const char*`, объявлен как [[explicit|explicit]]. Именно поэтому не компилируются следующие строки:

```c++
std::regex r = nullptr;            // Ошибка ! Не компилируется !
regexes.push_back(nullptr);        // Ошибка ! Не компилируется !
```

В обоих случаях требуется неявное преобразование указателя в [[regex|std::regex]], а объявление конструктора как [[explicit|explicit]] его предотвращает.

Однако в вызове `emplace_back` мы передаем не объект [[regex|std::regex]], а аргументы конструктора объекта [[regex|std::regex]]. Это не рассматривается как запрос неявного преобразования. Компилятор трактует этот код так, как если бы вы написали

```c++
std::regex r(nullptr);              // Компилируется
```

Если лаконичный комментарий "Компилируется" кажется вам лишенным энтузиазма, то это хорошо, потому что, несмотря на компилируемость, данный код имеет неопределенное поведение. Конструктор [[regex|std::regex]], принимающий указатель `const char*`, требует, чтобы этот указатель был ненулевым, а `nullptr` подчеркнуто нарушает данное требование. Если вы напишете и скомпилируете такой код, лучшее, на что вы можете надеяться - аварийное завершение программы во время выполнения. Если вы не такой счастливчик, то вам предстоит получить немалый опыт работы с отладчиком.

На минутку оставляя без внимания `push_back` и `emplace_back`, обратим внимание на то, что очень похожие синтаксисы инициализации дают совершенно разные результаты:

```c++
std::regex r1 = nullptr;                   // Ошибка ! Не компилируется
std::regex r2 (nullptr);                    // Компилируется
```

В официальной терминологии стандарта синтаксис, использованный для инициализации `r` (со знаком равенства), соответствует инициализации копированием (==сору iпitialization==). Синтаксис же, использованный для инициализации `r2` (с круглыми скобками, хотя могут использоваться и фигурные), дает то, что называется прямой инициализацией (==direct initialization==). Инициализация копированием не может использовать конструкторы, объявленные как [[explicit|explicit]], в то время как прямая инициализация - может. Вот почему строка с инициализацией `r1` не компилируется, в отличие от строки с инициализацией `r2`.

Но вернемся к `push_back` и `emplace_back` и в более общем случае - к функциям вставки и размещения. Функции размещения используют прямую инициализацию, т.е. могут пользоваться конструкторами, объявленными как [[explicit|explicit]] . Функции вставки применяют инициализацию копированием, а потому использовать такие конструкторы не могут.

```c++
regexes.emplace_Ьack(nullptr);          // Компилируется. Прямая
						// инициализация разрешает использовать конструктор
						// explicit std::regex, получающий указатель
regexes.push_Ьack(пullptr);            // Ошибка 1 Копируюшая
						// инициализация такие конструкторы не использует
```

Урок, который следует извлечь из данного материала, состоит в том, что при использовании размещающих функций необходимо быть особенно осторожным и убедиться, что функциям передаются правильные аргументы, поскольку в ходе анализа кода будут рассмотрены даже конструкторы, объявленные как [[explicit|explicit]].

> В принципе, функции размещения должны иногда быть более эффективными, чем соответствующие функции вставки, и не должны быть менее эффективными.
>
> На практике они чаще всего более быстрые, когда (1) добавляемое значение конструируется в контейнере, а не присваивается; (2) типы передаваемых аргументов отличаются от типа, хранящегося в контейнере; и (З) контейнер не отвергает дубликаты уже содержащихся в нем значений.
> 
> Функции размещения могут выполнять преобразования типов, отвергаемые функциями вставки.


