# Познакомьтесь с случаями некорректной работы прямой передачи

Одной из ярких звезд на небосклоне С++11 является прямая передача (perfect forwarding). Можно сказать, идеально прямая. Но, как говорит наука, даже пространство искривляется, так что есть идеальная прямота, а есть реальная. Прямая передача С++11 очень хороша, но достигает истинного совершенства, только если вы готовы игнорировать небольшие искривления. В данном разделе вы познакомитесь с этими маленькими искривлениями.

Перед тем как перейти к их изучению, стоит посмотреть, что мы подразумеваем под "прямой передачей". Под передачей подразумевается, что одна функция передает свои параметры другой функции. Цель этого действия заключается в том, чтобы одна функция (которой передаются параметры) получила в точности те же объекты, которые переданы другой функции (которая выполняет передачу). Тем самым исключается передача параметров по значению, поскольку при этом выполняется копирование исходно переданных объектов; мы же хотим, чтобы передающая функция была способна работать с изначально переданными объектами. Указатели также исключаются, поскольку мы не хотим заставлять вызывающий код передавать указатели. Когда речь идет о передаче общего назначения, мы работаем с параметрами, представляющими собой ссылки.

Прямая передача означает, что мы передаем не просто объекты, но и их основные характеристики: их типы, являются они [[rvalue|lvalue или rvalue]], объявлены они как [[const|const]] или [[volatile|volatile]]. В сочетании с наблюдением о том, что мы будем иметь дело со ссылочными параметрами, это означает, что мы будем использовать универсальные ссылки ([[Отличие универсальных ссылок от rvalue-ссылок|см.]]), поскольку только параметры, являющиеся универсальными ссылками, хранят информацию о том, какие аргументы - являющиеся [[rvalue|lvalue или rvalue]] - были им переданы.

Предположим, что у нас есть некоторая функция `f` и мы хотели бы написать функцию (по правде говоря, шаблон функции), которая выполняет передачу ей. Ядро того, что нам надо, имеет следующий вид:

```c++
template<typename Т>
void fwd (T&& param)                   //Принимает любой аргумент
{
	f(std::forward<Т>(param));         // Передача аргумента в f
}
```

Передающие функции по своей природе являются обобщенными. Шаблон `fwd`, например, принимает аргумент любого типа, и он передает все, что бы ни получил. Логическим продолжением этой обобщенности являются передающие функции, являющиеся не просто шаблонами, а шаблонами с произвольным количеством аргументов (вариативными шаблонами (variadic templates)). Вариативная разновидность `fwd` выглядит следующим образом:

```c++
template<typename... Ts>
void fwd(Ts&&... params)                  // Принимает любые аргументы
{
	f(std::forward<Ts>(params)...);       // Передача аргументов в f
}
```

Эту разновидность вы встретите, помимо прочих мест, в [[Subtlety#Рассмотрите применение размещения вместо вставки|функциях размещения стандартных контейнеров]] и в фабричных функциях для интеллектуальных указателей, [[make_shared|std::make_shared]] и [[make_unique|std::make_unique]] ([[make_unique#Предпочитайте использование std make_unique и std make_shared непосредственному использованию оператора new|см.]]).

Для заданной целевой функции `f` и нашей передающей функции `fwd` прямая передача завершается неудачей, если вызов функции `f` с конкретным аргументом выполняет нечто одно, а вызов `fwd` с теми же аргументами - нечто иное:

```c++
f(expression);       // Если этот вызов выполняет что-то одно,
fwd(expression);     // а этот - нечто иное, прямая передача
                     // функцией fwd функции f неудачна
```

К такой неудаче могут привести несколько видов аргументов. Знать эти аргументы и то, как с ними работать, весьма важно, так что начнем наш тур по аргументам, которые не могут быть переданы с помощью прямой передачи.

## Инициализаторы в фигурных скобках

Предположим, что `f` объявлена следующим образом:

```c++
void f(const std::vector<int>& v);
```

В этом случае вызов `f` с инициализаторами в фигурных скобках компилируется:

```c++
f({1, 2, 3})                  // ОК, "{1, 2, 3}" неявно преобразуется
                              // в std::vector<int>
```

Однако передача того же инициализатора в фигурных скобках функции `fwd` не компилируется:

```c++
fwd({1, 2, 3});               // Ошибка! Код не компилируется!
```

Дело в том, что применение инициализаторов в фигурных скобках - один из случаев, когда прямая передача терпит неудачу.

Все такие случаи отказов имеют одну и ту же причину. В непосредственном вызове `f` (таком, как `f({1, 2, 3)}` ) компиляторы видят аргументы, переданные в точке вызова, и видят типы параметров, объявленные функцией `f`. Они сравнивают аргументы в точке вызова с объявлениями параметров на предмет совместимости и при необходимости выполняют неявное преобразование, чтобы вызов был успешным. В приведенном выше примере они генерируют временный объект типа `std::vector<int>` из `{1, 2, 3 }`, так что к параметру `v` функции `f` привязывается объект типа `std::vector<int>`.

При косвенном вызове `f` с помощью шаблона передающей функции `fwd` компиляторы больше не сравнивают аргументы, переданные в точке вызова `fwd`, с объявлениями параметров в `f`. Вместо этого они выводят типы аргументов, переданных в `fwd`, и сравнивают выведенные типы с объявлениями параметров в `f`. Прямая передача оказывается неудачной, если происходит что-то из следующего.

> - **Компиляторы неспособны вывести тип** одного или нескольких параметров `fwd`. В этом случае код не компилируется.
> - **Компиляторы выводят "неверный" тип** одного или нескольких параметров `fwd`. Здесь "неверный" может означать как то, что инстанцирование `fwd` не компилируется с выведенными типами, так и то, что вызов `f` с  использованием выведенных типов `fwd` ведет себя не так, как непосредственный вызов `f` с аргументами, переданными в `fwd`. Одним источником такого отклонения в поведении могла бы быть ситуация, когда у `f` имеется перегрузка, и из-за "некорректного" вывода типов эта перегрузка `f`, вызываемая в `fwd`, отличалась бы от перегруженной функции `f`, используемой при непосредственном вызове.

В приведенном выше вызове `fwd({1, 2, 3})` проблема заключается в том, что передача инициализатора в фигурных скобках параметру шаблона функции, не объявленному как [[initializer_list|std::initializer_list]], заставляет его быть, как предписывает стандарт, "не выводимым контекстом". На простом человеческом языке это означает, что компиляторам запрещено выводить тип для выражения `{1, 2, 3}` в вызове `fwd`, поскольку параметр `fwd` не объявлен как [[initializer_list|std::initializer_list]]. Не имея возможности вывести тип параметра `fwd`, компиляторы, понятно, вынуждены отклонять такой вызов. 

Интересно, что в [[Вывод типа auto|разделе]] поясняется, что вывод типа для переменных [[auto|auto]], инициализированных с помощью инициализатора в фигурных скобках, успешен. Такие переменные считаются объектами типа [[initializer_list|std::initializer_list]], и это обеспечивает простой обходной путь для случаев, когда тип передающей функции должен быть выведен как [[initializer_list|std::initializer_list]]: объявить локальную переменную как [[auto|auto]], а затем передать ее в передающую функцию

```c++
auto il = {1, 2, 3};             // Тип il выводится как
								 // std::initializer_list<int>
fwd(il);                         // ОК, прямая передача il в f
```

## 0 и NULL в качестве нулевых указателей

[[Предпочитайте nullptr значениям 0 и NULL|Тут поясняется]], что, когда вы пытаетесь передать в шаблон `0` или `NULL` в качестве нулевого указателя, вывод типа для переданного аргумента дает вместо типа указателя целочисленный тип (обычно `int`). В результате ни `0`, ни `NULL` не может быть передано с помощью прямой передачи как нулевой указатель. Решение проблемы простое: передавать nullptr вместо `0` и `NULL`. Детальную информацию вы можете найти [[Предпочитайте nullptr значениям 0 и NULL|здесь]].

## Целочисленные члены-данные static const и constexpr без определений

В качестве общего правила не требуется определять в классах целочисленные члены-данные [[static|static]] const и [[constexpr|constexpr]]; одних объявлений вполне достаточно. Дело в том, что компиляторы выполняют распространение [[const|const]] для значений таких членов, тем самым устраняя необходимость выделять для них память. Например, рассмотрим такой код:

```c++
class Widget {
	public:
		// Объявление MinVals :
		static constexpr std::size_t МinVals = 28;
);
// Объявления MinVals нет

std::vector<int> widgetData;
widgetData.reserve(Widget::МinVals);         // Использование MinVals
```

Здесь мы используем `Widget::MinVals` (далее - просто `MinVals`) для указания начальной емкости `widgetData`, даже несмотря на то, что определения `MinVals` нет. Компиляторы обходят отсутствующее определение (как и должны это делать) подстановкой значения 28 во все места, где упоминается `MinVals`. Тот факт, что для значения `MinVals` не выделена память, проблемой не является. Если берется адрес `MinVals` (например, кто-то создает указатель на `MinVals`), то `MinVals` требует места в памяти (чтобы указателю было на что указывать), и тогда приведенный выше код хотя и будет компилироваться, не будет компоноваться до тех пор, пока не будет предоставлено определение `MinVals`.

С учетом этого представим, что `f` (которой функция `fwd` передает аргумент) объявлена следующим образом:

```c++
void f(std::size_t val);
```

Вызов `f` с `MinVals` проблемы не представляет, поскольку компиляторы просто заменяют `MinVals` его значением:

```c++
f(Widget::МinVals);        // ОК, рассматривается как "f(28)"
```

Увы, все не так хорошо, если попытаться вызвать `f` через `fwd`:

```c++
fwd(Widget::МinVals);      // Ошибка! Не должно компоноваться
```

Этот код компилируется, но не должен компоноваться. Если это напоминает вам происходящее при взятии адреса `MinVals`, это хорошо, потому что проблема в обоих случаях одна и та же.

Хотя нигде в исходном коде не берется адрес `MinVals`, параметром `fwd` является универсальная ссылка, а ссылки в коде, сгенерированном компилятором, обычно рассматриваются как указатели. В бинарном коде программы указатели и ссылки, по сути, представляют собой одно и то же. На этом уровне можно считать, что ссылки - это просто указатели, которые автоматически разыменовываются. В таком случае передача `MinVals` по ссылке фактически представляет собой то же, что и передача по указателю, а раз так, то должна иметься память, на которую этот указатель указывает. Передача целочисленных членов-данных [[static|static]] [[const|const]] и [[constexpr|constexpr]] по ссылке в общем случае требует, чтобы они были определены, и это требование может привести к неудачному применению прямой передачи там, где эквивалентный код без прямой передачи будет успешен.

В соответствии со стандартом передача `MinVals` по ссылке требует, чтобы этот член-данные был определен. Но не все реализации выполняют это требование. Так что в зависимости от ваших компиляторов и компоновщиков вы можете обнаружить, что в состоянии выполнить прямую передачу целочисленных членов-данных [[static|static const]] и [[constexpr|constexpr]], которые не были определены. Если это так - поздравляю, но нет причин ожидать, что такой код будет переносим. Чтобы сделать его переносимым, просто добавьте определение интересующего вас целочисленного члена данных, объявленного как [[static|static const]] или [[constexpr|constexpr]]. Для `MinVals` это определение имеет следующий вид:

```c++
constexpr std::size_t Widget::MinVals;        // В .срр- файле Widget
```

Обратите внимание, что в определении не повторяется инициализатор (`28` в случае `MinVals`) . Не переживайте об этом. Если вы забудете предоставить инициализатор в обоих местах, компиляторы будут жаловаться, тем самым напоминая вам о необходимости указать его только один раз.

## Имена перегруженных функций и имена шаблонов

Предположим, что поведение нашей функции `f` (которой мы хотим передать аргументы через шаблон `fwd`) может настраиваться путем передачи ей некоторой функции, выполняющей определенную работу. В предположении, что эта функция получает и возвращает [[int|int]], функция `f` может быть объявлена следующим образом:

```c++
void f(int(*pf)(int));                 // pf - функция обработки
```

Стоит заметить, что `f` может также быть объявлена с помощью более простого синтаксиса без указателей. Такое объявление может имеет следующий вид, несмотря на то что оно означает в точности то же, что и объявление выше:

```c++
void f(int pf(int));                   // Объявление той же f, что и выше
```

В любом случае теперь предположим, что у нас есть перегруженная функция `processVal`:

```c++
int processVal(int value);
int processVal(int value, int priority);
```

Мы можем передать `processVal` функции `f`,

```c++
f (processVal);                        // Без проблем
```

но это выглядит удивительным. Функции `f` в качестве аргумента требуется указатель на функцию, но `processVal` не является ни указателем на функцию, ни даже функцией; это имя двух разных функций. Однако компиляторы знают, какая `processVal` нужна: та, которая соответствует типу параметра функции `f`. Таким образом, они могут выбрать `processVal`, принимающую один `int`, а затем передать адрес этой функции в функцию `f`.

Все это работает благодаря тому, что объявление `f` позволяет компиляторам вывести требующуюся версию функции `processVal`. Однако `fwd` представляет собой шаблон функции, не имеющий информации о том, какой тип ему требуется, а потому компиляторы не в состоянии определить, какая из перегрузок должна быть передана:

```c++
fwd(processVal);                      // Ошибка! Какая processVal?
```

Само по себе имя `processVal` не имеет типа. Без типа не может быть вывода типа, а без вывода типа мы получаем еще один случай неудачной прямой передачи.

Та же проблема возникает и если мы пытаемся использовать шаблон функции вместо перегруженного имени функции или в дополнение к нему. Шаблон функции представляет не единственную функцию, он представляет множество функций:

```c++
template<typename Т>
Т workOnVal(T param)          // Шаблон для обработки значений
{ ... }

fwd (workOnVal);              // Ошибка! Какое инстанцирование workOnVal?
```

Получить функцию прямой передачи наподобие `fwd`, принимающую имя перегруженной функции или имя шаблона, можно, вручную указав перегрузку (или инстанцирование), которую вы хотите передать. Например, вы можете создать указатель на функцию того же типа, что и параметр `f`, инициализировать этот указатель с помощью `processVal` или `workOnVal` (тем самым обеспечивая выбор корректной версии `processVal` или генерацию корректного инстанцирования `workOnVal`) и передать его шаблону `fwd`:

```c++
using Process FuncType =                       // Псевдоним типа
	int(*)(int);
	
ProcessFuncТype processValPtr =                 // Определяем необходимую
	processVal;                                 // сигнатуру processVal

fwd(processValPtr);                             // OK
fwd(static_cast<ProcessFuncТype>(workOnVal));   // Также ОК
```

Конечно, это требует знания типа указателя на функцию, передаваемого шаблоном `fwd`. Разумно предположить, что функция с прямой передачей это документирует. В конце концов, функции с прямой передачей предназначены для принятия всего что угодно, так что если нет никакой документации, говорящей, что должно быть передано, то откуда вы узнаете, что им передавать?

## Битовые поля

Последний случай неудачной прямой передачи - когда в качестве аргумента функции используется битовое поле. Чтобы увидеть, что это означает на практике, рассмотрим за­ головок IPv4, который может быть смоделирован следующим образом:

```c++
struct IPv4Header {
	std::uint32_t   version:4,
					IНL:4,
					DSCP:6,
					ECN:2,
					totalLength:16;
};
```

Если наша многострадальная функция `f` (являющаяся целевой для нашей функции прямой передачи `fwd`) объявлена как принимающая параметр [[size|std::size_t]], то вызов, скажем, с полем `totalLength` объекта `IPv4Header` компилируется без проблем:

```c++
void f(std::size_t sz);                  // Вызываемая функция
IPv4Header h;
...
f(h.totalLength);                        // Все в порядке
```

Однако попытка передать `h.totalLength` в `f` через `fwd` - это совсем другая история:

```c++
fwd(h.totalLength);                     // Ошибка!
```

Проблема заключается в том, что параметр функции `fwd` представляет собой ссылку, а `h.totаlLength` - неконстантное битовое поле. Это может показаться не столь уж плохим, но стандарт С++ осуждает это сочетание в непривычно ясной форме: "неконстантная ссылка не может быть привязана к битовому полю': Тому есть превосходная причина. Битовые поля могут состоять из произвольных частей машинных слов (например, биты 3-5 из 32-битного [[int|int]]), но непосредственно их адресовать нет никакой возможности. Ранее я упоминал, что ссылки и указатели представляют собой одно и то же на аппаратном уровне, и просто так же, как нет никакого способа создать указатели на отдельные биты (С++ утверждает, что наименьшей сущностью, которую вы можете адресовать, является [[Char|char]]), нет никакого способа связать ссылку с произвольными битами.

Обходной путь для невозможности прямой передачи битовых полей становится простым, как только вы осознаете, что любая функция, принимающая битовое поле в качестве аргумента, на самом деле получает копию значения битового поля. В конце концов, никакая функция не может привязать ссылку к битовому полю, поскольку не существует указателей на битовые поля. Единственная разновидность параметров, которым могут передаваться битовые поля - это параметры, передаваемые по значению, и, что интересно, ссылки на [[const|const]]. В случае передачи по значению вызываемая функция, очевидно, получает копию значения в битовом поле, и оказывается, что в случае параметра, являющегося ссылкой на [[const|const]], стандарт требует, чтобы эта ссылка в действительности была привязана к копии значения битового поля, сохраненного в объекте некоторого стандартного целочисленного типа (например, [[int|int]]). Ссылки на [[const|const]] не привязываются к битовым полям, они привязываются к "нормальным" объектам, в которые копируются значения битовых полей.

Итак, ключом к передаче битового поля в функцию с прямой передачей является использование того факта, что функция, в которую осуществляется передача, всегда получает копию значения битового поля. Таким образом, вы можете сделать копию самостоятельно и вызвать передающую функцию, передав ей копию. В нашем примере с `IPv4Header` код, осуществляющий этот подход, имеет следующий вид:

```c++
// Копирование значения битового поля
auto length
static_cast<std::uint16_t>(h.totalLength);
fwd(length);                                // Передача копии
```

В большинстве случаев прямая передача работает так, как разрекламировано. Вы редко должны задумываться о ней. Но когда она не работает (разумно выглядящий код не компилируется или, хуже того, компилируется, но работает не так, как вы ожидаете), важно знать о несовершенствах прямой передачи. Не менее важно знать, как эти несовершенства обойти. В большинстве случаев это довольно просто.

> - Прямая передача неудачна, когда вывод типа не удается выполнить или когда он выводит неверный тип.
> - Разновидностями аргументов, которые приводят к неудачам при прямой передаче, являются инициализаторы в фигурных скобках, нулевые указатели, выраженные как `0` или `NULL`, целочисленные члены-данные, объявленные как [[const|const]] [[static|static]] и не имеющие определений, имена шаблонов и перегруженных функций и битовые поля.













































