# Аргументы - массивы

Мы рассмотрели большую часть материала, посвященного [[Вывод типа шаблона|выводу типов шаблонов]], но есть еще один угол, в который стоит заглянуть. Это отличие типов массивов от типов указателей, несмотря на то, что зачастую они выглядят взаимозаменяемыми. Основ­ной вклад в эту иллюзию вносит то, что во множестве контекстов массив преобразуется в указатель на его первый элемент. Это преобразование позволяет компилироваться коду наподобие следующего:
```c++
const char name[] = "Briggs";           // Тип name - const char[13]
const char * ptrToName = name;          // Массив становится указателем
```

Здесь указатель `ptrToName` типа `const char*` инициализируется переменной `name`, которая имеет тип `const char[13]`. Эти типы (`const char*` и `const char[13]`) не являются одним и тем же типом, но благодаря правилу преобразования массива в указатель при­ веденный выше код компилируется.

Но что будет, если передать массив шаблону, принимающему параметр по значению?
```c++
template<typeпame Т>
void f(T param);                    // Шаблон, получающий параметр по значению

f(name);                            // Какой тип Т и param будет выведен?
```

Начнем с наблюдения, что не существует такой вещи, как параметр функции, являю­щийся массивом. Да, да - приведенный далее синтаксис корректен:
```c++
void myFunc(iпt param[]);
```

Однако объявление массива рассматривается как объявление указателя, а это означает, что функция `myFunc` может быть эквивалентно объявлена как
```c++
void myFunc(iпt* param);             // Та же функция, что и ранее
```

Эта эквивалентность параметров, представляющих собой массив и указатель, образно го­воря, представляет собой немного листвы от корней С на дереве С++ и способствует возникновению иллюзии, что типы массивов и указателей представляют собой одно и то же.

Поскольку объявление параметра-массива рассматривается так, как если бы это было объявление параметра-указателя, тип массива, передаваемого в шаблонную функцию по значению, выводится как тип указателя. Это означает, что в вызове шаблонной функции `f` ее параметр типа `Т` выводится как `const char *`:
```c++
f(name);                            // nаmе - массив, но Т - coпst char*
```

А вот теперь начинаются настоящие хитрости. Хотя функции не могут объявлять параметры как истинные массивы, они могут объявлять параметры, являющиеся ссылками на массивы! Так что если мы изменим шаблон `f` так, чтобы он получал свой аргумент по ссылке,
```c++
template<typeпame Т>
void f(T& param);                  // Шаблон с передачей параметра по ссылке
```

и передадим ему массив
```c++
f(пame);                           // Передача массива функции f
```

то тип, выведенный для `Т`, будет в действительности типом массива! Этот тип включает размер массива, так что в нашем примере `T` выводится как `const char[13]`, а типом параметра `f` (ссылки на этот массив) является `const char(&)[13]`. Да, выглядит этот синтаксис как наркотический бред, но знание его прибавит вам веса в глазах понимающих людей.

Интересно, что возможность объявлять ссылки на массивы позволяет создать шаблон, который выводит количество элементов, содержащихся в массиве:
```c++
// Возвращает размер массива как константу времени компиляции .
// Параметр не имеет имени, поскольку, кроме количества
// содержащихся в нем элементов, нас ничто не интересует.

template<typeпame Т, std::size_t N>
constexpr std::size_t arraySize (T(&)[N]) nоехсерt
{
	return N;
}
```

Как [[Используйте, где это возможно, constexpr|поясняется]], объявление этой функции как [[constexpr|constexpr]] делает ее результат доступным во время компиляции. Это позволяет объявить, например, массив с таким же количеством элементов, как и у второго массива, размер которого вычисляется из инициализатора в фигурных скобках:
```c++
// keyVals содержит 7 элементов:
iпt keyVals[] = {1, 3, 7, 9, 11, 22, 35};

iпt mappedVals[arraySize(keyVals)] ;         // mappedVals - тоже
```

Конечно, как разработчик на современном С++ вы, естественно, предпочтете [[Array|std::array]] встроенному массиву:
```c++
// Размер mappedVals равен 7
std::array<iпt, arraySize(keyVals)> mappedVals;
```

Что касается объявления `arraySize` как `nоехсерt`, то это помогает компилятору генери­ровать лучший код. [[noexcept|Детальнее...]]
