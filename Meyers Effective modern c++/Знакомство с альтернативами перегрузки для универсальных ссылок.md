# Знакомство с альтернативами перегрузки для универсальных ссылок

В [[Избегайте перегрузок для универсальных ссылок|разделе]] поясняется, что перегрузка для универсальных ссылок может привести к целому ряду проблем как для автономных функций, так и для функций-членов (в особенности для конструкторов). Тем не менее в нем также приводятся примеры, когда такая перегрузка может оказаться полезной, если только она будет вести себя так, как мы· хотим! В этом разделе исследуются способы достижения желаемого поведения либо путем проектирования, позволяющего избежать перегрузок для универсальных ссылок, либо путем применения их таким образом, чтобы ограничить типы аргументов, которым
они могут соответствовать.

Ниже использованы примеры, представленные в [[Избегайте перегрузок для универсальных ссылок|разделе]]. 

## Отказ от перегрузки

В первом примере [[Избегайте перегрузок для универсальных ссылок|раздела]] функция `logAndAdd` является типичным представителем функций, которые могут избежать недостатков перегрузки для универсальных ссылок, просто используя разные имена для потенциальных перегрузок. Например, рассматривавшиеся перегрузки `logAndAdd` могут быть разделены на `logAndAddName` и `logAndAddNameidx`. Увы, этот подход не будет работать для второго рассматривавшегося примера - конструктора `Person`, потому что имена конструкторов в языке зафиксированы. 

## Передача const T&

Одной из альтернатив является возврат к С++98 и замена передачи универсальной ссылки передачей [[rvalue|lvаluе-ссылки]] на [[const|const]]. Фактически это первый подход, рассматривавшийся [[Избегайте перегрузок для универсальных ссылок|тут]]. Его недостаток состоит в том, что данный дизайн не столь эффективен, как нам хотелось бы. С учетом всех нынешних наших знаний о взаимодействии универсальных ссылок и перегрузки отказ от некоторой эффективности в пользу простоты может оказаться более привлекательными компромиссом, чем нам казалось изначально.

## Передача по значению

Подход, который часто позволяет добиться производительности без увеличения сложности, заключается в замене передачи параметров по ссылке передачей по значению, как бы противоестественно это ни звучало. Этот дизайн основан на совете из: [[Subtlety#Рассмотрите передачу по значению для копируемых параметров, которые лeгкo перемещаются и всегда копируются|рассмотреть вопрос о передаче объектов по значению в случае, когда известно, что они будут копироваться]]. Поэтому я отложу до указанного раздела подробное обсуждение того, как все это работает и насколько эффективным является это решение. Здесь я просто покажу, как этот подход может использоваться в примере с классом `Person`:

```c++
class Person
	public:
		explicit Person(std::string n) // Замена конструктора с Т&&
			:name(std::move(n)){}      // на применение std::move

		explicit Person(int idx)       // Как и ранее
			:name(nameFromidx(idx)){}
		...
	
	private :
		std::string name;
};
```

Поскольку конструктора [[string|std::string]], принимающего только целочисленное значение нет, все аргументы типа [[int|int]] и подобных ему (например [[size_t|std::size_t]], [[short|short]], [[long|long]]), передаваемые конструктору `Person`, будут перенаправлены к перегрузке для [[int|int]]. Аналогично все аргументы типа [[string|std::string]] (а также аргументы, из которых могут быть созданы объекты [[string|std::string]], например литералы наподобие `"Ruth"` ) будут передаваться конструктору, принимающему [[string|std::string]]. Здесь для вызывающего кода нет никаких сюрпризов. Возможно, некоторые программисты будут удивлены, что применение `0` или `NULL` в качестве нулевого указателя приведет к вызову перегрузки для [[int|int]], но таким программистам необходимо внимательно прочесть [[Предпочитайте nullptr значениям 0 и NULL|раздел]] и читать его до полного просветления в данном вопросе.

## Диспетчеризация дескрипторов

Ни передача [[rvalue|lvаluе-ссылки]] на [[const|const]], ни передача по значению не предоставляют поддержку прямой передачи. Если мотивом использования универсальной ссылки является прямая передача, мы вынуждены использовать универсальную ссылку; у нас просто нет иного выбора. Тем не менее мы не хотим отказываться и от перегрузки. Если мы не отказываемся ни от перегрузок, ни от универсальных ссылок, то как же мы сможем избежать перегрузки для универсальных ссылок?

В действительности это не так трудно. Вызовы перегруженных функций разрешаются путем просмотра всех параметров всех перегрузок, а также всех аргументов в точке вызова с последующим выбором функции с наилучшим общим соответствием - с учетом всех комбинаций "параметр/аргумент". Параметр, являющийся универсальной ссылкой, обычно обеспечивает точное соответствие для всего, что бы ни было передано, но если универсальная ссылка является частью списка параметров, содержащего другие параметры, универсальными ссылками не являющиеся, достаточно плохое соответствие этих последних параметров может привести к отказу от вызова такой перегрузки. Эта идея лежит в основе подхода диспетчеризации дескрипторов (tag dispatch), а приведенный ниже пример позволит лучше понять, о чем идет речь.

Применим этот метод к примеру `logAndAdd` из третьего фрагмента кода [[Избегайте перегрузок для универсальных ссылок|раздела]].

```c++
std::multiset<std::string> names;     // Глобальная структура данных

template<typename Т>                  // Делает запись в журнале и
void logAndAdd(T&& name)              // добавляет name в names
{
	auto now = std::chrono::system_clock::now();
	log(now, "logAndAdd");
	names.emplace(std::forward<T>(name));
} 
```

Сама по себе эта функция работает отлично, но если мы добавим перегрузку, принимающую значение типа [[int|int]], использующееся для поиска объекта по индексу, то получим проблемы, описанные в [[Избегайте перегрузок для универсальных ссылок|разделе]]. Цель данного раздела - их избежать. Вместо добавления перегрузки мы реализуем `logAndAdd` заново для делегирования работы двум другим функциям: одной - для целочисленных значений, а другой - для всего прочего. Сама функция `logAndAdd` будет принимать все типы аргументов, как целочисленные, так и нет.

Эти две функции, выполняющие реальную работу, будут называться `logAndAddImpl`, т.е. мы воспользуемся перегрузкой. Одна из этих функций будет принимать универсальную ссылку. Так что у нас будет одновременно и перегрузка, и универсальные ссылки. Но каждая функция будет принимать и второй параметр, указывающий, является ли передаваемый аргумент целочисленным значением. Этот второй параметр и будет средством, избавляющим нас от падений в болото, описанное в [[Избегайте перегрузок для универсальных ссылок|разделе]], так как он будет фактором, определяющим выбираемую перегрузку.

Вот почти корректная версия обновленной функции `logAndAdd`:

```c++
template<typename Т>
void logAndAdd(T&& name)
{
	logAndAddimpl(std::forward<T>(name),
		std::is_integral<Т>());               // Не совсем корректно
}
```

Эта функция передает свой параметр в `logAndAddimpl` и при этом передает также аргумент, указывающий, является ли тип параметра (`Т`) целочисленным. Как минимум это то, что она должна делать. То же самое она делает и для целочисленных аргументов, являющихся [[rvalue|rvalue]]. Но, как [[Свертывание ссылок|поясняется]], если [[rvalue|lvаluе-аргумент]] передается по универсальной ссылке `name`, то выведенный тип для `T` будет [[rvalue|Ivаluе-ссылкой]]. Так что если в функцию `logAndAdd` передается [[rvalue|lvalue]] типа [[int|int]], то тип `Т` будет выведен как `int&`. Но это не целочисленный тип - ссылка таковым не является. Это означает, что `std::is_integral<T>` будет иметь ложное значение для любого [[rvalue|lvаluе-аргумента]], даже если этот аргумент на самом деле является целочисленным значением.

Понимание данной проблемы равносильно ее решению, поскольку в стандартной библиотеке имеется такое средство, как [[remove_reference|std::remove_reference]] ([[Предпочитайте объявление псевдонимов  применению typedef|см.]]), которое делает то, о чем говорит его имя и в чем мы так нуждаемся: удаляет любые квалификаторы ссылок из типа. Так что верный способ написания `logAndAdd` имеет следующий вид:

```c++
template<typename Т>
void logAndAdd(T&& name)
{
	logAndAddimpl(
		std::forward<T>(name),
		std::is_integral<
			typename std::remove_reference<T>::type
		>()
	);
}
```

Это в определенной мере трюк. (Кстати, в С++ 14 можно сэкономить несколько нажатий клавиш, воспользовавшись вместо текста [[remove_reference|std::remove_reference_t<T>]]. [[Предпочитайте объявление псевдонимов  применению typedef|Подробнее]]).

После принятия этих мер мы можем перенести наше внимание к вызываемой функции, `logAndAddimpl`. Имеются две перегрузки, первая из которых применима к любому нецелочисленному типу (т.е. ко всем типам, для которых значение `std::is_integral<typename std::remove_reference<T>::type>` ложно):

```c++
// Нецелочисленный аргумент добавляется
// в глобальную структуру данных:
template<typename Т>
void logAndAddimpl(T&& name, std::false_type)
{
	auto now = std::chrono::system_clock::now();
	log(now, " logAndAdd ");
	names.emplace(std::forward<T>(name));
```

Этот код прост, если вы понимаете механику.

Концептуально `logAndAdd` передает в функцию `logAndAddimpl` булево значение, указывающее, передан ли функции `logAndAdd` целочисленный тип, но значения `true` и `false` являются значениями времени выполнения, а нам для выбора верной версии `logAndAddimpl` необходимо разрешение перегрузки, т.е. явление времени компиляции. Это означает, что нам нужен тип, соответствующий значению `true`, и другой тип, соответствующий значению `false`. Такая необходимость - настолько распространенное явление, что стандартная библиотека предоставляет то, что нам нужно, под именами [[true_type|std::true_tуре]] и [[true_type|std::false_type]]. Аргумент, передаваемый в `logAndAddimpl` функцией `logAndAdd`, является объектом типа, унаследованного от `std::true_type`, если `Т` целочисленный тип, и от `std::false_type`, если `Т` таковым не является. Конечный результат заключается в том, что эта перегрузка `logAndAddimpl` является реальным кандидатом для вызова в `logAndAdd`, только если `Т` не является целочисленным типом.

Вторая перегрузка охватывает противоположный случай, когда `T` представляет собой целочисленный тип. В этом случае `logAndAddimpl` просто ищет имя, соответствующее целочисленному индексу, и передает это имя функции `logAndAdd`:

```c++
std::string nameFromidx(int idx);
// Целочисленный аргумент: поиск имени и
// вызов с этим именем функции logAndAdd:
void logAndAddimpl(int iclx, std::true_type)
{
	logAndAdd(nameFromidx(idx));
}
```

Наличие функции `logAndAddimpl` для поиска по индексу соответствующего имени и передача его функции `logAndAdd` (откуда оно будет передано с помощью [[forward|std::forward]] другой перегрузке функции `logAndAddimpl`) позволяет избежать размещения кода для записи в журнале в обеих перегрузках `logAndAddimpl`.

В таком решении типы [[true_type|std::true_type и std::false_type]] являются "дескрипторами",  единственная цель которых - обеспечить разрешение перегрузки требующимся нам способом. Обратите внимание, что нам даже не нужны эти параметры. Они не служат никакой цели во время выполнения, и мы фактически надеемся, что компиляторы распознают, что параметры дескрипторов не используются, и соответствующим образом оптимизируют выполнимый образ программы. (Некоторые компиляторы так и поступают, по крайней мере иногда.) Вызов перегруженных функций реализации в `logAndAdd` "диспетчеризует" передачу работы правильной перегрузке путем создания нужного объекта дескриптора. Отсюда и название этого метода проектирования: диспетчеризация дескрипторов. Это стандартный строительный блок шаблонного метапрограммирования, и чем больше вы будете просматривать код внутри современных библиотек С++, тем чаще вы будете с ним сталкиваться.

Для наших целей важно не столько то, как работает диспетчеризация дескрипторов, сколько как она позволяет комбинировать универсальные ссылки и перегрузку без проблем, [[Избегайте перегрузок для универсальных ссылок|описанных тут]]. Функция диспетчеризации - `logAndAdd` - принимает параметр, являющийся неограниченной универсальной ссылкой, но эта функция не перегружается. Перегружается функция реализации - `logAndAddimpl`, - которая принимает параметр, представляющий собой универсальную ссылку, но разрешение вызова этой функции зависит не только от параметра универсальной ссылки, но и от параметра дескриптора, а значения дескрипторов спроектированы таким образом, чтобы было не более одной совпадающей перегрузки. В результате то, какая из перегрузок будет вызвана, определяется дескриптором. Тот факт, что параметр, представляющий собой универсальную ссылку, всегда генерирует точное соответствие своему аргументу, значения не имеет.































