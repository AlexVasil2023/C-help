
[[#Знакомство с decltуре]]
[[#decltype C++11]]
[[#decltype(auto) C++14]]

# Знакомство с decltуре

**decltype** - создание странное. Для данного имени или выражения `decltype` сообщает вам тип этого имени или выражения. Обычно то, что сообщает `decltype`, это именно то, что вы предсказываете. Однако иногда он дает результаты, которые заставляют вас чесать в затылке и обращаться к справочникам или сайтам.

Мы начнем с типичных случаев, в которых нет никаких подводных камней. В отличие от того, что происходит в процессе [[Вывод типа шаблона|вывода типов для шаблонов]] и [[Вывод типа auto|auto]], `decltype` обычно попугайничает, возвращая точный тип имени или выражения, которое вы передаете ему:
```c++
const int i = О;                        // decltype(i) - const int

bool f(const Widget & w);               // decltype(w) - const Widget&
                                        // decltype(f) - bool(const Widget &)

struct Point {
	int х, у;                           // decltype (Point::x) - int
};                                      // decltype (Point::y) - int

Widget w;                               // decltype(w) - Widget

if(f(w))...                             // decltype(f(w)) - bool

template<typename Т>                    // Упрощенная версия std::vector
class vector {
public :
	...
	Т& operator[](std::size_t index);
};

vector<int>v;                            // decltype(v) - vector<int>

if(v[O] == 0)                            // decltype (v[O]) - int&
```

Пожалуй, основное применение `decltype` в С++11 объявление шаблонов функций, в которых возвращаемый тип функции зависит от типов ее параметров. Предположим, например, что мы хотим написать функцию, получающую контейнер, который поддерживает индексацию с помощью квадратных скобок (т.е. с использованием "[]") с индек­сом, а затем аутентифицирует пользователя перед тем как вернуть результат операции индексации. Возвращаемый тип функции должен быть тем же, что и тип, возвращаемый операцией индексации.

`operator[]` для контейнера объектов типа `Т` обычно возвращает `Т&`. Например, это так в случае [[deque|std::deque]] и почти всегда - в случае [[vector|std::vector]]. Однако для `std::vector<bool>` оператор `operator[]` не возвращает `bool &`. Вместо этого он возвращает новый объект. Все "почему" и "как" данной ситуации [[auto#Если auto выводит нежелательный тип, используйте явно типизированный инициализатор|рассматриваются тут"]], но главное здесь то, что возвращаемый оператором `operator[]` контейнера тип зависит от самого контейнера.

`decltype` упрощает выражение этой зависимости. Вот пример, показывающий применение `decltуре` для вычисления возвращаемого типа. Этот шаблон требует уточнения, но пока что мы его отложим.
```c++
template<typename Container, typename Index>    // Работает, но
auto authAndAccess(Container& c, Index i)       // требует
		-> decltype(c[i])                       // уточнения
{
	authenticateUser();
	return c[i] ;
}
```

Использование [[auto|auto]] перед именем функции не имеет ничего общего с выводом типа. На самом деле оно указывает, что использован синтаксис С++11 завершающий возвращаемый тип (trailing return type), т.е. что возвращаемый тип функции будет объявлен после списка параметров (после "->"). Завершающий возвращаемый тип обладает тем преимуществом, что в спецификации возвращаемого типа могут использоваться параметры функции. В `authAndAccess`, например, мы указываем возвращаемый тип с использовани­ем `с` и `i`. Если бы возвращаемый тип, как обычно, предшествовал имени функции, `с` и `i` были бы в нем недоступны, поскольку в этот момент они еще не были объявлены.

При таком объявлении `authAndAccess` возвращает тот тип, который возвращает `operator[]` при применении к переданному контейнеру, в точности как мы и хотели.

С++11 разрешает вывод возвращаемых типов лямбда-выражений из одной инструкции, а С++14 расширяет эту возможность на все лямбда-выражения и все функции, включая состоящие из множества инструкций. В случае `authAndAccess` это означает, что в С++14 мы можем опустить завершающий возвращаемый тип, оставляя только одно ведущее ключевое слово [[auto|auto]]. При таком объявлении [[auto|auto]] означает, что имеет место вывод типа. В частности, это означает, что компиляторы будут выводить возвращаемый тип функции из ее реализации:
```c++
template<typename Container, typename Index>    // С++14 ;
auto authAndAccess(Container& c, Index i)       // Не совсем
{                                               // корректно
	authenticateUser();
	return c[i] ;                           // Возвращаемый тип выводится из c[i]
}
```

В [[Вывод типа auto|разделе]] поясняется, что для функций с аutо-спецификацией возвращаемого типа компиляторы применяют вывод типа шаблона. В данном случае это оказывается пробле­матичным. Как уже говорилось, `operator[]` для большинства контейнеров с объектами типа `Т` возвращает `Т&`, но в [[Вывод типа шаблона|разделе]] поясняется, что в процессе вывода типа шаблона "ссылочность" инициализирующего выражения игнорируется. Рассмотрим, что это озна­чает для следующего клиентского кода:
```c++
std::deque<int> d;
...
authAndAccess(d, 5) = 10;           //Аутентифицирует пользователя,
									// возвращает d[5], затем присваивает ему
									// значение 10. Код не компилируется!
```

Здесь `d[5]` возвращает `int&`, но вывод возвращаемого типа `auto` для `authAndAccess` отбрасывает ссылку, тем самым давая возвращаемый тип `int`. Этот `int`, будучи возвращаемым значением функции, является [[rvalue|rvalue]], так что приведенный выше код пытается присвоить этому [[rvalue|rvalue]] типа `int` значение 10. Это запрещено в С++, так что данный код не компилируется.

Чтобы заставить `authAndAccess` работать так, как мы хотим, нам надо использовать для ее возвращаемого типа вывод типа `decltype`, т.е. указать, что `authAndAccess` должна возвращать в точности тот же тип, что и выражение `с[i]`. Защитники С++, предвидя необходимость использования в некоторых случаях правил вывода типа `decltуре`, сделали это возможным в С++14 с помощью спецификатора [[#decltype(auto) C++14|decltype(auto)]]. То, что изначально может показаться противоречием (`decltype` и [[auto|auto]]?), в действительности имеет смысл: [[auto|auto]] указывает, что тип должен быть выведен, а `decltype` говорит о том, что в процессе вывода следует использовать правила `decltype`. Итак, можно записать `authAndAccess` следующим образом:
```c++
template<typename Container, typename Index>    // С++14 ;
decltype(auto)                                  // но все еще
authAndAccess(Container& c, Index i)            // требует
{                                               // уточнения
	authenticateUser();
	return c[i] ; 
}
```

Теперь `authAndAccess` действительно возвращает то же, что и `с[i]`. В частности, в распространенном случае, когда `с[i]` возвращает `Т&`, `authAndAccess` также возвращает `Т&`, и в том редком случае, когда `с[i]` возвращает объект, `authAndAccess` также возвращает объект.

Использование [[#decltype(auto) C++14|decltype(auto)]] не ограничивается возвращаемыми типами функций. Это также может быть удобно для объявления переменных, когда вы хотите применять правила вывода типа `decltype` к инициализирующему выражению:
```c++
Widget w;
const Widget& cw = w;

auto myWidgetl = cw;            // Вывод типа auto:
                                // тип myWidgetl - Widget

decltype(auto) myWidget2 = cw;  // Вывод типа decltype :
								// тип myWidget2 - coпst Widget&
```

Я знаю, что вас беспокоят два момента. Один из них - упомянутое выше, но пока не описанное уточнение `authAndAccess`. Давайте, наконец-то, разберемся в этом вопросе.

Еще раз посмотрим на версию `authAndAccess` в С++14:
```c++
template<typename Container, typename Index> 
decltype(auto) authAndAccess(Container& c, Index i)
```

Контейнер передается как `lvalue-ccылкa` на неконстантный объект, поскольку возвращаемая ссылка на элемент контейнера позволяет клиенту модифицировать этот контейнер. Но это означает, что этой функции невозможно передавать контейнеры, являющиеся [[rvalue|rvalue]]. [[rvalue|rvalue]] невозможно связать с `lvаluе-ссылками` (если только они не являются `lvаluе-ссылками` на константные объекты, что в данном случае очевидным образом не выполняется).

Надо сказать, что передача контейнера, являющегося [[rvalue|rvalue]], в `authAndAccess` является крайним случаем. Такой `rvаluе-контейнер`, будучи временным объектом, обычно уничтожается в конце инструкции, содержащей вызов `authAndAccess`, а это означает, что ссылка на элемент в таком контейнере (то, что должна вернуть функция `authAndAccess`) окажется "висячей" в конце создавшей ее инструкции. Тем не менее передача временного объекта функции `authAndAccess` может иметь смысл. Например, клиент может просто хотеть сделать копию элемента во временном контейнере:
```c++
std::deque<std::string> makeStringDeque();       // Фабричная функция

// Делаем копию пятого элемента deque, возвращаемого
// функцией makeStringDeque
auto s = authAndAccess(makeStringDeque(), 5);
```

Поддержка такого использования означает, что мы должны пересмотреть объявление функции `authAndAccess`, которая должна принимать как [[rvalue|lvalue]], так и [[rvalue|rvalue]]. Можно ис­пользовать перегрузку (одна функция объявлена с параметром, представляющим собой `lvalue-ccылкy`, а вторая - с параметром, представляющим собой `rvalue-ccылкy`), но тогда нам придется поддерживать две функции. Избежать этого можно, если у нас будет функ­ция `authAndAccess`, использующая ссылочный параметр, который может быть связан как с [[rvalue|lvalue]], так и с [[rvalue|rvalue]], [[Отличие универсальных ссылок от rvalue-ссылок|в этом разделе]] поясняется, что это именно то, что делают универсаль­ные ссылки. Таким образом, `authAndAccess` может быть объявлена следующим образом:
```c++
template<typename Container, typename Index>         // Теперь с -
decltype(auto) authAndAccess(Container&& c, Index i) // универсальная ссылка
```

В этом шаблоне мы не знаем, с каким типом контейнера работаем, и точно так же не знаем тип используемых им индексных объектов. Использование [[Subtlety#Рассмотрите передачу по значению для копируемых параметров, которые лeгкo перемещаются и всегда копируются|передачи по значению для объектов]] неизвестного типа обычно сопровождается риском снижения производительности из-за ненужного копирования, проблемами со срезкой объектов и насмешками коллег. Но в случае индексов контейнеров, следуя примеру стан­дартной библиотеки для значений индексов (например, в `operator[]` для [[string|std::string]], [[vector|std::vector]] и [[deque|std::deque]]) это решение представляется разумным, так что мы будем придерживаться для них передачи по значению.

Однако нам нужно обновить реализацию шаблона для приведения его в соответствие с предостережениями [[Использование move и forward|о применении forward к универсальным ссылкам]] :
```c++
template<typename Container, typename Index>         // Окончательная -
decltype(auto)                                       // версия для
authAndAccess(Container&& c, Index i)                // C++14
{
	authenticateUser ( ) ;
	return std::forward<Container>(c)[i);
}
```

Этот код должен делать все, что мы хотели, но он требует компилятора С++14. Если у вас нет такового, вам следует использовать версию шаблона для С++11 . Она такая же, как и ее аналог С++14, за исключением того, что вы должны самостоятельно указать воз­вращаемый тип:
```c++
template<typename Container, typename Index>         // Окончательная -
auto                                                 // версия для
authAndAccess(Container&& c, Index i)                // C++11
->decltype(std::forward<Container>(с)[i])
{
	authenticateUser ( ) ;
	return std::forward<Container>(c)[i);
}
```

Вторым беспокоящим моментом является мое замечание в начале этого раздела о том, что `decltуре` почти всегда дает тип, который вы ожидаете, т.е. что он редко преподносит сюрпризы. По правде говоря, вряд ли вы столкнетесь с этими исключениями из правила, если только вы не занимаетесь круглосуточно написанием библиотек.

Чтобы полностью понимать поведение `decltype`, вы должны познакомиться с некоторыми особыми случаями. Большинство из них слишком невразумительны, чтобы быть размещенными здесь, но один из них приводит к лучшему пониманию `decltype` и его применения.

Применение `decltype` к имени дает объявленный тип для этого имени. Имена представляют собой `lvаluе-выражения`, но это не влияет на поведение `decltype`. Однако для `lvаluе-выражений`, более сложных, чем имена, `decltype` гарантирует, что возвраща­емый тип всегда будет `lvаluе-ссылкой`. Иначе говоря, если `lvаluе-выражение`, отличное от имени, имеет тип `Т`, то `decltype` сообщает об этом типе как об `Т&`. Это редко на что-то влияет, поскольку тип большинства `lvаluе-выражений` в обязательном порядке включает квалификатор `lvаluе-ссылки`. Например, функции, возвращающие `lvalue`, всегда возвращают `lvаluе-ссылки`.
Однако у этого поведения есть следствия, о которых необходимо знать. В коде
```c++
int х = О;
```

`x` является именем переменной, так что `decltype(х)` представляет собой `int`. Однако "заворачивание" имени `х` в скобки - "(х) " - дает выражение, более сложное, чем имя. Будучи именем, `х` представляет собой `lvalue`, и С++ также определяет выражение `(х)` как `lvalue`. Следовательно, `decltype((х))` представляет собой `int&`. Добавление скобок во­круг имени может изменить тип, возвращаемый для него `decltype`!
В C++11 это просто любопытный факт, но в сочетании с поддержкой в С++14 `decltype(auto)` это означает, что, казалось бы, тривиальные изменения в способе запи­си инструкции `return` могут повлиять на выводимый тип функции:
```c++
decltype(auto) f1()
{
	int х = О ;
	...
	return х;                       // decltype(x) представляет собой int,
									// так что fl возвращает int
}

decltype(auto) f2()
{
	int х = О ;
	...
	return (х);                     // decltype(x) представляет собой int &,
									// так что f2 возвращает int&
}
```

Обратите внимание, что `f2` не только имеет возвращаемый тип, отличный от `f1`, но и возвращает ссылку на локальную переменную! Этот код ведет вас к неопределенному поведению, что вряд ли является вашей целью.

Основной урок состоит в том, чтобы при использовании `decltype(auto)` уделять деталям самое пристальное внимание. Кажущиеся совершенно незначительными дета­ли в выражении, для которого выводится тип, могут существенно повлиять на тип, воз­вращаемый `decltype(auto)`. Чтобы гарантировать, что выводимый тип - именно тот, который вы ожидаете, используйте методы, описанные в [[Как просмотреть выведенные типы|разделе "Как просмотреть выведенные типы"]].
В то же время не забывайте и о более широкой перспективе. Конечно, `decltype` (как автономный, так и в сочетании с `auto`) при выводе типов иногда может  привести к сюр­призам, но это не нормальная ситуация. Как правило, `decltype` возвращает тот тип, ко­торый вы ожидаете. Это особенно верно, когда `decltype` применяется к именам, потомучто в этом случае `decltype` делает именно то, что скрывается в его названии: сообщает объявленный тип (`declared type`) имени.

> - `decltype` почти всегда дает тип переменной или выражения без каких-либо изменений.
> - Для lvаluе-выражений типа `T`, отличных от имени, `decltype` всегда дает тип `Т&`.
> - C++14 поддерживает конструкцию [[decltype(auto)|decltype(auto)]] , которая, подобно `auto`, выво­ дит тип из его инициализатора, но выполняет вывод типа с использованием правил `decltype`.

# decltype C++11

`decltype` – оператор, возвращающий объявленный тип переданного ему выражения. CV-квалификаторы и ссылки сохраняются, если они являются частью выражения.
```c++
int a = 1; // `a` объявлено `int`
decltype(a) b = a; // `decltype(a)` - `int`
const int& c = a; // `c` объявлено как `const int&`
decltype(c) d = a; // `decltype(c)` - `const int&`
decltype(123) e = 123; // `decltype(123)` is `int`
int&& f = 1; // `f` объявлено как `int&&`
decltype(f) g = 1; // `decltype(f) - `int&&`
decltype((a)) h = g; // `decltype((a))` - int&

template <typename X, typename Y>
auto add(X x, Y y) -> decltype(x + y) {
  return x + y;
}

add(1, 2.0); // `decltype(x + y)` => `decltype(3.0)` => `double`
```

# decltype(auto) C++14

Спецификатор типа `decltype(auto)` выводит тип, как [[auto|auto]], но сохраняет ссылки и CV-квалификаторы.
```c++
const int x = 0;
auto x1 = x; // int
decltype(auto) x2 = x; // const int

int y = 0;
int& y1 = y;
auto y2 = y1; // int
decltype(auto) y3 = y1; // int&

int&& z = 0;
auto z1 = std::move(z); // int
decltype(auto) z2 = std::move(z); // int&&

// возвращаемый тип `int`.
auto f(const int& i) {
	return i;
}

// возвращаемый тип  `const int&`.
decltype(auto) g(const int& i) {
	return i;
}

int x = 123;
static_assert(std::is_same<const int&, decltype(f(x))>::value == 0);
static_assert(std::is_same<int, decltype(f(x))>::value == 1);
static_assert(std::is_same<const int&, decltype(g(x))>::value == 1);
```
