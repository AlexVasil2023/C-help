
[[#Знакомство с decltуре]]
[[#decltype C++11]]
[[#Запись типа выражения с помощью decltype|Запись типа выражения с помощью decltype]]
[[#decltype(auto) C++14]]

# Знакомство с decltуре

**decltype** - создание странное. Для данного имени или выражения `decltype` сообщает вам тип этого имени или выражения. Обычно то, что сообщает `decltype`, это именно то, что вы предсказываете. Однако иногда он дает результаты, которые заставляют вас чесать в затылке и обращаться к справочникам или сайтам.

Мы начнем с типичных случаев, в которых нет никаких подводных камней. В отличие от того, что происходит в процессе [[Вывод типа шаблона|вывода типов для шаблонов]] и [[auto#Вывод типа auto|auto]], `decltype` обычно попугайничает, возвращая точный тип имени или выражения, которое вы передаете ему:
```c++
const int i = О;                        // decltype(i) - const int

bool f(const Widget & w);               // decltype(w) - const Widget&
                                        // decltype(f) - bool(const Widget &)

struct Point {
	int х, у;                           // decltype (Point::x) - int
};                                      // decltype (Point::y) - int

Widget w;                               // decltype(w) - Widget

if(f(w))...                             // decltype(f(w)) - bool

template<typename Т>                    // Упрощенная версия std::vector
class vector {
public :
	...
	Т& operator[](std::size_t index);
};

vector<int>v;                            // decltype(v) - vector<int>

if(v[O] == 0)                            // decltype (v[O]) - int&
```

Пожалуй, основное применение `decltype` в С++11 объявление шаблонов функций, в которых возвращаемый тип функции зависит от типов ее параметров. Предположим, например, что мы хотим написать функцию, получающую контейнер, который поддерживает индексацию с помощью квадратных скобок (т.е. с использованием "[]") с индек­сом, а затем аутентифицирует пользователя перед тем как вернуть результат операции индексации. Возвращаемый тип функции должен быть тем же, что и тип, возвращаемый операцией индексации.

`operator[]` для контейнера объектов типа `Т` обычно возвращает `Т&`. Например, это так в случае [[deque|std::deque]] и почти всегда - в случае [[vector|std::vector]]. Однако для `std::vector<bool>` оператор `operator[]` не возвращает `bool &`. Вместо этого он возвращает новый объект. Все "почему" и "как" данной ситуации [[auto#Если auto выводит нежелательный тип, используйте явно типизированный инициализатор|рассматриваются тут"]], но главное здесь то, что возвращаемый оператором `operator[]` контейнера тип зависит от самого контейнера.

`decltype` упрощает выражение этой зависимости. Вот пример, показывающий применение `decltуре` для вычисления возвращаемого типа. Этот шаблон требует уточнения, но пока что мы его отложим.
```c++
template<typename Container, typename Index>    // Работает, но
auto authAndAccess(Container& c, Index i)       // требует
		-> decltype(c[i])                       // уточнения
{
	authenticateUser();
	return c[i] ;
}
```

Использование [[auto|auto]] перед именем функции не имеет ничего общего с выводом типа. На самом деле оно указывает, что использован синтаксис С++11 завершающий возвращаемый тип (trailing return type), т.е. что возвращаемый тип функции будет объявлен после списка параметров (после "->"). Завершающий возвращаемый тип обладает тем преимуществом, что в спецификации возвращаемого типа могут использоваться параметры функции. В `authAndAccess`, например, мы указываем возвращаемый тип с использовани­ем `с` и `i`. Если бы возвращаемый тип, как обычно, предшествовал имени функции, `с` и `i` были бы в нем недоступны, поскольку в этот момент они еще не были объявлены.

При таком объявлении `authAndAccess` возвращает тот тип, который возвращает `operator[]` при применении к переданному контейнеру, в точности как мы и хотели.

С++11 разрешает вывод возвращаемых типов лямбда-выражений из одной инструкции, а С++14 расширяет эту возможность на все лямбда-выражения и все функции, включая состоящие из множества инструкций. В случае `authAndAccess` это означает, что в С++14 мы можем опустить завершающий возвращаемый тип, оставляя только одно ведущее ключевое слово [[auto|auto]]. При таком объявлении [[auto|auto]] означает, что имеет место вывод типа. В частности, это означает, что компиляторы будут выводить возвращаемый тип функции из ее реализации:
```c++
template<typename Container, typename Index>    // С++14 ;
auto authAndAccess(Container& c, Index i)       // Не совсем
{                                               // корректно
	authenticateUser();
	return c[i] ;                           // Возвращаемый тип выводится из c[i]
}
```

В [[Вывод типа auto|разделе]] поясняется, что для функций с аutо-спецификацией возвращаемого типа компиляторы применяют вывод типа шаблона. В данном случае это оказывается пробле­матичным. Как уже говорилось, `operator[]` для большинства контейнеров с объектами типа `Т` возвращает `Т&`, но в [[Вывод типа шаблона|разделе]] поясняется, что в процессе вывода типа шаблона "ссылочность" инициализирующего выражения игнорируется. Рассмотрим, что это озна­чает для следующего клиентского кода:
```c++
std::deque<int> d;
...
authAndAccess(d, 5) = 10;           //Аутентифицирует пользователя,
									// возвращает d[5], затем присваивает ему
									// значение 10. Код не компилируется!
```

Здесь `d[5]` возвращает `int&`, но вывод возвращаемого типа `auto` для `authAndAccess` отбрасывает ссылку, тем самым давая возвращаемый тип `int`. Этот `int`, будучи возвращаемым значением функции, является [[rvalue|rvalue]], так что приведенный выше код пытается присвоить этому [[rvalue|rvalue]] типа `int` значение 10. Это запрещено в С++, так что данный код не компилируется.

Чтобы заставить `authAndAccess` работать так, как мы хотим, нам надо использовать для ее возвращаемого типа вывод типа `decltype`, т.е. указать, что `authAndAccess` должна возвращать в точности тот же тип, что и выражение `с[i]`. Защитники С++, предвидя необходимость использования в некоторых случаях правил вывода типа `decltуре`, сделали это возможным в С++14 с помощью спецификатора [[#decltype(auto) C++14|decltype(auto)]]. То, что изначально может показаться противоречием (`decltype` и [[auto|auto]]?), в действительности имеет смысл: [[auto|auto]] указывает, что тип должен быть выведен, а `decltype` говорит о том, что в процессе вывода следует использовать правила `decltype`. Итак, можно записать `authAndAccess` следующим образом:
```c++
template<typename Container, typename Index>    // С++14 ;
decltype(auto)                                  // но все еще
authAndAccess(Container& c, Index i)            // требует
{                                               // уточнения
	authenticateUser();
	return c[i] ; 
}
```

Теперь `authAndAccess` действительно возвращает то же, что и `с[i]`. В частности, в распространенном случае, когда `с[i]` возвращает `Т&`, `authAndAccess` также возвращает `Т&`, и в том редком случае, когда `с[i]` возвращает объект, `authAndAccess` также возвращает объект.

Использование [[#decltype(auto) C++14|decltype(auto)]] не ограничивается возвращаемыми типами функций. Это также может быть удобно для объявления переменных, когда вы хотите применять правила вывода типа `decltype` к инициализирующему выражению:
```c++
Widget w;
const Widget& cw = w;

auto myWidgetl = cw;            // Вывод типа auto:
                                // тип myWidgetl - Widget

decltype(auto) myWidget2 = cw;  // Вывод типа decltype :
								// тип myWidget2 - coпst Widget&
```

Я знаю, что вас беспокоят два момента. Один из них - упомянутое выше, но пока не описанное уточнение `authAndAccess`. Давайте, наконец-то, разберемся в этом вопросе.

Еще раз посмотрим на версию `authAndAccess` в С++14:
```c++
template<typename Container, typename Index> 
decltype(auto) authAndAccess(Container& c, Index i)
```

Контейнер передается как `lvalue-ccылкa` на неконстантный объект, поскольку возвращаемая ссылка на элемент контейнера позволяет клиенту модифицировать этот контейнер. Но это означает, что этой функции невозможно передавать контейнеры, являющиеся [[rvalue|rvalue]]. [[rvalue|rvalue]] невозможно связать с `lvаluе-ссылками` (если только они не являются `lvаluе-ссылками` на константные объекты, что в данном случае очевидным образом не выполняется).

Надо сказать, что передача контейнера, являющегося [[rvalue|rvalue]], в `authAndAccess` является крайним случаем. Такой `rvаluе-контейнер`, будучи временным объектом, обычно уничтожается в конце инструкции, содержащей вызов `authAndAccess`, а это означает, что ссылка на элемент в таком контейнере (то, что должна вернуть функция `authAndAccess`) окажется "висячей" в конце создавшей ее инструкции. Тем не менее передача временного объекта функции `authAndAccess` может иметь смысл. Например, клиент может просто хотеть сделать копию элемента во временном контейнере:
```c++
std::deque<std::string> makeStringDeque();       // Фабричная функция

// Делаем копию пятого элемента deque, возвращаемого
// функцией makeStringDeque
auto s = authAndAccess(makeStringDeque(), 5);
```

Поддержка такого использования означает, что мы должны пересмотреть объявление функции `authAndAccess`, которая должна принимать как [[rvalue|lvalue]], так и [[rvalue|rvalue]]. Можно ис­пользовать перегрузку (одна функция объявлена с параметром, представляющим собой `lvalue-ccылкy`, а вторая - с параметром, представляющим собой `rvalue-ccылкy`), но тогда нам придется поддерживать две функции. Избежать этого можно, если у нас будет функ­ция `authAndAccess`, использующая ссылочный параметр, который может быть связан как с [[rvalue|lvalue]], так и с [[rvalue|rvalue]], [[Отличие универсальных ссылок от rvalue-ссылок|в этом разделе]] поясняется, что это именно то, что делают универсаль­ные ссылки. Таким образом, `authAndAccess` может быть объявлена следующим образом:
```c++
template<typename Container, typename Index>         // Теперь с -
decltype(auto) authAndAccess(Container&& c, Index i) // универсальная ссылка
```

В этом шаблоне мы не знаем, с каким типом контейнера работаем, и точно так же не знаем тип используемых им индексных объектов. Использование [[Subtlety#Рассмотрите передачу по значению для копируемых параметров, которые лeгкo перемещаются и всегда копируются|передачи по значению для объектов]] неизвестного типа обычно сопровождается риском снижения производительности из-за ненужного копирования, проблемами со срезкой объектов и насмешками коллег. Но в случае индексов контейнеров, следуя примеру стан­дартной библиотеки для значений индексов (например, в `operator[]` для [[string|std::string]], [[vector|std::vector]] и [[deque|std::deque]]) это решение представляется разумным, так что мы будем придерживаться для них передачи по значению.

Однако нам нужно обновить реализацию шаблона для приведения его в соответствие с предостережениями [[Использование move и forward|о применении forward к универсальным ссылкам]] :
```c++
template<typename Container, typename Index>         // Окончательная -
decltype(auto)                                       // версия для
authAndAccess(Container&& c, Index i)                // C++14
{
	authenticateUser ( ) ;
	return std::forward<Container>(c)[i);
}
```

Этот код должен делать все, что мы хотели, но он требует компилятора С++14. Если у вас нет такового, вам следует использовать версию шаблона для С++11 . Она такая же, как и ее аналог С++14, за исключением того, что вы должны самостоятельно указать воз­вращаемый тип:
```c++
template<typename Container, typename Index>         // Окончательная -
auto                                                 // версия для
authAndAccess(Container&& c, Index i)                // C++11
->decltype(std::forward<Container>(с)[i])
{
	authenticateUser ( ) ;
	return std::forward<Container>(c)[i);
}
```

Вторым беспокоящим моментом является мое замечание в начале этого раздела о том, что `decltуре` почти всегда дает тип, который вы ожидаете, т.е. что он редко преподносит сюрпризы. По правде говоря, вряд ли вы столкнетесь с этими исключениями из правила, если только вы не занимаетесь круглосуточно написанием библиотек.

Чтобы полностью понимать поведение `decltype`, вы должны познакомиться с некоторыми особыми случаями. Большинство из них слишком невразумительны, чтобы быть размещенными здесь, но один из них приводит к лучшему пониманию `decltype` и его применения.

Применение `decltype` к имени дает объявленный тип для этого имени. Имена представляют собой `lvаluе-выражения`, но это не влияет на поведение `decltype`. Однако для `lvаluе-выражений`, более сложных, чем имена, `decltype` гарантирует, что возвраща­емый тип всегда будет `lvаluе-ссылкой`. Иначе говоря, если `lvаluе-выражение`, отличное от имени, имеет тип `Т`, то `decltype` сообщает об этом типе как об `Т&`. Это редко на что-то влияет, поскольку тип большинства `lvаluе-выражений` в обязательном порядке включает квалификатор `lvаluе-ссылки`. Например, функции, возвращающие `lvalue`, всегда возвращают `lvаluе-ссылки`.
Однако у этого поведения есть следствия, о которых необходимо знать. В коде
```c++
int х = О;
```

`x` является именем переменной, так что `decltype(х)` представляет собой `int`. Однако "заворачивание" имени `х` в скобки - "(х) " - дает выражение, более сложное, чем имя. Будучи именем, `х` представляет собой `lvalue`, и С++ также определяет выражение `(х)` как `lvalue`. Следовательно, `decltype((х))` представляет собой `int&`. Добавление скобок во­круг имени может изменить тип, возвращаемый для него `decltype`!
В C++11 это просто любопытный факт, но в сочетании с поддержкой в С++14 `decltype(auto)` это означает, что, казалось бы, тривиальные изменения в способе запи­си инструкции `return` могут повлиять на выводимый тип функции:
```c++
decltype(auto) f1()
{
	int х = О ;
	...
	return х;                       // decltype(x) представляет собой int,
									// так что fl возвращает int
}

decltype(auto) f2()
{
	int х = О ;
	...
	return (х);                     // decltype(x) представляет собой int &,
									// так что f2 возвращает int&
}
```

Обратите внимание, что `f2` не только имеет возвращаемый тип, отличный от `f1`, но и возвращает ссылку на локальную переменную! Этот код ведет вас к неопределенному поведению, что вряд ли является вашей целью.

Основной урок состоит в том, чтобы при использовании `decltype(auto)` уделять деталям самое пристальное внимание. Кажущиеся совершенно незначительными дета­ли в выражении, для которого выводится тип, могут существенно повлиять на тип, воз­вращаемый `decltype(auto)`. Чтобы гарантировать, что выводимый тип - именно тот, который вы ожидаете, используйте методы, описанные в [[Как просмотреть выведенные типы|разделе "Как просмотреть выведенные типы"]].
В то же время не забывайте и о более широкой перспективе. Конечно, `decltype` (как автономный, так и в сочетании с `auto`) при выводе типов иногда может  привести к сюр­призам, но это не нормальная ситуация. Как правило, `decltype` возвращает тот тип, ко­торый вы ожидаете. Это особенно верно, когда `decltype` применяется к именам, потомучто в этом случае `decltype` делает именно то, что скрывается в его названии: сообщает объявленный тип (`declared type`) имени.

> - `decltype` почти всегда дает тип переменной или выражения без каких-либо изменений.
> - Для lvаluе-выражений типа `T`, отличных от имени, `decltype` всегда дает тип `Т&`.
> - C++14 поддерживает конструкцию [[decltype(auto)|decltype(auto)]] , которая, подобно `auto`, выво­ дит тип из его инициализатора, но выполняет вывод типа с использованием правил `decltype`.

# decltype C++11

`decltype` – оператор, возвращающий объявленный тип переданного ему выражения. CV-квалификаторы и ссылки сохраняются, если они являются частью выражения.
```c++
int a = 1; // `a` объявлено `int`
decltype(a) b = a; // `decltype(a)` - `int`
const int& c = a; // `c` объявлено как `const int&`
decltype(c) d = a; // `decltype(c)` - `const int&`
decltype(123) e = 123; // `decltype(123)` is `int`
int&& f = 1; // `f` объявлено как `int&&`
decltype(f) g = 1; // `decltype(f) - `int&&`
decltype((a)) h = g; // `decltype((a))` - int&

template <typename X, typename Y>
auto add(X x, Y y) -> decltype(x + y) {
  return x + y;
}

add(1, 2.0); // `decltype(x + y)` => `decltype(3.0)` => `double`
```

# Запись типа выражения с помощью decltype

Ключевое слово [[auto|auto]] позволяет избежать необходимости писать тип переменной, но не позволяет легко использовать тип этой переменной. Эту проблему решает ключевое слово `decltype`: оно позволяет программисту выразить точный тип выражения или объявления. Однако программисты должны быть осторожными и понимать тонкие различия между тем, что дает `decltype`, в зависимости от того, является переданный аргумент объявленной сущностью или выражением.
>
> Если `е` является именем сущности (такой как переменная, функция, перечислитель или член-данные) или обращением к члену класса, `decltype(е)` дает объявленный тип этой сущности или упомянутого члена класса. Таким образом, `decltype` может использоваться для изучения типа переменной. Это полезно, когда нам нужно точное соответствие типу существующего объявления. Рассмотрим, например, следующие переменные `у1` и `у2`:
```c++
auto х = ...;
auto y1 = х + 1;

decltype(х) у2 = х + 1;
```
> В зависимости от инициализатора `х`, `y1` может иметь тот же тип, что и `х` (но может и не иметь): это зависит от поведения `+`. Если переменная `х` была выведена как `int`, переменная `y1` также должна быть типа `int`. Если `х` была выведена как `char`, то `y1` должна быть `int`, поскольку сумма `char` и `1` (значение `1` имеет тип `int` по определению) имеет тип `int`. Использование `decltype (х)` в качестве типа `у2` гарантирует, что эта переменная всегда будет иметь тот же тип, что и переменная `х`.
>
> В противном случае, если `е` является некоторым другим выражением, `decltype (е)` дает тип, отражающий тип и категорию значения этого выражения следующим образом.
>	> Если `е` представляет собой [[значение#l-значение|l-значение]] типа `Т`, `decltype (е)` дает тип `Т&`.
>	> Если `е` представляет собой [[значение#x-значения|х-значение]] типа `Т`, `decltype (е)` дает тип `Т&&`.
>	> Если `е` представляет собой [[значение#pr-значения|рr-значение]] типа `Т`, `decltype (е)` дает тип `Т`.

О категориях значений рассказывается в #приложении_Б, “Категории значений”.

Указанные различия могут быть продемонстрированы следующим примером:
```c++
void g(std::string&& s)
{
	// Проверка типа s:
	std::is_lvalue_reference<decltype(s)>::value;   // false
	std::is_rvalue__reference<decltype(s)>::value;  // true
                                                    // (s как объявлено)
	std::is_same<decltype(s), std::string&>::value; // false
	std::is_same<decltype(s), std::string&& >::value; // true

	// Проверка категории значения s, использованного как выражение:
	std::is_lvalue_reference<decltype((s))>::value; // true
													// (s - 1-значение)
	std::is_rvalue_reference<decltype((s))>::value; // false
	std::is_same<decltype((s)),std::string&>::value;// true
											// (T& говорит об l-значении)
	std::is_same<decltype((s)),std::string&&>::value; // false
}
```

В первых четырех выражениях `decltype` применяется к переменной `s`:
```c++
decltype(s) // Объявленный тип сущности е определяется s
```

Это означает, что `decltype` производит объявленный тип `s`, т.е. `std::string&&`. В последних четырех выражениях операнд конструкции `decltype` является не просто именем, потому что в каждом случае выражение представляет собой (`s`), которое является именем в скобках. В этом случае тип будет отражать категорию значения (`s`):
```c++
decltype((s))  // Проверка категории значения (s)
```

Наше выражение ссылается на переменную по имени и, таким образом, является [[значение#l-значение|l-значением]]: согласно приведенным выше правилам, это означает, что `decltype(s)` является обычной ссылкой (т.е. ссылкой на [[значение#l-значение|l-значение]]) на [[string|std::string]] (поскольку тип `(s)` — [[string|std::string]]). Это одно из немногих мест в C++, где скобки меняют смысл программы (помимо воздействия на порядок вычислений операторов).

Тот факт, что `decltype` вычисляет тип произвольного выражения `е`, может оказаться полезным в различных местах. В частности, `decltype (е)` сохраняет достаточно информации о выражении, чтобы сделать возможным точно описать тип возвращаемого значения функции, которая возвращает это выражение `е`: `decltype` вычисляет тип этого выражения, а также передает категорию значения выражения вызывающему данную функцию коду. Рассмотрим простую передающую функцию `g()`, которая возвращает результат вызова `f()`:
```c++
??? f();

decltype(f()) g()
{
	return f();
}
```

Тип возвращаемого значения `g()` зависит от возвращаемого типа `f()`. Если `f()` будет возвращать `int &`, вычисление типа возвращаемого значения `g()` сначала определит, что выражение `f()` имеет тип `int`. Это выражение является [[значение#l-значение|l-значением]], поскольку `f()` возвращает ссылку на [[значение#l-значение|l-значение]], поэтому объявленным возвращаемым типом `g()` становится `int&`. Аналогично, если тип возвращаемого значения `f()` представляет собой ссылку на [[значение#r-значения|r-значение]], то вызов `f()` будет [[значение#x-значения|x-значением]], и `decltype` будет давать тип ссылки на [[значение#r-значения|r-значение]], который точно соответствует типу, возвращаемому `f()`. По существу, эта форма `decltype` принимает основные характеристики произвольного выражения — его тип и категорию значения — и кодирует их в системе типов таким образом, чтобы обеспечить корректную прямую передачу возвращаемого значения.

`decltype` также может быть полезным, когда вывода [[auto|auto]] оказывается недостаточно. Например, предположим, что у нас есть переменная `pos` некоторого неизвестного типа итератора, и мы хотим создать переменную `element`, которая ссылается на элемент, указываемый `pos`. Мы могли бы написать
```c++
auto element = *pos;
```

Однако таким образом всегда будет создаваться копия элемента. Если же мы попытаемся написать
```c++
auto& element = *pos;
```

то мы всегда будем получать ссылку на элемент, но программа завершится ошибкой, если `operator*` итератора возвращает значение, а не ссылку. Для решения этой проблемы можно использовать `decltype`, так что “значимость” или “ссылочность” `operator*` итератора сохраняется:
```c++
decltype(*pos) element = *pos;
```

Этот код будет использовать ссылку, когда итератор поддерживает ее, и копировать значение в противном случае. Его основной недостаток в том, что он требует записи выражения инициализатора дважды: один раз в `decltype` (где выражение не вычисляется) и один раз в качестве фактического инициализатора. C++14 для решения этого вопроса вводит конструкцию [[#decltype(auto) C++14|decltype (auto)]].

# decltype(auto) C++14

Стандарт C++14 добавляет функциональную возможность, которая представляет собой сочетание [[auto|auto]] и [[#Запись типа выражения с помощью decltype|decltype]]: `decltype (auto)`. Подобно спецификатору типа [[auto|auto]], это тип-заместитель, и тип переменной, возвращаемый тип или аргумент шаблона определяется из типа связанного выражения (инициализатора, возвращаемого значения или аргумента шаблона). Однако в отличие от простого [[auto|auto]], который использует правила вывода аргумента шаблона для определения интересующего типа, фактический тип определяется путем применения конструкции [[#Запись типа выражения с помощью decltype|decltype]] непосредственно к выражению. Приведенный далее пример иллюстрирует это:
```c++
int i = 42;             // i имеет тип int
int const& ref = i;     // ref имеет тип int const& и ссылается на i
auto x = ref;           // x имеет тип int и представляет собой
						// новый независимый объект
decltype(auto) у = ref; //у имеет тип int const&
						//и также ссылается на i
```

Тип `у` получается путем применения [[#Запись типа выражения с помощью decltype|decltype]] к выражению инициализатора, здесь — `ref`, которая имеет тип `int const&`. Правила же вывода типа для [[Вывод типа auto|auto]] дают тип `int`.

Еще один пример демонстрирует разницу при индексации [[vector|std::vector]] (дающем [[значение#l-значение|l-значение]]):
```c++
std::vector<int> v = { 42 };
auto x = v[0];                   // x — новый объект типа int
decltype(auto) у = v[0];         // у — ссылка (типа int&)
```

Эта конструкция аккуратно устраняет избыточность в нашем предыдущем примере:
```c++
decltype(*pos) element = *pos;
```

Теперь его можно переписать как
```c++
decltype(auto) element = *pos;
```

Ее часто удобно использовать и для возвращаемых типов. Рассмотрим следующий пример:
```c++
template<typename С> 
class Adapt
{
	С container;

	...


	decltype(auto) operator[](std::size_t idx)
	{
		return container[idx];
	}
};
```

Если `container[idx]` дает [[значение#l-значение|l-значение]], мы хотим передать его вызывающему коду как [[значение#l-значение|l-значение]] (кто-то может захотеть получить его адрес или изменить его). Это требует тип ссылки на [[значение#l-значение|l-значение]], в который разрешается конструкция `decltype (auto)`. Если же вместо этого получается [[значение|pr-значение]], ссылочный тип приведет к висячим ссылкам, — но, к счастью, для этого случая `decltype (auto)` будет давать тип объекта (а не ссылочный тип).

В отличие от [[auto|auto]], `decltype (auto)` не допускает спецификаторы или операторы, которые модифицируют выводимый тип. Например:
```c++
decltype(auto)* р = (void*)nullptr; // Неверно
int const N = 100;
decltype(auto) const NN = N * N;    // Неверно
```

Обратите также внимание на то, что скобки в инициализаторе могут быть значимыми ([[Семантика перемещения - Прямая передача|поскольку они являются существенными]] для конструкции [[decltуре#decltype C++11|decltype]]):
```c++
int х;

decltype(auto) z = х;      // Объект типа int
decltype(auto) r = (х);    // Ссылка типа int&
```

Эго, в частности, означает, что скобки могут иметь серьезное влияние на корректность операторов `return`:
```c++
int g();

...

decltype(auto) f()
{
	int r = g();
	return (r);      // Ошибка времени выполнения; возврат
}                    // ссылки на временную переменную
```

Начиная с C++17, `decltype (auto)` может также использоваться для [[Вывод аргументов шаблона#Спецификатор типа auto|выводимых параметров, не являющихся типами]]. Это проиллюстрировано в приведенном ниже примере:
```c++
template<decltype(auto) Val> class S
{
	...
};

constexpr int c = 42;
extern int v = 42;

S<c> sc;                  // #1 создает S<42>
S<(v)> sv;                // #2 создает S<(int&)v>
```

В строке `#1` отсутствие скобок вокруг `с` приводит к тому, что выводимый параметр имеет тип самого `с` (т.е. `int`). Поскольку `с` является константным выражением со значением 42, это эквивалентно `S<42>`. В строке `#2` скобки приводят к тому, что `decltype (auto)` становится ссылкой типа `int&`, которую можно связать с глобальной переменной `v` типа `int`. Следовательно, при таком объявлении [[Обобщенные библиотеки#Ссылки в качестве параметров шаблонов|шаблон класса зависит от ссылки на v]], и любые изменения значения `v` могут повлиять на поведение класса `S`. (`S<v>` без скобок будет ошибкой, поскольку `decltype (v)` имеет тип `int`, и поэтому ожидается константный аргумент типа `int`. Однако `v` не имеет константного значения типа `int`.)

Обратите внимание на то, что природа этих двух случаев несколько отличается. Мы считаем, что такие параметры шаблона, не являющиеся типами, могут привести к сюрпризам в поведении, и не думаем, что они будут широко использоваться.

Наконец, небольшой комментарий об использовании выводимых параметров, не являющихся типами, в шаблонах функций:
```c++
template<auto N> struct S {};

template<auto N> int f(S<N> p);

S<42> x;
int r = f(x);
```

В этом примере тип параметра `N` шаблона функции `f<>()` выводится из типа параметра `S`, не являющегося типом. Это возможно, поскольку имя вида `Х<...>`, где `X` является шаблоном класса, представляет собой выводимый контекст. Однако есть также много схем, которые не могут быть выведены таким образом:
```c++
template<auto V> 
int deduce(decltype(V) p);

int r1 = deduce<42>(42);    // OK
int r2 = deduce(42);        // Ошибка: decltype(V) является
							// невыводимым контекстом
```

В этом случае `decltype(V)` является невыводимым контекстом: отсутствует уникальное значение `V`, которое соответствует аргументу `42` (например, `decltype(7)` производит тот же тип, что и `decltype(42)`). Таким образом, чтобы иметь возможность вызывать эту функцию, следует явно указать параметр шаблона, не являющийся типом.

