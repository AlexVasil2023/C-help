# Отличие универсальных ссылок от rvalue-ссылок

Говорят, что истина делает нас свободными, но при соответствующих обстоятельствах хорошо выбранная ложь может оказаться столь же освобождающей. Этот раздел и есть такой ложью. Но поскольку мы имеем дело с программным обеспечением, давайте избегать слова "ложь': а вместо него говорить, что данный раздел содержит "абстракцию".

Чтобы объявить [[rvalue|rvalue-ссылку]] на некоторый тип `Т`, вы пишете `Т&&`. Таким образом представляется разумным предположить, что если вы видите в исходном тексте `Т&&`, то имеете дело с [[rvalue|rvalue-ссылками]]. Увы, не все так просто.

```c++
void f(Widget&& param);                 // rvalue - ccылкa

Widget&& var1 = Widget();               // rvalue - ccылкa

auto&& var2 = var1;                     // Не rvalue - ccылкa

template<typename Т>
void f(std::vector<T>&& param);        // rvalue - ccылкa

template<typename Т>
void f(T&& param);                     // Не rvalue - ccылкa
```

На самом деле `"T&&"` имеет два разных значения. Одно из них - конечно, [[rvalue|rvalue-ссылка]]. Такие ссылки ведут себя именно так, как вы ожидаете: они связываются только с [[rvalue|rvalue]] и их смысл заключается в идентификации объектов, которые могут быть перемещены.

Другое значение "Т&& " либо [[rvalue|rvalue-ссылка, либо rvalue-ссылка]]. Такие ссылки выглядят в исходном тексте как [[rvalue|rvalue-ссылки]] (т.е. `"T&&"`), но могут вести себя так, как если бы они были [[rvalue|rvalue-ссылками]] (т.е. `"T&"`). Такая дуальная природа позволяет им быть связанными как с [[rvalue|rvalue]] (подобно [[rvalue|rvalue-ссылкам]]), так и с [[rvalue|lvalue]] (подобно [[rvalue|rvalue-ссылкам]]). Кроме того, они могут быть связаны как с константными, так и с неконстантными объектами, как с объектами [[volatile|volatile]], так и с объектами, не являющимися [[volatile|volatile]], и даже с объектами, одновременно являющимися и [[const|const]], и [[volatile|volatile]]. Они могут быть связаны практически со всем. Такие беспрецедентно гибкие ссылки заслуживают собственного имени, и я называю их универсальными ссылками.

Универсальные ссылки возникают в двух контекстах. Наиболее распространенным являются параметры шаблона функции, такие как в приведенном выше примере кода:

```c++
template<typename Т>
void f(Т&& param);                      // param - универсальная ссылка
```

Вторым контекстом являются объявления [[auto|auto]], включая объявление из приведенного выше примера кода:

```c++
auto&& var2 = var1;                     // var2 - универсальная ссылка
```

Общее в этих контекстах - наличие вывода типа. В шаблоне `f` выводится тип `param`, а в объявлении `var2` выводится тип переменной `var2`. Сравните это с приведенными далее примерами (также взятыми из приведенного выше примера кода), в которых вывод типа отсутствует. Если вы видите `"T&&"` без вывода типа, то вы смотрите на [[rvalue|rvalue-ссылку]]:

```c++
void f(Widget&& param);                 // Вывод типа отсутствует;
										// param - rvalue-ccылкa

Widget&& var1 = Widget();               // Вывод типа отсутствует
										// var1 - rvalue-ccьшкa
```

Поскольку универсальные ссылки являются ссылками, они должны быть инициализированы. Инициализатор универсальной ссылки определяет, какую ссылку она представляет: [[rvalue|lvalue-ссылку или rvalue-ссылку]]. Если инициализатор представляет собой [[rvalue|rvаluе]], универсальная ссылка соответствует [[rvalue|rvalue-ссылке]]. Если же инициализатор является [[rvalue|lvаluе]], универсальная ссылка соответствует [[rvalue|lvalue-ссылке]]. Для универсальных ссылок, которые являются параметрами функций, инициализатор предоставляется в месте вызова:

```c++
template<typename Т>
void f (T&& param);                // param является универсальной ссылкой

Widget w;
f(W);                              // В f передается lvalue; тип param -
								   // Widget& (т.е. lvalue - ccылкa)

f(std::move(w));                   // В f передается rvalue; тип param -
								   // Widget&& (т.е. rvalue-ccыпкa)
```

Чтобы ссылка была универсальной, вывод типа необходим, но не достаточен. Вид объявления ссылки также должен быть корректным, и этот вид достаточно ограничен. Он должен в точности имеет вид `"T&&"`: Взглянем еще раз на пример, который мы уже рассматривали ранее:

```c++
template<typename Т>
void f(std::vector<T>&& param);            // param - rvalue - ccылкa
```
Когда вызывается `f`, тип `T` выводится (если только вызывающий код явно его не укажет, но этот крайний случай мы не рассматриваем). Однако объявление типа `param` не имеет вида `"T&&"`; оно представляет собой `std::vector<T>&&`. Это исключает возможность для `param` быть универсальной ссылкой. Следовательно, `param` является [[rvalue|rvalue-ссылкой]], что ваши компиляторы с удовольствием подтвердят при попытке передать в функцию `f` [[lvalue|lvalue]]:

```c++
std::vector<int> v;
f(V);                               // Ошибка! Невозможно связать lvalue
                                    // с rvаluе - ссылкой
```

Если вы находитесь в шаблоне и видите параметр функции с типом `"T&&"`: вы можете решить, что перед вами универсальная ссылка. Но вы не должны этого делать, поскольку размещение в шаблоне не гарантирует наличие вывода типа. Рассмотрим следующую функцию-член [[push_back|push_back]] в [[vector|std::vector]]:

```c++
template<class Т,
	class Allocator = allocator<T>>        // Из стандарта С++

class vector{
	public:
		void push_back(T&& х);
};
```
Параметр [[push_back|push_back]], определенно, имеет верный для универсальной ссылки вид, но в данном случае вывода типа нет. Дело в том, что [[push_back|push_back]] не может существовать без конкретного инстанцированного вектора, частью которого он является; а тип этого инстанцирования полностью определяет объявление [[push_back|push_back]]. Другими словами, код

```c++
std::vector<Widget> v;
```

приводит к следующему инстанцированию шаблона [[vector|std::vector]]:

```c++
class vector<Widget, allocator<Widget>> {
	public:
		void push_back (Widget&& х);       // rvalue - ccьmкa
};
```

Теперь вы можете ясно видеть, что [[push_back|push_back]] не использует вывода типа. Эта функция для `vector<T>` (их две - данная функция перегружена) всегда объявляет параметр типа "rvalue-ccылкa на `T`".

В противоположность этому концептуально подобная функция-член [[emplace_back|emplace_back]] в [[vector|std::vector]] выполняет вывод типа:
```c++
template<class Т,
	class Allocator = allocator<T>>          // Из стандарта С++
class vector {
	public:
		template <class ... Args>
		void emplace_back(Args&& ... args);
};
```
Здесь параметр типа `Args` не зависит от параметра типа вектора `Т`, так что `Args` должен выводиться при каждом вызове [[emplace_back|emplace_back]]. (Да, в действительности `Args` представляет собой набор параметров, а не параметр типа, но для нашего рассмотрения его можно рассматривать как параметр типа.)

Тот факт, что параметр типа [[emplace_back|emplace_back]] имеет имя `Args` и является при этом универсальным указателем, только усиливает мое замечание о том, что универсальная ссылка обязана иметь вид `"Т&&"`: Вы не обязаны использовать в качестве имени `T`. Например, приведенный далее шаблон принимает универсальную ссылку, поскольку она имеет правильный вид (`"type&&"`), а тип `param` выводится (опять же, исключая крайний случай, когда вызывающий код явно указывает тип):

```c++
template<typename MyTemplateType>           // param является
void someFunc(МyТemplateТype&& param);      // универсальной ссылкой
```

Ранее я отмечал, что переменные [[auto|auto]] также могут быть универсальными ссылками. Чтобы быть более точным, переменные, объявленные с типом `auto&&`, являются универсальными ссылками, поскольку имеет место вывод типа и они имеют правильный вид (`"Т&&"`) . Универсальные ссылки [[auto|auto]] не так распространены, как универсальные ссылки, используемые в качестве параметров шаблонов функций, но они также время от времени возникают в C++11. Гораздо чаще они возникают в C++14, поскольку лямбда-выражения
С++14 могут объявлять параметры `auto&&`. Например, если вы хотите написать лямбда-выражение С++14 для записи времени, которое занимает вызов произвольной функции, можете сделать это следующим образом:

```c++
auto timeFuncinvocation =
	[] (auto&& func, auto&& ... params)             // С++14
{
//Запуск таймера ;
std::forward<decltype(func)>(func) (                  // Вызов func
	std::forward<decltype(params)>(params) ...        // с params
);
// Останов таймера и запись времени;
);
```

Если ваша реакция на код `"std::forward<decltype(ля-ля-ля)>"` внутри лямбда-выражения - "Что за @#$%?!!'; то [[Lambda#Лямбда-функции (лямбда-выражения) C++11|см.]]. Не беспокойтесь о нем. Главное для нас сейчас в этом лямбда-выражении - объявленные как `auto&&` параметры `func` является универсальной ссылкой, которая может быть связана с любым вызываемым объектом, как [[rvalue|lvalue]], так и [[rvalue|rvalue]]. `params` представляет собой нуль или несколько универсальных ссылок (т.е. набор параметров, являющихся универсальными ссылками), которые могут быть связаны с любым количеством объектов произвольных типов. В результате, благодаря универсальным ссылкам [[auto|auto]], лямбда-выражение `timeFuncinvocation` в состоянии записать время работы почти любого выполнения функции. (Чтобы разобраться в разнице между "любого" и "почти любого" [[Познакомьтесь с случаями некорректной работы прямой передачи|см.]])

Имейте в виду, что весь этот раздел - основы универсальных ссылок - является лож . . . простите, абстракцией. Лежащая в основе истина, известная как свертывание ссылок (reference collapsing), является темой [[Свертывание ссылок|раздела]]. Но истина не делает абстракцию менее полезной. Понимание различий между [[rvalue|rvalue-ссылками]] и универсальными ссылками поможет вам читать исходные тексты более точно (`"Этот Т&& связывается только с rvalue или с чем утодно?"`), а также избегать неоднозначностей при общении с коллегами ("Здесь я использовал универсальную ссылку, а не rvalue-ccылкy. . ."). Оно также поможет вам в понимании смысла [[Использование move и forward|раздела]] и [[Избегайте перегрузок для универсальных ссылок|раздела]], которые опираются на указанное различие. Так что примите эту абстракцию, погрузитесь в нее . . . Так же как законы Ньютона (технически не совсем корректные) обычно куда полезнее и проще общей теории относительности Эйнштейна ("истины"), так и понятие универсальных ссылок обычно предпочтительнее для работы, чем детальная информация о свертывании ссылок.

> - Если параметр шаблона функции имеет тип `T&&` для выводимого типа `Т` или если объект объявлен с использованием `auto&&`, то параметр или объект является универсальной ссылкой.
> 
> - Если вид объявления типа не является в точности `tуре&&` или если вывод типа не имеет места, то `tуре&&` означает [[rvalue|rvalue-ccылкy]].
> 
> - Универсальные ссылки соответствуют [[rvalue|rvalue-ссылкам]], если они инициализируются значениями [[rvalue|rvаluе]]. Они соответствуют [[rvalue|lvalue-ссылкам]], если они инициализируются значениями [[rvalue|lvalue]].

