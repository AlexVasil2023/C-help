# Динамическая загрузка компонентов

Самый простой способ динамической загрузки различных частей QML - это использование элемента `Loader`. Он служит в качестве заполнителя загружаемого элемента. Управление загружаемым элементом осуществляется либо через свойство `source`, либо через свойство `sourceComponent`. В первом случае элемент загружается с заданного URL, а во втором - инстанцируется компонент .

Так как загрузчик служит заполнителем для загружаемого элемента, его размер зависит от размера элемента, и наоборот. Если элемент `Loader` имеет размер, либо заданный шириной и высотой , либо привязанный, то загружаемому элементу будет присвоен размер загрузчика. Если загрузчик не имеет размера, то его размер изменяется в соответствии с размером загружаемого элемента.

Описанный ниже пример демонстрирует, как две отдельные части пользовательского интерфейса могут быть загружены в одно пространство с помощью элемента `Loader`. Идея состоит в том, чтобы иметь быстрый набор номера, который может быть как цифровым, так и аналоговым, как показано на рисунке ниже. Код, окружающий циферблат, не зависит от того, какой элемент загружен в данный
момент.

![[QML Load.png]]

![[QML Load_2.png]]

Первым шагом в приложении является объявление элемента `Loader`. Обратите внимание, что свойство `source` оставлено без внимания. Это связано с тем, что источник зависит от того, в каком состоянии находится пользовательский интерфейс.

```c++
Loader {
	id: dialLoader
	anchors.fill: parent
}
```

В свойстве `states` родителя `dialLoader` набор элементов `PropertyChanges` управляет загрузкой различных QML-файлов в зависимости от состояния . Свойство `source` в данном примере представляет собой относительный путь к файлу, но с тем же успехом это может быть и полный URL, получающий элемент через Интернет.

```c++
states: [
	State {
		name: "analog"
		PropertyChanges { target: analogButton; color: "green";
		PropertyChanges { target: dialLoader; source: "Analog.q
	},
	State {
		name: "digital"
		PropertyChanges { target: digitalButton; color: "green"
		PropertyChanges { target: dialLoader; source: "Digital.
	}
]
```

Для того чтобы загруженный элемент ожил, его свойство скорости должно быть привязано к свойству скорости корня. Это невозможно сделать прямым связыванием, поскольку элемент не всегда загружен и изменяется со временем. Вместо этого необходимо использовать элемент [[Binding|Binding]] . Свойство `target` этой привязки изменяется каждый раз, когда `Loader` срабатывает по сигналу `onLoaded`.

```c++
Loader {
	id: dialLoader
	anchors.left: parent.left
	anchors.right: parent.right
	anchors.top: parent.top
	anchors.bottom: analogButton.top
	
	onLoaded: {
		binder.target = dialLoader.item;
	}
}

Binding {
	id: binder
	property: "speed"
	value: root.speed
}
```

Сигнал `onLoaded` позволяет загружаемому QML действовать, когда элемент загружен. Аналогичным образом загружаемый QML может полагаться на сигнал `Component.onCompleted` . Этот сигнал фактически доступен для всех компонентов, независимо от способа их загрузки. Например, корневой компонент всего приложения может использовать его для самозапуска после загрузки всего пользовательского интерфейса.

## Косвенное подключение

При динамическом создании QML-элементов нельзя подключаться к сигналам, используя подход `onSignalName`, применяемый при статической настройке. Вместо этого необходимо использовать элемент `Connections` . Он подключается к любому количеству сигналов целевого элемента.

Установив целевое свойство элемента `Connections`, можно подключать сигналы, как обычно, то есть используя подход `onSignalName`. Однако, изменяя свойство `target`,можно контролировать разные элементы в разное время.

![[QML Load_3.png]]

В приведенном примере пользователю представлен интерфейс, состоящий из двух областей, на которые можно нажать. При нажатии на одну из областей она мигает с помощью анимации. Левая область показана в приведенном ниже фрагменте кода. В области `MouseArea` срабатывает анимация **`leftClickedAnimation`** , в результате чего область начинает мигать.

```C++
Rectangle {
	id: leftRectangle
	width: 290
	height: 200
	color: "green"
	
	MouseArea {
		id: leftMouseArea
		anchors.fill: parent
		onClicked: leftClickedAnimation.start()
	}
	
	Text {
		anchors.centerIn: parent
		font.pixelSize: 30
		color: "white"
		text: "Click me!"
		}
}
```

В дополнение к двум щелкаемым областям используется элемент `Connections` . Он запускает третью анимацию при нажатии на активный, т.е. целевой , элемент.

```C++
Connections {
	id: connections
	function onClicked() { activeClickedAnimation.start() }
}
```

Для определения целевой области [[MouseArea|MouseArea]] определяются два состояния. Обратите внимание, что мы не можем установить свойство `target` с помощью элемента `PropertyChanges`, поскольку он уже содержит свойство `target` . Вместо этого используется сценарий `StateChangeScript` 

```C++
states: [
	State {
		name: "left"
		StateChangeScript {
			script: connections.target = leftMouseArea
		}
	},
	State {
		name: "right"
		StateChangeScript {
			script: connections.target = rightMouseArea
		}
	}
]
```

При отработке примера следует обратить внимание на то, что при использовании нескольких обработчиков сигналов вызываются все. Однако порядок их выполнения не определен.

При создании элемента `Connections` без установки свойства `target` это свойство по умолчанию принимает значение `parent`. Это означает, что оно должно быть явно установлено в `null`, чтобы не перехватывать сигналы от родителя до тех пор, пока не будет установлена цель. Такое поведение делает возможным создание пользовательских компонент обработчика сигналов на основе элемента `Connections`. Таким образом, код, реагирующий на сигналы, может быть инкапсулирован и использован повторно.

В приведенном ниже примере компонент `Flasher` может быть помещен внутрь любой `MouseArea`. При нажатии он запускает анимацию, заставляя родительскую область мигать. В той же [[MouseArea|MouseArea]] может выполняться и собственно запускаемая задача. Таким образом, стандартная обратная связь с пользователем, т.е. мигание, отделяется от фактического действия.

```C++
import QtQuick

Connections {
	function onClicked() {
		// Automatically targets the parent
	}
}
```

Чтобы использовать `Flasher`, достаточно инстанцировать `Flasher` в каждой [[MouseArea|MouseArea]], и все заработает.

```C++
import QtQuick

Item {
	// A background flasher that flashes the background of any
}
```

При использовании элемента `Connections` для мониторинга сигналов нескольких типов целевых элементов иногда возникает ситуация, когда доступные сигналы различаются между целевыми элементами. Это приводит к тому, что элемент `Connections` выдает ошибки времени выполнения, поскольку сигналы пропущены. Чтобы избежать этого, свойству `ignoreUnknownSignal` можно присвоить значение `true`.При этом все подобные ошибки будут игнорироваться.

> Подавлять сообщения об ошибках, как правило, не рекомендуется, и если вы это делаете, не забудьте указать причину в комментарии.

## Косвенное связывание

Как нельзя напрямую подключиться к сигналам динамически создаваемых элементов, так и нельзя связать свойства динамически создаваемого элемента без работы с элементом `bridge`. Для связывания свойства любого элемента, в том числе и динамически создаваемого, используется элемент [[Binding|Binding]].

Элемент [[Binding|Binding]] позволяет указать целевой элемент, свойство для связывания и значение для привязки. С помощью элемента [[Binding|Binding]] можно, например, связать свойства динамически загружаемого элемента, что было продемонстрировано выше и как показано ниже.

```c++
Loader {
	id: dialLoader
	anchors.left: parent.left
	anchors.right: parent.right
	anchors.top: parent.top
	anchors.bottom: analogButton.top
	
	onLoaded: {
		binder.target = dialLoader.item;
	}
}

Binding {
	id: binder
	property: "speed"
	value: root.speed
}
```

Поскольку целевой элемент привязки не всегда задан и, возможно, не всегда имеет заданное свойство, свойство `when` элемента привязки может быть использовано для ограничения времени, в течение которого привязка активна. Например, она может быть ограничена определенными режимами в пользовательском интерфейсе.

Элемент [[Binding|Binding]] также имеет свойство `delayed` . Когда это свойство установлено в `true`, привязка не будет передана цели до тех пор, пока очередь событий не будет опустошена. В ситуациях с высокой нагрузкой это может служить оптимизацией, поскольку промежуточные значения не передаются целевому объекту 












