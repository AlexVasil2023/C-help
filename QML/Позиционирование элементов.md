# Позиционирование элементов
Существует ряд QML-элементов, используемых для позиционирования элементов. Они называются позиционерами, из которых модуль Qt Quick предоставляет следующие: `Row`, `Column`, `Grid` и `Flow`. На рисунке ниже можно увидеть, как они отображают одно и то же содержимое.
> Прежде чем перейти к деталям, позвольте представить некоторые вспомогательные элементы: красный, синий, зеленый, более светлый и более темный квадраты. Каждый из этих компонентов содержит раскрашенный прямоугольник размером 48x48 пикселей. В качестве справочного материала здесь приведен исходный код квадрата `RedSquare`:
```c++
// RedSquare.qml
import QtQuick

Rectangle {
	width: 48
	height: 48
	color: "#ea7025"
	border.color: Qt.lighter(color)
}
```

Обратите внимание на использование `Qt.lighter(color)` для получения более светлого цвета границы на основе цвета заливки. Мы будем использовать эти помощники в следующих примерах, чтобы сделать исходный код более компактным и читабельным. Помните, что каждый прямоугольник изначально имеет размер 48x48 пикселей.
Элемент `Column` организует дочерние элементы в колонку, укладывая их друг на друга.  Свойство `spacing` может быть использовано для расстояния между дочерними элементами.

![[QML Example.png]]
```c++
// ColumnExample.qml
import QtQuick
DarkSquare {
	id: root
	width: 120
	height: 240
	
	Column {
		id: column
		anchors.centerIn: parent
		spacing: 8
		RedSquare { }
		GreenSquare { width: 96 }
		BlueSquare { }
	}
}
```

Элемент `Row` размещает свои дочерние элементы рядом друг с другом, либо слева направо, либо справа налево, в зависимости от свойства `layoutDirection`. Для разделения дочерних элементов снова используется интервал.
![[QML Example_Row.png]]
```c++
// RowExample.qml
import QtQuick
BrightSquare {
	id: root
	width: 400; height: 120
	
	Row {
		id: row
		anchors.centerIn: parent
		spacing: 20
		
		BlueSquare { }
		GreenSquare { }
		RedSquare { }
	}
}
```
Элемент `Grid` располагает свои дочерние элементы в виде сетки. Задавая свойства `rows` и `columns`, можно ограничить количество строк или столбцов. Если не задавать ни одно из них, то другое вычисляется из количества дочерних элементов. Например, если установить значение `rows` равным 3 и добавить 6 дочерних элементов, то получится 2 столбца. Свойства `flow` и `layoutDirection` используются для управления порядком расположения элементов добавляется в сетку, а `spacing` управляет количеством  пространства, разделяющего дочерние элементы.
![[QML Example_flow.png]]
```c++
// GridExample.qml
import QtQuick

BrightSquare {
	id: root
	width: 160
	height: 160
		
	Grid {
		id: grid
		rows: 2
		columns: 2
		anchors.centerIn: parent spacing: 8

		RedSquare { }
		RedSquare { }
		RedSquare { }
		RedSquare { }
	}
}
```
Последним позиционером является `Flow`. Он добавляет свои дочерние элементы в поток. Направление потока контролируется с помощью параметров `flow` и `layoutDirection`. Он может идти сбоку или сверху вниз. Он также может идти слева направо или в противоположном направлении. По мере добавления элементов в поток они заворачиваются, образуя при необходимости новые строки или столбцы. Для того чтобы поток работал, он должен иметь ширину или высоту. Они могут быть заданы как непосредственно, так и с помощью макетов якорей.
![[QML_FLOW_2.png]]
```c++
// FlowExample.qml
import QtQuick

BrightSquare {
	id: root
	width: 160
	height: 160
	
	Flow {
		anchors.fill: parent
		anchors.margins: 20
		spacing: 20
		
		RedSquare { }
		BlueSquare { }
		GreenSquare { }
	}
}
```
Элементом, часто используемым с позиционерами, является повторитель (`Repeater`) . Он работает как цикл `for` и выполняет итерации по модели. В простейшем случае модель - это просто значение, задающее количество циклов.
![[QML_Example.png]]
```c++
// RepeaterExample.qml
import QtQuick

DarkSquare {
	id: root
	width: 252
	height: 252
	
	property variant colorArray: ["#00bde3", "#67c111", "#ea702]
	
	Grid{
		anchors.fill: parent
		anchors.margins: 8
		spacing: 4
		
		Repeater {
			model: 16
			
			delegate: Rectangle {
				required property int index
				property int colorIndex: Math.floor(Math.random()*3]
				
				width: 56; height: 56
				color: root.colorArray[colorIndex]
				border.color: Qt.lighter(color)
				
				Text {
					anchors.centerIn: parent
					color: "#f0f0f0"
					text: "Cell " + parent.index
				}
			}
		}
	}
}
```
В этом примере ретранслятора мы используем новую магию. Мы определяем собственное свойство `colorArray` , которое представляет собой массив цветов. Повторитель создает серию прямоугольников (16, как определено в модели). Для каждого цикла он создает
прямоугольник, определенный дочерним свойством ретранслятора. В прямоугольнике мы выбираем цвет с помощью математических функций JS: `Math.floor(Math.random()*3)`. Это дает нам случайное число в диапазоне от `0...2`, которое мы используем для выбора цвета
из нашего массива цветов. Как уже отмечалось, JavaScript является основной частью Qt Quick, и поэтому нам доступны стандартные библиотеки.
В ретранслятор вводится свойство `index`. Оно содержит текущий индекс цикла. (0,1,..15). Мы можем использовать его для принятия собственных решений на основе индекса или, в нашем случае, для визуализации текущего индекса с помощью элемента `Text`.
> Хотя свойство `index` динамически вводится в `Rectangle`, для облегчения читаемости и помощи в работе с инструментами рекомендуется объявлять его как обязательное свойство. Для этого используется обязательное свойство `int index` line.

> Ретрансляторы лучше всего использовать при небольшом количестве статических данных, которые необходимо представить.




















