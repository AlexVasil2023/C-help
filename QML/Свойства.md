# Свойства
Элементы объявляются с помощью имени элемента, а определяются с помощью его свойств или путем создания собственных свойств. **Свойство** - это простая пара ключ-значение, например: `width: 100`, `text: 'Greetings'` , `color: '#FF0000'` . Свойство имеет четко определенный тип и может иметь начальное значение.
```c++
Text {
	// (1) identifier
	id: thisLabel
	
	// (2) set x- and y-position
	x: 24; y: 16
	
	// (3) bind height to 2 * width
	height: 2 * width
	
	// (4) custom property
	property int times: 24
	
	// (5) property alias
	property alias anotherTimes: thisLabel.times
	
	// (6) set text appended by value
	text: "Greetings " + times
	
	// (7) font is a grouped property
	font.family: "Ubuntu"
	font.pixelSize: 24
	
	// (8) KeyNavigation is an attached property
	KeyNavigation.tab: otherLabel
	
	// (9) signal handler for property changes
	onHeightChanged: console.log('height:', height)
	
	// focus is need to receive key events
	focus: true
	
	// change color based on focus value
	color: focus ? "red" : "black"
}
```
Рассмотрим различные особенности свойств:
* **(1)** `id` - это очень специальное свойство-значение, которое используется для ссылки на элементы внутри QML-файла (в **QML** он называется "документ"). `id` - это не строковый тип, а идентификатор и часть синтаксиса QML. `id` должен быть уникальным внутри документа, и его нельзя сбросить в другое значение, а также нельзя запросить (он ведет себя подобно ссылке в C++).
* **(2)** Свойство может быть установлено в значение, зависящее от его типа. Если для свойства не задано значение, то будет выбрано начальное значение. Для получения дополнительной информации о начальном значении свойства необходимо обратиться к документации конкретного элемента.
* **(3)** Свойство может зависеть от одного или многих других свойств. Это называется связыванием. Связанное свойство обновляется при изменении зависимых свойств. Это работает как контракт, в данном случае высота всегда должна быть в два раза больше ширины.
* **(4)** Добавление новых свойств к элементу осуществляется с помощью квалификатора `property` , за которым следуют тип, имя и необязательное начальное значение ( `property <type> <name> : <value>`). Если начальное значение не указано, то выбирается начальное значение по умолчанию.
* **(5)** Другим важным способом объявления свойств является использование ключевого слова `alias` ( `property alias <имя>: <ссылка>`). Ключевое слово `alias` позволяет переслать свойство объекта или сам объект изнутри типа во внешнюю область видимости. Этот прием мы будем использовать позже при определении компонентов для экспорта внутренних свойств или идентификаторов элементов на корневой уровень. Псевдоним свойства не нуждается в типе, он использует тип ссылаемого свойства или объекта.
* **(6)** Свойство `text` зависит от пользовательского свойства `times` типа `int`. Значение типа `int` автоматически преобразуется в строковый тип. Само выражение является еще одним примером связывания и приводит к тому, что текст обновляется каждый раз, когда изменяется свойство `times`.
* **(7)** Некоторые свойства являются сгруппированными свойствами. Это свойство используется, когда свойство является более структурированным и связанные свойства должны быть сгруппированы вместе. Другой способ записи сгруппированных свойств - `font { family: "Ubuntu"; pixelSize: 24 }`.
* **(8)** Некоторые свойства принадлежат самому классу элемента. Это делается для элементов глобальных настроек, которые появляются в приложении только один раз (например, ввод с клавиатуры). Запись имеет вид `<Element>.<property>: <value>`.
* **(9)** Для каждого свойства можно предоставить обработчик сигнала. Этот обработчик вызывается после изменения свойства. Например, здесь мы хотим получать уведомление при изменении высоты и использовать встроенную консоль для вывода сообщения в систему.

> Можно также объявить одно свойство свойством по умолчанию, используя ключевое слово `default`. Если внутри элемента создается другой элемент, не привязанный явно к какому-либо свойству, то он привязывается к свойству по умолчанию. Например, это используется при добавлении дочернего элемента `elements`. Дочерние элементы автоматически добавляются в список свойств типа `children` по умолчанию, если они являются видимыми элементами.

