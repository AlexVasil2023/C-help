# Основные элементы
Элементы можно разделить на визуальные и невизуальные. Визуальный элемент (например, `Rectangle` ) имеет геометрию и обычно представляет собой область на экране. Невизуальный элемент (например, `таймер`) обеспечивает общую функциональность,
обычно используемую для манипулирования визуальными элементами.
В настоящее время мы сосредоточимся на основных визуальных элементах, таких как
`Item`, `Rectangle`, `Text`, `Image` и `MouseArea`. Однако, используя модуль Qt Quick Controls 2, можно создавать пользовательские интерфейсы, построенные из стандартных компонентов платформы, таких как кнопки, ярлыки и ползунки.
## Элемент
`Item` является базовым элементом для всех визуальных элементов, поэтому все остальные визуальные элементы наследуются от `Item`. Сам по себе он ничего не рисует, но определяет все свойства, которые являются общими для всех визуальных элементов:
* **Геометрия** - `x` и `y` для определения верхне-левого положения, `ширина` и `высота` для расширения элемента, и `z` для порядка укладки, чтобы поднять или опустить элементы вверх или вниз от их естественного порядка.
* **Работа с макетом** - `якоря` (левый, правый, верхний, нижний, вертикальный и горизонтальный центр) для позиционирования элементов относительно других элементов с необязательными полями.
* **Работа с клавишами** - подключены свойства `Key` и `KeyNavigation` для управления работой с клавишами, а также свойство `focus` для включения работы с клавишами в первую очередь.
* **Трансформация** - преобразование масштаба и поворота и общее преобразование список свойств `transform` для преобразования `x`,`y`,`z`, а также `transformOrigin` point.
* **Визуальные** - `opacity` для управления прозрачностью, `visible` для отображения/скрытия элементов, `clip` для ограничения операций рисования границами элементов и `smooth` для улучшения качества рендеринга.
* **Определение состояния** - свойство списка состояний с поддерживаемым списком состояний, свойство текущего состояния и свойство списка переходов для анимации изменений состояния.
## Прямоугольный элемент
`Rectangle` расширяет `Item` и добавляет ему цвет заливки. Кроме того, он поддерживает границы, определяемые `border.color` и `border.width`. Для создания закругленных  прямоугольников можно использовать свойство `radius` .
```c++
Rectangle {
	id: rect1
	x: 12; y: 12
	width: 76; height: 96
	color: "lightsteelblue"
}

Rectangle {
	id: rect2
	x: 112; y: 12
	width: 76; height: 96
	border.color: "lightsteelblue"
	border.width: 4
	radius: 8
}
```
> Допустимыми значениями цвета являются цвета из имен цветов SVG. Цвета в QML можно задавать различными способами, но наиболее распространенным способом является строка RGB ('#FF4444') или имя цвета (например, 'white').

Помимо цвета заливки и границы, прямоугольник также поддерживает пользовательские градиенты:
```c++
Rectangle {
	id: rect1
	x: 12; y: 12
	width: 176; height: 96
	
	gradient: Gradient {
		GradientStop { position: 0.0; color: "lightsteelblue" }
		GradientStop { position: 1.0; color: "slategray" }
	}
	
	border.color: "slategray"
}
```
Градиент определяется серией градиентных остановок. Каждая остановка имеет позицию и цвет. Позиция обозначает положение на оси **y** (0 = верх, 1 = низ). Цвет остановки градиента  обозначает цвет в данной позиции.

> Прямоугольник, у которого не заданы **ширина/высота**, не будет виден. Такое часто случается, когда несколько прямоугольников по ширине (высоте) зависят друг от друга и что-то пошло не так в логике композиции. Так что будьте внимательны!

> Создать градиент под углом не представляется возможным. Для этого лучше использовать предопределенные изображения. Один из вариантов - просто повернуть прямоугольник с градиентом, но следует помнить, что геометрия повернутого прямоугольника не изменится, что приведет к путанице, поскольку геометрия элемента не совпадает с видимой областью. В этом  случае действительно лучше использовать проектные градиентные изображения.

## Текстовый элемент
Для отображения текста можно использовать элемент `Text`. Его наиболее заметным  свойством является свойство `text` типа `string`. Элемент вычисляет свои начальные ширину и высоту в зависимости от заданного текста и используемого шрифта. На шрифт можно влиять с помощью группы свойств `font` (например, `font.family`, `font.pixelSize`, ...). Для изменения цвета текста достаточно использовать свойство `color`.
```c++
Text {
	text: "The quick brown fox"
	color: "#303030"
	font.family: "Ubuntu"
	font.pixelSize: 28
}
```
Текст может быть выровнен по сторонам и по центру с помощью свойств `horizontalAlignment` и `verticalAlignment` . Для дополнительного улучшения визуализации текста можно использовать свойства `style` и `styleColor`, которые позволяют визуализировать текст в контурном, рельефном и утопленном виде. Для длинного текста часто требуется определить позицию разрыва, например, для очень длинного текста это можно сделать с помощью свойства `elide`. Свойство `elide` позволяет задать позицию разрыва слева, справа или посередине текста.
Если вы не хотите, чтобы отображался '...' режима ускорения, но при этом хотите видеть полный текст, вы можете обернуть текст, используя свойство `wrapMode` (работает только при явном задании ширины):
```c++
Text {
	width: 40; height: 120
	text: 'A very long text'
	
	// '...' shall appear in the middle
	elide: Text.ElideMiddle
	
	// red sunken text styling
	style: Text.Sunken
	styleColor: '#FF4444'
	
	// align text to the top
	verticalAlignment: Text.AlignTop
	// only sensible when no elide mode
	// wrapMode: Text.WordWrap
}
```
Элемент `Text` отображает только заданный текст, а все остальное пространство, которое он занимает, является прозрачным. Это  означает, что он не отображает никаких фоновых  декораций, поэтому при желании можно создать приемлемый фон.

> Следует помнить, что начальная ширина элемента `Text` зависит от заданного шрифта и текстовой строки. Элемент `Text` без заданной ширины и без текста не будет виден, так как его начальная ширина будет равна 0.

> Часто при компоновке элементов `Text` необходимо различать выравнивание текста внутри границы элемента `Text` и выравнивание самой границы элемента. В первом случае необходимо использовать свойства `horizontalAlignment` и `verticalAlignment` , а во втором - манипулировать геометрией элемента или использовать якоря.

## Элемент изображения
Элемент `Image` способен отображать изображения различных форматов (например, PNG , JPG , GIF , BMP , WEBP ). Кроме исходного текста свойство для указания URL-адреса изображения, оно содержит параметр `fillMode` , который управляет поведением изменения размера.
```
Image {
	x: 12; y: 12
	// width: 72
	// height: 72
	
	source: "assets/triangle_red.png"
}

Image {
	x: 12+64+12; y: 12
	// width: 72
	height: 72/2
	source: "assets/triangle_red.png"

	fillMode: Image.PreserveAspectCrop
	clip: true
}
```
> URL может представлять собой локальный путь с прямыми косыми чертами ("./images/home.png" ) или web-ссылку(например, "http://example.org/home.png").

> Элементы изображения, использующие `PreserveAspectCrop`, должны также включать обрезку, чтобы избежать вывода данных изображения за границы `Image`. По умолчанию обрезка отключена (`clip: false`). Необходимо включить обрезку (`clip: true`), чтобы ограничить рисование ограничивающим прямоугольником элемента. Это может быть использовано для любого визуального элемента, но применять его следует осторожно.

## Элемент MouseArea
Для взаимодействия с этими элементами часто используется область `MouseArea`. Это прямоугольный невидимый элемент, в котором можно перехватывать события мыши. Область мыши часто используется вместе с видимым элементом для выполнения команд при взаимодействии пользователя с визуальной частью.
```c++
Rectangle {
	id: rect1
	x: 12; y: 12
	width: 76; height: 96
	color: "lightsteelblue"
	
	MouseArea {
		id: area
		width: parent.width
		height: parent.height
		onClicked: rect2.visible = !rect2.visible
	}
}

Rectangle {
	id: rect2
	x: 112; y: 12
	width: 76; height: 96
	border.color: "lightsteelblue"
	border.width: 4
	radius: 8
}
```
> Это важный аспект Qt Quick: обработка ввода отделена от визуального представления. Это позволяет показать пользователю элемент интерфейса, где фактическая область взаимодействия может быть больше.

> Для более сложного взаимодействия предназначены для использования вместо таких элементов, как `MouseArea` и `Flickable`, и обеспечивают больший контроль и гибкость. Идея заключается в том, чтобы обрабатывать один аспект взаимодействия в каждом экземпляре обработчика вместо того, чтобы централизовать обработку всех событий от данного источника в одном элементе, как это было раньше.
















