# Эффекты в QML
## Эффекты частиц
Эффекты частиц позволяют создавать группы частиц, т.е. экземпляры данного элемента. Они генерируются стохастическим образом и позволяют работать не с отдельными элементами, а с их группами. Это позволяет создавать такие эффекты, как падающие листья, взрывы, огонь, облака и звездные поля.
## Эффекты шейдеров
Шейдерные эффекты применяются в конвейере рендеринга графики и позволяют изменять как размер, так и цвет любого видимого элемента QML. Это может быть использовано для создания переходов, таких как эффект джинна, волны и завесы, или фильтров, таких как размытие, градации серого и смешивание.

Шейдеры пишутся на языке шейдеров, который затем запекается и импортируется в сцену QML, как и другие ресурсы. Эти шейдеры могут быть применены к изображениям или другим элементам для создания сложных визуальных эффектов.

## Концепция частиц
В основе моделирования частиц лежит система частиц `ParticleSystem`, которая управляет общей временной шкалой. Сцена может иметь несколько систем частиц, каждая из которых имеет независимую временную линию. Частица испускается с помощью элемента `Emitter` и визуализируется с помощью `ParticlePainter`, который может быть изображением, элементом QML или шейдером. Эмиттер также задает направление частицы с помощью векторного пространства.  Испущенные частицы уже не могут управляться эмиттером. Модуль частиц предоставляет `Affector`, который позволяет манипулировать параметрами частицы после ее испускания.

Частицы в системе могут совместно использовать временные переходы с помощью элемента `ParticleGroup`. По умолчанию каждая частица находится в пустой ('') группе.
![[QML Canv.png]]

> - `ParticleSystem` - управляет общей временной линией между эмиттерами
> - `Emiter` - излучает логические частицы в систему
> - `ParticlePainter` - частицы визуализируются художником частиц
> - `Direction` - векторное пространство для излучаемых частиц
> - `ParticleGroup` - каждая частица является членом группы
> - `Affector` - манипулирует частицами после их испускания

## Простое моделирование
Для начала рассмотрим очень простую симуляцию. Qt Quick позволяет очень просто начать работу с рендерингом частиц. Для этого нам понадобятся:

> - `ParticleSystem`, которая связывает все элементы в симуляцию 
> - `Emitter`, который излучает частицы в систему
> - Производный элемент `ParticlePainter`, который визуализирует частицы

```c++
import QtQuick
import QtQuick.Particles

Rectangle {
	id: root
	width: 480; height: 160
	color: "#1f1f1f"
	
	ParticleSystem {
		id: particleSystem
	}
	
	Emitter {
		id: emitter
		anchors.centerIn: parent
		width: 160; height: 80
		system: particleSystem
		emitRate: 10
		lifeSpan: 1000
		lifeSpanVariation: 500
		size: 16
		endSize: 32
		
		Tracer { color: 'green' }
	}

	ImageParticle {
		source: "assets/particle.png"
		system: particleSystem
	}
}
```
Результат примера будет выглядеть следующим образом:
![[QML Effects.png]]
В качестве корневого элемента и фона мы начинаем с темного прямоугольника размером 80x80 пикселей. В нем мы объявляем систему частиц `ParticleSystem`. Это всегда первый шаг, поскольку система связывает все остальные элементы воедино. Как правило, следующим элементом является эмиттер, который определяет область излучения на основе ее ограничительного поля и основных параметров излучаемых частиц. Эмиттер привязывается к системе с помощью свойства `system`.

В данном примере излучатель испускает 10 частиц в секунду (`emitRate: 10`) по всей площади излучателя с периодом жизни каждой из них 1000 мс (`lifeSpan: 1000`) и разбросом времени жизни между испускаемыми частицами 500 мс. (`lifeSpanVariation: 500`). Размер частицы в начале ее существования составляет `16px` (`size: 16`), а в конце ее жизни - `32px` (`endSize: 32`).

Зеленый прямоугольник с рамкой - это элемент трассировки, показывающий геометрию эмиттера. Это наглядно показывает, что, хотя частицы испускаются внутри граничного поля излучателя, рендеринг не ограничивается граничным полем излучателя. Позиция рендеринга зависит от времени жизни и направления частицы. Это станет более понятным, когда мы рассмотрим, как изменять направление частиц.

Эмиттер излучает логические частицы. Логическая частица визуализируется с помощью `ParticlePainter`, в данном примере мы используем `ImageParticle`, который в качестве свойства источника принимает URL изображения. Частица изображения имеет также несколько других свойств, которые управляют внешним видом средней частицы.

> -`emitRate`: количество частиц, испускаемых в секунду (по умолчанию 10 в секунду)
> - `lifeSpan` : миллисекунды, в течение которых должна существовать частица (по умолчанию 1000 мс)
> - `size`, `endSize`: размер частиц в начале и в конце их жизни (по умолчанию 16 px)

Изменение этих свойств может кардинально повлиять на результат
```c++
Emitter {
	id: emitter
	anchors.centerIn: parent
	width: 20; height: 20
	system: particleSystem
	emitRate: 40
	lifeSpan: 2000
	lifeSpanVariation: 500
	size: 64
	sizeVariation: 32
	
	Tracer { color: 'green' }
}
```
Помимо увеличения скорости излучения до 40 и времени жизни до 2 секунд, размер теперь начинается с 64 пикселей и уменьшается на 32 пикселя в конце времени жизни частицы.
![[QML Effects_1.png]]
Увеличение `endSize` еще больше приведет к получению более или менее белого фона. Обратите внимание, что когда частицы излучаются только в области, заданной эмиттером, рендеринг не ограничивается ею.

## Параметры частиц
Мы уже видели, как можно изменить поведение эмиттера, чтобы изменить нашу симуляцию. Используемый художник частиц позволяет визуализировать изображение частицы для каждой частицы. 

Возвращаясь к нашему примеру, обновим `ImageParticle`. Сначала мы изменим изображение частицы на изображение маленькой искрящейся звезды:
```c++
ImageParticle {
	...
	source: 'assets/star.png'
}	
```
Частицы должны быть окрашены в золотистый цвет, который варьируется от частицы к частице на +/- 20%:
```c++
color: '#FFD700'
colorVariation: 0.2
```
Чтобы сделать сцену более живой, мы хотели бы вращать частицы. Каждая частица должна стартовать на 15 градусов по часовой стрелке и изменяться между частицами на +/-5 градусов. Дополнительно частица должна непрерывно вращаться со скоростью 45 градусов в секунду. Скорость также должна меняться от частицы к частице на +/- 15 градусов в секунду:
```c++
rotation: 15
rotationVariation: 5
rotationVelocity: 45
rotationVelocityVariation: 15
```
В последнюю очередь мы изменим эффект входа для частицы. Это эффект, который используется, когда частица оживает. В данном случае мы хотим использовать эффект масштабирования:
```c++
entryEffect: ImageParticle.Scale
```
Теперь повсюду появляются вращающиеся золотые звезды.
![[QML Effects_2.png]]
Вот код, который мы изменили для изображения-частицы в одном блоке.
```c++
ImageParticle {
	source: "assets/star.png"
	system: particleSystem
	color: '#FFD700'
	colorVariation: 0.2
	rotation: 0
	rotationVariation: 45
	rotationVelocity: 15
	rotationVelocityVariation: 15
	entryEffect: ImageParticle.Scale
}
```

## Направленные частицы
Мы видели, что частицы могут вращаться. Но частицы могут также иметь траекторию. Траектория задается как скорость или ускорение частиц, определяемое стохастическим направлением, которое также называется векторным пространством.

Для определения скорости или ускорения частицы существуют различные векторные пространства:
>
> - `AngleDirection` - направление, изменяющееся по углу
> 
> - `PointDirection` - направление, изменяющееся в компонентах `x` и `y`
> 
> - `TargetDirection` - направление на целевую точку

![[QML Effects_3.png]]

Попробуем переместить частицы из левой части сцены в правую, используя направления скоростей.

Сначала попробуем использовать `AngleDirection`. Для этого нам необходимо указать `AngleDirection` как элемент свойства `velocity` нашего эмиттера:

```c++
velocity: AngleDirection {}
```
Угол, под которым излучаются частицы, задается с помощью свойства `angle`. Угол задается в виде значения в диапазоне 0...360 градусов, причем 0 указывает вправо. В нашем примере мы хотим, чтобы частицы двигались в направлении вправо, так что 0 - это уже правильное направление. Частицы должны разлетаться на +/- 5 градусов:
```c++
velocity: AngleDirection {
	angle: 0
	angleVariation: 15
}
```
Теперь, когда мы задали направление, необходимо указать скорость частицы. Она задается величиной. Величина определяется в пикселях в секунду. Так как у нас есть около 640px для перемещения, 100 кажется хорошим числом. Это означает, что в среднем за 6,4 секунды частица пересечет открытое пространство. Чтобы сделать путешествие частиц более интересным, мы изменяем величину с помощью параметра `magnitudeVariation` и устанавливаем ее на половину величины:
```c++
velocity: AngleDirection {
	...
	magnitude: 100
	magnitudeVariation: 50
}
```
![[QML Effects_4.png]]

Здесь приведен полный исходный код, среднее время жизни установлено на 6,4 секунды. Мы установили ширину и высоту эмиттера равными 1px. Это означает, что все частицы испускаются в одном и том же месте и далее движутся по заданной нами траектории.
```c++
Emitter {
	id: emitter
	anchors.left: parent.left
	anchors.verticalCenter: parent.verticalCenter
	width: 1; height: 1
	system: particleSystem
	lifeSpan: 6400
	lifeSpanVariation: 400
	size: 32

	velocity: AngleDirection {
		angle: 0
		angleVariation: 15
		magnitude: 100
		magnitudeVariation: 50
	}
}
```
Что же тогда делает ускорение? Ускорение добавляет к каждой частице вектор ускорения, который изменяет вектор скорости с течением времени. Например, сделаем траекторию в виде звездной дуги. Для этого изменим направление скорости на -45 градусов и уберем вариации, чтобы лучше представить последовательную дугу:
```c++
velocity: AngleDirection {
	angle: -45
	magnitude: 100
}
```
Направление ускорения должно составлять 90 градусов (направление вниз), для чего выбираем одну четвертую часть величины скорости:
```c++
velocity: AngleDirection { 
	angle: 90
	magnitude: 25
}
```

В результате получается дуга, идущая от левого центра к правому низу

![[QML Effects_5.png]]

Значения определяются методом проб и ошибок. Вот полный код нашего эмиттера.
```c++
Emitter {
	id: emitter
	anchors.left: parent.left
	anchors.verticalCenter: parent.verticalCenter
	width: 1; height: 1
	system: particleSystem
	emitRate: 10
	lifeSpan: 6400
	lifeSpanVariation: 400
	size: 32
	
	velocity: AngleDirection {
		angle: -45
		angleVariation: 0
		magnitude: 100
	}
	
	acceleration: AngleDirection {
		angle: 90
		magnitude: 25
	}
}
```
В следующем примере мы хотим, чтобы частицы снова перемещались слева направо, но на этот раз мы используем векторное пространство `PointDirection`.

Векторное пространство `PointDirection` формируется из компонент `x` и `y`. Например, если вы хотите, чтобы частицы двигались по вектору с углом 45 градусов, необходимо задать одинаковые значения для `x` и `y`.

В нашем случае мы хотим, чтобы частицы двигались слева направо, образуя конус с углом 15 градусов. Для этого в качестве пространства вектора скорости мы задаем `PointDirection`:
```c++
	velocity: PointDirection {}
```
Чтобы получить скорость перемещения `100px` в секунду, зададим компоненту `x` равной 100. Для 15 градусов (что составляет 1/6 часть от 90 градусов) мы задаем любое изменение `100/6`:
```c++
velocity: PointDirection {
	x: 100
	y: 0
	xVariation: 0
	yVariation: 100/6
}
```
В результате частицы должны двигаться в 15-градусном конусе справа налево.
![[QML Effects_6.png]]

Переходим к нашему последнему претенденту - `TargetDirection`. Направление цели позволяет указать целевую точку в виде координат `x` и `y` относительно эмиттера или элемента. При указании элемента его центр становится целевой точкой. Можно получить 15-градусный конус, задав изменение цели на 1/6 часть от `x`:
```c++
velocity: TargetDirection {
	targetX: 100
	targetY: 0
	targetVariation: 100/6
	magnitude: 100
}
```
> - Направление цели удобно использовать, когда у вас есть определенная координата `x/y`, к которой вы хотите направить поток частиц.

Я избавляю вас от изображения, поскольку оно выглядит так же, как и предыдущее, вместо этого у меня есть для вас квест.

На следующем рисунке красный и зеленый кружки задают каждый целевой элемент для целевого направления свойства `velocity`, соответствующего свойству `acceleration`. Каждое целевое направление имеет одинаковые параметры. Здесь возникает вопрос: Кто отвечает за скорость, а кто за ускорение?
![[QML Effects_7.png]]

## Воздействующие частицы
Частицы испускаются эмиттером. После того как частица была испущена, она уже не может быть изменена эмиттером. Аффекторы позволяют воздействовать на частицы после их испускания.

Каждый тип аффектора воздействует на частицы по-своему:
>
> - **Возраст** - изменяет место частицы в ее жизненном цикле
> - **Аттрактор** - притягивает частицы к определенной точке
> - **Трение** - замедляет движение пропорционально текущей скорости частицы
> - **Гравитация** - задает ускорение по углу
> - **Турбулентность** - гидродинамические силы, основанные на шумовом изображении
> - **Блуждать** - произвольно изменять траекторию движения
> - **GroupGoal** - изменение состояния группы частиц
> - **SpriteGoal** - изменение состояния частицы спрайта

### Возраст
Позволяет частице стареть быстрее. Свойство `lifeLeft` указывает, сколько жизни должно остаться у частицы.
```c++
Age {
	anchors.horizontalCenter: parent.horizontalCenter
	width: 240; height: 120
	system: particleSystem
	advancePosition: true
	lifeLeft: 1200
	once: true
	
	Tracer {}
}
```
В примере мы сокращаем жизнь верхних частиц один раз, когда они достигают возраста аффектора в 1200 мсек. Поскольку мы установили опцию `advancePosition` в `true`, мы видим, что частица снова появляется на позиции, когда ей осталось жить 1200 мс.

![[QML Effects_8.png]]

### Аттрактор
Аттрактор притягивает частицы к определенной точке. Точка задается с помощью параметров `pointX` и `pointY`, которые относятся к геометрии аттрактора. Сила задает силу притяжения. В нашем примере частицы движутся слева направо. Аттрактор располагается сверху, и половина частиц проходит через аттрактор. Аттрактор воздействует на частицы только тогда, когда они находятся в своей граничной области. Такое разделение позволяет нам одновременно видеть обычный поток и поток, подверженный влиянию.

```c++
Attractor {
	anchors.horizontalCenter: parent.horizontalCenter
	width: 160; height: 120
	system: particleSystem
	pointX: 0
	pointY: 0
	strength: 1.0
	
	Tracer {}
}
```
Легко заметить, что верхняя половина частиц подвержена влиянию притяжения сверху. Точка притяжения установлена в левом верхнем углу (точка 0/0) аттрактора с силой 1,0.
![[QML Effects_9.png]]

### Фрикцион
Фрикционный аффектор замедляет частицы в определенный раз, пока не будет достигнут определенный порог.
```c++
Friction {
	anchors.horizontalCenter: parent.horizontalCenter
	width: 240; height: 120
	system: particleSystem
	factor : 0.8
	threshold: 25
	
	Tracer {}
}
```
В верхней зоне трения частицы замедляются в 0,8 раза пока частица не достигнет скорости 25 пикселей в секунду. Порог действует как фильтр. Частицы, движущиеся со скоростью выше пороговой, замедляются на заданный коэффициент.

![[QML Effects_10.png]]

### Гравитация
Гравитационный аффектор придает ускорение В примере мы направляем частицы снизу вверх, используя угловое направление. Правая сторона не затрагивается, а на левую накладывается эффект гравитации. Гравитация направлена под углом 90 градусов (направление снизу) с величиной 50.
```c++
Gravity {
	width: 240; height: 240
	system: particleSystem
	magnitude: 50
	angle: 90
	
	Tracer {}
}
```

Частицы, находящиеся слева, пытаются подняться вверх, но постоянное приложенное ускорение к низу увлекает их в направлении действия силы тяжести.

![[QML Effects_11.png]]

### Турбулентность
Аффектор турбулентности накладывает на частицы карту хаоса из векторов сил. Карта хаоса определяется шумовым образом, который можно задать с помощью свойства `noiseSource`. Сила определяет, насколько сильный вектор будет применяться к движениям частиц.
```c++
Turbulence {
	anchors.horizontalCenter: parent.horizontalCenter
	width: 240; height: 120
	system: particleSystem
	strength: 100
	
	Tracer {}
}
```
В верхней области примера частицы находятся под воздействием турбулентности. Их движение более неустойчиво. Величина нестабильного отклонения от первоначальной траектории определяется силой.

![[QML Effects_12.png]]

### Wander
Манипуляция управляет траекторией. С помощью свойства `affectedParameter` можно указать, на какой параметр (скорость, положение или ускорение) влияет движение. Свойство `pace` задает максимальное количество изменений атрибута в секунду. Свойства `xVariance` и `yVariance` задают влияние на x- и y-компоненту траектории частицы.
```c++
Wander {
	anchors.horizontalCenter: parent.horizontalCenter
	width: 240; height: 120
	system: particleSystem
	affectedParameter: Wander.Position
	pace: 200
	yVariance: 240
	
	Tracer {}
}
```
В верхнем блуждании частицы аффектора перемещаются по случайным траекториям. В данном случае положение меняется 200 раз в секунду в направлении `y`.
![[QML Effects_13.png]]

## Группы частиц

В начале этой главы мы указали, что частицы находятся в группах, которая по умолчанию является пустой группой (''). Используя аффектор `GroupGoal`, можно позволить частице менять группы. Для наглядности мы хотели бы создать небольшой фейерверк, в котором ракеты стартуют в космос и взрываются в воздухе, образуя эффектный фейерверк.
![[QML Effects_14.png]]
Пример разделен на 2 части. Первая часть под названием "Время запуска" предназначена для создания сцены и введения групп частиц, а вторая часть под названием "Пусть будет фейерверк" посвящена смене групп.
### Время запуска
Для начала создадим типичную темную сцену:
```c++
import QtQuick 2.5
import QtQuick.Particles 2.0

Rectangle {
	id: root
	width: 480; height: 240
	color: "#1F1F1F"
	property bool tracer: false
}
```

Свойство `tracer` будет использоваться для включения и выключения широкой сцены трассировки. Следующим шагом будет объявление нашей системы частиц:

```c++
ParticleSystem {
	id: particleSystem
}
```

И две наши частицы-изображения (одна для ракеты, другая для дыма от выхлопных газов): 

```c++
ImageParticle {
	id: smokePainter
	system: particleSystem
	
	groups: ['smoke']
	
	source: "assets/particle.png"
	alpha: 0.3
	entryEffect: ImageParticle.None
}

ImageParticle {
	id: rocketPainter
	system: particleSystem
	
	groups: ['rocket']
	
	source: "assets/rocket.png"
	entryEffect: ImageParticle.None
}
```

На изображениях видно, что для объявления того, к какой группе принадлежит частица, используется свойство `groups`. Достаточно просто объявить имя, и Qt Quick создаст неявную группу. 

Теперь пришло время выпустить в воздух несколько ракет. Для этого мы создадим эмиттер в нижней части нашей сцены и зададим скорость в направлении вверх. Для имитации гравитации зададим ускорение вниз:

```c++
Emitter {
	id: rocketEmitter
	anchors.bottom: parent.bottom
	width: parent.width; height: 40
	system: particleSystem
	group: 'rocket'
	emitRate: 2
	maximumEmitted: 4
	lifeSpan: 4800
	lifeSpanVariation: 400
	size: 32
	
	velocity: AngleDirection { angle: 270; magnitude: 150; magn
	
	acceleration: AngleDirection { angle: 90; magnitude: 50 }
	
	Tracer { color: 'red'; visible: root.tracer }
}
```
Излучатель находится в группе `rocket`, такой же, как и наш художник частиц ракеты. Благодаря имени группы они связаны друг с другом. Эмиттер излучает частицы в группу `rocket`, а художник частиц ракеты закрашивает их.

Для выхлопа мы используем эмиттер следа, который следует за нашей ракетой. Он объявляет собственную группу `smoke` и следует за частицами из группы `rocket`:

```c++
TrailEmitter {
	id: smokeEmitter
	system: particleSystem
	emitHeight: 1
	emitWidth: 4
	group: 'smoke'
	follow: 'rocket'
	emitRatePerParticle: 96
	velocity: AngleDirection { angle: 90; magnitude: 100; angle
	lifeSpan: 200
	size: 16
	sizeVariation: 4
	endSize: 0
}
```
Дым направлен вниз, чтобы имитировать силу, с которой дым выходит из ракеты. Параметры `emitHeight` и `emitWidth` задают область вокруг частицы, из которой будут вылетать частицы дыма. Если они не указаны, то берется высота частицы, за которой она следует, но в данном примере мы хотим усилить эффект того, что частицы исходят из центральная точка вблизи конца ракеты.

Если запустить пример сейчас, то можно увидеть, как ракеты взлетают вверх, а некоторые даже вылетают за пределы сцены. Так как это не очень желательно, нам нужно замедлить их до того, как они покинут экран. Здесь можно использовать аффектор трения, чтобы замедлить частицы до минимального порога
```c++
Friction {
	groups: ['rocket']
	anchors.top: parent.top
	width: parent.width; height: 80
	system: particleSystem
	threshold: 5
	factor: 0.9
}
```
В аффекторе трения также необходимо указать, на какие группы частиц он будет воздействовать. Трение замедлит все ракеты, находящиеся на расстоянии 80 пикселей от верхней границы экрана, в 0,9 раза (попробуйте 100, и вы увидите, что они почти сразу остановятся), пока они не достигнут скорости 5 пикселей в секунду. Поскольку частицы все еще имеют ускорение, направленное вниз, ракеты начнут опускаться к земле после того, как достигнут конца своего времени жизни.

Поскольку подъем в воздух - тяжелая работа и очень нестабильная ситуация, мы хотим смоделировать некоторые турбулентности во время подъема корабля:
```c++
Turbulence {
	groups: ['rocket']
	
	anchors.bottom: parent.bottom
	width: parent.width; height: 160
	system: particleSystem
	strength: 25
	
	Tracer { color: 'green'; visible: root.tracer }
}
```
Кроме того, турбулентность должна объявить, на какие группы она должна воздействовать. Сама турбулентность простирается снизу на 160 пикселей вверх (пока не достигнет границы трения). Они также могут накладываться друг на друга.

Запустив пример, вы увидите, что ракеты поднимаются вверх, затем замедляются за счет трения и падают на землю под действием все еще приложенного ускорения вниз. Следующим шагом будет запуск фейерверка.
![[QML Effects_15.png]]

> На изображении показана сцена с включенными трассерами для отображения различных областей. Ракетные частицы выбрасываются в красной области и затем подвергаются воздействию турбулентности в синей области. Наконец, они замедляются под действием трения в зеленой области и снова начинают падать, поскольку к ним постоянно прикладывается ускорение вниз.

### Пусть будет фейерверк

Чтобы превратить ракету в красивый фейерверк, необходимо добавить `ParticleGroup` для инкапсуляции изменений:
```c++
ParticleGroup {
	name: 'explosion'
	system: particleSystem
}
```
Мы переходим к группе частиц с помощью аффектора `GroupGoal`. Группа аффектор цели располагается вблизи вертикального центра экрана и воздействует на группу "ракета". С помощью свойства `groupGoal` мы устанавливаем целевую группу для изменения на `explosion`, нашу ранее определенную группу частиц:
```c++
GroupGoal {
	id: rocketChanger
	anchors.top: parent.top
	width: parent.width; height: 80
	system: particleSystem
	groups: ['rocket']
	goalState: 'explosion'
	jump: true
	Tracer { color: 'blue'; visible: root.tracer }
}
```
Свойство `jump` определяет, что изменение групп должно происходить немедленно, а не через некоторое время.

Поскольку группа ракеты теперь меняется на нашу группу частиц "взрыв", когда частица ракеты попадает в область цели группы, нам нужно добавить фейерверк внутри группы частиц:
```c++
// inside particle group
TrailEmitter {
	id: explosionEmitter
	anchors.fill: parent
	group: 'sparkle'
	follow: 'rocket'
	lifeSpan: 750
	emitRatePerParticle: 200
	size: 32
	velocity: AngleDirection { angle: -90; angleVariation: 180;
}
```
Взрыв выбрасывает частицы в группу `sparkle`. В ближайшее время мы определим художник частиц для этой группы. Используемый излучатель следа следует за частицей ракеты и излучает на каждую ракету 200 частиц. Частицы направлены вверх и изменяются на 180 градусов.

Поскольку частицы излучаются в группу `sparkle`, нам также необходимо определить художник частиц для этих частиц:
```c++
ImageParticle {
	id: sparklePainter
	system: particleSystem
	groups: ['sparkle']
	color: 'red'
	colorVariation: 0.6
	source: "assets/star.png"
	alpha: 0.3
}
```
Блестки нашего фейерверка должны представлять собой маленькие красные звездочки почти прозрачного цвета, позволяющие получить эффект сияния. Чтобы сделать фейерверк более эффектным, мы также добавим в группу частиц второй излучатель `trail`, который будет испускать частицы узким конусом вниз:
```c++
// inside particle group
TrailEmitter {
	id: explosion2Emitter
	anchors.fill: parent
	group: 'sparkle'
	follow: 'rocket'
	lifeSpan: 250
	emitRatePerParticle: 100
	size: 32
	velocity: AngleDirection { angle: 90; angleVariation: 15; m
}
```
В остальном установка аналогична установке другого излучателя взрывного следа. Вот и все. Вот окончательный результат.

![[QML Effects_16.png]]

Здесь приведен полный исходный код ракетного фейерверка.
```c++
import QtQuick
import QtQuick.Particles

Rectangle {
	id: root
	width: 480; height: 240
	color: "#1F1F1F"
	property bool tracer: false
	
	ParticleSystem {
		id: particleSystem
	}
	
	ImageParticle {
		id: smokePainter
		system: particleSystem
		groups: ['smoke']
		source: "assets/particle.png"
		alpha: 0.3
	}
	
	ImageParticle {
		id: rocketPainter
		system: particleSystem
		groups: ['rocket']
		source: "assets/rocket.png"
		entryEffect: ImageParticle.Fade
	}
	
	Emitter {
		id: rocketEmitter
		anchors.bottom: parent.bottom
		width: parent.width; height: 40
		system: particleSystem
		group: 'rocket'
		emitRate: 2
		maximumEmitted: 8
		lifeSpan: 4800
		lifeSpanVariation: 400
		size: 128
		
		velocity: AngleDirection { angle: 270; magnitude: 150;
		acceleration: AngleDirection { angle: 90; magnitude: 50
		Tracer { color: 'red'; visible: root.tracer }
	}
	
	TrailEmitter {
		id: smokeEmitter
		system: particleSystem
		group: 'smoke'
		follow: 'rocket'
		size: 16
		sizeVariation: 8
		emitRatePerParticle: 16
		velocity: AngleDirection { angle: 90; magnitude: 100; a
		lifeSpan: 200
		
		Tracer { color: 'blue'; visible: root.tracer }
	}

	Friction {
		groups: ['rocket']
		anchors.top: parent.top
		width: parent.width; height: 80
		system: particleSystem
		threshold: 5
		factor: 0.9
	}

	Turbulence {
		groups: ['rocket']
		anchors.bottom: parent.bottom
		width: parent.width; height: 160
		system: particleSystem
		strength:25
		Tracer { color: 'green'; visible: root.tracer }
	}
	
	ImageParticle {
		id: sparklePainter
		system: particleSystem
		groups: ['sparkle']
		color: 'red'
		colorVariation: 0.6
		source: "assets/star.png"
		alpha: 0.3
	}
	
	GroupGoal {
		id: rocketChanger
		anchors.top: parent.top
		width: parent.width; height: 80
		system: particleSystem
		groups: ['rocket']
		goalState: 'explosion'
		jump: true
		
		Tracer { color: 'blue'; visible: root.tracer }
	}
	
	ParticleGroup {
		name: 'explosion'
		system: particleSystem
		
		TrailEmitter {
			id: explosionEmitter
			anchors.fill: parent
			group: 'sparkle'
			follow: 'rocket'
			lifeSpan: 750
			emitRatePerParticle: 200
			size: 32
			
			velocity: AngleDirection { angle: -90; angleVariati
		}

		TrailEmitter {
			id: explosion2Emitter
			anchors.fill: parent
			group: 'sparkle'
			follow: 'rocket'
			lifeSpan: 250
			emitRatePerParticle: 100
			size: 32
			
			velocity: AngleDirection { angle: 90; angleVariatio
		}
	}
}
```






















