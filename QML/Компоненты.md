# Компоненты
Компонент - это многократно используемый элемент. QML предоставляет различные способы создания компонентов. В настоящее время мы рассмотрим только самую простую форму - компонент на основе файла. Компонент на основе файла создается путем помещения QML-элемента в файл и присвоения файлу имени элемента (например, `Button.qml`). Компонент можно использовать, как и любой другой элемент из модуля Qt Quick. В нашем случае в коде это будет выглядеть так: `Button { ... }`.
Например, создадим прямоугольник, содержащий текстовый компонент и область мыши. Это напоминает простую кнопку и для наших целей не требует усложнения.

```c++
Rectangle { // our inlined button ui
	id: button
	x: 12; y: 12
	width: 116; height: 26
	
	color: "lightsteelblue"
	border.color: "slategrey"
	
	Text {
		anchors.centerIn: parent
		text: "Start"
	}
	
	MouseArea {
		anchors.fill: parent
		onClicked: {
			status.text = "Button clicked!"
		}
	}
}

Text { // text changes when button was clicked
	id: status
	x: 12; y: 76
	width: 116; height: 26
	
	text: "waiting ..."
	horizontalAlignment: Text.AlignHCenter
}
```
Пользовательский интерфейс будет выглядеть примерно как на рисунке. На первом изображении пользовательский интерфейс находится в начальном состоянии, а на втором - кнопка уже нажата.
![[Qml Button.png]]
Теперь наша задача - извлечь пользовательский интерфейс кнопки в многократно используемый компонент. Для этого необходимо продумать возможный API для нашей кнопки. Это можно сделать, представив, как кто-то другой будет использовать вашу кнопку. Вот что я придумал:
```c++
// minimal API for a button
Button {
	text: "Click Me"
	onClicked: { /* do something */ }
}
```
Я хотел бы установить текст с помощью свойства `text` и реализовать собственный обработчик нажатия. Кроме того, я хотел бы, чтобы кнопка имела разумное начальное значение размера, который я могу перезаписать (например, с помощью width: 240 ).
Для этого мы создаем файл `Button.qml` и копируем в него наш пользовательский интерфейс кнопки. Кроме того, нам необходимо экспортировать свойства, которые пользователь может захотеть изменить на корневом уровне.
```c++
// Button.qml
import QtQuick

Rectangle {
	id: root
	// export button properties
	property alias text: label.text signal clicked
	
	width: 116; height: 26
	color: "lightsteelblue"
	border.color: "slategrey"

	Text {
		id: label
		anchors.centerIn: parent
		text: "Start"
	}
	
	MouseArea {
		anchors.fill: parent
		onClicked: {
			root.clicked()
		}
	}
}
```
Мы экспортировали свойство `text` и сигнал `clicked` на корневом уровне. Обычно мы называем наш корневой элемент `root`, чтобы упростить обращение к нему. Мы используем функцию псевдонимов в **QML**, которая позволяет экспортировать свойства внутри вложенных элементов **QML** на корневой уровень и сделать их доступными для внешнего мира. Важно знать, что извне этого файла другие компоненты могут получить доступ только к свойствам корневого уровня. 
Чтобы использовать наш новый элемент `Button`, мы можем просто объявить его в нашем файле. Таким образом, предыдущий пример немного упростится.
```c++
Button {            // our Button component
	id: button
	x: 12; y: 12
	text: "Start"
	onClicked: {
		status.text = "Button clicked!"
	}
}

Text {               // text changes when button was clicked
	id: status
	x: 12; y: 76
	width: 116; height: 26
	text: "waiting ..."
	horizontalAlignment: Text.AlignHCenter
}
```
Теперь в пользовательском интерфейсе можно использовать сколько угодно кнопок, просто используя `Button { ... }`. Настоящая кнопка может быть более сложной, например, обеспечивать обратную связь при нажатии или показывать более красивое оформление.
При желании можно даже пойти дальше и использовать элемент `Item` в качестве корневого элемента. Это не позволит пользователям изменить цвет кнопки, которую мы разработали, и обеспечит нам больший контроль над экспортируемым API. Цель должна заключаться в экспорте минимального API. Практически это означает, что нам нужно заменить корневой Rectangle на Item и сделать прямоугольник вложенным элементом в корневой элемент.

```c++
Item {
	id: root
	width: 116; height: 26
	property alias text: label.text signal clicked
	
	Rectangle {
		anchors.fill parent
		color: "lightsteelblue"
		border.color: "slategrey"
	}
...
}
```
С помощью этой техники легко создать целую серию многократно используемых компонентов.

## Простые преобразования

Трансформация управляет геометрией объекта. Объекты **QML**, как правило, могут быть переведены, повернуты и масштабированы. Существует простая форма этих операций и более сложная.
Начнем с простых преобразований. В качестве отправной точки приведем нашу сцену.
Простой перевод осуществляется путем изменения положения `x, y`. Поворот осуществляется с помощью свойства `rotation`. Значение задается в градусах (0 ... 360). Масштабирование выполняется с помощью свойства `scale`, причем значение <1 означает уменьшение масштаба элемента, а >1 - увеличение.
Вращение и масштабирование не изменяют геометрию элемента: `x, y` и не меняются; преобразуются только инструкции рисования.
Прежде чем мы покажем пример, я хотел бы представить вам небольшого помощника: элемент `ClickableImage`. `ClickableImage` - это просто изображение с областью мыши. В связи с этим возникает полезное правило: если вы скопировали кусок кода три раза, извлеките его в компонент.
```c++
// ClickableImage.qml
// Simple image which can be clicked

import QtQuick
Image {
	id: root
	signal clicked
	
	MouseArea {
		anchors.fill: parent
		onClicked: root.clicked()
	}
}
```
Мы используем наше кликабельное изображение для представления трех объектов (кквадрат, круг, треугольник). Каждый объект при щелчке выполняет простое преобразование. Щелчок на фоне приводит к сбросу сцены.
```c++
// TransformationExample.qml
import QtQuick

Item {
	// set width based on given background
	width: bg.width
	height: bg.height
	
	Image { // nice background image
		id: bg
		source: "assets/background.png"
	
	}
		
MouseArea {
	id: backgroundClicker
				// needs to be before the images as order matters
				// otherwise this mousearea would be before the other e
				// and consume the mouse events
				
	anchors.fill: parent
	
	onClicked: {
				// reset our little scene
		circle.x = 84
		box.rotation = 0
		triangle.rotation = 0
		triangle.scale = 1.0
	}
}
	
ClickableImage {
	id: circle
	x: 84; y: 68
	source: "assets/circle_blue.png"
	antialiasing: true
	onClicked: {
				// increase the x-position on click
		x += 20
	}
}

ClickableImage {
	id: box
	x: 164; y: 68
	source: "assets/box_green.png"
	antialiasing: true
	
	onClicked: {
					// increase the rotation on click
		rotation += 15
	}
}

ClickableImage {
	id: triangle
	x: 248; y: 68
	source: "assets/triangle_red.png"
	antialiasing: true
	onClicked: {
		// several transformations
		rotation += 15
		scale += 0.05
	}
}
```
Окружность увеличивает положение `x` при каждом щелчке, а рамка поворачивается при каждом щелчке. Треугольник будет поворачивать и масштабировать изображение при каждом щелчке, демонстрируя комбинированное преобразование. Для операций масштабирования и вращения мы установили значение `antialiasing: true`, чтобы включить сглаживание, которое отключено (так же, как и свойство обрезки clip ) по соображениям производительности. В собственной работе, когда в графике появляются растрированные края, сглаживание, вероятно, следует включить.
> Для достижения лучшего качества изображения при масштабировании рекомендуется масштабировать не вверх, а вниз. Увеличение масштаба изображения с большим коэффициентом масштабирования приведет к появлению артефактов масштабирования (размытости изображения). При масштабировании изображения следует использовать
`smooth: true`, ч то позволяет использовать фильтр более высокого качества за счет снижения производительности.

Фоновая `MouseArea` занимает весь фон и сбрасывает значения объектов.
> Элементы, которые появляются раньше в коде, имеют более низкий порядок укладки (так называемый z-порядок). Если долго щелкать на круге , то можно увидеть, что он перемещается ниже бокса . Порядком `z` можно также управлять с помощью свойства `z` элемента.
> Это связано с тем, что `box` появляется позже в коде. То же самое относится и к областям мыши. Область мыши, расположенная позже в коде, будет перекрывать (и, следовательно, захватывать события мыши) область мыши, расположенную раньше в коде.















