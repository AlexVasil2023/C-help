# Модель-Вид-Делегат
Как только объем данных выходит за рамки тривиального, хранить копию данных вместе с презентацией становится нецелесообразно. Это означает, что слой представления, то есть то, что видит пользователь, должен быть отделен от слоя данных, то есть реального содержимого. В `Qt Quick` данные отделяются от представления с помощью так называемого разделения модели и представления. `Qt Quick` предоставляет набор готовых представлений, в которых каждый элемент данных визуализируется делегатом. Для использования системы необходимо понимать эти классы и знать, как создать соответствующих делегатов, чтобы добиться нужного внешнего вида и настроек.
## Концепция
При разработке пользовательских интерфейсов распространенной схемой является разделение представления данных и их визуализации. Это позволяет отображать одни и те же данные разными способами в зависимости от того, какую задачу выполняет пользователь. Например, телефонная книга может быть представлена в виде вертикального списка текстовых записей или в виде сетки фотографий контактов. В обоих случаях данные одинаковы: телефонная книга, но визуализация разная. Такое разделение принято называть паттерном "модель-вид". В этом шаблоне данные называются моделью, а визуализация
выполняется представлением.

В QML модель и представление объединяются делегатом. Обязанности распределяются следующим образом: Модель предоставляет данные. Для каждого элемента данных может быть несколько значений. В приведенном примере каждая запись телефонной книги содержит имя, фотографию и номер. Данные располагаются в представлении, в котором каждый элемент визуализируется с помощью делегата. Задача представления -
упорядочить делегаты, при этом каждый делегат отображает значения каждого элемента пользователю.

Это означает, что делегат знает о содержимом модели и как его визуализировать.  Представление знает о концепции делегатов и о том, как их расположить. Модель знает только о данных, которые она представляет.
![[QML model.png]]

## Базовые модели

Самым простым способом визуализации данных из модели является использование элемента `Repeater`. Он используется для инстанцирования массива элементов и легко сочетается с позиционером для заполнения части пользовательского интерфейса. Ретранслятор использует модель, которая может быть любой: от количества элементов для инстанцирования до полноценной модели, собирающей данные из Интернета.

## Использование числа

В простейшем виде ретранслятор может быть использован для инстанцирования заданного количества элементов. Каждый элемент будет иметь доступ к вложенному свойству -  переменной `index`, которая может использоваться для различения элементов. В приведенном ниже примере ретранслятор используется для создания 10 экземпляров элемента.

Количество элементов контролируется с помощью свойства `model` и их управление визуальным представлением осуществляется с помощью свойства `delegate`. Для каждого элемента модели инстанцируется делегат (здесь делегат - `BlueBox` , который представляет собой настроенный прямоугольник, содержащий элемент `Text`). Как видно, свойство `text` установлено в значение `index`, поэтому элементы пронумерованы от нуля до девяти.
```c++
import QtQuick
import "../common"

Column {
	spacing: 2
	
	Repeater {
		model: 10
		
		delegate: BlueBox {
			required property int index

			width: 100
			height: 32
			text: index
		}
	}
}
```
![[QML model_2.png]]

## Использование массива
Как бы ни были хороши списки пронумерованных элементов, иногда бывает интересно отобразить более сложный набор данных. Заменив целочисленное значение модели на JavaScript-массив, мы можем достичь этого. Содержимое массива может быть любого типа, будь то строки, целые числа или объекты. В приведенном ниже примере используется список строк. Мы по-прежнему можем обращаться к переменной `index` и использовать ее, но у нас также есть доступ к `modelData` , содержащей данные для каждого элемента массива.
``` c++
import QtQuick
import "../common"

Column {
	spacing: 2
		
	Repeater {
		model: ["Enterprise", "Columbia", "Challenger", "Discov]

		delegate: BlueBox {
			required property var modelData
			required property int index
			
			width: 100
			height: 32
			radius: 3
			
			text: modelData + ' (' + index + ')'
		}
	}
}
```
![[QML model_3.png]]

## Использование модели ListModel
Имея возможность раскрывать данные массива, вы вскоре оказываетесь в ситуации, когда вам требуется несколько частей данных для каждого элемента массива. Вот тут-то и появляются модели. Одной из наиболее тривиальных моделей и одной из наиболее часто используемых является модель `ListModel`. Модель списка - это просто коллекция элементов `ListElement` . Внутри каждого элемента списка можно привязать к значениям ряд свойств. Например, в приведенном ниже примере для каждого элемента заданы имя и цвет.

Свойства, связанные внутри каждого элемента, прикрепляются ретранслятором к каждому инстанцированному элементу. Это означает, что переменные name и `surfaceColor` доступны из области видимости каждого `Rectangle` и элемент `Text`, создаваемый ретранслятором. Это не только упрощает доступ к данным, но и облегчает чтение исходного кода.
Сайт `surfaceColor` - это цвет круга слева от названия, а не что-то непонятное вроде данных из столбца `i` строки `j`.
```c++
import QtQuick
import "../common"

	Column {
		spacing: 2
		
		Repeater {
			
			model: ListModel {
				ListElement { name: "Mercury"; surfaceColor: "gray"]
				ListElement { name: "Venus"; surfaceColor: "yellow"]
				ListElement { name: "Earth"; surfaceColor: "blue"}
				ListElement { name: "Mars"; surfaceColor: "orange"]
				ListElement { name: "Jupiter"; surfaceColor: "orang"}
				ListElement { name: "Saturn"; surfaceColor: "yellow"}
				ListElement { name: "Uranus"; surfaceColor: "lightBlue}
				ListElement { name: "Neptune"; surfaceColor: "light"}
			}
			
			delegate: BlueBox {
				id: blueBox
				
				required property string name
				required property color surfaceColor
				
				width: 120
				height: 32
				radius: 3
				text: name
				
				Box {
					anchors.left: parent.left
					anchors.verticalCenter: parent.verticalCenter
					anchors.leftMargin: 4
					
					width: 16
					height: 16
					radius: 8
					
					color: blueBox.surfaceColor
				}
			}
		}
	}
```
![[QML model_4.png]]

## Использование делегата в качестве свойства по умолчанию

Свойство `delegate` ретранслятора является его свойством по умолчанию. Это означает, что код примера `01` можно записать и следующим образом:
```c++
import QtQuick
import "../common"

Column {
	spacing: 2
	
	Repeater {
		model: 10

		BlueBox {
			required property int index
		
			width: 100
			height: 32
			text: index
		}
	}
}
```
## Динамические представления
Повторители хорошо работают для ограниченных и статичных наборов данных, но в реальном мире модели обычно сложнее и больше. Здесь требуется более разумное решение. Для этого в `Qt Quick` предусмотрены элементы `ListView` и `GridView`. Оба они основаны на области `Flickable`, что позволяет пользователю перемещаться в большом наборе данных. В то же время они ограничивают количество одновременно  инстанцируемых делегатов. Для большой модели это означает меньшее количество элементов в сцене одновременно.
![[QML model_5.png]]

![[QML model_6.png]]

Эти два элемента схожи по своему использованию. Мы начнем с `ListView`, а затем опишем `GridView`, используя первый в качестве отправной точки сравнения. Обратите внимание, что
`GridView` размещает список элементов в двумерной сетке, слева направо или сверху вниз. Если вы хотите Для отображения таблицы с данными необходимо использовать `TableView`, который описан в разделе `Модели таблиц`.

`ListView` аналогичен элементу `Repeater`. Он использует модель, инстанцирует делегат, а между делегатами могут быть промежутки . В приведенном ниже листинге показано, как может выглядеть простая настройка.
```c++
import QtQuick
import "../common"

Background {
	width: 80
	height: 300

	ListView {
		anchors.fill: parent
		anchors.margins: 20
		
		clip: true
		model: 100
		
		delegate: GreenBox {
			required property int index
			
			width: 40
			height: 40
			text: index
		}
		
		spacing: 5
	}
}
```
![[QML model_5.png]]

Если модель содержит больше данных, чем может поместиться на экране, то в `ListView` отображается только часть списка. Однако, как следствие поведения `Qt Quick` по умолчанию, представление списка не ограничивает область экрана, в которой отображаются делегаты. Это означает, что делегаты могут быть видимым за пределами представления  списка, и чтобы динамическое создание и уничтожение делегатов за пределами представления списка было заметно пользователю. Для предотвращения этого
необходимо активизировать обрезание на элементе `ListView`, установив параметр `clip`
свойство в `true`. На рисунке ниже показан результат этого (вид слева) по сравнению с тем, когда свойство `clip` равно `false` (вид справа).

![[QML model_7.png]]

Для пользователя `ListView` представляет собой область с возможностью прокрутки. Он поддерживает кинетическую прокрутку, что означает, что его можно пролистывать для быстрого перемещения по содержимому. По умолчанию он также может растягиваться до
конца содержимого, а затем отскакивать назад, сигнализируя пользователю о том, что конец прокрутки достигнут.

Поведение в конце представления контролируется с помощью свойства `boundsBehavior`. Это перечисляемое значение, которое может изменяться от поведения по умолчанию, `Flickable.DragAndOvershootBounds`, когда представление можно как перетаскивать, так и пролистывать за его границы, до `Flickable.StopAtBounds`, при котором вид никогда не будет перемещаться за пределы своих границ. Средний вариант, `Flickable.DragOverBounds`, позволяет пользователю перетаскивать вид за его границы, но при этом щелчки будут останавливаться на границе.

Можно ограничить позиции, в которых разрешается останавливать вид. Это контролируется с помощью свойства `snapMode`. Поведение по умолчанию, `ListView.NoSnap`, позволяет представлению останавливаться в любой позиции. Если задать свойству `SnapMode` значение `ListView.SnapToItem`, то вид всегда будет выравниваться по верхней части элемента. И, наконец, в качестве свойства `ListView.SnapOneItem` можно использовать свойство `ListView.SnapOneItem` вид остановится не более чем на одном элементе от первого видимого элемента, когда была отпущена кнопка мыши или касание. Последний режим очень удобен при перелистывании страниц.

## Ориентация
По умолчанию представление списка обеспечивает вертикальную прокрутку списка, но горизонтальная прокрутка может быть не менее удобной. Направление прокрутки списка контролируется с помощью свойства `orientation`. Оно может быть установлено либо в значение по умолчанию `ListView.Vertical`, либо в `ListView.Horizontal`. 

Горизонтальное представление списка показано ниже.
```c++
import QtQuick
import "../common"

Background {
	width: 480
	height: 80
	
	ListView {
		anchors.fill: parent
		anchors.margins: 20
		
		spacing: 4
		clip: true
		model: 100
		
		orientation: ListView.Horizontal
		
		delegate: GreenBox {
			required property int index
			
			width: 40
			height: 40
			
			text: index
		}
	}
}
```
![[QML model_8.png]]

Как видно, по умолчанию направление горизонтальных потоков - слева направо. Это можно контролировать с помощью свойства `layoutDirection`, которое может быть установлено в значение `Qt.LeftToRight` или `Qt.RightToLeft` в зависимости от направления потока.
## Навигация и выделение на клавиатуре

При использовании `ListView` в сенсорном режиме достаточно самого представления. В сценарии с использованием клавиатуры или даже просто клавиш со стрелками для выбора элемента необходим механизм, указывающий на текущий элемент. В QML это называется
подсветкой.

Представления поддерживают делегат выделения, который отображается в представлении вместе с делегатами. Его можно рассматривать как дополнительный делегат, только он
инстанцируется только один раз и перемещается в ту же позицию, что и текущий элемент.

В приведенном ниже примере это продемонстрировано. Для того чтобы это сработало, необходимо задействовать два свойства. Во-первых, свойство `focus` устанавливается в `true`. Таким образом, `ListView` по лучает фокус клавиатуры. Во-вторых, свойство `highlight` задается для указания делегата выделения, который необходимо использовать. Делегату подсветки передаются значения `x` , `y` и высоты текущего элемента. Если ширина не указана, то используется ширина текущего элемента.

В примере для ширины используется присоединенное свойство `ListView.view.width`. Вложенные свойства, доступные делегатам, рассматриваются далее в разделе Делегаты этой главы, но полезно знать, что эти же свойства доступны и для выделенных делегатов.
```c++
import QtQuick
import "../common"

Background {
	width: 240
	height: 300
	
	ListView {
		id: view
		
		anchors.fill: parent
		anchors.margins: 20
		
		focus: true

		model: 100
		delegate: numberDelegate
		highlight: highlightComponent
		spacing: 5
		clip: true
	}
	
	Component {
		id: highlightComponent
		
		GreenBox {
			width: ListView.view ? ListView.view.width : 0
		}
	}
	
	Component {
		id: numberDelegate
		
		Item {
			id: wrapper
			required property int index
			width: ListView.view ? ListView.view.width : 0
			height: 40
			
			Text {
				anchors.centerIn: parent
				font.pixelSize: 10
				text: wrapper.index
			}
		}
	}
}
```
![[QML model_9.png]]
При использовании подсветки в сочетании со списком `ListView` можно использовать ряд свойств для управления ее поведением. Свойство `highlightRangeMode` управляет тем, как на подсветку влияет то, что отображается в представлении. Значение по умолчанию `ListView.NoHighlightRange` означает, что подсветка и видимый диапазон элементов в представлении никак не связаны. Значение `ListView.StrictlyEnforceRange` гарантирует, что выделение всегда будет видимым. Если действие попытается переместить выделение за пределы видимой части представления, то текущий элемент изменится соответствующим образом, чтобы выделение оставалось видимым.

Средним вариантом является значение `ListView.ApplyRange`. Оно пытается сохранить выделение видимым, но не изменяет текущий элемент для обеспечения этого. Вместо этого выделяемому объекту разрешается при необходимости уходить из поля зрения.

В конфигурации по умолчанию представление отвечает за перемещение выделенной области в нужное положение. Скорость перемещения и изменение размеров могут контролироваться как в виде скорости, так и в виде длительности. Для этого используются следующие свойства: `highlightMoveSpeed`, `highlightMoveDuration`, `highlightResizeSpeed` и `highlightResizeDuration`. По умолчанию

Для более детального управления перемещением выделенного объекта свойство `highlightFollowCurrentItem` может быть установлено в значение `false` . Это означает, что представление больше не отвечает за перемещение делегата выделения. Вместо этого движение можно контролировать с помощью `Behavior` или анимации. В приведенном ниже примере свойство y делегата выделения привязано к вложенному свойству `ListView.view.currentItem.y`. Это гарантирует, что выделение будет следовать за текущим элементом.

Однако, поскольку мы не позволяем представлению перемещать выделение, мы можем управлять тем, как перемещается элемент. Это делается с помощью свойства?

В приведенном ниже примере перемещение разделено на три этапа: затухание, перемещение, а затем затухание. Обратите внимание, что элементы `SequentialAnimation` и `PropertyAnimation` могут быть использованы в сочетании с `NumberAnimation`. 
```c++

Component {
	id: highlightComponent
	
	Item {
		width: ListView.view ? ListView.view.width : 0
		height: ListView.view ? ListView.view.currentItem.heigh

		y: ListView.view ? ListView.view.currentItem.y : 0
		
		Behavior on y {
			SequentialAnimation {
				PropertyAnimation { target: highlightRectangle;
					NumberAnimation { duration: 1 }
					PropertyAnimation { target: highlightRectangle;}
			}
		}
		
		GreenBox {
			id: highlightRectangle
			anchors.fill: parent
		}
	}
}
```

В каждый конец содержимого `ListView` можно вставить элемент заголовка и элемент нижнего колонтитула . Их можно рассматривать как специальные делегаты, размещаемые в начале или конце списка. Для горизонтального списка они будут располагаться не в начале и не в конце, а в начале или в конце, в зависимости от используемого `layoutDirection` . В приведенном ниже примере показано, как можно использовать верхний и нижний колонтитулы для улучшения восприятия начала и конца списка. Существуют и другие варианты использования этих специальных элементов списка. Например, они могут использоваться в качестве кнопок для загрузки дополнительного содержимого.

```c++
import QtQuick
import "../common"

Background {
	width: 240
	height: 300

	ListView {
		anchors.fill: parent
		anchors.margins: 20
		
		clip: true
		model: 4
		
		delegate: numberDelegate
		header: headerComponent
		footer: footerComponent
		spacing: 2
	}
	
	Component {
		id: headerComponent
			
		YellowBox {
			width: ListView.view ? ListView.view.width : 0
			
			height: 20
			text: 'Header'
		}
	}
	
	Component {
		id: footerComponent
		
		YellowBox {
			width: ListView.view ? ListView.view.width : 0
			height: 20
			text: 'Footer'
		}
	}
	
	Component {
		id: numberDelegate
		
		GreenBox {
			required property int index
			width: ListView.view.width
			height: 40
			text: 'Item #' + index
		}
	}
}

```

> Делегаты верхнего и нижнего колонтитулов не учитывают свойство `spacing ListView`, вместо этого они размещаются непосредственно рядом с делегатом следующего элемента в списке. Это означает, что любой интервал должен быть частью элементов верхнего и нижнего колонтитулов.
## GridView

Использование **GridView** очень похоже на использование `ListView`. Единственное отличие заключается в том, что в представлении сетки делегаты размещаются в двумерной сетке, а не в линейном списке.
![[QML Grid view.png]]
По сравнению со списочным представлением, сеточное представление не полагается на интервалы и размеры своих делегатов. Вместо этого для управления размерами делегатов содержимого используются свойства `cellWidth` и `cellHeight`. Каждый элемент делегата помещается в левый верхний угол каждой такой ячейки.
```c++
import QtQuick
import "../common"

Background {
	width: 220
	height: 300
	
	GridView {
		id: view
		anchors.fill: parent
		anchors.margins: 20
		clip: true
		model: 100
		
		cellWidth: 45
		cellHeight: 45
		
		delegate: GreenBox {
			required property int index
			width: 40
			height: 40
			text: index
		}
	}
}
```
GridView содержит верхние и нижние колонтитулы, может использовать делегат выделения и поддерживает режимы привязки, а также различные поведения границ. Он также может быть ориентирован в различных направлениях и ориентациях.

Управление ориентацией осуществляется с помощью свойства [[flow|flow]]. Оно может быть установлено в значение `GridView.LeftToRight` или `GridView.TopToBottom`. В первом случае сетка заполняется слева направо, а строки добавляются сверху вниз. Представление можно прокручивать в вертикальном направлении. Второе значение добавляет элементы сверху вниз, заполняя вид слева направо. Направление прокрутки в этом случае горизонтальное. В дополнение к свойству [[flow|flow]] свойство [[layoutDirection|layoutDirection]] может адаптировать направление сетки к языкам слева-направо или справа-налево в зависимости от используемого значения.
## Делегат

Когда речь идет об использовании моделей и представлений в пользовательском интерфейсе, делегат играет огромную роль в создании внешнего вида и поведения. Поскольку каждый элемент модели визуализируется через делегат, то то, что реально видит пользователь, - это делегаты.

Каждый делегат получает доступ к ряду присоединенных свойств, часть из которых поступает из модели данных, а часть - из представления. Из модели свойства передают делегату данные для каждого элемента. Из представления свойства передают информацию о состоянии делегата в рамках представления. Давайте рассмотрим свойства из представления.

Наиболее часто используемыми свойствами, привязанными к представлению, являются `ListView.isCurrentItem` и `ListView.view`. Первое представляет собой булево значение, указывающее, является ли элемент текущим, а второе - ссылку на реальное представление, доступную только для чтения. Благодаря доступу к представлению можно создавать общие делегаты многократного использования, которые адаптируются к размеру и характеру представления, в котором они содержатся. В приведенном ниже примере ширина каждого делегата привязана к ширине представления, а цвет фона каждого делегата зависит от вложенного свойства `ListView.isCurrentItem`
```c++
import QtQuick

Rectangle {
	width: 120
	height: 300
	
	gradient: Gradient {
		GradientStop { position: 0.0; color: "#f6f6f6" }
		GradientStop { position: 1.0; color: "#d7d7d7" }
	}

	ListView {
		anchors.fill: parent
		anchors.margins: 20
		focus: true
		model: 100
		delegate: numberDelegate
		spacing: 5
		clip: true
	}
	
	Component {
		id: numberDelegate
		
		Rectangle {
			id: wrapper
			required property int index
			
			width: ListView.view.width
			height: 40
			
			color: ListView.isCurrentItem ? "#157efb" : "#53d76
			border.color: Qt.lighter(color, 1.1)
			
			Text {
				anchors.centerIn: parent
				font.pixelSize: 10
				text: wrapper.index
			}
		}
	}
}
```
![[QML Delegat.png]]
Если каждый элемент в модели связан с действием, например, щелчок по элементу вызывает действие над ним, то эта функциональность является частью каждого делегата. Таким образом, управление событиями разделяется между представлением, которое управляет навигацией между элементами в представлении, и делегатом, который управляет действиями над конкретным элементом.

Самый простой способ сделать это - создать [[MouseArea|MouseArea]] внутри каждого делегата и действовать по сигналу [[onClicked|onClicked]] . [[Модель-Вид-Делегат#^1976b7|См.]]
## Анимация добавленных и удаленных элементов

В некоторых случаях содержимое, отображаемое в представлении, меняется с течением времени. Элементы добавляются и удаляются по мере изменения базовой модели данных. В таких случаях часто целесообразно использовать визуальные подсказки, чтобы дать пользователю возможность сориентироваться и понять, какие данные добавляются или удаляются.

Удобно, что представления QML подключают два сигнала, [[onAdd|onAdd]] и [[onRemove|onRemove]], для каждого делегата элемента. Запустив анимацию на их основе, можно легко создать движение, необходимое для идентификации пользователем происходящего.

Приведенный ниже пример демонстрирует это на примере динамически заполняемой модели `ListModel` . В нижней части экрана отображается кнопка для добавления новых элементов. При нажатии на нее в модель добавляется новый элемент с помощью метода [[append|append]] . Это вызывает создание нового делегата в представлении и выдачу сигнала `GridView.onAdd`. Запускаемая по сигналу `SequentialAnimation` с именем `addAnimation` приводит к увеличению масштаба элемента в представлении, анимируя свойство `scale` делегата.
```c++
GridView.onAdd: addAnimation.start()

SequentialAnimation {
	id: addAnimation

	NumberAnimation {
		target: wrapper
		property: "scale"
		from: 0
		to: 1
		duration: 250
		easing.type: Easing.InOutQuad
	}
}
```
При нажатии на делегат в представлении элемент удаляется из модели через вызов метода `remove`. Это приводит к выдаче сигнала `GridView.onRemove`, запускающего последовательную анимацию `removeAnimation`. Однако на этот раз уничтожение элемента делегат должен быть отложен до завершения анимации. Для этого с помощью элемента [[PropertyAction|PropertyAction]] свойству `GridView.delayRemove` присваивается значение `true` до начала анимации и `false` после. Это гарантирует, что анимация будет завершена до удаления элемента делегата.
```c++
GridView.onRemove: removeAnimation.start()

SequentialAnimation {
	id: removeAnimation
		PropertyAction { target: wrapper; property: "GridView.delay
		NumberAnimation { target: wrapper; property: "scale"; to: 0
		PropertyAction { target: wrapper; property: "GridView.delay
	}
```
Приведем полный код:
```c++
import QtQuick
Rectangle {
	width: 480
	height: 300
	
	gradient: Gradient {
		GradientStop { position: 0.0; color: "#dbddde" }
		GradientStop { position: 1.0; color: "#5fc9f8" }
	}
	
	ListModel {
		id: theModel
		ListElement { number: 0 }
		ListElement { number: 1 }
		ListElement { number: 2 }
		ListElement { number: 3 }
		ListElement { number: 4 }
		ListElement { number: 5 }
		ListElement { number: 6 }
		ListElement { number: 7 }
		ListElement { number: 8 }
		ListElement { number: 9 }
	}
	
	Rectangle {
		property int count: 9
		anchors.left: parent.left
		anchors.right: parent.right
		anchors.bottom: parent.bottom
		anchors.margins: 20
		height: 40
		color: "#53d769"
		border.color: Qt.lighter(color, 1.1)
		
		Text {
			anchors.centerIn: parent
			text: "Add item!"
		}

		MouseArea {
			anchors.fill: parent
			onClicked: {
				theModel.append({"number": ++parent.count})
			}
		}
	}
	
	GridGridView {
		anchors.fill: parent
		anchors.margins: 20
		anchors.bottomMargin: 80
		clip: true
		model: theModel
		cellWidth: 45
		cellHeight: 45
		delegate: numberDelegate
	}
	
	Component {
		id: numberDelegate
		Rectangle {
			id: wrapper
			required property int index
			required property int number
		
			width: 40
			height: 40
			
			gradient: Gradient {
				GradientStop { position: 0.0; color: "#f8306a"
				GradientStop { position: 1.0; color: "#fb5b40"
			}
			
			Text {
				anchors.centerIn: parent
				font.pixelSize: 10
				
				text: wrapper.number
			}
			
			MouseArea {
				anchors.fill: parent
				onClicked: {
					
					if (wrapper.index == -1) {
						return
					}
					
					theModel.remove(wrapper.index)
				}
			}
			
			GridView.onRemove: removeAnimation.start()
			
			SequentialAnimation {
				id: removeAnimation
				PropertyAction { target: wrapper; property: "Gr
				NumberAnimation { target: wrapper; property: "s
				PropertyAction { target: wrapper; property: "Gr
			}
			
			GridView.onAdd: addAnimation.start()
			
			SequentialAnimation {
				id: addAnimation
				
				NumberAnimation {
					target: wrapper
					property: "scale"
					from: 0
					to: 1
					duration: 250
					easing.type: Easing.InOutQuad
				}
			}
		}
	}
}
```

^1976b7
## Shape-Shifting Delegates

В списках часто используется механизм, при котором текущий элемент расширяется при активации. Это может быть использовано для динамического расширения элемента, чтобы заполнить экран для входа в новую часть пользовательского интерфейса, или для предоставления немного больше информации для текущего элемента в данном списке.

В приведенном ниже примере каждый элемент при щелчке раскрывается на весь объем содержащего его [[ListView|ListView]]. Дополнительное пространство используется для добавления дополнительной информации. Для управления этим механизмом используется состояние [[expanded|expanded]], в которое может перейти делегат каждого элемента. В этом состоянии изменяется ряд свойств. Прежде всего, высота обертки устанавливается равной высоте [[ListView|ListView]]. Затем миниатюрное изображение увеличивается и перемещается вниз, чтобы оно переместилось из своего маленького положения в большое. Кроме того, два скрытых элемента, `factsView` и `closeButton`, показываются путем изменения непрозрачности этих элементов. Наконец, настраивается [[ListView|ListView]].

Настройка [[ListView|ListView]] заключается в установке содержимого `Y`, то есть вершины видимой части представления, на значение y делегата. Другим изменением является установка интерактивности представления в `false`. Это предотвращает перемещение представления. Пользователь больше не сможет прокручивать список или изменять текущий элемент. 

При первом щелчке на элементе он переходит в расширенное состояние, в результате чего делегат элемента заполняет [[ListView|ListView]], а его содержимое перестраивается. При нажатии на кнопку закрытия состояние очищается, что приводит к возврату делегата в предыдущее состояние и повторному включению [[ListView|ListView]]
```c++
import QtQuick
Item {
	width: 300
	height: 480
	
	Rectangle {
		anchors.fill: parent
		
		gradient: Gradient {
			GradientStop { position: 0.0; color: "#4a4a4a" }
			GradientStop { position: 1.0; color: "#2b2b2b" }
		}
	}

	ListView {
		id: listView
		anchors.fill: parent
		delegate: detailsDelegate
		model: planets
	}

	ListModel {
		id: planets
		ListElement { name: "Mercury"; imageSource: "images/mer
		ListElement { name: "Venus"; imageSource: "images/venus
		ListElement { name: "Earth"; imageSource: "images/earth
		ListElement { name: "Mars"; imageSource: "images/mars.j
	}

	Component {
		id: detailsDelegate
		
		Item {
			id: wrapper
			
			required property string name
			required property string imageSource
			required property string facts
			
			width: listView.width
			height: 30
			
			Rectangle {
				anchors.left: parent.left
				anchors.right: parent.right
				anchors.top: parent.top
				height: 30
				color: "#333"
				border.color: Qt.lighter(color, 1.2)
			
				Text {
					anchors.left: parent.left
					anchors.verticalCenter: parent.verticalCent
					anchors.leftMargin: 4
					font.pixelSize: parent.height-4
					color: '#fff'
					text: wrapper.name
				}
			}
			
			Rectangle {
				id: image
				width: 26
				height: 26
				anchors.right: parent.right
				anchors.top: parent.top
				anchors.rightMargin: 2
				anchors.topMargin: 2
				color: "black"
				
				Image {
					anchors.fill: parent
					fillMode: Image.PreserveAspectFit
					source: wrapper.imageSource
				}
			}
			
			MouseArea {
				anchors.fill: parent
				onClicked: parent.state = "expanded"
			}
	
			Item {
				id: factsView
				anchors.top: image.bottom
				anchors.left: parent.left
				anchors.right: parent.right
				anchors.bottom: parent.bottom
				opacity: 0
				
				Rectangle {
					anchors.fill: parent
					
					gradient: Gradient {
						GradientStop { position: 0.0; color: "#
						GradientStop { position: 1.0; color: "#
					}
				
					border.color: '#000000'
					border.width: 2
				
					Text {
						anchors.fill: parent
						anchors.margins: 5
						clip: true
						wrapMode: Text.WordWrap
						color: '#1f1f21'
						font.pixelSize: 12
						text: wrapper.facts
					}
				}
			}
		
			Rectangle {
				id: closeButton
				anchors.right: parent.right
				anchors.top: parent.top
				anchors.rightMargin: 2
				anchors.topMargin: 2
				width: 26
				height: 26
				
				color: "#157efb"
				border.color: Qt.lighter(color, 1.1)
				opacity: 0
				
				MouseArea {
					anchors.fill: parent
					onClicked: wrapper.state = ""
				}
			}
		
			states: [
				State {
					name: "expanded"
					PropertyChanges { target: wrapper; height:...}
					PropertyChanges { target: image; width: lis...}
					PropertyChanges { target: factsView; opacit...}
					PropertyChanges { target: closeButton; opac...}
					PropertyChanges { target: wrapper.ListView....}
				}
			]
		
			transitions: [
				Transition {
					NumberAnimation {
						duration: 200;
						properties: "height,width,anchors.right
					}
				}
			]
		}
	}
}
```
![[WML Delegate_1.png]]
![[QML Delegate_2.png]]
Продемонстрированные здесь приемы расширения делегата на весь экран могут быть использованы для изменения формы делегата элемента в гораздо меньшую сторону. Например, при просмотре списка песен текущий элемент может быть немного увеличен в размерах, что позволит разместить больше информации об этом конкретном элементе.

## Advanced Techniques
### PathView
Элемент `PathView` является наиболее гибким видом представления, предоставляемым в `QtQuick`, но и наиболее сложным. Он позволяет создать представление, в котором элементы располагаются по произвольному пути. Вдоль этого пути можно детально управлять такими атрибутами, как масштаб, непрозрачность и т.д.

При использовании `PathView` необходимо определить делегата и путь. Кроме того, сам `PathView` может быть настроен с помощью ряда свойств. Наиболее распространенными из них являются `pathItemCount`, определяющее количество одновременно видимых элементов, и свойства управления диапазоном подсветки `preferredHighlightBegin`, `preferredHighlightEnd` и `highlightRangeMode`, определяющие, в какой части пути должен быть показан текущий элемент.

Прежде чем подробно рассматривать свойства элемента управления диапазоном выделения, необходимо рассмотреть свойство `path`. Свойство `path` ожидает элемент `Path`, определяющий путь, по которому будут двигаться делегаты при прокрутке `PathView`. Путь задается с помощью свойств `startX` и `startY` в комбинации с такими
элементами пути, как `PathLine`, `PathQuad` и `PathCubic` . Эти элементы
соединяются вместе, образуя два элемента размерный путь.

После того как путь определен, его можно дополнительно настроить с помощью элементов `PathPercent` и `PathAttribute` . Они располагаются между элементами пути и обеспечивают более тонкий контроль над путем и делегатами на нем. `PathPercent` определяет, насколько велика часть пути между каждым элементом. Это, в свою очередь, управляет распределением делегатов по пути, так как они распределяются пропорционально пройденному проценту.

Именно здесь в дело вступают свойства `preferredHighlightBegin` и `preferredHighlightEnd` программы `PathView`. Оба они ожидают реальных значений в диапазоне от нуля до единицы. Также ожидается, что конец будет больше или равен началу. Если установить оба этих свойства, например, в 0.5, то текущий элемент будет отображаться в пятидесятипроцентном месте пути. В контуре `Path`, элементы `PathAttribute` располагаются между элементами, как и элементы `PathPercent`. Они позволяют задавать значения свойств, которые интерполируются вдоль пути. Эти свойства привязываются к делегатам и могут использоваться для управления любыми возможными свойствами.
![[QML Path.png]]
Приведенный ниже пример демонстрирует, как элемент `PathView` используется для создания представления карт, которые пользователь может перелистывать. Для этого используется ряд приемов. Путь состоит из трех элементов `PathLine`. С помощью элементов `PathPercent` центральный элемент правильно центрируется и получает достаточно места, чтобы его не загромождали другие элементы. С помощью элементов `PathAttribute` осуществляется управление поворотом, размером и z-значением.

В дополнение к пути , свойство `pathItemCount` в `PathView` была установлена. Это определяет, насколько плотно будет заселен путь. В поле `preferredHighlightBegin` и `preferredHighlightEnd` `PathView.onPath` используется для управления видимостью делегатов.
```c++
PathView {
	anchors.fill: parent
	model: 100
	delegate: flipCardDelegate
	
	path: Path {
		startX: root.width / 2
		startY: 0
		
		PathAttribute { name: "itemZ"; value: 0 }
		PathAttribute { name: "itemAngle"; value: -90.0; }
		PathAttribute { name: "itemScale"; value: 0.5; }
		
		PathLine { x: root.width / 2; y: root.height * 0.4; }
		PathPercent { value: 0.48; }
		PathLine { x: root.width / 2; y: root.height * 0.5; }

		PathAttribute { name: "itemAngle"; value: 0.0; }
		PathAttribute { name: "itemScale"; value: 1.0; }
		PathAttribute { name: "itemZ"; value: 100 }
		
		PathLine { x: root.width / 2; y: root.height * 0.6; }
		PathPercent { value: 0.52; }
		PathLine { x: root.width / 2; y: root.height; }
		
		PathAttribute { name: "itemAngle"; value: 90.0; }
		PathAttribute { name: "itemScale"; value: 0.5; }
		PathAttribute { name: "itemZ"; value: 0 }
	}

	pathItemCount: 16
	preferredHighlightBegin: 0.5
	preferredHighlightEnd: 0.5
}
```
Делегат, показанный ниже, использует присоединенные свойства `itemZ`, [[itemAngle|itemAngle]] и [[itemScale|itemScale]] из элементов [[PathAttribute|PathAttribute]].

Стоит заметить, что присоединенные свойства делегата доступны только из обертки. Так, свойство `rotX` определено для того, чтобы можно было получить доступ к его значению из элемента [[Rotation|Rotation]].

Еще одна деталь, характерная для `PathView`, на которую стоит обратить внимание, - это использование присоединенного свойства `PathView.onPath`. Обычно принято привязывать к нему видимость, поскольку это позволяет `PathView` сохранять невидимые элементы для целей кэширования. Обычно это не удается сделать с помощью обрезки, поскольку делегаты элементов в `PathView` размещаются более свободно, чем делегаты элементов в представлениях [[Модель-Вид-Делегат#Динамические представления|ListView]] или [[Модель-Вид-Делегат#GridView|GridView]] 
```c++
Component {
	id: flipCardDelegate

	BlueBox {
		id: wrapper
		required property int index
		property real rotX: PathView.itemAngle
		visible: PathView.onPath
		width: 64
		height: 64
		scale: PathView.itemScale
		z: PathView.itemZ
		antialiasing: true
		
		gradient: Gradient {
			GradientStop { position: 0.0; color: "#2ed5fa" }
			GradientStop { position: 1.0; color: "#2467ec" }
		}

		transform: Rotation {
			axis { x: 1; y: 0; z: 0 }
			angle: wrapper.rotX
```
При преобразовании изображений или других сложных элементов в `PathView` часто используется прием оптимизации производительности, заключающийся в привязке свойства [[smooth|smooth]] элемента `Image` к присоединенному свойству `PathView.view.moving`. Это означает, что при движении изображения становятся менее красивыми, а при неподвижности плавно трансформируются. Нет смысла тратить вычислительную мощность на плавное масштабирование, когда изображение находится в движении, поскольку пользователь все равно не сможет этого увидеть.

> - Учитывая динамическую природу `PathAttribute`, инструментарий `qml` (в данном случае: `qmllint`) не знает ни `itemZ`, ни `itemAngle`, ни `itemScale`.

При использовании `PathView` и программном изменении `currentIndex` может возникнуть необходимость контролировать направление движения пути. Это можно сделать с помощью свойства [[movementDirection|movementDirection]]. Оно может быть установлено в значение `PathView.Shortest`, которое используется по умолчанию. Это означает, что движение может осуществляться в любом направлении, в зависимости от того, какой путь является наиболее близким для перемещения к целевому значению. Вместо этого направление можно ограничить, установив для свойства [[movementDirection|movementDirection]] значение `PathView.Negative` или `PathView.Positive`. 

## Table Models

Все рассмотренные до сих пор представления так или иначе представляют массив элементов. Даже [[Модель-Вид-Делегат#GridView|GridView]] ожидает, что модель предоставит одномерный список элементов. Для двумерных таблиц данных необходимо использовать элемент **TableView**.
Table Models похож на другие представления тем, что объединяет модель с делегатом для формирования сетки. Если ему дана модель, ориентированная на список, то он отображает один столбец, что делает его очень похожим на элемент [[Модель-Вид-Делегат#Динамические представления|ListView]] . Однако он может отображать и двумерные модели, в которых явно определены
столбцы и строки. 

В приведенном ниже примере мы создали простую таблицу **TableView** с пользовательской моделью, открываемой из C++. В настоящее время создание таблично-ориентированных моделей непосредственно из QML невозможно, но в #главе_Qt_и_C_++ эта концепция объясняется. Работающий пример показан на рисунке ниже.
![[QML TableView.png]]
В приведенном ниже примере мы создаем **TableView** и устанавливаем свойства [[rowSpacing|rowSpacing]] и [[columnSpacing|columnSpacing]] для управления горизонтальными и вертикальными промежутками между делегатами. Остальные свойства настраиваются так же, как
и для любого другого типа.
```c++
TableView {
	id: view
	anchors.fill: parent
	anchors.margins: 20
	rowSpacing: 5
	columnSpacing: 5
	clip: true
	model: tableModel
	delegate: cellDelegate
}
```
Сам делегат может нести неявный размер через [[implicitWidth|implicitWidth]] и [[implicitHeight|implicitHeight]] . Именно это мы и делаем в приведенном ниже примере.

```c++
Component {
	id: cellDelegate
	
	GreenBox {
		id: wrapper
		required property string display
		
		implicitHeight: 40
		implicitWidth: 40
		
		Text {
			anchors.centerIn: parent
			text: wrapper.display
		}
	}
}
```
В зависимости от содержания модели можно предоставлять делегатов разных размеров, например
```c++
GreenBox {
	implicitHeight: (1 + row) * 10
	// ...
}
```
Обратите внимание, что и ширина, и высота должны быть больше нуля.

При указании неявного размера из делегата размером управляет самый высокий делегат каждой строки и самый широкий делегат каждого столбца. Это может привести к интересному поведению, если ширина элементов зависит от строки, а высота - от столбца. Это связано с тем, что не все делегаты инстанцируются постоянно, поэтому ширина столбца может меняться по мере прокрутки таблицы пользователем.

Чтобы избежать проблем с указанием ширины столбцов и высоты строк с использованием неявных размеров делегата, можно предоставить функции, вычисляющие эти размеры. Для этого используются функции [[columnWidthProvider|columnWidthProvider]] и [[rowHeightProvider|rowHeightProvider]] . Эти функции возвращают размер ширины и высоты строки соответственно, как показано ниже:
```c++
TableView {
	columnWidthProvider: function (column) { return 10 * (colum)}
	// ...
}
```
Если необходимо динамически изменить ширину столбцов или высоту строк, необходимо уведомить об этом представление, вызвав метод [[forceLayout|forceLayout]] . Это заставит представление заново рассчитать размер и положение всех ячеек.

## Модель из XML

Поскольку XML является повсеместно распространенным форматом данных, в QML предусмотрен элемент [[XmlListModel|XmlListModel]] , который представляет XML-данные в виде модели. Этот элемент может получать XML-данные локально или удаленно, а затем обрабатывать их с помощью выражений `XPath`.

Приведенный ниже пример демонстрирует получение изображений из
потока RSS. Свойство source ссылается на удаленное местоположение
по протоколу HTTP, и данные загружаются автоматически.
![[QML XML.png]]
После загрузки данных они преобразуются в элементы и роли модели. Свойство `query` модели [[XmlListModel|XmlListModel]] - это `XPath`, представляющий базовый запрос для создания элементов модели. В данном примере путь - `/rss/channel/item`, поэтому для каждого тега `item`, находящегося внутри тега `channel`, внутри тега RSS, создается элемент модели.

Для каждого элемента модели извлекается ряд ролей. Они представлены элементами `XmlListModelRole` . Каждой роли присваивается имя, к которому делегат может получить доступ через присоединенное свойство. Фактическое значение каждого такого свойства определяется через свойства `elementName` и (необязательно) `attributeName` для каждой роли. Например, свойство `title` соответствует XML-элементу `title`, возвращая содержимое между тегами `<title>` и `</title>`.

Свойство [[imageSource|imageSource]] извлекает значение атрибута тега вместо его содержимого. В данном случае в виде строки извлекается атрибут `url` тега `enclosure`. Свойство [[imageSource|imageSource]] может быть использовано непосредственно в качестве источника для элемента `Image`, который загружает изображение с заданного URL.
```c++
import QtQuick
import QtQml.XmlListModel
import "../common"

Background {
	width: 300
	height: 480
	
	Component {
		id: imageDelegate
		
		Box {
			id: wrapper
			required property string title
			required property string imageSource
			width: listView.width
			height: 220
			color: '#333'
			
			Column {
				
				Text {
					text: wrapper.title
					color: '#e0e0e0'
				}
			
				Image {
					width: listView.width
					height: 200
					fillMode: Image.PreserveAspectCrop
					source: wrapper.imageSource
				}
			}
		}
	}
	
	XmlListModel {
		id: imageModel
		source: "https://www.nasa.gov/rss/dyn/image_of_the_day.
		query: "/rss/channel/item"
		XmlListModelRole { name: "title"; elementName: "title"}
		XmlListModelRole { name: "imageSource"; elementName: "e}
	}
	
	ListView {
		id: listView
		anchors.fill: parent
		model: imageModel
		delegate: imageDelegate
	}
}
```
## Списки с разделами
Иногда данные в списке можно разделить на разделы. Это может быть простое разделение списка контактов на разделы под каждой буквой алфавита или музыкальных треков на альбомы. Используя [[Модель-Вид-Делегат#Динамические представления|ListView]], можно разделить плоский список на категории, обеспечив большую глубину восприятия.
![[QML List.png]]
Для того чтобы использовать секции, необходимо настроить `section.property` и `section.criteria`. Свойство `section.property` определяет, какое свойство использовать для разделения содержимого на секции. Здесь важно знать, что для разделения содержимого на секции используется свойство модель должна быть отсортирована таким образом, чтобы каждая секция состояла из непрерывных элементов, иначе одно и то же имя свойства может появиться в нескольких местах.

Критерий `section.criteria` может быть установлен либо как `ViewSection.FullString` или `ViewSection.FirstCharacter`. Первый вариант является значением по умолчанию и может использоваться для моделей, имеющих прозрачные секции, например, треки музыкальных альбомов. Второе значение принимает первый символ свойства и означает, что для этого может быть использовано любое свойство. Наиболее распространенный пример - фамилия контактов в телефонной книге.

После определения разделов к ним можно обращаться из каждого элемента с помощью подключаемых свойств `ListView.section`, `ListView.previousSection` и `ListView.nextSection`. С помощью этих свойств можно определить первый и последний элемент секции и действовать соответствующим образом.

Также можно назначить компонент делегата раздела свойству `section.delegate` [[Модель-Вид-Делегат#Динамические представления|ListView]] . При этом создается делегат заголовка раздела, который вставляется перед любыми элементами раздела. Компонент-делегат может получить доступ к имени текущего раздела с помощью присоединенного свойства `section`.

Приведенный ниже пример демонстрирует концепцию секций, показывая список космонавтов, разделенных по национальному признаку. Национальность используется в качестве свойства `section.property`. Компонент `section.delegate`, `sectionDelegate`, показывает заголовок для каждой нации, отображая ее название. В каждом разделе с помощью компонента `spaceManDelegate` отображаются имена космонавтов.
```c++
import QtQuick
import "../common"

Background {
	width: 300
	height: 290
	
	ListView {
		anchors.fill: parent
		anchors.margins: 20
		clip: true
		model: spaceMen
		delegate: spaceManDelegate
		section.property: "nation"
		section.delegate: sectionDelegate
	}
	
	Component {
		id: spaceManDelegate
		
		Item {
			id: spaceManWrapper
			required property string name
			width: ListView.view.width
			height: 20
			
			Text {
				anchors.left: parent.left
				anchors.verticalCenter: parent.verticalCenter
				anchors.leftMargin: 8
				font.pixelSize: 12
				text: spaceManWrapper.name
				color: '#1f1f1f'
			}
		}
	}
	
	Component {
		id: sectionDelegate
		
		BlueBox {
			id: sectionWrapper
			required property string section
			width: ListView.view ? ListView.view.width : 0
			height: 20
			text: sectionWrapper.section
			fontColor: '#e0e0e0'
		}
	}
	
	ListModel {
		id: spaceMen
		
		ListElement { name: "Abdul Ahad Mohmand"; nation: "Afga}
		ListElement { name: "Marcos Pontes"; nation: "Brazil";}
		ListElement { name: "Alexandar Panayotov Alexandrov"; n}
		ListElement { name: "Georgi Ivanov"; nation: "Bulgaria"}
		ListElement { name: "Roberta Bondar"; nation: "Canada";}
		ListElement { name: "Marc Garneau"; nation: "Canada"; }
		ListElement { name: "Chris Hadfield"; nation: "Canada";}
		ListElement { name: "Guy Laliberte"; nation: "Canada";}
		ListElement { name: "Steven MacLean"; nation: "Canada";}
		ListElement { name: "Julie Payette"; nation: "Canada";}
		ListElement { name: "Robert Thirsk"; nation: "Canada";}
		ListElement { name: "Bjarni Tryggvason"; nation: "Canad}
		ListElement { name: "Dafydd Williams"; nation: "Canada"}
	}
}

```
## Объектная модель

В некоторых случаях требуется использовать представление списка для большого набора различных элементов. Это можно решить с помощью динамического QML и [[Loader|Loader]], но есть и другой вариант - использовать объектную модель из модуля `QtQml.Models`. Объектная модель отличается от других моделей тем, что позволяет поместить фактический визуальных элементов на стороне модели. Таким образом, представлению не требуется делегат.
![[QML Object.png]]
В приведенном ниже примере мы поместили в `ObjectModel` три элемента [[Основные элементы#Прямоугольный элемент|Rectangle]] . Однако у одного прямоугольника есть дочерний элемент [[Основные элементы#Текстовый элемент|Text]] , а у последнего - закругленные углы. Это привело бы к созданию модели в стиле таблицы с использованием чего-то вроде [[Модель-Вид-Делегат#Использование модели ListModel|ListModel]] . Это также привело бы к появлению в модели пустых элементов [[Основные элементы#Текстовый элемент|Text]].
```c++
import QtQuick
import QtQml.Models

Rectangle {
	width: 320
	height: 320
	
	gradient: Gradient {
		GradientStop { position: 0.0; color: "#f6f6f6" }
		GradientStop { position: 1.0; color: "#d7d7d7" }
	}
	
	ObjectModel {
			id: itemModel
		
		Rectangle { height: 60; width: 80; color: "#157efb" }
		Rectangle { height: 20; width: 300; color: "#53d769"}
		
		Text { anchors.centerIn: parent; color: "black"; te}
	}
	
	Rectangle { height: 40; width: 40; radius: 10; color: "}
	}
	
	ListView {
			anchors.fill: parent
			anchors.margins: 10
			spacing: 5
			model: itemModel
	}
}
```
Еще одним аспектом модели `ObjectModel` является возможность ее динамического наполнения с помощью методов `get`, `insert', move , remove и clear . Таким образом, содержимое модели может динамически генерироваться из различных источников и при этомлегко отображаться в одном представлении.

## Модели с действиями
Тип [[ListElement|ListElement]] поддерживает привязку Javascript-функций к свойствам. Это означает, что функции можно поместить в модель. Это очень удобно при построении меню с помощью действий и других подобных конструкций.

Приведенный ниже пример демонстрирует это на примере модели городов, которые приветствуют вас различными способами. Модель `actionModel` представляет собой модель четырех городов, но свойство `hello` привязано к функциям. Каждая функция принимает аргумент `value`, но аргументов может быть любое количество.

В делегате `actionDelegate` [[MouseArea|MouseArea]] вызывает функцию `hello` как обычную функцию, что приводит к вызову соответствующего свойства `hello` в модели.
```c++
import 

Rectangle {
	width: 120
	height: 300
	
	gradient: Gradient {
		GradientStop { position: 0.0; color: "#f6f6f6" }
		GradientStop { position: 1.0; color: "#d7d7d7" }
	}
	
	ListModel {
		id: actionModel
		
		ListElement {
			name: "Copenhagen"
			hello: function(value) { console.log(value + ": You")}
		}
		
		ListElement {
			name: "Helsinki"
			hello: function(value) { console.log(value + ": Hel")}
		}

		ListElement {
			name: "Oslo"
			hello: function(value) { console.log(value + ": Hei")}
		}
		
		ListElement {
			name: "Stockholm"
			hello: function(value) { console.log(value + ": Sto")}
		}
	}
	
	ListView {
		anchors.fill: parent
		anchors.margins: 20
		focus: true
		model: actionModel
		
		delegate: Rectangle {
			id: delegate
			required property int index
			required property string name
			required property var hello
			width: ListView.view.width
			height: 40
			color: "#157efb"
			
			Text {
				anchors.centerIn: parent
				font.pixelSize: 10
				text: delegate.name
			}
			
			MouseArea {
				anchors.fill: parent
				onClicked: delegate.hello(delegate.index)
			}
		}
		
spacing: 5
clip: true
	}
}
```
## Настройка производительности
Воспринимаемая производительность представления модели очень сильно зависит от времени, необходимого для подготовки новых делегатов. Например, при прокрутке [[Модель-Вид-Делегат#Динамические представления|ListView]] вниз делегаты добавляются сразу за пределы представления снизу и удаляются сразу после того, как они выходят из поля зрения над верхней частью представления. Это становится очевидным, если свойству `clip` присвоено значение `false`. Если делегаты требуют слишком много времени на инициализацию, и это станет очевидным для пользователя, как только представление будет прокручено слишком быстро.

Чтобы обойти эту проблему, можно настроить поля в пикселях по бокам прокручиваемого представления. Для этого используется свойство `cacheBuffer`. В описанном выше случае вертикальной прокрутки оно будет контролировать, на сколько пикселей выше и ниже [[Модель-Вид-Делегат#Динамические представления|ListView]] будут располагаться подготовленные делегаты. Комбинируя это с асинхронной загрузкой элементов `Image`, можно, например, дать время изображениям загрузиться до того, как они будут выведены на экран.

При большем количестве делегатов приходится жертвовать памятью ради более плавной работы и чуть большего времени на инициализацию каждого делегата. Это не решает проблему сложных делегатов. Каждый раз при инстанцировании делегата его содержимое оценивается и компилируется. На это требуется время, и если оно слишком велико, то это приведет к ухудшению качества прокрутки. Наличие большого количества элементов в делегате также снижает производительность прокрутки. Просто на перемещение большого количества элементов тратятся циклы.

Для устранения двух последних проблем рекомендуется использовать элементы [[Loader|Loader]]. Они могут использоваться для инстанцирования дополнительных элементов, когда это необходимо. Например, расширяющийся делегат может использовать [[Loader|Loader]], чтобы отложить инстанцирование своего детального представления до тех пор, пока оно не понадобится. По этой же причине полезно свести к минимуму количество JavaScript в каждом делегате. Лучше позволить им вызывать сложные фрагменты JavaScript, находящиеся вне каждого делегата. Это уменьшает время, затрачиваемое на компиляцию JavaScript при каждом создании делегата.

> Следует помнить, что использование [[Loader|Loader]] для отсрочки инициализации как раз и приводит к отсрочке проблемы производительности. Это означает, что производительность прокрутки будет улучшена, но для появления реального содержимого все равно потребуется время.

## Резюме
В этой главе мы рассмотрели модели, представления и делегаты. Для каждой записи данных в модели представление инстанцирует делегат, визуализирующий эти данные. Таким образом, данные отделяются от представления.

Модель может представлять собой одно целое число, в котором делегату передается переменная `index`. Если в качестве модели используется массив `JavaScript`, то переменная `modelData` представляет данные текущего индекса массива, а `index` хранит индекс. Для более сложных случаев, когда каждому элементу данных необходимо предоставить несколько значений, лучшим решением будет использование `ListModel`, заполненного элементами ListElement .

Для статических моделей в качестве представления может быть использован репитер . Его легко комбинировать с позиционерами типа `Row`, `Column`, `Grid` или `Flow` для построения частей пользовательского интерфейса. Для динамических или больших моделей данных более подходящими являются такие представления, как `ListView`, `GridView` или `TableView`. Они создают экземпляры делегатов "на лету", по мере необходимости, уменьшая количество элементов, одновременно находящихся в сцене.

Разница между `GridView` и `TableView` заключается в том, что табличное представление предполагает модель табличного типа с несколькими столбцами данных, а грид-представление отображает модель списочного типа в виде сетки.

Делегаты, используемые в представлениях, могут быть статическими элементами со свойствами, привязанными к данным из модели, или динамическими, состояние которых зависит от того, находятся они в фокусе или нет. Используя сигналы `onAdd` и `onRemove` функции В режиме просмотра их можно даже анимировать, когда они появляются и исчезают.

