# Qt для MCU

> Qt for MCUs входит не в дистрибутив Qt с открытым исходным кодом, а в качестве коммерческого дополнения.

Qt for MCUs - это версия Qt, предназначенная для платформ, которые слишком малы для работы с Linux. Вместо этого Qt for MCUs может работать поверх **FreeRTOS** или даже на "голом металле", т.е. без участия какой-либо операционной системы. Поскольку в этой книге основное внимание уделяется QML, мы более подробно рассмотрим Qt Quick Ultralite и сравним его с полноразмерным предложением Qt.

Используя Qt for MCUs, вы можете создавать красивые, плавные графические интерфейсы пользователя для систем на базе микроконтроллеров. Qt для MCUs ориентирован на графический фронт-энд, поэтому вместо традиционных модулей Qt используются обычные типы C++. Это означает, что некоторые интерфейсы меняются. В первую очередь это касается того, как модели отображаются в QML. В этой главе мы рассмотрим это и многое другое.

## Настройка

Qt for MCUs (https://doc.qt.io/QtForMCUs/index.html) поставляется с поддержкой ряда оценочных плат от таких компаний, как NCP, Renesas, ST и Infinion/Cypress. Они хороши для начала работы и помогают опробовать интеграцию с конкретным MCU. В конечном итоге, скорее всего, придется настраивать конкретное определение платформы под конкретное оборудование, например, настраивать объем оперативной памяти, FLASH и конфигурацию экрана.

![[QML MCU.png]]

Помимо поддержки нескольких MCU из коробки, Qt for MCUs также поддерживает работу либо с **FreeRTOS**, либо непосредственно на "голом металле", т.е. без операционной системы. Поскольку Qt for MCUs ориентирован на графический фронт-энд, в нем нет классов для файловых систем и т.п. Все это должно исходить от базовой системы. Поэтому, если вам нужна поддержка более сложных функций, то **FreeRTOS** - это один из вариантов.

Что касается среды разработки, то различные платы поставляются с различными компиляторами, поэтому настройка Qt for MCUs будет выглядеть несколько по-разному в зависимости от того, на какой MCU вы ориентируетесь, а также от того, какой компилятор вы выберете. Например, для плат от ST поддерживаются GCC и IAR, а для некоторых других плат используется Green Hills MULTI Compiler. Официально поддерживаемыми хостами разработки с точки зрения Qt являются Linux (Ubuntu 20.04 LTS на x86_64) или Windows (Windows 10 на x86_64). Для Windows обратите внимание, что поддерживаются компиляторы MSVC редакций 2017 и 2019 - не самые последние. Для получения рабочей среды обязательно следуйте последним инструкциям по настройке на сайте qt.io (https://doc.qt.io/QtForMCUs/qtul-setup- development-host.html). 

После настройки среды поддерживаемые платы можно найти в разделе Kits, а также в разделе Devices - MCU под пунктом меню Tools - Options... в Qt Creator.

![[QML MCU 2.png]]

![[QML MCU 3.png]]

> Если вы не нашли вкладку MCUs в разделе Tools, убедитесь, что подключаемые модули Qt for MCUs (McuSupport и BaremetalSupport) доступны и активированы в разделе Help - About Plugins.....

> Дополнительная информация на сайте qt.io:
> -Поддерживаемые платы
> Руководство по портированию платформ

## Hello World - для микроконтроллеров

Поскольку настройка Qt для MCU может быть несколько затруднительной, мы начнем с примера типа Hello World, чтобы убедиться в работоспособности инструментария и обсудить основные различия между Qt Quick Ultralite и стандартным Qt Quick.

Прежде всего, нам необходимо создать проект Qt for MCUs в Qt Creator, чтобы получить точку входа в систему на языке C++. При работе с Qt Quick Ultralite мы не можем использовать обычную среду выполнения, такую как qml . Это связано с тем, что Qt Quick Ultralite транслируется на C++ вместе с оптимизированными версиями всех активов. Затем они встраиваются в целевой исполняемый файл. Это означает, что нет поддержки динамической загрузки QML и т.п., поскольку на целевом исполняемом файле не работает интерпретатор.

![[QML MCU 4.png]]

Я называю проект helloworld . Не стесняйтесь выбрать собственное имя. Единственное, что изменится, - это имя QML-файла проекта, являющегося точкой входа.

![[QML MCU 5.png]]

Кроме того, при создании проекта обязательно выберите набор Qt for MCUs.

![[QML MCU 6.png]]

Пройдя еще несколько страниц настройки, вы получите проект, как показано ниже.

![[QML MCU 7.png]]

После того как базовый проект настроен, запустите его на рабочем столе и убедитесь, что появилось окно, подобное показанному ниже.

![[QML MCU 8.png]]

Теперь, когда мы знаем, что установка работает, замените QML в файле `helloworld.qml` на код, показанный ниже. Ниже мы рассмотрим этот пример построчно, но сначала соберите и запустите его для вашей целевой программы Qt for MCU Desktop. В результате должно появиться окно, похожее на скриншот, приведенный ниже.

```c++
import QtQuick
import QtQuickUltralite.Extras

Rectangle {
	width: 480
	height: 272
	
	Rectangle {
		id: rect
		anchors.fill: parent
		anchors.margins: 60
		color: "orange"

		Behavior on color {
			ColorAnimation { duration: 400 }
		}
		
		MouseArea {
			anchors.fill: parent
			
			onClicked: {
				if (rect.color == "red")
					rect.color = "orange";
				else
					rect.color = "red";
			}
		}
	}
	
	StaticText {
		anchors.centerIn: parent
		color: "black"
		text: "Hello World!"
		font.pixelSize: 52
	}
}
```

![[QML MCU 9.png]]

Щелкните на оранжевом прямоугольнике, и он станет красным. Щелкните его еще раз, и он снова станет оранжевым.

![[QML MCU 10.png]]

Теперь давайте посмотрим на исходный код с точки зрения Qt Quick и сравним.

Во-первых, Qt Quick Ultralight игнорирует номера версий после операторов импорта. Это поддерживается и в Qt Quick, начиная с Qt 6, за счет отсутствия номер версии, поэтому если вы можете обойтись без него, но вам нужна совместимость, оставьте номер версии.

```c++
import QtQuick
import QtQuickUltralite.Extras
```

В корне нашей сцены мы размещаем прямоугольник `Rectangle`. Это связано с тем, что Qt Quick Ultralite не предоставляет белый фон по умолчанию. Используя в качестве корня `Rectangle`, мы обеспечиваем контроль над цветом фона сцены.

```c++
Rectangle {
	width: 480
	height: 272
```

Следующая часть, прямоугольник с возможностью щелчка, представляет собой простой QML, с некоторым количеством Javascript, привязанным к событию `onClicked` . Qt для MCU имеет ограниченную поддержку Javascript, поэтому старайтесь, чтобы такие сценарии были простыми. Более подробно о конкретных ограничениях можно прочитать в ссылках в конце этого раздела.

```c++
Rectangle {
	id: rect
	anchors.fill: parent
	anchors.margins: 60
	color: "orange"
	
	Behavior on color {
		ColorAnimation { duration: 400 }
	}
	
	MouseArea {
		anchors.fill: parent
		
		onClicked: {
			if (rect.color == "red")
				rect.color = "orange";
			else
				rect.color = "red";
		}
	}
}
```

Наконец, текст выводится с помощью элемента `StaticText` , который представляет собой версию элемента `Text` для статических текстов. Это означает, что текст может быть отрисован один раз или даже предварительно отрендерен, что позволяет сэкономить много ресурсов на небольшой системе на базе MCU.

```c++
StaticText {
	anchors.centerIn: parent
	color: "black"
	text: "Hello World!"
	font.pixelSize: 52
}
```

В Qt Creator можно заметить, что появляются предупреждения вокруг Элемента `StaticText`. Это происходит потому, что Qt Creator предполагает, что вы работаете с Qt Quick. Для того чтобы Qt Creator знал Qt Quick Ultralite, необходимо установить параметр `QML_IMPORT_PATH` на путь к модулю совместимости с Qt for MCUs. Это можно сделать в файле [[CMakeLists.txt|CMakeLists.txt]] или в настройках проекта. Настройки проекта для стандартной установки Windows 10 приведены ниже.

![[QML MCU 11.png]]

Помимо того, что было сказано выше, есть и другие отличия. Например, в классе Qt Quick Ultralite Item , а значит, и в классе `Rectangle`, отсутствуют многие свойства, которые можно было бы найти в Qt Quick. Например, отсутствуют свойства масштабирования и вращения . Они доступны только для таких специфических элементов, как `Image` , и там вместо свойств используются типы `Rotation` и `Scale`. Если выйти за рамки приведенного примера, то в целом в Qt Quick Ultralite меньше QML-элементов, но поддерживаемые типы постоянны увеличивается. Мы стремимся к тому, чтобы предоставляемые типы покрывали все случаи использования целевых устройств. Более подробно об этом и об общих вопросах совместимости можно прочитать в приведенных ниже ссылках.

> Дополнительная информация на сайте qt.io:
> - Qt Quick Ultralite против Qt Quick
> - Различия между Qt Quick Ultralite Controls и Qt Quick Controls
> - Известные проблемы и ограничения

## Интеграция с C++
### C++

Для того чтобы продемонстрировать связь между C++ и QML в Qt for MCUs, мы создадим простой синглтон `Counter`, хранящий целочисленное значение. Обратите внимание, что мы начинаем со структуры, а не с класса . Это обычная практика в Qt Quick Ultralite.

Синглтон будет использоваться из небольшого пользовательского интерфейса, как показано ниже.

![[QML MCU 12.png]]

Структура `Counter` предоставляет свойство `value`, а также методы для изменения значения, `increase` и `decrease`, а также метод сброса. Кроме того, в ней предусмотрен сигнал [[hasBeenReset|hasBeenReset]]

```c++
#ifndef COUNTER_H
#define COUNTER_H

#include <qul/singleton.h>
#include <qul/property.h>
#include <qul/signal.h>

class Counter : public Qul::Singleton<Counter>
{
	public:
		Counter();
		Qul::Property<int> value;
		
		void increase();
		void decrease();
		void reset();
		Qul::Signal<void(void)> hasBeenReset;
};
#endif // COUNTER_H
```

Со стороны Qt это выглядит странно. Именно здесь Qt для MCUs демонстрирует основные отличия. Здесь нет базового класса [[QObject|QObject]] или макроса Q_OBJECT , вместо этого используется новый набор классов из Qul . В данном конкретном случае базовым классом является класс `Qul::Singleton` , создающий глобально доступный синглтон в мире QML. Мы также используем класс `Qul::Signal` для  создания сигнала и класс `Qul::Property` для создания свойства. Все публичные, не перегруженные функции-члены раскрываются в QML автоматически.

> Для создания элемента, который может быть инстанцирован из QML, вместо синглтона используйте базовый класс [[Object|Qul::Object]].

Затем эта структура выводится в QML с помощью макроса [[CMake|CMake]] `qul_target_generate_interfaces`. Ниже приведен [[CMakeLists.txt|CMakeLists.txt]], основанный на файле, сгенерированном Qt Creator, с добавленными файлами `counter.h` и `counter.cpp`.

```sh
qul_target_generate_interfaces(cppintegration counter.h)
```

Теперь продолжим реализацию структуры `Counter` . Во-первых, для свойства `value` мы используем функции `value` и `setValue` для доступа и модификации фактического значения. В нашем случае свойство содержит и [[int|int]], но, как и для обычного движка QML, типы отображаются между C++ и QML (https://doc.qt.io/QtForMCUs/qtul-integratecppqml.html#type-mapping).

Это используется в конструкторе, показанном ниже, который устанавливает начальное значение в ноль.

```c++
Counter::Counter()
{
	value.setValue(0);
}
```

Функции увеличения и уменьшения выглядят аналогично. Они используют геттер и сеттер вместо того, чтобы взаимодействовать непосредственно со значением.

```c++
void Counter::increase()
{
	value.setValue(value.value()+1);
}

void Counter::decrease()
{
	value.setValue(value.value()-1);
}
```

Счетчик также имеет сигнал. Сигнал представлен экземпляром `Qul::Signal` с именем `hasReset`. В качестве шаблонного аргумента сигнал принимает сигнатуру функции, поэтому для создания сигнала, несущего целое число, создать `Qul::Signal<void(int)>`. В данном случае сигнал не несет никаких значений, поэтому он определяется как `void(void)`. Чтобы издать сигнал, мы просто вызываем его, как если бы это была обычная функция, как показано в функции `reset` ниже.

```c++
void Counter::reset()
{
	std::cout << "Resetting from " << value.value() << std::end
	value.setValue(0);
	hasBeenReset();
}
```

### QML

Код QML создает простой пользовательский интерфейс, показанный ниже.

![[QML MCU 13.png]]

Мы рассмотрим пользовательский интерфейс в трех частях. Во-первых, основная структура и привязки к `Counter.value`:

```c++
import QtQuick

Rectangle {
	width: 480
	height: 272
	
	Column {
	// Left buttons goes here
	}
	
	Column {
	// Right buttons goes here
	}
	
	Text {
		anchors.centerIn: parent
		text: Counter.value;
	}
}
```

Как видно, свойство `text` элемента `Text` привязано к элементу Счетчик-значение, как и во всех QML.

Теперь рассмотрим левые боковые кнопки. Они используются для вызова методов C++, предоставляемых через синглтон `Counter`. `PlainButton` - это QML-элемент, который мы используем для создания этих простых кнопок. Он позволяет задать текст, цвет фона и обработчик сигнала нажатия . Как видно, каждая кнопка вызывает соответствующий метод синглтона `Counter`.

```c++
Column {
	x: 10
	y: 10
	spacing: 5
	
	PlainButton {
		text: "+"
		onClicked: Counter.increase()
	}
	
	PlainButton {
		text: "reset"
		onClicked: Counter.reset()
	}
	
	PlainButton {
		text: "-"
		onClicked: Counter.decrease()
	}
}
```

Кнопки справа изменяют значение `Counter.value` непосредственно из QML. Это возможно сделать, но невидимо для C++. В языке C++ нет простого способа отследить изменение свойства, поэтому, если необходима реакция C++, рекомендуется использовать метод сеттера, а не напрямую изменять значение свойства.

```c++
Column {
	x: 350
	y: 10
	spacing: 5
	
	PlainButton {
		color: "orange"
		text: "++"
		onClicked: Counter.value += 5;
	}
	
	PlainButton {
		color: "orange"
		text: "100"
		onClicked: Counter.value = 100;
	}

	PlainButton {
		color: "orange"
		text: "--"
		onClicked: Counter.value -= 5;
	}
}
```

Здесь показано, как предоставить синглтон из C++ и как осуществлять вызовы функций, выдавать сигналы и обмениваться состоянием (свойствами) между C++ и QML.

## Повторный просмотр файла CMake

Файл [[CMakeLists.txt|CMakeLists.txt]] может показаться вам знакомым, но в нем есть некоторые советы и хитрости, которые мы должны обсудить.

Прежде всего, для того чтобы отобразить класс C++ в QML, необходимо воспользоваться функцией `qul_target_generate_interfaces`, например:

```cmake
qul_target_generate_interfaces(cppintegration counter.h)
```

Вторая половина, QML-файлы, добавляется с помощью макроса `qul_target_qml_sources`. Если у вас несколько QML-файлов, просто перечислите их по очереди, как показано ниже:

```cmake
qul_target_qml_sources(cppintegration cppintegration.qml PlainB
```

Еще один интересный момент заключается в том, что мы собираем проект на языке Си++ без написания функции `main`. Об этом позаботился макрос `app_target_default_main`, который добавляет в проект эталонную реализацию `main`. Разумеется, вы можете заменить его на собственную функцию `main`, если вам требуется больший контроль.

```cmake
app_target_default_main(cppintegration cppintegration)
```

И наконец, библиотеки, с которыми выполняется линковка, - это не стандартные библиотеки Qt, а Qul такие, как, например:

```cmake
target_link_libraries(cppintegration
	Qul::QuickUltralite
	Qul::QuickUltralitePlatform)
```

> Дополнительная информация на сайте qt.io: Интеграция C++ и QML

# Работа с моделями

В Qt Quick Ultralite можно создавать модели на языке QML, используя элемент [[ListModel|ListModel]]. Также возможно, и это несколько интереснее, создавать модели из C++. Это позволяет отображать списки данных из C++ в QML и инстанцировать элементы пользовательского интерфейса для каждого элемента списка. Настройка очень похожа на обычную Qt Quick, но базовые классы и интерфейсы более
ограничены.

В этой главе мы создадим список городов Европы, в котором будет указано название города и страна, в которой он расположен. Города будут отображаться в [[ListView|ListView]], как показано ниже:

![[QML MCU 14.png]]

## Модель C++

Для создания модели в Qt Quick Ultralite первым делом необходимо определить `struct` с данными каждого элемента списка. Для этой структуры мы также необходимо предоставить оператор `==` . Именно так мы и поступим со структурой `CityData`, показанной ниже. Обратите внимание, что в Qt Quick Ultralite мы используем [[string|std::string]], а не [[QString|QString]]. Предполагается, что используется кодировка UTF-8.

```c++
#include <string>

struct CityData
{
	std::string name;
	std::string country;
};

inline bool operator==(const CityData &l, const CityData &r)
{
	return l.name == r.name && l.country == r.country;
}
```

После подготовки типа данных мы объявляем структуру `CityModel`, наследующую от `Qul::ListModel`. Это позволяет нам определить модель, к которой можно обращаться из QML. Мы должны реализовать методы `count` и `data`, которые аналогичны, но не идентичны соответствующим методам класса [[QAbstractListModel|QAbstractListModel]]. Мы также используем макрос `CMake qul_target_generate_interfaces`, чтобы сделать типы доступными для QML.

```c++
#include <qul/model.h>
#include <platforminterface/allocator.h>

struct CityModel : Qul::ListModel<CityData>
{
	private:
		Qul::PlatformInterface::Vector<CityData> m_data;
		
	public:
		CityModel();
	
		int count() const override { return m_data.size(); }
		CityData data(int index) const override { return m_data[ind]; }
};
```

Мы также реализуем конструктор для структуры `CityModel`, который заполняет данными вектор `m_data`.

```c++
#include "citymodel.h"

CityModel::CityModel()
{
	m_data.push_back(CityData {"Berlin", "Germany"});
	m_data.push_back(CityData {"Copenhagen", "Denmark"});
	m_data.push_back(CityData {"Helsinki", "Finland"});
	m_data.push_back(CityData {"London", "England"});
	m_data.push_back(CityData {"Oslo", "Norway"});
	m_data.push_back(CityData {"Paris", "France"});
	m_data.push_back(CityData {"Stockholm", "Sweden"});
}
```

## QML_

В примере мы показываем модель в виде прокручиваемого списка, как показано ниже.

![[QML MCU 15.png]]

```c++
import QtQuick 2.0

Rectangle {
	width: 480
	height: 272

	CityModel {
		id: cityModel
	}
	
	Component {
		id: cityDelegate
		
		Item {
			width: 480
			height: 45
			
			Column {
				spacing: 2
				
				Text {
					text: model.name
					x: 10
					
					font: Qt.font({
						pixelSize: 24,
						unicodeCoverage: [Font.UnicodeBlock
					})
				}
				
				Text {
					text: model.country
					x: 10
					color: "gray"
					
					font: Qt.font({
						pixelSize: 12,
						unicodeCoverage: [Font.UnicodeBlock
					})
				}
				
				Rectangle {
					color: "lightGreen"
					x: 10
					width: 460
					height: 1
				}
			}
		}
	}
	
	ListView {
		anchors.fill: parent
		model: cityModel
		delegate: cityDelegate
		spacing: 5
	}
}
```

Пример начинается с инстанцирования модели `cityModel`. Поскольку модель не является синглтоном, ее необходимо инстанцировать из QML. Затем делегат `cityDelegate` реализуется как `Component`. Это означает, что он может быть многократно инстанцирован из QML. Данные модели доступ к которому осуществляется через присоединенные свойства `model.name` и `model.country`. Наконец, элемент [[ListView|ListView]] объединяет модель и делегат, в результате чего получается список, показанный на скриншотах в этой главе.

![[QML MCU 16.png]]

Интересным аспектом QML является то, как настраивается шрифт элементов `Text`. Свойство `unicodeCoverage` позволяет указать компилятору Qt Quick Ultralite, какие символы мы хотели бы иметь возможность отображать. При указании фиксированных строк инструментарий Qt Quick Ultralite генерирует минимальные шрифты, содержащие именно те глифы, которые мы собираемся использовать.

Однако, поскольку модель будет предоставлять нам динамические данные, нам необходимо указать шрифту, какие символы мы предполагаем использовать. При рендеринге полного шрифта иногда возникают предупреждения следующего вида:

```c++
[2/7 8.8/sec] Generating CMakeFiles/cppmodel.dir/qul_font_engin
Warning: Glyph not found for character "\u0000"
Warning: Glyph not found for character "\u0001"
Warning: Glyph not found for character "\u0002"
Warning: Glyph not found for character "\u0003"
```

Их можно смело игнорировать, если только вы не рассчитываете показать данный персонаж.




















