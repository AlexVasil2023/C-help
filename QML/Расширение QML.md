# Расширение QML с помощью C++

При работе QML выполняется в среде времени выполнения. Время выполнения реализовано на языке C++ в модуле QtQml . Она состоит из движка, отвечающего за выполнение QML, контекстов, хранящих глобальные свойства, доступные для каждого компонента, и компонентов - элементов QML, которые могут быть инстанцированы из QML.

```c++
#include <QtGui>
#include <QtQml>

int main(int argc, char **argv)
{
	QGuiApplication app(argc, argv);
	QUrl source(QStringLiteral("qrc:/main.qml"));
	QQmlApplicationEngine engine;
	engine.load(source);
	return app.exec();
}
```

В примере [[QGuiApplication|QGuiApplication]] инкапсулирует все, что связано с экземпляром приложения (например, имя приложения, аргументы командной строки и управление циклом событий). 

[[QQmlApplicationEngine|QQmlApplicationEngine]] управляет иерархическим порядком контекстов и компонентов. Он требует загрузки типичного QML-файла в качестве начальной точки приложения. В данном случае это файл `main.qml,` содержащий окно и текстовый тип.

> Загрузка файла `main.qml` с простым `Item` в качестве корневого типа через [[QmlApplicationEngine|QmlApplicationEngine]] ничего не покажет на экране, так как для этого требуется окно, управляющее поверхностью для рендеринга. Движок способен загружать QML-код, не содержащий пользовательского интерфейса (например, простые объекты). Поэтому по умолчанию окно не создается. Внутренняя среда выполнения `qml` сначала проверит, содержит ли основной QML-файл окно в качестве корневого элемента, и если нет, то создаст его и установит корневой элемент в качестве дочернего для вновь созданного окна.

```c++
import QtQuick 2.5
import QtQuick.Window 2.2

Window {
	visible: true
	width: 512
	height: 300
	
	Text {
		anchors.centerIn: parent
		text: "Hello World!"
	}
}
```

В QML-файле мы объявляем наши зависимости, здесь это QtQuick и QtQuick.Window . Эти объявления вызовут поиск этих модулей в путях импорта и в случае успеха загрузят необходимые подключаемые модули в движок. Вновь загруженные типы будут доступны среде QML через объявление в файле `qmldir`, представляющем отчет.

Можно также сократить время создания плагина, добавив наши типы непосредственно в движок в файле `main.cpp`. Здесь мы предполагаем, что у нас есть `CurrentTime`, который является классом, основанным на базовом классе `QObject`.

```c++
QQmlApplicationEngine engine();
qmlRegisterType<CurrentTime>("org.example", 1, 0, "CurrentTime");
engine.load(source);
```
Теперь мы можем использовать тип `CurrentTime` и в нашем QML-файле.

```c++
import org.example 1.0

CurrentTime {
	// access properties, functions, signals
}
```

Если нам не нужно иметь возможность инстанцировать новый класс из QML, мы можем использовать свойства контекста для отображения объектов C++ в QML, например

```c++
QScopedPointer<CurrentTime> current(new CurrentTime());
QQmlApplicationEngine engine();
engine.rootContext().setContextProperty("current", current.value);
engine.load(source);
```

> Не путайте `setContextProperty()` и `setProperty()`. Первая устанавливает свойство контекста на qml-контекст, а `setProperty()` устанавливает динамическое значение свойства на [[QObject|QObject]] и не поможет вам.

Теперь вы можете использовать свойство `current` везде в своем приложении. Оно доступно везде в коде QML благодаря наследованию контекста. Текущий объект регистрируется в самом внешнем корневом контексте, который наследуется повсеместно.

```c++
import QtQuick
import QtQuick.Window

Window {
	visible: true
	width: 512
	height: 300
	
	Component.onCompleted: {
		console.log('current: ' + current)
	}
}
```

Вот различные способы расширения QML в целом:

* Свойства контекста - `setContextProperty()`
* Регистрация типа в движке - вызов [[qmlRegisterType|qmlRegisterType]] в вашем `main.cpp`
* Подключаемые модули расширения QML - максимальная гибкость, будет обсуждаться далее

**Контекстные свойства** удобны для использования в небольших приложениях. Они не требуют никаких усилий, вы просто представляете API своей системы в виде глобальных объектов. Полезно убедиться в отсутствии конфликтов именования (например, используя для этого специальный символ (`$`), например `$.currentTime`). `$` является допустимым символом для переменных JS.

Регистрация QML-типов позволяет пользователю управлять жизненным циклом объекта C++ из QML. Это невозможно при использовании свойств контекста. Кроме того, при этом не загрязняется глобальное пространство имен. Тем не менее все типы должны быть сначала зарегистрированы, а значит, все библиотеки должны быть скомпонованы при запуске приложения, что в большинстве случаев не представляет особой проблемы.

Наиболее гибкую систему обеспечивают **подключаемые модули расширения QML**. Они позволяют регистрировать типы в подключаемом модуле, который загружается при вызове идентификатора импорта в первом QML-файле. Кроме того, при использовании синглтона QML отпадает необходимость в засорении глобального пространства имен. Подключаемые модули позволяют повторно использовать модули в разных проектах, что очень удобно, когда вы делаете несколько проектов с Qt. 

Вернемся к нашему простому примеру файла `main.qml`:

```c++
import QtQuick 2.5
import QtQuick.Window 2.2

Window {
	visible: true
	width: 512
	height: 300

	Text {
		anchors.centerIn: parent
		text: "Hello World!"
	}
}
```

Когда мы импортируем QtQuick и QtQuick.Window , мы указываем времени выполнения QML найти соответствующие плагины расширения QML и загрузить их. Это делается движком QML путем поиска этих модулей в путях импорта QML. После этого вновь загруженные типы станут доступны среде QML.

В оставшейся части этой главы основное внимание будет уделено подключаемым модулям расширения QML. Поскольку они обеспечивают наибольшую гибкость и возможность повторного использования.






