# Состояния и Переходы
Часто части пользовательского интерфейса могут быть описаны в виде состояний. Состояние определяет набор изменений свойств и может быть вызвано определенным условием. Кроме того, к этим переключателям состояний может быть присоединен переход, который определяет, как эти изменения должны быть оживлены или какие дополнительные действия должны быть применены. Действия также могут применяться при переходе в то или иное состояние.
## Состояния
В QML состояния определяются с помощью элемента `State`, который должен быть привязан к массиву `states` любого элемента.
Состояние идентифицируется через имя состояния и в своей простейшей форме состоит из серии изменений свойств элементов. Состояние по умолчанию определяется начальными свойствами элемента и имеет имя "" (пустая строка).
```c++
Item {
	id: root
	
	states: [
		State {
			name: "go"
			PropertyChanges { ... }
		},
		
		State {
			name: "stop"
			PropertyChanges { ... }
		}
	]
}
```
Изменение состояния осуществляется путем присвоения нового имени состояния свойству `state` элемента, в котором определены состояния.
> Другим способом управления состояниями является использование свойства `when` элемента `State`. Свойство `when` может быть установлено в выражение, которое оценивается как `true`, когда состояние должно быть применено.
```c++
Item {
	id: root
	
	states: [
		...
	]
	
	Button {
		id: goButton
		...
		onClicked: root.state = "go"
	}
}
```
![[QML Animation_11.png]]
Например, светофор может иметь два сигнальных огня. Верхний из них сигнализирует об остановке красным цветом, а нижний - зеленым. В данном примере оба огня не должны светить одновременно. Давайте посмотрим на диаграмму состояний.
![[QML Animation_12.png]]
При включении система автоматически переходит в режим останова, который является состоянием по умолчанию. В состоянии останова `индикатор1` переключается в красный цвет, а `индикатор2` - в черный (выключен).
Теперь внешнее событие может вызвать переключение состояния в состояние "идти" . В состоянии "идти" мы меняем цвет светофора `light1` на черный (выключен), а светофора `light2` - на зеленый, чтобы показать, что теперь пешеходы могут переходить дорогу.
Для реализации этого сценария мы начнем рисовать эскиз пользовательского интерфейса для двух светильников. Для простоты мы используем 2 прямоугольника с радиусом, равным половине ширины (а ширина равна высоте, то есть это квадрат).
```c++
Rectangle {
	id: light1

	x: 25; y: 15
	width: 100; height: width
	radius: width / 2
	
	color: root.black
	border.color: Qt.lighter(color, 1.1)
}

Rectangle {
	id: light2

	x: 25; y: 135
	width: 100; height: width
	radius: width/2
	
	color: root.black
	border.color: Qt.lighter(color, 1.1)
}
```
Как определено на диаграмме состояний, мы хотим иметь два состояния: "движение" и "остановка", в каждом из которых светофор меняет свой цвет на красный или зеленый. Мы устанавливаем свойство `state` в значение `stop`, чтобы гарантировать, что начальным состоянием нашего светофора будет состояние `stop`.
> Мы могли бы добиться того же эффекта только с состоянием "go" и без явного состояния "stop", установив цвет `light1` красным, а цвет `light2` - черным. Начальное состояние "" , определяемое начальными значениями свойств, в этом случае выступало бы в качестве состояния " стоп".
```C++
state: "stop"
	
states: [
	
	State {
		name: "stop"
		PropertyChanges { target: light1; color: root.red }
		PropertyChanges { target: light2; color: root.black }
	},

	State {
		name: "go"
		PropertyChanges { target: light1; color: root.black }
		PropertyChanges { target: light2; color: root.green }
	}
]
```
Использование `PropertyChanges {target: light2; color: "black"}` в данных примерах не требуется, так как начальный цвет `light2` уже черный. В состоянии необходимо только описать, как свойства должны измениться по сравнению с их состоянием по умолчанию (а
не с предыдущим состоянием).
Смена состояния происходит с помощью области мыши, которая охватывает весь светофор и при нажатии переключается между состояниями "горит" и "стоп".
```c++
MouseArea {
	anchors.fill: parent
	onClicked: parent.state = (parent.state == "stop" ? "go" :
}
```
![[QML Animation_14.png]]
Теперь мы можем успешно изменять состояние светофора. Чтобы сделать пользовательский интерфейс более привлекательным и естественным, необходимо добавить несколько переходов с эффектами анимации. Переход может быть вызван изменением состояния.
> Аналогичную логику можно создать, используя сценарии, а не состояния QML. Однако QML является лучшим языком, чем JavaScript, для описания пользовательских интерфейсов. По возможности старайтесь писать декларативный, а не императивный код.

# Переходы
К каждому элементу может быть добавлена серия переходов. Переход выполняется при изменении состояния.
С помощью свойств `from:` и `to:` можно определить, при каком изменении состояния может быть применен тот или иной переход. Эти два свойства действуют как фильтр: когда фильтр равен `true`, переход будет применен. Можно также использовать подстановочный знак "\*", который означает "любое состояние".
Например, `from: "*";` `to: "*"` означает "из любого состояния в любое другое состояние" и является значением по умолчанию для `from` и `to`. Это означает, что переход будет применен к каждому переключателю состояний.
В данном примере мы хотим анимировать изменение цвета при переключении состояния с "go" на "stop". Для другого обратного изменения состояния ("stop" на "go") мы хотим сохранить немедленное изменение цвета и не применять переход.
Мы ограничиваем переход с помощью свойств `from` и `to`, чтобы фильтровать только изменение состояния от "go" до "stop". Внутри перехода мы добавляем две цветовые анимации для каждого света, которые должны анимировать изменения свойств, определенных в описании состояния.
```c++
transitions: [
	Transition {
		from: "stop"; to: "go"
		// from: "*"; to: "*"
		ColorAnimation { target: light1; properties: "color"; }
		ColorAnimation { target: light2; properties: "color"; }
	}
]
```
Изменить состояние можно щелчком мыши в пользовательском интерфейсе. Состояние применяется немедленно, а также изменяет состояние во время выполнения перехода. Поэтому попробуйте щелкнуть на пользовательском интерфейсе, когда состояние находится в состоянии перехода от "stop" к "go". Вы увидите, что изменение произойдет немедленно.
![[QML Animation_15.png]]
С этим пользовательским интерфейсом можно поиграть, например, уменьшив масштаб неактивного света, чтобы выделить активный.
Для этого необходимо добавить в состояния еще одно свойство изменения масштаба, а также обработать анимацию для свойства масштабирования в переходе.
Другим вариантом может быть добавление состояния "внимание", когда индикаторы мигают желтым цветом. Для этого необходимо добавить к переходу последовательную анимацию, в которой одна секунда будет желтой (свойство "to" анимации и одна секунда - черной).
Возможно, вам также захочется изменить кривую ослабления, чтобы сделать ее более привлекательной.






























