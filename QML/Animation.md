# Анимация

Существует несколько способов добавления анимации в 3D-сцены Qt Quick. Самый простой из них - перемещение, вращение и масштабирование элементов модели в сцене. Однако во многих случаях мы хотим изменять реальные сетки. Для этого существует два основных подхода: ***морфинг-анимация*** и ***скелетная анимация***.

***Морфинг-анимация*** позволяет создать несколько целевых фигур, которым могут быть присвоены различные веса. Комбинируя целевые формы в соответствии с весами, можно получить деформированную, т.е. морфированную, форму. Это широко используется для моделирования деформаций мягких материалов.

***Скелетная анимация*** используется для позиционирования объекта, например, тела, на основе положения скелета, состоящего из костей. Эти кости воздействуют на тело, тем самым деформируя его в требуемую позу.

Для обоих типов анимации наиболее распространенным подходом является определение морфинга целевых фигур и костей в инструменте моделирования, а затем экспорт в QML с помощью инструмента `Balsam`. В этой главе мы сделаем именно это для скелетной анимации, но для морфинг-анимации подход аналогичен.

## Скелетная анимация

Цель этого примера - заставить Сюзанну, голову обезьяны из Blender, махать одним из своих ушей.

![[QML Anima_1.png]]

Скелетную анимацию иногда называют вершинной анимацией. По сути, скелет помещается внутрь сетки, а вершины сетки привязываются к скелету. Таким образом, при перемещении скелета сетка деформируется, принимая различные позы. 

Поскольку обучение работе с Blender выходит за рамки данной книги, ключевые слова, которые вы ищете, - это позирование и арматура. ***Арматуры*** - это то, что в Blender называют костями. Существует множество видеоуроков, объясняющих, как это делается. На скриншоте ниже показана сцена с Сюзанной и арматурами в ***Blender***. Обратите внимание, что арматурам ушей были присвоены имена, чтобы мы могли идентифицировать их в QML.

![[QML Anima_2.png]]

После того как сцена в `Blender` готова, мы экспортируем ее в файл `COLLADA` и конвертируем в QML и сетку, как это было сделано в разделе "Работа с активами". Полученный QML-файл называется Monkey_with_bones.qml .

Затем мы должны сослаться на эти файлы в нашем утверждении `qt_add_qml_module` в файле CMakeLists.txt:

```
qt_add_qml_module(appanimations
	URI animations
	VERSION 1.0
	QML_FILES main.qml Monkey_with_bones.qml
	RESOURCES meshes/suzanne.mesh
)
```

Исследуя сгенерированный QML, можно заметить, что скелет построен из QML-элементов типов `Skeleton` и `Joint`. С этими элементами можно работать как с кодом в QML, но гораздо чаще их создают в инструментах проектирования.

```c++
Node {
	id: armature
	z: -0.874189
	
	Skeleton {
		id: qmlskeleton
		
		Joint {
			id: armature_Bone
			
			rotation: Qt.quaternion(0.707107, 0.707107, 0, 0)
			index: 0
			skeletonRoot: qmlskeleton

			Joint {
				id: armature_Bone_001
				y: 1
```

Затем на элемент `Skeleton` ссылается свойство `skeleton` элемента `Model`, перед свойством `inverseBindPoses`, связывающим суставы с моделью.

```c++
Model {
	id: suzanne
	skeleton: qmlskeleton

	inverseBindPoses: [
		Qt.matrix4x4(1, 0, 0, 0, 0, 0, 1, 0.748378, 0, -1, 0, 0
		Qt.matrix4x4(),
		Qt.matrix4x4(0.283576, -0.11343, 0.952218, 1.00072, -0.
		Qt.matrix4x4(),
		Qt.matrix4x4(0.311833, 0.101945, -0.944652, -1.01739, 0
		Qt.matrix4x4()
	]
	
	source: "meshes/suzanne.mesh"
```

Следующим шагом будет включение только что созданного элемента `Monkey_with_bones` в нашу основную сцену View3D:

```c++
View3D {
	anchors.fill: parent
	
	Monkey_with_bones {
		id: monkey
	}
```

А затем мы создаем `SequentialAnimation`, построенный из двух `NumberAnimations`, чтобы заставить ухо болтаться вперед и назад.

```c++
SequentialAnimation {

	NumberAnimation {
		target: monkey
		property: "left_ear_euler"
		duration: 1000
		from: -30
		to: 60
		easing: InOutQuad
	}

	NumberAnimation {
		target: monkey
		property: "left_ear_euler"
		duration: 1000
		from: 60
		to: -30
		easing: InOutQuad
	}
	
	loops: Animation.Infinite
	running: true
}
```

> Для того чтобы получить доступ к свойству `eulerRotation.y` сустава извне файла `Monkey_with_bones`, нам необходимо раскрыть его как псевдоним свойства верхнего уровня. Это означает модификацию сгенерированного файла, что не очень приятно, но решает проблему.

```c++
Node {
	id: scene
	property alias left_ear_euler: armature_left_ear.eul
	property alias right_ear_euler: armature_right_ear.e
```

Получившееся "висячее ухо" можно увидеть ниже:

![[QML Anima_3.png]]

Как видите, удобно импортировать и использовать скелеты, созданные в инструменте проектирования. Это делает удобным анимирование сложных 3D-моделей из


