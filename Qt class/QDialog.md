# QDialog

Класс `QDialog` реализует диалоговое окно. По умолчанию окно выводится с рамкой и заголовком, в котором расположена кнопка `Закрыть`. Размеры окна можно изменять с помощью мыши. Иерархия наследования для класса `QDialog` выглядит так:
```
(QObject, QPaintDevice) — QWidget — QDialog
```

Конструктор класса `QDialog` имеет следующий формат:
```c++
#include <QDialog>

QDialog(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags())
```

В параметре `parent` передается указатель на родительское окно. Если параметр не указан или имеет значение `nullptr`, то диалоговое окно будет центрироваться относительно экрана. Если передан указатель на родительское окно, то диалоговое окно будет центрироваться относительно родительского окна. Кроме того, это позволяет создать модальное диалоговое окно, которое будет блокировать только окно родителя, а не все окна приложения. Какие именно [[QWidget#Указание типа окна|значения можно указать в параметре `f`]]. Тип окна по умолчанию — `Dialog`.

Класс `QDialog` наследует все методы из базовых классов и содержит следующие дополнительные методы (перечислены только основные методы; полный список смотрите в документации):

> **exec()** — отображает модальное диалоговое окно и возвращает код возврата в виде значения следующих констант:
* **QDialog::Accepted** — нажата кнопка `OK`;
* `QDialog::Rejected` — нажата кнопка `Cancel`, кнопка `Закрыть` в заголовке окна или клавиша `<Esc>`.

Метод является слотом. Прототип метода:
```c++
virtual int exec()
```

Пример отображения диалогового окна и обработки статуса внутри обработчика нажатия кнопки (класс `MyDialog` является наследником класса [[QDialog|QDialog]], а `this` — указатель на главное окно):
```c++
void Widget::on_btn1_clicked()
{
	MyDialog dialog(this);
	int result = dialog.exec();
	
	if (result == QDialog::Accepted) {
		qDebug() << dialog.lineEdit->text();
	}
	else {
		qDebug() << "Нажата кнопка Cancel" << result;
	}
}
```

> **accept()** — скрывает модальное диалоговое окно и устанавливает код возврата равным значению константы `QDialog::Accepted`. Метод является слотом. Прототип метода:
```c++
virtual void accept()
```
Метод `accept()` следует соединить с сигналом нажатия кнопки `OK`:
```c++
connect(btnOK, SIGNAL(clicked()), this, SLOT(accept()));
```

> **reject()** — скрывает модальное диалоговое окно и устанавливает код возврата равным значению константы `QDialog::Rejected`. Метод является слотом. Прототип метода:
```c++
virtual void reject()
```

Метод `reject()` следует соединить с сигналом нажатия кнопки `Cancel`:
```c++
connect(btnCancel, SIGNAL(clicked()), this, SLOT(reject()));
```

> **done()** — скрывает модальное диалоговое окно и устанавливает код возврата равным значению параметра. Метод является слотом. Прототип метода:
```c++
virtual void done(int)
```

> **setResult()** — устанавливает код возврата. Прототип метода:
```c++
void setResult(int)
```

> **result()** — возвращает код завершения. Прототип метода:
```c++
int result() const
```

> **setSizeGripEnabled()** — если в качестве параметра указано значение `true`, то в правом нижнем углу диалогового окна будет отображен значок изменения размера, а если `false`, то скрыт (значение по умолчанию). Прототип метода:
```c++
void setSizeGripEnabled(bool)
```

> **isSizeGripEnabled()** — возвращает значение `true`, если значок изменения размера отображается в правом нижнем углу диалогового окна, и `false` — в противном случае. Прототип метода:
```c++
bool isSizeGripEnabled() const
```

> **setVisible()** — если в параметре указано значение `true`, то диалоговое окно будет отображено, а если значение `false`, то скрыто. Вместо этого метода можно воспользоваться методами `show()` и `hide()` из класса [[QWidget|QWidget]]. Прототип метода:
```c++
void setVisible(bool)
```

> **open()** — отображает диалоговое окно в модальном режиме. Блокируется только родительское окно, а не все окна приложения. Метод является слотом. Прототип метода:
```c++
virtual void open()
```

> **setModal()** — если в качестве параметра указано значение **true**, то окно будет модальным, а если `false`, то обычным. Обратите внимание на то, что окно, открываемое с помощью метода `exec()`, всегда будет модальным независимо от значения метода `setModal()`. Чтобы диалоговое окно было не модальным, следует отображать его с помощью метода `show()` или `setVisible()`. После вызова этих методов следует вызвать методы `raise()` (чтобы поместить окно поверх всех окон) и `activateWindow()` (чтобы сделать окно активным (имеющим фокус ввода)).

Указать, что окно является модальным, позволяет также метод `setWindowModality()` из класса [[QWidget|QWidget]]. Прототип метода:
```c++
void setWindowModality(Qt::WindowModality windowModality)
```

В качестве параметра могут быть указаны следующие константы:
* **Qt::NonModal** — окно не является модальным;
* **Qt::WindowModal** — окно блокирует только родительские окна в пределах иерархии;
* **Qt::ApplicationModal** — окно блокирует все окна в приложении.

Окна, открытые из модального окна, не блокируются. Следует также учитывать, что метод `setWindowModality()` должен быть вызван до отображения окна. Получить текущее значение позволяет метод `windowModality()` из класса [[QWidget|QWidget]]. Проверить, является ли окно модальным, можно с помощью метода `isModal()` из класса [[QWidget|QWidget]]. Метод возвращает `true`, если окно является модальным, и `false` — в противном случае. Прототипы методов:
```c++
Qt::WindowModality windowModality() const
bool isModal() const
```

Класс `QDialog` содержит следующие сигналы:

> **accepted()** — генерируется при установке флага `Accepted` (нажата кнопка `OK`). Сигнал не генерируется при сокрытии окна с помощью метода `hide()` или `setVisible()`;
> 
> **rejected()** — генерируется при установке флага `Rejected` (нажата кнопка `Cancel`, кнопка `Закрыть` в заголовке окна или клавиша `<Esc>`). Сигнал не генерируется при сокрытии окна с помощью метода `hide()` или `setVisible()`;
> 
> **finished(int)** — генерируется при установке кода завершения, например пользователем или с помощью методов `accept()`, `reject()` или `done()`. Внутри обработчика через параметр доступен код завершения. Сигнал не генерируется при сокрытии окна с помощью метода hide() или setVisible().

Для всех кнопок, добавляемых в диалоговое окно, автоматически вызывается метод `setAutoDefault()`, и ему передается значение `true`. В этом случае кнопка может быть нажата с помощью клавиши `<Enter>`, при условии что она находится в фокусе. По умолчанию нажать кнопку позволяет только клавиша `<Пробел>`.

С помощью метода `setDefault()` можно указать кнопку по умолчанию. Эта кнопка может быть нажата с помощью клавиши `<Enter>`, когда фокус ввода установлен на другой компонент, например на текстовое поле.
