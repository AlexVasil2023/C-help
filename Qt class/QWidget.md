# Управление окном приложения

Создать окно и управлять им позволяет класс **QWidget**. Класс `QWidget` наследует два класса — [[QObject|QObject]] и [[QPaintDevice|QPaintDevice]] . В свою очередь, класс `QWidget` является базовым классом для всех визуальных компонентов, поэтому любой компонент, не имеющий родителя, обладает своим собственным окном. В этой главе мы рассмотрим методы класса `QWidget` применительно к окну верхнего уровня, однако следует помнить, что те же самые методы можно применять и к любым компонентам. Например, метод, позволяющий управлять размерами окна, можно использовать и для изменения размеров компонента, имеющего родителя. Тем не менее некоторые методы имеет смысл использовать только для окон верхнего уровня. Например, метод, позволяющий изменить текст в заголовке окна, не имеет смысла использовать в обычных компонентах.

Для создания окна верхнего уровня помимо класса `QWidget` можно использовать и другие классы, которые являются наследниками класса `QWidget`, например класс [[QFrame|QFrame]] (окно с рамкой) или [[QDialog|QDialog]] (диалоговое окно). При использовании класса [[QDialog|QDialog]] окно будет выравниваться по центру экрана (или по центру родительского окна) и иметь только кнопку Закрыть в заголовке окна. Кроме того, можно использовать класс [[QMainWindow|QMainWindow]], который представляет главное окно приложения с меню, панелями инструментов и строкой состояния. Использование классов [[QDialog|QDialog]] и [[QMainWindow|QMainWindow]] имеет свои отличия.

## Создание и отображение окна

Самый простой способ создать пустое окно:

```c++
#include <QApplication>
#include <QWidget>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	
	QWidget window;
	window.setWindowTitle("Заголовок окна");
	window.resize(350, 70);
	window.show();
	
	return app.exec();
}
```

Конструктор класса `QWidget` имеет следующий формат:
```c++
QWidget(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags())
```

В параметре `parent` передается указатель на родительский компонент. Если параметр не указан или имеет значение [[nullptr_t|nullptr]], то компонент будет обладать своим собственным окном. Если в параметре `f` указан тип окна, то компонент, имея родителя, будет обладать своим собственным окном, но будет привязан к родителю. Это позволяет, например, создать модальное окно, которое будет блокировать только окно родителя, а не все окна приложения. Какие именно значения можно указать в параметре `f`, мы рассмотрим в следующем разделе.

Передать указатель на родительский компонент уже после создания объекта позволяет метод **setParent()** . Прототипы метода:
```c++
void setParent(QWidget *parent)
void setParent(QWidget *parent, Qt::WindowFlags f)
```

Получить указатель на родительской компонент можно с помощью метода **parentWidget()**. Если компонент не имеет родителя, то метод возвращает нулевой указатель. Прототип метода:
```c++
QWidget *parentWidget() const
```

Для изменения текста в заголовке окна предназначен метод **setWindowTitle()**. Метод является слотом. Прототип метода:
```c++
void setWindowTitle(const QString &)
```

Пример:
```c++
window.setWindowTitle("Текст, отображаемый в заголовке");
```

После создания окна необходимо вызвать метод **show()**, чтобы окно и все дочерние компоненты отобразились на экране. Для сокрытия окна предназначен метод **hide()**. Методы `show()` и `hide()` являются слотами. Для отображения и сокрытия компонентов можно также воспользоваться методом **setVisible()**. Метод является слотом. Прототип метода:
```c++
virtual void setVisible(bool visible)
```

Если в параметре указано значение `true`, то компонент будет отображен, а если значение `false`, то компонент будет скрыт. Пример отображения окна и всех дочерних компонентов:

```c++
window.setVisible(true);
```

Проверить, отображен компонент в настоящее время или нет, позволяет метод **isVisible()**. Метод возвращает `true`, если компонент отображен, и `false` — в противном случае. Кроме того, можно воспользоваться методом **isHidden()**. Метод возвращает `true`, если компонент скрыт, и `false` — в противном случае. Прототипы методов:
```c++
bool isVisible() const
bool isHidden() const
```

## Указание типа окна

При использовании класса `QWidget` по умолчанию окно создается с заголовком, в котором расположены: значок, текст заголовка и кнопки Свернуть, Развернуть и Закрыть. Указать другой тип создаваемого окна позволяет метод **setWindowFlags()** или параметр `f` в конструкторе класса `QWidget`. Обратите внимание на то, что метод `setWindowFlags()` должен вызываться перед отображением окна. Прототип метода:
```c++
void setWindowFlags(Qt::WindowFlags type)
```

В параметре type можно указать следующие константы:

> **Qt::Widget** — тип по умолчанию для класса `QWidget`;
> **Qt::Window** — указывает, что компонент является окном независимо от того, имеет он родителя или нет. Окно выводится с рамкой и заголовком, в котором расположены кнопки Свернуть, Развернуть и Закрыть. По умолчанию размеры окна можно изменять с помощью мыши;
> **Qt::Dialog** — диалоговое окно. Окно выводится с рамкой и заголовком, в котором расположена кнопка Закрыть. Размеры окна можно изменять с помощью мыши. Пример указания типа для диалогового окна:
```c++
window.setWindowFlags(Qt::Dialog);
```
> **Qt::Sheet**;
> **Qt::Drawer**;
> **Qt::Popup** — указывает, что окно является всплывающим меню. Окно выводится без рамки и заголовка. Кроме того, окно может отбрасывать тень. Изменить размеры окна с помощью мыши нельзя;
> **Qt::Tool** — сообщает, что окно является панелью инструментов. Окно выводится с рамкой и заголовком (уменьшенным по высоте по сравнению с заголовком обычного окна), в котором расположена кнопка Закрыть. Размеры окна можно изменять с помощью мыши;
> **Qt::ToolTip** — указывает, что окно является всплывающей подсказкой. Окно выводится без рамки и заголовка. Изменить размеры окна с помощью мыши нельзя;
> **Qt::SplashScreen** — сообщает, что окно является заставкой. Окно выводится без рамки и заголовка. Изменить размеры окна с помощью мыши нельзя. Значение по умолчанию для класса [[QSplashScreen|QSplashScreen]];
> **Qt::SubWindow** — сообщает, что окно является дочерним компонентом независимо от того, имеет он родителя или нет. Окно выводится с рамкой и заголовком (уменьшенным по высоте по сравнению с заголовком обычного окна) без кнопок. Изменить размеры окна с помощью мыши нельзя;
> **Qt::ForeignWindow**;
> **Qt::CoverWindow**.

Определить тип окна из программы позволяет метод **windowType()**. Прототип метода:
```c++
Qt::WindowType windowType() const
```

Для окон верхнего уровня можно дополнительно указать следующие константы через оператор `|` (перечислены только наиболее часто используемые константы; полный список смотрите в документации):

> **Qt::MSWindowsFixedSizeDialogHint** — запрещает изменение размеров окна. Изменить размеры с помощью мыши нельзя. Кнопка Развернуть в заголовке окна становится неактивной;
> **Qt::FramelessWindowHint** — убирает рамку и заголовок окна. Изменять размеры окна и перемещать его нельзя;
> **Qt::CustomizeWindowHint** — убирает заголовок окна. Размеры окна можно изменять с помощью мыши;
> **Qt::WindowTitleHint** — добавляет заголовок окна. Выведем окно с заголовком, в котором находится только текст и неактивная кнопка Закрыть:
```c++
window.setWindowFlags(Qt::Window | Qt::WindowTitleHint);
```
> **Qt::WindowSystemMenuHint** — добавляет оконное меню;
> **Qt::WindowMinimizeButtonHint** — кнопка Свернуть в заголовке окна делается активной;
> **Qt::WindowMaximizeButtonHint** — кнопка Развернуть в заголовке окна делается активной;
> **Qt::WindowMinMaxButtonsHint** — кнопки Свернуть и Развернуть в заголовке окна делаются активными;
> **Qt::WindowCloseButtonHint** — добавляет кнопку Закрыть;
> **Qt::WindowContextHelpButtonHint** — добавляет кнопку Справка. Кнопки Свернуть и Развернуть в заголовке окна не отображаются. Добавим кнопки Справка и Закрыть:
```c++
window.setWindowFlags(Qt::Window |
						Qt::WindowCloseButtonHint |
						Qt::WindowContextHelpButtonHint);
```
> **Qt::WindowStaysOnTopHint** — сообщает системе, что окно всегда должно отображаться поверх всех других окон;
> **Qt::WindowStaysOnBottomHint** — сообщает системе, что окно всегда должно быть расположено позади всех других окон.

Получить все установленные флаги из программы позволяет метод `windowFlags()`. Прототип метода: 
```c++
Qt::WindowFlags windowFlags() const
```

## Изменение и получение размеров окна

Для изменения размеров окна предназначены следующие методы:
> **resize()** — изменяет текущий размер окна. Если содержимое окна не помещается в установленный размер, то размер будет выбран так, чтобы компоненты поместились без искажения, при условии, что используются менеджеры геометрии. Следовательно, заданный размер может не соответствовать реальному размеру окна. Если используется абсолютное позиционирование, то компоненты могут оказаться наполовину или полностью за пределами видимой части окна. Прототипы метода:
```c++
void resize(int w, int h)
void resize(const QSize &)
```
Пример:
```c++
window.resize(350, 70);
```

> **setGeometry()** — изменяет одновременно положение компонента и его размер. Первые два параметра задают координаты левого верхнего угла (относительно родительского компонента или экрана), а третий и четвертый параметры — ширину и высоту. Прототипы метода:
```c++
void setGeometry(int x, int y, int w, int h)
void setGeometry(const QRect &)
```
Пример:
```c++
window.setGeometry(100, 100, 350, 70);
```

> **setFixedSize()** — задает фиксированный размер. Изменить размеры окна с помощью мыши нельзя. Кнопка Развернуть в заголовке окна становится неактивным. Прототипы метода:
```c++
void setFixedSize(int w, int h)
void setFixedSize(const QSize &s)
```
Пример:
```c++
window.setFixedSize(350, 70);
```

> **setFixedWidth()** — задает фиксированный размер только по ширине. Изменить ширину окна с помощью мыши нельзя. Прототип метода: 
```c++
void setFixedWidth(int w)
```

**setFixedHeight()**` — задает фиксированный размер только по высоте. Изменить высоту окна с помощью мыши нельзя. Прототип метода: 
```c++
void setFixedHeight(int h)
```

> **setMinimumSize()** — задает минимальный размер. Прототипы метода: 
```c++
void setMinimumSize(int minw, int minh)
void setMinimumSize(const QSize &)
```
Пример:
```c++
window.setMinimumSize(350, 70);

```
> **setMinimumWidth()** и **setMinimumHeight()** — задают минимальный размер только по ширине и высоте соответственно. Прототипы методов: 
```c++
```
> void setMinimumWidth(int minw)
> void setMinimumHeight(int minh)
```
```

> **setMaximumSize()** — задает максимальный размер. Прототипы метода: 
```c++
void setMaximumSize(int maxw, int maxh)
void setMaximumSize(const QSize &)
```
> **setMaximumWidth()** и **setMaximumHeight()** — задают максимальный размер только по ширине и высоте соответственно. Прототипы методов: 
```c++
void setMaximumWidth(int maxw)
void setMaximumHeight(int maxh)
```

> **setBaseSize()** — задает базовые размеры. Прототипы метода:
```c++
void setBaseSize(int basew, int baseh)
void setBaseSize(const QSize &)
```

> **adjustSize()** — подгоняет размеры компонента под содержимое. При этом учитываются рекомендуемые размеры, возвращаемые методом `sizeHint()`. Прототип метода:
```c++
void adjustSize()
```

Получить размеры позволяют следующие методы:
> **width()** и **height()** — возвращают ширину и высоту соответственно. Прототипы методов:
```c++
int width() const
int height() const
```
Пример:
```c++
window.resize(350, 70);
qDebug() << window.width() << window.height(); // 350 70
```

> **size()** — возвращает экземпляр класса `QSize`, содержащий размеры. Прототип метода:
```c++
QSize size() const
```
Пример:
```c++
window.resize(350, 70);
qDebug() << window.size().width() << window.size().height(); // 350 70
```

> **minimumSize()** — возвращает экземпляр класса `QSize`, содержащий минимальные размеры. Прототип метода:
```c++
QSize minimumSize() const
```

> **minimumWidth()** и **minimumHeight()** — возвращают минимальную ширину и высоту соответственно. Прототипы методов:
```c++
int minimumWidth() const
int minimumHeight() const
```

> **maximumSize()** — возвращает экземпляр класса `QSize`, содержащий максимальные размеры. Прототип метода:
```c++
QSize maximumSize() const
```

> **maximumWidth()** и **maximumHeight()** — возвращают максимальную ширину и высоту соответственно. Прототипы методов:
```c++
int maximumWidth() const
int maximumHeight() const
```

> **baseSize()** — возвращает экземпляр класса `QSize`, содержащий базовые размеры. Прототип метода:
```c++
QSize baseSize() const
```

> **sizeHint()** — возвращает экземпляр класса `QSize`, содержащий рекомендуемый размер компонента. Если возвращаемые размеры являются отрицательными, то считается, что нет рекомендуемого размера. Прототип метода:
```c++
virtual QSize sizeHint() const
```

> **minimumSizeHint()** — возвращает экземпляр класса [[QSize|QSize]] , содержащий рекомендуемый минимальный размер компонента. Если возвращаемые размеры являются отрицательными, то считается, что нет рекомендуемого минимального размера. Прототип метода:
```c++
virtual QSize minimumSizeHint() const
```

> **rect()** — возвращает экземпляр класса [[QRect|QRect]], содержащий координаты и размеры прямоугольника, в который вписан компонент. Прототип метода:
```c++
QRect rect() const
```
Пример:
```c++
window.setGeometry(100, 100, 350, 70);
QRect rect = window.rect();

qDebug() << rect.left() << rect.top(); // 0 0
qDebug() << rect.width() << rect.height(); // 350 70
```

> **geometry()** — возвращает ссылку на экземпляр класса [[QRect|QRect]], содержащий координаты относительно родительского компонента. Прототип метода:
```c++
const QRect &geometry() const
```
Пример:
```c++
window.setGeometry(100, 100, 350, 70);
QRect rect = window.geometry();

qDebug() << rect.left() << rect.top(); // 100 100
qDebug() << rect.width() << rect.height(); // 350 70
```

При изменении и получении размеров окна следует учитывать, что:

> размеры не включают высоту заголовка окна и ширину границ;
> 
> размер компонентов может изменяться в зависимости от настроек стиля.  Например, на разных компьютерах может быть указан шрифт разного наименования и размера. Поэтому от указания фиксированных размеров лучше отказаться;
> 
> размер окна может изменяться в промежутке между получением значения и действиями, выполняющими обработку этих значений в программе. Например, сразу после получения размера пользователь изменил размеры окна с помощью мыши.

Чтобы получить размеры окна, включая высоту заголовка и ширину границ, следует воспользоваться методом **frameSize()**. Метод возвращает экземпляр класса [[QSize|QSize]]. Прототип метода:
```c++
QSize frameSize() const
```

Обратите внимание на то, что полные размеры окна доступны только после отображения окна. До этого момента размеры совпадают с размерами окна без учета высоты заголовка и ширины границ. Пример получения полного размера окна:

```c++
window.resize(350, 70);                           // Задаем размеры
// ...
window.show();                                    // Отображаем окно

qDebug() << window.width() << window.height();    // 350 70
qDebug() << window.frameSize().width() << window.frameSize().height(); // 366 109
```

Чтобы получить координаты окна с учетом высоты заголовка и ширины границ, следует воспользоваться методом `frameGeometry()`. Прототип метода:

```c++
QRect frameGeometry() const
```

Обратите внимание на то, что полные размеры окна доступны только после отображения окна. Пример:

```c++
window.setGeometry(100, 100, 350, 70);
// ...
window.show();                                           // Отображаем окно

QRect rect = window.geometry();

qDebug() << rect.left() << rect.top();                   // 100 100
qDebug() << rect.width() << rect.height();               // 350 70

rect = window.frameGeometry();

qDebug() << rect.left() << rect.top();                   // 92 69
qDebug() << rect.width() << rect.height();               // 366 109
```

## Местоположение окна на экране

Задать местоположение окна на экране монитора позволяют следующие методы:

> - **move()** — изменяет положение компонента относительно родителя. Метод учитывает высоту заголовка и ширину границ. Прототипы метода:
```c++
void move(int x, int y)
void move(const QPoint &)
```
Пример вывода окна в левом верхнем углу экрана:
```c++
window.move(0, 0);
```

> - **setGeometry()** — изменяет одновременно положение компонента и его размер. Первые два параметра задают координаты левого верхнего угла (относительно родительского компонента), а третий и четвертый параметры — ширину и высоту. Обратите внимание на то, что метод не учитывает высоту заголовка и ширину границ. Поэтому, если указать координаты (0, 0) , заголовок окна и левая граница будут за пределами экрана. Прототипы метода:
```c++
void setGeometry(int x, int y, int w, int h)
void setGeometry(const QRect &)
```
Пример:
```c++
window.setGeometry(100, 100, 350, 70);
```
> Начало координат расположено в левом верхнем углу. Положительная ось **X** направлена вправо, а положительная ось **Y** — вниз.

Получить позицию окна позволяют следующие методы:

> **x()** и **y()** — возвращают координаты левого верхнего угла окна относительно родителя по осям `X` и `Y` соответственно. Методы учитывают высоту заголовка и ширину границ. Прототипы методов:
```c++
int x() const
int y() const
```
Пример:
```c++
window.move(10, 10);
qDebug() << window.x() << window.y(); // 10 10
```

> **pos()** — возвращает экземпляр класса [[QPoint|QPoint]], содержащий координаты левого верхнего угла окна относительно родителя. Метод учитывает высоту заголовка и ширину границ. Прототип метода:
```c++
QPoint pos() const
```
Пример:
```c++
window.move(10, 10);
qDebug() << window.pos().x() << window.pos().y(); // 10 10
```

> **geometry()** — возвращает ссылку на экземпляр класса [[QRect|QRect]], содержащий координаты относительно родительского компонента. Обратите внимание на то, что метод не учитывает высоту заголовка и ширину границ. Прототип метода:
```c++
const QRect &geometry() const
```
Пример:
```c++
window.resize(350, 70);
window.move(10, 10);
// ...
window.show();
QRect rect = window.geometry();
qDebug() << rect.left() << rect.top(); // 18 41
qDebug() << rect.width() << rect.height(); // 350 70
```

> **frameGeometry()** — возвращает экземпляр класса [[QRect|QRect]], содержащий координаты с учетом высоты заголовка и ширины границ. Обратите внимание на то, что полные размеры окна доступны только после отображения окна. Прототип метода:
```c++
QRect frameGeometry() const
```
Пример:
```c++
window.resize(350, 70);
window.move(10, 10);
// ...
window.show();
QRect rect = window.frameGeometry();
qDebug() << rect.left() << rect.top(); // 10 10
qDebug() << rect.width() << rect.height(); // 366 109
```

## Получение информации о размере экрана

Для отображения окна по центру экрана или у правой или нижней границы необходимо знать размеры экрана. Для получения размеров экрана сначала следует вызвать статический метод `QApplication::primaryScreen()`, который возвращает указатель на объект основного экрана. Прототип метода:

```c++
#include <QScreen>
static QScreen *primaryScreen()
```

Получить размеры экрана позволяют следующие методы из класса `QScreen`:

> **geometry()** — возвращает экземпляр класса [[QRect|QRect]], содержащий координаты и размеры всего экрана. Прототип метода:
```c++
QRect geometry() const
```
Пример:
```c++
// #include <QScreen>
QScreen *screen = QApplication::primaryScreen();
QRect rect = screen->geometry();
qDebug() << rect.left() << rect.top(); // 0 0
qDebug() << rect.width() << rect.height(); // 1920 1080
```

> **availableGeometry()** — возвращает экземпляр класса [[QRect|QRect]], содержащий координаты и размеры только доступной части экрана (без размера Панели задач). Прототип метода:
```c++
QRect availableGeometry() const
```
Пример:
```c++
QScreen *screen = QApplication::primaryScreen();
QRect rect = screen->availableGeometry();
qDebug() << rect.left() << rect.top(); // 0 0
qDebug() << rect.width() << rect.height(); // 1920 1040
```

Получить список всех экранов позволяет статический метод `screens()` объекта приложения. Прототип метода:
```c++
static QList<QScreen *> screens()
```

Пример отображения окна примерно по центру экрана:

```c++
#include <QApplication>
#include <QWidget>
#include <QScreen>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	QWidget window;
	window.setWindowTitle("Вывод окна по центру экрана");
	window.resize(350, 70);
	
	QScreen *screen = QApplication::primaryScreen();
	QRect rect = screen->geometry();
	
	int x = (rect.width() - window.width()) / 2;
	int y = (rect.height() - window.height()) / 2;
	
	window.move(x, y);
	window.show();
	
	return app.exec();
}
```

В этом примере мы воспользовались методами `width()` и `height()` , которые не учитывают высоту заголовка и ширину границ. В большинстве случаев этого способа достаточно. Если необходима точность при выравнивании, то для получения размеров окна можно воспользоваться методом `frameSize()`. Однако этот метод возвращает корректные значения только после отображения окна. Если код выравнивания по центру расположить после вызова метода `show()`, то окно отобразится сначала в одном месте экрана, а затем переместится в центр, что вызовет неприятное мелькание. Чтобы исключить мелькание, следует сначала отобразить окно за пределами экрана, а затем переместить окно в центр экрана:

```c++
#include <QApplication>
#include <QWidget>
#include <QScreen>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	
	QWidget window;
	window.setWindowTitle("Вывод окна по центру экрана");
	window.resize(350, 70);
	window.move(window.width() * -2, 0);
	window.show();
	
	QScreen *screen = QApplication::primaryScreen();
	QRect rect = screen->geometry();
	
	int x = (rect.width() - window.frameSize().width()) / 2;
	int y = (rect.height() - window.frameSize().height()) / 2;
	
	window.move(x, y);
	
	return app.exec();
}
```

Этот способ можно также использовать для выравнивания окна по правому краю экрана. Например, чтобы расположить окно в правом верхнем углу экрана, следует заменить код, выравнивающий окно по центру, из предыдущего примера следующим кодом:

```c++
QScreen *screen = QApplication::primaryScreen();

QRect rect = screen->availableGeometry();

int x = rect.x() + rect.width() - window.frameSize().width();

window.move(x, rect.y());
```

Если попробовать вывести окно в правом нижнем углу, то может возникнуть проблема, т. к. в операционной системе Windows в нижней части экрана располагается **Панель задач**. В итоге окно будет частично расположено под Панелью задач. Чтобы при размещении окна учитывать местоположение Панели задач, необходимо использовать метод `availableGeometry()`. Получить высоту Панели задач, расположенной в нижней части экрана, можно, например, так:

```c++
QScreen *screen = QApplication::primaryScreen();

QRect rect = screen->geometry();
int taskBarHeight = rect.height() -

screen->availableGeometry().height();
```

Следует также заметить, что в некоторых операционных системах Панель задач может быть прикреплена к любой стороне экрана. Кроме того, экран может быть разделен на несколько рабочих столов. Все это необходимо учитывать при размещении окна. За подробной информацией обращайтесь к документации по классу [[QScreen|QScreen]]

## Указание координат и размеров

В двух предыдущих разделах были упомянуты классы [[QPoint|QPoint]], [[QSize|QSize]] и [[QRect|QRect]]. Класс [[QPoint|QPoint]] описывает координаты точки, класс [[QSize|QSize]] — размеры, а класс [[QRect|QRect]] — координаты и размеры прямоугольной области. Рассмотрим эти классы более подробно.

> Классы [[QPoint|QPoint]], [[QSize|QSize]] и [[QRect|QRect]] предназначены для работы с целыми числами. Чтобы работать с вещественными числами, необходимо использовать классы [[QPoint|QPointF]], [[QSize|QSizeF]] и [[QRect|QRectF]] соответственно.

## Разворачивание и сворачивание окна

В заголовке окна расположены кнопки Свернуть и Развернуть, с помощью которых можно свернуть окно в значок на Панели задач или максимально развернуть окно. Выполнить подобные действия из программы позволяют следующие методы класса `QWidget` 

> **showMinimized()** — сворачивает окно на Панель задач. Эквивалентно нажатию кнопки Свернуть в заголовке окна. Метод является слотом. Прототип метода:
```c++
void showMinimized()
```

> **showMaximized()** — разворачивает окно до максимального размера. Эквивалент-но нажатию кнопки Развернуть в заголовке окна. Метод является слотом. Прототип метода:
```c++
void showMaximized()
```

> **showFullScreen()** — включает полноэкранный режим отображения окна. Окно отображается без заголовка и границ. Метод является слотом. Прототип метода:
```c++
void showFullScreen()
```

> **showNormal()** — отменяет сворачивание, максимальный размер и полноэкранный режим. Метод является слотом. Прототип метода:
```c++
void showNormal()
```

> **activateWindow()** — делает окно активным (т. е. имеющим фокус ввода). В Windows, если окно было ранее свернуто в значок на Панель задач, то оно автоматически не будет отображено на экране. В этом случае станет активным только значок на Панели задач. Прототип метода:
```c++
void activateWindow()
```

> **setWindowState()** — изменяет статус окна в зависимости от переданных флагов. Прототип метода:
```c++
void setWindowState(Qt::WindowStates windowState)
```

> В качестве параметра указывается комбинация следующих констант через побитовые операторы:
* **Qt::WindowNoState** — нормальное состояние окна;
* **Qt::WindowMinimized** — окно свернуто;
* **Qt::WindowMaximized** — окно максимально развернуто;
* **Qt::WindowFullScreen** — полноэкранный режим;
* **Qt::WindowActive** — окно имеет фокус ввода, т. е. является активным.

Например, включить полноэкранный режим можно так:
```c++
this->setWindowState((this->windowState() &
			~(Qt::WindowMinimized | Qt::WindowMaximized))
			| Qt::WindowFullScreen);
```

Проверить статус окна позволяют следующие методы:

> **isMinimized()** — возвращает `true`, если окно свернуто, и `false` — в противном случае. Прототип метода:
```c++
bool isMinimized() const
```

> **isMaximized()** — возвращает `true`, если окно раскрыто до максимальных размеров, и `false` — в противном случае. Прототип метода:
```c++
bool isMaximized() const
```

> **isFullScreen()** — возвращает `true`, если включен полноэкранный режим, и `false` — в противном случае. Прототип метода:
```c++
bool isFullScreen() const
```

> **isActiveWindow()** — возвращает `true`, если окно имеет фокус ввода, и `false` — в противном случае. Прототип метода:
```c++
bool isActiveWindow() const
```

> **windowState()** — возвращает комбинацию флагов, обозначающих статус окна. Прототип метода:
```c++
Qt::WindowStates windowState() const
```

Пример проверки использования полноэкранного режима:

```c++
if (this->windowState() & Qt::WindowFullScreen) {
	qDebug() << "Полноэкранный режим";
}
```

Пример разворачивания и сворачивания окна:
```c++
#include <QApplication>
#include <QWidget>
#include <QPushButton>
#include <QVBoxLayout>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	QWidget window;
	
	window.setWindowTitle("Разворачивание и сворачивание окна");
	window.resize(350, 200);
	
	QPushButton *btnMin = new QPushButton("Свернуть");
	QPushButton *btnMax = new QPushButton("Развернуть");
	QPushButton *btnFull = new QPushButton("Полный экран");
	QPushButton *btnNormal = new QPushButton("Нормальный размер");
	
	QVBoxLayout *vbox = new QVBoxLayout();
	
	vbox->addWidget(btnMin);
	vbox->addWidget(btnMax);
	vbox->addWidget(btnFull);
	vbox->addWidget(btnNormal);
	window.setLayout(vbox);
	
	QObject::connect(btnMin, SIGNAL(clicked()), &window, SLOT(showMinimized()));
	QObject::connect(btnMax, SIGNAL(clicked()), &window, SLOT(showMaximized()));
	QObject::connect(btnFull, SIGNAL(clicked()), &window, SLOT(showFullScreen()));
	QObject::connect(btnNormal, SIGNAL(clicked()), &window, SLOT(showNormal()));
	
	window.show();
	
	return app.exec();
}
```

## Управление прозрачностью окна

Сделать окно полупрозрачным позволяет метод `setWindowOpacity()` из класса `QWidget`. Прототип метода:

```c++
void setWindowOpacity(qreal level)
```

В качестве параметра указывается вещественное число от 0.0 до 1.0 . Число 0.0 соответствует полностью прозрачному окну, а число 1.0 — отсутствию прозрачности. Для получения степени прозрачности окна из программы предназначен метод `windowOpacity()`, который возвращает вещественное число от 0.0 до 1.0 . Прототип метода:

```c++
qreal windowOpacity() const
```

Выведем окно со степенью прозрачности 0.5.
```c++
#include <QApplication>
#include <QWidget>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	QWidget window;
	
	window.setWindowTitle("Полупрозрачное окно");
	window.resize(350, 100);
	window.setWindowOpacity(0.5);
	window.show();
	
	qDebug() << window.windowOpacity(); // 0.498039
	
	return app.exec();
}
```

## Модальные окна

Модальным называется окно, которое не позволяет взаимодействовать с другими окнами в том же приложении. Пока модальное окно не будет закрыто, сделать активным другое окно нельзя. Например, если в программе Microsoft Word выбрать пункт меню `Файл | Сохранить как`, то откроется модальное диалоговое окно, позволяющее выбрать путь и название файла. Пока это окно не будет закрыто, вы не сможете взаимодействовать с главным окном приложения.

Указать, что окно является модальным, позволяет метод `setWindowModality()` из класса `QWidget` . Прототип метода:
```c++
void setWindowModality(Qt::WindowModality windowModality)
```

В качестве параметра могут быть указаны следующие константы:

> **Qt::NonModal** — окно не является модальным;
> 
> **Qt::WindowModal** — окно блокирует только родительские окна в пределах иерархии;
> 
> **Qt::ApplicationModal** — окно блокирует все окна в приложении.

Окна, открытые из модального окна, не блокируются. Следует также учитывать, что метод `setWindowModality()` должен быть вызван до отображения окна.

Получить текущее значение позволяет метод `windowModality()`. Проверить, является ли окно модальным, можно с помощью метода `isModal()`. Метод возвращает `true`, если окно является модальным, и `false` — в противном случае. Прототипы методов:

```c++
Qt::WindowModality windowModality() const
bool isModal() const
```

Создадим два независимых окна. В первом окне разместим кнопку, при нажатии которой откроем модальное окно. Это модальное окно будет блокировать только первое окно, но не второе. При открытии модального окна отобразим его примерно по центру родительского окна. Содержимое файла `widget.h`, `widget.cpp` и файла ниже:

Widget.
```c++
#include <QPushButton>
#include <QVBoxLayout>

class Widget : public QWidget
{
	Q_OBJECT

	public:
		Widget(QWidget *parent=nullptr);
		~Widget();
		
	private slots:
		void on_btn1_clicked();
		
	private:
		QPushButton *btn1;
		QVBoxLayout *vbox;
};
#endif // WIDGET_H
```

widget.cpp

```c++
#include "widget.h"

Widget::Widget(QWidget *parent)
	: QWidget(parent)
{
	btn1 = new QPushButton("Открыть модальное окно");
	vbox = new QVBoxLayout();
	vbox->addWidget(btn1);
	
	setLayout(vbox);
	
	connect(btn1, SIGNAL(clicked()),
	this, SLOT(on_btn1_clicked()));
}

void Widget::on_btn1_clicked()
{
	QWidget *w = new QWidget(this, Qt::Window);
	w->setWindowTitle("Модальное окно");
	w->resize(300, 50);
	w->setWindowModality(Qt::WindowModal);
	w->setAttribute(Qt::WA_DeleteOnClose, true);
	w->move(frameGeometry().center() - w->rect().center());
	w->show();
}

Widget::~Widget() {}
```

main.cpp
```c++
#include "widget.h"

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	
	Widget window;
	window.setWindowTitle("Обычное окно");
	window.resize(350, 100);
	window.show();
	
	QWidget window2;
	window2.setWindowTitle(
	"Это окно не будет блокировано при WindowModal");
	window2.resize(500, 100);
	window2.show();
	
	return app.exec();
}
```

Если запустить приложение и нажать кнопку `Открыть модальное окно`, то откроется окно, выровненное примерно (произвести точное выравнивание вы сможете самостоятельно) по центру родительского окна. При этом получить доступ к родительскому окну можно только при закрытии модального окна, а второе окно блокировано не будет. Если заменить константу `Qt::WindowModal` константой `Qt::ApplicationModal`, то оба окна будут блокированы.

Обратите внимание на то, что в конструктор модального окна мы передали указатель на первое окно и константу `Qt::Window`. Если указатель не передать, то окно блокировано не будет, а если константу не указать, то окно вообще не откроется. Чтобы объект окна автоматически удалялся при закрытии окна, константе `Qt::WA_DeleteOnClose` в методе `setAttribute()` было присвоено значение `true`.

Модальные окна в большинстве случаев являются диалоговыми. Для работы с диалоговыми окнами в Qt предназначен класс `QDialog` , который автоматически выравнивает окно по центру экрана или по центру родительского окна. Кроме того, этот класс предоставляет множество специальных методов, позволяющих дождаться закрытия окна, определить статус завершения и многое другое. 

## Смена значка в заголовке окна

По умолчанию в левом верхнем углу окна отображается стандартный значок. Отобразить другой значок в заголовке окна позволяет метод `setWindowIcon()` из класса `QWidget`. В качестве параметра метод принимает экземпляр класса [[QIcon|QIcon]] . Прототип метода:
```c++
void setWindowIcon(const QIcon &icon)
```

Чтобы загрузить значок из файла, следует передать путь к файлу конструктору класса. Если указан относительный путь, то поиск файла будет производиться относительно текущего рабочего каталога. Получить список поддерживаемых форматов файлов можно с помощью статического метода `supportedImageFormats()` из класса [[QImageReader|QImageReader]]. Метод возвращает список с экземплярами класса [[QByteArray|QByteArray]].

Прототип метода:
```c++
#include <QImageReader>

static QList<QByteArray> supportedImageFormats()
```

Получим список поддерживаемых форматов:

```c++
qDebug() << QImageReader::supportedImageFormats();
```

Результат выполнения на моем компьютере:

```c++
QList("bmp", "cur", "gif", "ico", "jpeg", "jpg", "pbm", "pgm", "png", "ppm", "svg", "svgz", "xbm", "xpm")
```

Если для окна не задан значок, то будет использоваться значок приложения, установленный с помощью метода `setWindowIcon()` из класса `QApplication`. В качестве параметра метод принимает экземпляр класса [[QIcon|QIcon]] . Прототип метода:

```c++
void setWindowIcon(const QIcon &icon)
```

Вместо загрузки значка из файла можно воспользоваться одним из встроенных значков. Загрузить стандартный значок позволяет следующий код:

```c++
// #include <QIcon>
// #include <QStyle>

QIcon ico = window.style()->standardIcon(
QStyle::SP_MessageBoxCritical);
window.setWindowIcon(ico);
```

Посмотреть список всех встроенных значков можно в документации к классу [[QStyle|QStyle]].

В качестве примера создаем значок в формате `ICO` и сохраняем его в одной папке с программой, а далее устанавливаем этот значок для окна и для всего приложения.

```c++
#include <QApplication>
#include <QWidget>
#include <QIcon>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	
	QWidget window;
	window.setWindowTitle("Смена значка в заголовке окна");
	window.resize(350, 70);

	QIcon ico("C:\\cpp\\projectsQt\\Test\\test.ico");
	window.setWindowIcon(ico); // Значок для окна
	app.setWindowIcon(ico); // Значок для приложения
	window.show();
	
	return app.exec();
}
```

## Изменение цвета фона окна

Чтобы изменить цвет фона окна (или компонента), следует установить палитру с настроенной ролью Window. Цветовая палитра содержит цвета для каждой роли и состояния компонента. Указать состояние компонента позволяют следующие константы из класса [[QPalette|QPalette]]: 

> **Active** и **Normal** — компонент активен (окно находится в фокусе ввода);
> 
> **Disabled** — компонент недоступен;
> 
> **Inactive** — компонент неактивен (окно находится вне фокуса ввода).

Получить текущую палитру компонента позволяет метод `palette()`. Прототип метода:
```c++
const QPalette &palette() const
```

Чтобы изменить цвет для какой-либо роли и состояния, следует воспользоваться методом `setColor()` из класса [[QPalette|QPalette]] . Прототипы метода:
```c++
#include <QPalette>

void setColor(QPalette::ColorRole role, const QColor &color)
void setColor(QPalette::ColorGroup group, QPalette::ColorRole role, const QColor &color)
```

В параметре `role` указывается, для какого элемента изменяется цвет. Например, константа Window изменяет цвет фона, а `WindowText` — цвет текста. Полный список констант смотрите в документации по классу [[QPalette|QPalette]].

В параметре `color` указывается цвет элемента. В качестве значения можно указать константы (например: `Qt::black`, `Qt::red` и т. д.) или экземпляр класса [[QColor|QColor]] (например: `QColor("red")`, `QColor(255, 0, 0)` и др.).

После настройки палитры необходимо вызвать метод `setPalette()` и передать ему измененный объект палитры. Прототип метода:

```c++
void setPalette(const QPalette &)
```

Следует помнить, что компоненты-потомки по умолчанию имеют прозрачный фон и не перерисовываются автоматически. Чтобы включить перерисовку, необходимо передать значение `true` методу `setAutoFillBackground()`. Прототип метода:
```c++
void setAutoFillBackground(bool enabled)
```

Изменить цвет фона можно также с помощью CSS-атрибута `background-color`. Для этого следует передать таблицу стилей в метод `setStyleSheet()` . Прототип метода:
```c++
void setStyleSheet(const QString &styleSheet)
```

Таблицы стилей могут быть внешними (подключение через командную строку), установленными на уровне приложения (с помощью метода `setStyleSheet()` из класса `QApplication`) или установленными на уровне компонента (с помощью метода `setStyleSheet()` из класса `QWidget`). Атрибуты, установленные последними, обычно перекрывают значения аналогичных атрибутов, указанных ранее. Если вы занимались веб-программированием, то CSS вам уже знаком, а если нет, то придется дополнительно изучить HTML и CSS.

Создадим окно с надписью. Для активного окна установим зеленый цвет, а для неактивного — красный. Цвет фона надписи сделаем белым. Для изменения фона окна будем устанавливать палитру, а для изменения цвета фона надписи — CSS-атрибут `background-color`.

```c++
#include <QApplication>
#include <QWidget>
#include <QLabel>
#include <QVBoxLayout>
#include <QPalette>
#include <QColor>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);

	QWidget window;
	window.setWindowTitle("Изменение цвета фона окна");
	window.resize(350, 70);
	
	QPalette pal = window.palette();
	pal.setColor(QPalette::Normal, QPalette::Window,
	QColor(0, 128, 0));
	pal.setColor(QPalette::Inactive, QPalette::Window,
	QColor(255, 0, 0));
	window.setPalette(pal);
	
	QLabel *label = new QLabel("Текст надписи");
	label->setAlignment(Qt::AlignCenter);
	label->setStyleSheet("background-color: #ffffff;");
	label->setAutoFillBackground(true);
	
	QVBoxLayout *vbox = new QVBoxLayout;
	vbox->addWidget(label);
	window.setLayout(vbox);
	window.show();

	return app.exec();
}
```

## Использование изображения в качестве фона

В качестве фона окна (или компонента) можно использовать изображение. Для этого необходимо получить текущую палитру компонента с помощью метода `palette()`, а затем вызвать метод `setBrush()` из класса [[QPalette|QPalette]] . Прототипы метода:

```c++
void setBrush(QPalette::ColorRole role, const QBrush &brush)
void setBrush(QPalette::ColorGroup group, QPalette::ColorRole role, const QBrush &brush)
```

Параметры `group` и `role` аналогичны соответствующим параметрам в методе `setColor()`, который мы рассматривали в предыдущем разделе. В параметре `brush` указывается экземпляр класса [[QBrush|QBrush]] . Прототипы конструктора класса:
```c++
#include <QBrush>

QBrush()
QBrush(Qt::BrushStyle style)
QBrush(Qt::GlobalColor color, Qt::BrushStyle style = Qt::SolidPattern)
QBrush(const QColor &color, Qt::BrushStyle style = Qt::SolidPattern)
QBrush(Qt::GlobalColor color, const QPixmap &pixmap)
QBrush(const QColor &color, const QPixmap &pixmap)
QBrush(const QPixmap &pixmap)
QBrush(const QImage &image)
QBrush(const QGradient &gradient)
QBrush(const QBrush &other)
```

В параметре `style` указываются константы, задающие стиль кисти, например:

* **Qt::NoBrush**
* **Qt::SolidPattern**
* **Qt::Dense1Pattern**
* **Qt::Dense2Pattern**
* **Qt::Dense3Pattern**
* **Qt::Dense4Pattern**
* **Qt::Dense5Pattern**
* **Qt::Dense6Pattern**
* **Qt::Dense7Pattern**
* **Qt::CrossPattern**
 
др. С помощью этого параметра можно сделать цвет сплошным (`Qt::SolidPattern`) или имеющим текстуру (например, константа `Qt::CrossPattern` задает текстуру в виде сетки).

В параметре color указывается цвет кисти. В качестве значения можно указать константы (например: `Qt::black`, `Qt::red` и т. д.) или экземпляр класса [[QColor|QColor]] (например: `QColor("red")`, `QColor(255, 0, 0)` и др.). Например, установка сплошного цвета фона окна выглядит так:

```c++
QPalette pal = window.palette();
pal.setBrush(QPalette::Normal, QPalette::Window, QBrush(QColor(0, 128, 0), Qt::SolidPattern));
window.setPalette(pal);
```

Параметры `pixmap` и `image` позволяют передать объекты изображений. Конструкторы этих классов принимают путь к файлу, который может быть как абсолютным, так и относительным. Основные прототипы конструкторов:

```c++
QPixmap(const QString &fileName, const char *format = nullptr,
					Qt::ImageConversionFlags flags = Qt::AutoColor)

QImage(const QString &fileName, const char *format = nullptr)
```

После настройки палитры необходимо вызвать метод `setPalette()` и передать ему измененный объект палитры. Следует помнить, что компоненты-потомки по умолчанию имеют прозрачный фон и не перерисовываются автоматически. Чтобы включить перерисовку, необходимо передать значение `true` в метод `setAutoFillBackground()`.

Указать, что изображение используется в качестве фона, можно также с помощью
CSS-атрибутов `background` и `background-image`. С помощью CSS-атрибута `background-repeat` можно дополнительно указать режим повтора фонового рисунка. Он может принимать значения `repeat`, `repeat-x` (повтор только по горизонтали), `repeat-y` (повтор только по вертикали) и `no-repeat` (не повторяется).

Создадим окно с надписью. Для активного окна установим одно изображение (с помощью изменения палитры), а для надписи — другое изображение (с помощью CSS-атрибута `background-image`).

```c++
#include <QApplication>
#include <QWidget>
#include <QLabel>
#include <QVBoxLayout>
#include <QPalette>
#include <QPixmap>
#include <QBrush>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	
	QWidget window;
	window.setWindowTitle("Изображение в качестве фона");
	window.resize(350, 70);
	
	QPalette pal = window.palette();
	pal.setBrush(QPalette::Normal, QPalette::Window,
	
	QBrush(QPixmap("C:\\cpp\\projectsQt\\Test\\texture2.jpg")));
	
	window.setPalette(pal);
	
	QLabel *label = new QLabel("Текст надписи");
	label->setAlignment(Qt::AlignCenter);
	label->setStyleSheet( 
				"background-image: url(C:/cpp/projectsQt/Test/texture.jpg);");
	label->setAutoFillBackground(true);

	QVBoxLayout *vbox = new QVBoxLayout;
	vbox->addWidget(label);
	
	window.setLayout(vbox);
	window.show();
	
	return app.exec();
}
```

## Создание окна произвольной формы

Чтобы создать окно произвольной формы, необходимо выполнить следующие шаги:

> создать изображение нужной формы с прозрачным фоном и сохранить его, например, в формате `PNG`;
> 
> создать экземпляр класса [[QPixmap|QPixmap]] , передав конструктору класса абсолютный или относительный путь к изображению;
> 
> установить изображение в качестве фона окна с помощью палитры;
> 
> отделить альфа-канал с помощью метода `mask()` из класса [[QPixmap|QPixmap]] . Прототип метода:
```c++
QBitmap mask() const
```

> передать маску в метод `setMask()` объекта окна. Прототип метода: 
```c++
void setMask(const QBitmap &bitmap)
```

> убрать рамку окна, например передав комбинацию следующих флагов:
```c++
Qt::Window | Qt::FramelessWindowHint
```

Если для создания окна используется класс `QLabel`, то вместо установки палитры можно передать экземпляр класса [[QPixmap|QPixmap]] в метод `setPixmap()`, а маску — в метод `setMask()`. Прототипы методов:

```c++
void setPixmap(const QPixmap &)
void setMask(const QBitmap &bitmap)
```

В качестве примера создадим круглое окно с кнопкой, с помощью которой можно закрыть окно. Окно выведем без заголовка и границ

```c++
#include <QApplication>
#include <QWidget>
#include <QPushButton>
#include <QPalette>
#include <QPixmap>
#include <QBrush>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);

	QWidget window;
	window.setWindowTitle("Создание окна произвольной формы");
	window.setWindowFlags(Qt::Window | Qt::FramelessWindowHint);
	window.resize(300, 300);
	
	QPixmap pixmap("C:\\cpp\\projectsQt\\Test\\fon.png");
	QPalette pal = window.palette();
	pal.setBrush(QPalette::Normal, QPalette::Window,
	
	QBrush(pixmap));
	pal.setBrush(QPalette::Inactive, QPalette::Window,
	QBrush(pixmap));
	
	window.setPalette(pal);
	window.setMask(pixmap.mask());
	
	QPushButton *button = new QPushButton("Закрыть окно", &window);
	button->setFixedSize(150, 30);
	button->move(75, 135);
	
	QObject::connect(button, SIGNAL(clicked()),
	qApp, SLOT(quit()));
	window.show();
	
	return app.exec();
}
```

## Всплывающие подсказки

При работе с программой у пользователя могут возникать вопросы: для чего предназначен тот или иной компонент? Обычно для информирования пользователя используются надписи, расположенные над компонентом или перед ним. Но часто место в окне либо ограничено, либо вывод таких надписей испортит весь дизайн окна. В таких случаях принято выводить текст подсказки в отдельном окне без рамки при наведении указателя мыши на компонент. После выведения указателя окно должно автоматически закрываться.

В Qt нет необходимости создавать окно с подсказкой самому и следить за перемещениями указателя мыши. Весь процесс автоматизирован и максимально упрощен. Чтобы создать всплывающие подсказки для окна или любого другого компонента и управлять ими, нужно воспользоваться следующими методами из класса `QWidget`.

>  **setToolTip()** — задает текст вплывающей подсказки. В качестве параметра можно указать простой текст или текст в формате HTML. Чтобы отключить вывод подсказки, достаточно передать в этот метод пустую строку. Прототип метода:
```c++
void setToolTip(const QString &)
```

 > **toolTip()** — возвращает текст всплывающей подсказки. Прототип метода:
```c++
QString toolTip() const
```

> **setWhatsThis()** — задает текст справки. Обычно этот метод используется для вывода информации большего объема, чем во всплывающей подсказке. Чтобы отобразить текст справки, необходимо сделать компонент активным и нажать комбинацию клавиш `<Shift>+<F1>`. Кроме того, в заголовке окна может быть кнопка Справка. После нажатия этой кнопки вид курсора изменится на стрелку со знаком вопроса. Чтобы в этом случае отобразить текст справки, следует щелкнуть мышью на компоненте. В качестве параметра можно указать простой текст или текст в формате HTML. Чтобы отключить вывод подсказки, достаточно передать в этот метод пустую строку. Прототип метода:
```c++
void setWhatsThis(const QString &)
```

> **whatsThis()** — возвращает текст справки. Прототип метода:
```c++
QString whatsThis() const
```

Создадим окно с кнопкой и зададим для них текст всплывающих подсказок и текст справки

```c++
#include <QApplication>
#include <QWidget>
#include <QPushButton>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);

	QWidget window;
	window.setWindowTitle("Всплывающие подсказки");
	window.setWindowFlags(Qt::Window |
						Qt::WindowCloseButtonHint |
						Qt::WindowContextHelpButtonHint);
	window.resize(300, 70);

	QPushButton *button = new QPushButton("Закрыть окно", &window);
	button->setFixedSize(150, 30);
	button->move(75, 20);
	button->setToolTip("Это всплывающая подсказка для кнопки");
	window.setToolTip("Это всплывающая подсказка для окна");
	
	button->setWhatsThis("Это справка для кнопки");
	window.setWhatsThis("Это справка для окна");
	
	QObject::connect(button, SIGNAL(clicked()), qApp, SLOT(quit()));

	window.show();
	
	return app.exec();
}
```

## Закрытие окна из программы

В предыдущих разделах для закрытия окна мы использовали слот `quit()` объекта приложения. Прототип метода:
```c++
void quit()
```

Однако этот метод не только закрывает текущее окно, но и завершает выполнение всего приложения. Чтобы закрыть только текущее окно, следует воспользоваться слотом `close()` из класса `QWidget`. Прототип метода:
```c++
bool close()
```

Метод возвращает значение `true`, если окно успешно закрыто, и `false` — в противном случае. Закрыть сразу все окна приложения позволяет слот `closeAllWindows()` из класса `QApplication`. Прототип метода:
```c++
void closeAllWindows()
```

Если для окна константа `Qt::WA_DeleteOnClose` установлена в истинное значение, то после закрытия окна объект окна будет автоматически удален. Если константа имеет ложное значение, то окно просто скрывается. Значение можно изменить с помощью метода `setAttribute()`:
```c++
w->setAttribute(Qt::WA_DeleteOnClose, true);
```

После вызова метода `close()` или нажатия кнопки Закрыть в заголовке окна генерируется событие `QEvent::Close`. Если внутри класса определить метод с предопределенным названием `closeEvent()`, то это событие можно перехватить и обработать. Прототип метода:
```c++
virtual void closeEvent(QCloseEvent *event)
```

В качестве параметра метод принимает указатель на объект класса `QCloseEvent`, который содержит методы `accept()` (позволяет закрыть окно) и `ignore()` (запрещает закрытие окна). Вызывая эти методы, можно контролировать процесс закрытия окна. Прототипы методов:
```c++
void accept()
void ignore()
```

В качестве примера закроем окно при нажатии кнопки

```c++
#include <QApplication>
#include <QWidget>
#include <QPushButton>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	
	QWidget window;
	window.setWindowTitle("Закрытие окна из программы");
	window.resize(350, 70);
	
	QPushButton *button = new QPushButton("Закрыть окно", &window);
	button->setFixedSize(150, 30);
	button->move(75, 20);
	
	QObject::connect(button, SIGNAL(clicked()),
	
	&window, SLOT(close()));
	window.show();
	
	return app.exec();
}
```

