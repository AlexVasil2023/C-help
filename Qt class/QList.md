# QList

QList является классом, основанным на шаблоне, и должен быть инициализирован типом. Он также является неявно разделяемым и хранит данные внутри кучи. Все контейнерные классы должны создаваться на стеке. Обычно не используется `new QList<T>()` , что означает, что `new` с контейнером не используется.

`QList` так же универсален, как и класс [[QString|QString]], и предлагает отличный API для работы с данными. Ниже приведен небольшой пример использования списка и его итерации с использованием некоторых новых возможностей C++ 11.

```c++
// Создание простого списка интов с использованием нового инициализатора C++11
// для этого в файл pro необходимо добавить "CONFIG += c++11".
QList<int> list{1,2};

// добавляем еще один
список int list << 3;

// Мы используем диапазоны, чтобы избежать столкновения имен переменных
{ // итерация по списку с помощью Qt for each
	int sum(0);
	
	foreach (int v, list) {
		sum += v;
	}
	
	QVERIFY(sum == 6);
}

{ // итерация по списку с помощью цикла на основе диапазона в C++ 11 
	int sum = 0;
	
	for(int v : list) {
		sum+= v;
	}
	
	QVERIFY(sum == 6);
}

{ // итерация по списку с использованием итераторов в стиле JAVA 
	int sum = 0;
	QListIterator<int> i(list);
	
	while (i.hasNext()) {
		sum += i.next();
	}
	
	QVERIFY(sum == 6);
}

{ // итерация по списку с использованием итератора в стиле STL 
	int sum = 0;
	QList<int>::iterator i;
	
	for (i = list.begin(); i != list.end(); ++i) {
		sum += *i;
	}
	
	QVERIFY(sum == 6);
}

// использование std::sort с мутабельным итератором на C++11
// список будет отсортирован в порядке убывания
std::sort(list.begin(), list.end(), [](int a, int b) { return a < b}
QVERIFY(list == QList<int>({3,2,1}));

int value = 3;
{ // использование std::find с const итератором
	QList<int>::const_iterator result = std::find(list.constBeg
	QVERIFY(*result == value);
}

{ // использование std::find с использованием лямбд C++ и автопеременной C++ 11 
	auto result =
		std::find_if(list.constBegin(), list.constBeg
		
	QVERIFY(*result == value);
}
```

