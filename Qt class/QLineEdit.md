[[#Однострочное текстовое поле]]
	1. [[#Основные методы и сигналы]]
	2. [[#Ввод данных по маске]]
	3. [[#Контроль ввода]]

# Однострочное текстовое поле

Однострочное текстовое поле предназначено для ввода и редактирования текста небольшого объема. С его помощью можно также отобразить вводимые символы в виде звездочек (например, чтобы скрыть пароль) или вообще не отображать их (например, чтобы скрыть длину пароля). Поле по умолчанию поддерживает технологию `drag & drop`, стандартные комбинации клавиш быстрого доступа, работу с буфером обмена и многое другое. Однострочное текстовое поле реализуется с помощью класса `QLineEdit`. Иерархия наследования:

```
(QObject, QPaintDevice) — QWidget — QLineEdit
```

Конструктор класса `QLineEdit` имеет два формата:
```c++
#include <QLineEdit>

QLineEdit(const QString &contents, QWidget *parent = nullptr)
QLineEdit(QWidget *parent = nullptr)
```

В параметре `parent` передается указатель на родительский компонент. Если параметр не указан или имеет значение [[nullptr_t|nullptr]], то компонент будет обладать своим собственным окном. Параметр `contents` позволяет задать текст, который будет отображен в однострочном текстовом поле. Пример:
```c++
QLineEdit *lineEdit = new QLineEdit("Начальное значение");
```
## Основные методы и сигналы

Класс `QLineEdit` содержит следующие методы (перечислены только основные методы; полный список смотрите в документации):

> **setEchoMode()** — задает режим отображения текста. Прототип метода:
```c++
void setEchoMode(QLineEdit::EchoMode)
```

Могут быть указаны следующие константы:
* **QLineEdit::Normal** — показывать символы, как они были введены;
* **QLineEdit::NoEcho** — не показывать вводимые символы;
* **QLineEdit::Password** — вместо символов показывать символ `*`;
* **QLineEdit::PasswordEchoOnEdit** — показывать символы при вводе, а при потере фокуса отображать символ `*`.

Получение значения:
```c++
QLineEdit::EchoMode echoMode() const
```

> **setCompleter()** — позволяет предлагать возможные варианты значений, начинающиеся с введенных пользователем символов. Прототип метода:
```c++
void setCompleter(QCompleter *c)
```

Пример:
```c++
QLineEdit *lineEdit = new QLineEdit();

QStringList list;
list << "кадр" << "каменный" << "камень" << "камера";

QCompleter *completer = new QCompleter(list, &window);
completer->setCaseSensitivity(Qt::CaseInsensitive);

lineEdit->setCompleter(completer);
```

Получение значения:
```c++
QCompleter *completer() const
```

> **setReadOnly()** — если в качестве параметра указано значение `true`, то поле будет доступно только для чтения. Прототип метода:
```c++
void setReadOnly(bool)
```

> **isReadOnly()** — возвращает значение `true`, если поле доступно только для чтения, и `false` — в противном случае. Прототип метода:
```c++
bool isReadOnly() const
```

> **setAlignment()** — задает выравнивание текста внутри поля. Прототип метода:
```c++
void setAlignment(Qt::Alignment flag)
```

Получение значения:
```c++
Qt::Alignment alignment() const
```

> **setMaxLength()** — задает максимальное количество символов. Прототип метода:
```c++
void setMaxLength(int)
```

Получение значения:
```c++
int maxLength() const
```

> **setFrame()** — если в качестве параметра указано значение `false`, то поле будет отображаться без рамки. Прототип метода:
```c++
void setFrame(bool)
```

Получение значения:
```c++
bool hasFrame() const
```

> **setClearButtonEnabled()** — если в качестве параметра указано значение `true`, то в правой части поля будет отображаться значок, при щелчке на котором поле очищается. Если поле пустое, то значок не отображается. Прототип метода:
```c++
void setClearButtonEnabled(bool enable)
```

Получение значения:
```c++
bool isClearButtonEnabled() const
```

> **setDragEnabled()** — если в качестве параметра указано значение `true`, то режим перетаскивания текста из текстового поля с помощью мыши будет включен. По умолчанию однострочное текстовое поле только принимает перетаскиваемый текст. Прототип метода:
```c++
void setDragEnabled(bool)
```

Получение значения:
```c++
bool dragEnabled() const
```

> **setPlaceholderText()** — задает текст подсказки пользователю, который будет выводиться в поле, когда оно не содержит значения и находится вне фокуса ввода. Прототип метода:
```c++
void setPlaceholderText(const QString &)
```

Получение значения:
```c++
QString placeholderText() const
```

> **setText()** — вставляет указанный текст в поле. Метод является слотом. Прототип метода:
```c++
void setText(const QString &)
```

> **insert()** — вставляет текст в текущую позицию текстового курсора. Если в поле был выделен фрагмент, то он будет удален. Прототип метода:
```c++
void insert(const QString &)
```

> **text()** — возвращает текст, содержащийся в текстовом поле. Прототип метода:
```c++
QString text() const
```

> **displayText()** — возвращает текст, который видит пользователь. Результат зависит от режима отображения, заданного с помощью метода `setEchoMode()`. Например, в режиме `Password` строка будет состоять из символов `*`. Прототип метода:
```c++
QString displayText() const 
```

> **selectedText()** — возвращает выделенный фрагмент или пустую строку. Прототип метода:
```c++
QString selectedText() const
```

> **clear()** — удаляет весь текст из поля. Метод является слотом. Прототип метода:
```c++
void clear()
```

> **backspace()** — удаляет выделенный фрагмент. Если выделенного фрагмента нет, то удаляет символ, стоящий слева от текстового курсора. Прототип метода:
```c++
void backspace()
```

> **del()** — удаляет выделенный фрагмент. Если выделенного фрагмента нет, то удаляет символ, стоящий справа от текстового курсора. Прототип метода:
```c++
void del()
```

> **setSelection()** — выделяет фрагмент длиной length, начиная с позиции `start`. Во втором параметре можно указать отрицательное значение. Прототип метода:
```c++
void setSelection(int start, int length)
```

> **selectAll()** — выделяет весь текст в поле. Метод является слотом. Прототип метода:
```c++
void selectAll()
```

> **selectionStart()** — возвращает начальный индекс выделенного фрагмента или значение `–1`, если ничего не выделено. Прототип метода:
```c++
int selectionStart() const
```

> **selectionEnd()** — возвращает конечный индекс выделенного фрагмента или значение `–1`, если ничего не выделено. Прототип метода:
```c++
int selectionEnd() const
```

> **selectionLength()** — возвращает длину выделенного фрагмента. Прототип метода:
```c++
int selectionLength() const
```

> **hasSelectedText()** — возвращает значение true, если поле содержит выделенный фрагмент, и `false` — в противном случае. Прототип метода:
```c++
bool hasSelectedText() const
```

> **deselect()** — снимает выделение. Прототип метода:
```c++
void deselect()
```

> **setCursorPosition()** — задает положение текстового курсора. Прототип метода:
```c++
void setCursorPosition(int)
```

> **cursorPosition()** — возвращает текущее положение текстового курсора. Прототип метода:
```c++
int cursorPosition() const
```

> **cursorForward()** — перемещает текстовый курсор вперед на указанное во втором параметре количество символов. Если в первом параметре указано значение `true`, то фрагмент выделяется. Прототип метода:
```c++
void cursorForward(bool mark, int steps = 1)
```

> **cursorBackward()** — перемещает текстовый курсор назад на указанное во втором параметре количество символов. Если в первом параметре указано значение `true`, то фрагмент выделяется. Прототип метода:
```c++
void cursorBackward(bool mark, int steps = 1)
```

> **cursorWordForward()** — перемещает текстовый курсор вперед на одно слово. Если в параметре указано значение `true`, то фрагмент выделяется. Прототип метода:
```c++
void cursorWordForward(bool mark)
```

> **cursorWordBackward()** — перемещает текстовый курсор назад на одно слово. Если в параметре указано значение true, то фрагмент выделяется. Прототип метода:
```c++
void cursorWordBackward(bool mark)
```

> **home()** — перемещает текстовый курсор в начало поля. Если в параметре указано значение `true`, то фрагмент выделяется. Прототип метода:
```c++
void home(bool mark)
```

> **end()** — перемещает текстовый курсор в конец поля. Если в параметре указано значение `true`, то фрагмент выделяется. Прототип метода:
```c++
void end(bool mark)
```

> **cut()** — копирует выделенный текст в буфер обмена, а затем удаляет его из поля при условии, что есть выделенный фрагмент и используется режим `Normal`. Метод является слотом. Прототип метода:
```c++
void cut()
```

> **copy()** — копирует выделенный текст в буфер обмена при условии, что есть выделенный фрагмент и используется режим `Normal`. Метод является слотом. Прототип метода:
```c++
void copy() const
```

> **paste()** — вставляет текст из буфера обмена в текущую позицию текстового курсора при условии, что поле доступно для редактирования. Метод является слотом. Прототип метода:
```c++
void paste()
```

> **undo()** — отменяет последнюю операцию ввода пользователем при условии, что отмена возможна. Метод является слотом. Прототип метода:
```c++
void undo()
```

> **redo()** — повторяет последнюю отмененную операцию ввода пользователем, если это возможно. Метод является слотом. Прототип метода:
```c++
void redo()
```

> **isUndoAvailable()** — возвращает значение true, если можно отменить последнюю операцию ввода, и `false` — в противном случае. Прототип метода:
```c++
bool isUndoAvailable() const
```

> **isRedoAvailable()** — возвращает значение `true`, если можно повторить последнюю отмененную операцию ввода, и `false` — в противном случае. Прототип метода:
```c++
bool isRedoAvailable() const
```

> **createStandardContextMenu()** — создает стандартное меню, которое отображается при щелчке правой кнопкой мыши в текстовом поле. Чтобы изменить стандартное меню, следует создать класс, наследующий класс `QLineEdit`, и переопределить метод `contextMenuEvent()`. Внутри этого метода можно создать свое собственное меню или добавить новый пункт в стандартное меню. Прототипы методов:
```c++
QMenu *createStandardContextMenu()
virtual void contextMenuEvent(QContextMenuEvent *event)
```

> **setTextMargins()** — задает отступы между линией рамки и текстом. Прототипы метода:
```c++
void setTextMargins(int left, int top, int right, int bottom)
void setTextMargins(const QMargins &margins)
```

Получение значения:
```c++
QMargins textMargins() const
```

Класс `QLineEdit` содержит следующие сигналы:

> **cursorPositionChanged(int,int)** — генерируется при перемещении текстового курсора. Внутри обработчика через первый параметр доступна старая позиция курсора, а через второй параметр — новая позиция;
>
> **editingFinished()** — генерируется при нажатии клавиши `<Enter>` или потере полем фокуса ввода;
>
>**returnPressed()** — генерируется при нажатии клавиши `<Enter>`;
>
>**selectionChanged()** — генерируется при изменении выделения;
>
> **inputRejected()** — генерируется при недопустимом вводе;
>
> **textChanged(const QString&)** — генерируется при изменении текста внутри поля пользователем или программно. Внутри обработчика через параметр доступно новое значение;
> 
> **textEdited(const QString&)** — генерируется при изменении текста внутри поля пользователем. Сигнал не генерируется при изменении текста с помощью метода `setText()`. Внутри обработчика через параметр доступно новое значение.

## Ввод данных по маске

С помощью метода `setInputMask()` можно ограничить ввод символов допустимым диапазоном значений. Прототип метода:
```c++
void setInputMask(const QString &inputMask)
```

Получение значения:
```c++
QString inputMask() const
```

В качестве параметра указывается строка, имеющая следующий формат:
```
"<Последовательность символов>[;<Символ-заполнитель>]"
```

В первом параметре указывается комбинация из следующих специальных символов:

> **`9`** — обязательна цифра от 0 до 9;
> **`0`** — разрешена, но не обязательна цифра от 0 до 9;
> **`D`** — обязательна цифра от 1 до 9;
> **`d`** — разрешена, но не обязательна цифра от 1 до 9;
> **`B`** — обязательна цифра 0 или 1;
> **`b`** — разрешена, но не обязательна цифра 0 или 1;
> **`H`** — обязателен шестнадцатеричный символ (0-9, A-F, a-f);
> **`h`** — разрешен, но не обязателен шестнадцатеричный символ (0-9, A-F, a-f);
> **`#`** — разрешена, но не обязательна цифра или знак «плюс» или «минус»;
> **`A`** — обязательна латинская буква в любом регистре;
> **`a`** — разрешена, но не обязательна латинская буква в любом регистре;
> **`N`** — обязательна латинская буква в любом регистре или цифра от 0 до 9;
> **`n`** — разрешена, но не обязательна латинская буква в любом регистре или цифра от 0 до 9;
> **`X`** — обязателен любой символ;
> **`x`** — разрешен, но не обязателен любой символ;
> **`>`** — все последующие буквы переводятся в верхний регистр;
> **`<`** — все последующие буквы переводятся в нижний регистр;
> **`!`** — отключает изменение регистра;
> **`\`** — используется для отмены действия спецсимволов.

Все остальные символы трактуются как есть. В необязательном параметре `<Символ-заполнитель>` можно указать символ, который будет отображаться в поле, обозначая место ввода. Если параметр не указан, то символом является пробел. Пример:
```c++
lineEdit->setInputMask("Дата: 99.B9.9999;#"); // Дата: ##.##.####
lineEdit->setInputMask("Дата: 99.B9.9999;_"); // Дата: __.__.____
lineEdit->setInputMask("Дата: 99.B9.9999 г."); // Дата: . . г.
```

Проверить соответствие введенных данных маске позволяет метод `hasAcceptableInput()`. Если данные соответствуют маске, то метод возвращает значение `true`, в противном случае — `false`. Прототип метода:

```c++
bool hasAcceptableInput() const
```

## Контроль ввода

Контролировать ввод данных позволяет метод `setValidator()`. Прототип метода:
```c++
void setValidator(const QValidator *v)
```

В качестве значения указывается экземпляр класса, наследующего класс `QValidator`. Существуют следующие стандартные классы, позволяющие контролировать ввод данных:

> **QIntValidator** — допускает ввод только целых чисел. Функциональность класса зависит от настройки локали. Форматы конструктора:
```c++
#include <QIntValidator>

QIntValidator(int minimum, int maximum, QObject *parent = nullptr
QIntValidator(QObject *parent = nullptr)
```

Пример ограничения ввода диапазоном целых чисел от 0 до 100:
```c++
lineEdit->setValidator(new QIntValidator(0, 100, this));
```

> **QDoubleValidator** — допускает ввод только вещественных чисел. Функциональность класса зависит от настройки локали. Форматы конструктора:
```c++
#include <QDoubleValidator>

QDoubleValidator(double bottom, double top, int decimals,
QObject *parent = nullptr)
QDoubleValidator(QObject *parent = nullptr)
```

Пример ограничения ввода диапазоном вещественных чисел от 0.0 до 100.0 и двумя цифрами после десятичной точки:
```c++
lineEdit->setValidator(new QDoubleValidator(0.0, 100.0, 2, this));
```

Чтобы позволить вводить числа в экспоненциальной форме, необходимо передать значение константы `ScientificNotation` в метод `setNotation()`. Если передать значение константы `StandardNotation`, то число должно быть только в десятичной форме. Пример:
```c++
QDoubleValidator *validator = new QDoubleValidator(0.0, 100.0, 2, this);
validator->setNotation(QDoubleValidator::StandardNotation);
lineEdit->setValidator(validator);
```

> **QRegularExpressionValidator** — позволяет проверить данные на соответствие шаблону регулярного выражения. Форматы конструктора:
```C++
#include <QRegularExpressionValidator>

QRegularExpressionValidator(const QRegularExpression &re,
							QObject *parent = nullptr)
							
QRegularExpressionValidator(QObject *parent = nullptr)
```

Пример ввода только цифр от 0 до 9:
```C++
QRegularExpression p("[0-9]+");
QRegularExpressionValidator *validator = 
					new QRegularExpressionValidator(p, this);
lineEdit->setValidator(validator);
```

Обратите внимание на то, что производится проверка полного соответствия шаблону, поэтому символы `^` и `$` явным образом указывать не нужно. Проверить
соответствие введенных  данных условию позволяет метод `hasAcceptableInput()`. Если данные соответствуют условию, то метод возвращает значение `true`, в противном случае — `false`. Прототип метода:

```C++
bool hasAcceptableInput() const
```







