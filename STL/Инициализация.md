
[[#Инициализация]]
[[auto#Вывод типа auto|Вывод типа auto]]
[[auto]]

# Инициализация

Прежде чем объект можно будет использовать, ему должно быть присвоено значение. C++ предлагает различные варианты записи для выражения инициализации, таких как `=`, используемое выше, и универсальную форму, основанную на списках инициализаторов, заключённых в фигурные скобки:
```c++
double d1 = 2.3;                   // initialize d1 to 2.3
double d2 {2.3};                   // initialize d2 to 2.3
double d3 = {2.3};                 // initialize d3 to 2.3 (the = is optional
								  // with { ... })
complex<double> z = 1;             // a complex number with double-precision
								  // floating-point scalars
complex<double> z2 {d1,d2};
complex<double> z3 = {d1,d2};      // the = is optional with { ... }
vector<int> v {1, 2, 3, 4, 5, 6};  // a vector of ints
```

Форма `=` является традиционной и восходит к C, но, если вы сомневаетесь, используйте общую форму списка инициализаторов `{}`. По крайней мере, это избавит вас от приведений типов, при которых теряется информация:
```c++
int i1 = 7.8;                      // i1 becomes 7 (surprise?)
int i2 {7.8};                      // error: floating-point to integer conversion
```

К сожалению, преобразования, которые теряют информацию, сужающие преобразования, такие как из `double` в `int` и из `int` в `char`, разрешены и неявно применяются при использовании `=` (но не при использовании `{}`). Проблемы, вызванные неявными сужающими преобразованиями, являются платой за совместимость с `C`.

Константы нельзя оставлять неинициализированными, а переменную следует оставлять неинициализированной только в крайне редких случаях. Не вводите имя до тех пор, пока у вас не будет подходящего значения для него. Пользовательские типы (такие как [[string|string]], [[vector|vector]], [[Matrix|Matrix]], [[Motor_controller|Motor_controller]] или [[Orc_warrior|Orc_warrior]]) могут быть определены как неявно инициализируемые.

При определении переменной вам не нужно явно указывать ее тип, если тип может быть выведен из инициализатора:
```c++
auto b = true;          // a bool
auto ch = x ;           // a char
auto i = 123;           // an int
auto d = 1.2;           // a double
auto z = sqrt(y);       // z has the type of whatever sqrt(y) returns
auto bb {true};         // bb is a bool
```

При использовании [[auto|auto]] мы склонны использовать `=`, поскольку здесь не требуется потенциально сложное преобразование типов, но, если вы предпочитаете последовательно использовать инициализацию `{}`, вы можете сделать это. Мы используем [[auto|auto]] там, где у нас нет конкретной причины явно указывать тип. “Конкретные причины” включают:
* Определение находится в большой области видимости, где мы хотим сделать тип четко видимым для читателей нашего кода.
* Тип инициализатора неочевиден.
* Мы хотим четко указать диапазон или точность переменной (например, `double`, а не `float`)

Используя [[auto|auto]], мы избегаем избыточности и написания длинных имен типов. Это особенно важно в обобщённом программировании, где программисту может быть
трудно определить точный тип объекта, а имена типов могут быть довольно длинными.

