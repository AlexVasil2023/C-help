
1. [[#Введение|Введение]] 17.1
2. [[#Математические функции|Математические функции]] 17.2
3. [[#Численные алгоритмы|Численные алгоритмы]] 17.3
	1. [[#Многопоточные численные алгоритмы|Многопоточные численные алгоритмы]] 17.3.1
4. [[#Комплексные числа|Комплексные числа]] 17.4
5. [[#Случайные числа|Случайные числа]] 17.5
6. [[#Векторная арифметика|Векторная арифметика]] 17.6
7. [[#Числовые ограничения|Числовые ограничения]] 17.7
8. [[#Псевдонимы типов|Псевдонимы типов]] 17.8
9. [[#Математические константы|Математические константы]] 17.9



# Введение

C++ не был разработан в первую очередь с учетом числовых вычислений. Однако числовые вычисления обычно выполняются в контексте другой работы – такой, как научные вычисления, доступ к базам данных, создание сетей, управление приборами, графика, моделирование и финансовый анализ, – поэтому C++ становится привлекательным средством для вычислений, которые являются частью более крупной системы. Кроме того, числовые методы прошли долгий путь от простых циклов над векторами чисел с плавающей запятой. Там, где в рамках вычислений требуются более сложные структуры данных, преимущества C++ становятся актуальными. Конечным результатом является то, что C++ широко используется для научных, инженерных, финансовых и других вычислений, связанных со сложными числами. Следовательно, появились средства и методы, поддерживающие такие вычисления. В этой главе описываются части стандартной библиотеки, поддерживающие численные методы.

# Математические функции

В `<cmath>` мы находим стандартные математические функции, такие как [[sqrt|sqrt()]], [[log|log()]] и [[sin|sin()]] для аргументов типа `float`, `double` и `long double`:

|                     | Некоторые стандартные математические функции                         |
| ------------------- | -------------------------------------------------------------------- |
| [[abs\|abs(x)]]     | Абсолютное значение                                                  |
| [[ceil\|ceil(x)]]   | Округление до целого в большую сторону `>= x`                        |
| [[floor\|floor(x)]] | Округление до целого в меньшую сторону `<= x`                        |
| [[sqrt\|sqrt(x)]]   | Квадратный корень; `x` не отрицательный                              |
| [[cos\|cos(x)]]     | Косинус                                                              |
| [[sin\|sin(x)]]     | Синус                                                                |
| [[tan\|tan(x)]]     | Тангенс                                                              |
| [[acos\|acos(x)]]   | Аркосинус; результат не отрицательный                                |
| [[asin\|asin(x)]]   | Арксинус; возвращается результат, ближайший к 0                      |
| [[atan\|atan(x)]]   | Арктангенс                                                           |
| [[sinh\|sinh(x)]]   | Гиперболический синус                                                |
| [[cosh\|cosh(x)]]   | Гиперболический косинус                                              |
| [[tanh\|tanh(x)]]   | Гиперболический тангенс                                              |
| [[exp\|exp(x)]]     | Экспонента по основанию `е`                                          |
| [[exp2\|exp2(x)]]   | Экспонента по основанию 2                                            |
| [[log\|log(x)]]     | Натуральный логарифм по основанию `е`; `x` должен быть положительным |
| [[log2\|log2(x)]]   | Натуральный логарифм по основанию `2`; `x` должен быть положительным |
| [[log10\|log10(x)]] | Логарифм по основанию `10`; `x` должен быть положительным            |

Версии этих функций для complex ( #§17_4) приведены в `<complex>`. Для каждой функции возвращаемый тип совпадает с типом аргумента.

Об ошибках сообщается путем установки `errno` из `<cerrno>` в `EDOM` для ошибки домена и в `ERANGE` для ошибки диапазона. Например:
```c++
errno = 0;            // clear old error state
double d = sqrt(-1);
if (errno==EDOM)
	cerr << "sqrt() not defined for negative argument\n";

errno = 0;           // clear old error state
double dd = pow(numeric_limits<double>::max(),2);
if (errno == ERANGE)
	cerr << "result of pow() too large to represent as a double\n";
```

Дополнительные математические функции можно найти в `<cmath>` и `<cstdlib>`. Так называемые специальные математические функции, такие как [[beta|beta()]], [[rieman_zeta|rieman_zeta()]] и [[sph_bessel|sph_bessel()]], также находятся в `<cmath>`.

# Численные алгоритмы

В `<numeric>` мы находим небольшой набор обобщенных численных алгоритмов, таких как [[accumulate|accumulate()]].

|                                                            | Численные алгоритмы                                                                                                                                                 |
| ---------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [[accumulate\|x=accumulate(b,e,i)]]                        | `x` - это сумма `i` и элементов `[b:e)`                                                                                                                             |
| [[accumulate\|x=accumulate(b,e,i,f)]]                      | [[accumulate\|accumulate]] используя функцию `f` вместо `+`                                                                                                         |
| [[inner_product\|x=inner_product(b,e,b2,i)]]               | `x` является внутренним продуктом `[b:e)` и `[b2:b2+(e-b))`, то есть сумма `i` и `(*p1)*(*p2)` для каждого `p1` в `[b:e)` и соответствующего `p2` в `[b2:b2+(e-b))` |
| [[inner_product\|x=inner_product(b,e,b2,i,f,f2)]]          | [[inner_product\|inner_product]] используя функции `f` и `f2` вместо `+` и `*`                                                                                      |
| [[partial_sum\|p=partial_sum(b,e,out)]]                    | Элемент `i` из `[out:p)` является суммой элементов `[b:b+i]`                                                                                                        |
| [[partial_sum\|p=partial_sum(b,e,out,f)]]                  | [[partial_sum\|partial_sum]] используя функцию `f` вместо `+`                                                                                                       |
| [[adjacent_difference\|p=adjacent_difference (b,e,out)]]   | Элемент `i` из `[out:p)` это `*(b+i)-*(b+i-1)` для `i>0`; если `e-b>0`, тогда `*out` это `*b`                                                                       |
| [[adjacent_difference\|p=adjacent_difference (b,e,out,f)]] | [[adjacent_difference\|adjacent_difference]] используя функцию `f` вместо `−`                                                                                       |
| [[iota\|iota(b,e,v)]]                                      | Для каждого элемента в `[b:e)` присваивает `v` и увеличивает `++v`; получаем такую последовательность `v`, `v+1`, `v+2`, ...                                        |
| [[gcd\|x=gcd(n,m)]]                                        | `x` является наибольшим общим знаменателем целых чисел `n` и `m`                                                                                                    |
| [[lcm\|x=lcm(n,m)]]                                        | `x` является наименьшим общим кратным целых чисел `n` и `m`                                                                                                         |
| [[midpoint\|x=midpoint(n,m)]]                              | `x` является средней точкой между `n` и `m`                                                                                                                         |

Эти алгоритмы обобщают распространенные операции, такие как вычисление суммы, позволяя им применяться ко всем видам последовательностей. Они также делают операцию, применяемую к элементам этих последовательностей, параметром. Для каждого алгоритма общая версия дополняется версией, применяющей наиболее распространенный оператор для этого алгоритма. Например:
```c++
list<double> lst {1, 2, 3, 4, 5, 9999.99999};

// calculate the sum: 10014.9999
auto s = accumulate(lst.begin(),lst.end(),0.0); 
```

Эти алгоритмы работают для каждой последовательности из стандартной библиотеки и могут содержать операции, предоставляемые в качестве аргументов ( #§17_3).

## Многопоточные численные алгоритмы

В `<numeric>` численные алгоритмы имеют параллельные версии, которые незначительно отличаются от последовательных. В частности, параллельные версии допускают операции с элементами в неопределенном порядке. Параллельные численные алгоритмы могут принимать аргумент [[Алгоритмы - STL#Параллельные алгоритмы|политики выполнения]]: `seq`, `unseq`, `par` и `par_unseq`.

|                                                                             | Параллельные численные алгоритмы                                                                       |
| --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| [[reduce\|x=reduce(b,e,v)]]                                                 | [[accumulate\|x=accumulate(b,e,v)]], кроме вышедших из строя                                           |
| [[reduce\|x=reduce(b,e)]]                                                   | [[reduce\|x=reduce(b,e,V{})]], где `V` это тип хранилища для `b`                                       |
| [[reduce\|x=reduce(pol,b,e,v)]]                                             | [[reduce\|x=reduce(b,e,v)]] с политикой выполнения `pol`                                               |
| [[reduce\|x=reduce(pol,b,e)]]                                               | [[reduce\|x=reduce(pol,b,e,V{})]], где `V` это тип хранилища для `b`                                   |
| [[exclusive_scan\|p=exclusive_scan (pol,b,e,out)]]                          | [[partial_sum\|p=partial_sum(b,e,out)]] согласно `pol`, исключает `i`-й входной элемент из `i`-й суммы |
| [[inclusive_scan\|p=inclusive_scan (pol,b,e,out)]]                          | [[partial_sum\|p=partial_sum(b,e,out)]] согласно `pol` включает `i`-й входной элемент в `i`-ю сумму    |
| [[transform_reduce\|p=transform_reduce (pol,b,e,f,v)]]                      | `f(x)` для каждого `x` в `[b:e)`, применяет [[reduce\|reduce]]                                         |
| [[transform_exclusive_scan\|p= transform_exclusive_scan (pol,b,e,out,f,v)]] | `f(x)` для каждого `x` в `[b:e)`, применяет [[exclusive_scan\|exclusive_scan]]                         |
| [[transform_inclusive_scan\|p=transform_inclusive_scan (pol,b,e,out,f,v)]]  | `f(x)` для каждого `x` в `[b:e)`, применяет [[inclusive_scan\|inclusive_scan]]                         |

Для простоты я опустил версии этих алгоритмов, которые принимают операции в качестве аргументов, а не просто используют `+` и `=`. За исключением [[reduce|reduce()]], я также опустил версии с политикой по умолчанию (последовательной) и значением по умолчанию.

Точно так же, как для [[Алгоритмы - STL#Параллельные алгоритмы|параллельных алгоритмов в <algorithm>]], мы можем указать политику выполнения:
```c++
vector<double> v {1, 2, 3, 4, 5, 9999.99999};

// calculate the sum using a double as the accumulator
auto s = reduce(v.begin(),v.end());

vector<double> large;
// ... fill large with lots of values ...
auto s2 = reduce(par_unseq, large.begin(),large.end());
// calculate the sum using available parallelism
```

Политики выполнения, `par`, `sec`, `unsec` и `par_unsec` скрыты в пространстве имен `std::execution` в `<execution>`.

Измерьте быстродействие, чтобы убедиться в целесообразности использования параллельного или векторизованного алгоритма.

# Комплексные числа

Стандартная библиотека поддерживает семейство типов комплексных чисел в соответствии с классом [[complex|complex]]. Для поддержки комплексных чисел, где скалярами являются числа с плавающей запятой одинарной точности (`float`), числа с плавающей запятой двойной точности (`double`) и т.д., класс [[complex|complex]] стандартной библиотеки является шаблонным:
```c++
template<typename Scalar>
class complex {
	public:
		// default function arguments
		complex(const Scalar& re ={}, const Scalar& im ={});
		...
};
```

Для комплексных чисел поддерживаются обычные арифметические операции и наиболее распространенные математические функции. Например:
```c++
void f(complex<float> f1, complex<double> db)
{
	complex<long double> ld {f1+sqrt(db)};
	db += f1*3;
	f1 = pow(1/f1,2);
	// ...
}
```

Функции [[sqrt|sqrt()]] и [[pow|pow()]] (возведение в степень) относятся к числу обычных математических функций, [[Числовые вычисления#Математические функции|определенных в <complex>]].

# Случайные числа

Случайные числа полезны во многих контекстах, таких как тестирование, игры, моделирование и безопасность. Разнообразие областей применения отражается в широком выборе генераторов случайных чисел, предоставляемых стандартной библиотекой в `<random>`. Генератор случайных чисел состоит из двух частей:
>
> Генератор, который генерирует последовательность случайных или псевдослучайных значений
> 
> Распределение, которое преобразует эти значения в математическое распределение в диапазоне

Примерами распределений являются `uniform_int_distribution` (где все полученные целые числа имеют равную вероятность), `normal_distribution` (нормальное распределение, “колоколообразная кривая”) и `exponential_distribution` (экспоненциальный рост); каждое для некоторого заданного диапазона. Например:
```c++
using my_engine = default_random_engine;           // type of engine
using my_distribution = uniform_int_distribution<>;// type of distribution

my_engine eng{};               // the default version of the engine
my_distribution dist {1,6};    // distribution that maps to the ints 1..6
auto die = [&](){ return dist(eng); }; // make a generator

int x = die(); // roll the die: x becomes a value in [1:6]
```

Благодаря бескомпромиссному вниманию к универсальности и производительности, один эксперт назвал компонент случайных чисел стандартной библиотеки “тем, чем хочет быть каждая библиотека случайных чисел, когда вырастет”. Однако его вряд ли можно назвать “удобным для новичков”. Операторы `using` и лямбда-выражение делают код, немного более очевидным.

Для новичков (любого уровня подготовки) полностью общий интерфейс библиотеки случайных чисел может стать серьезным препятствием. Для начала часто бывает достаточно простого генератора однородных случайных чисел. Например:
```c++
Rand_int rnd {1,10};  // make a random number generator for [1:10]
int x = rnd();        // x is a number in [1:10]
```

Итак, как мы могли бы это получить? Мы должны получить что-то похожее на, `die()`, объединяющее движок и распределение внутри класса `Rand_int`:
```c++
class Rand_int {
	public:
		Rand_int(int low, int high) :dist{low, high} { }
		int operator()() { return dist(re); }  // draw an int
		void seed(int s) { re.seed(s); } // choose new random engine seed
	private
		default_random_engine re;
		uniform_int_distribution<> dist;
};
```

Это определение по-прежнему относится к “экспертному уровню”, но с использованием `Rand_int()` можно справиться на первой неделе курса C++ для новичков. Например:
```c++
int main()
{
	constexpr int max = 9;
	Rand_int rnd {0,max};       // make a uniform random number generator
	
	vector<int> histogram(max+1); // make a vector of appropriate size
	for (int i=0; i!=200; ++i)
		// fill histogram with the frequencies of numbers [0:max]
		++histogram[rnd()];

	for (int i = 0; i!=histogram.size(); ++i) { // write out a bar graph
		cout << i << '\t' ;
		
		for (int j=0; j!=histogram[i]; ++j) cout <<'*' ;
			cout << '\n' ;
	}
}
```

Результатом является (обнадеживающе скучное) равномерное распределение (с разумным статистическим разбросом):
```c++
0 *********************
1 ****************
2 *******************
3 ********************
4 ****************
5 ***********************
6 **************************
7 ***********
8 **********************
9 *************************
```

Стандартной графической библиотеки для C++ не существует, поэтому я использую “ASCII графику”. Очевидно, что для C++ существует множество графических библиотек с открытым исходным кодом и коммерческих графических интерфейсов, но в этой книге я ограничусь средствами стандарта ISO.

Чтобы получить повторяющуюся или другую последовательность значений, мы указываем `seed` для движка; то есть мы присваиваем его внутреннему состоянию новое значение. Например:
```c++
Rand_int rnd {10,20};
for (int i = 0; i<10; ++i) 
	cout << rnd() << ' ';      // 16 13 20 19 14 17 10 16 15 14
cout << '\n';

rnd.seed(999);
for (int i = 0; i<10; ++i) 
	cout << rnd() << ' ';     // 11 17 14 19 20 13 20 14 16 19
cout << '\n';

rnd.seed(999);
for (int i = 0; i<10; ++i) 
	cout << rnd() << ' ';     // 11 17 14 19 20 13 20 14 16 19
cout << '\n';
```

Повторяющиеся последовательности важны для детерминированной отладки. Заполнение разными значениями важно, когда мы не хотим повторения. Если вам нужны подлинные случайные числа, а не сгенерированная псевдослучайная последовательность, посмотрите, как `random_device` реализован на вашем компьютере.

# Векторная арифметика

[[vector|vector]], был разработан как общий механизм хранения значений, чтобы быть гибким и вписываться в архитектуру контейнеров, итераторов и алгоритмов. Однако он не поддерживает математические векторные операции. Добавить такие операции в [[vector|vector]] было бы несложно, но его общность и гибкость исключают оптимизацию, которая часто считается необходимой для серьезной работы с числами. Следовательно, стандартная библиотека предоставляет (в `<valarray>`) похожий на [[vector|vector]] шаблон, называемый [[valarray|valarray]], который является менее общим и лучше поддается оптимизации для численных вычислений:
```c++
template<typename T>
class valarray {
	// ...
};
```

Для [[valarray|valarray]] поддерживаются обычные арифметические операции и наиболее распространенные математические функции. Например:
```c++
void f(valarray<double>& a1, valarray<double>& a2)
{
	// numeric array operators *, +, /, and =
	valarray<double> a = a1*3.14+a2/a1;

	a2 += a1*3.14;
	a = abs(a);
	double d = a2[7];
	// ...
}
```

Операции являются векторными операциями; то есть они применяются к каждому элементу задействованных векторов.

В дополнение к арифметическим операциям [[valarray|valarray]] предлагает пошаговый доступ для реализации многомерных вычислений.

# Числовые ограничения

В `<limits>` стандартная библиотека предоставляет классы, которые описывают свойства встроенных типов - такие как максимальный показатель степени `float` или количество байт в `int`. Например, мы можем проверить утверждение, что `char` знаковый:
```c++
static_assert(numeric_limits<char>::is_signed,"unsigned characters!");
static_assert(100000<numeric_limits<int>::max(),"small ints!");
```

Второе утверждение работает, только потому что `numeric_limits<int>::max()` является функцией [[constexpr|constexpr]].

Мы можем определить [[numeric_limits|numeric_limits]] для наших собственных пользовательских типов.

# Псевдонимы типов

Размер фундаментальных типов, таких как `int` и `long long` определяется реализацией; то есть они могут отличаться в разных реализациях C++. Если нам нужно уточнить размер наших целых чисел, мы можем использовать псевдонимы, определенные в `<stdint>`, такие как `int32_t` и `uint_least64_t`. Последнее означает целое число без знака длиной не менее 64 бит.

Любопытный суффикс `_t` - это пережиток времен C, когда считалось важным, чтобы имя отражало то, что оно называет псевдоним.

Другие распространенные псевдонимы, такие как [[size#std size_t|size_t]] (тип, возвращаемый оператором [[sizeof|sizeof]]) и [[ptrdiff|ptrdiff_t]] (тип результата вычитания одного указателя из другого), можно найти в `<stddef>`.

# Математические константы

При выполнении математических вычислений нам нужны общие математические константы, такие как `e`, `pi` и `log2e`. Стандартная библиотека предлагает это и многое другое. Они бывают двух форм: шаблон, который позволяет нам указать точный тип (например, `pi_v<T>`) и краткое название для наиболее распространенного использования (например, `pi` означает `pi_v<double>`). Например:
```c++
void area(float r)
{
	// this is where the mathematical constants are kept
	using namespace std::numbers; 
	double d = pi*r*r;
	float f = pi_v<float>*r*r;
	// ...
}
```

В этом случае разница невелика (нам пришлось бы печатать с точностью 16 знаков или около того, чтобы увидеть ее), но в реальных физических расчетах такие различия быстро становятся значительными. Другими областями, где важна точность констант, являются графика и искусственный интеллект, где все большее значение приобретают меньшие представления значений.

В `<numbers>` можно найти `e` (число Эйлера), `log2e` (`log2` из `e`), `log10e` (`log10` из `e`), `pi`,` inv_pi` (`1/pi`), `inv_sqrtpi` (`1/sqrt(pi)`), `ln2`, `ln10`, `sqrt2` (`sqrt(2)`), `sqrt3` (`sqrt(3)`), `inv_sqrt3` (`1/sqrt3`), `egamma` (постоянная Эйлера-Маскерони) и `phi` (золотое сечение).

Естественно, нам хотелось бы иметь больше математических констант и констант для других областей. Это легко сделать, потому что такие константы представляют собой шаблоны переменных со специализациями для `double` (или любого другого типа, наиболее полезного для области применения):
```c++
template<typename T>
constexpr T tau_v = 2*pi_v<T>;
constexpr double tau = tau_v<double>;
```


