
1. [[#Введение|Введение]] 17.1
2. [[#Математические функции|Математические функции]] 17.2
3. [[#Численные алгоритмы|Численные алгоритмы]] 17.3
	1. [[#Многопоточные численные алгоритмы|Многопоточные численные алгоритмы]] 17.3.1



# Введение

	C++ не был разработан в первую очередь с учетом числовых вычислений. Однако числовые вычисления обычно выполняются в контексте другой работы – такой, как научные вычисления, доступ к базам данных, создание сетей, управление приборами, графика, моделирование и финансовый анализ, – поэтому C++ становится привлекательным средством для вычислений, которые являются частью более крупной системы. Кроме того, числовые методы прошли долгий путь от простых циклов над векторами чисел с плавающей запятой. Там, где в рамках вычислений требуются более сложные структуры данных, преимущества C++ становятся актуальными. Конечным результатом является то, что C++ широко используется для научных, инженерных, финансовых и других вычислений, связанных со сложными числами. Следовательно, появились средства и методы, поддерживающие такие вычисления. В этой главе описываются части стандартной библиотеки, поддерживающие численные методы.

# Математические функции

В `<cmath>` мы находим стандартные математические функции, такие как [[sqrt|sqrt()]], [[log|log()]] и [[sin|sin()]] для аргументов типа `float`, `double` и `long double`:

|                     | Некоторые стандартные математические функции                         |
| ------------------- | -------------------------------------------------------------------- |
| [[abs\|abs(x)]]     | Абсолютное значение                                                  |
| [[ceil\|ceil(x)]]   | Округление до целого в большую сторону `>= x`                        |
| [[floor\|floor(x)]] | Округление до целого в меньшую сторону `<= x`                        |
| [[sqrt\|sqrt(x)]]   | Квадратный корень; `x` не отрицательный                              |
| [[cos\|cos(x)]]     | Косинус                                                              |
| [[sin\|sin(x)]]     | Синус                                                                |
| [[tan\|tan(x)]]     | Тангенс                                                              |
| [[acos\|acos(x)]]   | Аркосинус; результат не отрицательный                                |
| [[asin\|asin(x)]]   | Арксинус; возвращается результат, ближайший к 0                      |
| [[atan\|atan(x)]]   | Арктангенс                                                           |
| [[sinh\|sinh(x)]]   | Гиперболический синус                                                |
| [[cosh\|cosh(x)]]   | Гиперболический косинус                                              |
| [[tanh\|tanh(x)]]   | Гиперболический тангенс                                              |
| [[exp\|exp(x)]]     | Экспонента по основанию `е`                                          |
| [[exp2\|exp2(x)]]   | Экспонента по основанию 2                                            |
| [[log\|log(x)]]     | Натуральный логарифм по основанию `е`; `x` должен быть положительным |
| [[log2\|log2(x)]]   | Натуральный логарифм по основанию `2`; `x` должен быть положительным |
| [[log10\|log10(x)]] | Логарифм по основанию `10`; `x` должен быть положительным            |

Версии этих функций для complex ( #§17_4) приведены в `<complex>`. Для каждой функции возвращаемый тип совпадает с типом аргумента.

Об ошибках сообщается путем установки `errno` из `<cerrno>` в `EDOM` для ошибки домена и в `ERANGE` для ошибки диапазона. Например:
```c++
errno = 0;            // clear old error state
double d = sqrt(-1);
if (errno==EDOM)
	cerr << "sqrt() not defined for negative argument\n";

errno = 0;           // clear old error state
double dd = pow(numeric_limits<double>::max(),2);
if (errno == ERANGE)
	cerr << "result of pow() too large to represent as a double\n";
```

Дополнительные математические функции можно найти в `<cmath>` и `<cstdlib>`. Так называемые специальные математические функции, такие как [[beta|beta()]], [[rieman_zeta|rieman_zeta()]] и [[sph_bessel|sph_bessel()]], также находятся в `<cmath>`.

# Численные алгоритмы

В `<numeric>` мы находим небольшой набор обобщенных численных алгоритмов, таких как [[accumulate|accumulate()]].

|                                                            | Численные алгоритмы                                                                                                                                                 |
| ---------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [[accumulate\|x=accumulate(b,e,i)]]                        | `x` - это сумма `i` и элементов `[b:e)`                                                                                                                             |
| [[accumulate\|x=accumulate(b,e,i,f)]]                      | [[accumulate\|accumulate]] используя функцию `f` вместо `+`                                                                                                         |
| [[inner_product\|x=inner_product(b,e,b2,i)]]               | `x` является внутренним продуктом `[b:e)` и `[b2:b2+(e-b))`, то есть сумма `i` и `(*p1)*(*p2)` для каждого `p1` в `[b:e)` и соответствующего `p2` в `[b2:b2+(e-b))` |
| [[inner_product\|x=inner_product(b,e,b2,i,f,f2)]]          | [[inner_product\|inner_product]] используя функции `f` и `f2` вместо `+` и `*`                                                                                      |
| [[partial_sum\|p=partial_sum(b,e,out)]]                    | Элемент `i` из `[out:p)` является суммой элементов `[b:b+i]`                                                                                                        |
| [[partial_sum\|p=partial_sum(b,e,out,f)]]                  | [[partial_sum\|partial_sum]] используя функцию `f` вместо `+`                                                                                                       |
| [[adjacent_difference\|p=adjacent_difference (b,e,out)]]   | Элемент `i` из `[out:p)` это `*(b+i)-*(b+i-1)` для `i>0`; если `e-b>0`, тогда `*out` это `*b`                                                                       |
| [[adjacent_difference\|p=adjacent_difference (b,e,out,f)]] | [[adjacent_difference\|adjacent_difference]] используя функцию `f` вместо `−`                                                                                       |
| [[iota\|iota(b,e,v)]]                                      | Для каждого элемента в `[b:e)` присваивает `v` и увеличивает `++v`; получаем такую последовательность `v`, `v+1`, `v+2`, ...                                        |
| [[gcd\|x=gcd(n,m)]]                                        | `x` является наибольшим общим знаменателем целых чисел `n` и `m`                                                                                                    |
| [[lcm\|x=lcm(n,m)]]                                        | `x` является наименьшим общим кратным целых чисел `n` и `m`                                                                                                         |
| [[midpoint\|x=midpoint(n,m)]]                              | `x` является средней точкой между `n` и `m`                                                                                                                         |

Эти алгоритмы обобщают распространенные операции, такие как вычисление суммы, позволяя им применяться ко всем видам последовательностей. Они также делают операцию, применяемую к элементам этих последовательностей, параметром. Для каждого алгоритма общая версия дополняется версией, применяющей наиболее распространенный оператор для этого алгоритма. Например:
```c++
list<double> lst {1, 2, 3, 4, 5, 9999.99999};

// calculate the sum: 10014.9999
auto s = accumulate(lst.begin(),lst.end(),0.0); 
```

Эти алгоритмы работают для каждой последовательности из стандартной библиотеки и могут содержать операции, предоставляемые в качестве аргументов ( #§17_3).

## Многопоточные численные алгоритмы

В `<numeric>` численные алгоритмы имеют параллельные версии, которые незначительно отличаются от последовательных. В частности, параллельные версии допускают операции с элементами в неопределенном порядке. Параллельные численные алгоритмы могут принимать аргумент [[Алгоритмы - STL#Параллельные алгоритмы|политики выполнения]]: `seq`, `unseq`, `par` и `par_unseq`.

|                                                                             | Параллельные численные алгоритмы                                                                       |
| --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| [[reduce\|x=reduce(b,e,v)]]                                                 | [[accumulate\|x=accumulate(b,e,v)]], кроме вышедших из строя                                           |
| [[reduce\|x=reduce(b,e)]]                                                   | [[reduce\|x=reduce(b,e,V{})]], где `V` это тип хранилища для `b`                                       |
| [[reduce\|x=reduce(pol,b,e,v)]]                                             | [[reduce\|x=reduce(b,e,v)]] с политикой выполнения `pol`                                               |
| [[reduce\|x=reduce(pol,b,e)]]                                               | [[reduce\|x=reduce(pol,b,e,V{})]], где `V` это тип хранилища для `b`                                   |
| [[exclusive_scan\|p=exclusive_scan (pol,b,e,out)]]                          | [[partial_sum\|p=partial_sum(b,e,out)]] согласно `pol`, исключает `i`-й входной элемент из `i`-й суммы |
| [[inclusive_scan\|p=inclusive_scan (pol,b,e,out)]]                          | [[partial_sum\|p=partial_sum(b,e,out)]] согласно `pol` включает `i`-й входной элемент в `i`-ю сумму    |
| [[transform_reduce\|p=transform_reduce (pol,b,e,f,v)]]                      | `f(x)` для каждого `x` в `[b:e)`, применяет [[reduce\|reduce]]                                         |
| [[transform_exclusive_scan\|p= transform_exclusive_scan (pol,b,e,out,f,v)]] | `f(x)` для каждого `x` в `[b:e)`, применяет [[exclusive_scan\|exclusive_scan]]                         |
| [[transform_inclusive_scan\|p=transform_inclusive_scan (pol,b,e,out,f,v)]]  | `f(x)` для каждого `x` в `[b:e)`, применяет [[inclusive_scan\|inclusive_scan]]                         |

Для простоты я опустил версии этих алгоритмов, которые принимают операции в качестве аргументов, а не просто используют `+` и `=`. За исключением [[reduce|reduce()]], я также опустил версии с политикой по умолчанию (последовательной) и значением по умолчанию.

Точно так же, как для [[Алгоритмы - STL#Параллельные алгоритмы|параллельных алгоритмов в <algorithm>]], мы можем указать политику выполнения:
```c++
vector<double> v {1, 2, 3, 4, 5, 9999.99999};

// calculate the sum using a double as the accumulator
auto s = reduce(v.begin(),v.end());

vector<double> large;
// ... fill large with lots of values ...
auto s2 = reduce(par_unseq, large.begin(),large.end());
// calculate the sum using available parallelism
```





































