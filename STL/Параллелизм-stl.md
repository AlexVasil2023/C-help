
1. [[#Введение|Введение]] 18.1
2. [[#Задачи и thread|Задачи и thread]] 18.2
	1. [[#Передача аргументов|Передача аргументов]] 18.2.1
	2. [[#Возвращение результатов|Возвращение результатов]] 18.2.2
3. [[#Обмен данными|Обмен данными]] 18.3


# Введение

***===Параллелизм===*** – выполнение нескольких задач одновременно – широко используется для повышения пропускной способности (за счет использования нескольких процессоров для одного вычисления) или для повышения быстродействия (позволяя одной части программы выполнять работу, в то время как другая ожидает ответа). Все современные языки программирования обеспечивают поддержку этого. Поддержка, предоставляемая стандартной библиотекой C++, является переносимым и типобезопасным вариантом того, что используется в C++ уже более 20 лет и почти повсеместно поддерживается современным оборудованием. Поддержка стандартной библиотеки в первую очередь направлена на поддержку параллелизма на системном уровне, а не на прямое предоставление сложных моделей параллелизма более высокого уровня; они могут поставляться в виде библиотек, созданных с использованием средств стандартной библиотеки.

Стандартная библиотека напрямую поддерживает одновременное выполнение нескольких потоков в одном адресном пространстве. Чтобы обеспечить это, C++ предоставляет подходящую модель памяти и набор атомарных операций. Атомарные операции позволяют программировать без блокировок. Модель памяти гарантирует, что до тех пор, пока программист избегает состояния гонки за данные (неконтролируемый параллельный доступ к изменяемым данным), все работает так, как можно было бы наивно ожидать. Однако большинство пользователей увидят параллелизм только в терминах стандартной библиотеки и библиотек, построенных поверх нее. В этом разделе кратко приведены примеры основных средств поддержки параллелизма стандартной библиотеки: [[thread|thread]], [[mutex|mutex]], операции [[lock|lock()]], [[packaged_task|packaged_task]] и [[future|future]]. Эти функции основаны непосредственно на том, что предлагают операционные системы, и не приводят к снижению производительности по сравнению с ними. Они также не гарантируют значительного повышения производительности по сравнению с тем, что предлагает операционная система.

Не рассматривайте параллелизм как панацею. Если задачу можно выполнять последовательно, то часто это делается проще и быстрее. Передача информации из одного потока в другой может оказаться на удивление дорогостоящей.

В качестве альтернативы использованию явных функций параллелизма мы часто можем использовать [[Алгоритмы - STL#Параллельные алгоритмы|параллельный алгоритм]] для использования [[Числовые вычисления#Многопоточные численные алгоритмы|нескольких механизмов выполнения для повышения производительности]].

Наконец, C++ поддерживает [[Особенности сопрограмм|корутины (сопрограммы)]], то есть функции, которые сохраняют свое состояние между вызовами.

# Задачи и thread

Мы называем вычисление, которое потенциально может выполняться одновременно с другими вычислениями, [[task|задачей (task)]]. [[thread|Поток (thread)]]- это представление задачи в программе на системном уровне. Задача, которая должна выполняться одновременно с другими задачами, запускается путем создания [[thread|thread]] (находящегося в `<thread>`) с задачей в качестве аргумента. Задача - это функция или функциональный объект:
```c++
void f();               // function

struct F {              // function object
	void operator()();  // F's call operator
};

void user()
{
	thread t1 {f};      // f() executes in separate thread
	thread t2 {F{}};    // F{}() executes in separate thread

	t1.join();          // wait for t1
	t2.join();          // wait for t2
}
```

Функции `join()` гарантируют, что мы не выйдем из `user()` до завершения потоков. “Присоединиться” к потоку означает “дождаться завершения потока”.

Легко забыть `join()`, и результаты этого обычно плохие, поэтому стандартная библиотека предоставляет [[thread#std jthread|jthread]], который является “присоединённым thread”, который следует `RAII` вызывая [[thread#Функции join и detach|join()]] с помощью своего деструктора:
```c++
void user()
{
	jthread t1 {f};    // f() executes in separate thread
	jthread t2 {F{}};  // F{}() executes in separate thread
}
```

Присоединение к потоку выполняется деструкторами, поэтому порядок построения обратный. Здесь мы ждем завершения `t2` до `t1`.

Потоки программы совместно используют одно адресное пространство. В этом потоки отличаются от процессов, которые обычно напрямую не обмениваются данными. Поскольку потоки совместно используют адресное пространство, они могут взаимодействовать через общие объекты ( #§18_3). Такая связь обычно контролируется блокировками или другими механизмами для предотвращения состояние гонки за данные (неконтролируемый параллельный доступ к переменной).

Программирование параллельных задач может быть очень сложным делом. Рассмотрим возможные реализации задач `f` (функция) и `F` (функциональный объект):
```c++
void f()
{
	cout << "Hello ";
}

struct F {
	void operator()() { cout << "Parallel World!\n"; }
};
```

Это пример серьезной ошибки: здесь и `f`, и `F{}` используют объект `cout` без какой-либо формы синхронизации. Результирующий вывод был бы непредсказуемым и мог бы варьироваться при различных выполнениях программы, поскольку порядок выполнения отдельных операций в двух задачах не определен. Программа может выдавать “странный” вывод, например
```
PaHerallllel o World!
```

Только определённая в стандарте гарантия спасает нас от гонки данных в рамках определения [[stream#std ostream|ostream]], которая может привести к сбою.

Чтобы избежать подобных проблем с выходными потоками, либо попросите только один [[thread|thread]] использовать выходной поток, либо используйте [[syncstream#osyncstream|osyncstream]].

При определении задач многопоточной программы наша цель состоит в том, чтобы полностью разделить задачи, за исключением случаев, когда они взаимодействуют простыми и очевидными способами. Самый простой способ представить параллельную задачу как функцию, которая выполняется одновременно с вызывающей ее. Чтобы это сработало, нам просто нужно передать аргументы, вернуть результат и убедиться, что между ними нет использования общих данных (никаких соревнований за данные).

## Передача аргументов

Как правило, для работы задачи требуются данные. Мы можем легко передавать данные (или указатели, или ссылки на данные) в качестве аргументов. Рассмотрим:
```c++
void f(vector<double>& v);   // function: do something with v

struct F {                   // function object: do something with v
	vector<double>& v;
	F(vector<double>& vv) :v{vv} { }
	void operator()();       // application operator
};

int main()
{
	vector<double> some_vec {1, 2, 3, 4, 5, 6, 7, 8, 9};
	vector<double> vec2 {10, 11, 12, 13, 14};

	// f(some_vec) executes in a separate thread
	jthread t1 {f, ref(some_vec)};
	// F(vec2)() executes in a separate thread	
	jthread t2 {F{vec2}};
}
```

`F{vec2}` принимает ссылку на вектор в качестве аргумента в `F`. Теперь `F` может использовать этот вектор, и, надеюсь, никакая другая задача не обращается к `vec2` во время выполнения `F`. Передача `vec2` по значению устранила бы этот риск.

Инициализация с помощью `{f, ref(some_vec)}` использует конструктор вариадик шаблона [[thread|thread]], который может принимать [[Концепты и обобщенное программирование - STL#Шаблоны с переменным числом аргументов|произвольную последовательность аргументов]]. `ref()` - это функция типа из `<functional>`, которая, к сожалению, необходима для указания [[Вариативные шаблоны#Вариативные шаблоны|вариадик шаблону]] обрабатывать `some_vec` как ссылку, а не как объект. Без `ref()` аргумент `some_vec` передавался бы по значению. Компилятор проверяет, что первый аргумент может быть вызван с учетом следующих аргументов, и создает необходимый объект функции для передачи потоку. Таким образом, если `F::operator()()` и `f()` выполняют один и тот же алгоритм, то обработка двух задач примерно эквивалентна: в обоих случаях создается функциональный объект для запуска [[thread|thread]].

# Возвращение результатов

[[Параллелизм-stl#Передача аргументов|В примере]], я передаю аргументы по [[По значению или по ссылке#Передача с помощью неконстантной ссылки|неконстантной ссылке]]. Я делаю это только в том случае, если ожидаю, что [[Программы - STL#Указатели, Массивы и Ссылки|задача изменит значение упомянутых данных]]. Это несколько хитрый, но нередкий способ вернуть результат. Более явный метод заключается в передаче входных данных по [[const|const]] ссылке и передаче указателя или ссылки на местоположение результата в качестве отдельного аргумента:
```c++
// take input from v; place result in *res
void f(const vector<double>& v, double* res);

class F {
	public:
		F(const vector<double>& vv, double* p) :v{vv}, res{p} { }
		void operator()();        // place result in *res
	
	private:
		const vector<double>& v;  // source of input
		double* res;              // target for output
};

double g(const vector<double>&);  // use return value

void user(vector<double>& vec1, vector<double> vec2, vector<double> vec3)
{
	double res1;
	double res2;
	double res3;

	// f(vec1,&res1) executes in a separate thread
	thread t1 {f,cref(vec1),&res1}; 
	// F{vec2,&res2}() executes in a separate thread
	thread t2 {F{vec2,&res2}};
	// capture local variables by reference
	thread t3 { [&](){ res3 = g(vec3); } };

	t1.join();
	t2.join();
	t3.join();
	
	// join before using results
	cout << res1 << ' ' << res2 << ' ' << res3 << '\n';
}
```

Здесь `cref(vec1)` передает [[const|const]] ссылку на `vec1` в качестве аргумента для `t1`.

Это работает, и техника очень распространена, но я не считаю возврат результатов через ссылки особенно элегантным, поэтому я возвращаюсь к этой теме в #§18_5_1.

# Обмен данными








