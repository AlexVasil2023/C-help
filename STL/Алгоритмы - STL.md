
1. [[#Введение|Введение]] 13.1
2. [[iterator#Применение итераторов|Применение итераторов]] 13.2
3. [[iterator#Типы итераторов|Типы итераторов]] 13.3
	1. [[iterator#ostream_iterator и istream_iterator|Потоковые итераторы]] 13.3.1
4. [[#Использование предикатов|Использование предикатов]] 13.4
5. [[#Обзор алгоритмов|Обзор алгоритмов]] 13.5
6. [[#Параллельные алгоритмы|Параллельные алгоритмы]] 13.6

Введение

Структура данных, такая как список или вектор, сама по себе не очень полезна. Чтобы использовать их, нам нужны операции для базового доступа, такие как добавление и удаление элементов (как предусмотрено для [[list|list]] и [[vector|vector]]). Кроме того, мы редко просто храним объекты в контейнере. Мы сортируем их, выводим, извлекаем подмножества, удаляем элементы, ищем объекты и т.д. Поэтому стандартная библиотека предоставляет наиболее распространенные алгоритмы для контейнеров в дополнение к наиболее распространенным типам контейнеров. Например, мы можем просто и эффективно отсортировать [[vector|vector]] из `Entry` и поместить копию каждого уникального элемента [[vector|vector]] в [[list|list]]:
```c++
void f(vector<Entry>& vec, list<Entry>& lst)
{
	// use < for order
	sort(vec.begin(),vec.end()); 

	// don't copy adjacent equal elements
	unique_copy(vec.begin(),vec.end(),lst.begin()); 
}
```

Чтобы этот код сработал, для `Entry` должны быть определены операторы меньше (`<`) и равно (`==`). Например:
```c++
bool operator<(const Entry& x, const Entry& y) // less than
{
	return x.name<y.name; // order Entries by their names
}
```

Стандартный алгоритм выражается в терминах (полуоткрытых) последовательностей элементов. Последовательность представлена парой итераторов, задающих первый элемент и элемент следующий за последним:
![[Algoritm.png]]

В примере функция [[sort|sort()]] сортирует последовательность, определенную парой итераторов `vec.begin()` и `vec.end()`, которая ограничивает все элементы [[vector|vector]]. Для записи (вывода) нам нужно только указать первый записываемый элемент. Если записано более одного элемента, элементы, следующие за этим начальным элементом, будут перезаписаны. Таким образом, чтобы избежать ошибок, `lst` должен содержать по крайней мере
столько элементов, сколько уникальных значений в `vec`.

К сожалению, стандартная библиотека не предлагает абстракцию для поддержки записи в контейнер с проверкой диапазона. Однако мы можем определить один:
```c++
template<typename C>
class Checked_iter 
{
	public:
		using value_type = typename C::value_type;
		using difference_type = int;
		Checked_iter() { throw Missing_container{}; } 

		// default constructor
		Checked_iter(C& cc) : pc{ &cc } {}
		Checked_iter(C& cc, typename C::iterator pp) 
				: pc{ &cc }, p{ pp } {}
		
		Checked_iter& operator++() { check_end(); ++p; 
				return *this; }
		Checked_iter operator++(int) { check_end(); 
				auto t{ *this }; ++p; return t; }
				
		value_type& operator*() const { check_end(); return *p; }
		bool operator==(const Checked_iter& a) 
				const { return p==a.p; }
		bool operator!=(const Checked_iter& a) 
				const { return p!=a.p; }

	private:
		void check_end() const { if (p == pc->end()) 
					throw Overflow{}; }
		C* pc {}; // default initialize to nullptr
		typename C::iterator p = pc->begin();
};
```

Очевидно, что это не качество стандартной библиотеки, но это показывает идею:
```c++
vector<int> v1 {1, 2, 3}; // three elements
vector<int> v2(2); // two elements

copy(v1,v2.begin()); // will overflow
copy(v1,Checked_iter{v2}); // will throw
```

Если бы в примере с чтением и сортировкой мы хотели поместить уникальные элементы в новый список, мы могли бы написать:
```c++
list<Entry> f(vector<Entry>& vec)
{
	list<Entry> res;
	sort(vec.begin(),vec.end());
	// append to res
	unique_copy(vec.begin(),vec.end(),back_inserter(res)); 

	return res;
}
```

Вызов `back_inserter(res)` создает итератор для `res`, который добавляет элементы в конец контейнера, расширяя контейнер, выделяя для них место. Это избавляет нас от необходимости сначала выделять фиксированный объем памяти, а затем заполнять его. Таким образом, стандартные контейнеры плюс функции `back_inserter()` устраняют необходимость в использовании подверженного ошибкам явного управления памятью в
стиле `C` с помощью `realloc()`. В [[list|list]] стандартной библиотеки есть [[Основные операции#Перемещение контейнеров|конструктор перемещения]], который делает возврат `res` по значению эффективным (даже для [[list|list]] из тысяч элементов).

Когда мы находим код в стиле пары итераторов, такой как `sort(vec.begin(),vec.end())`, утомительным, мы можем использовать различные версии алгоритмов и написать `sort(vec)`. Эти две версии эквивалентны. Аналогично, [[for|цикл for]] для диапазонов примерно эквивалентен циклу в стиле `C`, использующему итераторы напрямую:
```c++
// write out all elements of v
for (auto& x : v) cout<<x; 

// write out all elements of v
for (auto p = v.begin(); p!=v.end(); ++p) cout<<*p; 
```

В дополнение к тому, что версия [[for|for]] для диапазонов проще и менее подвержена ошибкам, она часто также более эффективна.

# Применение итераторов

[[iterator#Применение итераторов|см. Применение итераторов]]

# Типы итераторов

[[iterator#Типы итераторов|см. Типы итераторов]]

## Потоковые итераторы
[[iterator#ostream_iterator и istream_iterator|см. Потоковые итераторы]]

# Использование предикатов

В приведённых до настоящего времени примерах алгоритмы просто “встроены” в действие, которое необходимо выполнить для каждого элемента последовательности. Однако мы часто хотим сделать это действие параметром алгоритма. Например, алгоритм [[find|find]] предоставляет удобный способ поиска определенного значения. Более общий вариант ищет элемент, удовлетворяющий указанному требованию - `предикат`. Например, мы могли бы захотеть выполнить поиск в [[map|map]] первого значения, большего чем `42`. [[map|map]] позволяет нам получать доступ к ее элементам в виде последовательности пар (ключ, значение), поэтому мы можем искать `pair<const string, int>` в последовательности `map<string, int>`, где значение `int` больше `42`:
```c++
void f(map<string,int>& m)
{
	auto p = find_if(m,Greater_than{42});
	...
}
```

Здесь Greater_than - это [[Template_STL#Функциональные объекты|функциональный объект]], содержащий значение (42) для сравнения с записью карты типа `pair<string, int>`:
```c++
struct Greater_than {
	int val;
	Greater_than(int v) 
		: val{v} 
	{ }
	bool operator()(const pair<string,int>& r) const 
	{ 
		return r.second > val; 
	}
};
```

Альтернативно и эквивалентно, мы могли бы использовать  [[Template_STL#Функциональные объекты|лямбда-выражение]]:
```c++
auto p = find_if(m, [](const auto& r) { return r.second>42; });
```

Предикат не должен изменять элементы, к которым он применяется.

# Обзор алгоритмов

Общее определение алгоритма - это “конечный набор правил, который задает последовательность операций для решения определенного набора задач `[и]` обладает пятью важными характеристиками: 
>
>Конечностью ... 
>
>Определенностью ... 
>
>Вводом ... 
>
>Выводом ...
>
> Эффективностью”.

В контексте стандартной библиотеки C++ алгоритм - это шаблон функции, работающий с последовательностями элементов.

Стандартная библиотека предоставляет несколько десятков алгоритмов. Алгоритмы определены в пространстве имен `std` и представлены в заголовках `<algorithm>` и `<numeric>`. Все эти алгоритмы стандартной библиотеки принимают последовательности в качестве входных данных. Полуоткрытая последовательность от `b` до `e` называется `[b:e)`. Вот несколько примеров:

Избранные стандартные алгоритмы `<algorithm>`

| `f = for_each(b, e, f)`            | Для каждого элемента `x` в `[b:e)` выполнить `f(x)`                                                                   |
| ---------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| `p=find(b, e, x)`                  | `p` это первый элемент в `[b:e)` такой что `*p==x`                                                                    |
| `p=find_if(b, e, f)`               | `p` это первый элемент в `[b:e)` такой что `f(*p)==true`                                                              |
| `n=count(b, e, x)`                 | `n` количество элементов `*q` в `[b:e)` такое что `*q==x`                                                             |
| `n = count_if(b, e, f)`            | `n` количество элементов `*q` в `[b:e)` такое что `f(*q)==true`                                                       |
| `replace(b, e, v, v2)`             | Заменить элементы `*q` в `[b:e)` такие что `*q==v` элементами `v2`                                                    |
| `replace_if(b, e, f, v2)`          | Заменить элементы `*q` в `[b:e)` такие что `f(*q)==true` элементами `v2`                                              |
| `p = copy(b, e, out)`              | Копировать `[b:e)` в `[out:p)`                                                                                        |
| `p = copy_if(b, e, out, f)`        | Копировать элементы `*q` из `[b:e)` такие что `f(*q)==true` в `[out:p)`                                               |
| `p = move(b, e, out)`              | Переместить `[b:e)` в `[out:p)`                                                                                       |
| `p = unique_copy(b, e, out`        | Копировать `[b:e)` в `[out:p)`; не копирует последующие дубликаты элем.                                               |
| `sort(b,e)`                        | Сортировать элементы `[b:e)` используя `<` в качестве условия сортировки                                              |
| `sort(b,e,f)`                      | Сортировать элементы `[b:e)` используя `f` в качестве условия сортировки                                              |
| `(p1,p2) = equal_range(b, e, v)`   | `[p1:p2)` поддиапазон сортированной последовательности `[b:e)` со<br>значением v; по сути, это бинарный поиск для `v` |
| `p = merge(b, e, b2, e2, out)`     | Объединить две отсортированные последовательности `[b:e)` и<br>`[b2:e2)` в `[out:p)`                                  |
| `p = merge( b, e, b2, e2, out, f)` | Объединить две отсортированные последовательности `[b:e)` и `[b2:e2)` в `[out:p)` используя `f` как компаратор        |

Для каждого алгоритма, принимающего диапазон `[b:e)`, `<ranges>` предлагает версию, которая принимает диапазон. Пожалуйста, помните [[Обзор стандартной библиотеки - STL#Пространство имён ranges|...]], что для использования как традиционной итераторной версии алгоритма стандартной библиотеки, так и его аналога с диапазонами, вам необходимо либо явно квалифицировать вызов, либо использовать `using`.

Эти и многие другие алгоритмы (например, #§17_3) могут быть применены к элементам контейнеров, [[string|string]] и встроенных массивов. 

Некоторые алгоритмы, такие как [[replace|replace()]] и [[sort|sort()]], изменяют значения элементов, но ни один алгоритм не добавляет или не удаляет элементы контейнера. Причина в том, что последовательность не идентифицирует контейнер, содержащий элементы последовательности. Чтобы добавлять или удалять элементы, вам нужно что-то, что знает о контейнере (например, [[back_inserter|back_inserter]]) или непосредственно ссылается на сам контейнер (например, [[push_back|push_back()]] или `erase()`).

Лямбды очень распространены в качестве операций, передаваемых в качестве аргументов. Например:
```c++
vector<int> v = {0,1,2,3,4,5};

for_each(v,[](int& x){ x=x*x; }); // v=={0,1,4,9,16,25}

for_each(v.begin(),v.begin()+3, [](int& x){ x=sqrt(x); }); // v=={0,1,2,9,16,25}
```

Алгоритмы стандартной библиотеки, как правило, более тщательно разработаны, специфицированы и реализованы, чем обычный цикл, созданный вручную. Знайте их и используйте вместо кода, написанного на ”голом” языке.

# Параллельные алгоритмы

Когда одна и та же задача должна быть выполнена со многими элементами данных, мы можем выполнять ее параллельно для каждого элемента данных при условии, что вычисления для разных элементов данных независимы:
>
> ***параллельное выполнение***: задачи выполняются в нескольких потоках (часто на нескольких процессорных ядрах)
> 
> ***векторизованное выполнение***: задачи выполняются в одном потоке с использованием векторизации, также известной как `SIMD` (“Одна инструкция, множество данных”).

Стандартная библиотека предлагает поддержку и того, и другого, и мы можем точно указать необходимость последовательного выполнения; в `<execution>` в пространстве имён `execution` мы находим:

> ***==seq==***: последовательное выполнение
>
> ***==par==***: параллельное выполнение (если возможно)
>
> ***==unseq==***: непоследовательное (векторизованное) выполнение (если возможно)
> 
> ***==par_unseq==***: параллельное и/или непоследовательное (векторизованное) выполнение (если это возможно). 

Рассмотрим [[sort|std::sort()]]:
```c++
sort(v.begin(), v.end()); // sequential
sort(seq, v.begin(), v.end()); // sequential (same as the default)
sort(par, v.begin(), v.end()); // parallel
sort(par_unseq, v.begin(), v.end()); // parallel and/or vectorized
```

Стоит ли распараллеливать и/или векторизовать, зависит от алгоритма, количества элементов в последовательности, аппаратного обеспечения и использования этого оборудования программами, запущенными на нём. Следовательно, индикаторы политики исполнения - это всего лишь подсказки. Компилятор и/или планировщик времени выполнения будут решать, какой объем параллелизма использовать. Все это нетривиально, и здесь очень важно правило, запрещающее делать заявления об эффективности без проведения измерений.

К сожалению, расширенные версии параллельных алгоритмов еще не включены в стандарт, но если они нам понадобятся, их легко определить:
```c++
void sort(auto pol, random_access_range auto& r)
{
	sort(pol,r.begin(),r.end());
}
```
Большинство [[Алгоритмы - STL#Обзор алгоритмов|алгоритмов стандартной библиотеки, включая все из таблицы]], за исключением [[range#equal_range|equal_range]], могут запросить распараллеливание и векторизацию с использованием `par` и `par_unseq`, как для [[sort|sort()]]. Почему не `equal_range()`? Потому что до сих пор никто не придумал для этого стоящего параллельного алгоритма.

Многие параллельные алгоритмы используются в основном для обработки числовых данных; см. #§17_3_1.

Запрашивая параллельное выполнение, обязательно избегайте состояния гонки за данные ( #§18_2) и взаимоблокировок ( #§18_3).

