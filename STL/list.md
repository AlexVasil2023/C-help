
[[#std list|list]] (12.3 STL)
[[#forward_list|forward_list]] (12.4 STL)

# std::list

Стандартная библиотека предлагает двусвязный список, называемый `list`:
![[list.png]]

Мы используем `list` для последовательностей, в которые мы хотим вставлять и удалять элементы, не перемещая другие элементы. Вставка и удаление записей телефонной книги может быть обычным делом, поэтому `list` может быть подходящим для представления простой телефонной книги. Например:
```c++
list<Entry> phone_book = {
	{"David Hume",123456},
	{"Karl Popper",234567},
	{"Bertrand Arthur William Russell",345678}
};
```

Когда мы используем двусвязанный список, мы, как правило, не получаем доступ к элементам, используя индекс, как мы обычно делаем для векторов. Вместо этого мы могли бы выполнить поиск по списку в поисках элемента с заданным значением. Чтобы сделать это, мы воспользуемся тем фактом, что `list` - это последовательность, как описано в #главе_13:
```c++
int get_number(const string& s)
{
	for (const auto& x : phone_book)
		if (x.name==s)
			return x.number;
	
	return 0; // use 0 to represent "number not found"
}
```

Поиск `s` начинается с начала списка и продолжается до тех пор, пока не будет найден `s` или не будет достигнут конец `phone_book`.

Иногда нам нужно идентифицировать элемент в `list`. Например, мы можем захотеть удалить элемент или вставить перед ним новый элемент. Для этого мы используем итератор: итератор `list` указывает на элемент `list` и может использоваться для итерации по `list` (отсюда и его название). Каждый контейнер стандартной библиотеки предоставляет функции `begin()` и `end()`, которые возвращают итератор  на первый и на следующийза последним элемент соответственно ( #§13_1). Используя итераторы явно, мы можем менее элегантно – написать функцию `get_number()` следующим образом
```C++
int get_number(const string& s)
{
	for (auto p = phone_book.begin(); p!=phone_book.end(); ++p)
		if (p->name==s)
			return p->number;
			
	return 0; 
}
```

На самом деле, примерно так компилятор реализует более краткий и менее подверженный ошибкам [[for|цикл for]] для диапазона. Учитывая что `p` это итератор, `*p` - это элемент, на который он ссылается, `++p` передвигает `p` для ссылки на следующий элемент, и когда `p` ссылается на класс с членом `m`, тогда `p->m `эквивалентно `(*p).m`.

Добавлять элементы в `list` и удалять элементы из `list` очень просто:
```C++
void f(const Entry& ee, list<Entry>::iterator p,
									list<Entry>::iterator q)
{
	phone_book.insert(p,ee); 
	phone_book.erase(q); 
}
```

Для `list` вызов `insert(p, elem)` вставляет элемент с копией значения `elem` перед элементом, на который указывает `p`. Здесь `p` может быть итератором, указывающим на следующий за последним элементом `list`. И наоборот, ё удаляет элемент, на который указывает `p`, и уничтожает его.

Эти примеры `list` могут быть написаны идентично с использованием `vector` и (удивительно, если вы не разбираетесь в архитектуре машины) часто работают лучше с `vector`, чем с `list`. Когда все, что нам нужно, - это последовательность элементов, у нас есть выбор между использованием `vector` и `list`. Если у вас нет причин поступить иначе, используйте `vector`. `vector` лучше подходит для обхода (например, `find()` и `count()`), а также для сортировки и поиска (например, [[sort|sort()]] и [[equal|equal_range()]]).

# forward_list

Стандартная библиотека также предлагает односвязный список под названием `forward_list`:
![[List_2.png]]

Список `forward_list` отличается от (двусвязного) `list` тем, что разрешает только прямую итерацию. Смысл этого в том, чтобы сэкономить место. Нет необходимости сохранять указатель- на элемент предшественник в каждой ссылке, а размер пустого списка `forward_list` равен всего одному указателю. `forward_list` даже не сохраняет количество своих
элеменов. Если вам нужно количество элементов, подсчитайте. Если вы не можете позволить себе считать, вам, вероятно, не следует использовать `forward_list.`





