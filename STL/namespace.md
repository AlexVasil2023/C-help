
# namespace (Пространства имён)

В дополнение к функциям, классам и [[enum|перечислениям]] C++ предлагает пространства имен в качестве механизма для выражения того, что некоторые объявления связаны друг с другом и что их имена не должны конфликтовать с другими именами. Например, я мог бы захотеть поэкспериментировать со своим собственным [[Числовые вычисления#Комплексные числа|типом комплексного числа]]:
```c++
namespace My_code {
	class complex {
		// ...
	};
	
	complex sqrt(complex);

	// ...
	
	int main();
}

int My_code::main()
{
	complex z {1,2};
	auto z2 = sqrt(z);
	std::cout << '{' << z2.real() << ',' << z2.imag() << "}\n";
	
	// ...
}

int main()
{
	return My_code::main();
}
```

Помещая свой код в пространство имен `My_code`, я гарантирую, что мои имена не конфликтуют с именами стандартных библиотек в [[namespace#namespace (Пространства имён)|пространстве имен]] `std`. Эта мера предосторожности разумна, поскольку стандартная библиотека действительно обеспечивает поддержку [[Числовые вычисления#Комплексные числа|арифметики `complex` комплексных чисел]].

Самый простой способ получить доступ к имени в другом пространстве имен - указать его с помощью имени пространства имён (например, [[cout|std::cout]] и `My_code::main`). “Настоящий main()” определен в глобальном пространстве имен, то есть не является локальным для определенного пространства имен, класса или функции.

Если повторное указание имени становится утомительным или отвлекающим, мы можем поместить имя в область видимости с помощью объявления `using`:
```c++
void my_code(vector<int>& x, vector<int>& y)
{
	using std::swap;     // make the standard-library swap available locally

	// ...
	
	swap(x,y);          // std::swap()
	other::swap(x,y);   // some other swap()

	// ...
}
```

Объявление `using` делает имя из пространства имен пригодным для использования, как если бы оно было объявлено в области, в которой к нему обращаются. После `using std::swap`, можно обращаться к `swap` так как если бы он был объявлен в `my_code()`.

Чтобы получить доступ ко всем именам в пространстве имен стандартной библиотеки, мы можем использовать `using namespace`:
```c++
using namespace std;
```

Директива `using` делает имена из именованного пространства имен доступными из области, в которую мы поместили эту директиву. Поэтому, после директивы `using` для `std` мы можем просто написать `cout` вместо `std::cout`. Например, мы могли бы избежать повторяющихся префиксов `std::` в нашем тривиальном модуле `vector_printer`:
```c++
export module vector_printer;
import std;
using namespace std;

export
template<typename T>
void print(vector<T>& v)         // this is the (only) function seen by users
{
	cout << "{\n";
	
	for (const T& val : v)
		cout << " " << val << '\n';
	
	cout << '}';
}
```

Важно отметить, что использование директивы `namespace` не влияет на пользователей наших модулей; это деталь реализации, локальная для модуля. Используя директиву `using`, мы теряем возможность выборочно использовать имена из этого пространства имен, поэтому это средство следует использовать осторожно, обычно для библиотеки, которая широко распространена в приложении (например, `std`), или во время перехода для приложения, которое не использовало пространства имен.

Пространства имен в основном используются для организации более крупных программных компонентов, таких как библиотеки. Они упрощают составление программы из отдельно разработанных частей.
