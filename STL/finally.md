
# finally

Деструкторы предлагают общий и неявный механизм [[Основные операции#Управление ресурсами|очистки после использования объекта]] (RAII), но что, если нам нужно выполнить некоторую очистку, которая не связана с отдельным объектом, или связана с объектом, у которого нет деструктора (например, потому что это тип, совместно используемый с программой на языке Си)? Мы можем определить функцию `finally()` которая выполняет действие, подлежащее выполнению при выходе из области видимости
```c++
void old_style(int n)
{
	void* p = malloc(n*sizeof(int)); // C-style
	auto act = finally([&]{free(p);}); // call the lambda upon scope exit

	...
} // p is implicitly freed upon scope exit
```

Это узкоспециализированно, но намного лучше, чем пытаться правильно и последовательно вызывать `free(p)` при любом выходе из функции.

Функция `finally()` тривиальна:
```c++
template <class F>
[[nodiscard]] auto finally(F f)
{
	return Final_action{f};
}
```

Я использовал атрибут `[[nodiscard]]`, чтобы гарантировать, что пользователи не забудут скопировать сгенерированное `Final_action` в область, для которой предназначено его действие.

Класс `Final_action`, который предоставляет необходимый деструктор, может выглядеть следующим образом:
```c++
template <class F>
struct Final_action {
	explicit Final_action(F f) 
		:act(f) 
	{}
	
	~Final_action() 
	{ 
		act(); 
	}
	
	F act;
};
```

В библиотеке поддержки Core Guidelines (GSL) есть функция `finally()` и предложение по более сложному механизму #scope_exit для стандартной библиотеки.
