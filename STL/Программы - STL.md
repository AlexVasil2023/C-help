
1. [[#Программы]] 1.2
	1. [[#Hello, World!|Hello, World!]] 1.2.1
2. [[#Функции|Функции]] 1.3
3. [[#Типы, Переменные и Арифметика|Типы, Переменные и Арифметика]] 1.4
	1. [[#Арифметика|Арифметика]] 1.4.1
	2. [[#Инициализация|Инициализация]] 1.4.2
	3. [[auto|auto]] 1.4.3
	4. [[auto#Вывод типа auto|Вывод типа auto]] 1.4.4
4. [[#Область видимости и время жизни|Область видимости и время жизни]] 1.5
5. [[#Константы|Константы]] 1.6
6. [[#Указатели, Массивы и Ссылки|Указатели, Массивы и Ссылки]] 1.7
	1. [[nullptr_t#nullptr|nullptr (Нулевой указатель)]] 1.7.1
7. [[#Условные операторы|Условные операторы]] 1.8
8. [[#Сопоставление с аппаратным обеспечением|Сопоставление с аппаратным обеспечением]] 1.9
	1. [[#Присваивание|Присваивание]] 1.9.1
	2. [[#Инициализация|Инициализация]] 1.9.2

# Программы

C++ - это компилируемый язык. Для запуска программы ее исходный текст должен быть обработан компилятором, создающим объектные файлы, которые объединяются компоновщиком, получая исполняемую программу. Программа на C++ обычно состоит из множества файлов исходного кода (обычно называемых просто исходными файлами).

![[STL_Prog_1.png]]

Исполняемая программа создается для определенной комбинации аппаратной платформы и операционной системы; она не переносима, скажем, с устройства Android на персональный компьютер с Windows. Когда мы говорим о переносимости программ на C++, мы обычно имеем в виду переносимость исходного кода; то есть исходный код может быть успешно скомпилирован и запущен в различных системах.

Стандарт ISO C++ определяет два типа сущностей:
>
> Фундаментальные возможности языка, такие как встроенные типы (например, `char` и `int`) и циклы (например, операторы [[for|for]] и [[while|while]])
> 
> Компоненты стандартной библиотеки STL, такие как контейнеры (например, [[vector|vector]] и [[map|map]]) и операции ввода-вывода (например, `<<` и `getline()`)

Компоненты стандартной библиотеки - это совершенно обычный код на C++, предоставляемый каждой реализацией языка C++. То есть стандартная библиотека C++ может быть реализована в самом C++ и является таковой (с очень незначительным использованием машинного кода для таких вещей, как переключение контекста [[thread|thread]]). Это означает, что C++ достаточно выразителен и эффективен для самых сложных задач системного программирования.

C++ - это статически типизированный язык. То есть тип каждой сущности (например, объекта, значения, имени и выражения) должен быть известен компилятору в момент его использования. Тип объекта определяет набор операций, применимых к нему, и его расположение в памяти.

## Hello, World!

Минимальная программа на C++ выглядит следующим образом:
```c++
int main() { }                    // the minimal C++ program
```

Здесь определена функция с именем `main`, которая не принимает аргументов и ничего не делает.

Фигурные скобки, `{ }`, группируют выражения в C++. Здесь они указывают начало и конец тела функции. Двойная косая черта, `//`, начинает комментарий, который продолжается до конца строки. Комментарий предназначен для обычного чтения человеком, а компилятор полностью игнорирует комментарии.

Каждая программа на C++ должна иметь ровно одну глобальную функцию с именем `main()`. Программа начинается с выполнения этой функции. Целочисленное значение `int`, возвращаемое `main()`, если таковое имеется, является значением, возвращаемым программой “системе”. Если значение не будет возвращено, система получит значение, указывающее на успешное завершение. Ненулевое значение возвращаемое `main()` указывает на сбой. Не каждая операционная система и среда выполнения используют это возвращаемое значение: среды на базе `Linux/Unix` используют, но среды на базе `Windows` делают это редко.

Как правило, программа выдает некоторый вывод. Вот программа, которая выводит в консоль `Hello, World!`:
```c++
import std;
int main()
{
	std::cout << "Hello, World!\n";
}
```

Строка `import std;` инструктирует компилятор что необходимо сделать доступными объявления стандартной библиотеки. Без этих объявлений выражение
```c++
std::cout << "Hello, World!\n"
```

не имело бы никакого смысла. Оператор `<<` (“put to”) записывает свой второй аргумент в свой первый. В данном случае строковый литерал `"Hello, World!\n"` записывается в стандартный поток вывода [[cout|std::cout]]. Строковый литерал - это последовательность символов, заключенная в двойные кавычки. В строковом литерале символ обратной косой черты `\`, за которым следует другой символ, обозначает один “специальный символ”. В этом случае `\n` - это символ перевода курсора на новую строку, так что написанные символы - это `Hello, World!` за ним следует переход на новую строку.

`std::` указывает, что имя `cout` находится [[namespace#namespace (Пространства имён)|в пространстве имен стандартной библиотеки]]. Я обычно опускаю `std::` при обсуждении стандартных функций.

Директива `import` является новой в C++20, и представление всей стандартной библиотеки в виде [[Module#Модули|модуля]] `std` еще не является стандартным. Если у вас возникли проблемы с `import std;`, попробуйте обычный старомодный
```c++
#include <iostream>     // include the declarations for the I/O
						// stream library
int main()
{
	std::cout << "Hello, World!\n";
}
```

По сути, весь исполняемый код помещается в функции и вызывается прямо или косвенно из `main()`. Например:
```c++
import std;           // import the declarations for the standart library
using namespace std;  // make names from std visible without std::

double square(double x) { //square a double-precision floating-point number
	return x*x;
}

void print_square(double x) {
	cout << "the square of " << x << " is " << square(x) << "\n";
}

int main() {
	print_square(1.234);  // print: the square of 1.234 is 1.52276
}
```

# Функции

Основной способ заставить что-то сделать программу на C++ - это вызвать соответствующую функцию. Определение функции - это способ указать, как должны выполняться необходимые действия. Функция не может быть вызвана, если она не была объявлена ранее.

Объявление функции указывает имя функции, тип возвращаемого значения (если таковое имеется), а также количество и типы аргументов, которые должны быть переданы при вызове. Например:
```c++
Elem* next_elem();    // no argument; return a pointer to Elem (an Elem*)
void exit(int);       // int argument; return nothing
double sqrt(double);  // double argument; return a double
```

В объявлении функции возвращаемый тип указывается перед именем функции, а типы аргументов - после имени, заключенными в круглые скобки.

Семантика [[Модульность#Передача аргументов|передачи аргументов]] идентична семантике инициализации. То есть проверяются типы аргументов, и при необходимости выполняется неявное [[#Типы, Переменные и Арифметика|преобразование типов аргументов]]. Например:
```c++
double s2 = sqrt(2);       // call sqrt() with the argument double{2}
double s3 = sqrt("three"); // error: sqrt() requires an argument of type double
```

Ценность такой проверки во время компиляции и преобразования типов не следует недооценивать.

Объявление функции может содержать имена аргументов. Это может помочь читателю программы, но, если объявление не является также определением функции, компилятор просто игнорирует такие имена. Например:
```c++
double sqrt(double d);      // return the square root of d
double square(double);      // return the square of the argument
```

Тип функции состоит из типа возвращаемого значения, за которым следует последовательность типов ее аргументов в круглых скобках. Например:
```c++
double get(const vector<double>& vec, int index);   // type: double(const
													// vector<double>&,int)
```

Функция может быть [[Пользовательские типы#Классы|членом класса]]. Для такой функции-члена имя ее класса также является частью типа функции. Например:
```c++
char& String::operator[](int index); // type: char& String::(int)
```

Мы хотим, чтобы наш код был понятным, потому что это первый шаг на пути к удобству его обслуживания. Первым шагом к пониманию является разбиение вычислительных задач на значимые фрагменты (представленные в виде функций и классов) и присвоение им имен. Затем такие функции составляют базовый словарь вычислений, точно так же, как типы (встроенные и определяемые пользователем) составляют базовый словарь данных. Стандартные алгоритмы C++ (например, [[find|find]], [[sort|sort]] и [[iota|iota]]) обеспечивают хорошее начало. Далее мы можем объединять функции, представляющие общие или специализированные задачи, в более крупные вычисления.

Количество ошибок в коде сильно коррелирует с объемом кода и его сложностью. Обе проблемы можно решить, используя большее количество функций и делая функции короче. Использование функции для выполнения определенной задачи часто избавляет нас от написания определенного фрагмента кода посреди другого кода; превращение его в функцию заставляет нас называть действие и документировать его зависимости. Если мы не можем найти подходящее название, высока вероятность того, что у нас проблема с дизайном.

Если определены две функции с одинаковым именем, но с разными типами аргументов, компилятор выберет наиболее подходящую функцию для каждого вызова. Например:
```c++
void print(int);          // takes an integer argument
void print(double);       // takes a floating-point argument
void print(string);       // takes a string argument

void user() {
	print(42);            // calls print(int)
	print(9.65);          // calls print(double)
	print("Barcelona");   // calls print(string)
}
```

Если могут быть вызваны две альтернативные функции, но ни одна из них не подходит лучше другой, вызов считается неоднозначным и компилятор выдает ошибку. Например:
```c++
void print(int, double);
void print(double, int);

void user2() {
	print(0,0);           // error: ambiguous
}
```

Определение нескольких функций с одинаковым именем называется перегрузкой функций и является одной из важнейших частей обобщённого программирования. При перегрузке функций, каждая функция с одинаковым именем должна реализовывать одинаковую семантику. Функции `print()` являются примером этого; каждая функция `print()` выводит свой аргумент.

# Типы, Переменные и Арифметика

Каждое имя и каждое выражение имеют тип, который определяет, какие операции могут быть выполнены над ними. Например, объявление
```c++
int inch;
```

указывает, что `inch` имеет тип `int`; то есть `inch` является целочисленной переменной. Объявление - это инструкция, которая вводит объект в программу и определяет его тип:
>
> Тип определяет набор возможных значений и набор операций (для объекта).
> 
> Объект - это некоторая память, которая содержит значение некоторого типа.
> 
> Значение - это набор битов, интерпретируемых в соответствии с типом.
> 
> Переменная - это именованный объект.

C++ предлагает небольшой зоопарк фундаментальных типов. Примеры фундаментальных типов:
```c++
bool                // Boolean, possible values are true and false
char                // character, for example, 'a', 'z', and 9
int                 // integer, for example, -273, 42, and 1066
double              // double-precision floating-point number, for example,
					// -273.15, 3.14, and 6.626e-34
unsigned            // non-negative integer, for example, 0, 1, and 999
					// (используется для побитовых логических операций)
```

Каждый базовый тип непосредственно соответствует аппаратным средствам и имеет фиксированный размер, который определяет диапазон значений, которые могут в нем храниться:
![[STL_2.png]]

Переменная типа `char` имеет естественный размер для хранения символа на данной машине (обычно 8-разрядный байт), а размеры других типов кратны размеру символа `char`. Размер типа определяется реализацией (т.е. он может варьироваться на разных машинах и операционных системах) и может быть получен с помощью оператора [[sizeof|sizeof]]; например, `sizeof(char)` равен 1, а `sizeof(int)` часто равен 4. Когда нам нужен тип определенного размера, мы используем [[Числовые вычисления#Псевдонимы типов|псевдоним типа стандартной библиотеки]], такой как `int32_t`.

Числа могут быть как целыми, так и с плавающей запятой.
>
> Литералы чисел с плавающей запятой распознаются по десятичной точке (например, 3.14) или по показателю степени (например, 314e-2).
> 
> Целочисленные литералы по умолчанию являются десятичными (например, 42 означает сорок два). Префикс `0b` указывает на двоичный (по основанию 2) целочисленный литерал (например, `0b10101010`). Префикс `0x` указывает на шестнадцатеричный (по основанию 16) целочисленный литерал (например, `0xBAD12CE3`). Префикс `0` указывает на восьмеричный (по основанию 8) целочисленный литерал (например, `0334`).

Чтобы сделать длинные литералы более удобочитаемыми для людей, мы можем использовать одинарную кавычку в качестве разделителя цифр. Например, π - это примерно 3.14159’26535’89793’23846’26433’83279’50288 или, если вы предпочитаете шестнадцатеричную систему счисления 0x3.243F’6A88’85A3’08D3.

## Арифметика

Арифметические операторы могут быть использованы для соответствующих комбинаций фундаментальных типов:
```c++
x + y      // plus
+x         // unary plus
x - y      // minus
-x         // unary minus
x * y      // multiply
x / y      // divide
x % y      // remainder (modulus) for integers
```

То же самое могут сделать операторы сравнения:
```c++
x == y     // equal
x != y     // not equal
x < y      // less than
x > y      // greater than
x <= y     // less than or equal
x >= y     // greater than or equal
```

Кроме того, имеются логические операторы:
```c++
x & y      // bitwise and
x | y      // bitwise or
x ^ y      // bitwise exclusive or
~x         // bitwise complement
x && y     // logical and
x || y     // logical or
!x         // logical not (negation)
```

Побитовый логический оператор выдает результат того же типа что и операнды, для которых операция была выполнена над каждым битом. Логические операторы `&&` и `||` просто возвращают `true` или `false` в зависимости от значений их операндов.

В присваиваниях и арифметических операциях C++ выполняет все необходимые преобразования между базовыми типами, чтобы их можно было свободно смешивать:
```c++
void some_function()    // function that doesn't return a value
{
	double d = 2.2;     // initialize floating-point number
	int i = 7;          // initialize integer
	
	d = d + i;          // assign sum to d
	i = d * i;          // assign product to i;
						// beware: truncating the double d*i to an int
}
```

Преобразования, используемые в выражениях, называются обычными арифметическими преобразованиями и направлены на то, чтобы гарантировать, что выражения вычисляются с максимальной точностью их операндов. Например, сложение `double` и `int` вычисляется с использованием арифметики с плавающей запятой двойной точности.

Обратите внимание, что `=` - это оператор присваивания, а `==` проверяет на равенство. В дополнение к обычным арифметическим и логическим операторам, C++ предлагает более специфические операции для изменения переменной:
```c++
x += y                  // x = x+y
++x                     // increment: x = x+1
x -= y                  // x = x-y
--x                     // decrement: x = x-1
x *= y                  // scaling: x = x*y
x /= y                  // scaling: x = x/y
x %= y                  // x = x%y
```

Эти операторы лаконичны, удобны и очень часто используются.

Порядок вычисления слева направо для `x.y`, `x->y`, `x(y)`, `x[y]`, `x << y`, `x >> y`, `x && y` и `x || y`. Для присваиваний (например, `x += y`) порядок - справа налево. По историческим причинам, связанным с оптимизацией, порядок вычисления других выражений (например, `f(x) + g(y)`) и аргументов функции (например, `h(f(x)`, `g(y)`)), к сожалению, не определен.

# Инициализация

[[Инициализация#Инициализация|см. Инициализация]]

## auto

[[auto| см. auto]]

## Вывод типа auto

[[auto#Вывод типа auto|см. Вывод типа auto]]

# Область видимости и время жизни

Объявление вводит объявляемое имя в область видимости:
>
> **Локальная область видимости**: имя, объявленное в [[#Функции|функции]] или [[Template_STL#Функциональные объекты|лямбда-выражении]], называется локальным именем. Его область действия простирается от точки объявления до конца блока, в котором находится его объявление. Блок ограничен парой `{ }`. Имена аргументов функций считаются локальными именами.
> 
> **Область видимости класса**: имя называется именем члена (или именем члена класса), если оно [[Классы|определено в классе]], вне какой-либо [[#Функции|функции]], [[Template_STL#Функциональные объекты|лямбда-выражения]] или перечисления [[enum|enum class]]. Его область видимости простирается от открывающей `{` его объявления до ближайшей `}`.
> 
> **Область пространства имен**: Имя называется именем члена пространства имен, если оно определено в [[namespace#namespace (Пространства имён)|пространстве имен]] вне какой-либо функции, [[Template_STL#Функциональные объекты|лямбды]], [[Классы|класса]] или [[enum|enum class]]. Его область действия простирается от точки объявления до конца его пространства имен.

Имя, не объявленное внутри какой-либо другой конструкции, называется глобальным именем и находится в глобальном пространстве имен.

Кроме того, у нас могут быть объекты без имен, такие как временные объекты и объекты, созданные с помощью [[new|new]]. Например:
```c++
vector<int> vec;    // vec is global (a global vector of integers)

void fct(int arg)   // fct is global (names a global function)
					// arg is local (names an integer argument)
{
	string motto {"Who dares wins"};  // motto is local
	auto p = new Record{"Hume"};      // p points to an unnamed Record 
									  // (created by new)
	...
}

struct Record {
	string name;         // name is a member of Record (a string member)
	
	...
};
```

Объект должен быть создан (инициализирован) до того, как он будет использован, и будет уничтожен при выходе из его области видимости. Для объекта пространства имен точкой уничтожения является завершение программы. Для члена точка разрушения определяется точкой разрушения объекта, членом которого он является. Объект, созданный с помощью [[new|new]], “живет” до тех пор, пока не будет уничтожен с помощью [[delete|delete]] .

# Константы

[[const#const|см. const (Константы)]]

# Указатели, Массивы и Ссылки

Наиболее фундаментальный контейнер данных - это непрерывно расположенная последовательность элементов одного и того же типа, называемая массивом. Это в основном то, что предлагает аппаратное обеспечение. Массив элементов типа `char` может быть объявлен следующим образом:
```c++
char v[6];                        // array of 6 characters
```

Аналогично, указатель может быть объявлен следующим образом:
```c++
char* p;                          // pointer to character
```

В объявлениях `[ ]` означает “массив из”, а `*` - “указатель на”. Все массивы имеют 0 в качестве нижней границы, поэтому `v` содержит шесть элементов, от `v[0]` до `v[5]`. Размер массива должен быть [[const#const|константным выражением]]. Переменная-указатель может содержать адрес объекта соответствующего типа:
```c++
char* p = &v[3];                  // p points to v's fourth element
char x = *p;                      // *p is the object that p points to
```

В выражении префикс унарная `*` означает “содержимое”, а префикс унарный `&` означает “адрес”. Мы можем представить это графически следующим образом:
![[STL_3.png]]

Рассмотрим возможность вывода элементов массива:
```c++
void print()
{
	int v1[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	for (auto i=0; i != 10; ++i) // print elements
		cout << v[i] << '\n';
	...
}
```

Это выражение [[for|for]] можно прочитать как “установите `i` равным нулю; пока `i` не равно `10`, выведите `i-й` элемент и увеличьте `i`”. C++ также предлагает более простой оператор [[for|for]], называемый [[for|for]] для диапазона, для циклов, которые просто перебирают все элементы последовательности:
```c++
void print2()
{
	int v[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	
	for (auto x : v)                         // for each x in v
		cout << x << '\n';
		
	for (auto x : {10, 21, 32, 43, 54, 65})  // for each integer in the list
		cout << x << '\n';

	...
}
```

Первый оператор [[for|for]] для диапазона можно прочитать как “для каждого элемента `v`, от первого до последнего, поместите копию в `x` и выведите ее”. Обратите внимание, что нам не нужно указывать границы массива, когда мы инициализируем его списком. Оператор [[for|for]] для диапазона может использоваться для любой [[Алгоритмы - STL#Введение|последовательности элементов]].

Если бы мы не хотели копировать значения из `v` в переменную `x`, а просто чтобы `x` ссылался на элемент, мы могли бы написать:
```c++
void increment()
{
	int v[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	
	for (auto& x : v) // add 1 to each x in v
		++x;
	
	...
}
```

В объявлении унарный суффикс `&` означает “ссылка на”. Ссылка похожа на указатель, за исключением того, что вам не нужно использовать префикс `*` для доступа к значению, на которое указывает ссылка. Кроме того, ссылка после её инициализации не может быть изменена для указания на другой объект. Ссылки особенно полезны для указания аргументов функции. Например:
```c++
void sort(vector<double>& v); // sort v (v is a vector of doubles)
```

Используя ссылку, мы гарантируем, что для вызова `sort(my_vec)` мы не копируем `my_vec`. Следовательно, на самом деле сортируется `my_vec`, а не его копия. 

Когда мы не хотим изменять аргумент, но хотим избежать затрат на копирование, мы используем [[const|const]] ссылку; то есть ссылку на [[const|const]]. Например:
```c++
double sum(const vector<double>&)
```

Функции, принимающие константные ссылки, очень распространены.

При использовании в объявлениях операторы (такие как `&`, `*` и `[ ]`) называются операторами деклараторов:
```c++
T a[n]  // T[n]: a is an array of n Ts
T* p    // T*: p is a pointer to T
T& r    // T&: r is a reference to T
T f(A)  // T(A): f is a function taking an argument of type A 
		// returning a result of type T
```

## Нулевой указатель

 [[nullptr_t#nullptr|см. nullptr (Нулевой указатель)]] 

# Условные операторы

C++ предоставляет обычный набор операторов для ветвлений и циклов, таких как [[if|if]], [[switch|switch]], [[while|while]] и [[for|for]]. Например, вот простая функция, которая запрашивает пользовательский ввод и возвращает логическое значение, соответствующее вводу:
```c++
bool accept()
{
	cout << "Do you want to proceed (y or n)?\n"; // write question
	char answer = 0;                        // initialize to a value
											// that will not appear on input
	cin >> answer;                          //read answer

	if (answer == 'y' )
		return true;
	
	return false;
}
```

Аналогично оператору вывода `<<` (“put to”), для ввода используется оператор `>>` (“get from ”); [[cin|cin]] - стандартный входной поток. Тип правого операнда `>>` определяет, какой ввод принимается, а его правый операнд является целью операции ввода. Символ `\n` в конце выходной строки обозначает собой [[Программы - STL#Hello, World!|переход на новую строку]].

Обратите внимание, что определение `answer` появляется там, где это необходимо (а не до этого). Объявление может появиться в любом месте, где может появиться оператор. 

Пример можно было бы улучшить, приняв во внимание `n` (для ответа “нет”):
```c++
bool accept2()
{
	cout << "Do you want to proceed (y or n)?\n"; // write question
	
	char answer = 0;                        // initialize to a value
											// that will not appear on input
	cin >> answer; // read answer

	switch (answer) {
		case 'y': return true;
		case 'n': return false;
		default:  cout << "I'll take that for a no.\n"; 
				  return false;
	}
}
```

Оператор [[switch|switch]] сравниваем значение на соответствие набору констант. Эти константы, называемые case-метками, должны быть разными, и, если проверяемое значение не соответствует ни одной из них, выбирается метка `default`. Если значение не соответствует ни одной `case-метке` и `default-метка` не указана, никакие действия не предпринимаются.

Нам не нужно выходить из `case` при помощи `return` как из функции, которая содержит его оператор [[switch|switch]]. Часто мы просто хотим продолжить выполнение с инструкции, следующей за оператором [[switch|switch]]. Мы можем сделать это, используя оператор **`break`**. В качестве примера рассмотрим чрезмерно умный, но примитивный синтаксически анализатор для простейших команд видеоигры:
```c++
void action()
{
	while (true) {
		cout << "enter action:\n"; // request action
		string act;
		cin >> act; // read characters into a string
		
		Point delta {0,0}; // Point holds an {x,y} pair
		
		for (char ch : act) {
			switch (ch) {
				case 'u': // up
				case 'n': // north
					++delta.y;
				break;
				
				case 'r': // right
				case 'e': // east
					++delta.x;
				break;
				
				// ... more actions ...
				default:
					cout << "I freeze!\n";
			}

			move(current + delta * scale);
			update_display();
		}
	}
}
```

Подобно оператору [[for|for]], оператор [[if|if]] может вводить переменную и проверять ее. Например:
```c++
void do_something(vector<int>& v)
{
	if (auto n = v.size(); n!=0) {
		// ... we get here if n!=0 ...
	}

	...
}
```

Здесь целое число `n` определено для использования в операторе [[if|if]], инициализируется с помощью `v.size()` и немедленно проверяется условием `n!=0` после точки с запятой. Имя, объявленное в условии, находится в области видимости в обеих ветвях оператора [[if|if]].

Как и в случае с оператором [[for|for]], целью объявления имени в условии оператора [[if|if]] является ограничение области видимости переменной для улучшения удобочитаемости и минимизации ошибок.

Наиболее распространенным случаем является проверка переменной на равенство 0 (или [[nullptr_t|nullptr]]). Чтобы сделать это, просто опустите явное упоминание об этом условии. Например:
```c++
void do_something(vector<int>& v)
{
	if (auto n = v.size()) {
		// ... we get here if n!=0 ...
	}
	
	...
}
```

Предпочитительно использование этой краткой и простой формы, когда можете.

# Сопоставление с аппаратным обеспечением

C++ предлагает прямое сопоставление с аппаратным обеспечением. Когда вы используете одну из основных операций, реализация - это то, что предлагает аппаратное обеспечение, обычно это одна машинная операция. Например, при сложении двух `int`, `x+y` выполняет машинную инструкцию сложения целых чисел.

Реализация C++ рассматривает память машины как последовательность ячеек памяти, в которые она может размещать (типизированные) объекты и обращаться к ним с помощью указателей:

![[STL_4.png]]

Указатель представлен в памяти в виде машинного адреса, поэтому числовое значение `p` на этом рисунке будет равно `103`. Если это очень похоже на [[Программы - STL#Указатели, Массивы и Ссылки|массив]], то это потому, что массив - это базовая абстракция C++, представляющая собой “непрерывную последовательность объектов в памяти”.

Простое сопоставление фундаментальных языковых конструкций с аппаратным обеспечением имеет решающее значение для высокой производительности, которой C и C++ славятся десятилетиями. Базовая машинная модель C и C++ основана на компьютерном оборудовании, а не на какой-либо математической абстракции.

## Присваивание

Присваивание встроенного типа - это простая операция машинного копирования. Рассмотрим:
```c++
int x = 2;
int y = 3;

x = y;              // x becomes 3; so we get x==y
```

Мы можем наглядно представить это графически следующим образом:

![[STL_5.png]]

Эти два объекта независимы. Мы можем изменить значение `y`, не влияя на значение `x`. Например, `x=99` не изменит значение `y`. В отличие от Java, C# и других языков, но подобно Cи, это верно для всех типов, а не только для `int`.

Если мы хотим, чтобы разные объекты ссылались на одно и то же (общее) значение, мы должны написать следующее:
```c++
int x = 2;
int y = 3;
int* p = &x;
int* q = &y;         // p!=q and *p!=*q

p = q;               // p becomes &y; now p==q, so (obviously)*p==*q
```

Можно представить это графически следующим образом:
![[STL_6.png]]

Я произвольно выбрал 88 и 92 в качестве адресов `int`. Опять же, мы можем видеть, что объект, которому присвоено значение, получает значение от назначенного объекта, в результате чего получаются два независимых объекта (здесь указатели) с одинаковым значением. То есть `p=q` дает `p==q`. После `p=q` оба указателя указывают на `y`.

Ссылка и указатель оба ссылаются/указывают на объект, и оба представлены в памяти в виде машинного адреса. Однако языковые правила их использования различаются. Присвоение ссылки не изменяет адрес объекта, на который указывает ссылка, а присваивает объекту, на который указывает ссылка:
```c++
int x = 2;
int y = 3;

int& r = x;        // r refers to x
int& r2 = y;       // r2 refers to y

r = r2;            // read through r2, write through r: x becomes 3
```

Мы можем представить это графически следующим образом:
![[STL_7.png]]

Чтобы получить доступ к значению, на которое указывает указатель, вы используете `*`; для ссылки это выполняется неявно.

После `x=y` `у` выполняется `x==y` для каждого встроенного типа и хорошо спроектированного [[Пользовательские типы|пользовательского типа]], для которых реализованы операторы `=` (присвоение) и `==` (сравнение на равенство).

## Инициализация

Инициализация отличается от присваивания. В общем случае, чтобы присваивание работало корректно, объект, которому присвоено значение, должен иметь значение. С другой стороны, задача инициализации состоит в том, чтобы превратить неинициализированный фрагмент памяти в корректный объект. Почти для всех типов результат чтения из неинициализированной переменной или записи в нее не определен. Рассмотрим примеры:
```c++
int x = 7;

int& r {x};   // bind r to x (r refers to x)
r = 7;        // assign to whatever r refers to

int& r2;      // error: uninitialized reference
r2 = 99;      // assign to whatever r2 refers to
```

К счастью, у нас не может быть неинициализированной ссылки; если бы мы могли, то при `r2=99` присвоили бы 99 некоторой неопределенной ячейке памяти; результат в конечном итоге привел бы к неверным результатам или сбою.

Вы можете использовать `=` для инициализации ссылки, но, пожалуйста, пусть это вас не смущает. Например:
```c++
int& r = x; // bind r to x (r refers to x)
```

Это все еще инициализация и привязывает `r` к `x`, а не какая-либо форма копирования значения.

Различие между инициализацией и присваиванием также имеет решающее значение для многих пользовательских типов, таких как [[string|string]] и [[vector|vector]], где целевой объект присваивания владеет ресурсом, который в [[Основные операции#Управление ресурсами|конечном итоге должен быть освобожден]].

Основная семантика передачи аргументов и возврата значения из функции - это [[Модульность#Аргументы функции и возвращаемые значения|семантика инициализации]]. Например, так мы получаем возможность [[Модульность#Передача аргументов|передачи аргументов по ссылке]].
