
[[#Представления|Представления]] 14.2 (STL)


# Представления

Представление - это способ выразить диапазон. Например:
```c++
void user(forward_range auto& r)
{
	// view (only) odd numbers from r
	filter_view v {r, [](int x) { return x%2; } }; 
	cout << "odd numbers: "
	
	for (int x : v)
		cout << x <<' ';
}
```

При чтении из `filter_view` мы считываем данные из его диапазона. Если считанное значение соответствует предикату, оно возвращается; в противном случае `filter_view` повторяет попытку со следующим элементом из диапазона.

Многие диапазоны бесконечны. Кроме того, нам часто нужно всего несколько значений. Следовательно, существуют представления для получения только нескольких значений из диапазона:
```c++
void user(forward_range auto& r)
{
	// view (only) odd numbers in r
	filter_view v{r, [](int x) { return x%2; } }; 
	take_view tv {v, 100 }; // view at most 100 element from v 
	
	cout << "odd numbers: "
	for (int x : tv)
		cout << x <<' ';
}
```

Мы можем избежать присвоения имени `take_view`, используя его напрямую:
```c++
for (int x : take_view{v, 3})
	cout << x <<' ';
```

Аналогично для [[filter_view|filter_view]]:
```c++
for (int x : take_view{ filter_view { r, [](int x) { return x % 2; } }, 3 })
cout << x <<' ';
```
Такое вложение представлений может быстро стать нечитаемым, поэтому есть альтернатива: [[Конвейеры - STL#Конвейеры|конвейеры]].

Стандартная библиотека предлагает множество представлений, также известных как адаптеры диапазона:

Представления стандартной библиотеки (адаптеры диапазона) `<ranges>` `v` это `view`; `r` это `range`; `p` это предикат; `n` это целое число

| `v = all_view{r}`            | `v` это все элементы из `r`                                                                                   |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `v = filter_view{r, p}`      | `v` это элементы из `r` которые соответствуют `p`                                                             |
| `v = transform_view{r, f}`   | `v` это результат вызова `f` для каждого элемента из `r`                                                      |
| `v = take_view{r, n}`        | `v` это не более `n` элементов из `r`                                                                         |
| `v = take_while_view{r, p}`  | `v` это элементы из `r` пока не выполнится `p`                                                                |
| `v = drop_view{r, n}`        | `v` это элементы из `r` начиная с `n+1` элемента                                                              |
| `v = drop_while_view{r, p}`  | `v` это элементы из `r` начиная с первого элемента, который не соответствует `p`                              |
| `v = join_view{r}`           | `v` развернутая версия `r`; элементы `r` должны быть диапазонами                                              |
| `v = split_view(r, d)`       | `v` это диапазон из поддиапазонов `r` определяемый разделителем `d`; `d` должен быть элементом или диапазоном |
| `v = common_view(r)`         | `v` это `r` записанный парой (begin:end)                                                                      |
| `v = reverse_view{r}`        | `v` это элементы из `r` в обратном порядке; `r` должен иметь двунаправленный доступ                           |
| `v = views::elements<n> (r)` | `v` это диапазон из `n`–ных элементов из [[tuple (Кортежи)\|tuple]], являющихся элементами `r`                          |
| `v = keys_view{r}`           | `v` это диапазон из первых элементов [[pair\|pair]], являющихся элементами `r`                                |
| `v = values_view{r}`         | `v` это диапазон из вторых элементов [[pair\|pair]], являющихся элементами `r`                                |
| `v = ref_view{r}`            | `v` это диапазон из ссылок на элементы `r`                                                                    |

Представление предлагает интерфейс, очень похожий на интерфейс диапазона, поэтому в большинстве случаев мы можем использовать представление везде, где мы можем использовать диапазон, и таким же образом. Ключевое отличие заключается в том, что представление не владеет своими элементами; оно не несет ответственности за удаление элементов из своего базового диапазона - это ответственность диапазона. С другой стороны, представление не должно выходить за рамки своего диапазона:
```c++
auto bad()
{
	vector v = {1, 2, 3, 4};
	return filter_view{v,odd}; // v will be destroyed before the view
}
```

Предполагается, что представления дешевы для копирования, поэтому мы передаем их по значению.

Я использовал простые стандартные типы, чтобы примеры были тривиальными, но, конечно, у нас могут быть представления наших собственных пользовательских типов. Например:
```c++
struct Reading {
	int location {};
	int temperature {};
	int humidity {};
	int air_pressure {};
	...
};

int average_temp(vector<Reading> readings)
{
	if (readings.size()==0) throw No_readings{};
		double s = 0;
		for (int x: views::elements<1>(readings)) // look 
		s += x;
		return s/readings.size();
}
```


