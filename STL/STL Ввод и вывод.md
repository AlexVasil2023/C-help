
[[#Ввод и вывод|Ввод и вывод]] 11
1. [[stream#Введение|Введение]] 11.1
2. [[stream#std ostream|ostream]] 11.2
3. [[stream#std istream|istream]] 11.3
4. [[iostream#iostream|Состояния потоков I/O]] 11.4
5. [[iostream#I/O пользовательских типов|I/O пользовательских типов]] 11.5
6. [[#Форматирование вывода|Форматирование вывода]] 11.6
	1. [[format#Форматирование потока|Форматирование потока]] 11.6.1
	2. [[format#Форматирование в стиле printf()|Форматирование в стиле printf()]] 11.6.2
7. [[#Потоки|Потоки]] 11.7
	1. [[#Стандартные потоки|Стандартные потоки]] 11.7.1
	2. [[#Файловые потоки|Файловые потоки]] 11.7.2
	3. [[std/sstream#Строковые потоки|Строковые потоки]] 11.7.3
	4. [[#Потоки памяти|Потоки памяти]] 11.7.4
8. [[#I/O в стиле Си|I/O в стиле Си]] 11.8
9. [[#Файловая система|Файловая система]] 11.9
	1. [[#Пути|Пути]] 11.9.1
	2. [[#Файлы и каталоги| Файлы и каталоги]] 11.9.2


# Ввод и вывод
# Введение

[[stream#Введение|Введение]] 11.1

# ostream

[[stream#std ostream|см. тут]]

# istream

[[stream#std istream|см. тут]]

# Состояния потоков I/O

[[iostream#iostream|см. тут]] 

# I/O пользовательских типов

 [[iostream#I/O пользовательских типов|I/см. тут]] 

# Форматирование вывода

Библиотеки [[iostream|iostream]] и [[format|format]] предоставляют операции для управления форматом ввода и вывода. Средства [[iostream|iostream]] примерно такие же старые, как C++, и ориентированы на форматирование потоков чисел. Средства [[format|format]] появились недавно (C++20) и ориентированы на форматирование комбинаций значений по спецификации в стиле `printf()`.

Форматирование выходных данных также обеспечивает поддержку unicode, но это выходит за рамки данной книги.

## Форматирование потока

[[format#Форматирование потока|см. тут]]

## Форматирование в стиле printf()

[[format#Форматирование в стиле printf()|см тут]]

# Потоки

Стандартная библиотека непосредственно поддерживает
>
> Стандартные потоки: потоки, подключенные к стандартным потокам ввода-вывода системы ( #§11_7_1)
> 
> Файловые потоки: потоки, прикрепленные к файлам ( #§11_7_2)
> 
> Строковые потоки: потоки, присоединенные к строкам ( #§11_7_3)
> 
> Потоки памяти: поток, привязанный к определенным областям памяти ( #§11_7_4)
> 
> Синхронизированные потоки: потоки, которые могут использоваться из нескольких потоков без скачков данных ( #§11_7_5)

Кроме того, мы можем определить наши собственные потоки, например, подключенные к каналам связи.

Потоки не могут быть скопированы; всегда передавайте их по ссылке.

Все потоки стандартной библиотеки являются шаблонами с типом символа в качестве параметра. Версии с названиями, которые я здесь использую, содержат `char`.

Например,[[stream#std ostream|ostream]] - это [[stream#basic_ostream|basic_ostream<char>]]. Для каждого такого потока стандартная библиотека также предоставляет версию для `wchar_t`. Например, `wostream` - это [[stream#basic_ostream|basic_ostream<wchar_t>]]. Потоки широких символов можно использовать для символов Юникода.

## Стандартные потоки

Стандартными потоками являются
>
> [[cout|cout]] для “обычного вывода”
> 
> [[cerr#std cerr|cerr]] для небуферизованного “вывода ошибки”
> 
> [[clog#std clog|clog]] буферизованного “вывода журнала”
> 
> [[cin#std cin|cin]] для стандартного ввода.

## Файловые потоки

В [[fstream|<fstream>]] стандартной библиотеки представлены потоки чтения и записи в файл:
>
> [[fstream#ifstream|ifstream]] для чтения из файла
> 
> [[fstream#ofstream|ofstream]] для записи в файл
> 
> [[fstream#fstream|fstream]] для чтения из файла и записи в него, например:

```c++
ofstream ofs {"target"};           // “o” for “output”
if (!ofs)
	error("couldn't open 'target' for writing");
```

Проверка правильности открытия файлового потока обычно выполняется путем проверки его состояния.
```c++
ifstream ifs {"source"}; // “i” for “input”

if (!ifs)
	error("couldn't open 'source' for reading");
```

Предполагая, что тесты прошли успешно, ofs можно использовать как обычный [[stream#std ostream|ostream]] (точно так же, как [[cout|cout]]), а [[ifs|ifs]] можно использовать как обычный [[stream#std istream|istream]] (точно так же, как [[cin|cin]]).

Навигация в файле и более детальное управление способом открытия файла возможны, но выходят за рамки данной книги.

О составлении имен файлов и манипуляциях с файловой системой смотрите в #§11_9.

## Строковые потоки

[[std/sstream#Строковые потоки|см. тут]]

## Потоки памяти

С самых ранних дней C++ существовали потоки, привязанные к разделам памяти, указанным пользователем, так что мы могли читать/записывать непосредственно в них. Самые старые из таких потоков, `strstream`, устарели на протяжении десятилетий, но их замена, [[spanstream#spanstream| spanstream]], [[spanstream#ispanstream|ispanstream]] и [[spanstream#ospanstream|ospanstream]], станет официальной не ранее C++23. Однако они уже широко доступны; попробуйте свою реализацию или выполните поиск на GitHub.

[[spanstream#ospanstream|ospanstream]] ведет себя как [[std/sstream#stringstream|ostringstream]] и инициализируется аналогично ему, за исключением того, что [[spanstream#ospanstream|ospanstream]] принимает в качестве аргумента [[span|span]], а не [[string|string]]. Например:
```c++
void user(int arg)
{
	array<char,128> buf;
	ospanstream ss(buf);
	ss << "write " << arg << " to memory\n";
	...
}
```

Попытки переполнения целевого буфера приводят к [[iostream#iostream|failure]] (сбою) состояния строки.
Аналогично,[[spanstream#ispanstream| ispanstream]] подобен [[std/sstream#istringstream|istringstream]].

## Синхронизированные потоки

[[syncstream]]

# I/O в стиле Си

Стандартная библиотека C++ также поддерживает ввод-вывод стандартной библиотеки C, включая [[print#printf|printf()]] и [[scan#scanf]] Многие варианты использования этой библиотеки ненадёжны с точки зрения типо- и кибер-безопасности, поэтому я не рекомендую ее использовать. В частности, её может быть сложно использовать для безопасного и удобного ввода. Она не поддерживает пользовательские типы. Если вы не используете ввод-вывод в стиле C, и заботитесь о производительности ввода-вывода, вызовите
```c++
ios_base::sync_with_stdio(false); // avoid significant overhead
```

Без этого вызова стандартные потоки [[iostream#iostream|iostream]] (например, [[cin|cin]] и [[cout|cout]]) могут быть значительно замедлены, чтобы быть совместимыми с вводом-выводом в стиле C. Если вам нравится форматированный вывод в стиле [[print#printf|printf()]], используйте [[format|format]] ; он безопасен для ввода, прост в использовании, гибок и быстр.

# Файловая система

Большинство систем имеют описание файловой системы, обеспечивающее доступ к постоянной информации, хранящейся в виде файлов. К сожалению, свойства файловых систем и способы манипулирования ими сильно различаются. Чтобы справиться с этим, библиотека файловой системы в [[filesystem|<filesystem>]] предлагает единый интерфейс для большинства средств большинства файловых систем. Используя [[filesystem|<filesystem>]], мы можем переносимо
>
> определять пути в файловой системе и перемещаться по ней
> 
>  узнавать типы файлов и связанные с ними разрешения

Библиотека файловой системы может обрабатывать `Unicode`, но объяснение того, как это делается, выходит за рамки данной книги. Я рекомендую cppreference  и документацию по `Boost filesystem` для получения более подробной информации.

## Пути

Рассмотрим пример:

```c++
path f = "dir/hypothetical.cpp"; // naming a file
assert(exists(f)); // f must exist

if (is_regular_file(f)) // is f an ordinary file?
	cout << f << " is a file; its size is " << file_size(f) << '\n';
```

Обратите внимание, что программа, управляющая файловой системой, обычно выполняется на компьютере вместе с другими программами. Таким образом, содержимое файловой системы может изменяться между двумя командами. Например, несмотря на то, что мы сначала тщательно утверждали, что `f` существует, это может уже не соответствовать действительности, когда в следующей строке мы спрашиваем, является ли `f` обычным файлом.

Путь [[filesystem#Path|path]] - это довольно сложный класс, способный обрабатывать различные наборы символов и соглашения многих операционных систем. В частности, он может обрабатывать имена файлов из командной строки, представленные `main()`; например:
```C++
int main(int argc, char* argv[])
{
	if (argc < 2) {
		cerr << "arguments expected\n";
		
		return 1;
	}

	path p {argv[1]}; // create a path from the command line
	cout << p << " " << exists(p) << '\n'; // note: a path can be printed 
										// like a string
	...
}
```

Путь [[filesystem#Path|path]] не проверяется на достоверность до тех пор, пока он не будет использован. Даже в этом случае его действительность зависит от соглашений системы, в которой выполняется программа.

Естественно, можно использовать [[filesystem#Path|path]] для открытия файла:
```C++
void use(path p)
{
	ofstream f {p};
	
	if (!f) error("bad file name: ", p);
		f << "Hello, file!";
}
```

В дополнение к [[filesystem#Path|path]], [[filesystem|<filesystem>]] предлагает типы для обхода каталогов и запроса свойств найденных файлов:

| `path`                         | Путь к каталогу                             |
| ------------------------------ | ------------------------------------------- |
| `filesystem_error`             | Исключение файловой системы                 |
| `directory_entry`              | Запись в каталоге                           |
| `directory_iterator`           | Для итерации по каталогу                    |
| `recursive_directory_iterator` | Для итерации по каталогу и его подкаталогам |

Рассмотрим простой, но не совсем уж нереальный пример:
```c++
void print_directory(path p) // print the names of all files in p
{
	try
	{
		if (is_directory(p)) {
			cout << p << ":\n";
			
			for (const directory_entry& x : directory_iterator{p})
				cout << " " << x.path() << '\n';
		}
	}
	catch (const filesystem_error& ex) {
		cerr << ex.what() << '\n';
	}
}
```

Строка может быть неявно преобразована в [[filesystem#Path|path]], поэтому мы можем использовать `print_directory` следующим образом:
```c++
void use()
{
	print_directory("."); // current directory
	print_directory(".."); // parent directory
	print_directory("/"); // Unix root directory
	print_directory("c:"); // Windows volume C
	
	for (string s; cin>>s; )
		print_directory(s);
}
```

Если бы я хотел также перечислить подкаталоги, я бы сказал `recursive_directory_iterator{p}`. Если бы я хотел напечатать записи в лексикографическом порядке, я бы скопировал [[filesystem#Path|path]] в [[vector|vector]] и отсортировал их перед печатью.

Класс [[filesystem#Path|path]] предлагает множество распространенных и полезных операций:

Операции с путями (некоторые) `p` и `p2` это [[filesystem#Path|path]]

| `value_type`               | Тип символа, используемый собственной кодировкой файловой системы: char в POSIX, wchar_t в Windows |
| -------------------------- | -------------------------------------------------------------------------------------------------- |
| `string_type`              | [[string#basic_string\|std::basic_string<value_type>]]                                             |
| `const_iterator`           | [[const\|const]] двунаправленный итератор с `value_type` для [[filesystem#Path\|path]]             |
| `iterator`                 | Псевдоним для `const_iterator`                                                                     |
| `p=p2`                     | Присвоить p2 в p                                                                                   |
| p/=p2                      | p и p2 объединить с использованием разделителя (по умолчанию `/`)                                  |
| `p+=p2`                    | p и p2 объединить (без разделителя)                                                                |
| `s=p.native()`             | Ссылка на нативный формат p                                                                        |
| `s=p.string()`             | `p` в нативном формате в виде [[string\|string]]                                                   |
| `s=p.generic_string()`     | p в общем формате в виде [[string\|string]]                                                        |
| `p2=p.filename()`          | Часть пути p включающая только имя файла                                                           |
| `p2=p.stem()`              | Часть пути p включающая только каталоги                                                            |
| `p2=p.extension()`         | Часть пути p включающая расширение файла                                                           |
| `i=p.begin()`              | Начальный итератор последовательности элементов p                                                  |
| `i= p.end()`               | Конечный итератор последовательности элементов p                                                   |
| `p==p2, p!=p2`             | Проверка на равенство и неравество путей p и p2                                                    |
| `p<p2, p<=p2, p>p2, p>=p2` | Лексикографическое сравнение                                                                       |
| `is>>p, os<<p`             | Потоковый I/O в/из p                                                                               |
| `u8path(s)`                | Путь из источника s, в кодировке UTF-8                                                             |

Например:
```c++
void test(path p)
{
	if (is_directory(p)) {
		cout << p << ":\n";
		
		for (const directory_entry& x : directory_iterator(p)) {
			const path& f = x; // refer to the path part of a directory en-
			try
				if (f.extension() == ".exe")
					cout << f.stem() << " is a Windows executable\n";
				else 
				{
					string n = f.extension().string();
					
					if (n == ".cpp" || n == ".C" || n == ".cxx")
						cout << f.stem() << " is a C++ source file\n";
				}
		}
	}
}
```

Мы используем [[filesystem#Path|path]] в качестве строки (например, `f.extension`), и мы можем извлекать строки различных типов из [[filesystem#Path|path]] (например, `f.extension().string()`).

Соглашения об именовании, естественные языки и строковые кодировки отличаются высокой сложностью. Абстракции файловой системы стандартной библиотеки обеспечивают переносимость и значительное упрощение.

##  Файлы и каталоги






















