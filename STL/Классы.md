
1. [[#Классы]] 5.1
2. [[#Конкретные типы|Конкретные классы]] 5.2
	1. [[#Арифметические типы|Арифметические типы]]  5.2.1
	2. [[#Контейнеры|Контейнеры]] 5.2.2
	3. [[#Инициализация контейнеров|Инициализация контейнеров]] 5.2.3
3. [[#Абстрактные типы|Абстрактные типы]] 5.3
4. [[#Виртуальные функции|Виртуальные функции]] 5.4
[[#Иерархии классов|Иерархии классов]] 5.5

# Классы

Центральной языковой особенностью C++ является класс. Класс - это пользовательский тип, служащий для представления сущности в коде программы. Всякий раз, когда в нашем проекте программы появляется полезная идея, объект, набор данных и т.д., мы стараемся представить это как класс в программе, чтобы идея существовала в коде, а не только в наших головах, в проектном документе или в некоторых комментариях. Программу, построенную на основе хорошо подобранного набора классов, гораздо легче понять и сделать безошибочной, чем ту, которая строит все непосредственно в терминах встроенных типов. В частности, библиотеки зачастую предлагают именно наборы классов.

По сути, все языковые средства, помимо фундаментальных типов, операторов и ключевых слов, существуют для того, чтобы помочь определить лучшие классы или более удобно их использовать. Под “лучше” я подразумеваю более корректный, более простой в обслуживании, более эффективный, более элегантный, более простой в использовании, более легкий для чтения и более понятный для рассуждений. Большинство методов программирования основаны на разработке и реализации определенных типов классов. Потребности и вкусы программистов сильно различаются. Следовательно, поддержка классов является обширной. Здесь мы рассмотрим базовую поддержку для трех важных типов классов:

* [[#Конкретные типы|Конкретные классы]]
* [[#Абстрактные типы|Абстрактные классы]]
* [[#Иерархии классов|Классы в иерархиях классов]] 

Поразительное количество полезных классов оказывается одного из этих трех видов. Еще больше классов можно рассматривать как упрощенные варианты из этих трёх видов или реализованные с использованием комбинаций методов, используемых в этих основных вариантах.

# Конкретные типы

Основная идея конкретных классов заключается в том, что они ведут себя “точно так же, как встроенные типы”. Например, тип комплексное число и целое число бесконечной точности во многом похожи на встроенные в него `int`, за исключением, конечно, того, что они имеют свою собственную семантику и наборы операций. Аналогично, [[vector|vector]] и [[string|string]] во многом похожи на [[Array|встроенные массивы]], за исключением того, что они более гибкие и лучше управляются.

Определяющей характеристикой конкретного типа является то, что его представление является частью его определения. Во многих важных случаях, таких как [[vector|vector]], это представление является всего лишь одним или несколькими указателями на данные, хранящиеся в другом месте, но это представление присутствует в каждом объекте конкретного класса. Это позволяет реализации быть оптимально эффективной по быстродействию и памяти. В частности, это позволяет нам:
>
>Размещать объекты конкретных типов в стеке, в статически выделяемой памяти и в других объектах (§1.5).
>
> Ссылаться на объекты напрямую (а не только через указатели или ссылки).
> 
> Инициализировать объекты немедленно и полностью (например, с помощью конструкторов; §2.3).
> 
> Копировать и перемещать объекты ( #§6_2).

Представление может быть приватным и доступным только через методы(как это имеет место для [[vector|Vector]]), но оно присутствует. Следовательно, если представление изменяется каким-либо существенным образом, пользователь должен выполнить перекомпиляцию. Это цена того, что конкретные типы ведут себя точно так же, как встроенные типы. Для типов, которые меняются нечасто, и где локальные переменные обеспечивают столь необходимую ясность и эффективность, это приемлемо и часто идеально. Чтобы повысить гибкость, конкретный тип может сохранять основные части своего представления в динамической памяти и получать к ним доступ через часть, хранящуюся в самом объекте класса. Именно так реализованы [[vector|vector]] и [[string|string]]; их можно рассматривать как дескрипторы ресурсов с тщательно проработанными интерфейсами.

### Арифметические типы

“Классическим пользовательским арифметическим типом” является комплексное число [[complex|complex]]:
```c++
class complex {
		double re, im;                  // representation: two doubles
	public:
		complex(double r, double i) 
			:re{r}, im{i} {}            // construct complex from two scalars

		complex(double r) 
			:re{r}, im{0} {}            // construct complex from one scalar
			
		complex() 
			:re{0}, im{0} {}            // default complex: {0,0}

		complex(complex z) 
			:re{z.re}, im{z.im} {}      // copy constructor
			
		double real() const { return re; }
		void real(double d) { re=d; }
		double imag() const { return im; }
		void imag(double d) { im=d; }
		
		complex& operator+=(complex z)
		{
			re+=z.re;                   // add to re and im
			im+=z.im;
			
			return *this;               // return the result
		}
		
		complex& operator-=(complex z)
		{
			re-=z.re;
			im-=z.im;
			
			return *this;
		}
		
		complex& operator*=(complex);   // defined out-of-class somewhere
		complex& operator/=(complex);  // defined out-of-class somewhere
};
```

Это упрощенная версия [[complex|complex]] из стандартной библиотеки ( #§17_4). Само определение класса содержит только операции, требующие доступа к представлению. Представление простое и общепринятое. По практическим соображениям оно должно быть совместимо с тем, что предоставлял `Fortran` 60 лет назад, и нам нужен обычный набор операторов. В дополнение к требованиям к базоаой логике, [[complex|complex]] должен быть эффективным, иначе он будет непригодным к использованию. Это подразумевает, что простые операции должны быть встраиваемыми ([[inline|inline]]). То есть простые операции (такие как конструкторы, `+=` и `imag()`) должны быть реализованы без вызовов функций в сгенерированном машинном коде. Функции, определенные в классе, [[inline|inline]] по умолчанию. Можно явно запросить встраивание, указав перед объявлением функции ключевое слово [[inline|inline]]. [[complex|complex]] из библиотеки `Industrial Strength` (подобный complex стандартной библиотеки) тщательно реализован для выполнения соответствующего встраивания. Кроме того, в [[complex|complex]] стандартной библиотеки функции, показанные здесь, объявлены [[constexpr|constexpr]], чтобы мы могли выполнять сложную арифметику во время компиляции. 

Копирующий оператор присваивания и конструктор копирования определены неявно ( #§6_2).

Конструктор, который может быть вызван без аргумента, называется конструктором по умолчанию. Таким образом, [[complex|complex()]] является конструктором [[complex|complex]] по умолчанию. Определяя конструктор по умолчанию, вы исключаете возможность существования неинициализированных переменных этого типа.

Спецификаторы [[const|const]] для функций, возвращающих действительную и мнимую части, указывают на то, что эти функции не изменяют объект, для которого они вызываются. Функция-член [[const|const]] может быть вызвана как для объектов [[const|const]], так и для неконстантных объектов, но неконстантная функция-член может быть вызвана только для неконстантных объектов. Например:
```c++
complex z = {1,0};
const complex cz {1,3};

z = cz;               // OK: assigning to a non-const variable
cz = z;               // error: assignment to a const
double x = z.real();  // OK: complex::real() is const
```

Множество полезных операций не требуют прямого доступа к представлению [[complex|complex]], поэтому они могут быть определены отдельно от определения класса:
```c++
complex operator+(complex a, complex b) { return a+=b; }
complex operator-(complex a, complex b) { return a-=b; }
complex operator-(complex a) { return {-a.real(), -a.imag()}; } // unary minus
complex operator*(complex a, complex b) { return a*=b; }
complex operator/(complex a, complex b) { return a/=b; }
```

Здесь я использую тот факт, что аргумент, передаваемый по значению, копируется, так что я могу изменить аргумент, не затрагивая копию вызывающего объекта, и использовать результат в качестве возвращаемого значения.

Определения `==` и `!=` просты:
```c++
bool operator==(complex a, complex b) { return a.real()==b.real() && a.imag()==b.imag(); } // equal
bool operator!=(complex a, complex b) { return !(a==b); } // not equal
```

Класс [[complex|complex]] может быть использован следующим образом:
```c++
void f(complex z)
{
	complex a {2.3}; // construct {2.3,0.0} from 2.3
	complex b {1/a};
	complex c {a+z*complex{1,2.3}};
	
	if (c != b)
		c = -(b/a)+2*b;
}
```

Компилятор преобразует операторы, включающие [[complex|complex]] комплексные числа, в соответствующие вызовы функций. Например, `c!=b` означает `operator!=(c,b)`, и `1/a` означает `operator/(complex{1},a)`.

Определяемые пользователем операторы (“перегруженные операторы”) следует использовать осторожно и традиционно ( #§6_4). Синтаксис фиксирован языком, поэтому вы не можете определить унарный `/`. Кроме того, невозможно изменить значение оператора для встроенных типов, поэтому вы не можете переопределить `+` для вычитания целых чисел `int`.

### Контейнеры

Контейнер - это объект, содержащий коллекцию элементов. Мы называем класс `Vector` контейнером, потому что объекты типа `Vector` являются контейнерами. Как  [[Пользовательские типы#Классы|определено]], `Vector` не является необоснованным контейнером `double`: он прост для понимания, [[Обработка ошибок#Инварианты|устанавливает полезный инвариант]], обеспечивает [[Обработка ошибок#Исключения|доступ с проверкой диапазона]] и предоставляет `size()`, что позволяет нам перебирать его элементы. Однако у него есть фатальный недостаток: он выделяет элементы, используя [[new|new]], но никогда не освобождает их. Это не очень хорошая идея, потому что C++ не предлагает сборщик мусора, чтобы сделать неиспользуемую память доступной для новых объектов. В некоторых средах вы не можете использовать сборщик, и часто вы предпочитаете более точное управление уничтожением по логичным соображениям или соображениям производительности. Нам нужен механизм, гарантирующий освобождение памяти, выделенной конструктором; этот механизм называется деструктором:
```c++
class Vector {
	public:
		Vector(int s) 
			:elem{new double[s]}, sz{s} // constructor: acquire resources
		{
			for (int i=0; i!=s; ++i)    // initialize elements
				elem[i]=0;
		}
		
		~Vector() 
			{ delete[] elem; }          // destructor: release resources

		double& operator[](int i);
		int size() const;
	
	private:
		double* elem;                // elem points to an array of sz doubles
		int sz;
};
```
Именем деструктора является оператор дополнения, `~`, за которым следует имя класса; деструктор — это дополнение конструктора.

Конструктор `Vector` выделяет некоторую память в динамической памяти (также называемой кучей) с помощью оператора [[new|new]]. Деструктор выполняет очистку, освобождая эту память с помощью оператора [[delete|delete[]]]. Простой [[delete|delete]] удаляет отдельный объект; [[delete|delete[]]] удаляет массив.

Все это делается без вмешательства пользователей `Vector`. Пользователи просто создают и используют `Vector` так же, как они использовали бы переменные встроенных типов. Например:
```c++
Vector gv(10);  // global variable; gv is destroyed at the 
				// end of the program
Vector* gp = new Vector(100);   // Vector on free store; 
								// never implicitly destroyed
void fct(int n)
{
	Vector v(n);
	
	... use v ...
	
	{
		Vector v2(2*n);
		... use v and v2 ...
	} // v2 is destroyed here
	
	 ... use v ..
} // v is destroyed here
```

Vector подчиняется тем же [[Программы - STL#Область видимости и время жизни|правилам именования, области видимости, выделения памяти, времени жизни и т.д]], как и встроенный тип, такой как `int` и `char`. Этот `Vector` был упрощен за счет исключения обработки ошибок.

Комбинация конструктора и деструктора лежит в основе многих элегантных методов. В частности, это основа для большинства общих методов управления ресурсами C++ ( #§6_3,  #§15_2_1). Рассмотрим графическую иллюстрацию `Vector`:

![[STL_10.png]]

Конструктор аллоцирует (выделяет память) и соответствующим образом инициализирует элементы `Vector`. Деструктор освобождает память выделенную под элементы. Эта модель обращения к данным очень часто используется для управления данными, размер которых может изменяться в течение срока жизни объекта. Метод получения ресурсов в конструкторе и освобождения их в деструкторе, известный как получение ресурсов есть инициализация или RAII. Это позволяет нам исключить операции с `“голым new”`, то есть избежать аллокаций в основном коде и сохранить их скрытыми внутри реализации хорошо управляемых абстракций. Аналогичным образом, следует избегать операций с `“голым delete”`. Отказ от голых [[new|new]] и [[delete|delete]] делает код гораздо менее подверженным ошибкам и более защищенным от утечек ресурсов ( #§15_2_1).

### Инициализация контейнеров

Контейнер существует для хранения элементов, поэтому, очевидно, нам нужны удобные способы добавления элементов в контейнер. Мы можем создать `Vector` с соответствующим количеством элементов, а позже присвоить им значения, но обычно другие способы более элегантны. Здесь я просто упомяну два предпочтительных:
>
> **Конструктор от списка инициализации**: Инициализация с помощью списка элементов.
> 
> **`push_back()`**: Добавление нового элемента в конец последовательности.

Они могут быть объявлены следующим образом:
```c++
class Vector {
	public:
		Vector(); // default initalize to "empty"; that is, to no elements
		
		// initialize with a list of doubles
		Vector(std::initializer_list<double>); 
		
		...
		
		// add element at end, increasing the size by one
		void push_back(double); 

		 ...
};
```

Функция `push_back()` полезна для добавления произвольного количества элементов. Например:
```c++
Vector read(istream& is)
{
	Vector v;
	
	for (double d; is>>d; )      // read floating-point values into d
		v.push_back(d);          // add d to v

	return v;
}
```

Цикл ввода прерывается в случае окончания файла или ошибки форматирования. До тех пор, пока этого не произойдет, каждое считанное число добавляется к `Vector` так, чтобы в конце размер `v` был равен количеству считанных элементов. Я использовал оператор [[for|for]], а не более традиционный оператор [[while|while]], чтобы ограничить область действия `d` циклом.

Возврат потенциально огромного объема данных из `read()` может быть дорогостоящим. Чтобы гарантировать, что возврат `Vector` будет дешевым, необходимо реализовать для него конструктор перемещения ( #§6_2_2):
```c++
Vector v = read(cin);              // no copy of Vector elements here
```

Способ реализации [[vector|std::vector]] для повышения эффективности `push_back()` и других операций, изменяющих размер вектора, представлен в #§12_2.

[[initializer_list|std::initializer_list]], используемый для определения конструктора от списка инициализации, является типом стандартной библиотеки, известным компилятору: когда мы используем `{}`-список, такой как `{1,2,3,4}`, компилятор создаст объект типа [[initializer_list|initializer_list]] для передачи программе. Итак, мы можем написать:
```c++
Vector v1 = {1, 2, 3, 4, 5};            // v1 has 5 elements
Vector v2 = {1.23, 3.45, 6.7, 8};       // v2 has 4 elements
```

Конструктор от списка инициализации `Vector` может быть определен следующим образом:
```c++
Vector::Vector(std::initializer_list<double> lst) // initialize with a list
	:elem{new double[lst.size()]}, sz{static_cast<int>(lst.size())}
{
	copy(lst.begin(), lst.end(), elem); // copy from lst into elem
}
```

К сожалению, стандартная библиотека использует `unsigned` (беззнаковые) целые для размеров и индексов, поэтому нам нужно использовать уродливый [[static_cast|static_cast]], чтобы явно преобразовать размер списка инициализаторов в `int`. Это педантично, потому что вероятность того, что количество элементов в рукописном списке больше, чем наибольшее целое число (32 767 для 16-разрядных целых чисел и 2 147 483 647 для 32-разрядных целых чисел), довольно мала. Однако система типов здравым смыслом не обладает. Она знает о возможных значениях переменных, а не о фактических значениях, поэтому она может жаловаться там, где фактического нарушения нет. Такие предупреждения иногда могут спасти программиста от серьезной ошибки.

[[static_cast|static_cast]] не проверяет значение, которое он преобразует; компилятор считает что программист использует его правильно. Это не всегда верное предположение, поэтому, если вы сомневаетесь, проверьте значение. Явных преобразований типов (часто называемых `casts` (приведениями), чтобы напомнить вам, что они используются в качестве костыля для поддержки чего-то сломанного) лучше избегать. Старайтесь использовать непроверенные приведения только для самого низкого уровня системы. Они подвержены ошибкам.

Другими приведениями являются [[reinterpret_cast|reinterpret_cast]] и [[bit_cast|bit_cast]] ( #§16_7) для обработки объекта как простой последовательности байтов и [[const_cast|const_cast]] для `“отбрасывания const”`. Разумное использование системы типов и хорошо продуманных библиотек позволяют нам устранять непроверенные приведения в программном обеспечении более высокого уровня.

# Абстрактные типы

Такие типы, как [[complex|complex]] и `Vector`, называются конкретными типами, потому что их представление является частью их определения. В этом они напоминают встроенные типы. Абстрактный тип - напротив, полностью изолирует пользователя от деталей реализации. Для этого, мы отделяем интерфейс от представления и отказываемся от реальных локальных переменных. Поскольку мы ничего не знаем о представлении абстрактного типа (даже о его размере), мы должны [[Классы#Контейнеры|размещать объекты в динамической памяти]] и получать к ним доступ через [[Программы - STL#Указатели, Массивы и Ссылки|ссылки или указатели]] ( #§15_2_1).

Сначала мы определяем интерфейс класса `Container`, который мы разработаем как более абстрактную версию нашего `Vector`:
```c++
class Container {
	public:
		virtual double& operator[](int) = 0;   // pure virtual function
		virtual int size() const = 0;          // const member function
		virtual ~Container() {}                // destructor
};
```

Этот класс является чистым интерфейсом к конкретным контейнерам, определенным позже. Слово [[virtual|virtual]] означает “может быть переопределено позже в классе, производном от этого”. Неудивительно, что функция, объявленная [[virtual|virtual]], называется виртуальной функцией. Класс, производный от `Container`, предоставляет реализацию интерфейса `Container`. Интересный синтаксис `=0` говорит, что функция является чисто виртуальной; то есть некоторый класс, производный от `Container`, должен определить эту функцию. Таким образом, невозможно определить объект, который является просто `Container`. Например:
```c++
Container c;       // error: there can be no objects of an abstract class

	// OK: Container is an interface for Vector_container
Container* p = new Vector_container(10); 
```

`Container` может служить интерфейсом только для класса, который реализует его функции `operator[]()` и [[size|size()]]. Класс как минимум с одной чисто виртуальной функцией называется абстрактным классом.

Этот `Container` можно использовать следующим образом:
```c++
void use(Container& c)
{
	const int sz = c.size();
	
	for (int i=0; i!=sz; ++i)
		cout << c[i] << '\n';
}
```

Обратите внимание, как `use()` использует интерфейс `Container` при полном незнании деталей реализации. Он использует `size()` и `[ ]` без какого-либо представления о том, какой именно тип обеспечивает их реализацию. Класс, который предоставляет интерфейс для множества других классов, часто называют полиморфным типом.

Как это обычно бывает с абстрактными классами, `Container` не имеет конструктора. В конце концов, у него нет никаких данных для инициализации. С другой стороны, у `Container` действительно есть деструктор, и этот деструктор является виртуальным, так что классы, производные от `Container`, могут предоставлять соответствующие реализации. Опять же, это характерно для абстрактных классов, потому что ими, как правило, манипулируют с помощью ссылок или указателей, и кто-то, уничтожающий `Container` с помощью указателя, понятия не имеет, какими ресурсами владеет его реализация; [[#Иерархии классов|см.]].

Абстрактный класс `Container` определяет только интерфейс и никакой реализации. Чтобы контейнер был полезен, мы должны реализовать контейнер, который реализует функции, требуемые его интерфейсом. Для этого мы могли бы использовать конкретный класс `Vector`:
```c++
// Vector_container implements Container
class Vector_container : public Container 
{ 
	public:
		Vector_container(int s) : v(s) { } // Vector of s elements
		~Vector_container() {}
		
		double& operator[](int i) override { return v[i]; }
		int size() const override { return v.size(); }
	
	private:
		Vector v;
};
```

Параметр `:public` может быть прочитан как “является производным от” или “является подтипом”. Класс `Vector_container` считается производным от класса `Container`, а класс `Container` считается базовым для класса `Vector_container`. Альтернативная терминология называет `Vector_container` и `Container` подклассом и суперклассом, соответственно. Производный класс наследует элементы от своего базового класса, поэтому использование базового и производных классов обычно называют наследованием.

Методы `operator[]()` и `size()` переопределяют соответствующие элементы в базовом классе `Container`. Я использовал явное указание ключевого слова [[override|override]], чтобы прояснить задуманное. Использование [[override|override]] необязательно, но его явное использование позволяет компилятору обнаруживать ошибки, такие как неправильное написание имен функций или незначительные различия между типом [[virtual|virtual]] функции и ее предполагаемым переопределителем. Явное использование [[override|override]] особенно полезно в больших иерархиях классов, где в противном случае может быть трудно понять, что должно переопределять что.

Деструктор (`~Vector_container()`) переопределяет деструктор базового класса (`~Container()`). Обратите внимание, что деструктор элемента (`~Vector()`) неявно вызывается деструктором его класса (`~Vector_container()`).

Чтобы такая функция, как `use(Container&)`, использовала `Container` при полном незнании деталей реализации, какая-то другая функция должна будет создать объект, с которым она может работать. Например:
```c++
void g()
{
	Vector_container vc(10); // Vector of ten elements
	
	... fill vc ...

	use(vc);
}
```

Поскольку `use()` не знает о `Vector_container`, а знает только интерфейс `Container`, он будет работать так же хорошо для другой реализации `Container`. Например:
```c++
// List_container implements Container
class List_container : public Container { 
	public:
		List_container() { }                           // empty List
		List_container(initializer_list<double> il) : ld{il} { }
		~List_container() {}
		
		double& operator[](int i) override;
		int size() const override { return ld.size(); }
	
	private:
		std::list<double> ld; // (standard-library) list of doubles
};

double& List_container::operator[](int i)
{
	for (auto& x : ld) {
		if (i==0)
			return x;
		
		--i;
	}
	throw out_of_range{"List container"};
}
```

Здесь показан `list<double>` из стандартной библиотеки. Обычно я бы не стал реализовывать контейнер с операцией индекса, используя [[list|list]], потому что производительность операции индекса на [[list|list]] ужасна по сравнению с таковой в [[vector|vector]]. Однако здесь я просто хотел показать реализацию, которая радикально отличается от обычной. 

Функция может создать `List_container` и заставить `use()` использовать его:
```c++
void h()
{
	List_container lc = {1, 2, 3, 4, 5, 6, 7, 8, 9};
	use(lc);
}
```

Дело в том, что `use(Container&)` понятия не имеет, является ли его аргумент `Vector_container`, `List_container` или каким-либо другим типом контейнера; ему не нужно это знать. Для этого можно использовать любой вид `Container`. Он знает только интерфейс, определенный `Container`. Следовательно, `use(Container&)` не нужно перекомпилировать, если изменяется реализация `List_container` или используется совершенно новый класс, производный от `Container`.

Оборотной стороной такой гибкости является то, что объектами необходимо управлять с помощью указателей или ссылок ( #§6_2, #§15_2_1).

# Виртуальные функции

Опять рассмотрим использование `Container`:
```c++
void use(Container& c)
{
	const int sz = c.size();
	for (int i=0; i!=sz; ++i)
		cout << c[i] << '\n';
}
```

Как вызов `c[i]` в `use()` преобразуется в соответствующий `operator[]()`? Когда `h()` вызывает `use()`, должен быть вызван `operator[]()` из `List_container`. Когда `g()` вызывает `use()`, должен быть вызван `operator[]()` из `Vector_container`. Чтобы решить эту задачу, объект `Container` должен содержать информацию, позволяющую ему выбрать правильную функцию для вызова во время выполнения. Обычно это реализовано так, что компилятор преобразует имя виртуальной функции в индекс в таблице указателей на функции. Эта таблица обычно называется таблицей виртуальных функций или просто `vtbl`. Каждый класс с виртуальными функциями имеет свой собственный `vtbl`, идентифицирующий его виртуальные функции. Это можно представить графически следующим образом:

![[STL_11.png]]

![[STL_12.png]]


































# Иерархии классов
