
1. [[#Классы]] 5.1
2. [[#Конкретные типы|Конкретные классы]] 5.2
	1. [[#Арифметические типы|Арифметические типы]]  5.2.1
	2. [[#Контейнеры|Контейнеры]] 5.2.2
	3. [[#Инициализация контейнеров|Инициализация контейнеров]] 5.2.3
3. [[#Абстрактные типы|Абстрактные типы]] 5.3
4. [[#Виртуальные функции|Виртуальные функции]] 5.4
5. [[#Иерархии классов|Иерархии классов]] 5.5
	1. [[#Преимущества иерархий|Преимущества иерархий]] 5.5.1
	2. [[#Навигация в иерархии|Навигация в иерархии]] 5.5.2
	3. [[#Предотвращение утечки ресурсов|Предотвращение утечки ресурсов]] 5.5.3

# Классы

Центральной языковой особенностью C++ является класс. Класс - это пользовательский тип, служащий для представления сущности в коде программы. Всякий раз, когда в нашем проекте программы появляется полезная идея, объект, набор данных и т.д., мы стараемся представить это как класс в программе, чтобы идея существовала в коде, а не только в наших головах, в проектном документе или в некоторых комментариях. Программу, построенную на основе хорошо подобранного набора классов, гораздо легче понять и сделать безошибочной, чем ту, которая строит все непосредственно в терминах встроенных типов. В частности, библиотеки зачастую предлагают именно наборы классов.

По сути, все языковые средства, помимо фундаментальных типов, операторов и ключевых слов, существуют для того, чтобы помочь определить лучшие классы или более удобно их использовать. Под “лучше” я подразумеваю более корректный, более простой в обслуживании, более эффективный, более элегантный, более простой в использовании, более легкий для чтения и более понятный для рассуждений. Большинство методов программирования основаны на разработке и реализации определенных типов классов. Потребности и вкусы программистов сильно различаются. Следовательно, поддержка классов является обширной. Здесь мы рассмотрим базовую поддержку для трех важных типов классов:

* [[#Конкретные типы|Конкретные классы]]
* [[#Абстрактные типы|Абстрактные классы]]
* [[#Иерархии классов|Классы в иерархиях классов]] 

Поразительное количество полезных классов оказывается одного из этих трех видов. Еще больше классов можно рассматривать как упрощенные варианты из этих трёх видов или реализованные с использованием комбинаций методов, используемых в этих основных вариантах.

# Конкретные типы

Основная идея конкретных классов заключается в том, что они ведут себя “точно так же, как встроенные типы”. Например, тип комплексное число и целое число бесконечной точности во многом похожи на встроенные в него `int`, за исключением, конечно, того, что они имеют свою собственную семантику и наборы операций. Аналогично, [[vector|vector]] и [[string|string]] во многом похожи на [[Array|встроенные массивы]], за исключением того, что они более гибкие и лучше управляются.

Определяющей характеристикой конкретного типа является то, что его представление является частью его определения. Во многих важных случаях, таких как [[vector|vector]], это представление является всего лишь одним или несколькими указателями на данные, хранящиеся в другом месте, но это представление присутствует в каждом объекте конкретного класса. Это позволяет реализации быть оптимально эффективной по быстродействию и памяти. В частности, это позволяет нам:
>
>Размещать объекты конкретных типов в стеке, в статически выделяемой памяти и в других объектах ([[Программы - STL#Область видимости и время жизни|Область видимости и время жизни]]).
>
> Ссылаться на объекты напрямую (а не только через указатели или ссылки).
> 
> Инициализировать объекты немедленно и полностью (например, с помощью конструкторов; [[Пользовательские типы#Классы|Классы]]).
> 
> [[Основные операции#Копирование и перемещение|Копировать и перемещать объекты]].

Представление может быть приватным и доступным только через методы(как это имеет место для [[vector|Vector]]), но оно присутствует. Следовательно, если представление изменяется каким-либо существенным образом, пользователь должен выполнить перекомпиляцию. Это цена того, что конкретные типы ведут себя точно так же, как встроенные типы. Для типов, которые меняются нечасто, и где локальные переменные обеспечивают столь необходимую ясность и эффективность, это приемлемо и часто идеально. Чтобы повысить гибкость, конкретный тип может сохранять основные части своего представления в динамической памяти и получать к ним доступ через часть, хранящуюся в самом объекте класса. Именно так реализованы [[vector|vector]] и [[string|string]]; их можно рассматривать как дескрипторы ресурсов с тщательно проработанными интерфейсами.

### Арифметические типы

“Классическим пользовательским арифметическим типом” является комплексное число [[complex|complex]]:
```c++
class complex {
		double re, im;                  // representation: two doubles
	public:
		complex(double r, double i) 
			:re{r}, im{i} {}            // construct complex from two scalars

		complex(double r) 
			:re{r}, im{0} {}            // construct complex from one scalar
			
		complex() 
			:re{0}, im{0} {}            // default complex: {0,0}

		complex(complex z) 
			:re{z.re}, im{z.im} {}      // copy constructor
			
		double real() const { return re; }
		void real(double d) { re=d; }
		double imag() const { return im; }
		void imag(double d) { im=d; }
		
		complex& operator+=(complex z)
		{
			re+=z.re;                   // add to re and im
			im+=z.im;
			
			return *this;               // return the result
		}
		
		complex& operator-=(complex z)
		{
			re-=z.re;
			im-=z.im;
			
			return *this;
		}
		
		complex& operator*=(complex);   // defined out-of-class somewhere
		complex& operator/=(complex);  // defined out-of-class somewhere
};
```

Это упрощенная версия [[complex|complex]] из стандартной библиотеки. Само определение класса содержит только операции, требующие доступа к представлению. Представление простое и общепринятое. По практическим соображениям оно должно быть совместимо с тем, что предоставлял `Fortran` 60 лет назад, и нам нужен обычный набор операторов. В дополнение к требованиям к базоаой логике, [[complex|complex]] должен быть эффективным, иначе он будет непригодным к использованию. Это подразумевает, что простые операции должны быть встраиваемыми ([[inline|inline]]). То есть простые операции (такие как конструкторы, `+=` и `imag()`) должны быть реализованы без вызовов функций в сгенерированном машинном коде. Функции, определенные в классе, [[inline|inline]] по умолчанию. Можно явно запросить встраивание, указав перед объявлением функции ключевое слово [[inline|inline]]. [[complex|complex]] из библиотеки `Industrial Strength` (подобный complex стандартной библиотеки) тщательно реализован для выполнения соответствующего встраивания. Кроме того, в [[complex|complex]] стандартной библиотеки функции, показанные здесь, объявлены [[constexpr|constexpr]], чтобы мы могли выполнять сложную арифметику во время компиляции. 

[[Основные операции#Копирование и перемещение|Копирующий оператор присваивания и конструктор копирования определены неявно]].

Конструктор, который может быть вызван без аргумента, называется конструктором по умолчанию. Таким образом, [[complex|complex()]] является конструктором [[complex|complex]] по умолчанию. Определяя конструктор по умолчанию, вы исключаете возможность существования неинициализированных переменных этого типа.

Спецификаторы [[const|const]] для функций, возвращающих действительную и мнимую части, указывают на то, что эти функции не изменяют объект, для которого они вызываются. Функция-член [[const|const]] может быть вызвана как для объектов [[const|const]], так и для неконстантных объектов, но неконстантная функция-член может быть вызвана только для неконстантных объектов. Например:
```c++
complex z = {1,0};
const complex cz {1,3};

z = cz;               // OK: assigning to a non-const variable
cz = z;               // error: assignment to a const
double x = z.real();  // OK: complex::real() is const
```

Множество полезных операций не требуют прямого доступа к представлению [[complex|complex]], поэтому они могут быть определены отдельно от определения класса:
```c++
complex operator+(complex a, complex b) { return a+=b; }
complex operator-(complex a, complex b) { return a-=b; }
complex operator-(complex a) { return {-a.real(), -a.imag()}; } // unary minus
complex operator*(complex a, complex b) { return a*=b; }
complex operator/(complex a, complex b) { return a/=b; }
```

Здесь я использую тот факт, что аргумент, передаваемый по значению, копируется, так что я могу изменить аргумент, не затрагивая копию вызывающего объекта, и использовать результат в качестве возвращаемого значения.

Определения `==` и `!=` просты:
```c++
bool operator==(complex a, complex b) { return a.real()==b.real() && a.imag()==b.imag(); } // equal
bool operator!=(complex a, complex b) { return !(a==b); } // not equal
```

Класс [[complex|complex]] может быть использован следующим образом:
```c++
void f(complex z)
{
	complex a {2.3}; // construct {2.3,0.0} from 2.3
	complex b {1/a};
	complex c {a+z*complex{1,2.3}};
	
	if (c != b)
		c = -(b/a)+2*b;
}
```

Компилятор преобразует операторы, включающие [[complex|complex]] комплексные числа, в соответствующие вызовы функций. Например, `c!=b` означает `operator!=(c,b)`, и `1/a` означает `operator/(complex{1},a)`.

Определяемые пользователем операторы [[Основные операции#Перегрузка операторов|(“перегруженные операторы”)]] следует использовать осторожно и традиционно. Синтаксис фиксирован языком, поэтому вы не можете определить унарный `/`. Кроме того, невозможно изменить значение оператора для встроенных типов, поэтому вы не можете переопределить `+` для вычитания целых чисел `int`.

### Контейнеры

Контейнер - это объект, содержащий коллекцию элементов. Мы называем класс `Vector` контейнером, потому что объекты типа `Vector` являются контейнерами. Как  [[Пользовательские типы#Классы|определено]], `Vector` не является необоснованным контейнером `double`: он прост для понимания, [[Обработка ошибок#Инварианты|устанавливает полезный инвариант]], обеспечивает [[Обработка ошибок#Исключения|доступ с проверкой диапазона]] и предоставляет `size()`, что позволяет нам перебирать его элементы. Однако у него есть фатальный недостаток: он выделяет элементы, используя [[new|new]], но никогда не освобождает их. Это не очень хорошая идея, потому что C++ не предлагает сборщик мусора, чтобы сделать неиспользуемую память доступной для новых объектов. В некоторых средах вы не можете использовать сборщик, и часто вы предпочитаете более точное управление уничтожением по логичным соображениям или соображениям производительности. Нам нужен механизм, гарантирующий освобождение памяти, выделенной конструктором; этот механизм называется деструктором:
```c++
class Vector {
	public:
		Vector(int s) 
			:elem{new double[s]}, sz{s} // constructor: acquire resources
		{
			for (int i=0; i!=s; ++i)    // initialize elements
				elem[i]=0;
		}
		
		~Vector() 
			{ delete[] elem; }          // destructor: release resources

		double& operator[](int i);
		int size() const;
	
	private:
		double* elem;                // elem points to an array of sz doubles
		int sz;
};
```
Именем деструктора является оператор дополнения, `~`, за которым следует имя класса; деструктор — это дополнение конструктора.

Конструктор `Vector` выделяет некоторую память в динамической памяти (также называемой кучей) с помощью оператора [[new|new]]. Деструктор выполняет очистку, освобождая эту память с помощью оператора [[delete|delete[]]]. Простой [[delete|delete]] удаляет отдельный объект; [[delete|delete[]]] удаляет массив.

Все это делается без вмешательства пользователей `Vector`. Пользователи просто создают и используют `Vector` так же, как они использовали бы переменные встроенных типов. Например:
```c++
Vector gv(10);  // global variable; gv is destroyed at the 
				// end of the program
Vector* gp = new Vector(100);   // Vector on free store; 
								// never implicitly destroyed
void fct(int n)
{
	Vector v(n);
	
	... use v ...
	
	{
		Vector v2(2*n);
		... use v and v2 ...
	} // v2 is destroyed here
	
	 ... use v ..
} // v is destroyed here
```

Vector подчиняется тем же [[Программы - STL#Область видимости и время жизни|правилам именования, области видимости, выделения памяти, времени жизни и т.д]], как и встроенный тип, такой как `int` и `char`. Этот `Vector` был упрощен за счет исключения обработки ошибок.

Комбинация конструктора и деструктора лежит в основе многих элегантных методов. В частности, это основа для большинства общих методов [[Основные операции#Управление ресурсами|управления ресурсами C++]]. Рассмотрим графическую иллюстрацию `Vector`:

![[STL_10.png]]

Конструктор аллоцирует (выделяет память) и соответствующим образом инициализирует элементы `Vector`. Деструктор освобождает память выделенную под элементы. Эта модель обращения к данным очень часто используется для управления данными, размер которых может изменяться в течение срока жизни объекта. Метод получения ресурсов в конструкторе и освобождения их в деструкторе, известный как получение ресурсов есть инициализация или RAII. Это позволяет нам исключить операции с `“голым new”`, то есть избежать аллокаций в основном коде и сохранить их скрытыми внутри реализации хорошо управляемых абстракций. Аналогичным образом, следует избегать операций с `“голым delete”`. Отказ от голых [[new|new]] и [[delete|delete]] делает код гораздо менее подверженным ошибкам и [[Указатели#unique_ptr и shared_ptr|более защищенным от утечек ресурсов]].

### Инициализация контейнеров

Контейнер существует для хранения элементов, поэтому, очевидно, нам нужны удобные способы добавления элементов в контейнер. Мы можем создать `Vector` с соответствующим количеством элементов, а позже присвоить им значения, но обычно другие способы более элегантны. Здесь я просто упомяну два предпочтительных:
>
> **Конструктор от списка инициализации**: Инициализация с помощью списка элементов.
> 
> **`push_back()`**: Добавление нового элемента в конец последовательности.

Они могут быть объявлены следующим образом:
```c++
class Vector {
	public:
		Vector(); // default initalize to "empty"; that is, to no elements
		
		// initialize with a list of doubles
		Vector(std::initializer_list<double>); 
		
		...
		
		// add element at end, increasing the size by one
		void push_back(double); 

		 ...
};
```

Функция `push_back()` полезна для добавления произвольного количества элементов. Например:
```c++
Vector read(istream& is)
{
	Vector v;
	
	for (double d; is>>d; )      // read floating-point values into d
		v.push_back(d);          // add d to v

	return v;
}
```

Цикл ввода прерывается в случае окончания файла или ошибки форматирования. До тех пор, пока этого не произойдет, каждое считанное число добавляется к `Vector` так, чтобы в конце размер `v` был равен количеству считанных элементов. Я использовал оператор [[for|for]], а не более традиционный оператор [[while|while]], чтобы ограничить область действия `d` циклом.

Возврат потенциально огромного объема данных из `read()` может быть дорогостоящим. Чтобы гарантировать, что возврат `Vector` будет дешевым, необходимо реализовать для него [[Основные операции#Перемещение контейнеров|конструктор перемещения]]:
```c++
Vector v = read(cin);              // no copy of Vector elements here
```

Способ реализации [[vector|std::vector]] для повышения эффективности `push_back()` и других операций, изменяющих размер [[vector#std vector|вектора]].

[[initializer_list|std::initializer_list]], используемый для определения конструктора от списка инициализации, является типом стандартной библиотеки, известным компилятору: когда мы используем `{}`-список, такой как `{1,2,3,4}`, компилятор создаст объект типа [[initializer_list|initializer_list]] для передачи программе. Итак, мы можем написать:
```c++
Vector v1 = {1, 2, 3, 4, 5};            // v1 has 5 elements
Vector v2 = {1.23, 3.45, 6.7, 8};       // v2 has 4 elements
```

Конструктор от списка инициализации `Vector` может быть определен следующим образом:
```c++
Vector::Vector(std::initializer_list<double> lst) // initialize with a list
	:elem{new double[lst.size()]}, sz{static_cast<int>(lst.size())}
{
	copy(lst.begin(), lst.end(), elem); // copy from lst into elem
}
```

К сожалению, стандартная библиотека использует `unsigned` (беззнаковые) целые для размеров и индексов, поэтому нам нужно использовать уродливый [[static_cast|static_cast]], чтобы явно преобразовать размер списка инициализаторов в `int`. Это педантично, потому что вероятность того, что количество элементов в рукописном списке больше, чем наибольшее целое число (32 767 для 16-разрядных целых чисел и 2 147 483 647 для 32-разрядных целых чисел), довольно мала. Однако система типов здравым смыслом не обладает. Она знает о возможных значениях переменных, а не о фактических значениях, поэтому она может жаловаться там, где фактического нарушения нет. Такие предупреждения иногда могут спасти программиста от серьезной ошибки.

[[static_cast|static_cast]] не проверяет значение, которое он преобразует; компилятор считает что программист использует его правильно. Это не всегда верное предположение, поэтому, если вы сомневаетесь, проверьте значение. Явных преобразований типов (часто называемых `casts` (приведениями), чтобы напомнить вам, что они используются в качестве костыля для поддержки чего-то сломанного) лучше избегать. Старайтесь использовать непроверенные приведения только для самого низкого уровня системы. Они подвержены ошибкам.

Другими приведениями являются [[reinterpret_cast|reinterpret_cast]] и [[bit_cast|bit_cast]] для обработки объекта как простой последовательности байтов и [[const_cast|const_cast]] для `“отбрасывания const”`. Разумное использование системы типов и хорошо продуманных библиотек позволяют нам устранять непроверенные приведения в программном обеспечении более высокого уровня.

# Абстрактные типы

Такие типы, как [[complex|complex]] и `Vector`, называются конкретными типами, потому что их представление является частью их определения. В этом они напоминают встроенные типы. Абстрактный тип - напротив, полностью изолирует пользователя от деталей реализации. Для этого, мы отделяем интерфейс от представления и отказываемся от реальных локальных переменных. Поскольку мы ничего не знаем о представлении абстрактного типа (даже о его размере), мы должны [[Классы#Контейнеры|размещать объекты в динамической памяти]] и получать к ним доступ через [[Программы - STL#Указатели, Массивы и Ссылки|ссылки или указатели]].

Сначала мы определяем интерфейс класса `Container`, который мы разработаем как более абстрактную версию нашего `Vector`:
```c++
class Container {
	public:
		virtual double& operator[](int) = 0;   // pure virtual function
		virtual int size() const = 0;          // const member function
		virtual ~Container() {}                // destructor
};
```

Этот класс является чистым интерфейсом к конкретным контейнерам, определенным позже. Слово [[virtual|virtual]] означает “может быть переопределено позже в классе, производном от этого”. Неудивительно, что функция, объявленная [[virtual|virtual]], называется виртуальной функцией. Класс, производный от `Container`, предоставляет реализацию интерфейса `Container`. Интересный синтаксис `=0` говорит, что функция является чисто виртуальной; то есть некоторый класс, производный от `Container`, должен определить эту функцию. Таким образом, невозможно определить объект, который является просто `Container`. Например:
```c++
Container c;       // error: there can be no objects of an abstract class

	// OK: Container is an interface for Vector_container
Container* p = new Vector_container(10); 
```

`Container` может служить интерфейсом только для класса, который реализует его функции `operator[]()` и [[size|size()]]. Класс как минимум с одной чисто виртуальной функцией называется абстрактным классом.

Этот `Container` можно использовать следующим образом:
```c++
void use(Container& c)
{
	const int sz = c.size();
	
	for (int i=0; i!=sz; ++i)
		cout << c[i] << '\n';
}
```

Обратите внимание, как `use()` использует интерфейс `Container` при полном незнании деталей реализации. Он использует `size()` и `[ ]` без какого-либо представления о том, какой именно тип обеспечивает их реализацию. Класс, который предоставляет интерфейс для множества других классов, часто называют полиморфным типом.

Как это обычно бывает с абстрактными классами, `Container` не имеет конструктора. В конце концов, у него нет никаких данных для инициализации. С другой стороны, у `Container` действительно есть деструктор, и этот деструктор является виртуальным, так что классы, производные от `Container`, могут предоставлять соответствующие реализации. Опять же, это характерно для абстрактных классов, потому что ими, как правило, манипулируют с помощью ссылок или указателей, и кто-то, уничтожающий `Container` с помощью указателя, понятия не имеет, какими ресурсами владеет его реализация; [[#Иерархии классов|см.]].

Абстрактный класс `Container` определяет только интерфейс и никакой реализации. Чтобы контейнер был полезен, мы должны реализовать контейнер, который реализует функции, требуемые его интерфейсом. Для этого мы могли бы использовать конкретный класс `Vector`:
```c++
// Vector_container implements Container
class Vector_container : public Container 
{ 
	public:
		Vector_container(int s) : v(s) { } // Vector of s elements
		~Vector_container() {}
		
		double& operator[](int i) override { return v[i]; }
		int size() const override { return v.size(); }
	
	private:
		Vector v;
};
```

Параметр `:public` может быть прочитан как “является производным от” или “является подтипом”. Класс `Vector_container` считается производным от класса `Container`, а класс `Container` считается базовым для класса `Vector_container`. Альтернативная терминология называет `Vector_container` и `Container` подклассом и суперклассом, соответственно. Производный класс наследует элементы от своего базового класса, поэтому использование базового и производных классов обычно называют наследованием.

Методы `operator[]()` и `size()` переопределяют соответствующие элементы в базовом классе `Container`. Я использовал явное указание ключевого слова [[override|override]], чтобы прояснить задуманное. Использование [[override|override]] необязательно, но его явное использование позволяет компилятору обнаруживать ошибки, такие как неправильное написание имен функций или незначительные различия между типом [[virtual|virtual]] функции и ее предполагаемым переопределителем. Явное использование [[override|override]] особенно полезно в больших иерархиях классов, где в противном случае может быть трудно понять, что должно переопределять что.

Деструктор (`~Vector_container()`) переопределяет деструктор базового класса (`~Container()`). Обратите внимание, что деструктор элемента (`~Vector()`) неявно вызывается деструктором его класса (`~Vector_container()`).

Чтобы такая функция, как `use(Container&)`, использовала `Container` при полном незнании деталей реализации, какая-то другая функция должна будет создать объект, с которым она может работать. Например:
```c++
void g()
{
	Vector_container vc(10); // Vector of ten elements
	
	... fill vc ...

	use(vc);
}
```

Поскольку `use()` не знает о `Vector_container`, а знает только интерфейс `Container`, он будет работать так же хорошо для другой реализации `Container`. Например:
```c++
// List_container implements Container
class List_container : public Container { 
	public:
		List_container() { }                           // empty List
		List_container(initializer_list<double> il) : ld{il} { }
		~List_container() {}
		
		double& operator[](int i) override;
		int size() const override { return ld.size(); }
	
	private:
		std::list<double> ld; // (standard-library) list of doubles
};

double& List_container::operator[](int i)
{
	for (auto& x : ld) {
		if (i==0)
			return x;
		
		--i;
	}
	throw out_of_range{"List container"};
}
```

Здесь показан `list<double>` из стандартной библиотеки. Обычно я бы не стал реализовывать контейнер с операцией индекса, используя [[list|list]], потому что производительность операции индекса на [[list|list]] ужасна по сравнению с таковой в [[vector|vector]]. Однако здесь я просто хотел показать реализацию, которая радикально отличается от обычной. 

Функция может создать `List_container` и заставить `use()` использовать его:
```c++
void h()
{
	List_container lc = {1, 2, 3, 4, 5, 6, 7, 8, 9};
	use(lc);
}
```

Дело в том, что `use(Container&)` понятия не имеет, является ли его аргумент `Vector_container`, `List_container` или каким-либо другим типом контейнера; ему не нужно это знать. Для этого можно использовать любой вид `Container`. Он знает только интерфейс, определенный `Container`. Следовательно, `use(Container&)` не нужно перекомпилировать, если изменяется реализация `List_container` или используется совершенно новый класс, производный от `Container`.

Оборотной стороной такой гибкости является то, что объектами необходимо управлять с помощью [[Указатели#unique_ptr и shared_ptr|указателей]] или ссылок.

# Виртуальные функции

Опять рассмотрим использование `Container`:
```c++
void use(Container& c)
{
	const int sz = c.size();
	for (int i=0; i!=sz; ++i)
		cout << c[i] << '\n';
}
```

Как вызов `c[i]` в `use()` преобразуется в соответствующий `operator[]()`? Когда `h()` вызывает `use()`, должен быть вызван `operator[]()` из `List_container`. Когда `g()` вызывает `use()`, должен быть вызван `operator[]()` из `Vector_container`. Чтобы решить эту задачу, объект `Container` должен содержать информацию, позволяющую ему выбрать правильную функцию для вызова во время выполнения. Обычно это реализовано так, что компилятор преобразует имя виртуальной функции в индекс в таблице указателей на функции. Эта таблица обычно называется таблицей виртуальных функций или просто `vtbl`. Каждый класс с виртуальными функциями имеет свой собственный `vtbl`, идентифицирующий его виртуальные функции. Это можно представить графически следующим образом:

![[STL_11.png]]

![[STL_12.png]]

Функции в `vtbl` позволяют корректно использовать объект, даже если размер объекта и расположение его данных неизвестны вызывающей стороне. Реализация вызывающего объекта должна знать только местоположение указателя на `vtbl` в `Container` и индекс, используемый для каждой виртуальной функции. Этот механизм виртуального вызова можно сделать почти таким же эффективным, как механизм “обычного вызова функции” (в пределах 25% и намного дешевле при повторных вызовах одного и того же объекта). Его накладные расходы памяти составляют один указатель на каждый объект класса с виртуальными функциями плюс одна `vtbl` для каждого такого класса.

# Иерархии классов

Пример `Container` - это очень простой пример иерархии классов. Иерархия классов - это набор классов, упорядоченных в структуре, созданной путем наследования (например, `: public`). Мы используем иерархии классов для представления понятий, имеющих иерархические отношения, таких как “Пожарная машина - это разновидность грузовика, который является разновидностью транспортного средства” и “Смайлик - это разновидность круга, который является разновидностью формы”. Огромные иерархии, с сотнями классов, которые являются как глубокими, так и широкими, это обычное явление. В качестве полуреалистичного классического примера давайте рассмотрим геометрические фигуры на экране:
![[STL_13.png]]

Стрелки представляют отношение наследования. Например, класс `Circle` является производным от класса `Shape`. Иерархия классов обычно рисуется сверху вниз от самого базового класса, корневого, к (определенным позже) производным классам. Чтобы представить эту простую диаграмму в коде, мы должны сначала указать класс, который определяет общие свойства всех фигур:
```c++
class Shape {
	public:
		virtual Point center() const =0;        // pure virtual
		virtual void move(Point to) =0;
		virtual void draw() const = 0;          // draw on current "Canvas"
		virtual void rotate(int angle) = 0;
		virtual ~Shape() {}                     // destructor
												// ...
};
```

Естественно, этот интерфейс является абстрактным классом: что касается представления, то ничто (кроме расположения указателя на `vtbl`) не является общим для каждой фигуры `Shape`. Учитывая это определение, мы можем написать общие функции, манипулирующие векторами указателей на фигуры:
```c++
// rotate v's elements by angle degrees
void rotate_all(vector<Shape*>& v, int angle) 
{
	for (auto p : v)
		p->rotate(angle);
}
```

Чтобы определить конкретную фигуру, мы должны сказать, что это `Shape`, и указать ее конкретные свойства (включая ее виртуальные функции):
```c++
class Circle : public Shape {
	public:
		Circle(Point p, int rad) :x{p}. r{rad} {} // constructor
		
		Point center() const override { return x; }
		void move(Point to) override { x = to; }
		void draw() const override;
		void rotate(int) override {} // nice simple algorithm
	
	private:
		Point x; // center
		int r; // radius
};
```

Пока что пример `Shape` и `Circle` не дает ничего нового по сравнению с примером `Container` и `Vector_container`, но мы можем продолжить:
```c++
class Smiley : public Circle {     // use the circle as the base for a face
	public:
		Smiley(Point p, int rad) : Circle{p,rad}, mouth{nullptr} { }
		~Smiley()
		{
			delete mouth;
	
			for (auto p : eyes)
				delete p;
		}

		void move(Point to) override;
		void draw() const override;
		void rotate(int) override;
		
		void add_eye(Shape* s)
		{
			eyes.push_back(s);
		}
		
		void set_mouth(Shape* s);
		virtual void wink(int i);  // wink eye number i
	
		...
	
	private:
		vector<Shape*> eyes;       // usually two eyes
		Shape* mouth;
};
```

Метод `push_back()` класса [[vector|vector]] копирует свой аргумент в [[vector|vector]] (здесь `eyes`) в качестве последнего элемента, увеличивая размер этого вектора на единицу

Теперь мы можем определить `Smiley::draw()`, используя вызовы к базовому элементу `Smiley` и методу `draw()`:
```c++
void Smiley::draw() const
{
	Circle::draw();

	for (auto p : eyes)
		p->draw();
	
	mouth->draw();
}
```

Обратите внимание на то, как `Smiley` сохраняет свои глаза в [[vector|vector]] стандартной библиотеки и удаляет их в своем деструкторе. Деструктор `Shape` является [[virtual|virtual]], и деструктор `Smiley` переопределяет его. Виртуальный деструктор необходим для абстрактного класса, поскольку управление объектом производного класса обычно осуществляется через интерфейс, предоставляемый его абстрактным базовым классом. В частности, он может быть [[delete|delete]] через указатель на базовый класс. Затем механизм вызова виртуальной функции гарантирует, что будет вызван соответствующий деструктор. Затем этот деструктор неявно вызывает деструкторы своих баз и членов.

В этом упрощенном примере задача программиста - соответствующим образом разместить глаза и рот внутри круга, представляющего лицо.

Мы можем добавлять элементы данных, операции или и то, и другое по мере определения нового класса путем наследования. Это обеспечивает большую гибкость и соответствующие возможности для путаницы и плохого дизайна.

### Преимущества иерархий

Иерархия классов дает два вида преимуществ:
>
> **Наследование интерфейса**: объект производного класса может использоваться везде, где требуется объект базового класса. То есть базовый класс действует как интерфейс для производного класса. Например, классы `Container` и `Shape`. Такие классы часто являются абстрактными классами
>
> **Наследование реализации**: базовый класс предоставляет функции или данные, которые упрощают реализацию производных классов. Например `Smiley` использует конструктор `Circle` и `Circle::draw()`. Такие базовые классы часто содержат элементы данных и конструкторы.

Конкретные классы – особенно классы с небольшими представлениями – во многом похожи на встроенные типы: мы определяем их как локальные переменные, получаем к ним доступ, используя их имена, копируем их повсюду и т.д. Классы в иерархии классов различаются: мы обычно размещаем их в динамической памяти, используя [[new|new]], и получаем к ним доступ через указатели или ссылки. Например, рассмотрим функцию, которая считывает данные, описывающие фигуры, из входного потока и создает соответствующие объекты `Shape`:
```c++
enum class Kind {circle, triangle, smiley};

// read shape descriptions from input stream is
Shape* read_shape(istream& is) 
{
	// ... read shape header from is and find its Kind k ...
	switch (k) {
		case Kind::circle:
			... // read circle data {Point,int} into p and r ...
			return new Circle{p,r};
		
		case Kind::triangle:
			... // read triangle data {Point,Point,Point} 
				// into p1, p2, and p3 ...
			return new Triangle{p1,p2,p3};
			
		case Kind::smiley:
			... // read smiley data {Point,int,Shape,Shape,Shape} 
				// into p, r, e1, e2, and m
			
			Smiley* ps = new Smiley{p,r};
			ps->add_eye(e1);
			ps->add_eye(e2);
			ps->set_mouth(m);
			return ps;
	}
}
```

Программа может использовать этот считыватель фигур следующим образом:
```c++
void user()
{
	std::vector<Shape*> v;

	while (cin)
		v.push_back(read_shape(cin));
		
	draw_all(v);                     // call draw() for each element
	rotate_all(v,45);                // call rotate(45) for each element
	
	for (auto p : v)                 // remember to delete elements
		delete p;
}
```

Очевидно, что пример упрощен – особенно в отношении обработки ошибок, – но он наглядно иллюстрирует, что `user()` не имеет абсолютно никакого представления о том, какими типами фигур он манипулирует. Код `user()` может быть скомпилирован один раз и позже использован для новых фигур `Shape`, добавленных в программу. Обратите внимание, что нет указателей на фигуры вне `user()`, поэтому `user()` несет ответственность за их освобождение. Это делается с помощью оператора [[delete|delete]] и критически зависит от виртуального деструктора `Shape`. Поскольку этот деструктор является виртуальным [[delete|delete]] вызывает деструктор для самого производного класса. Это крайне важно, поскольку производный класс может получить любые виды ресурсов (таких как дескрипторы файлов, блокировки и выходные потоки), которые необходимо освободить. В этом случае `Smiley` удаляет объекты `eyes` и `mouth`. Как только он это сделает, он вызывает деструктор `Circle`. Объекты создаются конструкторами “снизу-вверх” (сначала базовые) и уничтожаются деструкторами “сверху-вниз” (сначала производные).

### Навигация в иерархии

Функция **`read_shape()`** возвращает **`Shape*`**, так что мы можем обрабатывать все **`Shape`** одинаково. Однако, что мы можем сделать, если хотим использовать функцию-член, которая предоставляется только определенным производным классом, например, **`Smileywink()`**? Мы можем спросить: “Является ли эта **`Shape`** чем-то вроде **`Smiley`**?”, используя оператор [[dynamic_cast|dynamic_cast]]:
```c++
Shape* ps {read_shape(cin)};

if (Smiley* p = dynamic_cast<Smiley*>(ps))  // does ps point to a Smiley?
{  
	... //a Smiley; use it ...
}
else {
	... //not a Smiley, try something else ...
}
```

Если во время выполнения объект, на который указывает аргумент [[dynamic_cast|dynamic_cast]] (здесь, `ps`), не относится к ожидаемому типу (здесь, `Smiley`) или является классом, производным от ожидаемого, [[dynamic_cast|dynamic_cast]] возвращает [[nullptr_t#nullptr|nullptr]].

Мы используем [[dynamic_cast|dynamic_cast]] для указателя, когда указатель на объект производного класса является допустимым аргументом. Затем мы проверяем, является ли результат [[nullptr_t#nullptr|nullptr]]. Этот тест часто удобно использовать при инициализации переменной в условии.

Когда другой тип неприемлем, мы можем просто преобразовать [[dynamic_cast|dynamic_cast]] в ссылочный тип. Если объект не относится к ожидаемому типу, [[dynamic_cast|dynamic_cast]] бросает исключение **`bad_cast`**:
```c++
Shape* ps {read_shape(cin)};
Smiley& r {dynamic_cast<Smiley&>(*ps)}; // somewhere, catch std::bad_cast
```

Код становится чище, когда [[dynamic_cast|dynamic_cast]] используется ограниченно. Если мы сможем избежать проверки информации о типе во время выполнения, мы сможем написать более простой и эффективный код, но иногда информация о типе теряется и должна быть восстановлена. Обычно это происходит, когда мы передаем объект некоторой системе, которая принимает интерфейс, указанный базовым классом. Когда эта система позже передаст объект обратно нам, нам, возможно, придется восстановить исходный тип. Операции, аналогичные [[dynamic_cast|dynamic_cast]], известны как операции “является производным от” или “является экземпляром”.

### Предотвращение утечки ресурсов

**Утечка** - это общепринятый термин для обозначения того, что происходит, когда мы приобретаем ресурс и не можем его освободить. Необходимо избегать утечки ресурсов, поскольку это делает утекший ресурс недоступным для системы. Таким образом, утечки могут в конечном итоге привести к замедлению работы или даже сбоям, поскольку в системе заканчиваются необходимые ресурсы.

Опытные программисты наверняка заметили, что я оставил открытыми три возможности для ошибок в примере со `Smiley`:
>
> Разработчик `Smiley` может не удалить [[delete|delete]] указатель на `mouth`.
> 
> Пользователь `read_shape()` может не [[delete|delete]] возвращенный указатель.
> 
> Владелец контейнера с указателями `Shape` может не [[delete|delete]] объекты, на которые ведут указатели.

В этом смысле указатели на объекты, размещенные в динамической памяти, опасны: “обычный старый указатель” не должен использоваться для представления права собственности. Например:
```c++
void user(int x)
{
	Shape* p = new Circle{Point{0,0},10};
	
	...
	
	if (x<0) 
		throw Bad_x{};             // potential leak
	
	if (x==0) 
		return;                    // potential leak
		...
delete p;
}
```

Это приведет к утечке, если `x` не будет положительным. Присвоение результата [[new|new]] “голому указателю” приводит к возникновению проблем.

Одним из простых решений таких проблем является использование умного указателя [[unique_ptr|unique_ptr]] стандартной библиотеки вместо “голого указателя”, когда требуется удаление:
```c++
class Smiley : public Circle {
	...

	private:
		vector<unique_ptr<Shape>> eyes; // usually two eyes
		unique_ptr<Shape> mouth;
};
```

Это пример простого, общего и эффективного метода [[Основные операции#Управление ресурсами|управления ресурсами]].

В качестве приятного побочного эффекта этого изменения нам больше не нужно определять деструктор для **`Smiley`**. Компилятор неявно сгенерирует тот, который выполняет требуемое уничтожение [[unique_ptr|unique_ptr]] в [[vector|vector]]. Код, использующий [[unique_ptr]], будет точно таким же эффективным, как и код, правильно использующий сырые указатели.

Теперь рассмотрим пользователей `read_shape()`:
```c++
// read shape descriptions from input stream
unique_ptr<Shape> read_shape(istream& is) 
is
{
	switch (k) {	// ... read shape header from is and find its Kind k ...
		case Kind::circle:
		// ... read circle data {Point,int} into p and r ...
		return unique_ptr<Shape>{new Circle{p,r}}; 
		// ...
	}
}

void user()
{
	vector<unique_ptr<Shape>> v;
	while (cin)
		v.push_back(read_shape(cin));
	
		draw_all(v); // call draw() for each element
		rotate_all(v,45); // call rotate(45) for each element
} // all Shapes implicitly destroyed
```

Теперь каждый объект принадлежит [[unique|unique_ptr]], который [[delete|delete]] объект, когда он
больше не понадобится, то есть когда соответствующий [[unique_ptr|unique_ptr]] выйдет за пределы области видимости.

Чтобы версия [[unique_ptr|unique_ptr]] функции user() работала, нам нужны версии [[draw_all|draw_all()]] и [[rotate#std rotate|rotate_all()]], которые принимают `vector<unique_ptr<Shape>>`. Написание многих таких `_all()` функций может стать утомительным, поэтому в [[Template_STL#Функциональные объекты|показана альтернатива]].
