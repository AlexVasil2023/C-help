# std::variant C++17#
Концепция “вариант” может показаться знакомой тем, кто имел дело с Visual Basic. Вариант – это типобезопасное объединение [[union|union]], которое в заданный момент времени содержит значение одного из альтернативных типов (причем, здесь не может быть ссылок, массивов или `'void'`).  
```c++
std::variant<int, double> v{ 12 };
std::get<int>(v); // == 12
std::get<0>(v); // == 12

v = 12.0;

std::get<double>(v); // == 12.0
std::get<1>(v); // == 12.0
```
Простой пример: допустим, есть некоторые данные, где возраст человека может быть представлен в виде целого числа или в виде строки с датой рождения. Можно представить такую информацию при помощи варианта, содержащего беззнаковое целое число или строку. Присваивая целое число переменной, мы задаем значение, а затем можем извлечь его при помощи [[get|std::get]], вот так:
```c++
std::variant<uint32_t, std::string> age;
age = 51; 

auto a = std::get<uint32_t>(age);
```
Если попытаться использовать член, который не задан таким образом, то программа выбросит исключение:
```c++
try { 	
	std::cout << std::get<std::string>(age) << std::endl;
}catch ( std::bad_variant_access &ex ) { 	
	std::cout << "Doesn't contain a string" << std::endl;
}
```
Зачем использовать `std::variant`, а не обычное объединение? В основном потому, что объединения присутствуют в языке прежде всего ради совместимости с C и не работают с объектами, не относящимися к POD-типам. Отсюда, в частности, следует, что в объединение не так-то просто поместить члены с копиями пользовательских конструкторов копирования и деструкторов. С `std::variant` таких ограничений нет.
