
[[#Конвейеры|Конвейеры]] 14.4 (STL)


# Конвейеры

Для каждого [[range#Представления|представления из стандартной библиотеки]] есть функция, которая создает фильтр; то есть объект, который может использоваться в качестве аргумента оператору фильтра `|`. Например, `filter()` возвращает [[filter_view|filter_view]]. Это позволяет нам комбинировать фильтры в конвейер, а не представлять их в виде набора вложенных вызовов функций.
```c++
void user(forward_range auto& r)
{
	auto odd = [](int x) { return x % 2; };
	for (int x : r | views::filter(odd) | views::take(3))
	cout << x <<' ';
}
```

Диапазон входных данных `2 4 6 8 20` дает значение `1 2 3`.

Конвейерный стиль (использующий оператор конвейера `Unix |`) широко считается более удобочитаемым, чем вызовы вложенных функций. Конвейер работает слева направо; то есть `f | g` результат `f` передается в `g`, поэтому `r | f | g` означает (`g_filter (f_filter (r) ) `). Начальное значение `r` должно быть диапазоном или генератором. 

Эти функции фильтрации находятся в пространство имён `ranges::views`:
```c++
void user(forward_range auto& r)
{
	for (int x : r | views::filter([](int x) { return x % 2; } ) | views::take(3) )
	cout << x <<' ';
}
```
Я нахожу, что использование `views`:: явно делает код вполне читабельным, но, конечно, мы можем еще больше улучшить код:
```c++
void user(forward_range auto& r)
{
	using namespace views;
	auto odd = [](int x) { return x % 2; };
	for (int x : r | filter(odd) | take(3) )
		cout << x <<' ';
}
```
Реализация представлений и конвейеров включает в себя довольно сложное метапрограммирование шаблонов, поэтому, если вы беспокоитесь о производительности, обязательно измерьте, обеспечивает ли ваша реализация то, что вам нужно. Если нет, то всегда есть обычный обходной путь:
```c++
void user(forward_range auto& r)
{
	int count = 0;
	for (int x : r)
		if (x % 2) {
			cout << x <<' ';
			
			if (++count == 3) return;
		}
}
```
Однако здесь логика происходящего затуманена.



