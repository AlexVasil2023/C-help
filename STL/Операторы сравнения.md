
# Операторы сравнения

Имеется ввиду сравнение на равенство (`==` и `!=`) тесно связано с копированием. После копирования копии должны проверяться на равенство:
```c++
X a = something;
X b = a;

assert(a==b);                  // if a!=b here, something is very odd
```

При определении `==` также определите `!=` и убедитесь, что `a!=b` означает `!(a==b)`.

Аналогично, если вы определяете `<`, также определите `<=`, `>`, `>=` чтобы убедиться, что выполняются обычные эквивалентности:
>
> `a<=b` равнозначно `(a<b)||(a==b)` и `!(b<a)`.
> 
> `a>b` равнозначно `b<a`.
> 
> `a>=b` равнозначно `(a>b)||(a==b)` и `!(a<b)`.

Чтобы обеспечить идентичную обработку обоих операндов бинарного оператора, такого как `==`, его лучше всего определить  как отдельную функцию в пространстве имен своего класса. Например:
```c++
namespace NX {
	class X {
		...
	};

	bool operator==(const X&, const X&);
	
	...
};
```

“Оператор космический корабль” `<=>` сам по себе является законом; его правила отличаются от правил для всех других операторов. В частности, при определении значения по умолчанию `<=>` неявно определяются другие операторы сравнения:
```c++
class R {
	...
	
	auto operator<=>(const R& a) const = default;
};

void user(R r1, R r2)
{
	bool b1 = (r1<=>r2) == 0; // r1==r2
	bool b2 = (r1<=>r2) < 0; // r1<r2
	bool b3 = (r1<=>r2) > 0; // r1>r2
	bool b4 = (r1==r2);
	bool b5 = (r1<r2);
}
```

Как и `strcmp()` в C, `<=>` реализует трехстороннее сравнение. Отрицательное возвращаемое значение означает меньше, `0` означает равно, а положительное значение означает больше.

Если `<=>` определено не как по умолчанию, то `==` неявно не определено, но `<` и другие операторы сравннения определены! Например:
```c++
struct R2 {
	int m;
	
	auto operator<=>(const R2& a) const 
	{ 
		return a.m == m ? 0 : a.m < m ? -1 : 1; 
	}
};
```

Здесь я использовал форму выражения оператора `if : p ? x : y` - это выражение, которое вычисляет условие `p`, и если оно истинно, то значение `?:` выражения равно `x`, в противном случае `y`.
```c++
void user(R2 r1, R2 r2)
{
	bool b4 = (r1==r2); // error: no non-default ==
	bool b5 = (r1<r2);  // OK
}
```

Это приводит к такому шаблону определения для нетривиальных типов:
```c++
struct R3 { /* ... */ };

auto operator<=>(const R3& a,const R3& b) { /* ... */ }
bool operator==(const R3& a, const R3& b) { /* ... */ }
```

Большинство типов стандартной библиотеки, таких как [[string|string]] и [[vector|vector]], следуют этому шаблону. Причина в том, что если тип имеет более одного элемента, участвующего в сравнении, по умолчанию `<=>` проверяет их по одному, получая лексикографический порядок. В таком случае часто имеет смысл дополнительно предоставить отдельный оптимизированный `==`, потому что `<=>` должен изучить все элементы, чтобы определить все три альтернативы. Рассмотрим сравнение символьных строк:
```c++
string s1 = "asdfghjkl";
string s2 = "asdfghjk";

bool b1 = s1==s2; // false
bool b2 = (s1<=>s2)==0; // false
```

Используя обычное `==`, мы обнаруживаем, что строки не равны, посмотрев на количество символов. Используя `<=>`, мы должны прочитать все символы `s2`, чтобы обнаружить, что оно меньше `s1` и, следовательно, не равно.

В операторе `<=>` есть еще много деталей, но они в первую очередь представляют интерес для продвинутых разработчиков библиотечных средств, занимающихся сравнениями и сортировкой, выходящими за рамки этой книги. Более старый код не использует `<=>`.
