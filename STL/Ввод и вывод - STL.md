
[[#Ввод и вывод|Ввод и вывод]] 11
1. [[stream#Введение|Введение]] 11.1
2. [[stream#std ostream|ostream]] 11.2
3. [[stream#std istream|istream]] 11.3
4. [[iostream#iostream|Состояния потоков I/O]] 11.4
5. [[iostream#I/O пользовательских типов|I/O пользовательских типов]] 11.5
6. [[#Форматирование вывода|Форматирование вывода]] 11.6
	1. [[format#Форматирование потока|Форматирование потока]] 11.6.1
	2. [[format#Форматирование в стиле printf()|Форматирование в стиле printf()]] 11.6.2
7. [[#Потоки|Потоки]] 11.7
	1. [[#Стандартные потоки|Стандартные потоки]] 11.7.1
	2. [[#Файловые потоки|Файловые потоки]] 11.7.2
	3. [[std/sstream#Строковые потоки|Строковые потоки]] 11.7.3
	4. [[#Потоки памяти|Потоки памяти]] 11.7.4
	5. [[#Синхронизированные потоки|Синхронизированные потоки]] 11.7.5
8. [[#I/O в стиле Си|I/O в стиле Си]] 11.8
9. [[#Файловая система|Файловая система]] 11.9
	1. [[path|Пути]] 11.9.1
	2. [[#Файлы и каталоги| Файлы и каталоги]] 11.9.2


# Ввод и вывод
# Введение

[[stream#Введение|Введение]] 11.1

# ostream

[[stream#std ostream|см. тут]]

# istream

[[stream#std istream|см. тут]]

# Состояния потоков I/O

[[iostream#iostream|см. тут]] 

# I/O пользовательских типов

 [[iostream#I/O пользовательских типов|I/см. тут]] 

# Форматирование вывода

Библиотеки [[iostream|iostream]] и [[format|format]] предоставляют операции для управления форматом ввода и вывода. Средства [[iostream|iostream]] примерно такие же старые, как C++, и ориентированы на форматирование потоков чисел. Средства [[format|format]] появились недавно (C++20) и ориентированы на форматирование комбинаций значений по спецификации в стиле `printf()`.

Форматирование выходных данных также обеспечивает поддержку unicode, но это выходит за рамки данной книги.

## Форматирование потока

[[format#Форматирование потока|см. тут]]

## Форматирование в стиле printf()

[[format#Форматирование в стиле printf()|см тут]]

# Потоки

Стандартная библиотека непосредственно поддерживает
>
> Стандартные потоки: потоки, подключенные к стандартным потокам ввода-вывода системы ( #§11_7_1)
> 
> Файловые потоки: потоки, прикрепленные к файлам ( #§11_7_2)
> 
> Строковые потоки: потоки, присоединенные к строкам ( #§11_7_3)
> 
> Потоки памяти: поток, привязанный к определенным областям памяти ( #§11_7_4)
> 
> Синхронизированные потоки: потоки, которые могут использоваться из нескольких потоков без скачков данных ( #§11_7_5)

Кроме того, мы можем определить наши собственные потоки, например, подключенные к каналам связи.

Потоки не могут быть скопированы; всегда передавайте их по ссылке.

Все потоки стандартной библиотеки являются шаблонами с типом символа в качестве параметра. Версии с названиями, которые я здесь использую, содержат `char`.

Например,[[stream#std ostream|ostream]] - это [[stream#basic_ostream|basic_ostream<char>]]. Для каждого такого потока стандартная библиотека также предоставляет версию для `wchar_t`. Например, `wostream` - это [[stream#basic_ostream|basic_ostream<wchar_t>]]. Потоки широких символов можно использовать для символов Юникода.

## Стандартные потоки

Стандартными потоками являются
>
> [[cout|cout]] для “обычного вывода”
> 
> [[cerr#std cerr|cerr]] для небуферизованного “вывода ошибки”
> 
> [[clog#std clog|clog]] буферизованного “вывода журнала”
> 
> [[cin#std cin|cin]] для стандартного ввода.

## Файловые потоки

В [[fstream|<fstream>]] стандартной библиотеки представлены потоки чтения и записи в файл:
>
> [[fstream#ifstream|ifstream]] для чтения из файла
> 
> [[fstream#ofstream|ofstream]] для записи в файл
> 
> [[fstream#fstream|fstream]] для чтения из файла и записи в него, например:

```c++
ofstream ofs {"target"};           // “o” for “output”
if (!ofs)
	error("couldn't open 'target' for writing");
```

Проверка правильности открытия файлового потока обычно выполняется путем проверки его состояния.
```c++
ifstream ifs {"source"}; // “i” for “input”

if (!ifs)
	error("couldn't open 'source' for reading");
```

Предполагая, что тесты прошли успешно, ofs можно использовать как обычный [[stream#std ostream|ostream]] (точно так же, как [[cout|cout]]), а [[ifs|ifs]] можно использовать как обычный [[stream#std istream|istream]] (точно так же, как [[cin|cin]]).

Навигация в файле и более детальное управление способом открытия файла возможны, но выходят за рамки данной книги.

О составлении имен файлов и манипуляциях с [[Ввод и вывод - STL#Файловая система|файловой системой]].

## Строковые потоки

[[std/sstream#Строковые потоки|см. тут]]

## Потоки памяти

С самых ранних дней C++ существовали потоки, привязанные к разделам памяти, указанным пользователем, так что мы могли читать/записывать непосредственно в них. Самые старые из таких потоков, `strstream`, устарели на протяжении десятилетий, но их замена, [[spanstream#spanstream| spanstream]], [[spanstream#ispanstream|ispanstream]] и [[spanstream#ospanstream|ospanstream]], станет официальной не ранее C++23. Однако они уже широко доступны; попробуйте свою реализацию или выполните поиск на GitHub.

[[spanstream#ospanstream|ospanstream]] ведет себя как [[std/sstream#stringstream|ostringstream]] и инициализируется аналогично ему, за исключением того, что [[spanstream#ospanstream|ospanstream]] принимает в качестве аргумента [[span|span]], а не [[string|string]]. Например:
```c++
void user(int arg)
{
	array<char,128> buf;
	ospanstream ss(buf);
	ss << "write " << arg << " to memory\n";
	...
}
```

Попытки переполнения целевого буфера приводят к [[iostream#iostream|failure]] (сбою) состояния строки.
Аналогично,[[spanstream#ispanstream| ispanstream]] подобен [[std/sstream#istringstream|istringstream]].

## Синхронизированные потоки

[[syncstream]]

# I/O в стиле Си

Стандартная библиотека C++ также поддерживает ввод-вывод стандартной библиотеки C, включая [[print#printf|printf()]] и [[scan#scanf]] Многие варианты использования этой библиотеки ненадёжны с точки зрения типо- и кибер-безопасности, поэтому я не рекомендую ее использовать. В частности, её может быть сложно использовать для безопасного и удобного ввода. Она не поддерживает пользовательские типы. Если вы не используете ввод-вывод в стиле C, и заботитесь о производительности ввода-вывода, вызовите
```c++
ios_base::sync_with_stdio(false); // avoid significant overhead
```

Без этого вызова стандартные потоки [[iostream#iostream|iostream]] (например, [[cin|cin]] и [[cout|cout]]) могут быть значительно замедлены, чтобы быть совместимыми с вводом-выводом в стиле C. Если вам нравится форматированный вывод в стиле [[print#printf|printf()]], используйте [[format|format]] ; он безопасен для ввода, прост в использовании, гибок и быстр.

# Файловая система

Большинство систем имеют описание файловой системы, обеспечивающее доступ к постоянной информации, хранящейся в виде файлов. К сожалению, свойства файловых систем и способы манипулирования ими сильно различаются. Чтобы справиться с этим, библиотека файловой системы в [[filesystem|<filesystem>]] предлагает единый интерфейс для большинства средств большинства файловых систем. Используя [[filesystem|<filesystem>]], мы можем переносимо
>
> определять пути в файловой системе и перемещаться по ней
> 
>  узнавать типы файлов и связанные с ними разрешения

Библиотека файловой системы может обрабатывать `Unicode`, но объяснение того, как это делается, выходит за рамки данной книги. Я рекомендую cppreference  и документацию по `Boost filesystem` для получения более подробной информации.

## Пути

[[path|см. Пути]] 

##  Файлы и каталоги

Естественно, файловая система предлагает множество операций, и естественно, что разные операционные системы предлагают разные наборы операций. Стандартная библиотека предлагает несколько вариантов, которые могут быть разумно реализованы в самых разных системах.

Операции с файловой системой (некоторые) p, p1, и p2 это [[path#Пути|path]]; `e` это `error_code`; `b` это `bool` показывающий успешное или ошибочное завершение операции

| `exists(p)`               | Ссылается ли p на существующий объект файловой системы?                                 |
| ------------------------- | --------------------------------------------------------------------------------------- |
| `copy(p1,p2)`             | Копирование файлов или каталогов из `p1` в `p2`; сообщает об ошибках исключениями       |
| `copy(p1,p2,e)`           | Копирование файлов или каталогов; сообщает об ошибках при помощи кодов ошибок           |
| `b=copy_file(p1,p2)`      | Копирование файлов из `p1` в `p2`; сообщает об ошибках исключениями                     |
| `b=create_directory(p)`   | Создать новый каталог с именем p; все промежуточные каталоги до `p` должны существовать |
| `b=create_directories(p)` | Создать новый каталог с именем p; создаёт все промежуточные каталоги до `p`             |
| `p=current_path()`        | `p` присваивается текущий рабочий каталог                                               |
| `current_path(p)`         | Сделать `p` текущим рабочим каталогом                                                   |
| `s=file_size(p)`          | `s` присваивается количество байт в `p`                                                 |
| `b=remove(p)`             | Удалить `p` если это файл или пустой каталог                                            |

Многие операции имеют перегрузки, которые требуют дополнительных аргументов, таких как разрешения операционной системы. Работа с ними выходит далеко за рамки данной книги, поэтому ознакомьтесь с ними, если они вам понадобятся.

Как и [[copy|copy()]], все операции выполняются в двух вариантах:
>
> Базовая версия, указанная в таблице, например, `exists(p)`. Функция бросит исключение `filesystem_error`, если операция завершилась неудачей.
> 
> Версия с дополнительным аргументом `error_code`, например, `exists(p,e)`. Проверьте `e`, чтобы убедиться, что операции выполнены успешно.

Мы используем коды ошибок, когда ожидается частый сбой операций при нормальном использовании, и операции с исключениями, когда ошибка считается редкой.

Часто использование функции запроса является самым простым и понятным подходом к изучению свойств файла. Библиотека `<filesystem>` знает о нескольких распространенных типах файлов и классифицирует остальные как “другие”:

Типы файлов `f` это [[path|path]] или `file_status`

| `is_block_file(f)`     | Является ли `f` блочным устройством?         |
| ---------------------- | -------------------------------------------- |
| `is_character_file(f)` | Является ли `f` символьным устройством?      |
| `is_directory(f)`      | Является ли `f` каталогом?                   |
| `is_empty(f)`          | Является ли `f` пустым файлом или каталогом? |
| `is_fifo(f)`           | Является ли `f` именованным каналом?         |
| `is_other(f)`          | Является ли `f` каким-то другим видом файла? |
| `is_regular_file(f)`   | Является ли `f` обычным (ординарным) файлом? |
| `is_socket(f)`         | Является ли `f` именованным IPC-сокетом?     |
| `is_symlink(f)`        | Является ли `f` символической ссылкой?       |
| `status_known(f)`      | Известен ли статус файла `f`?                |


