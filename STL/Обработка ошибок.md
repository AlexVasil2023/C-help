
[[#Обработка ошибок|Обработка ошибок]] 4
1. [[#Введение|Введение]] 4.1
2. [[#Исключения|Исключения]] 4.2
3. [[#Инварианты|Инварианты]] 4.3
4. [[#Альтернативные способы обработки ошибок|Альтернативные способы обработки ошибок]] 4.4
5. [[#Утверждения|Утверждения]] 4.5
	1. [[assert#assert|assert]] 4.5.1
	2. [[assert#static_assert()|static_assert()]] 4.5.2
	3. [[noexcept|noexcept]] 4.5.3

# Обработка ошибок

## Введение

Обработка ошибок - это большая и сложная тема с проблемами и ответвлениями, которые выходят далеко за рамки возможностей языка програмирования и касаются методов и инструментов программирования. Однако C++ предоставляет несколько полезных функций. Основным инструментом является сама система типов. Вместо того, чтобы кропотливо создавать наши приложения на основе встроенных типов (например, `char`, `int` или `double`) и операторов (например, [[if|if]], [[while|while]] и [[for|for]]), мы создаем типы (например, [[string|string]], [[map|map]] и [[thread|thread]]) и #алгоритмы (например, [[sort|sort()]], [[find#std find_if|find_if()]] и [[draw_all|draw_all()]]), которые подходят для наших приложений. Такие высокоуровневые конструкции упрощают наше программирование, ограничивают возможности для ошибок (например, вы вряд ли попытаетесь применить обход дерева к диалоговому окну) и увеличивают шансы компилятора на обнаружение ошибок. Большинство конструкций языка C++ предназначены для проектирования и реализации элегантных и эффективных абстракций (например, пользовательских типов и алгоритмов, использующих их). Одним из эффектов использования таких абстракций является то, что точка, в которой может быть обнаружена ошибка времени выполнения, отделена от точки, в которой она может быть обработана. По мере роста программ, и особенно при интенсивном использовании библиотек, стандарты обработки ошибок становятся важными. Это хорошая идея - сформулировать стратегию обработки ошибок на ранних стадиях разработки программы.

## Исключения

Рассмотрим еще раз пример `Vector`. Что следует делать, когда мы пытаемся получить доступ к элементу, который находится вне диапазона для вектора из [[Пользовательские типы#Классы|см. . . .]]?
>
> Автор `Vector` не знает, что пользователь хотел бы сделать в этом случае (автор `Vector` обычно даже не знает, в какой программе будет работать `Vector`).
> 
> Пользователь `Vector` не может последовательно обнаружить проблему (если бы пользователь мог, доступ за пределы диапазона не произошел бы в первую очередь)

Предполагая, что доступ за пределы диапазона - это своего рода ошибка, от которой мы хотим избавиться, решение заключается в том, чтобы разработчик `Vector` обнаружил попытку доступа за пределы диапазона и сообщил об этом пользователю. Затем пользователь может предпринять соответствующие действия. Например, `Vector::operator[]()` может обнаружить попытку доступа вне диапазона и выдать исключение `out_of_range`:
```c++
double& Vector::operator[](int i)
{
	if (!(0<i && i<size()))
		throw out_of_range{"Vector::operator[]"};
	
	return elem[i];
}
```

`throw` передает управление обработчику исключений типа `out_of_range` в некоторой функции, которая прямо или косвенно вызывает `Vector::operator[]()`. Чтобы сделать это, реализация разворачивает стек вызовов функций по мере необходимости, чтобы вернуться к контексту вызывающего объекта. То есть механизм обработки исключений будет выходить из областей видимости и функций по мере необходимости, чтобы вернуться к вызывающей стороне, которая выразила заинтересованность в обработке такого рода исключений, вызывая деструкторы по мере необходимости. Например:
```c++
void f(Vector& v)
{
	...
	
	try {           // out_of_range exceptions thrown in this block 
					//are handled by the handler defined below
		compute1(v); // might try to access beyond the end of v
		Vector v2 = compute2(v); // might try to access beyond the end of v
		compute3(v2); // might try to access beyond the end of v2
	}
	catch (const out_of_range& err) { // oops: out_of_range error
		...                           // handle range error ...
		
		cerr << err.what() << '\n';
	}

	...
}
```

Мы помещаем код, для которого нас интересует обработка исключений, в блок `try`. Вызовы `compute1()`, `compute2()`, и `compute3()` предназначены для представления кода, для которого сложно заранее определить, произойдет ли ошибка диапазона. Предложение `catch` предоставляется для обработки исключений типа `out_of_range`. Если бы `f()` не был подходящим местом для обработки таких исключений, мы бы не использовали блок `try`, а вместо этого позволили исключению неявно передаваться вызывающему `f`.

Тип `out_of_range` определен в стандартной библиотеке (в `<stdexcept>`) и фактически ис
пользуется некоторыми функциями доступа к контейнерам стандартной библиотеки.

Я перехватил исключение по ссылке, чтобы избежать копирования, и использовал функцию `what()`, чтобы вывести сообщение об ошибке, полученное в момент `throw`.

Использование механизмов обработки исключений может сделать обработку ошибок более простой, систематизированной и читабельной. Чтобы достичь этого, не злоупотребляйте операторами `try`. Во многих программах обычно существуют десятки вызовов функций между `throw` и функцией, которая может разумно обработать выданное исключение. Таким образом, большинство функций должны просто разрешать распространение исключения вверх по стеку вызовов. Основной метод, позволяющий упростить и систематизировать обработку ошибок (называемый получением ресурсов при инициализации; RAII),. Основная идея RAII заключается в том, чтобы конструктор получал ресурсы, необходимые для работы класса, а деструктор освобождал все полученные ресурсы, таким образом делая освобождение ресурсов гарантированным и неявным.

## Инварианты

Использование исключений для сигнализации о доступе за пределы диапазона является примером того, как функция проверяет свой аргумент и отказывается работать, когда не выполняется предусловие. Если бы мы формально указали оператор индекса `Vector`, мы бы сказали что-то вроде “индекс должен находиться в диапазоне `[0 : size())”`, и это было фактически то, что мы проверили в нашем `operator[]()`. Обозначение `[a:b)` обозначает полуоткрытый диапазон, в котором `a` является частью диапазона, а `b` - нет. Всякий раз, когда мы определяем функцию, мы должны учитывать, каковы ее предварительные условия, и решить, стоит ли их проверять ( #§4_4). Для большинства приложений хорошей идеей является проверка простых инвариантов; см. также #§4_5.

Однако `operator[]()` работает с объектами типа `Vector`, и ничто из того, что он делает, не имеет смысла, если члены `Vector` не имеют “разумных” значений. В частности, мы действительно сказали `“ elem указывает на массив из sz элементов типа double”`, но мы сказали это только в комментарии. Такое утверждение о том, что предполагается истинным для класса, называется инвариантом класса, или просто инвариантом. Задача конструктора - установить инвариант для своего класса (чтобы функции-члены могли полагаться на него), а функций-членов - гарантировать, что инвариант сохраняется при выходе. К сожалению, наш конструктор `Vector` лишь частично выполнил свою работу. Он правильно инициализировал элементы `Vector`, но не смог проверить, что переданные ему аргументы имеют смысл. Рассмотрим:
```c++
Vector v(-27);
```

Это, вероятно, вызовет хаос.

Вот более подходящее определение:
```c++
Vector::Vector(int s)
{
	if (s<0)
		throw length_error{"Vector constructor: negative size"};
		
	elem = new double[s];
	sz = s;
}
```

Я использую исключение стандартной библиотеки `length_error` для сообщения об отрицательном количестве элементов, потому что некоторые операции стандартной библиотеки используют это исключение для сообщения о проблемах такого рода. Если operator [[new|new]] не может выделить необходимую память, он бросает исключение `std::bad_alloc`. Теперь мы можем написать:
```c++
void test(int n)
{
	try {
		Vector v(n);
	}
	catch (std::length_error& err) {
		... //handle negative size ...
	}
	catch (std::bad_alloc& err) {
		... //handle memory exhaustion ...
	}
}

void run()
{
	test(-27);            // throws length_error (-27 is too small)
	test(1 000 000 000);  // may throw bad_alloc
	test(10);             // likely OK
}
```

Исчерпание памяти происходит, если вы запрашиваете больше памяти, чем предлагает компьютер, или если ваша программа уже почти потребила лимит, и ваш запрос превышает лимит. Обратите внимание, что современные операционные системы обычно предоставляют вам больше места, чем поместится в физической памяти, поэтому запрос слишком большого объема памяти может привести к серьезному замедлению работы задолго до запуска `bad_alloc`.

Вы можете определить свои собственные классы для использования в качестве исключений и сделать так, чтобы они несли столько информации, сколько вам нужно, от момента обнаружения ошибки до момента, когда она может быть обработана. Нет необходимости использовать иерархию исключений стандартной библиотеки. 

Часто функция не имеет возможности выполнить назначенную ей задачу после возникновения исключения. Затем “обработка” исключения означает выполнение некоторой минимальной локальной очистки и повторное создание исключения. Например:
```c++
void test(int n)
{
	try {
		Vector v(n);
	}
	catch (std::length_error&) { // do something and rethrow
		cerr << "test failed: length error\n";
		throw; // rethrow
	}
	catch (std::bad_alloc&) {   // ouch! this program is not designed to
								// handle memory exhaustion
		std::terminate();       // terminate the program
	}
}
```

В хорошо продуманном коде блоки `try` встречаются редко. Избегайте чрезмерного использования, систематически используйте RAII.

Понятие инвариантов занимает центральное место при проектировании классов, а предварительные условия играют аналогичную роль при проектировании функций:
>
> Формулировка инвариантов помогает нам точнее понять, чего мы хотим.
> 
> Инварианты вынуждают нас быть конкретными; это дает нам больше шансов написать корректный код

Понятие инвариантов лежит в основе представлений C++ об управлении ресурсами, [[Классы|поддерживаемых конструкторами и деструкторами]].

## Альтернативные способы обработки ошибок

Обработка ошибок является серьезной проблемой во всех реальных программах, поэтому, естественно, существует множество подходов. Если обнаружена ошибка, и она не может быть обработана локально в функции, функция должна каким-то образом сообщить о проблеме какому-либо вызывающему объекту. Создание исключения это главный механизм в C++ для этого.

Существуют языки, в которых исключения предназначены просто для того, чтобы обеспечить альтернативный механизм возврата значений. C++ не является таким языком: исключения предназначены для сообщения о невозможности выполнения данной задачи. Исключения интегрированы с конструкторами и деструкторами, чтобы обеспечить согласованную структуру для обработки ошибок и [[Основные операции#Управление ресурсами|управления ресурсами]]. Компиляторы оптимизированы таким образом, чтобы сделать возврат значения намного дешевле, чем выбрасывание того же значения в качестве исключения.

Создание исключения - не единственный способ сообщить об ошибке, которая не может быть обработана локально. Функция может указать на то, что она не может выполнить возложенную на нее задачу с помощью:
>
> выбрасывания исключения
> 
> возвращения значения, указывающего на ошибку
> 
> завершения работы программы (путем вызова такой функции, как [[terminate|terminate()]], `exit()` или `abort()` ( #§16_8)).

Мы возвращаем индикатор ошибки (“код ошибки”), когда:
>
> Сбой является нормальным и ожидаемым. Например, вполне нормально, что запрос на открытие файла завершается ошибкой (возможно, файла с таким именем не существует или, возможно, файл не может быть открыт с запрошенными правами доступа)
> 
> Ожидается, что непосредственный вызывающий справится с обработкой ошибки.
> 
> Произошла ошибка в одной из множества параллельных задач, и нам нужно знать, какая задача завершилась неудачей.
> 
> В системе так мало памяти, что поддержка исключений во время выполнения вытеснила бы необходимую функциональность.

Мы используем исключение, когда:
>
> Ошибка настолько редка, что программист, скорее всего, забудет ее проверить. Например, когда вы в последний раз проверяли возвращаемое значение printf()?
> 
> Ошибка не может быть обработана непосредственно вызывающей функцией. Вместо этого ошибка должна распространяться обратно по цепочке вызовов к “конечному вызывающему”. Например, невозможно, чтобы каждая функция в приложении надежно обрабатывала каждый сбой аллокации и отключение сети. Повторная проверка кода ошибки была бы утомительной, дорогостоящей и подверженной ошибкам. Тесты на наличие ошибок и передача кодов ошибок в качестве возвращаемых значений могут легко затенить основную логику функции.
> 
> В нижестоящие модули приложения могут быть добавлены новые виды ошибок, так что модули более высокого уровня не будут написаны для устранения таких ошибок. Например, когда ранее однопоточное приложение модифицируется для использования нескольких потоков, или ресурсы размещаются удаленно для доступа по сети.
> 
> Не доступен подходящий путь возврата для кодов ошибок. Например, у конструктора нет возвращаемого значения для проверки “вызывающим”. В частности, конструкторы могут быть вызваны для нескольких локальных переменных или в частично сконструированном сложном объекте, так что очистка на основе кодов ошибок была бы довольно сложной. Аналогично, операторы обычно не имеют очевидного пути возврата для кодов ошибок. Например, `a*b+c/d`.
> 
> Путь возврата функции усложняется или удорожается из-за необходимости передавать обратно как значение, так и индикатор ошибки (например, [[pair|pair]]; #§15_3_3), что может привести к использованию внешних параметров, нелокальных индикаторов состояния ошибки или других обходных путей.
> 
> Восстановление после ошибок зависит от результатов нескольких вызовов функций, что приводит к необходимости поддерживать локальное состояние между вызовами и сложным управляющим структурам.
> 
> Функция, обнаружившая ошибку, была обратным вызовом `callback` (функциональный аргумент), поэтому непосредственный вызывающий может даже не знать, какая функция была вызвана.
> 
> Ошибка подразумевает, что требуется какое-то “отмены действий”

Мы прекращаем работу программы, когда:
>
> Восстановление после ошибки такого рода невозможно. Например, для многих – но не для всех систем не существует разумного способа восстановления после исчерпания памяти.
> 
> В системах, в которых обработка ошибок основана на перезапуске потока, процесса или компьютера при обнаружении нетривиальной ошибки.

Один из способов обеспечить завершение работы приложения - добавить [[noexcept|noexcept]] к функции, чтобы `throw` из любого места реализации функции превращался в [[terminate|terminate().]] Обратите внимание, что существуют приложения, для которые безусловное завершение программы не приемлемо, поэтому необходимо использовать альтернативные варианты. Библиотека, предназначенная для общего использования никогда не должна завершаться без сообщений об ошибках.

К сожалению, эти условия не всегда логически разделимы и просты в применении. Имеют значение размер и сложность программы. Иногда по мере развития приложения приоритеты и компромиссы меняются. Требуется опыт для принятия верных решений. Если вы сомневаетесь, отдавайте предпочтение исключениям, потому что их использование лучше масштабируется и не требует внешних инструментов для про-
верки того, что все ошибки обработаны.

Не верьте, что все коды ошибок или все исключения являются плохими; есть очевидное применение и тому, и другому. Кроме того, не верьте мифу о том, что обработка  исключений происходит медленно; зачастую она быстрее, чем правильная обработка сложных или редких ошибок и повторных проверок кодов ошибок.

RAII необходим для [[Основные операции#Управление ресурсами|простой и эффективной обработки ошибок с использованием исключений]]. Код, усеянный блоками `try`, часто просто отражает худшие аспекты стратегий обработки ошибок, разработанных для кодов ошибок.

## Утверждения

В настоящее время не существует общего и стандартного способа написания дополнительных тестов времени выполнения для инвариантов, предусловий и т.д. Однако для многих крупных программ существует необходимость в поддержке пользователей, которые хотят полагаться на обширные `run-time` проверки во время тестирования, но затем развертывать код с минимальными проверками.

Пока нам приходится полагаться на специальные механизмы. Таких механизмов существует множество. Они должны быть гибкими, общими и не предполагать никаких затрат, если они не включены. Это подразумевает простоту концепции и изощренность в реализации. Вот схема, которую я использовал:
```c++
// error-handling alternatives
enum class Error_action { ignore, throwing, terminating, logging }; 

// a default
constexpr Error_action default_Error_action = Error_action::throwing; 

// individual errors
enum class Error_code { range_error, length_error }; 

// names of individual errors
string error_code_name[] { "range error", "length error" }; 

template<Error_action action = default_Error_action, class C>
constexpr void expect(C cond, Error_code x) 
			// take "action" if the expected condition "cond" doesn't hold
{
	if constexpr (action == Error_action::logging)
		if (!cond()) std::cerr << "expect() failure: " << int(x) << '' 
								<< error_code_name[int(x)] << '\n';
	
	if constexpr (action == Error_action::throwing)
		if (!cond()) 
			throw x;
			
	if constexpr (action == Error_action::terminating)
		if (!cond()) 
			terminate();
	
	// or no action
}
```

На первый взгляд это может показаться ошеломляющим, поскольку многие используемые языковые функции еще не представлены. Однако, по мере необходимости, он одновременно очень гибок и тривиален в использовании. Например:
```c++
double& Vector::operator[](int i)
{
	expect([i,this] { return 0<=i && i<size(); }, Error_code::range_error);

	return elem[i];
}
```

Здесь проверяется, находится ли индекс в диапазоне, и выполняет действие по умолчанию, вызывая исключение, если это не так. Ожидаемое выполнение условия, `0 <= i && i < size()`, передается в `expect()` как лямбда-выражение, `[i,this]{return 0<=i && i<size();}` ( #§7_3_3). Проверка `if constexpr` выполняется во время компиляции ( #§7_4_3), поэтому для каждого вызова `expect()` выполняется не более одного теста во время выполнения. Установите `action` в значение `Error_action::ignore`, и никаких действий не будет предпринято, и никакой код не будет сгенерирован для `expect()`.

Установив `default_Error_action`, пользователь может выбрать действие, подходящее для конкретного развертывания программы, например, завершение работы `terminating` или ведение журнала `logging`. Для поддержки логирования необходимо определить таблицу `error_code_name`. Информация о протоколировании может быть улучшена с помощью `source_location` ( #§16_5).

Во многих системах важно, чтобы механизм утверждений, такой как `expect()`, предоставлял единую точку контроля значений проверки утверждений. Поиск в большой базе кода из инструкций [[if|if]], которые на самом деле являются проверками предположений, обычно непрактичен.

### assert

[[assert#assert|см. assert]] 

### static_assert()

[[assert#static_assert()|см. static_assert()]] 

### noexcept

[[noexcept|см. noexcept]]
