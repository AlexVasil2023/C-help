
1. [[#Введение|Введение]] 12.1
2. [[vector#std vector|Вектор (std::vector)]] 12.2
	1. [[vector#Элементы|Элементы]] 12.2.1
	2. [[vector#Проверка диапазона|Проверка диапазона]] 12.2.2
3. [[list#std list]] 12.3
4. [[list#forward_list|forward_list]] 12.4
5. [[map#std map|std::Map]] 12.5
6. [[map#unordered_map|unordered_map]] 12.6
7. [[allocator#std allocator|Аллокаторы]]  12.7
8. [[#Обзор контейнеров|Обзор контейнеров]] 12.8
9. 
10. 

# Введение

Большая часть вычислений включает в себя создание коллекций значений и последующее манипулирование такими коллекциями. Простой пример это чтение символов в [[string|string]] и вывод [[string|string]]. Класс, основной целью которого является хранение объектов, обычно называется контейнером. Предоставление подходящих контейнеров для данной задачи и поддержка контейнеров полезными базовыми операциями являются важными шагами при построении любой программы.

Чтобы проиллюстрировать контейнеры стандартной библиотеки, рассмотрим простую программу для хранения имен и телефонных номеров. Это та разновидность программ, для которой различные подходы кажутся “простыми и очевидными” для людей с разным опытом. [[iostream#I/O пользовательских типов|Класс Entry]] можно использовать для хранения простой записи в телефонной книге. Здесь мы намеренно игнорируем многие сложности реального мира, такие как тот факт, что многие телефонные номера не имеют простого представления в виде 32-битного `int`.

# std::vector

[[vector]]

## Элементы

[[vector#Элементы|см. Элементы]]

## Проверка диапазона

[[vector#Проверка диапазона|см. Проверка диапазона]]

# list

[[list#std list|см. list]]

# forward_list

[[list#forward_list|см. forward_list]] 

# std::map 

[[map#std mapсм. |std::Map]] 12.5

# unordered_map

[[map#unordered_map|см. unordered_map]] 


# Аллокаторы

[[allocator#std allocator|Аллокаторы]] 

# Обзор контейнеров

Стандартная библиотека предоставляет некоторые из наиболее общих и полезных типов контейнеров, позволяющих программисту выбрать контейнер, который наилучшим образом соответствует потребностям приложения:

**Краткое описание стандартных контейнеров**

| [[vector\|vector<T>]]                                        | Динамический массив                               |
| ------------------------------------------------------------ | ------------------------------------------------- |
| [[list\|list<T>]]                                            | Двусвязный список                                 |
| [[list#forward_list\|forward_list<T>]]                       | Односвязный список                                |
| [[deque\|deque<T>]]                                          | Двусторонняя очередь                              |
| [[map\|map<K,V>]]                                            | Ассоциативный массив                              |
| [[multimap\|multimap<K,V>]]                                  | Карта, в которой ключ может встречаться много раз |
| [[map#unordered_map\|unordered_map<K,V>]]                    | Карта, использующая поиск на основе хэша          |
| [[multimap#std unordered_multimap\|unordered_multimap<K,V>]] | Multimap с использованием поиска на основе хэша   |
| [[set\|set<T>]]                                              | Набор (карта только с ключом и без значения)      |
| [[multiset\|multiset<T>]]                                    | Набор, в котором ключ может встречаться много раз |
| [[set#std unordered_set<>\|unordered_set<T>]]                | Набор, использующий поиск на основе хэша          |
| [[multiset#unordered_multiset]]                              | Multiset, использующий поиск на основе хэша       |

Неупорядоченные контейнеры оптимизированы для поиска по ключу (часто в виде строки); другими словами, они являются хэш-таблицами.

Контейнеры определены в пространстве имен `std` и представлены в заголовках `<vector>`, `<list>`, `<map>` и т.д.. Кроме того, стандартная библиотека предоставляет адаптеры контейнеров [[queue|queue<T>]], [[stack|stack<T>]] и [[queue#priority_queue|priority_queue<T>]]. Изучите их, если они вам понадобятся. Стандартная библиотека также предоставляет более специализированные типы, подобные контейнерам, такие как [[Array|array<T,N>]] и [[bitset|bitset<N>]].

Стандартные контейнеры и их основные операции спроектированы таким образом, чтобы быть похожими с точки зрения обозначения. Кроме того, смысл операций эквивалентен для различных контейнеров. Основные операции применимы ко всем типам контейнеров, для которых они имеют смысл и могут быть эффективно реализованы:

Операции стандартных контейнеров (некоторые)

| value_type          | Тип элемента                                                                                                                                                                                                                                                          |
| ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `p=c.begin()`       | p указывает на первый элемент в `c`; также [[cbegin\|cbegin()]] для [[const\|const]] итератора                                                                                                                                                                        |
| `p=c.end()`         | p указывает на элемент следующий за последним в `c`;<br>также [[cend\|cend()]] для [[const\|const]] итератора                                                                                                                                                         |
| `k=c.size()`        | `k` равно количеству элементов в `c`                                                                                                                                                                                                                                  |
| `c.empty()`         | Пуст ли `c` ?                                                                                                                                                                                                                                                         |
| `k=c.capacity()`    | `k` это количество элементов которое c может хранить без новой аллокации                                                                                                                                                                                              |
| `c.reserve(k)`      | Увеличивает ёмкость до `k`; если `k<=c.capacity()`, `c.reserve(k)` ничего не делает                                                                                                                                                                                   |
| `c.resize(k)`       | Устанавливает количество элементов `k`;<br>добавленные элементы имеют значение по умолчанию `value_type{}`                                                                                                                                                            |
| `c[k]`              | `k`-й элемент в `c`; индекс первого элемента 0; без гарантий проверки диапазона                                                                                                                                                                                       |
| `c.at(k)`           | `k`-й элемент в `c`; если выходит за диапазон, бросает исключение `out_of_range`                                                                                                                                                                                      |
| `c.push_back(x)`    | Добавить `x` в конец `c`; увеличивает размер c на единицу                                                                                                                                                                                                             |
| `c.emplace_back(a)` | Добавить `value_type{a}` в конец c; увеличивает размер` c` на единицу                                                                                                                                                                                                 |
| `q=c.insert(p,x)`   | Вставить `x` перед `p` в `c`                                                                                                                                                                                                                                          |
| `q=c.erase(p)`      | Удаляет элемент с индексом` p` из `c`                                                                                                                                                                                                                                 |
| `c=c2`              | Присвоение: копирует все элементы из `c2` для получения `c==c2`                                                                                                                                                                                                       |
| `b=(c==c2)`         | Равенство всех элементов `c` и `c2`; `b==true` если элементы равны                                                                                                                                                                                                    |
| `x=(c<=>c2)`        | Равенство всех элементов `c` и `c2`; `b==true` если элементы равны `x=(c<=>c2)` Лексикографическое сравнение `c` и `c2`: `x<0` если `c` меньше чем `c2`, `x==0` если они равны, и `0<x` если `c` больше чем `c2`.<br>`!=`, `<`, `<=`, `>` и `>=` производные от `<=>` |

Такое нотационное и семантическое единообразие позволяет программистам создавать новые типы контейнеров, которые могут использоваться очень похожим образом на стандартные. Например вектор с проверкой границ диапазона, [[Обработка ошибок#Инварианты|Vector]]. Единообразие интерфейсов контейнеров позволяет нам определять алгоритмы независимо от отдельных типов контейнеров. Однако у каждого из них есть свои сильные и слабые стороны. Например, оператор индекса и перемещение по [[vector|vector]] дешево и просто. С другой стороны, элементы [[vector|vector]] переаллоцируются, когда мы вставляем или удаляем элементы; [[list|list]] обладает прямо противоположными свойствами. Пожалуйста, обратите внимание, что [[vector|vector]] обычно более эффективен, чем [[list|list]], для коротких последовательностей небольших элементов (даже для `insert()` и `erase()`). Я рекомендую [[vector|vector]] стандартной библиотеки в качестве типа по умолчанию для последовательностей элементов: вам нужна веская причина, чтобы выбрать другой.

Рассмотрим односвязный список [[list#forward_list|forward_list]], контейнер, оптимизированный для пустой последовательности. Пустой [[list#forward_list|forward_list]] занимает всего одно слово (размер указателя в 32-разрядной системе), в то время как пустой [[vector|vector]] занимает три. Пустые последовательности и последовательности, содержащие только один или два элемента, на удивление распространены и полезны.

Операция размещения, такая как [[emplace_back|emplace_back()]], принимает аргументы для конструктора элемента и создает объект во вновь выделенном пространстве в контейнере, вместо копирования объекта в контейнер. Например, для `vector<pair<int,string>>` мы могли бы написать:
```c++
// make a pair and move it into v
v.push_back(pair{1,"copy or move"}); 

// build a pair in v
v.emplace_back(1,"build in place"); 
```

Для простых примеров, подобных этому, оптимизация может привести к эквивалентной производительности для обоих вызовов.



