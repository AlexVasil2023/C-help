
1. [[#Введение|Введение]] 12.1
2. [[vector#std vector|Вектор (std::vector)]] 12.2
	1. [[vector#Элементы|Элементы]] 12.2.1
	2. [[vector#Проверка диапазона|Проверка диапазона]] 12.2.2
3. [[list#std list]] 12.3
4. [[list#forward_list|forward_list]] 12.4
5. [[map#std map|std::Map]] 12.5
6. [[map#unordered_map|unordered_map]] 12.6
7. [[allocator#std allocator|Аллокаторы]]  12.7
8. [[#Обзор контейнеров|Обзор контейнеров]] 12.8
9. [[#Контейнер C++11|Контейнер C++11]]
	1. [[#Требования контейнеров|Требования контейнеров]]
10. [[#Контейнеры|Контейнеры]] 15.3(STL)
11. 

# Введение

Большая часть вычислений включает в себя создание коллекций значений и последующее манипулирование такими коллекциями. Простой пример это чтение символов в [[string|string]] и вывод [[string|string]]. Класс, основной целью которого является хранение объектов, обычно называется контейнером. Предоставление подходящих контейнеров для данной задачи и поддержка контейнеров полезными базовыми операциями являются важными шагами при построении любой программы.

Чтобы проиллюстрировать контейнеры стандартной библиотеки, рассмотрим простую программу для хранения имен и телефонных номеров. Это та разновидность программ, для которой различные подходы кажутся “простыми и очевидными” для людей с разным опытом. [[iostream#I/O пользовательских типов|Класс Entry]] можно использовать для хранения простой записи в телефонной книге. Здесь мы намеренно игнорируем многие сложности реального мира, такие как тот факт, что многие телефонные номера не имеют простого представления в виде 32-битного `int`.

# std::vector

[[vector]]

## Элементы

[[vector#Элементы|см. Элементы]]

## Проверка диапазона

[[vector#Проверка диапазона|см. Проверка диапазона]]

# list

[[list#std list|см. list]]

# forward_list

[[list#forward_list|см. forward_list]] 

# std::map 

[[map#std mapсм. |std::Map]] 12.5

# unordered_map

[[map#unordered_map|см. unordered_map]] 


# Аллокаторы

[[allocator#std allocator|Аллокаторы]] 

# Обзор контейнеров

Стандартная библиотека предоставляет некоторые из наиболее общих и полезных типов контейнеров, позволяющих программисту выбрать контейнер, который наилучшим образом соответствует потребностям приложения:

**Краткое описание стандартных контейнеров**

| [[vector\|vector<T>]]                                        | Динамический массив                               |
| ------------------------------------------------------------ | ------------------------------------------------- |
| [[list\|list<T>]]                                            | Двусвязный список                                 |
| [[list#forward_list\|forward_list<T>]]                       | Односвязный список                                |
| [[deque\|deque<T>]]                                          | Двусторонняя очередь                              |
| [[map\|map<K,V>]]                                            | Ассоциативный массив                              |
| [[multimap\|multimap<K,V>]]                                  | Карта, в которой ключ может встречаться много раз |
| [[map#unordered_map\|unordered_map<K,V>]]                    | Карта, использующая поиск на основе хэша          |
| [[multimap#std unordered_multimap\|unordered_multimap<K,V>]] | Multimap с использованием поиска на основе хэша   |
| [[set\|set<T>]]                                              | Набор (карта только с ключом и без значения)      |
| [[multiset\|multiset<T>]]                                    | Набор, в котором ключ может встречаться много раз |
| [[set#std unordered_set<>\|unordered_set<T>]]                | Набор, использующий поиск на основе хэша          |
| [[multiset#unordered_multiset]]                              | Multiset, использующий поиск на основе хэша       |

Неупорядоченные контейнеры оптимизированы для поиска по ключу (часто в виде строки); другими словами, они являются хэш-таблицами.

Контейнеры определены в пространстве имен `std` и представлены в заголовках `<vector>`, `<list>`, `<map>` и т.д.. Кроме того, стандартная библиотека предоставляет адаптеры контейнеров [[queue|queue<T>]], [[stack|stack<T>]] и [[queue#priority_queue|priority_queue<T>]]. Изучите их, если они вам понадобятся. Стандартная библиотека также предоставляет более специализированные типы, подобные контейнерам, такие как [[Array|array<T,N>]] и [[bitset|bitset<N>]].

Стандартные контейнеры и их основные операции спроектированы таким образом, чтобы быть похожими с точки зрения обозначения. Кроме того, смысл операций эквивалентен для различных контейнеров. Основные операции применимы ко всем типам контейнеров, для которых они имеют смысл и могут быть эффективно реализованы:

Операции стандартных контейнеров (некоторые)

| value_type          | Тип элемента                                                                                                                                                                                                                                                          |
| ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `p=c.begin()`       | p указывает на первый элемент в `c`; также [[cbegin\|cbegin()]] для [[const\|const]] итератора                                                                                                                                                                        |
| `p=c.end()`         | p указывает на элемент следующий за последним в `c`;<br>также [[cend\|cend()]] для [[const\|const]] итератора                                                                                                                                                         |
| `k=c.size()`        | `k` равно количеству элементов в `c`                                                                                                                                                                                                                                  |
| `c.empty()`         | Пуст ли `c` ?                                                                                                                                                                                                                                                         |
| `k=c.capacity()`    | `k` это количество элементов которое c может хранить без новой аллокации                                                                                                                                                                                              |
| `c.reserve(k)`      | Увеличивает ёмкость до `k`; если `k<=c.capacity()`, `c.reserve(k)` ничего не делает                                                                                                                                                                                   |
| `c.resize(k)`       | Устанавливает количество элементов `k`;<br>добавленные элементы имеют значение по умолчанию `value_type{}`                                                                                                                                                            |
| `c[k]`              | `k`-й элемент в `c`; индекс первого элемента 0; без гарантий проверки диапазона                                                                                                                                                                                       |
| `c.at(k)`           | `k`-й элемент в `c`; если выходит за диапазон, бросает исключение `out_of_range`                                                                                                                                                                                      |
| `c.push_back(x)`    | Добавить `x` в конец `c`; увеличивает размер c на единицу                                                                                                                                                                                                             |
| `c.emplace_back(a)` | Добавить `value_type{a}` в конец c; увеличивает размер` c` на единицу                                                                                                                                                                                                 |
| `q=c.insert(p,x)`   | Вставить `x` перед `p` в `c`                                                                                                                                                                                                                                          |
| `q=c.erase(p)`      | Удаляет элемент с индексом` p` из `c`                                                                                                                                                                                                                                 |
| `c=c2`              | Присвоение: копирует все элементы из `c2` для получения `c==c2`                                                                                                                                                                                                       |
| `b=(c==c2)`         | Равенство всех элементов `c` и `c2`; `b==true` если элементы равны                                                                                                                                                                                                    |
| `x=(c<=>c2)`        | Равенство всех элементов `c` и `c2`; `b==true` если элементы равны `x=(c<=>c2)` Лексикографическое сравнение `c` и `c2`: `x<0` если `c` меньше чем `c2`, `x==0` если они равны, и `0<x` если `c` больше чем `c2`.<br>`!=`, `<`, `<=`, `>` и `>=` производные от `<=>` |

Такое нотационное и семантическое единообразие позволяет программистам создавать новые типы контейнеров, которые могут использоваться очень похожим образом на стандартные. Например вектор с проверкой границ диапазона, [[Обработка ошибок#Инварианты|Vector]]. Единообразие интерфейсов контейнеров позволяет нам определять алгоритмы независимо от отдельных типов контейнеров. Однако у каждого из них есть свои сильные и слабые стороны. Например, оператор индекса и перемещение по [[vector|vector]] дешево и просто. С другой стороны, элементы [[vector|vector]] переаллоцируются, когда мы вставляем или удаляем элементы; [[list|list]] обладает прямо противоположными свойствами. Пожалуйста, обратите внимание, что [[vector|vector]] обычно более эффективен, чем [[list|list]], для коротких последовательностей небольших элементов (даже для `insert()` и `erase()`). Я рекомендую [[vector|vector]] стандартной библиотеки в качестве типа по умолчанию для последовательностей элементов: вам нужна веская причина, чтобы выбрать другой.

Рассмотрим односвязный список [[list#forward_list|forward_list]], контейнер, оптимизированный для пустой последовательности. Пустой [[list#forward_list|forward_list]] занимает всего одно слово (размер указателя в 32-разрядной системе), в то время как пустой [[vector|vector]] занимает три. Пустые последовательности и последовательности, содержащие только один или два элемента, на удивление распространены и полезны.

Операция размещения, такая как [[emplace_back|emplace_back()]], принимает аргументы для конструктора элемента и создает объект во вновь выделенном пространстве в контейнере, вместо копирования объекта в контейнер. Например, для `vector<pair<int,string>>` мы могли бы написать:
```c++
// make a pair and move it into v
v.push_back(pair{1,"copy or move"}); 

// build a pair in v
v.emplace_back(1,"build in place"); 
```

Для простых примеров, подобных этому, оптимизация может привести к эквивалентной производительности для обоих вызовов.


# Контейнер C++11

Как уже было отмечено, под контейнером понимают объект, содержащий другие (однотипные) объекты, называемые элементами контейнера. Стандартная библиотека С++ предоставляет типичные контейнеры, такие как: [[list|список]], [[vector|вектор]], [[queue|очередь]], [[map|карта]], [[set|множество]] и др. Доступ к элементам контейнера осуществляется через итераторы.
  
К контейнерам выдвигается ряд общих требований. Это осуществляется для того, чтобы
использование контейнеров было одинаковым, независимо от его реализации. Соответственно, часто контейнеры бывают взаимозаменяемы.

## Требования контейнеров ##

| **выражение**      | **возвращаемый тип**                              | **утверждение/примечание состояние до/после**                                                                                   |
| ------------------ | ------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| X::value_type      | T                                                 |                                                                                                                                 |
| X::reference       | T&                                                |                                                                                                                                 |
| X::const_reference | const T&                                          |                                                                                                                                 |
| X::pointer         | тип указателя, указывающий на X::reference        | указатель на T в модели памяти, используемой контейнером                                                                        |
| X::iterator        | тип итратора, указывающий<br>на X::reference      | итератор любой категории, кроме итератора вывода.                                                                               |
| X::const_iter ator | тип итератора, указывающий на X:: const_reference | постоянный итератор любой категории, кроме итератора вывода.                                                                    |
| X::difference_type | знаковый целочисленный тип                        | идентичен типу расстояния X::iterator и X::const_iterator                                                                       |
| X::size_type       | беззнаковый целочисленный тип                     | size_type может представлять любое неотрицательное значение difference_type                                                     |
| X u;               |                                                   | конструктор по умолчанию. после: u.size() == 0                                                                                  |
| X()                |                                                   | конструктор по умолчанию. X().size() == 0.                                                                                      |
| X(a)               |                                                   | конструктор копирования. a == X(a)                                                                                              |
| X u(a); X u = a;   |                                                   | конструктор копирования. после: u = a.                                                                                          |
| (&a)->~X()         | результат не используется                         | после: a.size() == 0. примечание: деструктор применяется к каждому элементу a, и вся память возвращается.                       |
| a.begin()          | iterator; const_iterator для постоянного a        | итератор, указывающий на первый элемент                                                                                         |
| a.end()            | iterator; const_iterator<br>для постоянного a     | итератор, указывающий на конец контейнера                                                                                       |
| a == b             | обратимый в bool                                  | == - это отношение эквивалентности. примечание:<br>equal определяется в разделе алгоритмов.                                     |
| a != b             | обратимый в bool                                  |                                                                                                                                 |
| r = a              | X&                                                | после: r == a                                                                                                                   |
| a.size()           | size_type                                         | количество элементов в контейнере                                                                                               |
| a.max_size()       | size_type                                         | size() самого большого возможного контейнера                                                                                    |
| a.empty()          | обратимый в bool                                  |                                                                                                                                 |
| a < b              | обратимый в bool                                  | до: < определён для значений T. < - отношение полного упорядочения. lexicographical _compare определяется в разделе алгоритмов. |
| a > b              | обратимый в bool                                  |                                                                                                                                 |
| a <= b             | обратимый в bool                                  |                                                                                                                                 |
| a >= b             | обратимый в bool                                  |                                                                                                                                 |

# Контейнеры

Стандарт предоставляет несколько [[Контейнеры - STL|контейнеров]], которые не совсем вписываются в структуру STL. Примерами являются встроенные массивы, [[Array|array]] и [[string|string]]. Я иногда называю их “почти контейнерами”, но это не совсем справедливо: они содержат элементы, поэтому они являются контейнерами, но у каждого есть ограничения или дополнительные возможности, которые делают их неудобными в контексте STL. Описание их по отдельности также упрощает описание STL.

| Контейнеры                               |                                                                                                                                                              |
| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `T[N]`                                   | Встроенный массив: непрерывно выделенная последовательность из `N` элементов фиксированного размера типа `T`; неявно преобразуется в `T*`                    |
| [[Array\|array<T,N>]]                    | непрерывно выделенная последовательность из `N` элементов фиксированного размера типа `T`; аналогично встроенному массиву, но с решением большинства проблем |
| [[bitset\|bitset<N>]]                    | Последовательность фиксированного размера из `N` бит                                                                                                         |
| [[vector\|vector<bool>]]                 | Последовательность бит, компактно хранящаяся в специализированном [[vector\|vector]]                                                                         |
| [[pair\|pair<T, U>]]                     | Пара элементов типа `T` и `U`                                                                                                                                |
| [[tuple (Кортежи)\|tuple<T...>]]         | Последовательность из произвольного числа элементов произвольных типов                                                                                       |
| [[string#basic_string\|basic_string<C>]] | Последовательность символов типа `C`; обеспечивает операции со строками                                                                                      |
| [[Array#valarray\|valarray<T>]]          | Массив числовых значений типа `T`; обеспечивает выполнение числовых операций                                                                                 |

Почему в стандарте предусмотрено так много контейнеров? Они удовлетворяют общие, но разные (часто пересекающиеся) потребности. Если бы стандартная библиотека не предоставляла их, многим людям пришлось бы разрабатывать и внедрять свои собственные. Например:
>
> [[pair|pair]] и [[tuple (Кортежи)|tuple]] неоднородны; все остальные контейнеры однородны (все элементы одного типа).
> 
> элементы [[Array|array]] и [[tuple (Кортежи)|tuple]] располагаются последовательно; [[list|list]] и [[map|map]] являются связанными структурами.
> 
> [[bitset|bitset]] и [[vector|vector<bool>]] содержат биты и получают к ним доступ через прокси-объекты; все остальные контейнеры стандартной библиотеки могут содержать различные типы и получать доступ к элементам напрямую.
> 
> [[string#basic_string|basic_string]] требует, чтобы его элементы были некоторой формой символов и обеспечивали манипулирование строками, такое как конкатенация и операции, зависящие от локали.
> 
> [[Array#valarray|valarray]] требует, чтобы его элементы были числами и обеспечивали числовые операции.

Все эти контейнеры можно рассматривать как предоставляющие специализированные услуги, необходимые большим сообществам программистов. Ни один отдельный контейнер не может удовлетворить все эти потребности, потому что некоторые потребности противоречат друг другу, например, “способность к росту” против “гарантированно размещается в фиксированном местоположении” и “элементы не перемещаются при добавлении” против “ размещаются в памяти непрерывно”.







