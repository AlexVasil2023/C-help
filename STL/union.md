
[[#union|union]]
[[#std set_union|std::set_union]]

# union

Объединение `union` - это `struct`, в которой все члены располагаются по одному и тому же адресу, так что `union` занимает ровно столько места, сколько занимает его самый большой элемент. Естественно, `union` может содержать значение только для одного члена одновременно. Например, рассмотрим запись таблицы символов, которая содержит имя и значение. Значением может быть либо `Node*`, либо `int`:
```c++
enum class Type { ptr, num };    // a Type can hold values ptr and num (§2.4)

struct Entry {
	string name;                 // string is a standard-library type
	Type t;
	Node* p;                     // use p if t==Type::ptr
	int i;                       // use i if t==Type::num
};

void f(Entry* pe)
{
	if (pe->t == Type::num)
		cout << pe->i;
	
	// ...
}
```

Члены `p` и `i` никогда не используются одновременно, поэтому память тратится впустую. Это можно легко исправить, указав, что оба должны быть членами `union`, например так:
```c++
union Value {
	Node* p;
	int i;
};
```

Теперь `Value::p` и `Value::i` помещаются по одному и тому же адресу памяти каждого объекта `Value`.

Такого рода оптимизация пространства может быть важна для приложений, которые занимают большие объемы памяти, поэтому компактное представление имеет решающее значение.

Язык не отслеживает, какое значение содержит `union`, поэтому программист должен это сделать:
```c++
struct Entry {
	string name;
	Type t;
	Value v; // use v.p if t==Type::ptr; use v.i if t==Type::num
};

void f(Entry* pe)
{
	if (pe->t == Type::num)
		cout << pe->v.i;
	
	// ...
}
```

Поддержание соответствия между полем типа, иногда называемым дискриминантом или тегом (здесь `t`), и типом, содержащимся в `union`, подвержено ошибкам. Чтобы избежать ошибок, мы можем обеспечить соблюдение этого соответствия, инкапсулировав объединение и поле типа в класс и предложив доступ только через функции-члены, которые правильно используют объединение. На прикладном уровне абстракции, опирающиеся на такие объединения с тегами, являются распространенными и полезными. Использование “голых” `union` лучше свести к минимуму.

В стандартной библиотеке тип [[variant|variant]], может быть использован для устранения большинства прямых применений объединений. [[variant|variant]] хранит одно значение из набора альтернативных типов. Например, `variant<Node*,int>` может содержать либо `Node*`, либо `int`. Используя `variant`, пример `Entry` может быть записан как:
```c++
struct Entry {
	string name;
	variant<Node*, int> v;
};

void f(Entry* pe)
{
	if (holds_alternative<int>(pe->v)) // does *pe hold an int? (see §15.4.1)
		cout << get<int>(pe->v);       // get the int

	// ...
}
```

Для многих применений [[variant|variant]] проще и безопаснее в использовании, чем `union`.

# std::set_union
#std_set_union













