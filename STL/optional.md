
[[#Optional|Optional]] 15.4.2 (STL)
[[#std optional C++17|std::optional C++17]]

# Optional

`optional<A>` можно рассматривать как особый вид `variant` (например, `variant<A, nothing>`) или как обобщение идеи `A*`, либо указывающего на объект, либо являющегося [[nullptr_t|nullptr]].

`optional` может быть полезен для функций, которые могут возвращать, а могут и не возвращать объект:
```c++
optional<string> compose_message(istream& s)
{
	string mess;
	// ... read from s and compose message ...
	if (no_problems)
		return mess;

	return {};          // the empty optional
}
```

Учитывая это, мы можем написать:
```c++
if (auto m = compose_message(cin))
	cout << *m;                    // note the dereference (*)
else {
	// ... handle error ...
}
```

Это нравится некоторым программистам, которым [[Обработка ошибок#Альтернативные способы обработки ошибок|не нравятся исключения]]. Обратите внимание на любопытное использование `*. optional` обрабатывается как указатель на его объект, а не как сам объект.

В `optional` эквивалентом [[nullptr_t|nullptr]] является пустой объект `{}`. Например:
```c++
int sum(optional<int> a, optional<int> b)
{
	int res = 0;
	if (a) res+=*a;
	if (b) res+=*b;
	return res;
}

int x = sum(17,19);    // 36
int y = sum(17,{});    // 17
int z = sum({},{});    // 0
```

Если мы попытаемся получить доступ к `optional`, который не содержит значения, результат будет неопределенным; исключение не генерируется. Таким образом, `optional` не гарантирует типобезопасность. Не пытайтесь:
```c++
int sum2(optional<int> a, optional<int> b)
{
	return *a+*b;       // asking for trouble
}
```

# std::optional C++17

`std::optional` удивительно полезен и на практике предоставляет возможности, существующие во многих функциональных языках. `'optional'` – это объект, который может содержать либо не содержать значения; этот объект удобно использовать в качестве возвращаемого значения функции, когда она не может вернуть значение; тогда он служит альтернативой, например, нулевому указателю.  

Работая с `optional`, мы приобретаем дополнительное преимущество: теперь возможность отказа функции явно обозначена прямо в объявлении, и, поскольку приходится извлекать значение из optional, значительно снижается вероятность, что мы случайно используем нулевое значение.  

В следующем примере определяется функция преобразования, пытающаяся превратить строку в целое число. Возвращая `optional`, функция оставляет такую возможность: может быть передана недопустимая строка, преобразовать которую не удастся. Вызывающая сторона использует функцию `value_or`, чтобы получить значение из `optional`, а при отказе функции возвращает заданное по умолчанию значение, равное нулю (в случае, если преобразование не удалось).
```c++
#include <experimental/optional> 

using namespace std::experimental; 

optional<int> convert(const std::string& s) { 
	try { 
		int res = std::stoi(s); 
		
		return res; 
	} 
	catch(std::exception&) { 
		return {}; 
	} 
} 

int v = convert("123").value_or(0); 
std::cout << v << std::endl; 

int v1 = convert("abc").value_or(0); 
std::cout << v1 << std::endl;
```




















