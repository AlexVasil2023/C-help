
# Модули

В C++20 у нас наконец-то появился поддерживаемый языком способ прямого выражения модульности #§19_2_4. Рассмотрим, как выразить `Vector` и `sqrt_sum()` в примере из [[Модульность#Раздельная компиляция|Раздельная компиляция]] с использованием module:
```c++
export module Vector;                // defining the module called "Vector"

export class Vector {
	public:
		Vector(int s);
		double& operator[](int i);
		int size();
		
	private:
		double* elem;             // elem points to an array of sz doubles
		int sz;
};

Vector::Vector(int s)
:elem{new double[s]}, sz{s} // initialize members
{    }

double& Vector::operator[](int i)
{ 
	return elem[i];
}

int Vector::size()
{
	return sz;
}

export bool operator==(const Vector& v1, const Vector& v2)
{
	if (v1.size() != v2.size())
		return false;
		
	for (int i = 0; i < v1.size(); ++i)
		if (v1[i] != v2[i])
			return false;

	return true;
}
```

Здесь определён `module` с именем Vector, который экспортирует класс `Vector`, все его функции-члены и функцию, не являющуюся членом, перегружающую оператор `==`.

Способ, которым мы используем этот `module`, заключается в импорте `import` его туда, где он нам нужен. Например:
```c++
// file user.cpp:

import Vector;             // get Vector's interface
#include <cmath> // get the standard-library math function interface including
				//sqrt()

double sqrt_sum(Vector& v)
{
	double sum = 0;
	for (int i=0; i!=v.size(); ++i)
		sum+=std::sqrt(v[i]); // sum of square roots

	return sum;
}
```

Я мог бы также importировать математические функции стандартной библиотеки, но я использовал старомодный `#include` просто для того, чтобы показать, что мы можем смешивать старое и новое. Такое смешивание необходимо для постепенного обновления старого кода, использующего `#include` на использование `import`.
* Модуль компилируется только один раз (а не в каждой единице трансляции, в которой он используется).
* Два модуля могут быть importированы в любом порядке без изменения их значения.
* Если вы `import` или `#include` что-либо в модуль, пользователи вашего модуля неявно получают доступ к этому (и не беспокоятся об этом): `import` не является транзитивным

Влияние модулей на обслуживаемость кода и производительность во время компиляции может быть впечатляющим. Например, по моим измерениям время компиляции программы “Hello, World!”, с использованием
```c++
import std;
```

в 10 раз быстрее, чем версия, с использованием
```c++
#include<iostream>
```

Удивительный результат, несмотря на то, что модуль `std` содержит всю стандартную библиотеку, содержащую более чем в 10 раз больше информации, чем заголовок `<iostream>`. Причина в том, что модули экспортируют только интерфейсы, тогда как заголовок дает компилятору все, что он прямо или косвенно содержит. Это позволяет нам использовать большие модули, так что нам не нужно запоминать, какой именно `#include` из сбивающей с толку [[Обзор стандартной библиотеки - STL#Заголовочные файлы|коллекции заголовков]]. С этого момента я буду предполагать `import std` для всех примеров.

К сожалению, `module std` не является частью C++20. В приложении `A` объясняется, как получить `module std`, если реализация стандартной библиотеки еще не предоставляет его.

При определении модуля нам не обязательно разделять объявления и определения в отдельные файлы; мы можем, если это улучшает организацию нашего исходного кода, но это не обязательно. Мы могли бы определить простой `Vector` модуль следующим образом:
```c++
export module Vector;            // defining the module called "Vector"

export class Vector {
	// ...
};

export bool operator==(const Vector& v1, const Vector& v2)
{
	// ...
}
```

Графически фрагменты программы можно представить следующим образом:
![[STL_1.png]]

Компилятор отделяет интерфейс модуля, указанный спецификаторами `export`, от деталей его реализации. Таким образом, интерфейс `Vector` генерируется компилятором и никогда явно не именуется пользователем.

Используя `module`, нам не нужно усложнять наш код, чтобы скрыть детали реализации от пользователей; `module` будет предоставлять доступ только к exportированным объявлениям. Рассмотрим:
```c++
export module vector_printer;

import std;

export
template<typename T>
void print(std::vector<T>& v)       // this is the (only) function seen by users
{
	cout << "{\n";
	
	for (const T& val : v)
		std::cout << " " << val << '\n';
	
	cout << '}';
}
```

Импортируя этот тривиальный модуль, мы не получаем внезапно доступ ко всей стандартной библиотеке.

`template<typename T>` - это то, как мы параметризуем функцию с типом ([[Template_STL#Параметризованные типы|Параметризованные типы]]).
