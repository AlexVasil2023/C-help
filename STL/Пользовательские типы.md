
[[#Пользовательские типы|Пользовательские типы]] 2
1. [[#Введение|Введение]] 2.1
2. [[#Структуры|Структуры]] 2.2
3. [[#Классы|Классы]] 2.3
4. [[enum|enum(Перечисления)]] 2,4
5. [[union|см. union(Объединения)]] 2,5

# Пользовательские типы

## Введение

Мы называем типы, которые могут быть построены на основе [[#Типы, Переменные и Арифметика|фундаментальных типов]], модификатора [[const|const ]]и [[Программы - STL#Указатели, Массивы и Ссылки|операторов объявления]], встроенными типами. Набор встроенных типов и операций в C++ богат, но намеренно сделан низкоуровневым. Они непосредственно и эффективно отражают возможности обычного компьютерного оборудования. Однако они не предоставляют программисту высокоуровневых возможностей для удобного написания сложных приложений. Вместо этого C++ дополняет встроенные типы и операции сложным набором механизмов абстракции, с помощью которых программисты могут создавать необходимые высокоуровневые средства.

Механизмы абстракции C++ в первую очередь предназначены для того, чтобы позволить программистам разрабатывать и реализовывать свои собственные типы с соответствующими представлениями и операциями, и просто и элегантно использовать такие типы. Типы, созданные из других типов с использованием механизмов абстракции C++, называются пользовательскими типами. Они называются [[#Классы|классами]] и [[enum|перечислениями]]. Пользовательские типы могут быть созданы как из встроенных типов, так и из других пользовательских типов. Большая часть этой книги посвящена проектированию, реализации и использованию пользовательских типов. Пользовательские типы часто предпочтительнее встроенных типов, потому что они проще в использовании, менее подвержены ошибкам и, как правило, столь же эффективны в том, что они делают, как прямое использование встроенных типов, или даже более эффективны.

В остальной части этой главы представлены самые простые и фундаментальные средства определения и использования типов. 

## Структуры

Первым шагом в создании нового типа часто является организация необходимых ему элементов в структуру данных `struct`:
```c++
struct Vector {
	double* elem;  // pointer to elements
	int sz;        // number of elements
};
```

Эта первая версия `Vector` состоит из `int` и `double*`.

Переменная типа `Vector` может быть определена следующим образом:
```c++
Vector v;
```

Однако само по себе это не имеет большого значения, потому что указатель `elem` объекта `v` ни на что не указывает. Чтобы это можно было использовать, мы должны присвоить `v` указатель на некоторые элементы. Например:
```c++
void vector_init(Vector& v, int s) // initialize a Vector
{
	v.elem = new double[s]; // allocate an array of s doubles
	v.sz = s;
}
```

То есть поле `elem` объекта `v` получает указатель, созданный оператором [[new|new]], а поле `sz` объекта `v` получает количество элементов. Символ `&` в `Vector&` указывает, что мы передаем объект `v` по [[Программы - STL#Указатели, Массивы и Ссылки|неконстантной ссылке]]; таким образом, функция `vector_init()` может изменить переданный ей вектор.

Оператор [[new|new]] выделяет память из области, называемой динамической памятью (также известной также как куча или свободное хранилище). Объекты, размещенные в динамической памяти, не зависят от области видимости, из которой они созданы, и “живут” до тех пор, пока не будут уничтожены с помощью оператора [[delete|delete]].

Простое использование `Vector` выглядит следующим образом:
```c++
double read_and_sum(int s)
// read s integers from cin and return their sum; s is assumed to be positive
{
	Vector v;
	vector_init(v,s);      // allocate s elements for v
	
	for (int i=0; i!=s; ++i)
		cin >> v.elem[i]; // read into elements
		
	double sum = 0;
	
	for (int i=0; i!=s; ++i)
		sum+=v.elem[i]; // compute the sum of the elements
		
	return sum;
}
```

Предстоит пройти долгий путь, прежде чем наш `Vector` станет таким же элегантным и гибким, как `vector` стандартной библиотеки. В частности, пользователь `Vector` должен знать каждую деталь представления `Vector`. Остальная часть этой главы и две следующие постепенно улучшают `Vector` в качестве примера языковых возможностей и техник.
Я использую [[vector|vector]] и другие компоненты стандартной библиотеки в качестве примеров чтобы:
>
> проиллюстрировать особенности языка и методы проектирования, а также
> 
> помочь вам изучить и использовать компоненты стандартной библиотеки.

Не изобретайте заново компоненты стандартной библиотеки, такие как [[vector|vector]] и [[string|string]]; используйте их. Типы стандартной библиотеки имеют имена в нижнем регистре, поэтому, чтобы различать названия типов, используемых для иллюстрации методов проектирования и реализации в качестве примеров (например, `Vector` и `String`), я пишу их с заглавной буквы.

Для доступа к элементам структуры struct через имя (и через ссылку) мы используем `.` (точку), а для доступа через указатель - оператор `->`. Например:
```c++
void f(Vector v, Vector& rv, Vector* pv)
{
	int i1 = v.sz;   // access through name
	int i2 = rv.sz;  // access through reference
	int i3 = pv->sz; // access through pointer
}
```

## Классы

Определение данных отдельно от операций над ними имеет преимущества, такие как возможность использовать данные произвольными способами. Однако для того, чтобы пользовательский тип обладал всеми свойствами, ожидаемыми от “реального типа”, необходима более тесная связь между представлением данных и операциями над ними. В частности, мы часто хотим сохранить представление данных недоступным для пользователей, чтобы упростить использование, гарантировать согласованное использование данных и позволить нам позже улучшить представление данных. Чтобы сделать это, мы должны различать интерфейс типа (который общедоступен) и его реализацию (которая имеет доступ к данным недоступным другими способами). Языковой механизм для этого называется классом. Класс состоит из набора членов, в котором могут быть элементы данных, функции или типы.

Интерфейс класса определяется его `public` публичными членами, а его `private` приватные члены доступны только через этот интерфейс. Публичная `public` и приватная `private` части объявления класса могут отображаться в любом порядке, но обычно мы размещаем `public` объявления первыми, а `private` - позже, за исключением случаев, когда мы хотим подчеркнуть представление. Например:
```c++
class Vector {
	public:
		Vector(int s) :elem{new double[s]}, sz{s} { } // construct a Vector
		
		double& operator[](int i) 
			{ return elem[i]; } // element access: subscripting
			
		int size() 
			{ return sz; }
	private:
		double* elem; // pointer to the elements
		int sz; // the number of elements
};
```

Учитывая это, мы можем определить переменную нашего нового типа `Vector`:
```c++
Vector v(6); // a Vector with 6 elements
```

Мы можем проиллюстрировать объект `Vector` графически:
![[STL_8.png]]

По сути, объект `Vector` представляет собой “дескриптор”, содержащий указатель на элементы (`elem`) и количество элементов (`sz`). Количество элементов (`6` в примере) может варьироваться от одного объекта `Vector` к другому объекту `Vector`, и объект `Vector` может иметь разное количество элементов в разное время ([[Классы#Инициализация контейнеров|Инициализация контейнеров]]). Однако сам объект `Vector` всегда имеет одинаковый размер. Это основной метод обработки различных объемов информации в C++: дескриптор фиксированного размера, ссылающийся на переменный объем данных “в другом месте” (например, в динамической памяти, выделенной [[new|new]]). Как проектировать и использовать такие объекты - основная тема [[Классы|Классы]].

Здесь представление `Vector` (элементы `elem` и `sz`) доступно только через интерфейс, предоставляемый `public` элементами: `Vector()`, `operator[]()`, и `size()`. Пример `read_and_sum()` упрощается до:
```c++
double read_and_sum(int s)
{
	Vector v(s); // make a vector of s elements
	
	for (int i=0; i!=v.size(); ++i)
		cin>>v[i]; // read into elements
		
	double sum = 0;
	
	for (int i=0; i!=v.size(); ++i)
		sum+=v[i]; // take the sum of the elements
		
	return sum;
}
```

Функция-член с тем же именем, что и у её класса, называется конструктором, то есть функцией, используемой для создания объектов класса. Таким образом, конструктор `Vector()` заменяет `vector_init()`. В отличие от обычной функции, конструктор гарантированно используется для инициализации объектов своего класса. Таким образом, определение конструктора устраняет проблему неинициализированных переменных для класса.

`Vector(int)` определяет, как создаются объекты типа `Vector`. В частности, в нем указано, что для этого ему нужно целое число. Это целое число используется в качестве количества элементов. Конструктор инициализирует члены объекта `Vector`, используя список инициализаторов элементов:
```c++
:elem{new double[s]}, sz{s}
```

То есть сначала инициализируется `elem` указателем на `s` элементов типа `double`, полученных из кучи. Затем инициализируется `sz` значением `s`.

Доступ к элементам обеспечивается функцией индекса, называемой `operator[]`. Он возвращает ссылку на соответствующий элемент (`double&` позволяющий как чтение, так и запись).

Функция `size()` возвращает количество хранящихся элементов.

Очевидно, что [[Обработка ошибок#Обработка ошибок|обработка ошибок]] здесь полностью отсутствует. Аналогично, мы не предоставили механизм для “возврата” массива `double`, полученного с помощью [[new|new]]; [[Классы#Контейнеры|показано, как определить деструктор]], чтобы элегантно сделать это.

Между struct и `class` нет принципиальной разницы; `struct` - это просто `class`, члены которого по умолчанию являются `public`. Например, вы можете определить конструкторы и другие функции-члены для `struct`.

## Перечисления

[[enum|см. enum(Перечисления)]]

## Объединения

[[union|см. union(Объединения)]]
