
1. [[#Введение]] 8.1
2. [[Concepts#Концепт STL|Концепты]] 8.2
	1. [[Concepts#Использование концептов|Использование концептов]] 8.2.1
	2. [[Concepts#Перегрузка основанная на концептах|Перегрузка основанная на концептах]] 8.2.2
	3. [[Concepts#Правильный код|Правильный код]] 8.2.3
	4. [[Concepts#Определение концептов|Определение концептов]] 8.2.4
		1. [[Concepts#Проверка определения|Проверка определения]] 8.2.4.1
	5. [[Concepts#Концепты и auto|Концепты и auto]] 8.2.5
	6. [[Concepts#Концепты и типы|Концепты и типы]] 8.2.6
3. [[#Обобщённое программирование|Обобщённое программирование]] 8.3
	1. [[#Использование концептов|Использование концептов]] 8.3.1
	2. [[#Абстракции использующие шаблоны|Абстракции использующие шаблоны]] 8.3.2
4. [[#Шаблоны с переменным числом аргументов|Шаблоны с переменным числом аргументов]] 8.4
	1. [[#Выражения свёртки|Выражения свёртки]] 8.4.1
	2. [[#Передача аргументов|Передача аргументов]] 8.4.2
5. [[#Модель компиляции шаблонов|Модель компиляции шаблонов]] 8.5

# Введение

Для чего нужны шаблоны? Другими словами, какие методы программирования становятся эффективнее с помощью шаблонов? Шаблоны предлагают: 
>
> Возможность передавать типы (а также значения и шаблоны) в качестве аргументов без потери информации. Это подразумевает большую гибкость в применении, и отличные возможности для встраивания ([[inline|inline]]), которые широко используются в текущих реализациях.
> 
> Возможности объединить информацию из разных контекстов во время создания экземпляра (инстанцирования). Что подразумевает возможности оптимизации.
> 
> Возможность передавать значения в качестве аргументов шаблона. Что подразумевает возможности для вычислений во время компиляции.

Другими словами, шаблоны предоставляют мощный механизм для вычислений во время компиляции и манипуляций типами, что может привести к созданию очень компактного и эффективного кода. Помните, что типы (классы) могут содержать как [[Template_STL#Функциональные объекты|код]], так и [[Template_STL#Аргументы-значения шаблона|значения]].

Первое и наиболее распространенное использование шаблонов - это поддержка обобщенного программирования, то есть программирования, ориентированного на разработку, реализацию и использование общих алгоритмов. Здесь “общий” означает, что алгоритм может быть разработан таким образом, чтобы принимать самые разнообразные типы, при условии, что они удовлетворяют требованиям алгоритма к его аргументам. Вместе с [[Concepts|концептами]] шаблоны являются основой поддержки обобщенного программирования в С++. Шаблоны обеспечивают параметрический полиморфизм (времени компиляции).

# Концепты

[[Concepts#Концепт STL|см. тут]]

## Использование концептов

[[Concepts#Использование концептов|см. тут]]

## Перегрузка основанная на концептах

[[Concepts#Перегрузка основанная на концептах|см. тут]]

## Правильный код

[[Concepts#Правильный код|см. тут]]

## Определение концептов

[[Concepts#Определение концептов|Определение концептов]] 

### Проверка определения

[[Concepts#Проверка определения|см. тут]]

## Концепты и auto

[[Concepts#Концепты и auto|см. тут]]

## Концепты и типы

[[Concepts#Концепты и типы|см. тут]]

# Обобщённое программирование

Форма ***обобщённого программирования***, непосредственно поддерживаемая C++, сосредоточена вокруг идеи абстрагирования от конкретных эффективных алгоритмов для получения обобщённых алгоритмов, которые можно комбинировать с различными представлениями данных для создания широкого спектра полезного программного обеспечения. Абстракции, которые представляют фундаментальные операции и структуры данных, называются концептами.

## Использование концептов

Хорошие, полезные [[Concepts|концепты]] являются фундаментальными, и их чаще обнаруживают, чем разрабатывают. Примерами являются целое число и число с плавающей запятой (как определено даже в Classic C), последовательность и более общие математические понятия, такие как поле и векторное пространство. Они представляют собой [[Concepts|фундаментальные концепты]] той или иной области применения. Вот почему они называются `“концептами”`. Определение и формализация [[Concepts|концептов]] в той степени, в какой это необходимо для эффективного обобщённого программирования, может оказаться непростой задачей.

Для начала, рассмотрим [[Concepts#концепт regular|концепт regular]]. Тип является обычным (`regular`), когда он ведет себя очень подобно `int` или `vector`. Объект обычного типа:
>
> может быть создан конструктором по умолчанию;
> 
> может быть скопирован (с обычной семантикой копирования, в результате чего получаются два объекта, которые независимы и равны при сравнении)
> 
> помощью конструктора или присваивания;
> 
> можно сравнить с помощью `==` и `!=`;
> 
> не страдает от технических проблем из-за чрезмерно хитроумных программных трюков.

[[string|string]] - это еще один пример обычного типа [[Concepts#концепт regular|regular]]. Как `int`, [[string|string]] также является `totally_ordered`. То есть две строки можно сравнить с помощью `<`, `<=`, `>`, `>=`, и `<=>` с соответствующей семантикой.

[[Concepts|Концепт]] - это не просто синтаксическое понятие, оно в корне связано с семантикой. Например, не определяйте `+` для деления; это не соответствует требованиям для любого разумного числа. К сожалению, у нас пока нет какой-либо языковой поддержки для выражения семантики, поэтому чтобы получить семантически значимые [[Concepts|концепции]], нам приходится полагаться на экспертные знания и здравый смысл. Не определяйте семантически бессмысленные понятия, такие как `Addable` (добавляемое) и `Subtractable` (вычитаемое). Вместо этого опирайтесь на знания предметной области для определения [[Concepts|концептов]], которые соответствуют фундаментальным понятиям в предметной области.

## Абстракции использующие шаблоны

Хорошие абстракции бережно выращиваются на конкретных примерах. Не очень хорошая идея пытаться “абстрагироваться”, пытаясь предусмотреть все возможные потребности и методы; в этом направлении кроется неэлегантность и раздувание кода. Вместо этого начните с одного, а лучше с нескольких, конкретных примеров из реального использования и постарайтесь исключить несущественные детали. Рассмотрим:
```c++
double sum(const vector<int>& v)
{
	double res = 0;
	
	for (auto x : v)
		res += x;
	
	return res;
}
```

Очевидно, что это один из многих способов вычисления суммы последовательности чисел.

Рассмотрим, что делает этот код менее общим, чем он должен быть:
>
> Почему только int?
> 
> Почему именно [[vector|vector]]?
> 
> Почему накапливание суммы в `double`?
> 
> Зачем начинать с 0?
> 
> Зачем суммируем?

Отвечая на первые четыре вопроса путем преобразования конкретных типов в шаблонные аргументы, мы получаем простейшую форму алгоритма [[accumulate|accumulate]] из стандартной библиотеки:
```c++
template<forward_iterator Iter, Arithmetic<iter_value_t<Iter>> Val>
Val accumulate(Iter first, Iter last, Val res)
{
	for (auto p = first; p!=last; ++p)
		res += *p;

	return res;
}
```

Здесь у нас есть:
>
> Структура данных, подлежащая обходу, была абстрагирована в пару итераторов, представляющих последовательность.
> 
> Тип аккумулятора был преобразован в параметр.
> 
> Тип аккумулятора должен быть арифметическим.
> 
> Тип накопителя должен работать с типом значения итератора (типом элемента последовательности).
> 
> Начальное значение теперь является входным; тип аккумулятора соответствует типу этого начального значения.

Быстрый анализ или, что еще лучше, измерение покажет, что код, сгенерированный для вызовов с различными структурами данных, идентичен тому, что вы получаете из примеров, написанных вручную. Рассмотрим:
```c++
void use(const vector<int>& vec, const list<double>& lst)
{
	auto sum = accumulate(begin(vec),end(vec),0.0); // accumulate in a double
	auto sum2 = accumulate(begin(lst),end(lst),sum); 
	
	...
}
```

Процесс обобщения из конкретного фрагмента кода (и предпочтительнее из нескольких) при сохранении производительности называется лифтингом (`lifting`). И наоборот, лучший способ разработать шаблон часто заключается в том, чтобы
>
> сначала написать конкретную версию
> 
> затем отладить, протестировать и измерить её
> 
> наконец, заменить конкретные типы шаблонными аргументами.

Естественно, повторение[[begin| begin()]] и [[end|end()]] утомительно, поэтому мы можем немного упростить пользовательский интерфейс:
```c++
template<forward_range R, Arithmetic<value_type_t<R>> Val>
Val accumulate(const R& r, Val res = 0)
{
	for (auto x : r)
		res += x;
		
	return res;
}
```

Диапазон - это концепция стандартной библиотеки, представляющая последовательность с [[begin|begin()]] и [[end|end()]]. Для полной обобщённости мы также можем абстрагировать операцию `+=`.

Полезны как пара итераторов, так и версия [[accumulate|accumulate()]] для диапазона: версия пары итераторов для универсальности, версия для диапазона для простоты общего использования.

# Шаблоны с переменным числом аргументов

Шаблон может быть определен таким образом, чтобы принимать произвольное количество аргументов произвольных типов. Такой шаблон называется ***вариадическим шаблоном*** или шаблоном с переменным количеством аргументов (variadic template). Рассмотрим простую функцию для записи значений любого типа, которая имеет оператор `<<` :
```c++
void user()
{
		// first: 1 2.2 hello
	print("first: ", 1, 2.2, "hello\n"s); 
	
		// second: 0.2 c yuck! 0 1 2
	print("\nsecond: ", 0.2, 'c', "yuck!"s, 0, 1, 2, '\n'); 
}
```

Традиционно реализация вариадического шаблона заключалась в том, чтобы отделить первый аргумент от остальных, а затем рекурсивно вызвать вариадический шаблон для конца аргументов:
```c++
template<typename T>
concept Printable = requires(T t) { std::cout << t; } // just one operation!

void print()
{
	// what we do for no arguments: nothing
}

template<Printable T, Printable... Tail>
void print(T head, Tail... tail)
{
	cout << head << ' ';   // first, what we do for the head
	print(tail...);        // then, what we do for the tail
}
```

`Printable...` указывает, что `Tail` - это последовательность типов. `Tail...` указывает, что `tail` - это последовательность значений типов в `Tail`. Параметр, объявленный с помощью .`..,` называется пакетом параметров. Здесь `tail` (аргумент функции) - это пакет параметров, в котором элементы относятся к типам, найденным в пакете параметров `Tail` (аргумент шаблона). Итак, `print()` может принимать любое количество аргументов любых типов.

Вызов `print()` разделяет аргументы на голову `head` (первый) и хвост `tail` (остальные). Печатается голова, а затем вызывается функция `print()` для хвоста. В конце концов, конечно, `tail` станет пустым, поэтому нам нужна версия `print()` без аргументов, чтобы справиться с этим. Если мы не хотим допускать случай с нулевым аргументом, мы можем исключить эту функцию `print()`, используя [[if|if]] времени компиляции:
```c++
template<Printable T, Printable... Tail>
void print(T head, Tail... tail)
{
	cout << head << ' ';
	
	if constexpr(sizeof...(tail)> 0)
		print(tail...);
}
```

Я использовал [[if#if constexpr|if]] времени компиляции, а не обычный [[if#if|if]] времени выполнения, чтобы избежать генерации окончательного вызова `print()`. Учитывая это, “пустую” функцию `print()` определять не нужно.

Сила вариадических шаблонов заключается в том, что они могут принимать любые аргументы, которые вы пожелаете им предоставить. Слабые стороны включают в себя
>
> Рекурсивные реализации может быть сложно реализовать правильно.
> 
> Проверка типов интерфейса – это, возможно, сложно разрабатываемый шаблонный код.
> 
> Код проверки типа является специальным, а не определенным в стандарте.
> 
> Рекурсивные реализации могут быть на удивление дорогостоящими с точки зрения времени компиляции и требований к памяти компилятора.

Из-за своей гибкости вариадические шаблоны широко используются в стандартной библиотеке, а иногда даже чрезмерно широко.

## Выражения свёртки

Чтобы упростить реализацию простых вариадических шаблонов, C++ предлагает ограниченную форму итерации по элементам пакета параметров. Например:
```c++
template<Number... T>
int sum(T... v)
{
	return (v + ... + 0); // add all elements of v starting with 0
}
```

Эта функция `sum()` может принимать любое количество аргументов любых типов:
```c++
int x = sum(1, 2, 3, 4, 5); // x becomes 15
int y = sum('a', 2.4, x);   // y becomes 114 (2.4 is truncated and the value 
							// of 'a' is 97)
```

В теле `sum` используется выражение свёртки:
```c++
return (v + ... + 0); // add all elements of v to 0
```

Здесь `(v+...+0)` означает сложение всех элементов `v`, начиная с начального значения `0`. Первым добавляемым элементом является “самый правый” (с наибольшим индексом): `(v[0]+(v[1]+(v[2]+(v[3]+(v[4]+0)))))`. То есть, начиная справа, где находится `0`. Это называется ***правой свёрткой***. В качестве альтернативы мы могли бы использовать ***левую свёртку***:
```c++
template<Number... T>
int sum2(T... v)
{
	return (0 + ... + v); // add all elements of v to 0
}
```

Теперь первым добавляемым элементом является “крайний левый” (с наименьшим индексом): `(((((0+v[0])+v[1])+v[2])+v[3])+v[4])`. То есть, начиная слева, где находится `0`.

***Свёртка***(fold) - это очень мощная абстракция, явно связанная с [[accumulate|accumulate()]] стандартной библиотеки, с множеством названий в разных языках и сообществах. В C++ свёртка выражений в настоящее время ограничена для упрощения реализации вариадических шаблонов. Свёртке не обязательно выполнять числовые вычисления. Рассмотрим известный пример:
```c++
template<Printable ...T>
void print(T&&... args)
{
	(std::cout << ... << args) << '\n'; // print all arguments
}

print("Hello!"s,' ',"World ",2017); // (((((std::cout << "Hello!"s) << ' ') <<
									// "World ") << 2017) << '\n');
```

Почему именно 2017 год? Потому что функция свёртки` fold()` была добавлена в C++ в 2017 году.

## Передача аргументов

Передача аргументов через интерфейс в неизмененном виде является важным случаем использованием вариадических шаблонов. Рассмотрим понятие сетевого входного канала, для которого фактический метод перемещения значений является параметром. Различные транспортные механизмы имеют разные наборы параметров конструктора:
```c++
template<concepts::InputTransport Transport>
class InputChannel {
	public:
		...
		
		InputChannel(Transport::Args&&... transportArgs)
			: _transport(std::forward<TransportArgs>(transportArgs)...)
		{}

		...
		Transport _transport;
};
```

Функция [[forward|forward()]] стандартной библиотеки используется для передачи аргументов без изменений из конструктора `InputChannel` в конструктор `Transport.`

Дело в том, что автор `InputChannel` может создать объект типа `Transport` без необходимости знать, какие аргументы требуются для построения конкретного `Transport`. Разработчику `InputChannel` необходимо только знать общий пользовательский интерфейс для всех `Transport` объектов.

Пересылка очень распространена в базовых библиотеках, где необходимы универсальность и низкие накладные расходы во время выполнения, а также распространены очень общие интерфейсы.

# Модель компиляции шаблонов

В момент обращения аргументы шаблона проверяются на соответствие его [[Concepts|концептам]]. Об обнаруженных здесь ошибках будет немедленно сообщено. То, что не может быть проверено на данном этапе, например, аргументы для неограниченных параметров шаблона, откладывается до тех пор, пока для шаблона не будет сгенерирован код с набором аргументов шаблона: “во время создания экземпляра шаблона”.

Неприятным побочным эффектом проверки типа во время создания экземпляра является то, что ошибка типа может быть обнаружена с неприятной задержкой. Кроме того, поздняя проверка часто приводит к появлению впечатляюще плохих сообщений об ошибках, поскольку компилятор не располагает информацией о типе, дающей подсказки о намерениях программиста, и часто обнаруживает проблему только после объединения информации из нескольких мест в программе.

Проверка типа во время создания экземпляра, предусмотренная для шаблонов, проверяет использование аргументов в определении шаблона. Это обеспечивает во время компиляции вариант того, что часто называют утиной типизацией (“Если нечто выглядит как утка, ходит как утка и крякает как утка, то это утка”). Или – используя более техническую терминологию – мы оперируем значениями, а наличие и значение операции зависят исключительно от значений операндов. Это отличается от альтернативного представления о том, что объекты имеют типы, которые определяют наличие и значение операций. Значения “живут” в объектах. Именно так объекты (например, переменные) работают в C++, и в него могут быть помещены только значения, соответствующие требованиям объекта. То, что делается во время компиляции с использованием шаблонов, в основном не связано с объектами, только со значениями. Исключением являются локальные переменные в [[constexpr|constexpr]] функции, которые используются как объекты внутри компилятора.

Чтобы использовать неограниченный шаблон, его определение (а не только его объявление) должно находиться в области видимости в месте его использования. При использовании файлов заголовков и `#include` это означает, что определения шаблонов должны находиться в заголовочных файлах, а не в файлах `.cpp`. Например, стандартный заголовок `<vector>` содержит определение vector.

Это меняется, когда мы начинаем использовать [[Module#Модули|модули]] Используя модули, исходный код может быть организован для шаблонных функций таким же образом, как и для обычных функций. Модуль частично компилируется в представление, что позволяет быстро импортировать import и использовать его. Думайте об этом представлении как о легко проходимом графе, содержащем всю доступную информацию о области и типе и поддерживаемом таблицей символов, позволяющей быстро получить доступ к отдельным объектам.
