
1. [[#Введение|Введение]] 16.1
2. [[#Время|Время]] 16.2
	1. [[#Часы|Часы]] 16.2.1
	2. [[#Календари|Календари]] 16.2.2
	3. [[#Временные зоны|Временные зоны]] 16.2.3
3. [[#Адаптация функций|Адаптация функций]] 16.3
	1. [[#Лямбды как адапторы|Лямбды как адапторы]] 16.3.1
	2. [[mem_fn|см. mem_fn]] 16.3.2
	3. [[function|function]] 16.3.3
4. [[#Функция типа|Функция типа]] 16.4
	1. [[#Предикаты типа|Предикаты типа]] 16.4.1
	2. [[#Условные свойства|Условные свойства]] 16.4.2
	3. [[#Генераторы типов|Генераторы типов]] 16.4.3
	4. [[#Связанные типы|Связанные типы]] 16.4.4
5. [[#source_location|source_location]] 16.5
6. [[#move() and forward()|move() and forward()]] 16.6
7. [[#Битовые манипуляции|Битовые манипуляции]] 16.7
8. [[#Выход из программы|Выход из программы]] 16.8




# Введение

Обозначение библиотечного компонента как "утилиты" не очень информативно. Очевидно, что каждый библиотечный компонент был полезен кому-то, где-то, в какой-то момент времени. Представленные здесь компоненты выбраны потому, что они служат критически важным целям для многих, но их описание не подходит для других мест. Часто они выступают в качестве строительных блоков для более мощных библиотечных средств, включая другие компоненты стандартной библиотеки.

# Время

В [[Chrono|<chrono>]] стандартная библиотека предоставляет средства для работы со временем:
>
> Часы, `time_point`, и `duration` для измерения того, сколько времени занимает какое-либо действие, и в качестве основы для всего, что связано со временем.
> 
> `day`, `month`, `year`, и `weekdays` для отображения [[Chrono#std chrono time_point (Моменты времени)|time_point]] в нашей повседневной жизни.
>
> `time_zone` и `zoned_time` для устранения различий в отсчёте времени по всему миру. По сути, каждая крупная система имеет дело с некоторыми из этих объектов.

## Часы

Вот простой способ замерить длительность действий:
```c++
using namespace std::chrono;  // in sub-namespace std::chrono

auto t0 = system_clock::now();
do_work();
auto t1 = system_clock::now();

cout << t1-t0 << "\n";       // default unit: 20223[1/00000000]s
cout << duration_cast<milliseconds>(t1-t0).count() << "ms\n"; // specify
													// unit: 2ms
cout << duration_cast<nanoseconds>(t1-t0).count() << "ns\n"; // specify
													// unit: 2022300ns
```

Часы возвращает [[Chrono#std chrono time_point (Моменты времени)|time_point]] (определенный момент времени). Вычитание двух [[Chrono#std chrono time_point (Моменты времени)|time_point]] дает [[Chrono#std chrono duration|duration]] (длительность, период времени). По умолчанию `<<` для [[Chrono#std chrono duration|duration]] добавляет указание группы и отображается как суффикс. Различные часы дают свои результаты в различных единицах измерения времени, “тиках часов”, (я использовал меры в сотни наносекунд), поэтому это часто хорошая идея, преобразовать [[Chrono#std chrono duration|duration]] в соответствующую единицу измерения, что [[Chrono#std chrono duration|duration_cast]] и делает.

Часы полезны для быстрых измерений. Не делайте заявления об “эффективности” кода, не проведя измерения быстродействия. Предположения о производительности наиболее ненадежны. Быстрые, простые замеры лучше, чем их отсутствие, но производительность современных компьютеров - это сложная тема, поэтому мы должны быть осторожны, чтобы не придавать слишком большое значение нескольким простым измерениям. Всегда проводите замеры многократно, чтобы снизить шансы на получение ошеломляющих редких событий или эффектов кэша.

Пространства имен [[Chrono#std literals chrono_literals|std::chrono_literals]] определяет [[Основные операции#Пользовательские литералы|суффиксы единиц измерения времени]]. Например:
```c++
// wait for 10 milliseconds and 33 microseconds
this_thread::sleep_for(10ms+33us); 
```

Обычные символьные имена значительно повышают удобочитаемость и делают код более удобным в обслуживании.

## Календари

Когда мы имеем дело с повседневными событиями, мы редко используем миллисекунды; мы используем годы, месяцы, дни, часы, секунды и дни недели. Стандартная библиотека поддерживает это. Например:
```c++
auto spring_day = April/7/2018;
cout << weekday(spring_day) << '\n';               // Sat
cout << format("{:%A}\n",weekday(spring_day));     // Saturday
```

`Sat` - это символьное представление субботы по умолчанию на моем компьютере. Мне не понравилась эта аббревиатура, поэтому я [[format#Форматирование в стиле printf()|использовал формат]], чтобы получить более длинное название. По непонятным причинам `%A` означает “напишите полное название дня недели”. Естественно, `April` - это месяц; точнее, [[Chrono|std::chrono::Month]]. Мы могли бы также сказать
```c++
auto spring_day = 2018y/April/7;
```

Суффикс `y` используется для того, чтобы отличать годы от простых `int`, которые используются для обозначения дней месяца с номерами от 1 до 31.

Можно указать недопустимые даты. Если вы сомневаетесь, проверьте с помощью `ok()`:
```c++
auto bad_day = January/0/2024;
if (!bad_day.ok())
	cout << bad_day << " is not a valid day\n";
```

Очевидно, что `ok()` наиболее полезен для дат, полученных в результате вычислений.

Даты составляются путем перегрузки оператора `/` (косая черта) по типам `year`, `month` и `int`. Результирующий тип `Year_month_day` может преобразовываться в/из [[Chrono#std chrono time_point (Моменты времени)|time_point]] для обеспечения точного и эффективного вычисления дат. Например:
```c++
// get a time point with the precision of days
sys_days t = sys_days{February/25/2022}; 

t += days{7};               // one week after February 25, 2022
auto d = year_month_day(t); // convert the time point back to the calendar

cout << d << '\n';          // 2022-03-04

// March/04/2022
cout << format("{:%B}/{}/{}\n", d.month(), d.day(), d.year());
```

Этот расчет требует смены месяца и знаний о високосных годах. По умолчанию реализация указывала дату в стандартном формате ISO 8601. Чтобы указать месяц как “март”, мы должны выделить отдельные поля даты и перейти к [[format#Форматирование в стиле printf()|деталям форматирования]]. По непонятным причинам `%B` означает “напишите полное название месяца”.

Такие операции часто могут выполняться во время компиляции и поэтому выполняются на удивление быстро:
```c++
static_assert(weekday(April/7/2018) == Saturday);          // true
```

Календари сложны и неуловимы. Это типично и уместно для “систем”, разработанных для “обычных людей” на протяжении веков, а не программистами для упрощения программирования. Календарная система стандартной библиотеки может быть расширена (и была расширена) для работы с юлианским, исламским, тайским и другими календарями.

## Временные зоны

Один из самых сложных вопросов, связанных со временем, - это часовые пояса. Они настолько произвольны, что их трудно запомнить, и время от времени они меняются различными способами, которые не стандартизированы по всему миру. Например:
```c++
auto tp = system_clock::now();  // tp is a time_point
cout << tp << '\n';             // 2021-11-27 21:36:08.2085095

zoned_time ztp { current_zone(),tp }; // 2021-11-27 16:36:08.2085095 EST
cout << ztp << '\n';

const time_zone est {"Europe/Copenhagen"};
cout << zoned_time{ &est,tp } << '\n';// 2021-11-27 22:36:08.2085095 GMT+1
```

`time_zone` - это время относительно стандарта (называемого GMT или UTC), используемого `system_clock`. Стандартная библиотека синхронизируется с глобальной базой данных (IANA), чтобы получить правильные ответы. Эта синхронизация может быть автоматической в операционной системе или под контролем системного администратора. Названия часовых поясов представляют собой строки в стиле `C` вида “континент/крупный город”, такие как "America/New_York", "Asia/Tokyo", "Africa/Nairobi". zoned_time - это time_zone вместе с [[Chrono#std chrono time_point (Моменты времени)|time_point]].

Как и календари, часовые пояса (временные зоны) решают ряд проблем, которые мы должны оставить стандартной библиотеке, а не полагаться на наш собственный код, созданный вручную. Подумайте: в какое время суток в последний день февраля 2024 года в Нью-Йорке изменится дата в Нью-Дели? Когда в 2020 году в Денвере, штат Колорадо, США, закончилось летнее время? Когда наступит следующая високосная секунда? Стандартная библиотека “знает”.

# Адаптация функций

При передаче функции в качестве аргумента, тип аргумента должен точно соответствовать ожидаемому, выраженному в объявлении вызываемой функции. Если предполагаемый аргумент только “почти соответствует ожиданиям”, у нас есть альтернативные способы его корректировки:
>
> Использование [[Lambda|лямбда-выражений]].
> 
> Использование [[mem_fn|std::mem_fn()]] чтобы создать функциональный объект из функции-члена.
> 
> Определение функции, которая будет принимать [[function|std::function]].

Есть много других способов, но обычно лучше всего работает один из этих трех способов.

## Лямбды как адапторы

Рассмотрим классический пример “нарисуй все фигуры”:
```c++
void draw_all(vector<Shape*>& v)
{
	for_each(v.begin(), v.end(), 
					[](Shape* p) { p->draw(); }
			);
}
```

Как и все алгоритмы стандартной библиотеки, [[for_each|for_each()]] вызывает свой аргумент, используя традиционный синтаксис вызова функции `f(x)`, но `draw()` для `Shape` использует обычную объектно-ориентированную нотацию `x->f()`. Лямбда-выражение легко служит посредником между этими двумя обозначениями.

## mem_fn()

[[mem_fn|см. mem_fn]] 

## function

[[function|см. function]]

# Функция типа

Функция типа - это функция, которая вычисляется во время компиляции с заданным типом в качестве аргумента или возвращающая тип. Стандартная библиотека предоставляет множество функций ввода, помогающих разработчикам библиотек (и программистам в целом) писать код, который использует преимущества языка, стандартной библиотеки и кода в целом.

Для числовых типов [[numeric_limits|numeric_limits]] из `<limits>` содержит разнообразную полезную информацию ([[Числовые вычисления#Числовые ограничения|Числовые ограничения]]). Например:
```c++
constexpr float min = numeric_limits<float>::min();
// smallest positive float
```

Аналогично, размеры объектов могут быть определены с помощью встроенного оператора [[sizeof|sizeof]]. Например:
```c++
constexpr int szi = sizeof(int);
// the number of bytes in an int
```

В `<type_traits>` стандартная библиотека предоставляет множество функций для запроса свойств типов. Например:
```c++
// true if X is one of the (built-in) arithmetic types
bool b = is_arithmetic_v<X>;

// Res is int if f is a function that returns an int
using Res = invoke_result_t<decltype(f)>;
```

`decltype(f)` - это вызов встроенной функции типа [[decltуре|decltype(f)]], возвращающей объявленный тип своего аргумента; здесь `f`.

Некоторые функции типа создают новые типы на основе входных данных. Например:
```c++
typename<typename T>
using Store = conditional_t(sizeof(T) < max, On_stack<T>, On_heap<T>);
```

Если первый (логический) аргумент [[conditional|conditional_t]] равен `true`, результатом будет первая альтернатива; в противном случае - вторая. Предполагая, что `On_stack` и `On_heap` предлагают одинаковые функции доступа к `T`, они могут распределять свои `T` так, как указывают их имена. Таким образом, пользователи `Store<X>` могут быть настроены в соответствии с размером объектов `X`. Настройка производительности, обеспечиваемая таким выбором распределения, может быть очень значительной. Это простой пример того, как мы можем создавать наши собственные функции типа, либо на основе стандартных, либо с помощью [[Concepts|концептов]].

[[Concepts|Концепты]] - это функции типа. Когда они используются в выражениях, они являются специфическими предикатами типа. Например:
```c++
template<typename F, typename... Args>
auto call(F f, Args... a, Allocator alloc)
{
	if constexpr (invocable<F,alloc,Args...>) // needs an allocator?
		return f(f,alloc,a...);
	else
		return f(f,a...);
}
```

Во многих случаях концепты являются лучшими функциями типа, но большая часть стандартной библиотеки была написана до появления концептов и должна поддерживать кодовые базы, написанные до появления концептов.

Условные обозначения сбивают с толку. Стандартная библиотека использует `_v` для функций типа, возвращающих значения, и `_t` для функций типа, возвращающие типы, это пережиток слабо типизированных времен C и доконцептного C++. Ни одна функция типа стандартной библиотеки не возвращает одновременно тип и значение, поэтому эти суффиксы являются избыточными. С концептами, как в стандартной библиотеке, так и в других местах, суффикс не требуется и не используется.

Функции типов являются частью механизмов C++ для вычислений во время компиляции, которые обеспечивают более жесткую проверку типов и более высокую производительность, чем это было бы возможно без них. Использование функций и [[Концепты и обобщенное программирование - STL|концептов типов]] часто называют [[Метапрограммирование|метапрограммированием]] или (когда речь идет о шаблонах) [[Метапрограммирование|шаблонным метапрограммированием]].

## Предикаты типа

В `<type_traits>` стандартная библиотека предлагает десятки простых функций типа, называемых предикатами типа, которые отвечают на фундаментальные вопросы о типах. Вот небольшая подборка:

|                                                              | Некоторые предикаты типа<br>T, A, и U - типы; все предикаты возвращают bool                       |
| ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------- |
| [[is_void\|is_void_v<T>]]                                    | Является ли `T` типом `void`?                                                                     |
| [[is_integral\|is_integral_v<T>]]                            | Является ли `T` целочисленным типом?                                                              |
| [[is_floating_point\|is_floating_point_v<T>]]                | Является ли T типом число с плавающей точкой?                                                     |
| [[is_class\|is_class v<T>]]                                  | Является ли `T` классом (и не [[union\|union]])?                                                  |
| [[is_function#std is_function_v\|is_function_v<T>]]          | Является ли `T` функцией (и не функциональным объектом или не указатель на функцию)?              |
| [[is_arithmetic\|is_arithmetic_v<T>]]                        | Является ли `T` численым типом с плавающей точкой или целым?                                      |
| [[is_scalar\|is_scalar_v<T>]]                                | Является ли `T` арифметическим типом, перечислением, указателем или указателем на элемент данных? |
| [[is_constructible\|is_constructible_v<T, A...]]             | Может ли `T` быть создан из списка аргументов `A...`?                                             |
| [[is_default_constructible\|is_default_constructible_v <T>]] | Может ли `T` быть создан без обязательных аргументов (конструктором по умолчанию)?                |
| [[is_copy_constructible\|is_copy_constructible_v <T>]]       | Может ли `T` быть создан от другого `T`?                                                          |
| [[is_move_constructible\|is_move_constructible_v <T>]]       | Может ли `T` быть копирован или перемещён в другой `T`?                                           |
| [[is_assignable\|is_assignable_v<T,U>]]                      | Может ли `U` быть присвоенным в `T`?                                                              |
| [[is_trivially_copyable\|is_trivially_copyable_v <T,U>]]     | Может ли `U` быть присвоенным в `T` без пользовательских операций копирования?                    |
| [[is_same\|is_same_v<T,U>]]                                  | Является ли `T` того же типа как `U`?                                                             |
| [[is_base_of\|is_base_of_v<T,U>]]                            | Является ли `U` производным от `T` или оба `T` и `U` одного типа?                                 |
| [[is_convertible\|is_convertible_v<T,U>]]                    | Может ли `T` быть неявно преобразованным в `U`?                                                   |
| [[is_iterator\|is_iterator_v<T>]]                            | Является ли `T` типом итератора?                                                                  |
| [[is_invocable\|is_invocable_v <T, A...>]]                   | Может ли `T` быть вызван со списком аргументов `A...`?                                            |
| [[has_virtual_destructor\|has_virtual_destructor_v <T>]]     | Имеет ли `T` виртуальный деструктор?                                                              |

Одно из традиционных применений этих предикатов заключается в ограничении аргументов шаблона. Например:
```c++
template<typename Scalar>
class complex {
		Scalar re, im;
	public:
		static_assert(is_arithmetic_v<Scalar>, 
				"Sorry, I support only complex of arithmetic types");
		// ...
};
```

Однако это – как и другие традиционные способы использования – проще и элегантнее сделать с помощью концептов:
```c++
template<Arithmetic Scalar>
class complex {
		Scalar re, im;
	public:
		// ...
};
```

Во многих случаях предикаты типа, такие как `is_arithmetic`, скрываются в определении концептов для большей простоты использования. Например:
```c++
template<typename T>
concept Arithmetic = is_arithmetic_v<T>;
```

Как ни странно, концепта `std::arithmetic` не существует.

Часто мы можем определить концепты, которые являются более общими, чем предикаты типа стандартной библиотеки. Многие предикаты типов стандартной библиотеки применяются только к встроенным типам. Мы можем определить концепт в терминах требуемых операций, как это предлагается в [[Concepts#Определение концептов|определении Number]]:
```c++
template<typename T, typename U = T>
concept Arithmetic = Number<T,U> && Number<U,T>;
```

Чаще всего использование предикатов типа стандартной библиотеки встречается глубоко в реализации фундаментальных сервисов, часто для выделения вариантов оптимизации. Например, часть реализации `std::copy(Iter, Iter1, Iter2)` могла бы оптимизировать важный случай непрерывных последовательностей простых типов, таких как целые числа:
```c++
template<class T>
void cpy1(T* first, T* last, T* target)
{
	if constexpr (is_trivially_copyable_v<T>)
		memcpy(first, target, (last - first) * sizeof(T));
	else
		while (first != last) *target++ = *first++;
}
```

Эта простая оптимизация превосходит свой неоптимизированный вариант примерно на 50% в некоторых реализациях. Не позволяйте себе подобных ухищрений, пока вы не убедитесь, что стандарт уже не работает лучше. Оптимизированный вручную код, как правило, менее удобен в обслуживании, чем более простые альтернативы.

## Условные свойства

Рассмотрим определение “умного указателя”:
```c++
template<typename T>
class Smart_pointer {
	// ...
	T& operator*() const;
	T* operator->() const; // -> should work if and only if T is a class
};
```

Оператор `->` должен быть определен тогда и только тогда, когда `T` является типом класса. Например, `Smart_pointer<vector<T>>` должен иметь `->`, но `Smart_pointer<int>` не должен.

Мы не можем использовать [[if|if]] времени компиляции, потому что мы не находимся внутри функции. Вместо этого мы пишем
```c++
template<typename T>
class Smart_pointer {
	// ...
	T& operator*() const;
	
	// -> is defined if and only if T is a class
	T* operator->() const requires is_class_v<T>;
};
```

Предикат типа непосредственно выражает ограничение на `operator->()`. Мы также можем использовать концепты для этого. Не существует концепта стандартной библиотеки, требующего, чтобы тип был типом класса (то есть `class`, struct или [[union|union]]), но мы могли бы определить один из них:
```c++
template<typename T>
concept Class = is_class_v<T> || is_union_v<T>; // unions are classes
template<typename T>
class Smart_pointer {
	// ...
	T& operator*() const;
	
	// -> is defined if and only if T is a class or a union
	T* operator->() const requires Class<T>;
};
```

Часто концепт является более общим или просто более подходящим, чем прямое использование предиката типа стандартной библиотеки.

## Генераторы типов

Многие функции типа возвращают типы, часто новые типы, которые они вычисляют. Я называю такие функции генераторами типов, чтобы отличать их от предикатов типов. Стандарт предлагает некоторые, например, такие:

|                                                          | Некоторые генераторы типов                                                                                                               |
| -------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| [[remove_const\|R = remove_const_t<T>]]                  | `R` это `T` с удалением константности (если таковая имеется)                                                                             |
| [[add_const\|R = add_const_t<T>]]                        | `R` это `const T`                                                                                                                        |
| [[remove_reference\|R = remove_reference_t<T>]]          | если `T` это [[r-значение#l-значение\|lvalue ссылка]], `R` это `T` иначе `T&`                                                            |
| [[add_lvalue_reference\|R = add_lvalue_reference_t <T>]] | если `T` это [[r-значение#l-значение\|lvalue ссылка]], `R` это `T` иначе `T&`                                                            |
| [[add_rvalue_reference\|R = add_rvalue_reference_t <T>]] | если `T` это [[rvalue\|rvalue]] ссылка, `R` это `T` иначе `T&&`                                                                          |
| [[enable_if\|R = enable_if_t<b,T =void>]]                | если `b` истинно, `R` это `T` иначе `R` не определено                                                                                    |
| [[conditional\|R = conditional_t<b,T,U>]]                | `R` это `T` если `b` истинно; иначе `U`                                                                                                  |
| [[common_type\|R = common_type_t<T...>]]                 | если существует тип, к которому все `T` могут быть неявно преобразованы, `R` является этим типом; в противном случае `R` не<br>определен |
| [[underlying_type\|R = underlying_type_t<T>]]            | если `T` является перечислением, `R` является его базовым типом; в противном случае ошибка                                               |
| [[invoke_result\|R = invoke_result_t<T,A...>]]           | если `T` может быть вызван с аргументами `A...`, `R` это тип возвращаемого значения; иначе ошибка                                        |

Функции такого типа обычно используются при реализации утилит, а не непосредственно в коде приложения. Из них [[enable_if|enable_if]], вероятно, является наиболее распространенным в коде до создания концептов. Например, условно включенный `->` для умного указателя традиционно реализуется примерно так:

## Связанные типы

Все [[Контейнеры - STL#Обзор контейнеров|стандартные контейнеры]] и все контейнеры, разработанные в соответствии с их шаблоном, имеют некоторые связанные типы, такие как их типы значений и типы итераторов. В [[iterator|<iterator>]] и [[range|<ranges>]] стандартная библиотека предоставляет имена для этих:

|                    | Некоторе генераторы типов                       |
| ------------------ | ----------------------------------------------- |
| `range_value_t<R>` | Тип диапазона элементов `R`                     |
| `iter_value_t<T>`  | Тип элементов на которые указывает итератор `T` |
| `iterator_t<R>`    | Тип итаратора диапазона `R`                     |

# source_location

При записи сообщения трассировки или сообщения об ошибке мы часто хотим вывести данные о местоположении ошибки в исходнике частью этого сообщения. Стандартная библиотека предоставляет [[source_location|source_location]] для этого:
```c++
const source_location loc = source_location::current();
```

Эта функция `current()` возвращает значение [[source_location|source_location]], описывающее место в исходном коде, где оно появляется. Класс [[source_location|source_location]] имеет элементы `file()` и `function_name()`, возвращающие строки в стиле `C`, а элементы `line()` и `column()`, возвращающие целые числа без знака.

Оберните это в функцию, и мы получим хороший первый фрагмент сообщения журнала:
```c++
void log(const string& mess = "", const source_location loc = 
										source_location::current())
{
	cout << loc.file_name()
		<< '(' << loc.line() << ':' << loc.column() << ") "
		<< loc.function_name() ": "
		<< mess;
}
```

Вызов `current()` является аргументом по умолчанию, так что мы получаем местоположение вызывающего `log()`, а не местоположение `log()`:
```c++
void foo()
{
	log("Hello");        // myfile.cpp (17,4) foo: Hello
	// ...
}

int bar(const string& label)
{
	log(label);         // myfile.cpp (23,4) bar: <<the value of label>>
	// ...
}
```

Код, написанный до C++20 или нуждающийся в компиляции на более старых компиляторах, использует для этого макросы `__FILE__` и `__LINE__`.

# move() and forward()

Выбор между перемещением и копированием в основном выполняется неявно. Компилятор предпочитает перемещение, когда объект вот-вот будет уничтожен (как при `return`), потому что предполагается, что это более простая и эффективная операция. Однако иногда мы должны быть откровенны. Например, [[unique_ptr|unique_ptr]] является единственным владельцем объекта. Следовательно, он не может быть скопирован, поэтому, если вам нужен [[unique_ptr|unique_ptr]] в другом месте, вы должны переместить его. Например: 
```c++
void f1()
{
	auto p = make_unique<int>(2);
	auto q = p;         // error: we can't copy a unique_ptr
	auto q = move(p);   // p now holds nullptr
	// ...
}
```

Сбивает с толку то, что [[move|std::move()]] ничего не перемещает. Вместо этого он приводит свой аргумент к [[rvalue|rvalue]] ссылке, тем самым сообщая, что его аргумент больше не будет использоваться и, следовательно, [[Основные операции#Перемещение контейнеров|может быть перемещен]]. Это должно было называться как-то вроде `rvalue_cast`. Он существует для обслуживания нескольких важных случаев. Рассмотрим простой обмен:
```c++
template <typename T>
void swap(T& a, T& b)
{
	T tmp {move(a)};  // the T constructor sees an rvalue and moves
	a = move(b);      // the T assignment sees an rvalue and moves
	b = move(tmp);    // the T assignment sees an rvalue and moves
}
```

Мы не хотим повторно копировать потенциально большие объекты, поэтому мы запрашиваем перемещения с помощью [[move|std::move()]].

Что касается других приведений, то существуют заманчивые, но опасные варианты использования [[move|std::move()]]. Рассмотрим:
```c++
string s1 = "Hello";
string s2 = "World";
vector<string> v;

// use a "const string&" argument; push_back() will copy
v.push_back(s1);        

v.push_back(move(s2)); // use a move constructor

// an alternative; place a copy of s1 in a new end position of v
v.emplace_back(s1);
```

Здесь `s1` копируется (с помощью `push_back()`), тогда как `s2` перемещается. Это иногда (только иногда) делает `push_back()` из `s2` дешевле. Проблема в том, что перемещенный объект остается позади. Если мы снова используем `s2`, у нас возникнет проблема:
```c++
cout << s1[2];     // write 'l'
cout << s2[2];     // crash?
```

Я считаю, что такое использование [[move|std::move()]] слишком подвержено ошибкам. Не используйте его, если только вы не сможете продемонстрировать значительное и необходимое улучшение производительности. Последующее техническое обслуживание может случайно привести к непредвиденному использованию перемещенного объекта.

Компилятор знает, что возвращаемое значение больше не используется в функции, поэтому использование явного [[move|std::move()]], например, `return std::move(x)`, является избыточным и может даже препятствовать оптимизации.

Состояние перемещаемого объекта, как правило, не определено, но все типы стандартных библиотек оставляют перемещаемый объект в состоянии, в котором он может быть уничтожен и присвоен. Было бы неразумно не последовать этому примеру. Для контейнера (например, [[vector|vector]] или [[string|string]]) состояние перемещения из будет “пустым”. Для многих типов хорошим значением по умолчанию является пустое состояние: значимое
и дешевое в установке.

[[Концепты и обобщенное программирование - STL#Передача аргументов|Передача аргументов]] - важный вариант использования, требующий перемещений. Иногда мы хотим передать набор аргументов в другую функцию, ничего не меняя (для достижения “идеальной пересылки”):
```c++
template<typename T, typename... Args>
unique_ptr<T> make_unique(Args&&... args)
{
	return unique_ptr<T>{new T{std::forward<Args>(args)...}};
	// forward each argument
}
```

Функция [[forward|forward()]] стандартной библиотеки отличается от более простой [[move|std::move()]] правильной обработкой тонкостей, связанных с [[r-значение#l-значение|lvalue]] и [[rvalue|rvalue]]. Используйте [[forward|std::forward()]] исключительно для передачи и не [[forward|forward()]] что-либо дважды; как только вы передали объект, он больше не принадлежит вам и нельзя его использовать.

# Битовые манипуляции

В `<bit>` мы находим функции для низкоуровневой обработки битов. Манипулирование битами - это специализированный, но часто необходимый вид деятельности. Когда мы приближаемся к аппаратному обеспечению, нам часто приходится смотреть на биты, изменять битовые структуры в байте или слове и превращать необработанную память в типизированные объекты. Например, [[bit_cast|bit_cast]] позволяет нам преобразовать значение одного типа в другой тип того же размера:
```c++
double val = 7.2;
// get the bit representation of a 64-bit floating point number
auto x = bit_cast<uint64_t>(val); 

// get the bit representation of a 64-bit pointer
auto y = bit_cast<uint64_t>(&val);

struct Word { std::byte b[8]; };
std::byte buffer[1024];

// ...

auto p = bit_cast<Word*>(&buffer[i]); // p points to 8 bytes
auto i = bit_cast<int64_t>(*p);   // convert those 8 bytes to an integer
```

Тип стандартной библиотеки [[byte|std::byte]] (требуется `std::`) существует для представления байтов, а не байтов представляющих символы или целые числа. В частности, [[byte|std::byte]] предоставляет только побитовые логические операции, а не арифметические. Обычно лучшим типом для выполнения битовых операций является беззнаковое целое или [[byte|std::byte]]. Под лучшим я подразумеваю самый быстрый и наименее подверженный сюрпризам. Например:
```c++
void use(unsigned int ui)
{
	// the smallest number of bits needed to represent ui
	int x0 = bit_width(ui);

	// rotate left 8 bits (note: doesn't change ui)
	unsigned int ui2 = rotl(ui,8); 
	
	int x1 = popcount(ui);  // the number of 1s in ui
	// ...
}
```

Смотрите также [[bitset|bitset]]

# Выход из программы

Иногда фрагмент кода сталкивается с проблемой, с которой он не может справиться:
>
> Если проблема такого рода возникает часто и можно ожидать, что непосредственный вызывающий справится с ней, [[Обработка ошибок#Альтернативные способы обработки ошибок|верните какой-нибудь код возврата]].
> 
> Если проблема такого рода возникает нечасто или нельзя ожидать, что непосредственный вызывающий абонент справится с ней, [[Обработка ошибок#Альтернативные способы обработки ошибок|создайте исключение]].
> 
> Если проблема настолько серьезна, что нельзя ожидать, что ни одна обычная часть программы не справится с ней, выйдите из программы.

Стандартная библиотека предоставляет средства для работы с этим последним случаем (“выход из программы”):
>
> `exit(x)`: вызов функций, зарегистрированных с помощью `atexit()` затем выход из программы с возвращаемым значением `x`. Если вам нужно, посмотрите `atexit()`, это, по сути, примитивный механизм деструктора, совместно используемый с языком C.
> 
> `abort()`: немедленно и безоговорочно завершить работу программы с возвращаемым значением, указывающим на неудачное завершение. Некоторые операционные системы предлагают средства, которые изменяют это простое поведение.
> 
> `quick_exit(x)`: вызывает функции, зарегистрированные с помощью `at_quick_exit()`; затем завершает работу программы с возвращаемым значением `x`.
> 
> `terminate()`: вызывает `terminate_handler`. По умолчанию `terminate_handler` это `abort()`.

Эти функции предназначены для действительно серьезных ошибок. Они не вызывают деструкторы; то есть они не выполняют обычную и надлежащую очистку. Различные обработчики используются для выполнения действий перед выходом. Такие действия должны быть очень простыми, потому что одной из причин вызова этих функций выхода является то, что состояние программы повреждено. Одно разумное и достаточно популярное действие - “перезапустить систему в четко определенном состоянии, не полагаясь ни на какое состояние текущей программы”. Другое, немного более сложное, но часто небезосновательное действие - “зарегистрировать сообщение об ошибке и выйти”. Причина, по которой запись сообщения журнала может быть проблемой, заключается в том, что система ввода-вывода могла быть повреждена из-за того, что вызвало вызов функции выхода.

Обработка ошибок - один из самых сложных видов программирования; даже чисто выйти из программы может быть непросто. Ни одна библиотека общего назначения не должна безоговорочно завершать работу.


