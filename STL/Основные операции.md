
[[#Основные операции|Основные операции]] 6
1. [[#Введение|Введение]] 6.1
	1. [[#Операции|Основные операции]] 6.1.1
	2. [[#Преобразования типов|Преобразования типов]] 6.1.2
	3. [[#Инициализация элементов|Инициализация элементов]] 6.1.3
2. [[#Копирование и перемещение|Копирование и перемещение]] 6.2


# Основные операции

# Введение

Некоторые операции, такие как инициализация, присвоение, копирование и перемещение, являются фундаментальными в том смысле, что правила языка программирования делают предположения относительно них. Другие операции, такие как `==` и `<<`, имеют общепринятые значения, которые опасно игнорировать.

## Операции

Конструкторы, деструкторы и операции копирования и перемещения для типа логически неразделимы. Мы должны определить их как согласованный набор, иначе возникнут проблемы с логикой или производительностью. Если у класса `X` есть деструктор, который выполняет нетривиальную задачу, такую как освобождение динамической памяти или снятие блокировки, классу, вероятно, потребуется полный набор функций:
```c++
class X {
	public:
		X(Sometype);             // “ordinary constructor”: create an object
		X();                     // default constructor
		X(const X&);             // copy constructor
		X(X&&);                  // move constructor
		X& operator=(const X&);  // copy assignment: clean up target and copy
		X& operator=(X&&);       // move assignment: clean up target and move
		~X();                    // destructor: clean up
		
		...
};
```

Существует пять ситуаций, в которых объект может быть скопирован или перемещен:
>
> В качестве источника присваивания
> 
> В качестве инициализатора объекта
> 
> В качестве аргумента функции
> 
> Как возвращаемое функцией значение
> 
> В качестве исключения

При присваивании используется копирующая или перемещающая версия оператора. В принципе, в других случаях используется конструктор копирования или перемещения. Однако вызов конструктора копирования или перемещения часто оптимизируется путем создания объекта, используемого для инициализации, прямо в целевом объекте. Например:
```c++
X make(Sometype);
X x = make(value);
```

Здесь компилятор обычно создает `X` из `make()` непосредственно в `x`; таким образом, исключая (“устраняя”) копию (copy elision).

В дополнение к инициализации именованных объектов и объектов в динамической памяти конструкторы используются для инициализации временных объектов и реализации явного преобразования типов.

За исключением “обычного конструктора”, эти специальные функции-члены будут генерироваться компилятором по мере необходимости. Если вы хотите четко указать, как создавать реализации по умолчанию, вы можете:
```c++
class Y {
	public:
		Y(Sometype);
		Y(const Y&) = default; // I really do want the default copy constructor
		Y(Y&&) = default;      // and the default move constructor
	
		...
};
```

Если вы явно укажете некоторые значения по умолчанию, другие определения по умолчанию сгенерированы не будут.

Когда у класса есть поле-указатель, обычно рекомендуется четко указывать операции копирования и перемещения. Причина в том, что указатель может указывать на что-то, что классу необходимо [[delete|delete]], и в этом случае копирование по умолчанию по элементам было бы неправильным. В качестве альтернативы, это может указывать на что-то, что класс не должен [[delete|delete]]. В любом случае, читатель кода хотел бы знать. Пример см. в #§6_2_1.

Хорошее эмпирическое правило (иногда называемое правилом нуля) состоит в том, чтобы либо определять все основные операции, либо ни одной (используя значение по умолчанию для всех). Например:
```c++
struct Z {
	Vector v;
	string s;
};

Z z1;                // default initialize z1.v and z1.s
Z z2 = z1;           // default copy z1.v and z1.s
```

Здесь компилятор синтезирует для членов конструктор по умолчанию, конструктор копирования, конструктор перемещения и деструктор по мере необходимости, и все это с правильной семантикой.

В дополнение к `=default` у нас есть `=delete`, чтобы указать, что операция не должна быть сгенерирована. Базовый класс в иерархии классов - это классический пример, когда мы не хотим разрешать копирование по элементам. Например:
```c++
class Shape {
	public:
		Shape(const Shape&) =delete; // no copying
		Shape& operator=(const Shape&) =delete;

	...
};

void copy(Shape& s1, const Shape& s2)
{
	s1 = s2;                        // error: Shape copy is deleted
}
```

Конструкция `=delete` приводит к тому, что попытка использования [[delete|delete]] функции приводит к ошибке во время компиляции; `=delete` может использоваться для запрещения любой функции, а не только основных функций-членов.

## Преобразования типов

Конструктор, принимающий один аргумент, определяет преобразование из типа принятого аргумента. [[Классы#Арифметические типы|Например, complex предоставляет конструктор из double]]:
```c++
complex z1 = 3.14; // z1 becomes {3.14,0.0}
complex z2 = z1*2; // z2 becomes z1*{2.0,0} == {6.28,0.0}
```
Это неявное преобразование иногда является идеальным, но не всегда. [[Классы#Контейнеры|Например, Vector предоставляет конструктор из int]]:
```c++
Vector v1 = 7;     // OK: v1 has 7 elements
```

Обычно это считается неудачным, и [[vector|vector]] стандартной библиотеки не допускает такого “преобразования” `int` в `vector`.

Способ избежать этой проблемы - указать, что разрешено только явное “преобразование”; то есть мы можем определить конструктор следующим образом:
```c++
class Vector {
	public:
		explicit Vector(int s); // no implicit conversion from int to Vector
	
	...
};
```

Это дает нам:
```c++
Vector v1(7);    // OK: v1 has 7 elements
Vector v2 = 7;   // error: no implicit conversion from int to Vector
```

Когда дело доходит до преобразований, большинство типов похожи на `Vector`, а не на `complex`, поэтому используйте [[explicit|explicit]] для конструкторов, которые принимают один аргумент, если только нет веской причины не делать этого.

## Инициализация элементов

При определении элемента данных класса, мы можем предоставить инициализатор, называемый инициализатором элемента по умолчанию. [[Классы#Арифметические типы|Рассмотрим версию complex]]:
```c++
class complex {
	double re = 0;
	double im = 0; // representation: two doubles with default value 0.0
	
	public:
		// construct complex from two scalars: {r,i}
		complex(double r, double i) :re{r}, im{i} {} 
		
		// construct complex from one scalar: {r,0}
		complex(double r) :re{r} {} 
		
		// default complex: {0,0}
		complex() {}
	
	...
}
```

Значение по умолчанию используется всякий раз, когда конструктор не предоставляет значения. Это упрощает код и помогает нам избежать случайного оставления элемента неинициализированным.

# Копирование и перемещение








