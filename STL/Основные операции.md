
[[#Основные операции|Основные операции]] 6
1. [[#Введение|Введение]] 6.1
	1. [[#Операции|Основные операции]] 6.1.1
	2. [[#Преобразования типов|Преобразования типов]] 6.1.2
	3. [[#Инициализация элементов|Инициализация элементов]] 6.1.3
2. [[#Копирование и перемещение|Копирование и перемещение]] 6.2
	1. [[#Копирование контейнеров|Копирование контейнеров]] 6.2.1
	2. [[#Перемещение контейнеров|Перемещение контейнеров]] 6.2.2
3. [[#Управление ресурсами|Управление ресурсами]] 6.3
4. [[#Перегрузка операторов|Перегрузка операторов]] 6.4
5. [[#Стандартные операции|Стандартные операции]] 6.5
	1. [[Операторы сравнения|Операторы сравнения]] 6.5.1
	2. [[Операции с контейнерами|Операции с контейнерами]] 6.5.2
	3. [[#Итераторы и “умные указатели”|Итераторы и “умные указатели”]] 6.5.3
	4. [[#Операции ввода-вывода|Операции ввода-вывода]] 6.5.4
	5. [[swap|swap()]] 6.5.5
	6. [[hash|hash()]] 6.5.6
6. [[#Пользовательские литералы|Пользовательские литералы]] 6.6

# Основные операции

# Введение

Некоторые операции, такие как инициализация, присвоение, копирование и перемещение, являются фундаментальными в том смысле, что правила языка программирования делают предположения относительно них. Другие операции, такие как `==` и `<<`, имеют общепринятые значения, которые опасно игнорировать.

## Операции

Конструкторы, деструкторы и операции копирования и перемещения для типа логически неразделимы. Мы должны определить их как согласованный набор, иначе возникнут проблемы с логикой или производительностью. Если у класса `X` есть деструктор, который выполняет нетривиальную задачу, такую как освобождение динамической памяти или снятие блокировки, классу, вероятно, потребуется полный набор функций:
```c++
class X {
	public:
		X(Sometype);             // “ordinary constructor”: create an object
		X();                     // default constructor
		X(const X&);             // copy constructor
		X(X&&);                  // move constructor
		X& operator=(const X&);  // copy assignment: clean up target and copy
		X& operator=(X&&);       // move assignment: clean up target and move
		~X();                    // destructor: clean up
		
		...
};
```

Существует пять ситуаций, в которых объект может быть скопирован или перемещен:
>
> В качестве источника присваивания
> 
> В качестве инициализатора объекта
> 
> В качестве аргумента функции
> 
> Как возвращаемое функцией значение
> 
> В качестве исключения

При присваивании используется копирующая или перемещающая версия оператора. В принципе, в других случаях используется конструктор копирования или перемещения. Однако вызов конструктора копирования или перемещения часто оптимизируется путем создания объекта, используемого для инициализации, прямо в целевом объекте. Например:
```c++
X make(Sometype);
X x = make(value);
```

Здесь компилятор обычно создает `X` из `make()` непосредственно в `x`; таким образом, исключая (“устраняя”) копию (copy elision).

В дополнение к инициализации именованных объектов и объектов в динамической памяти конструкторы используются для инициализации временных объектов и реализации явного преобразования типов.

За исключением “обычного конструктора”, эти специальные функции-члены будут генерироваться компилятором по мере необходимости. Если вы хотите четко указать, как создавать реализации по умолчанию, вы можете:
```c++
class Y {
	public:
		Y(Sometype);
		Y(const Y&) = default; // I really do want the default copy constructor
		Y(Y&&) = default;      // and the default move constructor
	
		...
};
```

Если вы явно укажете некоторые значения по умолчанию, другие определения по умолчанию сгенерированы не будут.

Когда у класса есть поле-указатель, обычно рекомендуется четко указывать операции копирования и перемещения. Причина в том, что указатель может указывать на что-то, что классу необходимо [[delete|delete]], и в этом случае копирование по умолчанию по элементам было бы неправильным. В качестве альтернативы, это может указывать на что-то, что класс не должен [[delete|delete]]. В любом случае, читатель кода хотел бы знать. [[Основные операции#Копирование контейнеров|Пример]].

Хорошее эмпирическое правило (иногда называемое правилом нуля) состоит в том, чтобы либо определять все основные операции, либо ни одной (используя значение по умолчанию для всех). Например:
```c++
struct Z {
	Vector v;
	string s;
};

Z z1;                // default initialize z1.v and z1.s
Z z2 = z1;           // default copy z1.v and z1.s
```

Здесь компилятор синтезирует для членов конструктор по умолчанию, конструктор копирования, конструктор перемещения и деструктор по мере необходимости, и все это с правильной семантикой.

В дополнение к `=default` у нас есть `=delete`, чтобы указать, что операция не должна быть сгенерирована. Базовый класс в иерархии классов - это классический пример, когда мы не хотим разрешать копирование по элементам. Например:
```c++
class Shape {
	public:
		Shape(const Shape&) =delete; // no copying
		Shape& operator=(const Shape&) =delete;

	...
};

void copy(Shape& s1, const Shape& s2)
{
	s1 = s2;                        // error: Shape copy is deleted
}
```

Конструкция `=delete` приводит к тому, что попытка использования [[delete|delete]] функции приводит к ошибке во время компиляции; `=delete` может использоваться для запрещения любой функции, а не только основных функций-членов.

## Преобразования типов

Конструктор, принимающий один аргумент, определяет преобразование из типа принятого аргумента. [[Классы#Арифметические типы|Например, complex предоставляет конструктор из double]]:
```c++
complex z1 = 3.14; // z1 becomes {3.14,0.0}
complex z2 = z1*2; // z2 becomes z1*{2.0,0} == {6.28,0.0}
```
Это неявное преобразование иногда является идеальным, но не всегда. [[Классы#Контейнеры|Например, Vector предоставляет конструктор из int]]:
```c++
Vector v1 = 7;     // OK: v1 has 7 elements
```

Обычно это считается неудачным, и [[vector|vector]] стандартной библиотеки не допускает такого “преобразования” `int` в `vector`.

Способ избежать этой проблемы - указать, что разрешено только явное “преобразование”; то есть мы можем определить конструктор следующим образом:
```c++
class Vector {
	public:
		explicit Vector(int s); // no implicit conversion from int to Vector
	
	...
};
```

Это дает нам:
```c++
Vector v1(7);    // OK: v1 has 7 elements
Vector v2 = 7;   // error: no implicit conversion from int to Vector
```

Когда дело доходит до преобразований, большинство типов похожи на `Vector`, а не на `complex`, поэтому используйте [[explicit|explicit]] для конструкторов, которые принимают один аргумент, если только нет веской причины не делать этого.

## Инициализация элементов

При определении элемента данных класса, мы можем предоставить инициализатор, называемый инициализатором элемента по умолчанию. [[Классы#Арифметические типы|Рассмотрим версию complex]]:
```c++
class complex {
	double re = 0;
	double im = 0; // representation: two doubles with default value 0.0
	
	public:
		// construct complex from two scalars: {r,i}
		complex(double r, double i) :re{r}, im{i} {} 
		
		// construct complex from one scalar: {r,0}
		complex(double r) :re{r} {} 
		
		// default complex: {0,0}
		complex() {}
	
	...
}
```

Значение по умолчанию используется всякий раз, когда конструктор не предоставляет значения. Это упрощает код и помогает нам избежать случайного оставления элемента неинициализированным.

# Копирование и перемещение

По умолчанию объекты могут быть скопированы. Это верно как для объектов пользовательских типов, так и для встроенных типов. По умолчанию под копированием подразумевается поэлементное копирование: копирование каждого элемента. Например, используя  [[Классы#Арифметические типы|complex]]:
```c++
void test(complex z1)
{
	complex z2 {z1};      // copy initialization
	complex z3;
	z3 = z2;              // copy assignment
	// ...
}
```

Теперь `z1`, `z2` и `z3` имеют одинаковое значение, потому что и присваивание, и инициализация скопировали оба элемента.

Когда мы разрабатываем класс, мы всегда должны учитывать, может ли объект быть скопирован и как именно. Для простых конкретных типов поэлементное копирование часто является точно подходящей семантикой для копирования. Для некоторых сложных конкретных типов, таких как [[vector|vector]], поэлементное копирование не является подходящей семантикой для копирования; для абстрактных типов поэлементное копирование почти никогда не подходит.

## Копирование контейнеров

Когда класс является дескриптором ресурса, то есть когда класс отвечает за объект, доступ к которому осуществляется через указатель, поэлементное копирование по умолчанию обычно приводит к сбою. Копирование по элементам нарушило бы [[Обработка ошибок#Инварианты|инвариант дескриптора ресурса]]. Например, копия по умолчанию оставила бы копию [[vector|vector]], ссылающегося на те же элементы, что и оригинал:
```c++
void bad_copy(Vector v1)
{
	Vector v2 = v1; // copy v1's representation into v2
	v1[0] = 2; // v2[0] is now also 2!
	v2[1] = 3; // v1[1] is now also 3!
}
```

Предполагая, что `v1` состоит из четырех элементов, результат может быть представлен графически следующим образом:
![[stl_14.png]]

К счастью, тот факт, что у `Vector` есть деструктор, является сильным намеком на то, что семантика копирования по умолчанию (поэлементная) неверна, и компилятор должен, по крайней мере, предупредить об этом. Нам нужно лучше определить семантику копирования.

Копирование объекта класса определяется двумя членами: ***конструктором копирования*** и ***оператором присваивания копированием***:
```c++
class Vector {
	public:
		Vector(int s);  // constructor: establish invariant, acquire re-
						// sources
		~Vector()       // destructor: release resources
		{ 
			delete[] elem; 
		} 
		
		Vector(const Vector& a); // copy constructor
		Vector& operator=(const Vector& a); // copy assignment
		
		double& operator[](int i);
		const double& operator[](int i) const;
		
		int size() const;
	private:
		double* elem; // elem points to an array of sz doubles
		int sz;
};
```

Подходящее определение конструктора копирования для `Vector` выделяет пространство для требуемого количества элементов, а затем копирует в него элементы так, чтобы после копирования каждый `Vector` имел свою собственную копию элементов:
```c++
Vector::Vector(const Vector& a) // copy constructor
	: elem{new double[a.sz]} // allocate space for elements
	, sz{a.sz}
{
	for (int i=0; i!=sz; ++i) // copy elements
		elem[i] = a.elem[i];
}
```

Результат примера` v2=v1` теперь может быть представлен в виде:
![[STL_15.png]]

Конечно, нам нужен оператор присваивания копированием в дополнение к конструктору копирования:
```c++
Vector& Vector::operator=(const Vector& a) // copy assignment
{
	double* p = new double[a.sz];
	
	for (int i=0; i!=a.sz; ++i)
		p[i] = a.elem[i];
		
	delete[] elem; // delete old elements
	
	elem = p;
	sz = a.sz;
	
	return *this;
}
```

Имя `this` предопределено в функциях-членах и указывает на объект, для которого вызывается функция-член.

Элементы были скопированы до того, как старые элементы были удалены, так что, если что-то пойдет не так с копией элемента и возникнет исключение, старое значение `Vector` будет сохранено.

## Перемещение контейнеров

Мы можем управлять копированием, определив конструктор копирования и оператор присваивания, но копирование может быть дорогостоящим для больших контейнеров. Мы избегаем затрат на копирование, когда передаем объекты в функции с помощью ссылок, но в результате мы не можем вернуть ссылку на локальный объект (локальный объект будет уничтожен к тому времени, когда вызывающий получит возможность взглянуть на него). Рассмотрим:
```c++
Vector operator+ (const Vector& a, const Vector& b)
{
	if (a.size() != b.size())
		throw Vector_size_mismatch{};
		
	Vector res(a.size());

	for (int i=0; i!=a.size(); ++i)
		res[i]=a[i]+b[i];
	
	return res;
}
```

Возврат из `+` включает копирование результата из локальной переменной `res` в какое-либо место, где вызывающий может получить к нему доступ. Мы могли бы использовать этот `+` следующим образом:
```c++
void f(const Vector& x, const Vector& y, const Vector& z)
{
	Vector r;

	...
	
	r = x+y+z;
	
	...
}
```

Это означало бы копирование `Vector` по крайней мере дважды (по одному для каждого использования оператора `+`). Если `Vector` большой, скажем, `10 000 double`, это может привести к затруднениям. Самая неприятная часть заключается в том, что `res` в `operator+()` больше никогда не используется после копирования. На самом деле нам не нужна была копия; мы просто хотели получить результат из функции: мы хотели переместить `Vector`, а не копировать его. К счастью, мы можем заявить об этом намерении:
```c++
class Vector {
	...

	Vector(const Vector& a);             // copy constructor
	Vector& operator=(const Vector& a);  // copy assignment
	Vector(Vector&& a);                  // move constructor
	Vector& operator=(Vector&& a);       // move assignment
};
```

Учитывая это определение, компилятор выберет конструктор перемещения для реализации передачи возвращаемого значения из функции. Это означает, что `r=x+y+z` не будет включать копирование объектов `Vector`. Вместо этого объекты `Vector` просто перемещаются.

Как обычно, конструктор перемещения `Vector` тривиален для определения:
```c++
Vector::Vector(Vector&& a)
	: elem{a.elem}         // "grab the elements" from a
	, sz{a.sz}
{
	a.elem = nullptr;      // now a has no elements
	a.sz = 0;
}
```

`&&` означает `“rvalue ссылка”` и является ссылкой, к которой мы можем привязать [[rvalue|rvalue]]. Слово `“rvalue”` предназначено для дополнения `“lvalue”`, что примерно означает “что-то, что может отображаться в левой части присваивания”. Таким образом, [[rvalue|rvalue]] – это – в первом приближении - значение, которому вы не можете присвоить значение, например, целое число, возвращаемое вызовом функции. Таким образом, [[rvalue|rvalue ссылка]] - это ссылка на что-то, чему никто другой не может присвоить значение, поэтому мы можем безопасно “украсть” его значение. Примером является локальная переменная `res` в `operator+()` для `Vector`.

Конструктор перемещения не принимает аргумент [[const|const]]: в конце концов, предполагается, что конструктор перемещения удаляет значение из своего аргумента. Оператор присвоения перемещением определяется аналогично.

Операция перемещения применяется, когда [[rvalue|rvalue]] ссылка используется в качестве инициализатора или в качестве правой части присваивания.

После перемещения исходный перемещенный объект должен находиться в состоянии, позволяющем запустить деструктор. Как правило, мы также разрешаем присвоение перемещенному объекту. [[Алгоритмы - STL|Алгоритмы стандартной библиотеки]] предполагают это. Наш `Vector` делает это.

Там, где программист знает, что значение больше не будет использоваться, но компилятор недостаточно умен, чтобы понять это, программист может дополнительно на это указать:
```c++
Vector f()
{
	Vector x(1000);
	Vector y(2000);
	Vector z(3000);

	z = x;              // we get a copy (x might be used later in f())
	y = std::move(x);   // we get a move (move assignment)

	...                 // better not use x here ...

	return z;           // we get a move
}
```

Функция стандартной библиотеки [[move|move()]] на самом деле ничего не перемещает. Вместо этого он возвращает ссылку на свой аргумент, для которой возможно перемещение – [[rvalue|rvalue]] ссылку; это своего рода [[Классы#Инициализация контейнеров|приведение]].

Непосредственно перед `return` у нас есть:
![[STL_16.png]]

Когда мы возвращаемся из `f()`, `z` уничтожается после того, как его элементы были перемещены из функции `f()` при `return`. А для `y` деструктор `delete[]` его элементы. 

Компилятор обязан (по стандарту C++) опимизировать большинство копирований, связанных с инициализацией, поэтому конструкторы перемещения вызываются не так часто, как вы могли бы себе представить. Такое исключение копирования устраняет даже очень незначительные накладные расходы. С другой стороны, обычно невозможно неявно исключить операции копирования или перемещения из присваиваний, поэтому присваивание перемещением может иметь решающее значение для производительности.

# Управление ресурсами

Определяя конструкторы, операции копирования, перемещения и деструктор, программист может обеспечить полный контроль над временем жизни содержащегося ресурса (например, элементов контейнера). Кроме того, конструктор перемещения позволяет объекту просто и дешево перемещаться из одной области видимости в другую. Таким образом, объекты, которые мы не можем или не хотели бы копировать из области видимости, могут быть просто и дешево перемещены вместо этого. Рассмотрим [[thread|thread]] стандартной библиотеки, представляющий [[Параллелизм-stl#Задачи и thread|параллельные вычисления]] и `Vector` из миллиона `double`. Мы не можем скопировать первое и не хотим  опировать второе.
```c++
std::vector<thread> my_threads;

Vector init(int n)
{
	thread t{heartbeat};    // run heartbeat concurrently (in a separate
							// thread)
	my_threads.push_back(std::move(t)); // move t into my_threads (§16.6)
							// ... more initialization ...
	Vector vec(n);
	for (auto& x : vec)
		x = 777;
	
	return vec;             // move vec out of init()
}

auto v = init(1 000 000);   // start heartbeat and initialize v
```

Дескрипторы ресурсов, такие как `Vector` и [[thread|thread]], во многих случаях являются превосходной альтернативой прямому использованию встроенных указателей. Фактически, “умные указатели” стандартной библиотеки, такие как [[unique_ptr|unique_ptr]], сами по себе являются дескрипторами ресурсов.

Я использовал [[vector|vector]] стандартной библиотеки для хранения [[thread|thread]], потому что мы не можем [[Template_STL#Параметризованные типы|параметризовать наш простой `Vector` с типом элемента]].

Почти таким же образом, как [[new|new]] и [[delete|delete]] исчезают из кода приложения, мы можем заставить указатели исчезнуть в дескрипторах ресурсов. В обоих случаях результатом является более простой и обслуживаемый код без дополнительных накладных расходов. В частности, мы можем добиться высокой безопасности ресурсов; то есть мы можем устранить утечки ресурсов для общего понятия ресурса. Примерами являются [[vector|vector]], содержащие память, [[thread|thread]], содержащие системные потоки, и [[STL/fstream|fstream]] содержащие дескрипторы файлов.

Во многих языках программирования управление ресурсами в первую очередь делегируется сборщику мусора. В C++ вы можете подключить сборщик мусора. Тем не менее, я считаю сборку мусора последним выбором после того, как были исчерпаны более чистые, общие и лучше локализованные альтернативы управлению ресурсами. Мой идеал - не создавать никакого мусора, тем самым устраняя необходимость в сборщике мусора: Не мусорьте!

Сборка мусора - это, по сути, глобальная схема управления памятью. Продуманные реализации могут компенсировать это, но по мере того, как системы становятся все более распределенными (например, кэши, многоядерные процессоры и кластеры), локальность становится более важной, чем когда-либо.

Кроме того, память - это не единственный ресурс. Ресурс - это все, что должно быть выделено и (явно или неявно) освобождено после использования. Примерами являются память, блокировки, сокеты, дескрипторы файлов и дескрипторы потоков. Неудивительно, что ресурс, который не является просто памятью, называется ресурсом, не являющимся памятью. Хорошая система управления ресурсами обрабатывает все виды ресурсов. В любой долго работающей системе необходимо избегать утечек, но чрезмерное удержание ресурсов может быть почти таким же вредным, как и утечка. Например, если система удерживает память, блокировки, файлы и т.д. в течение вдвое большего срока, система должна быть обеспечена потенциально вдвое большим количеством ресурсов.

Прежде чем прибегать к сборке мусора, систематически используйте дескрипторы ресурсов: пусть у каждого ресурса есть владелец в некоторой области видимости и по умолчанию он будет освобожден в конце области видимости его владельца. В C++ это известно, как идиома RAII (получение ресурсов - это инициализация) и интегрировано с обработкой ошибок в виде исключений. Ресурсы могут быть перемещены в другую область видимости, используя [[move|move]]-семантику или “умные указатели”, а совместное владение может быть представлено [[shared_ptr|“общими указателями (shared pointer)”]].

В стандартной библиотеке C++ RAII широко распространена: например, для памяти ([[string|string]], [[vector|vector]], [[map|map]], [[unordered_map|unordered_map]] и т.д.), файлов ([[fstream#ifstream|ifstream]], [[fstream#ofstream|ofstream]] и т.д.), потоков ([[thread|thread]]), блокировок ([[lock#Тип std lock_guard|lock_guard]], [[lock#Тип std unique_lock|unique_lock]] и т.д.) и общих объектов (через [[unique_ptr|unique_ptr]] и [[shared_ptr|shared_ptr]]). Результатом является неявное управление ресурсами, которое незаметно при обычном использовании и приводит к низкой продолжительности удержания ресурсов.

# Перегрузка операторов

Мы можем придать смысл операторам C++ для пользовательских типов ([[enum|enum(Перечисления)]], [[Классы#Арифметические типы|арифметических типов]]). Это называется перегрузкой оператора, потому что при использовании правильная реализация оператора должна быть выбрана из набора операторов с таким же именем. Например, наш `+` для  [[Классы#Арифметические типы|комплексных чисел в z1+z2]] следует отличать от `+` для [[Программы - STL#Арифметика|целых]] и `+` для [[Программы - STL#Арифметика|чисел с плавающей запятой]].

Невозможно определить новые операторы, например, мы не можем определить операторы `^^`, `===`, `**`, `$`, или унарный `%`. Допущение этого вызвало бы столько же путаницы, сколько и пользы.

Настоятельно рекомендуется определять операторы с обычной семантикой. Например, оператор `+`, который вычитает, никому не принесет никакой пользы.

Мы можем определять операторы для пользовательских типов (классов и перечислений):
> 
> Бинарные арифметические операторы: `+`, `-`, `*`, `/`, и `%`
> 
>  Бинарные логические операторы: `&` (побитовое И), `|` (побитовое ИЛИ), и `^` (побитовое исключающее ИЛИ)
>  
> Бинарные операторы сравнения: `==`, `!=`, `<`, `<=`, `>`, `>=`, и `<=>`
> 
> Логические операторы: `&&` и `||`
> 
> Унарные арифметические и логические операторы: `+`, `-`, `~` (побитовое НЕ) и `!` (логическое отрицание)
> 
> Присваивание: `=`, `+=`, `*=` и т.д.
> 
> Инкремент и декремент: `++` и `--`
> 
> Операции с указателями: `->`, унарная `*`, и унарный `&`
> 
> Вызов: ()
> 
> Обращение к элементу: []
> 
> Запятая: ,
> 
> Сдвиг: `>>` и `<<`

К сожалению, мы не можем переопределить оператор точка (`.`) для получения интеллектуальных ссылок.

Оператор может быть определен как функция-член:
```c++
class Matrix {
	...
	
	Matrix& operator=(const Matrix& a);     // assign m to *this; 
			                                // return a reference to *this
};
```

Обычно это делается для операторов, которые изменяют свой первый операнд, и по историческим причинам требуется для `=`, `->`, `()` и `[ ]`.

В качестве альтернативы, большинство операторов могут быть определены как автономные функции вне класса:
```c++
Matrix operator+ (const Matrix& m1, const Matrix& m2);  // assign m1 to m2 
														// and return the sum
```

Принято определять операторы с симметричными операндами как самостоятельные функции, чтобы оба операнда обрабатывались одинаково. Чтобы получить хорошую производительность при возврате потенциально большого объекта, такого как `Matrix`, мы полагаемся на [[Основные операции#Перемещение контейнеров|семантику перемещения]].

# Стандартные операции

Некоторые операции имеют общепринятое значение, когда они определены для типа. Эти общепринятые значения часто используются программистами и библиотеками (в частности, стандартной библиотекой), поэтому разумно придерживаться их при разработке новых типов, для которых операции имеют смысл.
>
> [[Операторы сравнения|Сравнение]]: `==`, `!=`, `<`, `<=`, `>`, `>=` и `<=>`
> 
>  Операторы контейнеров: [[size|size()]], [[begin|begin()]] и [[end|end()]] ( #§6_5_2)
>  
> [[iterator#Типы итераторов|Итераторы]] и [[Указатели#unique_ptr и shared_ptr|“умные указатели”]]: `->`, `*`, `[]`, `++`, `--`, `+`, `-`, `+=` и `-=` 
> 
> [[Template_STL#Функциональные объекты|Функции]]: `()`
> 
> [[Основные операции#Операции ввода-вывода|Операции ввода-вывода]]: `>>` и `<<`
> 
> [[swap|swap()]]
> 
> Хэш-функции: [[hash|hash<>]]

## Операторы сравнения

[[Операторы сравнения|см. тут]]

## Операции с контейнерами

[[Операции с контейнерами|см. тут]]

## Итераторы и “умные указатели”

[[iterator#Типы итераторов|Определяемые пользователем итераторы]] и [[Указатели#unique_ptr и shared_ptr|“умные указатели”]] реализуют операторы и аспекты указателя, необходимые для их целей, и часто добавляют семантику по мере необходимости.
>
> Доступ: `*`, `->` (для класса), и `[]` (для контейнера)
> 
> Итерация/навигация: `++` (вперёд), `--` (назад), `+=`, `-=`, `+` и `-`
> 
> Копирование и/или перемещение: `=`

## Операции ввода-вывода

Для пар целых чисел `<<` означает сдвиг влево, а `>>` означает сдвиг вправо. Однако для [[iostream|iostream]] они являются [[Программы - STL#Условные операторы|операторами вывода и ввода данных]] соответственно. Для получения [[Ввод и вывод - STL#Ввод и вывод|подробной информации и дополнительных операций ввода-вывода]].

## swap()

[[swap|см. тут]]

## hash<>

[[hash|см. тут]]

# Пользовательские литералы

Одна из целей классов состояла в том, чтобы позволить программисту разрабатывать и реализовывать типы, максимально имитирующие встроенные типы. Конструкторы обеспечивают инициализацию, которая равна или превосходит по гибкости и эффективности инициализацию встроенных типов, а для встроенных типов у нас есть литералы:
>
> `123` как пример `int`.
> 
> `0xFF00u` как пример `unsigned int`.
> 
> `123.456` в качестве `double`.
> 
> `"Surprise!"` как `const char[10]`.

Может быть полезно предоставить такие литералы и для пользовательского типа. Это делается путем определения значения подходящего к литералу суффикса, так что мы можем получить
>
> `"Surprise!"s` является [[string|std::string]].
> 
> `123s` это `second`.
> 
> `12.7i` это [[imaginary|imaginary]] такое что `12.7i+47` является [[complex|complex]] числом (например, {`47,12.7`}).

В частности, мы можем получить эти примеры из стандартной библиотеки, используя подходящие заголовки и пространства имен:
Суффиксы стандартной библиотеки для литералов:

| [[chrono\|<chrono>]]           | `std::literals::chrono_literals`  | ***h, min, s, ms, us, ns*** |
| ------------------------------ | --------------------------------- | --------------------------- |
| [[string\|<string>]]           | `std::literals::string_literals`  | ***s***                     |
| [[string_view\|<string_view>]] | `std::literals::string_literals`  | ***sv***                    |
| [[complex\|<complex>]]         | `std::literals::complex_literals` | ***i, il, if***             |

Литералы с пользовательскими суффиксами называются ***пользовательскими литералами*** или UDL. Такие литералы определяются с помощью ***литеральных операторов***. Литеральный оператор преобразует литерал, переданный как аргумент, за которым следует суффикс, в возвращаемый тип. Например, `i` для [[imaginary|imaginary]] суффикса может быть реализован следующим образом:
```c++
constexpr complex<double> operator""i(long double arg) // imaginary literal
{
	return {0, arg};
}
```

Где
> `operator""` указывает на то, что мы определяем литеральный оператор.
> 
> `i` после литерального индикатора `""` является суффиксом, которому оператор придает значение.
> 
> Тип аргумента `long double` указывает, что суффикс (`i`) определяется для литерала с плавающей запятой.
> 
> Тип возвращаемого значения `complex<double>`, определяет тип результирующего литерала.

Учитывая это, мы можем написать
```c++
complex<double> z = 2.7182818+6.283185i;
```

Реализация суффикса `i` и `+` оба являются [[constexpr|constexpr]], поэтому вычисление значения `z` выполняется во время компиляции.
