
Модульность]
1. [[#Введение|Введение]] 3.1
2. [[#Раздельная компиляция|Раздельная компиляция]] 3.2
	1. [[#Заголовочные файлы|Заголовочные файлы]] 3.2.1
	2. [[#Модули|Модули]] 3.2.2
3. [[#Пространства имён|Пространства имён]] 3.3
4. [[#Аргументы функции и возвращаемые значения|Аргументы функции и возвращаемые значения]] 3.4
	1. [[#Передача аргументов|Передача аргументов]] 3.4.1
	2. [[#Возвращение значений|Возвращение значений]] 3.4.2


# Введение

Программа на C++ состоит из множества отдельно разработанных частей, таких как [[#Функции|функции]], [[Пользовательские типы|пользовательские типы]], иерархии классов ( #§5_5) и [[templates|шаблоны]]. Ключом к управлению таким множеством частей является четкое определение взаимодействий между этими частями. Первым и наиболее важным шагом является разделение интерфейса к части и ее реализации. На уровне языка C++ интерфейсы представлены с помощью объявлений. Объявление определяет все, что необходимо для использования функции или типа. Например:
```c++
double sqrt(double);    // the square root function takes a 
						//double and returns a double

class Vector { // what is needed to use a Vector
	public:
		Vector(int s);
		double& operator[](int i);
		int size();
	
	private:
		double* elem; // elem points to an array of sz doubles
		int sz;
};
```

Ключевым моментом здесь является то, что тела функций, определения функций, могут находиться “в другом месте”. В этом примере мы могли бы пожелать, чтобы представление `Vector` также было “в другом месте”, но мы разберемся с этим позже (говоря об абстрактных типах; #§5_3). Определение `sqrt()` будет выглядеть следующим образом:
```c++
double sqrt(double d) // definition of sqrt()
{
	// ... algorithm as found in math textbook ...
}
```

Для `Vector` нам нужно определить все три функции-члена:
```c++
Vector::Vector(int s)        // definition of the constructor
:elem{new double[s]}, sz{s}  // initialize members
{
	...
}

double& Vector::operator[](int i) // definition of subscripting
{
	return elem[i];
}

int Vector::size() // definition of size()
{
	return sz;
}
```

Мы должны определить функции `Vector`, но не `sqrt()`, потому что это часть стандартной библиотеки. Однако реальной разницы нет: библиотека - это просто “какой-то другой код, который мы используем при необходимости”, написанный с использованием тех же языковых средств, которые используем мы.

Для объекта, такого как функция, может быть много объявлений, но только одно определение.

## Раздельная компиляция

C++ поддерживает концепцию раздельной компиляции, когда пользовательский код видит только объявления используемых типов и функций. Это можно сделать двумя способами:
>
> **[[#Заголовочные файлы|Заголовочные файлы]]**: Поместите объявления в отдельные файлы, называемые заголовочными файлами, и буквально `#include`(включите) заголовочный файл там, где необходимы его объявления.
> 
> **[[Module#Модули|Модули]]**: Определите файлы модулей `module`, скомпилируйте их отдельно и импортируйте `import` их при необходимости. Код, импортирующий `import` модуль `module`, видит только явно экспортированные `export` объявления.

Любой из них может быть использован для организации программы в набор полунезависимых фрагментов кода. Такое разделение может быть использовано для минимизации времени компиляции и обеспечения разделения логически различных частей программы (таким образом, сводя к минимуму вероятность ошибок). Библиотека часто представляет собой набор отдельно скомпилированных фрагментов кода (например, функций).

Метод организации кода с использованием заголовочных файлов восходит к самым ранним дням Cи и до сих пор остается наиболее распространенным. Использование модулей является новым в C++20 и дает огромные преимущества в плане гигиены кода и времени компиляции.

### Заголовочные файлы

Традиционно мы помещаем объявления, указывающие интерфейс к фрагменту кода, который мы рассматриваем как модуль, в файл с именем, указывающим на его предполагаемое использование. Например:
```c++
// Vector.h:
class Vector {
	public:
		Vector(int s);
		double& operator[](int i);
		int size();
	
	private:
		double* elem; // elem points to an array of sz doubles
		int sz;
};
```

Это объявление размещено в файле `Vector.h`. Затем пользователи `#include` этот файл, называемый заголовочным файлом, для доступа к этому интерфейсу. Например:
```c++
// user.cpp:

#include "Vector.h" // get Vector's interface
#include <cmath>    // get the standard-library math function
					// interface including sqrt()

double sqrt_sum(const Vector& v)
{
	double sum = 0;
	
	for (int i=0; i!=v.size(); ++i)
		sum+=std::sqrt(v[i]); // sum of square roots

	return sum;
}
```

Чтобы помочь компилятору обеспечить согласованность, файл `.cpp`, предоставляющий реализацию `Vector`, также будет включать файл `.h`, предоставляющий его интерфейс:
```c++
// Vector.cpp:

#include "Vector.h"           // get Vector's interface
Vector::Vector(int s)
:elem{new double[s]}, sz{s}   // initialize members
{
	...
}

double& Vector::operator[](int i)
{
	return elem[i];
}

int Vector::size()
{
	return sz;
}
```

Код в `user.cpp` и `Vector.cpp` оба используют информацию об интерфейсе `Vector`, представленную в `Vector.h`, но в остальном эти два файла независимы и могут быть скомпилированы отдельно. Графически фрагменты программы можно представить следующим образом:
![[STL_9.png]]

Наилучший подход к организации программы - представлять ее как набор модулей с четко определенными зависимостями. Заголовочные файлы представляют эту модульность с помощью файлов, а затем используют эту модульность посредством раздельной компиляции.

Файл `.cpp`, который компилируется сам по себе (включая `h`-файлы, которые он `#include`), называется единицей трансляции. Программа может состоять из тысяч единиц трансляции.

Использование заголовочных файлов и `#include` - это очень старый способ имитации модульности со значительными недостатками:
>
> **Время компиляции**: Если вы `#include header.h` в 101 единицу трансляции, текст `header.h` будет обработан компилятором 101 раз
> 
> **Зависимость от порядка**: Если мы включаем `#include header1.h` перед `header2.h`, то объявления и макросы ( #§19_3_2_1) в `header1.h` могут повлиять на код в `header2.h`. Если вместо этого вы включите `#include header2.h` перед `header1.h`, то уже `header2.h` может повлиять на код в `header1.h`.
> 
> **Несоответствия**: Определение объекта, такого как тип или функция, в одном файле, а затем определение его немного по-другому в другом файле может привести к сбоям или незначительным ошибкам. Это может произойти, если мы – случайно или намеренно – объявим объект отдельно в двух исходных файлах, вместо того, чтобы поместить его в заголовок, или из-за зависимостей от порядка включения между различными файлами заголовков.
> 
> **Транзитивность**: весь код, необходимый для объявления в заголовочном файле, должен присутствовать в этом заголовочном файле. Это приводит к массовому раздуванию кода, поскольку заголовочные файлы `#include` в себя другие заголовки, и это приводит к тому, что пользователь заголовочного файла – случайно или намеренно – становится зависимым от таких деталей реализации.

Очевидно, что это не идеально, и этот метод был основным источником трат времени на компиляцию и ошибок с тех пор, как он был впервые введен в C в начале 1970-х годов. Однако использование заголовочных файлов было жизнеспособным на протяжении десятилетий, и старый код, использующий `#include`, будет “жить” очень долго, потому что обновление больших программ может быть дорогостоящим и отнимать много времени.

### Модули

[[Module#Модули|см. Модули]]

## Пространства имён

[[namespace#namespace (Пространства имён)|см. namespace (Пространства имён)]]

## Аргументы функции и возвращаемые значения

Основным и рекомендуемым способом передачи информации из одной части программы в другую является вызов функции. Информация, необходимая для выполнения задачи, передается в качестве аргументов функции, а полученные результаты передаются обратно в виде возвращаемых значений. Например:
```c++
int sum(const vector<int>& v)
{
	int s = 0;
	
	for (const int i : v)
		s += i;
	
	return s;
}

vector fib = {1, 2, 3, 5, 8, 13, 21};
int x = sum(fib);     // x becomes 53
```

Существуют и другие пути передачи информации между функциями, такие как [[Программы - STL#Область видимости и время жизни|глобальные переменные]] и общее состояние в объекте класса ( #глава_5). Глобальные переменные настоятельно не рекомендуются как известный источник ошибок, а общее состояние, как правило, должно использоваться только функциями, совместно реализующими четко определенную абстракцию (например, [[Пользовательские типы#Классы|функции-члены класса]]).

Учитывая важность передачи информации в функции и из них, неудивительно, что существует множество способов сделать это. Ключевыми проблемами являются:
>
> Является ли объект копируемым или используется совместно?
> 
> Если объект используется совместно, может ли он изменяться?
> 
> Если объект перемещается, остаётся ли после этого “пустой объект” ( #§6_2_2)?

По умолчанию [[Программы - STL#Сопоставление с аппаратным обеспечением|как при передаче аргументов, так и при возврате значения - “создаётся копия”]], но многие копии могут быть неявно оптимизированы для перемещения.

В примере `sum()` результирующий `int` копируется из `sum(),` но было бы неэффективно и бессмысленно копировать потенциально очень большой [[vector|vector]] в `sum()`, поэтому [[Программы - STL#Указатели, Массивы и Ссылки|аргумент передается по ссылке]] .

У `sum()` нет причин изменять свой аргумент. Эта неизменяемость указывается объявлением аргумента [[vector|vector]] как [[const|const]], поэтому [[vector|vector]] передается по `const-ссылке`.

### Передача аргументов

Сначала рассмотрим, как передать значения в функцию. По умолчанию мы копируем (“передаём по значению”), но, если мы хотим сослаться на объект в среде вызывающего объекта, мы используем ссылку (“передаём по ссылке”). Например:
```c++
void test(vector<int> v, vector<int>& rv)   // v is passed by value;
{                                           // rv is passed by reference
	v[1] = 99;                              // modify v (a local variable)
	rv[2] = 66;                             // modify whatever rv refers to
}

int main()
{
	vector fib = {1, 2, 3, 5, 8, 13, 21};
	test(fib,fib);
	cout << fib[1] <<'' << fib[2] << '\n'; // prints 2 66
}
```

Когда мы заботимся о производительности, мы обычно передаем малые значения по значению, а большие - по ссылке. Здесь “малые” означает “что-то, что действительно дешево скопировать”. Что именно означает “малый”, зависит от архитектуры машины; “размер двух-трех указателей или меньше” - хорошее эмпирическое правило. Если для вас важна производительность, измерьте разные варианты и выберите лучший.

Если мы хотим передать аргументы по ссылке из соображений производительности, но нам не нужно их изменять, мы передаем по [[const|const-ссылке]], как в примере `sum()`. Это, безусловно, самый распространенный случай в обычном хорошем коде: он быстр и не подвержен ошибкам.

Нередко аргумент функции имеет значение по умолчанию, то есть значение, которое считается предпочтительным или просто наиболее распространенным. Мы можем указать такое значение с помощью аргумента функции по умолчанию. Например:
```c++
void print(int value, int base = 10); // print value in base "base"

print(x,16); // hexadecimal
print(x,60); // sexagesimal (Sumerian)
print(x); // use the default: decimal
```

Это более простая в обозначениях альтернатива перегрузке:
```c++
void print(int value, int base); // print value in base "base"

void print(int value) // print value in base 10
{
	print(value, 10);
}
```

Использование аргументов по умолчанию означает, что существует только одно определение функции. Обычно это хорошо для понимания и размера кода. Когда нам нужен разный код для реализации одной и той же семантики для разных типов, то лучше использовать перегрузку.

### Возвращение значений

Как только мы вычислили результат, нам нужно извлечь его из функции и вернуть вызывающему. Опять же, по умолчанию для возврата значения используется копирование, и для небольших объектов это идеально. Мы возвращаем “по ссылке” только то-












