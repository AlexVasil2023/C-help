
Модульность
1. [[#Введение|Введение]] 3.1
2. [[#Раздельная компиляция|Раздельная компиляция]] 3.2
	1. [[#Заголовочные файлы|Заголовочные файлы]] 3.2.1
	2. [[#Модули|Модули]] 3.2.2
3. [[#Пространства имён|Пространства имён]] 3.3
4. [[#Аргументы функции и возвращаемые значения|Аргументы функции и возвращаемые значения]] 3.4
	1. [[#Передача аргументов|Передача аргументов]] 3.4.1
	2. [[#Возвращение значений|Возвращение значений]] 3.4.2
	3. [[#Выведение типа возвращаемого значения|Выведение типа возвращаемого значения]] 3.4.3
	4. [[#Суффиксная запись типа возвращаемого значения|Суффиксная запись типа возвращаемого значения]] 3.4.4
	5. [[#Структурное связывание|Структурное связывание]] 3.4.5

# Введение

Программа на C++ состоит из множества отдельно разработанных частей, таких как [[#Функции|функции]], [[Пользовательские типы|пользовательские типы]], иерархии классов ( #§5_5) и [[templates|шаблоны]]. Ключом к управлению таким множеством частей является четкое определение взаимодействий между этими частями. Первым и наиболее важным шагом является разделение интерфейса к части и ее реализации. На уровне языка C++ интерфейсы представлены с помощью объявлений. Объявление определяет все, что необходимо для использования функции или типа. Например:
```c++
double sqrt(double);    // the square root function takes a 
						//double and returns a double

class Vector { // what is needed to use a Vector
	public:
		Vector(int s);
		double& operator[](int i);
		int size();
	
	private:
		double* elem; // elem points to an array of sz doubles
		int sz;
};
```

Ключевым моментом здесь является то, что тела функций, определения функций, могут находиться “в другом месте”. В этом примере мы могли бы пожелать, чтобы представление `Vector` также было “в другом месте”, но мы разберемся с этим позже (говоря об абстрактных типах; #§5_3). Определение `sqrt()` будет выглядеть следующим образом:
```c++
double sqrt(double d) // definition of sqrt()
{
	// ... algorithm as found in math textbook ...
}
```

Для `Vector` нам нужно определить все три функции-члена:
```c++
Vector::Vector(int s)        // definition of the constructor
:elem{new double[s]}, sz{s}  // initialize members
{
	...
}

double& Vector::operator[](int i) // definition of subscripting
{
	return elem[i];
}

int Vector::size() // definition of size()
{
	return sz;
}
```

Мы должны определить функции `Vector`, но не `sqrt()`, потому что это часть стандартной библиотеки. Однако реальной разницы нет: библиотека - это просто “какой-то другой код, который мы используем при необходимости”, написанный с использованием тех же языковых средств, которые используем мы.

Для объекта, такого как функция, может быть много объявлений, но только одно определение.

## Раздельная компиляция

C++ поддерживает концепцию раздельной компиляции, когда пользовательский код видит только объявления используемых типов и функций. Это можно сделать двумя способами:
>
> **[[#Заголовочные файлы|Заголовочные файлы]]**: Поместите объявления в отдельные файлы, называемые заголовочными файлами, и буквально `#include`(включите) заголовочный файл там, где необходимы его объявления.
> 
> **[[Module#Модули|Модули]]**: Определите файлы модулей `module`, скомпилируйте их отдельно и импортируйте `import` их при необходимости. Код, импортирующий `import` модуль `module`, видит только явно экспортированные `export` объявления.

Любой из них может быть использован для организации программы в набор полунезависимых фрагментов кода. Такое разделение может быть использовано для минимизации времени компиляции и обеспечения разделения логически различных частей программы (таким образом, сводя к минимуму вероятность ошибок). Библиотека часто представляет собой набор отдельно скомпилированных фрагментов кода (например, функций).

Метод организации кода с использованием заголовочных файлов восходит к самым ранним дням Cи и до сих пор остается наиболее распространенным. Использование модулей является новым в C++20 и дает огромные преимущества в плане гигиены кода и времени компиляции.

### Заголовочные файлы

Традиционно мы помещаем объявления, указывающие интерфейс к фрагменту кода, который мы рассматриваем как модуль, в файл с именем, указывающим на его предполагаемое использование. Например:
```c++
// Vector.h:
class Vector {
	public:
		Vector(int s);
		double& operator[](int i);
		int size();
	
	private:
		double* elem; // elem points to an array of sz doubles
		int sz;
};
```

Это объявление размещено в файле `Vector.h`. Затем пользователи `#include` этот файл, называемый заголовочным файлом, для доступа к этому интерфейсу. Например:
```c++
// user.cpp:

#include "Vector.h" // get Vector's interface
#include <cmath>    // get the standard-library math function
					// interface including sqrt()

double sqrt_sum(const Vector& v)
{
	double sum = 0;
	
	for (int i=0; i!=v.size(); ++i)
		sum+=std::sqrt(v[i]); // sum of square roots

	return sum;
}
```

Чтобы помочь компилятору обеспечить согласованность, файл `.cpp`, предоставляющий реализацию `Vector`, также будет включать файл `.h`, предоставляющий его интерфейс:
```c++
// Vector.cpp:

#include "Vector.h"           // get Vector's interface
Vector::Vector(int s)
:elem{new double[s]}, sz{s}   // initialize members
{
	...
}

double& Vector::operator[](int i)
{
	return elem[i];
}

int Vector::size()
{
	return sz;
}
```

Код в `user.cpp` и `Vector.cpp` оба используют информацию об интерфейсе `Vector`, представленную в `Vector.h`, но в остальном эти два файла независимы и могут быть скомпилированы отдельно. Графически фрагменты программы можно представить следующим образом:
![[STL_9.png]]

Наилучший подход к организации программы - представлять ее как набор модулей с четко определенными зависимостями. Заголовочные файлы представляют эту модульность с помощью файлов, а затем используют эту модульность посредством раздельной компиляции.

Файл `.cpp`, который компилируется сам по себе (включая `h`-файлы, которые он `#include`), называется единицей трансляции. Программа может состоять из тысяч единиц трансляции.

Использование заголовочных файлов и `#include` - это очень старый способ имитации модульности со значительными недостатками:
>
> **Время компиляции**: Если вы `#include header.h` в 101 единицу трансляции, текст `header.h` будет обработан компилятором 101 раз
> 
> **Зависимость от порядка**: Если мы включаем `#include header1.h` перед `header2.h`, то объявления и макросы ( #§19_3_2_1) в `header1.h` могут повлиять на код в `header2.h`. Если вместо этого вы включите `#include header2.h` перед `header1.h`, то уже `header2.h` может повлиять на код в `header1.h`.
> 
> **Несоответствия**: Определение объекта, такого как тип или функция, в одном файле, а затем определение его немного по-другому в другом файле может привести к сбоям или незначительным ошибкам. Это может произойти, если мы – случайно или намеренно – объявим объект отдельно в двух исходных файлах, вместо того, чтобы поместить его в заголовок, или из-за зависимостей от порядка включения между различными файлами заголовков.
> 
> **Транзитивность**: весь код, необходимый для объявления в заголовочном файле, должен присутствовать в этом заголовочном файле. Это приводит к массовому раздуванию кода, поскольку заголовочные файлы `#include` в себя другие заголовки, и это приводит к тому, что пользователь заголовочного файла – случайно или намеренно – становится зависимым от таких деталей реализации.

Очевидно, что это не идеально, и этот метод был основным источником трат времени на компиляцию и ошибок с тех пор, как он был впервые введен в C в начале 1970-х годов. Однако использование заголовочных файлов было жизнеспособным на протяжении десятилетий, и старый код, использующий `#include`, будет “жить” очень долго, потому что обновление больших программ может быть дорогостоящим и отнимать много времени.

### Модули

[[Module#Модули|см. Модули]]

## Пространства имён

[[namespace#namespace (Пространства имён)|см. namespace (Пространства имён)]]

## Аргументы функции и возвращаемые значения

Основным и рекомендуемым способом передачи информации из одной части программы в другую является вызов функции. Информация, необходимая для выполнения задачи, передается в качестве аргументов функции, а полученные результаты передаются обратно в виде возвращаемых значений. Например:
```c++
int sum(const vector<int>& v)
{
	int s = 0;
	
	for (const int i : v)
		s += i;
	
	return s;
}

vector fib = {1, 2, 3, 5, 8, 13, 21};
int x = sum(fib);     // x becomes 53
```

Существуют и другие пути передачи информации между функциями, такие как [[Программы - STL#Область видимости и время жизни|глобальные переменные]] и общее состояние в объекте класса ( #глава_5). Глобальные переменные настоятельно не рекомендуются как известный источник ошибок, а общее состояние, как правило, должно использоваться только функциями, совместно реализующими четко определенную абстракцию (например, [[Пользовательские типы#Классы|функции-члены класса]]).

Учитывая важность передачи информации в функции и из них, неудивительно, что существует множество способов сделать это. Ключевыми проблемами являются:
>
> Является ли объект копируемым или используется совместно?
> 
> Если объект используется совместно, может ли он изменяться?
> 
> Если объект перемещается, остаётся ли после этого “пустой объект” ( #§6_2_2)?

По умолчанию [[Программы - STL#Сопоставление с аппаратным обеспечением|как при передаче аргументов, так и при возврате значения - “создаётся копия”]], но многие копии могут быть неявно оптимизированы для перемещения.

В примере `sum()` результирующий `int` копируется из `sum(),` но было бы неэффективно и бессмысленно копировать потенциально очень большой [[vector|vector]] в `sum()`, поэтому [[Программы - STL#Указатели, Массивы и Ссылки|аргумент передается по ссылке]] .

У `sum()` нет причин изменять свой аргумент. Эта неизменяемость указывается объявлением аргумента [[vector|vector]] как [[const|const]], поэтому [[vector|vector]] передается по `const-ссылке`.

### Передача аргументов

Сначала рассмотрим, как передать значения в функцию. По умолчанию мы копируем (“передаём по значению”), но, если мы хотим сослаться на объект в среде вызывающего объекта, мы используем ссылку (“передаём по ссылке”). Например:
```c++
void test(vector<int> v, vector<int>& rv)   // v is passed by value;
{                                           // rv is passed by reference
	v[1] = 99;                              // modify v (a local variable)
	rv[2] = 66;                             // modify whatever rv refers to
}

int main()
{
	vector fib = {1, 2, 3, 5, 8, 13, 21};
	test(fib,fib);
	cout << fib[1] <<'' << fib[2] << '\n'; // prints 2 66
}
```

Когда мы заботимся о производительности, мы обычно передаем малые значения по значению, а большие - по ссылке. Здесь “малые” означает “что-то, что действительно дешево скопировать”. Что именно означает “малый”, зависит от архитектуры машины; “размер двух-трех указателей или меньше” - хорошее эмпирическое правило. Если для вас важна производительность, измерьте разные варианты и выберите лучший.

Если мы хотим передать аргументы по ссылке из соображений производительности, но нам не нужно их изменять, мы передаем по [[const|const-ссылке]], как в примере `sum()`. Это, безусловно, самый распространенный случай в обычном хорошем коде: он быстр и не подвержен ошибкам.

Нередко аргумент функции имеет значение по умолчанию, то есть значение, которое считается предпочтительным или просто наиболее распространенным. Мы можем указать такое значение с помощью аргумента функции по умолчанию. Например:
```c++
void print(int value, int base = 10); // print value in base "base"

print(x,16); // hexadecimal
print(x,60); // sexagesimal (Sumerian)
print(x); // use the default: decimal
```

Это более простая в обозначениях альтернатива перегрузке:
```c++
void print(int value, int base); // print value in base "base"

void print(int value) // print value in base 10
{
	print(value, 10);
}
```

Использование аргументов по умолчанию означает, что существует только одно определение функции. Обычно это хорошо для понимания и размера кода. Когда нам нужен разный код для реализации одной и той же семантики для разных типов, то лучше использовать перегрузку.

### Возвращение значений

Как только мы вычислили результат, нам нужно извлечь его из функции и вернуть вызывающему. Опять же, по умолчанию для возврата значения используется копирование, и для небольших объектов это идеально. Мы возвращаем “по ссылке” только тогда, когда хотим предоставить вызывающему доступ к чему-то, что не является локальным для функции. Например, `Vector` может предоставить пользователю доступ к элементу посредством оператора индекса:
```c++
class Vector {
	public:
		...
		
		double& operator[](int i) 
			{ return elem[i]; }  // return reference to ith element
	
	private:
		double* elem;            // elem points to an array of sz
	
	...
};
```

i-й элемент `Vector` существует независимо от вызова оператора индекса, поэтому мы можем вернуть ссылку на него.

С другой стороны, локальная переменная исчезает при возврате функции, поэтому мы не должны возвращать указатель или ссылку на нее:
```c++
int& bad()
{
	int x;

	 ...
	
	return x;         // bad: return a reference to the local variable x
}
```

К счастью, все основные компиляторы C++ обнаружат очевидную ошибку в `bad()`.

Возврат ссылки или значения “малого” типа эффективен, но как передавать большие объемы информации из функции? Рассмотрим:
```c++
Matrix operator+(const Matrix& x, const Matrix& y)
{
	Matrix res;
	// ... for all res[i,j], res[i,j] = x[i,j]+y[i,j] ...
	return res;
}

Matrix m1, m2;

...

Matrix m3 = m1 + m2; // no copy
```

[[Matrix|Matrix]] может быть очень большой и дорогостоящей для копирования даже на современном аппаратном обеспечении. Поэтому чтобы избежать копирования, мы даем [[Matrix|Matrix]] конструктор перемещения ( #§6_2_2), который очень дешево возвращает [[Matrix|Matrix]] из `operator+()`. Даже если мы не определяем конструктор перемещения, компилятор часто способен оптимизировать копирование (исключить копирование) и построить [[Matrix|Matrix]] именно там, где это необходимо. Это называется пропуском копирования (copy elision).

Мы не должны скатываться к ручному управлению памятью:
```c++
Matrix* add(const Matrix& x, const Matrix& y) // complicated and error-prone
{                                             // 20th century style
	Matrix* p = new Matrix;
	// ... for all *p[i,j], *p[i,j] = x[i,j]+y[i,j] ...
	return p;
}

Matrix m1, m2;

...

Matrix* m3 = add(m1,m2);                      // just copy a pointer

...

delete m3;                                    // easily forgotten
```

К сожалению, возврат большого объекта путем передачи указателя на него является распространенным явлением в старом коде и основным источником трудноисправимых ошибок. Не пишите такой код! `Matrix operator+()` по крайней мере так же эффективен, как `Matrix add()`, но гораздо проще в определении, проще в использовании и менее подвержен ошибкам.

Если функция не может выполнить требуемую от нее задачу, она может выдать исключение  ( #§4_2). Это может помочь избежать засорения кода проверками кодов ошибок для выявления “исключительных проблем”.

### Выведение типа возвращаемого значения

Тип возвращаемого значения функции может быть выведен из ее возвращаемого значения. Например:
```c++
auto mul(int i, double d) { return i*d; } // here, "auto" means "deduce
										  // the return type"
```

Это может быть удобно, особенно для универсальных функций ( #§7_3_1) и лямбд( #§7_3_3), но использовать их следует осторожно, поскольку выведенный тип не обеспечивает стабильного интерфейса: изменение реализации функции (или лямбда-выражения) может изменить ее тип.

### Суффиксная запись типа возвращаемого значения

Почему возвращаемый тип указывается перед именем и аргументами функции? Причина в основном историческая. Именно так это делали Fortran, C и Simula (и делают до сих пор). Однако иногда нам нужно посмотреть на аргументы, чтобы определить тип результата. Выведение возвращаемого типа - один из примеров этого, но не единственный. В примерах, выходящих за рамки этой книги, проблема возникает в связи с [[namespace#namespace (Пространства имён)|пространствами имен]], лямбдами ( #§7_3_3) и концептами ( #§8_2). Следовательно, мы разрешаем добавлять возвращаемый тип после списка аргументов, где мы хотим четко указать возвращаемый тип. Это делает [[auto|auto]] означающим “возвращаемый тип будет упомянут позже или будет выведен”. Например:
```c++
// the return type is "double"
auto mul(int i, double d) -> double { return i*d; } 
```

Как и [[Инициализация#Инициализация|в случае с переменными]], мы можем использовать это обозначение для более аккуратного выстраивания имен. Сравните это использование суффиксной записи возвращаемых типов [[#Функции|с версией]]:
```c++
auto next_elem() -> Elem*;
auto exit(int) -> void;
auto sqrt(double) -> double;
```

Я нахожу суффиксную запись возвращаемого типа с более логичной, чем традиционную префиксную, но поскольку подавляющее большинство кода использует традиционное обозначение, я придерживаюсь его в этой книге.

### Структурное связывание

Функция может возвращать только одно значение, но это значение может быть объектом класса со многими членами. Это позволяет нам элегантно возвращать множество значений. Например:
```c++
struct Entry {
	string name;
	int value;
};

Entry read_entry(istream& is) { // naive read function (for a better
{   string s;                   // version, see §11.5)
	int i;
	
	is >> s >> i;
	return {s, i};
}

auto e = read_entry(cin);
cout << "{ " << e.name << " , " << e.value << " }\n";
```

Здесь `{s, i}` используется для построения возвращаемого значения типа `Entry`. Аналогично, мы можем “распаковать” члены `Entry` в локальные переменные:
```c++
auto [n, v] = read_entry(is);
cout << "{ " << n << " , " << v << " }\n";
```

Конструкция `auto [n,v]` объявляет две локальные переменные `n` и `v` с типами, выведенными из возвращаемого `read_entry()` типа. Этот механизм присвоения локальных имен членам объекта класса называется структурным связыванием.

Рассмотрим другой пример:
```c++
map<string, int> m;

// ... fill m ...

for (const auto [key, value] : m)
	cout << "{" << key << "," << value << "}\n";
```

Как обычно, мы можем украсить [[auto|auto]] с помощью [[const|const]] и `&`. Например:
```c++
void incr(map<string, int>& m) // increment the value of each element of m
{
	for (auto& [key, value] : m)
		++value;
}
```

Когда структурное связывание используется для класса без приватных полей, легко увидеть, как выполняется связывание: для связывания должно быть определено столько же имен, сколько элементов данных в объекте класса, и каждое имя, введенное в связывание, называет соответствующий элемент. Не будет никакой разницы в качестве объектного кода по сравнению с явным использованием составного объекта. В частности, использование структурного связывания не подразумевает копирование `struct`. Кроме того, возврат простого `struct` редко включает в себя копирование, поскольку [[Модульность#Возвращение значений|простые возвращаемые типы могут быть созданы непосредственно в том месте, где они необходимы]]. Использование структурного связывания - это все о том, как наилучшим образом выразить идею.

Также возможно обрабатывать классы, доступ к которым осуществляется через функции-члены. Например:
```c++
complex<double> z = {1, 2};
auto [re, im] = z+2;            // re=3; im=2
```

[[complex|complex]] имеет два элемента данных, но его интерфейс состоит из функций доступа, таких как `real()` и `imag()`. Сопоставление `complex<double>` двум локальным переменным, таким как `re` и `im`, осуществимо и эффективно, но методика выполнения этого выходит за рамки данной книги.

