
[[#constexpr C++11]]
[[#constexpr C++17]]
[[#Ослабление ограничений для constexpr функций C++14]]
[[#Используйте, где это возможно, constexpr|Используйте, где это возможно, constexpr]]
[[#if constexpr|if constexpr]]

# constexpr C++11

Выражения, которые вычисляются во время компиляции. В константном выражении могут выполняться только несложные вычисления.

```c++
constexpr int square(int x) {
  return x * x;
}

int square2(int x) {
  return x * x;
}

int a = square(2);  // mov DWORD PTR [rbp-4], 4

int b = square2(2); // mov edi, 2
                    // call square2(int)
                    // mov DWORD PTR [rbp-8], eax
```

Константные выражения с классами:

```c++
struct Complex {
  constexpr Complex(double r, double i) : re(r), im(i) { }
  constexpr double real() { return re; }
  constexpr double imag() { return im; }

private:
  double re;
  double im;
};

constexpr Complex I(0, 1);
```

# constexpr C++17

В C++17 появилась возможность выполнять условные конструкции на этапе  компиляции. Это очень мощный инструмент, особенно полезный в  метапрограммировании. Приведу простой пример:

```c++
// C++17
#include <iostream>
#include <type_traits>

template <typename T>
auto GetValue(T t){  
	if constexpr (std::is_pointer<T>::value)  {    
		return *t;  
	}  
	else  {    
		return t;  
	}
}

int main(){  
	int v = 10;  
	
	std::cout << GetValue(v) << '\n'; // 10  
	std::cout << GetValue(&v) << '\n'; // 10  
	
	return 0;
}
```

```c++
template <typename T>
constexpr bool isIntegral() {
  if constexpr (std::is_integral<T>::value) {
    return true;
  } else {
    return false;
  }
}

static_assert(isIntegral<int>() == true);
static_assert(isIntegral<char>() == true);
static_assert(isIntegral<double>() == false);
struct S {};
static_assert(isIntegral<S>() == false);
```

До C++17 нам пришлось бы использовать [[SFINAE|SFINAE]] и [[enable_if|enable_if]]:

```c++
// C++14

template<typename T>
typename std::enable_if<std::is_pointer<T>::value,  std::remove_pointer_t<T>>::type
GetValue(T t)
{  
	return *t;
}

template<typename T>
typename std::enable_if<!std::is_pointer<T>::value, T>::type
GetValue(T t)
{  
	return t;
}

int main()
{  
	int v = 10;  
	std::cout << GetValue(v) << '\n'; // 10  
	std::cout << GetValue(&v) << '\n'; // 10  
	
	return 0;
}
```

Не трудно заметить, что код с `constexpr if` на порядок читабельнее.

# Ослабление ограничений для constexpr функций C++14

Обновления C++14 этот значительно расширили набор конструкций, допустимых в **`constexpr`** функциях: добавились **`if`-операторы**, множественные **`return`**, **циклы** и т.д.
```c++
constexpr int factorial(int n) {
  if (n <= 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

factorial(5); // == 120
```

# Используйте, где это возможно, constexpr

Если бы присуждалась награда за наиболее запутанную новую возможность в С++11, без сомнений, ее бы получило новое ключевое слово `constexpr`. При применении к объектам это, по сути, усиленная разновидность [[const|const]], но при применении к функциям оно имеет совсем другой смысл. Имеет смысл разобраться в этой путанице, потому что, когда ключевое слово `constexpr` соответствует тому, что вы хотите выразить, вы определенно, захотите его использовать.

Концептуально ключевое слово `constexpr` указывает значение, которое не просто является константой, но и известно во время компиляции. Эта концепция - лишь часть всей истории, поскольку при применении `constexpr` к функциям появляется больше нюансов, чем можно предположить. Пожалуй, наиболее интригующим является то, что это возможности данного ключевого слова. Это хорошо, что `constexpr`- функция не обязана давать константный результат или результат, известный во время компиляции!

Но давайте начнем с объектов `constexpr`. Такие объекты являются, по сути, константными ([[const|const]]) и на самом деле обладают значениями, известными во время компиляции. (Технически их значения определяются во время трансляции, а трансляция состоит не только из компиляции, но и из компоновки. Однако, если вы не пишете компиляторы или редакторы связей для С++, это не имеет для вас значения, так что можете беспечно программировать так, как будто эти значения объектов `constexpr` определяются во время компиляции.)

Значения, известные во время компиляции, являются привилегированными. Они, например, могут быть размещены в памяти, предназначенной только для чтения, и это может представлять особое значение для разработчиков встроенных систем. Широко применяется то, что целочисленные значения, являющиеся константами и известные во время компиляции, могут использоваться в контекстах, где С++ требует целочисленное константное выражение. Такие контексты включают спецификации размеров массивов, целочисленные аргументы шаблонов (включая длину объектов [[array|std::array]]), значения перечислителей, спецификаторы выравнивания и прочее. Если вы хотите использовать для этих вещей переменные, вы, определенно, захотите объявить их как `constexpr`, поскольку тогда компиляторы будут точно знать, что имеют дело со значением времени компиляции:
```c++
int sz;                         // Неконстантная переменная
...
constexpr auto arraySize1 = sz; // Ошибка ! Значение sz
                                // неизвестно при компиляции

std::array<int, sz> data1;      // Ошибка! Таже проблема

constexpr auto arraySize2 = 10; // ОК, 10 представляет собой
                                // константу времени компиляции

std::array<int,                 // ОК, arraySize2 представляет
	arraySize2> data2;          // собой constexpr
```
Обратите внимание, что [[const|const]] не предоставляет таких же гарантий, что и `constexpr`, поскольку объекты [[const|const]] не обязаны инициализироваться значениями, известными во время компиляции:
```c++
int sz;                         // Как и ранее
...
const auto arraySize = sz;      // ОК, arraySize является
								// константной копией sz

std::array<int,                 // Ошибка! Значение arraySize
	arraySize> data;            // при компиляции неизвестно
```
Проще говоря, все объекты, являющиеся `constexpr`, являются [[const|const]], но не все объекты, являющиеся [[const|const]], являются `constexpr`. Если вы хотите, чтобы компиляторы гарантировали, что переменная имеет значение, которое можно использовать в требующих константы времени компиляции контекстах, то следует использовать `constexpr`, а не [[const|const]].

Сценарии применения объектов `constexpr` становятся более интересными, когда в дело вступают функции `constexpr`. Такие функции производят константы времени компиляции, когда они вызываются с константами времени компиляции. Если они вызываются со значениями, неизвестными до времени выполнения, они производят значения времени выполнения. Это может выглядеть так, как будто вы не знаете, что они будут делать, но так думать - неверно. Вот как выглядит правильный взгляд на эти моменты:
>
> - Функции, объявленные как `constexpr`, могут использоваться в контекстах, требующих константы времени компиляции. Если значения передаваемых вами аргументов в `constexpr`-функцию в таком контексте известны во время компиляции, результат функции будет вычислен в процессе компиляции. Если любое из значений аргументов неизвестно во время компиляции, ваш код будет отвергнут.
> 
> - Когда `constexpr`-функция вызывается с одним или несколькими значениями, неизвестными во время компиляции, она действует так же, как и обычная функция, выполняя вычисления во время выполнения. Это означает, что вам не нужны две функции для выполнения одних и тех же операций, одной - для констант времени компиляции, другой - для всех прочих значений. Функция, объявленная как `constexpr`, выполняет их все.

Предположим, что нам нужна структура данных для хранения результатов эксперимента, который может быть проведен при разных условиях. Например, уровень освещения в ходе эксперимента может быть высоким, низким или освещение может быть отключено вовсе; может быть разная температура, и т.д. Если всего имеется `n` условий, влияющих на проведение эксперимента, и у каждого по три возможных состояния, то общее количество комбинаций составит `3"`. Хранение результатов экспериментов для всех комбинаций условий требует структуры данных с достаточным количеством памяти для хранения `3"` значений. В предположении, что каждый результат представляет собой `int` и что `n` известно (или может быть вычислено) во время компиляции, подходящим выбором структуры данных может быть [[Array|std::array]]. Однако нам требуется способ вычисления `3"` во время компиляции. Стандартная библиотека С++ предоставляет функцию [[pow|std::pow]], обеспечивающую интересующую нас математическую функциональность, но с точки зрения наших целей имеются две проблемы. Во-первых, [[pow|std::pow]] работает с типами с плавающей точкой, а нам нужен целочисленный результат. Во-вторых, [[pow|std::pow]] не является `constexpr` (т.е. не гарантирует возврат времени компиляции при переданных ей значениях времени компиляции), так что мы не можем использовать ее для указания размера [[Array|std::array]].

К счастью, мы можем написать функцию `pow`, которая нам нужна. Как это сделать, я покажу чуть позже, но сначала давайте взглянем, каким образом эта функция может быть объявлена и использована:
```c++
constexpr                                    // pow является constexpr
int pow (int base, int ехр) constexpr        // Не генерирует исключений
{
											 // Ее реализация - ниже
}

constexpr auto numConds = 5;                 // Количество условий

std::array<int, роw(З, numConds)>            // results содержит
		results;                             // 3^numConds элементов
```
Вспомним, что `constexpr` перед [[pow|pow]] не говорит о том, что [[pow|pow]] возвращает константное значение; оно говорит, что если `base` и `ехр` являются константами времени компиляции, то результат [[pow|pow]] может быть использован как константа времени компиляции. Если `base` и/или `ехр` не являются константами времени компиляции, то результат [[pow|pow]] будет вычисляться во время выполнения. Это означает, что [[pow|pow]] может быть вызвана не только для вычисления во время компиляции таких вещей, как размер [[Array|std::array]], но и в контексте времени выполнения, как здесь:
```c++
auto base = readFromDB("base");               // Эти значения получаются
auto ехр = readFromDB("exponent");            // во время компиляции
auto baseToExp = pow(base, ехр);              // Вызов функции pow
                                              // во время выполнения
```
 Поскольку функции `constexpr` должны быть способны возвращать результаты во время компиляции при вызове со значениями времени компиляции, на их реализации накладываются ограничения. Эти ограничения различны в C++11 и С++14.
 
В С++11 функции `constexpr` могут содержать не более одной выполнимой инструкции - `return`. Это выглядит более ограничивающим, чем является на самом деле, поскольку для повышения выразительности `constexpr`-функций можно использовать две хитрости. Во-первых, можно применять условный оператор `"? :"` вместо инструкции `if - else`, а во-вторых, вместо циклов можно использовать рекурсию. Таким образом, функция [[pow|pow]] может быть реализована следующим образом:
```c++
constexpr int pow(int base, int ехр) noexcept
{
	return (ехр == О ? 1 : base * pow(base, ехр - 1));
}
```
Этот код работает, но только очень непритязательный функциональный программист сможет назвать его красивым. В С++14 ограничения на `constexpr`-функции существенно слабее, так что становится возможной следующая реализация:
```c++
constexpr int pow (int base, int ехр) noexcept       // С++14
{
	auto result = 1;
	
	for (int i = О; i < ехр; ++i) 
		result * = base ;

	return result;
}
```
Функции `constexpr` ограничены приемом и возвратом только литеральных типов (literal types), которые, по сути, означают типы, могущие иметь значения, определяемые во время компиляции. В С++11 к ним относятся все встроенные типы за исключением [[void|void]], но литеральными могут быть и пользовательские типы, поскольку конструкторы и прочие функции-члены также могут являться `constexpr`:
```c++
class Point {
	public:
		constexpr Point(double xVal = 0, double yVal = 0) noexcept
			: x(xVal)
			, y(yVal)
		{}
		
		constexpr double xValue() const noexcept { return х; }
		constexpr double yValue() const noexcept { return у; }

		void setX(double newX) noexcept { х = newX; }
		void setY(double newY) noexcept { у = newY; }

	private:
		double х, у;
};
```
Здесь конструктор `Point` может быть объявлен как `constexpr`, поскольку, если переданные ему аргументы известны во время компиляции, значения членов-данных созданного `Point` также могут быть известны во время компиляции. А значит, инициализированный таким образом объект `Point` может быть `constexpr`:
```c++
constexpr Point р1(9.4, 27.7);           // ОК, во время компиляции
                                         // работает constexpr конструктор
constexpr Point р2(28.8, 5.3);           // То же самое
```
Аналогично функции доступа `xValue` и `yValue` могут быть `constexpr`, поскольку если они вызываются для объекта `Point` со значением, известным во время компиляции (например, объект `constexpr Point`), значения членов-данных `х` и `у` могут быть известны во время компиляции. Это делает возможным написать `constexpr`-функции, которые вызывают функции доступа `Point` и инициализируют `constexpr`-объекты результатами вызовов этих функций:
```c++
constexpr
Point midpoint(const Point& p1, const Point& р2) noexcept
{
	return {(p1.xValue() + p2.xValue())/2 ,      // Вызов constexpr
	        (p1.yValue() + p2.yValue())/2};      // функции - члена
}

constexpr auto mid = midpoint(p1, р2);           // Инициализация
			// constexpr объекта результатом соnstехрr - функции
```
Это очень интересно. Это означает, что объект `mid` может быть создан в памяти, предназначенной только для чтения, несмотря на то что его инициализация включает вызовы конструкторов, функций доступа и функции, не являющейся членом! Это означает, что вы можете использовать выражение наподобие `mid.xValue() * 1О` в аргументе шаблона или в выражении, определяющем значение перечислителя! Это означает, что традиционно довольно строгая граница между работой во время компиляции и работой во время выполнения начинает размываться, и некоторые вычисления, традиционно являющиеся вычислениями времени выполнения, могут перейти на стадию компиляции. Чем больший код участвует в таком переходе, тем быстрее будет работать ваша программа. (Однако компилироваться она может существенно дольше.)

В С++11 два ограничения предотвращают объявление функций-членов `Point` `setX` и `setY` как `constexpr`. Во-первых, они модифицируют объект, с которым работают, а в С++11 функции-члены `constexpr` неявно являются [[const|const]]. Во-вторых, они имеют возвращаемый тип [[void|void]], а [[void|void]] не является литеральным типом в С++11. Оба эти ограничения сняты в С++14, так что в С++14 даже функции установки полей `Point` могут быть объявлены как `constexpr`:
```c++
class Point {
	public:
		constexpr void setX(double пеwХ) noexcept      // С++14
				{ x = newX; }

		constexpr void setY(double пеwУ) noexcept      // С++14
				{ у = newY; )
};
```
Это делает возможным написание функций наподобие следующей:
```c++
// Возвращает отражение точки р
// относительно начала координат (С++14)
constexpr Poiпt reflectioп(const Point& р) noexcept
{
	Poiпt result;                      // Неконстантный объект Point
	result.setX(-p.xValue());          // Установка его полей х и у
	result.setY(-p.yValue());
	returп result;                     // Возврат копии
```
Соответствующий клиентский код имеет вид:
```c++
constexpr Point р1(9.4, 27.7);         // Как и вьnuе
constexpr Point р2(28.8, 5.3);
constexpr auto mid = midpoiпt (pl , р2);
constexpr auto reflectedМid =          // представляет
			reflection(mid);           // собой (-19.1 - 16.5) и
									   // известно во время компиляции
```
Совет из этого раздела заключается в том, чтобы использовать `constexpr` везде, где это только возможно, и теперь, надеюсь, вам понятно, почему: и объекты `constexpr`,  и `constexpr`-функции могут применяться в более широком диапазоне контекстов, чем объекты и функции, не являющиеся `constexpr` Применяя `constexpr`, где это возможно, вы максимизируете диапазон ситуаций, в которых ваши объекты и функции могут быть использованы.

Важно отметить, что `constexpr` является частью интерфейса объекта или функции. `constexpr` провозглашает: "Меня можно использовать в контексте, где для С++ требуется константное выражение". Если вы объявляете объект или функцию как `constexpr`, клиенты могут использовать их в указанных контекстах. Если позже вы решите, что такое использование `constexpr` было ошибкой, и удалите его, то это может привести к тому, что большое количество клиентского кода перестанет компилироваться. (Простое действие, заключающееся в добавлении в функцию отладочного вывода для отладки или настройки производительности может привести к таким проблемам, поскольку инструкции ввода-вывода в общем случае в `constexpr`-функциях недопустимы.) Часть "где это возможно" совета является вашей доброй волей на придание долгосрочного характера данному ограничению на объекты и функции, к которым вы его применяете.

> * Объекты `constexpr` являются константными и инициализируются объектами, значения которых известны во время компиляции.
> 
> * Функции `constexpr` могут производить результаты времени компиляции при вы­зове с аргументами, значения которых известны во время компиляции.
> 
> * Объекты и функции `constexpr` могут использоваться в более широком диапазоне контекстов по сравнению с объектами и функциями, не являющимися `constexpr`.
> 
> * `constexpr` является частью интерфейса объектов и функций.


# if constexpr
#if_constexpr





