
1. [[#Указатели|Указатели]] 15.2(STL)
	1. [[#unique_ptr и shared_ptr|unique_ptr и shared_ptr]] 15.2.1(STL)


# Указатели

Общее понятие указателя - это нечто, что позволяет нам ссылаться на объект и получать к нему доступ в соответствии с его типом. Встроенный указатель, такой как `int*`, является примером, но их гораздо больше.

|                                 | Указатели                                                                                                                                     |
| ------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `T*`                            | Встроенный тип указателя: указывает на объект типа `T` или к непрерывно-аллоцированной последовательности элементов типа `T`                  |
| `T&`                            | Встроенный ссылочный тип: ссылается на объект типа `T`; [[Программы - STL#Указатели, Массивы и Ссылки\|указатель с неявным разыменованием]]   |
| [[unique_ptr\|unique_ptr<T>]]   | Владеющий указатель на T                                                                                                                      |
| [[shared_ptr\|shared_ptr<T>]]   | Указатель на объект типа `T`;<br>право собственности распределяется между всеми [[shared_ptr\|shared_ptr]] на этот `T`                        |
| [[weak_ptr\|weak_ptr<T>]]       | Указатель на объект, принадлежащий [[shared_ptr\|shared_ptr]];<br>должен быть преобразован в [[shared_ptr\|shared_ptr]] для доступа к объекту |
| [[span\|span<T>]]               | Указатель на непрерывную последовательность `T` #§15_2_2                                                                                      |
| [[string_view\|string_view<T>]] | [[string_view#Строковые представления\|Указатель на константную const подстроку]]                                                             |
| `X_iterator<C>`                 | Последовательность элементов из `C`;<br>Символ `X` в названии указывает на [[iterator#Типы итераторов\|тип итератора]]                        |

На объект может быть более одного указателя. Указатель-владелец - это тот, который отвечает за конечное удаление объекта, на который он ссылается. Указатель, не являющийся владельцем (например, `T*` или [[span|span]]), может повиснуть; то есть указывать на местоположение, где объект был `deleted` или вышел за пределы области видимости.

Чтение или запись с помощью повисшего указателя - один из самых неприятных видов ошибок. Результат этого технически не определен. На практике это часто означает доступ к объекту, который случайно находится в этом местоположении. Тогда чтение означает получение произвольного значения, а запись перезаписывает несвязанную структуру данных. Лучшее, на что мы можем надеяться, - это сбой; обычно это предпочтительнее неправильного результата.

`C++ Core Guidelines [CG]` предлагают правила, позволяющие избежать этого, и советы по статической проверке того, что этого никогда не произойдет. Однако вот несколько подходов, позволяющих избежать проблем с указателями:
>
> Не сохраняйте указатель на локальный объект после того, как объект выходит за пределы области видимости. В частности, никогда не возвращайте указатель на локальный объект из функции и не храните указатель неопределенного происхождения в долговечных структурах данных. Систематическое использование [[Контейнеры - STL|контейнеров]] и [[Алгоритмы - STL|алгоритмов]] часто избавляет нас от использования методов программирования, из-за которых трудно избежать проблем с указателями.
>
> Используйте собственные указатели на объекты, размещенные в динамической памяти.
>
> Указатели на статические объекты (например, глобальные переменные) не могут повиснуть.
> 
> Оставьте арифметику указателей для реализации дескрипторов ресурсов (таких как [[vector|vector]] и [[unordered_map|unordered_map]]).
> 
> Помните, что [[string_view|string_view]] и [[span|span]] - это разновидности указателей, не являющихся владельцами.

## unique_ptr и shared_ptr

Одной из ключевых задач любой нетривиальной программы является управление ресурсами. Ресурс - это то, что должно быть приобретено и позже (явно или неявно) освобождено. Это может быть память, блокировки, сокеты, дескрипторы потоков и дескрипторы файлов. Для длительно работающей программы [[allocator#std allocator|несвоевременное высвобождение ресурса (“утечка”) может привести к серьезному снижению производительности]] и, возможно, даже к серьезному сбою. Даже для коротких программ утечка может стать затруднительной, скажем, вызвав нехватку ресурсов, и увеличив время выполнения на порядки.

Компоненты стандартной библиотеки сконструированы таким образом, чтобы не допускать утечки ресурсов. Для этого они полагаются на поддержку базового языка для управления ресурсами с использованием пар конструктор/деструктор, чтобы гарантировать, что ресурс не переживет ответственный за него объект. Примером является использование пары конструктор/деструктор в [[vector|Vector]] для [[Классы#Контейнеры|управления временем жизни его элементов]], и все контейнеры стандартной библиотеки реализованы аналогичным образом. Важно отметить, что этот подход корректно взаимодействует с обработкой ошибок с использованием исключений. Например, этот метод используется для классов блокировки стандартной библиотеки:
```c++
mutex m; // used to protect access to shared data

void f()
{
	scoped_lock lck {m};          // acquire the mutex m
	// ... manipulate shared data ...
}
```

[[thread|thread]] не будет запущен до тех пор, пока конструктор `lck` не получит [[mutex|mutex]]. Соответствующий деструктор освобождает [[mutex|mutex]]. Итак, в этом примере деструктор [[lock#Тип std scoped_lock|scoped_lock]] освобождает [[mutex|mutex]], когда поток управления покидает `f()` (через `return`, путем “выпадения из конца функции” или посредством выброса исключения).

[[Классы#Контейнеры|Здесь реализованно RAII (идиома “Получение ресурса - это инициализация”)]]. RAII имеет фундаментальное значение для идиоматической обработки ресурсов в C++. Контейнеры (такие как [[vector|vector]] и [[map|map]], [[string|string]] и [[iostream|iostream]]) управляют своими ресурсами (такими как файловые дескрипторы и буферы) аналогичным образом.

Приведенные до сих пор примеры заботятся об объектах, определенных в области видимости, освобождая ресурсы, которые они получают при выходе из области видимости, но как насчет объектов, размещенных в динамической памяти? В `<memory>` стандартная библиотека предоставляет два “умных указателя”, помогающих управлять объектами в динамической памяти:
>
> [[unique_ptr|unique_ptr]] представляет собой уникальное владение (его деструктор уничтожает его объект)
>
> [[shared_ptr|shared_ptr]] представляет собой совместное владение (деструктор последнего общего указателя уничтожает объект)

Самое основное применение этих “умных указателей” заключается в предотвращении утечек памяти, вызванных небрежным программированием. Например:
```c++
void f(int i, int j)            // X* vs. unique_ptr<X>
{
	X* p = new X;               // allocate a new X
	unique_ptr<X> sp {new X};   // allocate a new X and give its pointer to
								// unique_ptr
	// ...
	
	if (i<99) throw Z{};        // may throw an exception
	if (j<77) return;           // may return "early"
	
	// ... use p and sp ..
	delete p;                   // destroy *p
}
```

Здесь мы “забыли” удалить `p`, если `i<99` или если `j<77`. С другой стороны, [[unique_ptr|unique_ptr]] гарантирует, что его объект будет должным образом уничтожен, каким бы способом мы ни вышли из `f()` (путем создания исключения, выполнения `return` или “выпадения из конца”). По иронии судьбы, мы могли бы решить проблему, просто не используя указатель и не используя [[new|new]]:
```c++
void f(int i, int j)           // use a local variable
{
	X x;
	// ...
}
```

К сожалению, злоупотребление оператором [[new|new]] (а также указателями и ссылками), по-видимому, становится все более серьезной проблемой.

Однако, когда вам действительно нужна семантика указателей, [[unique_ptr|unique_ptr]] - это облегченный механизм, не требующий затрат памяти или процессорного времени по сравнению с правильным использованием встроенного указателя. Его дальнейшее использование включает передачу объектов, выделенных в динамической памяти, в функции и возврат из них:
```c++
unique_ptr<X> make_X(int i)
			// make an X and immediately give it to a unique_ptr
{
	//... check i, etc. ...
	return unique_ptr<X>{new X{i}};
}
```

[[unique_ptr|unique_ptr]] - это дескриптор отдельного объекта (или массива) во многом таким же образом, как [[vector|vector]] является дескриптором последовательности объектов. Оба управляют временем жизни других объектов (используя `RAII`) и оба полагаются на исключение копирования или семантику перемещения, чтобы [[Основные операции#Перемещение контейнеров|сделать `return` простым и эффективным]].

[[shared_ptr|shared_ptr]] похож на [[unique_ptr|unique_ptr]], за исключением того, что [[shared_ptr|shared_ptr]] копируются, а не перемещаются. [[shared_ptr|shared_ptr]] для объекта разделяют право собственности на объект; этот объект уничтожается, когда уничтожается последний из его [[shared_ptr|shared_ptr]]. Например:
```c++
void f(shared_ptr<fstream>);
void g(shared_ptr<fstream>);

void user(const string& name, ios_base::openmode mode)
{
	shared_ptr<fstream> fp {new fstream(name, mode)};
	
	if (!*fp)                // make sure the file was properly opened
		throw No_file{};

	f(fp);
	g(fp);
	
	// ...
}
```

Теперь файл, открытый конструктором `fp`, будет закрыт последней функцией, которая(явно или неявно) уничтожит копию `fp`. Обратите внимание, что `f()` или `g()` могут вызвать задачу, содержащую копию `fp`, или каким-либо другим способом сохранить копию, которая переживёт `user()`. Таким образом, [[shared_ptr|shared_ptr]] представляет собой форму сборки мусора, которая реализует управление ресурсами основанное на деструкторе объектов в динамической памяти. Это не является ни бесплатным, ни непомерно дорогим, но из-за этого трудно предсказать срок службы общего объекта. Используйте [[shared_ptr|shared_ptr]] только в том случае, если вам действительно нужно совместное владение.

Создание объекта в динамической памяти и последующая передача указателя на него умному указателю - это немного многословно. Это также допускает ошибки, можно забыть передать указатель на [[unique_ptr|unique_ptr]] или передать указатель на что-то, чего нет в динамической памяти, в [[shared_ptr|shared_ptr]]. Чтобы избежать подобных проблем, стандартная библиотека (в `<memory>`) предоставляет функции для построения объекта и возврата соответствующего интеллектуального указателя, [[make_shared|make_shared()]] и [[make_unique|make_unique()]]. Например:
```c++
struct S {
	int i;
	string s;
	double d;
	// ...
};

auto p1 = make_shared<S>(1,"Ankh Morpork",4.65); // p1 is a shared_ptr<S>
auto p2 = make_unique<S>(2,"Oz",7.62);           // p2 is a unique_ptr<S>
```

Теперь `p2` - это [[unique_ptr|unique_ptr<S>]], указывающий на выделенный в динамической памяти объект типа `S` со значением `{2, "Oz"s, 7.62}`.

Использование [[make_shared|make_shared()]] не просто удобнее, чем отдельное создание объекта с помощью [[new|new]] и последующая передача его в [[shared_ptr|shared_ptr]] – это также заметно более эффективно, поскольку не требует отдельного выделения для подсчета использования, что важно при реализации [[shared_ptr|shared_ptr]].

Используя [[unique_ptr|unique_ptr]] и [[shared_ptr|shared_ptr]], мы можем полностью [[Классы#Контейнеры|реализовать политику ”никаких голых new "]] для большинства программ. Однако эти “умные указатели” по прежнему концептуально являются указателями и, следовательно, являются лишь моим вторым выбором для управления ресурсами - после контейнеров и других типов, которые управляют своими ресурсами на более высоком концептуальном уровне. В частности, [[shared_ptr|shared_ptr]] сами по себе не предоставляют никаких правил, по которым их владельцы могут читать и/или записывать общий объект. Состояние гонки за данными ( #§18_5) и другие формы путаницы не устраняются простым устранением проблем с управлением ресурсами.

Когда мы используем “умные указатели” (такие как [[unique_ptr|unique_ptr]]) вместо дескрипторов ресурсов с операциями, разработанными специально для ресурса (такими как [[vector|vector]] или [[thread|thread]])? Неудивительно, что ответ таков: “когда нам нужна семантика указателя”.
>
> Когда мы совместно используем объект, нам нужны указатели (или ссылки) для ссылки на общий объект, поэтому [[shared_ptr|shared_ptr]] становится очевидным выбором (если только нет очевидного единственного владельца).
>
> Когда мы [[Классы#Иерархии классов|ссылаемся на полиморфный объект в классическом объектно-ориентированном коде]], нам нужен указатель (или ссылка), потому что мы не знаем точный тип объекта, на который ссылаемся (или даже его размер), поэтому очевидным выбором становится [[unique_ptr|unique_ptr]].
>
> Для общего полиморфного объекта обычно требуется [[shared_ptr|shared_ptr]].

Нам не нужно использовать указатель для возврата коллекции объектов из функции; контейнер, который является дескриптором ресурса, сделает это просто и эффективно, полагаясь на [[Модульность#Возвращение значений|исключение копирования]] и [[Основные операции#Перемещение контейнеров|семантику перемещения]].


