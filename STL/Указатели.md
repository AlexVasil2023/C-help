
1. [[#Указатели|Указатели]] 15.2(STL)
	1. [[#unique_ptr и shared_ptr|unique_ptr и shared_ptr]] 15.2.1(STL)


# Указатели

Общее понятие указателя - это нечто, что позволяет нам ссылаться на объект и получать к нему доступ в соответствии с его типом. Встроенный указатель, такой как `int*`, является примером, но их гораздо больше.

|                                 | Указатели                                                                                                                                     |
| ------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `T*`                            | Встроенный тип указателя: указывает на объект типа `T` или к непрерывно-аллоцированной последовательности элементов типа `T`                  |
| `T&`                            | Встроенный ссылочный тип: ссылается на объект типа `T`; [[Программы - STL#Указатели, Массивы и Ссылки\|указатель с неявным разыменованием]]   |
| [[unique_ptr\|unique_ptr<T>]]   | Владеющий указатель на T                                                                                                                      |
| [[shared_ptr\|shared_ptr<T>]]   | Указатель на объект типа `T`;<br>право собственности распределяется между всеми [[shared_ptr\|shared_ptr]] на этот `T`                        |
| [[weak_ptr\|weak_ptr<T>]]       | Указатель на объект, принадлежащий [[shared_ptr\|shared_ptr]];<br>должен быть преобразован в [[shared_ptr\|shared_ptr]] для доступа к объекту |
| [[span\|span<T>]]               | Указатель на непрерывную последовательность `T` #§15_2_2                                                                                      |
| [[string_view\|string_view<T>]] | [[string_view#Строковые представления\|Указатель на константную const подстроку]]                                                             |
| `X_iterator<C>`                 | Последовательность элементов из `C`;<br>Символ `X` в названии указывает на [[iterator#Типы итераторов\|тип итератора]]                        |

На объект может быть более одного указателя. Указатель-владелец - это тот, который отвечает за конечное удаление объекта, на который он ссылается. Указатель, не являющийся владельцем (например, `T*` или [[span|span]]), может повиснуть; то есть указывать на местоположение, где объект был `deleted` или вышел за пределы области видимости.

Чтение или запись с помощью повисшего указателя - один из самых неприятных видов ошибок. Результат этого технически не определен. На практике это часто означает доступ к объекту, который случайно находится в этом местоположении. Тогда чтение означает получение произвольного значения, а запись перезаписывает несвязанную структуру данных. Лучшее, на что мы можем надеяться, - это сбой; обычно это предпочтительнее неправильного результата.

`C++ Core Guidelines [CG]` предлагают правила, позволяющие избежать этого, и советы по статической проверке того, что этого никогда не произойдет. Однако вот несколько подходов, позволяющих избежать проблем с указателями:
>
> Не сохраняйте указатель на локальный объект после того, как объект выходит за пределы области видимости. В частности, никогда не возвращайте указатель на локальный объект из функции и не храните указатель неопределенного происхождения в долговечных структурах данных. Систематическое использование [[Контейнеры - STL|контейнеров]] и [[Алгоритмы - STL|алгоритмов]] часто избавляет нас от использования методов программирования, из-за которых трудно избежать проблем с указателями.
>
> Используйте собственные указатели на объекты, размещенные в динамической памяти.
>
> Указатели на статические объекты (например, глобальные переменные) не могут повиснуть.
> 
> Оставьте арифметику указателей для реализации дескрипторов ресурсов (таких как [[vector|vector]] и [[unordered_map|unordered_map]]).
> 
> Помните, что [[string_view|string_view]] и [[span|span]] - это разновидности указателей, не являющихся владельцами.

## unique_ptr и shared_ptr

Одной из ключевых задач любой нетривиальной программы является управление ресурсами. Ресурс - это то, что должно быть приобретено и позже (явно или неявно) освобождено. Это может быть память, блокировки, сокеты, дескрипторы потоков и дескрипторы файлов. Для длительно работающей программы [[allocator#std allocator|несвоевременное высвобождение ресурса (“утечка”) может привести к серьезному снижению производительности]] и, возможно, даже к серьезному сбою. Даже для коротких программ утечка может стать затруднительной, скажем, вызвав нехватку ресурсов, и увеличив время выполнения на порядки.

Компоненты стандартной библиотеки сконструированы таким образом, чтобы не допускать утечки ресурсов. Для этого они полагаются на поддержку базового языка для управления ресурсами с использованием пар конструктор/деструктор, чтобы гарантировать, что ресурс не переживет ответственный за него объект. Примером является использование пары конструктор/деструктор в [[vector|Vector]] для [[Классы#Контейнеры|управления временем жизни его элементов]], и все контейнеры стандартной библиотеки реализованы аналогичным образом. Важно отметить, что этот подход корректно взаимодействует с обработкой ошибок с использованием исключений. Например, этот метод используется для классов блокировки стандартной библиотеки:
```c++
mutex m; // used to protect access to shared data

void f()
{
	scoped_lock lck {m};          // acquire the mutex m
	// ... manipulate shared data ...
}
```

[[thread|thread]] не будет запущен до тех пор, пока конструктор `lck` не получит [[mutex|mutex]]. Соответствующий деструктор освобождает [[mutex|mutex]]. Итак, в этом примере деструктор [[lock#Тип std scoped_lock|scoped_lock]] освобождает [[mutex|mutex]], когда поток управления покидает `f()` (через `return`, путем “выпадения из конца функции” или посредством выброса исключения).

[[Классы#Контейнеры|Здесь реализованно RAII (идиома “Получение ресурса - это инициализация”)]]. RAII имеет фундаментальное значение для идиоматической обработки ресурсов в C++. Контейнеры (такие как [[vector|vector]] и [[map|map]], [[string|string]] и [[iostream|iostream]]) управляют своими ресурсами (такими как файловые дескрипторы и буферы) аналогичным образом.

Приведенные до сих пор примеры заботятся об объектах, определенных в области видимости, освобождая ресурсы, которые они получают при выходе из области видимости, но как насчет объектов, размещенных в динамической памяти? В `<memory>` стандартная библиотека предоставляет два “умных указателя”, помогающих управлять объектами в динамической памяти:
>
> [[unique_ptr|unique_ptr]] представляет собой уникальное владение (его деструктор уничтожает его объект)
>
> [[shared_ptr|shared_ptr]] представляет собой совместное владение (деструктор последнего общего указателя уничтожает объект)

















