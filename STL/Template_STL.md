
[[#Шаблоны|Шаблоны]] 7
1. [[#Введение|Введение в шаблоны]] 7.1
2. [[#Параметризованные типы|Параметризованные типы]] 7.2
	1. [[#Ограниченные аргументы шаблона|Ограниченные аргументы шаблона]] 7.2.1
	2. [[#Аргументы-значения шаблона|Аргументы-значения шаблона]] 7.2.2
	3. [[#Выведение типов аргументов шаблонов|Выведение типов аргументов шаблонов]] 7.2.3
3. [[#Параметризированные операции|Параметризированные операции]] 7.3
	1. [[#Шаблоны функций|Шаблоны функций]] 7.3.1
	2. [[#Функциональные объекты|Функциональные объекты]] 7.3.2


# Шаблоны

## Введение

Тот, кто хочет использовать вектор, вряд ли всегда будет довольствоваться вектором `double`. Вектор - это общее понятие, независимое от понятия числа с плавающей запятой. Следовательно, тип элемента вектора должен быть представлен независимо. ***Шаблон*** - это класс или функция, которые мы параметризуем с помощью набора типов или значений. Мы используем шаблоны для представления идей, которые лучше всего понимать, как нечто общее, на основе чего мы можем генерировать конкретные типы и функции, указывая аргументы, такие как тип `double` в качестве типа элемента [[vector|vector]].

## Параметризованные типы

Мы можем обобщить [[Классы#Контейнеры|наш тип вектор]] из `double` на тип вектор из любых, сделав его шаблоном [[templates|template]] и заменив конкретный тип `double` параметром типа. Например:
```c++
template<typename T>
class Vector 
{
	private:
		T* elem; // elem points to an array of sz elements of type T
		int sz;

	public:
		explicit Vector(int s); // constructor: establish invariant, 
								// acquire resources
		~Vector() { delete[] elem; } // destructor: release resources
		
		// ... copy and move operations ...
		
		T& operator[](int i);        // for non-const Vectors
		const T& operator[](int i) const; // for const Vectors (§5.2.1)
		
		int size() const { return sz; }
};
```

Префикс `template<typename T>` делает `T` параметром типа для объявления, которому он предшествует. Это версия C++ математического выражения `“для всех T”` или, точнее, `“для всех типов T.”` Если вам нужен математический `“для всех T, такой, что P (T)”`, используйте концепты ( #§7_2_1,  #§8_2). Использование `class` для введения параметра типа эквивалентно использованию [[typename|typename]], и в более старом коде мы часто видим `template<class T>` в качестве префикса.

Функции-члены могут быть определены аналогичным образом:
```c++
template<typename T>
Vector<T>::Vector(int s)
{
	if (s<0)
		throw length_error{"Vector constructor: negative size"};

	elem = new T[s];
	
	sz = s;
}

template<typename T>
const T& Vector<T>::operator[](int i) const
{
	if (i<0 || size()<=i)
		throw out_of_range{"Vector::operator[]"};

	return elem[i];
}
```

Учитывая эти определения, мы можем определить `Vector` следующим образом:
```c++
Vector<char> vc(200);            // vector of 200 characters
Vector<string> vs(17);           // vector of 17 strings
Vector<list<int>> vli(45);       // vector of 45 lists of integers
```

Символы `>>` в `Vector<list<int>>` завершают вложенные аргументы шаблона (это закрывающие угловые скобки для `<list` и `<int`); это не ошибочный оператор ввода.
Мы можем использовать `Vector`, таким образом:
```c++
void write(const Vector<string>& vs) // Vector of some strings
{
	for (int i = 0; i!=vs.size(); ++i)
		cout << vs[i] << '\n';
}
```

Чтобы обеспечить поддержку диапазонного цикла [[for|for]] для нашего `Vector`, мы должны определить подходящие функции [[begin|begin()]] и [[end|end()]]:
```c++
template<typename T>
T* begin(Vector<T>& x)
{
	return &x[0]; // pointer to first element or to one-past-the-last element
}

template<typename T>
T* end(Vector<T>& x)
{
	return &x[0]+x.size(); // pointer to one-past-the-last element
}
```

Учитывая это, мы можем написать:
```c++
void write2(Vector<string>& vs) // Vector of some strings
{
	for (auto& s : vs)
		cout << s << '\n';
}
```

Аналогично, мы можем определять списки, векторы, карты (то есть ассоциативные массивы), неупорядоченные карты (то есть хэш-таблицы) и т.д. в качестве шаблонов ( #глава_12).

Шаблоны - это механизм времени компиляции, поэтому их использование не требует дополнительных затрат времени выполнения по сравнению с кодом, созданным вручную. Фактически, код, сгенерированный для `Vector<double>`, идентичен коду, [[Классы|сгенерированному для версии Vector]]. Более того, код, сгенерированный для `vector<double>` стандартной библиотеки, вероятно, будет лучше (поскольку на его реализацию было затрачено больше усилий).

Шаблон плюс набор аргументов шаблона называется инстанцированием экземпляра или специализацией. В конце процесса компиляции, во время инстанцирования экземпляра, генерируется код для каждого экземпляра, используемого в программе ( #§8_5).

## Ограниченные аргументы шаблона

Чаще всего шаблон будет иметь смысл только для аргументов шаблона, которые соответствуют определенным критериям. Например, `Vector` обычно предлагает операцию копирования, и если это так, то он должен требовать, чтобы его элементы поддержи- вали копирование. То есть мы должны потребовать, чтобы аргументом шаблона `Vector` было не просто [[typename|typename]], а` Element`, где `“Element”` определяет требования к типу, который может быть элементом:
```c++
template<Element T>
class Vector {
	private:
		T* elem; // elem points to an array of sz elements of type T
		int sz;
	
	...
};
```

Этот префикс `template<Element T>` является для C++ математической версией `“для всех T, таких как Element(T)”`; то есть `Element` - это предикат, который проверяет, обладает ли `T` всеми свойствами, которые требуются `Vector`. Такой предикат называется [[Concepts|концепт]]. Аргумент шаблона, для которого задан [[Concepts|концепт]], называется ограниченным аргументом, а шаблон, для которого аргумент ограничен, называется ограниченным шаблоном.

Требования к типу элемента стандартной библиотеки немного сложнее ( #§12_2), но для нашего простого `Vector` `Element` мог бы быть чем-то вроде [[Concepts#концепт copyable|концепта copyable]] стандартной библиотеки.

Попытка использовать шаблон с типом, который не соответствует его требованиям, является ошибкой времени компиляции. Например:
```c++
Vector<int> v1; // OK: we can copy an int
Vector<thread> v2; // error: we can't copy a standard thread
```

Таким образом, [[Concepts|концепты]] позволяют компилятору выполнять проверку типов в момент использования, выдавая лучшие сообщения об ошибках намного раньше, чем это возможно при использовании неограниченных аргументов шаблона. C++ официально не поддерживал [[Concepts|концепты]] до C++20, поэтому более старый код использует неограниченные аргументы шаблона и позволяет отражать требования лишь в документации. Однако код, сгенерированный из шаблонов, проверяется по типу, так что даже неограниченный шаблонный код так же типобезопасен, как и рукописный код. Для неограниченных параметров эта проверка типа не может быть выполнена до тех пор, пока не будут доступны типы всех задействованных объектов, поэтому проверка может произойти неприятно поздно в процессе компиляции, во время создания экземпляра ( #§8_5), и [[Применение шаблонов на практике#Расшифровка романов об ошибках|сообщения об ошибках часто ужасны]].

Проверка концепта - это механизм чисто времени компиляции, и сгенерированный код ничуть не уступает коду из неограниченных шаблонов.

## Аргументы-значения шаблона

В дополнение к аргументам-типа шаблон может принимать аргументы-значения. Например:
```c++
template<typename T, int N>
struct Buffer {
	constexpr int size() { return N; }
	T elem[N];
	
	...
};
```

Аргументы-значения полезны во многих контекстах. Например, `Buffer` позволяет нам создавать буферы произвольного размера без использования динамической памяти:
```c++
Buffer<char,1024> glob;    // global buffer of characters (statically allocated)

void fct()
{
	Buffer<int, 10> buf;   // local buffer of integers (on the stack)

	...
}
```

К сожалению, по неясным техническим причинам строковый литерал пока не может быть аргументом-значением шаблона. Однако в некоторых контекстах критически важна возможность параметризации с помощью строковых значений. К счастью, мы можем использовать массив строковых символов (строка в стиле С):
```c++
template<char* s>
void outs() 
{ 
	cout << s; 
}

char arr[] = "Weird workaround!";
void use()
{
	outs<"straightforward use">(); // error (for now)
	outs<arr>();                   // writes: Weird workaround!
}
```

В C++ обычно существует обходной путь; нам не нужна прямая поддержка для каждого варианта использования.

## Выведение типов аргументов шаблонов

При определении типа как экземпляра шаблона мы должны указать его аргументы шаблона. Рассмотрим возможное использования шаблона [[pair|pair]] из стандартной библиотеки:
```c++
pair<int, double> p = {1, 5.2};
```

Необходимость указывать типы аргументов шаблона может быть утомительной. К счастью, во многих контекстах мы можем просто позволить конструктору [[pair|pair]] выводить аргументы шаблона из инициализатора:
```c++
pair p = {1, 5.2};         // p is a pair<int,double>
```

Контейнеры представляют еще одним пример:
```c++
template<typename T>
class Vector {
	public:
		Vector(int);
		Vector(initializer_list<T>);    // initializer-list constructor
		
		...
};

Vector v1 {1, 2, 3};  // deduce v1's element type from the initializer element type:
int Vector v2 = v1;   // deduce v2's element type from v1's element type: int
auto p = new Vector{1, 2, 3}; // p is a Vector<int>*
Vector<int> v3(1);    // here we need to be explicit about the element type (no 
					// element type is mentioned)
```

Очевидно, что это упрощает форму записи и может устранить неприятности, вызванные неправильным вводом избыточных аргументов-типов шаблона. Однако это не панацея. Как и все другие мощные механизмы, выведение(дедукция) может вызывать неожиданности. Рассмотрим:
```c++
Vector<string> vs {"Hello", "World"};// OK: Vector<string>
Vector vs1 {"Hello", "World"};       // OK: deduces to Vector<const char*> (Surprise?)
Vector vs2 {"Hello"s, "World"s};     // OK: deduces to Vector<string>
Vector vs3 {"Hello"s, "World"};      // error: the initializer list is not homogenous
Vector<string> vs4 {"Hello"s, "World"}; // OK: the element type is explicit
```

Типом строкового литерала в стиле C является `const char*`. Если это не то, что предназначено для `vs1`, мы должны четко указать тип элемента или использовать суффикс `s`, чтобы сделать его [[string|string]].

Если элементы списка инициализаторов имеют разные типы, мы не можем определить уникальный тип элемента, поэтому получаем ошибку неоднозначности.

Иногда нам нужно устранить двусмысленность. Например, [[vector|vector]] стандартной библиотеки имеет конструктор, который принимает пару итераторов, определяющих последовательность, а также конструктор инициализатора, который может принимать пару значений. Рассмотрим:
```c++
template<typename T>
class Vector {
	public:
		Vector(initializer_list<T>); // initializer-list constructor
		
		template<typename Iter>
			Vector(Iter b, Iter e); // [b:e) iterator-pair constructor
			
		struct iterator { using value_type = T; /* ... */ };
		iterator begin();
	
		...
};

Vector v1 {1, 2, 3, 4, 5}; // element type is int
Vector v2(v1.begin(), v1.begin()+2);   // a pair of iterators or a pair of values
									// (of type iterator)?
Vector v3(9, 17); // error: ambiguous
```

Мы могли бы решить это с помощью [[Concepts#Концепт|концептов]], но стандартная библиотека и многие другие важные части кода были написаны за десятилетия до того, как у нас появилась языковая поддержка концептов. Для них нам нужен способ сказать: “пара значений одного и того же типа должна рассматриваться как итераторы”. Добавление руководства по выведению типа после объявления `Vector` делает именно это:
```c++
template<typename Iter>
		Vector(Iter, Iter) -> Vector<typename Iter::value_type>;
```

Теперь мы имеем:
```c++
Vector v1 {1, 2, 3, 4, 5};           // element type is int
Vector v2(v1.begin(), v1.begin()+2);  // pair-of-iterators: element type is int
Vector v3 {v1.begin(), v1.begin()+2}; // element type is Vector2::iterator
```

Синтаксис инициализатора `{}` всегда отдает предпочтение конструктору [[initializer_list|initializer_list]] (если он присутствует), поэтому `v3` - это вектор итераторов: 
```c++
Vector<Vector<int>::iterator>
```

Синтаксис инициализации `()` ( #§12_2) является обычным для случаев, когда нам не нужен [[initializer_list|initializer_list]].

Эффекты руководств по выведению типов часто незаметны, поэтому лучше всего создавать шаблоны классов таким образом, чтобы руководства по дедукции не требовались.

Люди, которым нравятся сокращения, называют "выведение аргумента шаблона класса” `CTAD`.

# Параметризированные операции

Шаблоны имеют гораздо больше применений, чем просто параметризация контейнера с помощью типа элемента. В частности, они широко используются для параметризации как типов, так и алгоритмов в стандартной библиотеке ( #§12_8, #§13_5).

Существует три способа выражения операции, параметризованной типами или значениями:
>
> Шаблон функции
> 
> Функциональный объект(функтор): объект, который может передавать данные и вызываться как функция
> 
> Лямбда-выражение: сокращенная форма записи функтора

## Шаблоны функций

Мы можем написать функцию, которая вычисляет сумму значений элементов любой последовательности, которую может перебрать диапазонный [[for|for]] (например, контейнер), следующим образом:
```c++
template<typename Sequence, typename Value>
Value sum(const Sequence& s, Value v)
{
	for (auto x : s)
		v+=x;
	
	return v;
}
```

Аргумент шаблона `Value` и аргумент функции `v` предназначены для того, чтобы позволить вызывающей стороне указать тип и начальное значение накопителя (переменной, в которой накапливается сумма):
```c++
void user(Vector<int>& vi, list<double>& ld, vector<complex<double>>& vc)
{
	int x = sum(vi,0); // the sum of a vector of ints (add ints)
	double d = sum(vi,0.0); // the sum of a vector of ints (add doubles)
	double dd = sum(ld,0.0); // the sum of a list of doubles
	auto z = sum(vc,complex{0.0,0.0}); // the sum of a vector of complex<double>s
}
```

Смысл добавления `int` в `double` состоял бы в том, чтобы изящно обрабатывать сумму, большую, чем самый большой `int`. Обратите внимание, как типы аргументов шаблона для `sum<Sequence, Value>` выводятся из аргументов функции. К счастью, нам не нужно явно указывать эти типы.

Эта функция `sum()` является упрощенной версией [[accumulate|accumulate()]] стандартной библиотеки.

Шаблон функции может быть функцией-членом, но не [[virtual|virtual]] членом. Компилятор не знал бы всех экземпляров такого шаблона в программе, поэтому он не смог бы сгенерировать [[Классы#Виртуальные функции|vtbl]].

## Функциональные объекты

Одним из особенно полезных типов шаблонов является функциональный объект (иногда называемый функтором), который используется для определения объектов, которые могут вызываться как функции. Например:
```c++
template<typename T>
class Less_than 
{
	const T val; // value to compare against
	
	public:
		Less_than(const T& v) :val{v} { }
		bool operator()(const T& x) const { return x<val; } // call operator
};
```

Функция с именем `operator()` реализует оператор приложения, `()`, также называемый “вызов функции” или просто “вызов”.

Мы можем определить именованные переменные типа `Less_than` для некоторого типа аргумента:
```c++
Less_than lti {42};        // lti(i) will compare i to 42 using < (i<42)
Less_than lts {"Backus"s}; // lts(s) will compare s to "Backus" using < (s<"Backus")
Less_than<string> lts2 {"Naur"};  // "Naur" is a C-style string, so we need <string>
								// to get the right <
```

Мы можем вызвать такой объект точно так же, как мы вызываем функцию:
```c++
void fct(int n, const string& s)
{
	bool b1 = lti(n); // true if n<42
	bool b2 = lts(s); // true if s<"Backus"

	...
}
```

Функциональные объекты широко используются в качестве аргументов алгоритмов. Например, мы можем подсчитать количество вхождений значений, для которых предикат возвращает значение `true`:
```c++
template<typename C, typename P>
int count(const C& c, P pred) // assume that C is a container and P is a
{ // predicate on its elements
int cnt = 0;
for (const auto& x : c)
if (pred(x))
++cnt;
return cnt;
}
```










