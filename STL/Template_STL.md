
[[#Шаблоны|Шаблоны]] 7
1. [[#Введение|Введение в шаблоны]] 7.1
2. [[#Параметризованные типы|Параметризованные типы]] 7.2
	1. [[#Ограниченные аргументы шаблона|Ограниченные аргументы шаблона]] 7.2.1
	2. [[#Аргументы-значения шаблона|Аргументы-значения шаблона]] 7.2.2


# Шаблоны

## Введение

Тот, кто хочет использовать вектор, вряд ли всегда будет довольствоваться вектором `double`. Вектор - это общее понятие, независимое от понятия числа с плавающей запятой. Следовательно, тип элемента вектора должен быть представлен независимо. ***Шаблон*** - это класс или функция, которые мы параметризуем с помощью набора типов или значений. Мы используем шаблоны для представления идей, которые лучше всего понимать, как нечто общее, на основе чего мы можем генерировать конкретные типы и функции, указывая аргументы, такие как тип `double` в качестве типа элемента [[vector|vector]].

## Параметризованные типы

Мы можем обобщить [[Классы#Контейнеры|наш тип вектор]] из `double` на тип вектор из любых, сделав его шаблоном [[templates|template]] и заменив конкретный тип `double` параметром типа. Например:
```c++
template<typename T>
class Vector 
{
	private:
		T* elem; // elem points to an array of sz elements of type T
		int sz;

	public:
		explicit Vector(int s); // constructor: establish invariant, 
								// acquire resources
		~Vector() { delete[] elem; } // destructor: release resources
		
		// ... copy and move operations ...
		
		T& operator[](int i);        // for non-const Vectors
		const T& operator[](int i) const; // for const Vectors (§5.2.1)
		
		int size() const { return sz; }
};
```

Префикс `template<typename T>` делает `T` параметром типа для объявления, которому он предшествует. Это версия C++ математического выражения `“для всех T”` или, точнее, `“для всех типов T.”` Если вам нужен математический `“для всех T, такой, что P (T)”`, используйте концепты ( #§7_2_1,  #§8_2). Использование `class` для введения параметра типа эквивалентно использованию [[typename|typename]], и в более старом коде мы часто видим `template<class T>` в качестве префикса.

Функции-члены могут быть определены аналогичным образом:
```c++
template<typename T>
Vector<T>::Vector(int s)
{
	if (s<0)
		throw length_error{"Vector constructor: negative size"};

	elem = new T[s];
	
	sz = s;
}

template<typename T>
const T& Vector<T>::operator[](int i) const
{
	if (i<0 || size()<=i)
		throw out_of_range{"Vector::operator[]"};

	return elem[i];
}
```

Учитывая эти определения, мы можем определить `Vector` следующим образом:
```c++
Vector<char> vc(200);            // vector of 200 characters
Vector<string> vs(17);           // vector of 17 strings
Vector<list<int>> vli(45);       // vector of 45 lists of integers
```

Символы `>>` в `Vector<list<int>>` завершают вложенные аргументы шаблона (это закрывающие угловые скобки для `<list` и `<int`); это не ошибочный оператор ввода.
Мы можем использовать `Vector`, таким образом:
```c++
void write(const Vector<string>& vs) // Vector of some strings
{
	for (int i = 0; i!=vs.size(); ++i)
		cout << vs[i] << '\n';
}
```

Чтобы обеспечить поддержку диапазонного цикла [[for|for]] для нашего `Vector`, мы должны определить подходящие функции [[begin|begin()]] и [[end|end()]]:
```c++
template<typename T>
T* begin(Vector<T>& x)
{
	return &x[0]; // pointer to first element or to one-past-the-last element
}

template<typename T>
T* end(Vector<T>& x)
{
	return &x[0]+x.size(); // pointer to one-past-the-last element
}
```

Учитывая это, мы можем написать:
```c++
void write2(Vector<string>& vs) // Vector of some strings
{
	for (auto& s : vs)
		cout << s << '\n';
}
```

Аналогично, мы можем определять списки, векторы, карты (то есть ассоциативные массивы), неупорядоченные карты (то есть хэш-таблицы) и т.д. в качестве шаблонов ( #глава_12).

Шаблоны - это механизм времени компиляции, поэтому их использование не требует дополнительных затрат времени выполнения по сравнению с кодом, созданным вручную. Фактически, код, сгенерированный для `Vector<double>`, идентичен коду, [[Классы|сгенерированному для версии Vector]]. Более того, код, сгенерированный для `vector<double>` стандартной библиотеки, вероятно, будет лучше (поскольку на его реализацию было затрачено больше усилий).

Шаблон плюс набор аргументов шаблона называется инстанцированием экземпляра или специализацией. В конце процесса компиляции, во время инстанцирования экземпляра, генерируется код для каждого экземпляра, используемого в программе ( #§8_5).

## Ограниченные аргументы шаблона

Чаще всего шаблон будет иметь смысл только для аргументов шаблона, которые соответствуют определенным критериям. Например, `Vector` обычно предлагает операцию копирования, и если это так, то он должен требовать, чтобы его элементы поддержи- вали копирование. То есть мы должны потребовать, чтобы аргументом шаблона `Vector` было не просто [[typename|typename]], а` Element`, где `“Element”` определяет требования к типу, который может быть элементом:
```c++
template<Element T>
class Vector {
	private:
		T* elem; // elem points to an array of sz elements of type T
		int sz;
	
	...
};
```

Этот префикс `template<Element T>` является для C++ математической версией `“для всех T, таких как Element(T)”`; то есть `Element` - это предикат, который проверяет, обладает ли `T` всеми свойствами, которые требуются `Vector`. Такой предикат называется [[Concepts|концепт]]. Аргумент шаблона, для которого задан [[Concepts|концепт]], называется ограниченным аргументом, а шаблон, для которого аргумент ограничен, называется ограниченным шаблоном.

Требования к типу элемента стандартной библиотеки немного сложнее ( #§12_2), но для нашего простого `Vector` `Element` мог бы быть чем-то вроде [[Concepts#концепт copyable|концепта copyable]] стандартной библиотеки.

Попытка использовать шаблон с типом, который не соответствует его требованиям, является ошибкой времени компиляции. Например:
```c++
Vector<int> v1; // OK: we can copy an int
Vector<thread> v2; // error: we can't copy a standard thread
```

Таким образом, [[Concepts|концепты]] позволяют компилятору выполнять проверку типов в момент использования, выдавая лучшие сообщения об ошибках намного раньше, чем это возможно при использовании неограниченных аргументов шаблона. C++ официально не поддерживал [[Concepts|концепты]] до C++20, поэтому более старый код использует неограниченные аргументы шаблона и позволяет отражать требования лишь в документации. Однако код, сгенерированный из шаблонов, проверяется по типу, так что даже неограниченный шаблонный код так же типобезопасен, как и рукописный код. Для неограниченных параметров эта проверка типа не может быть выполнена до тех пор, пока не будут доступны типы всех задействованных объектов, поэтому проверка может произойти неприятно поздно в процессе компиляции, во время создания экземпляра ( #§8_5), и [[Применение шаблонов на практике#Расшифровка романов об ошибках|сообщения об ошибках часто ужасны]].

Проверка концепта - это механизм чисто времени компиляции, и сгенерированный код ничуть не уступает коду из неограниченных шаблонов.

## Аргументы-значения шаблона




