
[[#Шаблоны|Шаблоны]] 7
1. [[#Введение|Введение в шаблоны]] 7.1
2. [[#Параметризованные типы|Параметризованные типы]] 7.2
	1. [[#Ограниченные аргументы шаблона|Ограниченные аргументы шаблона]] 7.2.1
	2. [[#Аргументы-значения шаблона|Аргументы-значения шаблона]] 7.2.2
	3. [[#Выведение типов аргументов шаблонов|Выведение типов аргументов шаблонов]] 7.2.3
3. [[#Параметризированные операции|Параметризированные операции]] 7.3
	1. [[#Шаблоны функций|Шаблоны функций]] 7.3.1
	2. [[#Функциональные объекты|Функциональные объекты]] 7.3.2
	3. [[#Лямбда выражения|Лямбда выражения]] 7.3.3
		1. [[#Лямбды как аргументы функции|Лямбды как аргументы функции]] 7.3.3.1
		2. [[#Лямбды для инициализации|Лямбды для инициализации]] 7.3.3.2
		3. [[finally|Напоследок, finally()]] 7.3.3.3
4. [[#Механизмы шаблонов|Механизмы шаблонов]] 7.4
	1. [[#Шаблоны переменных|Шаблоны переменных]] 7.4.1
	2. [[#Псевдонимы|Псевдонимы]] 7.4.2
	3. [[#if времени компиляции|if времени компиляции]] 7.4.3

# Шаблоны

## Введение

Тот, кто хочет использовать вектор, вряд ли всегда будет довольствоваться вектором `double`. Вектор - это общее понятие, независимое от понятия числа с плавающей запятой. Следовательно, тип элемента вектора должен быть представлен независимо. ***Шаблон*** - это класс или функция, которые мы параметризуем с помощью набора типов или значений. Мы используем шаблоны для представления идей, которые лучше всего понимать, как нечто общее, на основе чего мы можем генерировать конкретные типы и функции, указывая аргументы, такие как тип `double` в качестве типа элемента [[vector|vector]].

## Параметризованные типы

Мы можем обобщить [[Классы#Контейнеры|наш тип вектор]] из `double` на тип вектор из любых, сделав его шаблоном [[templates|template]] и заменив конкретный тип `double` параметром типа. Например:
```c++
template<typename T>
class Vector 
{
	private:
		T* elem; // elem points to an array of sz elements of type T
		int sz;

	public:
		explicit Vector(int s); // constructor: establish invariant, 
								// acquire resources
		~Vector() { delete[] elem; } // destructor: release resources
		
		// ... copy and move operations ...
		
		T& operator[](int i);        // for non-const Vectors
		const T& operator[](int i) const; // for const Vectors (§5.2.1)
		
		int size() const { return sz; }
};
```

Префикс `template<typename T>` делает `T` параметром типа для объявления, которому он предшествует. Это версия C++ математического выражения `“для всех T”` или, точнее, `“для всех типов T.”` Если вам нужен математический `“для всех T, такой, что P (T)”`, используйте концепты ( #§7_2_1,  #§8_2). Использование `class` для введения параметра типа эквивалентно использованию [[typename|typename]], и в более старом коде мы часто видим `template<class T>` в качестве префикса.

Функции-члены могут быть определены аналогичным образом:
```c++
template<typename T>
Vector<T>::Vector(int s)
{
	if (s<0)
		throw length_error{"Vector constructor: negative size"};

	elem = new T[s];
	
	sz = s;
}

template<typename T>
const T& Vector<T>::operator[](int i) const
{
	if (i<0 || size()<=i)
		throw out_of_range{"Vector::operator[]"};

	return elem[i];
}
```

Учитывая эти определения, мы можем определить `Vector` следующим образом:
```c++
Vector<char> vc(200);            // vector of 200 characters
Vector<string> vs(17);           // vector of 17 strings
Vector<list<int>> vli(45);       // vector of 45 lists of integers
```

Символы `>>` в `Vector<list<int>>` завершают вложенные аргументы шаблона (это закрывающие угловые скобки для `<list` и `<int`); это не ошибочный оператор ввода.
Мы можем использовать `Vector`, таким образом:
```c++
void write(const Vector<string>& vs) // Vector of some strings
{
	for (int i = 0; i!=vs.size(); ++i)
		cout << vs[i] << '\n';
}
```

Чтобы обеспечить поддержку диапазонного цикла [[for|for]] для нашего `Vector`, мы должны определить подходящие функции [[begin|begin()]] и [[end|end()]]:
```c++
template<typename T>
T* begin(Vector<T>& x)
{
	return &x[0]; // pointer to first element or to one-past-the-last element
}

template<typename T>
T* end(Vector<T>& x)
{
	return &x[0]+x.size(); // pointer to one-past-the-last element
}
```

Учитывая это, мы можем написать:
```c++
void write2(Vector<string>& vs) // Vector of some strings
{
	for (auto& s : vs)
		cout << s << '\n';
}
```

Аналогично, мы можем определять списки, векторы, карты (то есть ассоциативные массивы), неупорядоченные карты (то есть хэш-таблицы) и т.д. в качестве шаблонов ( #глава_12).

Шаблоны - это механизм времени компиляции, поэтому их использование не требует дополнительных затрат времени выполнения по сравнению с кодом, созданным вручную. Фактически, код, сгенерированный для `Vector<double>`, идентичен коду, [[Классы|сгенерированному для версии Vector]]. Более того, код, сгенерированный для `vector<double>` стандартной библиотеки, вероятно, будет лучше (поскольку на его реализацию было затрачено больше усилий).

Шаблон плюс набор аргументов шаблона называется инстанцированием экземпляра или специализацией. В конце процесса компиляции, во время инстанцирования экземпляра, генерируется код для каждого экземпляра, используемого в программе ( #§8_5).

## Ограниченные аргументы шаблона

Чаще всего шаблон будет иметь смысл только для аргументов шаблона, которые соответствуют определенным критериям. Например, `Vector` обычно предлагает операцию копирования, и если это так, то он должен требовать, чтобы его элементы поддержи- вали копирование. То есть мы должны потребовать, чтобы аргументом шаблона `Vector` было не просто [[typename|typename]], а` Element`, где `“Element”` определяет требования к типу, который может быть элементом:
```c++
template<Element T>
class Vector {
	private:
		T* elem; // elem points to an array of sz elements of type T
		int sz;
	
	...
};
```

Этот префикс `template<Element T>` является для C++ математической версией `“для всех T, таких как Element(T)”`; то есть `Element` - это предикат, который проверяет, обладает ли `T` всеми свойствами, которые требуются `Vector`. Такой предикат называется [[Concepts|концепт]]. Аргумент шаблона, для которого задан [[Concepts|концепт]], называется ограниченным аргументом, а шаблон, для которого аргумент ограничен, называется ограниченным шаблоном.

Требования к типу элемента стандартной библиотеки немного сложнее ( #§12_2), но для нашего простого `Vector` `Element` мог бы быть чем-то вроде [[Concepts#концепт copyable|концепта copyable]] стандартной библиотеки.

Попытка использовать шаблон с типом, который не соответствует его требованиям, является ошибкой времени компиляции. Например:
```c++
Vector<int> v1; // OK: we can copy an int
Vector<thread> v2; // error: we can't copy a standard thread
```

Таким образом, [[Concepts|концепты]] позволяют компилятору выполнять проверку типов в момент использования, выдавая лучшие сообщения об ошибках намного раньше, чем это возможно при использовании неограниченных аргументов шаблона. C++ официально не поддерживал [[Concepts|концепты]] до C++20, поэтому более старый код использует неограниченные аргументы шаблона и позволяет отражать требования лишь в документации. Однако код, сгенерированный из шаблонов, проверяется по типу, так что даже неограниченный шаблонный код так же типобезопасен, как и рукописный код. Для неограниченных параметров эта проверка типа не может быть выполнена до тех пор, пока не будут доступны типы всех задействованных объектов, поэтому проверка может произойти неприятно поздно в процессе компиляции, во время создания экземпляра ( #§8_5), и [[template Применение шаблонов на практике#Расшифровка романов об ошибках|сообщения об ошибках часто ужасны]].

Проверка концепта - это механизм чисто времени компиляции, и сгенерированный код ничуть не уступает коду из неограниченных шаблонов.

## Аргументы-значения шаблона

В дополнение к аргументам-типа шаблон может принимать аргументы-значения. Например:
```c++
template<typename T, int N>
struct Buffer {
	constexpr int size() { return N; }
	T elem[N];
	
	...
};
```

Аргументы-значения полезны во многих контекстах. Например, `Buffer` позволяет нам создавать буферы произвольного размера без использования динамической памяти:
```c++
Buffer<char,1024> glob;    // global buffer of characters (statically allocated)

void fct()
{
	Buffer<int, 10> buf;   // local buffer of integers (on the stack)

	...
}
```

К сожалению, по неясным техническим причинам строковый литерал пока не может быть аргументом-значением шаблона. Однако в некоторых контекстах критически важна возможность параметризации с помощью строковых значений. К счастью, мы можем использовать массив строковых символов (строка в стиле С):
```c++
template<char* s>
void outs() 
{ 
	cout << s; 
}

char arr[] = "Weird workaround!";
void use()
{
	outs<"straightforward use">(); // error (for now)
	outs<arr>();                   // writes: Weird workaround!
}
```

В C++ обычно существует обходной путь; нам не нужна прямая поддержка для каждого варианта использования.

## Выведение типов аргументов шаблонов

При определении типа как экземпляра шаблона мы должны указать его аргументы шаблона. Рассмотрим возможное использования шаблона [[pair|pair]] из стандартной библиотеки:
```c++
pair<int, double> p = {1, 5.2};
```

Необходимость указывать типы аргументов шаблона может быть утомительной. К счастью, во многих контекстах мы можем просто позволить конструктору [[pair|pair]] выводить аргументы шаблона из инициализатора:
```c++
pair p = {1, 5.2};         // p is a pair<int,double>
```

Контейнеры представляют еще одним пример:
```c++
template<typename T>
class Vector {
	public:
		Vector(int);
		Vector(initializer_list<T>);    // initializer-list constructor
		
		...
};

Vector v1 {1, 2, 3};  // deduce v1's element type from the initializer element type:
int Vector v2 = v1;   // deduce v2's element type from v1's element type: int
auto p = new Vector{1, 2, 3}; // p is a Vector<int>*
Vector<int> v3(1);    // here we need to be explicit about the element type (no 
					// element type is mentioned)
```

Очевидно, что это упрощает форму записи и может устранить неприятности, вызванные неправильным вводом избыточных аргументов-типов шаблона. Однако это не панацея. Как и все другие мощные механизмы, выведение(дедукция) может вызывать неожиданности. Рассмотрим:
```c++
Vector<string> vs {"Hello", "World"};// OK: Vector<string>
Vector vs1 {"Hello", "World"};       // OK: deduces to Vector<const char*> (Surprise?)
Vector vs2 {"Hello"s, "World"s};     // OK: deduces to Vector<string>
Vector vs3 {"Hello"s, "World"};      // error: the initializer list is not homogenous
Vector<string> vs4 {"Hello"s, "World"}; // OK: the element type is explicit
```

Типом строкового литерала в стиле C является `const char*`. Если это не то, что предназначено для `vs1`, мы должны четко указать тип элемента или использовать суффикс `s`, чтобы сделать его [[string|string]].

Если элементы списка инициализаторов имеют разные типы, мы не можем определить уникальный тип элемента, поэтому получаем ошибку неоднозначности.

Иногда нам нужно устранить двусмысленность. Например, [[vector|vector]] стандартной библиотеки имеет конструктор, который принимает пару итераторов, определяющих последовательность, а также конструктор инициализатора, который может принимать пару значений. Рассмотрим:
```c++
template<typename T>
class Vector {
	public:
		Vector(initializer_list<T>); // initializer-list constructor
		
		template<typename Iter>
			Vector(Iter b, Iter e); // [b:e) iterator-pair constructor
			
		struct iterator { using value_type = T; /* ... */ };
		iterator begin();
	
		...
};

Vector v1 {1, 2, 3, 4, 5}; // element type is int
Vector v2(v1.begin(), v1.begin()+2);   // a pair of iterators or a pair of values
									// (of type iterator)?
Vector v3(9, 17); // error: ambiguous
```

Мы могли бы решить это с помощью [[Concepts#Концепт|концептов]], но стандартная библиотека и многие другие важные части кода были написаны за десятилетия до того, как у нас появилась языковая поддержка концептов. Для них нам нужен способ сказать: “пара значений одного и того же типа должна рассматриваться как итераторы”. Добавление руководства по выведению типа после объявления `Vector` делает именно это:
```c++
template<typename Iter>
		Vector(Iter, Iter) -> Vector<typename Iter::value_type>;
```

Теперь мы имеем:
```c++
Vector v1 {1, 2, 3, 4, 5};           // element type is int
Vector v2(v1.begin(), v1.begin()+2);  // pair-of-iterators: element type is int
Vector v3 {v1.begin(), v1.begin()+2}; // element type is Vector2::iterator
```

Синтаксис инициализатора `{}` всегда отдает предпочтение конструктору [[initializer_list|initializer_list]] (если он присутствует), поэтому `v3` - это вектор итераторов: 
```c++
Vector<Vector<int>::iterator>
```

Синтаксис инициализации `()` ( #§12_2) является обычным для случаев, когда нам не нужен [[initializer_list|initializer_list]].

Эффекты руководств по выведению типов часто незаметны, поэтому лучше всего создавать шаблоны классов таким образом, чтобы руководства по дедукции не требовались.

Люди, которым нравятся сокращения, называют "выведение аргумента шаблона класса” `CTAD`.

# Параметризированные операции

Шаблоны имеют гораздо больше применений, чем просто параметризация контейнера с помощью типа элемента. В частности, они широко используются для параметризации как типов, так и алгоритмов в стандартной библиотеке ( #§12_8, #§13_5).

Существует три способа выражения операции, параметризованной типами или значениями:
>
> Шаблон функции
> 
> Функциональный объект(функтор): объект, который может передавать данные и вызываться как функция
> 
> Лямбда-выражение: сокращенная форма записи функтора

## Шаблоны функций

Мы можем написать функцию, которая вычисляет сумму значений элементов любой последовательности, которую может перебрать диапазонный [[for|for]] (например, контейнер), следующим образом:
```c++
template<typename Sequence, typename Value>
Value sum(const Sequence& s, Value v)
{
	for (auto x : s)
		v+=x;
	
	return v;
}
```

Аргумент шаблона `Value` и аргумент функции `v` предназначены для того, чтобы позволить вызывающей стороне указать тип и начальное значение накопителя (переменной, в которой накапливается сумма):
```c++
void user(Vector<int>& vi, list<double>& ld, vector<complex<double>>& vc)
{
	int x = sum(vi,0); // the sum of a vector of ints (add ints)
	double d = sum(vi,0.0); // the sum of a vector of ints (add doubles)
	double dd = sum(ld,0.0); // the sum of a list of doubles
	auto z = sum(vc,complex{0.0,0.0}); // the sum of a vector of complex<double>s
}
```

Смысл добавления `int` в `double` состоял бы в том, чтобы изящно обрабатывать сумму, большую, чем самый большой `int`. Обратите внимание, как типы аргументов шаблона для `sum<Sequence, Value>` выводятся из аргументов функции. К счастью, нам не нужно явно указывать эти типы.

Эта функция `sum()` является упрощенной версией [[accumulate|accumulate()]] стандартной библиотеки.

Шаблон функции может быть функцией-членом, но не [[virtual|virtual]] членом. Компилятор не знал бы всех экземпляров такого шаблона в программе, поэтому он не смог бы сгенерировать [[Классы#Виртуальные функции|vtbl]].

## Функциональные объекты

Одним из особенно полезных типов шаблонов является функциональный объект (иногда называемый функтором), который используется для определения объектов, которые могут вызываться как функции. Например:
```c++
template<typename T>
class Less_than 
{
	const T val; // value to compare against
	
	public:
		Less_than(const T& v) :val{v} { }
		bool operator()(const T& x) const { return x<val; } // call operator
};
```

Функция с именем `operator()` реализует оператор приложения, `()`, также называемый “вызов функции” или просто “вызов”.

Мы можем определить именованные переменные типа `Less_than` для некоторого типа аргумента:
```c++
Less_than lti {42};        // lti(i) will compare i to 42 using < (i<42)
Less_than lts {"Backus"s}; // lts(s) will compare s to "Backus" using < (s<"Backus")
Less_than<string> lts2 {"Naur"};  // "Naur" is a C-style string, so we need <string>
								// to get the right <
```

Мы можем вызвать такой объект точно так же, как мы вызываем функцию:
```c++
void fct(int n, const string& s)
{
	bool b1 = lti(n); // true if n<42
	bool b2 = lts(s); // true if s<"Backus"

	...
}
```

Функциональные объекты широко используются в качестве аргументов алгоритмов. Например, мы можем подсчитать количество вхождений значений, для которых предикат возвращает значение `true`:
```c++
template<typename C, typename P>
int count(const C& c, P pred) // assume that C is a container and P is a
{                             // predicate on its elements
	int cnt = 0;
	for (const auto& x : c)
		if (pred(x))
			++cnt;

	return cnt;
}
```

Это упрощенная версия алгоритма [[count#std count_if|count_if]] стандартной библиотеки. Учитывая [[Concepts|концепты]], мы можем формализовать предположения [[count|count()]] относительно его аргумента и проверить их во время компиляции. 

***Предикат*** - это то, что мы можем вызвать, чтобы вернуть значение `true` или `false`. Например:
```c++
void f(const Vector<int>& vec, const list<string>& lst, int x, 
		const string& s)
{
	cout << "number of values less than " << x << ": " 
			<< count(vec,Less_than{x}) <<'\n';
			
	cout << "number of values less than " << s << ": " 
			<< count(lst,Less_than{s}) << '\n';
}
```

Здесь `Less_than{x}` создает объект типа `Less_than<int>`, для которого оператор вызова сравнивает значения из вектора с `x; Less_than{s}` создает объект, который сравнивает значения из списка с `s`.

Прелесть функциональных объектов в том, что они несут в себе значение, с которым происходит сравнивнение. Нам не нужно писать отдельную функцию для каждого значения (и каждого типа), и нам не нужно вводить неприятные глобальные переменные для хранения значений. Кроме того, простой функциональный объект, такого как `Less_than`, легко инлайнится, поэтому вызов `Less_than` намного эффективнее, чем косвенный вызов функции. Способность переносить данные плюс их эффективность делают функциональные объекты особенно полезными в качестве аргументов для алгоритмов.

Функциональные объекты, используемые для указания значения ключевых операций общего алгоритма (такие как `Less_than` для [[count|count()]]), иногда называются объектами политики.

## Лямбда выражения

Выше мы определили `Less_than` отдельно от его использования. Это может быть неудобно. Следовательно, существует обозначение для неявно генерируемых объектов функций:
```c++
void f(const Vector<int>& vec, const list<string>& lst, int x, 
		const string& s)
{
	cout << "number of values less than " << x
			<< ": " << count(vec,[&](int a){ return a<x; })
			<< '\n';
			
	cout << "number of values less than " << s
		<< ": " << count(lst,[&](const string& a){ return a<s; })
		<< '\n';
}
```

Запись `[&](int a){ return a<x; }` называется лямбда-выражением. Он генерирует функциональный объект, подобный `Less_than<int>{x}`. `[&]` - это список захвата, указывающий, что доступ ко всем локальным именам, используемым в теле лямбды (таким как `x`), будет осуществляться через ссылки. Если бы мы хотели “захватить” только `x`, мы могли бы написать так: `[&x]`. Если бы мы хотели предоставить сгенерированному объекту копию `x`, мы могли бы написать так: `[x]`. Не захватывать ничего: `[ ]`, захватывать все локальные переменные по ссылке: `[&]`, а захватывать все локальные переменные по значению: `[=]`.

Для лямбды, определенной в функции-члене, `[this]` захватывает текущий объект по ссылке, чтобы мы могли ссылаться на члены класса. Если нам нужна копия текущего объекта, мы напишем `[*this]`.

Если мы хотим захватить несколько конкретных объектов, мы можем перечислить их. Примером является использование `[i,this]` при использовании [[Обработка ошибок#Утверждения|expect()]].

### Лямбды как аргументы функции

Использование лямбд может быть удобным и кратким, но в то же время непонятным. Для нетривиальных действий (скажем, нечто большее, чем простое выражение) я предпочитаю называть операцию так, чтобы более четко указать ее назначение и сделать ее доступной для использования в нескольких местах программы.

 [[Классы#Предотвращение утечки ресурсов|Была отмечена неприятность]], связанная с необходимостью написания множества функций для выполнения операций над элементами [[vector|vector]] указателей и
[[unique_ptr|unique_ptr]], таких как [[draw_all|draw_all()]] и [[rotate#rotate_all|rotate_all()]]. Функциональные объекты (в частности, лямбды) могут помочь, позволяя нам отделить обход контейнера от спецификации того, что должно быть сделано с каждым элементом.

Во-первых, нам нужна функция, которая применяет операцию к каждому объекту, на который указывают элементы контейнера указателей:
```c++
template<typename C, typename Oper>
void for_each(C& c, Oper op) // assume that C is a container of pointers
{
	for (auto& x : c)
		op(x); // pass op() a reference to each element pointed to
}
```

Это упрощенная версия алгоритма стандартной библиотеки [[for_each|for_each]]. 

Теперь мы можем написать версию [[Классы#Иерархии классов|user()]] без написания набора функций `_all`:
```c++
void user()
{
	vector<unique_ptr<Shape>> v;
	
	while (cin)
		v.push_back(read_shape(cin));

	// draw_all()
	for_each(v,[](unique_ptr<Shape>& ps){ ps->draw(); });

	// rotate_all(45)
	for_each(v,[](unique_ptr<Shape>& ps){ ps->rotate(45); }); 
}
```

Я передаю `unique_ptr<Shape>` лямбдам по ссылке. Таким образом, [[for_each|for_each()]] не придется иметь дело с проблемами срока жизни объекта. 

Как и функция, лямбда-выражение может быть универсальным. Например:
```c++
template<class S>
void rotate_and_draw(vector<S>& v, int r)
{
	for_each(v,[](auto& s){ s->rotate(r); 
							s->draw(); }
	);
}
```

Здесь, как и в объявлениях переменных, [[auto|auto]] означает, что значение любого типа принимается в качестве инициализатора (считается, что аргумент инициализирует
формальный параметр в вызове). Это превращает лямбду с параметром [[auto|auto]] в шаблон, универсальную лямбду. При необходимости мы можем ограничить параметр [[Concepts|концептом]]. Например, мы могли бы определить `Pointer_to_class` для требования `*` и `->` и записать:
```c++
for_each(v,[](Pointer_to_class auto& s){ s->rotate(r); 
										 s->draw(); }
);
```

Мы можем вызвать эту универсальную функцию `rotate_and_draw()` с любым контейнером объектов, которые вы можете `draw()` и `rotate()`. Например:
```c++
void user()
{
	vector<unique_ptr<Shape>> v1;
	vector<Shape*> v2;

	...

	rotate_and_draw(v1,45);
	rotate_and_draw(v2,90);
}
```

Для еще более тщательной проверки мы могли бы определить [[Concepts|концепт]] `Pointer_to_Shape`, определяющий свойства, которые мы хотим, чтобы тип можно было использовать в качестве формы. Это позволило бы нам использовать фигуры, которые не были производными от класса `Shape`.

### Лямбды для инициализации

Используя лямбду, мы можем превратить любое утверждение в выражение. В основном это используется для обеспечения операций вычисления значения в качестве значения аргумента, но эта возможность является общей. Рассмотрим сложную инициализацию:
```c++
enum class Init_mode { zero, seq, cpy, patrn }; // initializer alternatives

void user(Init_mode m, int n, vector<int>& arg, Iterator p, Iterator q)
{
	vector<int> v;

	// messy initialization code:
	
	switch (m) {
		case zero:
			v = vector<int>(n); // n elements initialized to 0
		break;

		case cpy:
			v = arg;
		break;
	};

	...

	if (m == seq)
		v.assign(p, q); // copy from sequence [p:q)

	 ...
}
```

Это стилизованный пример, но, к сожалению, не редкий. Нам нужно выбрать один из вариантов для инициализации структуры данных (здесь `v`), и нам нужно выполнить разные вычисления для разных вариантов. Такой код часто является беспорядочным, считается необходимым “для повышения эффективности” и источником ошибок:
>
> Переменная может быть использована до того, как она получит свое предполагаемое значение.
> 
>  “Код инициализации” может быть смешан с другим кодом, что затрудняет его понимание.
>  
> Когда “код инициализации” смешан с другим кодом, легче забыть `case`. 
> 
> Это не [[Программы - STL#Инициализация|инициализация]], это присвоение.

Вместо этого мы могли бы преобразовать его в лямбду, используемую в качестве инициализатора:
```c++
void user(Init_mode m, int n, vector<int>& arg, Iterator p, Iterator q)
{
	vector<int> v = [&] {
		switch (m) {
			case zero: 
				return vector<int>(n); // n elements initialized to 0
			
			case seq: 
				return vector<int>{p,q}; // copy from sequence [p:q)
			
			case cpy: 
				return arg;
		}
	}();

	...
}
```

Я все еще “забыл” один `case`, но теперь это легче обнаружить. Во многих случаях компилятор обнаружит проблему и предупредит.

### Напоследок, finally()

[[finally|см. тут]]

# Механизмы шаблонов

Чтобы определить хорошие шаблоны, нам нужны некоторые вспомогательные языковые средства:
>
> Значения, зависящие от типа: шаблоны переменных ( #§7_4_1).
> 
> Псевдонимы для типов и шаблонов: шаблоны псевдонимов ( #§7_4_2).
> 
> Механизм выбора времени компиляции: [[constexpr#if constexpr|if constexpr]].
> 
> Механизм времени компиляции для запроса свойств типов и выражений: requires-выражения ( #§8_2_3).

Кроме того, функции [[constexpr|constexpr]] и [[assert#static_assert()|static_asserts]] часто принимают участие в разработке и использовании шаблонов.

Эти базовые механизмы в первую очередь являются инструментами для построения общих, основополагающих абстракций.

## Шаблоны переменных

Когда мы используем тип, нам часто нужны константы и значения этого типа. Это, конечно, также имеет место, когда мы используем шаблон класса: когда мы определяем `C<T>`, нам часто нужны константы и переменные типа `C<T>` и других типов, зависящих от `T`. Вот пример из моделирования динамики жидкости:
```c++
template <class T>
constexpr T viscosity = 0.4;

template <class T>
constexpr space_vector<T> external_acceleration = { T{}, T{-9.8}, T{} };

auto vis2 = 2*viscosity<double>;
auto acc = external_acceleration<float>;
```

Здесь `space_vector` - это трехмерный вектор.

Достаточно любопытно, что большинство шаблонов переменных кажутся константами. Но с другой стороны, существует и множество переменных. Терминология не соответствует нашим представлениям о неизменности.

Естественно, мы можем использовать произвольные выражения подходящих типов в качестве инициализаторов. Рассмотрим:
```c++
template<typename T, typename T2>
							// is_assignable is a type trait
constexpr bool Assignable = is_assignable<T&,T2>::value; 
			
template<typename T>
void testing()
{
	static_assert(Assignable<T&,double>, "can't assign a double to a T");
	static_assert(Assignable<T&,string>, "can't assign a string to a T");
}
```

После некоторых существенных изменений эта идея стала основой определений [[Concepts|концептов]].

Стандартная библиотека использует шаблоны переменных для предоставления математических констант, таких как `pi` и `log2e` ( #§17_9).

## Псевдонимы

Удивительно часто бывает полезно ввести синоним для типа или шаблона. Например, стандартный заголовок `<cstddef>` содержит определение псевдонима `size_t`, возможно такой:
```c++
using size_t = unsigned int;
```

Фактический тип с именем `size_t` зависит от реализации, поэтому в другой реализации `size_t` может быть `unsigned long`. Наличие псевдонима `size_t` позволяет программисту писать переносимый код.

Очень часто параметризованный тип предоставляет псевдоним для типов, связанных с их аргументами шаблона. Например:
```c++
template<typename T>
class Vector {
	public:
		using value_type = T;

		...
}
```

Фактически, каждый контейнер стандартной библиотеки предоставляет `value_type` в качестве имени типа своих элементов ( #глава_12). Это позволяет нам написать код, который будет работать для любого контейнера, соответствующего этому соглашению. Например:
```c++
template<typename C>
using Value_type = C::value_type; // the type of C's elements

template<typename Container>
void algo(Container& c)
{
	Vector<Value_type<Container>> vec; // keep results here

	...
}
```

Этот `Value_type` является упрощенной версией [[range#range_value_t|range_value_t]] из стандартной библиотеки ( #§16_4_4). Механизм псевдонимов может быть использован для определения нового шаблона путем привязки некоторых или всех аргументов шаблона. Например:
```c++
template<typename Key, typename Value>
class Map {
	...
};

template<typename Value>
using String_map = Map<string, Value>;

String_map<int> m; // m is a Map<string,int>
```

## if времени компиляции

Рассмотрим возможность написания операции, которая может быть реализована с использованием одной из двух функций `slow_and_safe(T)` или `simple_and_fast(T)`. Таких проблем предостаточно в базовом коде, где важны обобщённость и оптимальная производительность. Если задействована иерархия классов, базовый класс может обеспечить общую операцию `slow_and_safe`, а производный класс может переопределить ее с помощью реализации `simple_and_fast`.

В качестве альтернативы, мы можем использовать [[if|if]] времени компиляции:
```c++
template<typename T>
void update(T& target)
{
	...
	
	if constexpr(is_trivially_copyable_v<T>)
		simple_and_fast(target); // for "plain old data"
	else
		slow_and_safe(target); // for more complex types

	 ...
}
```

[[predicate#is_trivially_copyable_v|is_trivially_copyable_v<T>]]  - это предикат типа, который сообщает нам, может ли
тип быть тривиально скопирован. 

Компилятор проходит только выбранную ветвь [[if#if constexpr|if constexpr]]. Это решение обеспечивает оптимальную производительность и локальность оптимизации.

Важно отметить, что[[if#if constexpr|if constexpr]] не является механизмом манипулирования текстом и не может использоваться для нарушения обычных правил грамматики, типа и области видимости. Например, вот наивная и неудачная попытка условно обернуть вызов в блок [[try|try]]:
```c++
template<typename T>
void bad(T arg)
{
	if constexpr(!is_trivially_copyable_v<T>)
		try { // Oops, the if extends beyond this line
			g(arg);
			
			if constexpr(!is_trivially_copyable_v<T>)
		} catch(...) {  ...  } // syntax error
}
```

Разрешение таких манипуляций с текстом может серьезно ухудшить читаемость кода и создать проблемы для инструментов, использующих современные методы представления программ (такие как “абстрактные синтаксические деревья”).

Множество подобных попыток «хакнуть плюсы» не нужны, поскольку доступны более чистые решения, которые не нарушают правила области видимости. Например:
```c++
template<typename T>
void good(T arg)
{
	if constexpr (is_trivially_copyable_v<T>)
		g(arg);
	else
		try {
			g(arg);
		}
		catch (...) {  ...  }
}
```

