# Полиморфизм на основе виртуальных функций C++11#

Полиморфизм на основе виртуальных функций, называемый также динамическим полиморфизмом, позволяет использовать данные различных типов в общем контексте. Динамический полиморфизм основан на возможности указателя на объект базового класса включать в себя указатель на объект класса-потомка.

В языке С++ программист может переопределить (переписать) функцию базового класса в дочернем классе. Например, в следующих строках кода показана эта возможность:
```c++
#include <iostream>

struct A{
    A() {}
    void print() const { std::cout << "A"; }
};

struct B:public A{
    B(){}
    void print() const { std::cout << "B"; }
};

int main(){
     A* obj = new B;
     obj->print();
     
     obj = new A;
     obj->print();
     
     return 0; 
}
```

Однако, ожидаемый результат не будет достигнут - на экране в обоих случаях будет напечатана буква A, а не B. Это связано с тем, что компилятор не может определить, какого типа является объект, находящийся в переменной obj, поэтому вызывается функция родительского объекта. Данная проблема может быть решена при помощи виртуальных функций. В случае использования виртуальных функций компилятор гарантирует вызов своего варианта функции для каждого объекта класса из иерархии.
```c++
#include <сstdio>

struct A{
     A() {}
     virtual void print() const { puts("A"); }
};

struct B:public A{
     B(){}
     virtual void print() const { puts("B"); }
};

int main(){
     A* obj = new B;
     obj->print();
     
     obj = new A;
     obj->print();
     
     return 0;
}
```

В примере мы получим желаемый результат: на экране будет напечатано "BA".

Данное свойство может быть использовано при реализации полиморфизма - возможности использования одной и той же функции (одного и того же имени функции) с различными типами параметров. Пример динамического полиморфизма с классами из показан в листинге:
```c++
#include <сstdio>
​
struct A{
     A() {}
     virtual void print() const { puts("A"); }
};
​
struct B:public A{
     B(){}
     virtual void print() const { puts("B"); }
};

void print(A* a){
     a->Print();
 }

int main(){
     A* obj = new B;
     print(obj);
     
     return 0;
 }
```